{"files":[{"patch":"@@ -8,0 +8,1 @@\n+warning=issuestitle,binary\n","filename":".jcheck\/conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-# These are needed for deterministic classlist:\n+# To make the classlist deterministic:\n@@ -67,2 +67,4 @@\n-# - Run with -Xint, as the compiler can speculatively resolve constant pool entries.\n-# - ForkJoinPool parallelism can cause constant pool resolution to be non-deterministic.\n+# - Concurrency in the core libraries can cause constant pool resolution\n+#   to be non-deterministic. Since the benefits of resolved CP references in the\n+#   default classlist is minimal, let's filter out the '@cp' lines until we can\n+#   find a proper solution.\n@@ -70,3 +72,1 @@\n-    -Duser.language=en -Duser.country=US \\\n-    -Xint \\\n-    -Djava.util.concurrent.ForkJoinPool.common.parallelism=0\n+    -Duser.language=en -Duser.country=US\n@@ -104,0 +104,1 @@\n+\t$(GREP) -v @cp $@.raw.3 > $@.raw.4\n@@ -106,1 +107,1 @@\n-\t    build.tools.classlist.SortClasslist $@.raw.3 > $@\n+\t    build.tools.classlist.SortClasslist $@.raw.4 > $@\n","filename":"make\/GenerateLinkOptData.gmk","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-    COMPATIBLE_CDS_ALIGNMENT_DEFAULT=true\n+    COMPATIBLE_CDS_ALIGNMENT_DEFAULT=auto\n@@ -202,1 +202,0 @@\n-  AC_SUBST(COMPATIBLE_CDS_ALIGNMENT_DEFAULT)\n@@ -441,0 +440,9 @@\n+          # detect_stack_use_after_return causes ASAN to offload stack-local\n+          # variables to c-heap and therefore breaks assumptions in hotspot\n+          # that rely on data (e.g. Marks) living in thread stacks.\n+          if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\"; then\n+            ASAN_CFLAGS=\"$ASAN_CFLAGS --param asan-use-after-return=0\"\n+          fi\n+          if test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n+            ASAN_CFLAGS=\"$ASAN_CFLAGS -fsanitize-address-use-after-return=never\"\n+          fi\n@@ -447,0 +455,2 @@\n+          # -fsanitize-address-use-after-return is off by default in MS Visual Studio 22 (19.37.32824).\n+          # cl : Command line warning D9002 : ignoring unknown option '-fno-sanitize-address-use-after-return'\n@@ -499,0 +509,5 @@\n+  UTIL_ARG_WITH(NAME: additional-ubsan-checks, TYPE: string,\n+      DEFAULT: [],\n+      DESC: [Customizes the ubsan checks],\n+      OPTIONAL: true)\n+\n@@ -501,1 +516,2 @@\n-  UBSAN_CHECKS=\"-fsanitize=undefined -fsanitize=float-divide-by-zero -fno-sanitize=shift-base -fno-sanitize=alignment\"\n+  UBSAN_CHECKS=\"-fsanitize=undefined -fsanitize=float-divide-by-zero -fno-sanitize=shift-base -fno-sanitize=alignment \\\n+      $ADDITIONAL_UBSAN_CHECKS\"\n@@ -669,1 +685,1 @@\n-      DEFAULT_DESC: [disabled],\n+      DEFAULT_DESC: [disabled except on linux-aarch64],\n","filename":"make\/autoconf\/jdk-options.m4","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -781,1 +781,1 @@\n-        result.appendLine(\"protected int mult(long[] a, long[] b, long[] r) {\");\n+        result.appendLine(\"protected void mult(long[] a, long[] b, long[] r) {\");\n@@ -807,3 +807,0 @@\n-        result.appendIndent();\n-        result.append(\"return 0;\");\n-        result.appendLine();\n@@ -839,1 +836,1 @@\n-        result.appendLine(\"protected int square(long[] a, long[] r) {\");\n+        result.appendLine(\"protected void square(long[] a, long[] r) {\");\n@@ -880,3 +877,0 @@\n-        result.appendIndent();\n-        result.append(\"return 0;\");\n-        result.appendLine();\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3432,0 +3432,1 @@\n+    call->_has_ea_local_in_scope = _has_ea_local_in_scope;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3802,1 +3802,1 @@\n-    bge(r_array_length, r_array_index, skip);\n+    blt(r_array_index, r_array_length, skip);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-reg_def V1    ( SOC, SOC, Op_VecA, 1,  v1->as_VMReg() \t        );\n+reg_def V1    ( SOC, SOC, Op_VecA, 1,  v1->as_VMReg()           );\n@@ -265,1 +265,1 @@\n-reg_def V5    ( SOC, SOC, Op_VecA, 5,  v5->as_VMReg() \t        );\n+reg_def V5    ( SOC, SOC, Op_VecA, 5,  v5->as_VMReg()           );\n@@ -275,1 +275,1 @@\n-reg_def V7    ( SOC, SOC, Op_VecA, 7,  v7->as_VMReg() \t        );\n+reg_def V7    ( SOC, SOC, Op_VecA, 7,  v7->as_VMReg()           );\n@@ -1919,0 +1919,2 @@\n+    case Op_ReverseBytesS:\n+    case Op_ReverseBytesUS:\n@@ -7869,29 +7871,0 @@\n-\/\/ ============================================================================\n-\/\/ BSWAP Instructions\n-\n-instruct bytes_reverse_unsigned_short(iRegINoSp dst, iRegIorL2I src) %{\n-  match(Set dst (ReverseBytesUS src));\n-\n-  ins_cost(ALU_COST * 5);\n-  format %{ \"revb_h_h_u  $dst, $src\\t#@bytes_reverse_unsigned_short\" %}\n-\n-  ins_encode %{\n-    __ revb_h_h_u(as_Register($dst$$reg), as_Register($src$$reg));\n-  %}\n-\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct bytes_reverse_short(iRegINoSp dst, iRegIorL2I src) %{\n-  match(Set dst (ReverseBytesS src));\n-\n-  ins_cost(ALU_COST * 5);\n-  format %{ \"revb_h_h  $dst, $src\\t#@bytes_reverse_short\" %}\n-\n-  ins_encode %{\n-    __ revb_h_h(as_Register($dst$$reg), as_Register($src$$reg));\n-  %}\n-\n-  ins_pipe(pipe_class_default);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":5,"deletions":32,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -209,1 +209,0 @@\n-  predicate(UseZbb);\n@@ -216,0 +215,1 @@\n+    assert(UseZbb, \"must be\");\n@@ -223,1 +223,0 @@\n-  predicate(UseZbb);\n@@ -230,0 +229,1 @@\n+    assert(UseZbb, \"must be\");\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_b.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -330,8 +330,3 @@\n-    if (FLAG_IS_DEFAULT(MaxVectorSize)) {\n-      MaxVectorSize = _initial_vector_length;\n-    } else if (!is_power_of_2(MaxVectorSize)) {\n-      vm_exit_during_initialization(err_msg(\"Unsupported MaxVectorSize: %d, must be a power of 2\", (int)MaxVectorSize));\n-    } else if (MaxVectorSize > _initial_vector_length) {\n-      warning(\"Current system only supports max RVV vector length %d. Set MaxVectorSize to %d\",\n-              _initial_vector_length, _initial_vector_length);\n-      MaxVectorSize = _initial_vector_length;\n+    if (!FLAG_IS_DEFAULT(MaxVectorSize) && MaxVectorSize != _initial_vector_length) {\n+      warning(\"Current system does not support RVV vector length for MaxVectorSize %d. Set MaxVectorSize to %d\",\n+               (int)MaxVectorSize, _initial_vector_length);\n@@ -339,0 +334,1 @@\n+    MaxVectorSize = _initial_vector_length;\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-  \/\/ Load object header.\n-  z_lg(Rmark, Address(Roop, hdr_offset));\n-\n@@ -88,0 +85,4 @@\n+\n+    \/\/ Load object header.\n+    z_lg(Rmark, Address(Roop, hdr_offset));\n+\n@@ -144,6 +145,1 @@\n-    const Register tmp = Z_R1_scratch;\n-    z_lg(Rmark, Address(Roop, hdr_offset));\n-    z_lgr(tmp, Rmark);\n-    z_nill(tmp, markWord::monitor_value);\n-    branch_optimized(Assembler::bcondNotZero, slow_case);\n-    lightweight_unlock(Roop, Rmark, tmp, slow_case);\n+    lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024 SAP SE. All rights reserved.\n@@ -36,0 +36,9 @@\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register temp1, Register temp2) {\n+  compiler_fast_lock_lightweight_object(obj, temp1, temp2);\n+}\n+\n+\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box, Register temp1, Register temp2) {\n+  compiler_fast_unlock_lightweight_object(obj, temp1, temp2);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024 SAP SE. All rights reserved.\n@@ -32,0 +32,4 @@\n+  \/\/ Code used by cmpFastLockLightweight and cmpFastUnlockLightweight mach instructions in s390.ad file.\n+  void fast_lock_lightweight(Register obj, Register box, Register temp1, Register temp2);\n+  void fast_unlock_lightweight(Register obj, Register box, Register temp1, Register temp2);\n+\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1008,3 +1008,0 @@\n-  \/\/ Load markWord from object into header.\n-  z_lg(header, hdr_offset, object);\n-\n@@ -1018,1 +1015,1 @@\n-    lightweight_lock(object, \/* mark word *\/ header, tmp, slow_case);\n+    lightweight_lock(object, header, tmp, slow_case);\n@@ -1021,0 +1018,3 @@\n+    \/\/ Load markWord from object into header.\n+    z_lg(header, hdr_offset, object);\n+\n@@ -1156,18 +1156,0 @@\n-    \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n-    \/\/ must handle it.\n-\n-    Register tmp = current_header;\n-\n-    \/\/ First check for lock-stack underflow.\n-    z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-    compareU32_and_branch(tmp, (unsigned)LockStack::start_offset(), Assembler::bcondNotHigh, slow_case);\n-\n-    \/\/ Then check if the top of the lock-stack matches the unlocked object.\n-    z_aghi(tmp, -oopSize);\n-    z_lg(tmp, Address(Z_thread, tmp));\n-    compare64_and_branch(tmp, object, Assembler::bcondNotEqual, slow_case);\n-\n-    z_lg(header, Address(object, hdr_offset));\n-    z_lgr(tmp, header);\n-    z_nill(tmp, markWord::monitor_value);\n-    z_brne(slow_case);\n@@ -1175,1 +1157,1 @@\n-    lightweight_unlock(object, header, tmp, slow_case);\n+    lightweight_unlock(object, header, current_header, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3193,0 +3193,1 @@\n+\/\/ \"The box\" is the space on the stack where we copy the object mark.\n@@ -3194,0 +3195,4 @@\n+\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_lock_lightweight\");\n+  assert_different_registers(oop, box, temp1, temp2);\n+\n@@ -3195,2 +3200,3 @@\n-  Register currentHeader = temp1;\n-  Register temp = temp2;\n+  Register currentHeader   = temp1;\n+  Register temp            = temp2;\n+\n@@ -3201,2 +3207,0 @@\n-  assert_different_registers(temp1, temp2, oop, box);\n-\n@@ -3210,2 +3214,4 @@\n-    testbit(Address(temp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n-    z_btrue(done);\n+    z_l(temp, Address(temp, Klass::access_flags_offset()));\n+    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n+    z_nilh(temp, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_brne(done);\n@@ -3225,1 +3231,2 @@\n-  } else if (LockingMode == LM_LEGACY) {\n+  } else {\n+    assert(LockingMode == LM_LEGACY, \"must be\");\n@@ -3254,4 +3261,0 @@\n-    z_bru(done);\n-  } else {\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-    lightweight_lock(oop, displacedHeader, temp, done);\n@@ -3273,4 +3276,3 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Store a non-null value into the box.\n-    z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-  }\n+\n+  \/\/ Store a non-null value into the box.\n+  z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n@@ -3298,0 +3300,4 @@\n+\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_unlock_lightweight\");\n+  assert_different_registers(oop, box, temp1, temp2);\n+\n@@ -3299,2 +3305,2 @@\n-  Register currentHeader = temp2;\n-  Register temp = temp1;\n+  Register currentHeader   = temp2;\n+  Register temp            = temp1;\n@@ -3304,2 +3310,0 @@\n-  assert_different_registers(temp1, temp2, oop, box);\n-\n@@ -3329,1 +3333,2 @@\n-  } else if (LockingMode == LM_LEGACY) {\n+  } else {\n+    assert(LockingMode == LM_LEGACY, \"must be\");\n@@ -3336,5 +3341,0 @@\n-  } else {\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-\n-    lightweight_unlock(oop, currentHeader, displacedHeader, done);\n-    z_bru(done);\n@@ -5708,3 +5708,0 @@\n-\/\/ Branches to slow upon failure to lock the object.\n-\/\/ Falls through upon success.\n-\/\/\n@@ -5712,1 +5709,1 @@\n-\/\/  - hdr: the header, already loaded from obj, contents destroyed.\n+\/\/  - temp1, temp2: temporary registers, contents destroyed.\n@@ -5714,1 +5711,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register temp, Label& slow_case) {\n+void MacroAssembler::lightweight_lock(Register obj, Register temp1, Register temp2, Label& slow) {\n@@ -5717,1 +5714,12 @@\n-  assert_different_registers(obj, hdr, temp);\n+  assert_different_registers(obj, temp1, temp2);\n+\n+  Label push;\n+  const Register top           = temp1;\n+  const Register mark          = temp2;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n+\n+  \/\/ Preload the markWord. It is important that this is the first\n+  \/\/ instruction emitted as it is part of C1's null check semantics.\n+  z_lg(mark, Address(obj, mark_offset));\n+\n@@ -5720,1 +5728,1 @@\n-  z_lgf(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n@@ -5722,1 +5730,1 @@\n-  compareU32_and_branch(temp, (unsigned)LockStack::end_offset()-1, bcondHigh, slow_case);\n+  compareU32_and_branch(top, (unsigned)LockStack::end_offset(), bcondNotLow, slow);\n@@ -5724,3 +5732,2 @@\n-  \/\/ attempting a lightweight_lock\n-  \/\/ Load (object->mark() | 1) into hdr\n-  z_oill(hdr, markWord::unlocked_value);\n+  \/\/ The underflow check is elided. The recursive check will always fail\n+  \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n@@ -5728,1 +5735,4 @@\n-  z_lgr(temp, hdr);\n+  \/\/ Check for recursion:\n+  z_aghi(top, -oopSize);\n+  z_cg(obj, Address(Z_thread, top));\n+  z_bre(push);\n@@ -5730,2 +5740,3 @@\n-  \/\/ Clear lock-bits from hdr (locked state)\n-  z_xilf(temp, markWord::unlocked_value);\n+  \/\/ Check header for monitor (0b10).\n+  z_tmll(mark, markWord::monitor_value);\n+  branch_optimized(bcondNotAllZero, slow);\n@@ -5733,2 +5744,9 @@\n-  z_csg(hdr, temp, oopDesc::mark_offset_in_bytes(), obj);\n-  branch_optimized(Assembler::bcondNotEqual, slow_case);\n+  { \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n+    const Register locked_obj = top;\n+    z_oill(mark, markWord::unlocked_value);\n+    z_lgr(locked_obj, mark);\n+    \/\/ Clear lock-bits from locked_obj (locked state)\n+    z_xilf(locked_obj, markWord::unlocked_value);\n+    z_csg(mark, locked_obj, mark_offset, obj);\n+    branch_optimized(Assembler::bcondNotEqual, slow);\n+  }\n@@ -5736,5 +5754,1 @@\n-  \/\/ After successful lock, push object on lock-stack\n-  z_lgf(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-  z_stg(obj, Address(Z_thread, temp));\n-  z_ahi(temp, oopSize);\n-  z_st(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+  bind(push);\n@@ -5742,2 +5756,4 @@\n-  \/\/ as locking was successful, set CC to EQ\n-  z_cr(temp, temp);\n+  \/\/ After successful lock, push object on lock-stack\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n+  z_stg(obj, Address(Z_thread, top));\n+  z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n@@ -5747,3 +5763,0 @@\n-\/\/ Branches to slow upon failure.\n-\/\/ Falls through upon success.\n-\/\/\n@@ -5751,1 +5764,1 @@\n-\/\/ - hdr: the (pre-loaded) header of the object, will be destroyed\n+\/\/ - temp1, temp2: temporary registers, will be destroyed\n@@ -5753,1 +5766,1 @@\n-void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register temp1, Register temp2, Label& slow) {\n@@ -5756,1 +5769,7 @@\n-  assert_different_registers(obj, hdr, tmp);\n+  assert_different_registers(obj, temp1, temp2);\n+\n+  Label unlocked, push_and_slow;\n+  const Register mark          = temp1;\n+  const Register top           = temp2;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n@@ -5759,9 +5778,0 @@\n-  {\n-    \/\/ Check that hdr is lightweight-locked.\n-    Label hdr_ok;\n-    z_lgr(tmp, hdr);\n-    z_nill(tmp, markWord::lock_mask_in_place);\n-    z_bre(hdr_ok);\n-    stop(\"Header is not lightweight-locked\");\n-    bind(hdr_ok);\n-  }\n@@ -5774,3 +5784,3 @@\n-    Label stack_ok;\n-    z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-    compareU32_and_branch(tmp, (unsigned)LockStack::start_offset(), Assembler::bcondHigh, stack_ok);\n+    NearLabel stack_ok;\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    compareU32_and_branch(top, (unsigned)LockStack::start_offset(), bcondNotLow, stack_ok);\n@@ -5780,8 +5790,155 @@\n-  {\n-    \/\/ Check if the top of the lock-stack matches the unlocked object.\n-    Label tos_ok;\n-    z_aghi(tmp, -oopSize);\n-    z_lg(tmp, Address(Z_thread, tmp));\n-    compare64_and_branch(tmp, obj, Assembler::bcondEqual, tos_ok);\n-    stop(\"Top of lock-stack does not match the unlocked object\");\n-    bind(tos_ok);\n+#endif \/\/ ASSERT\n+\n+  \/\/ Check if obj is top of lock-stack.\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n+  z_aghi(top, -oopSize);\n+  z_cg(obj, Address(Z_thread, top));\n+  branch_optimized(bcondNotEqual, slow);\n+\n+  \/\/ pop object from lock-stack\n+#ifdef ASSERT\n+  const Register temp_top = temp1; \/\/ mark is not yet loaded, but be careful\n+  z_agrk(temp_top, top, Z_thread);\n+  z_xc(0, oopSize-1, temp_top, 0, temp_top);  \/\/ wipe out lock-stack entry\n+#endif \/\/ ASSERT\n+  z_alsi(in_bytes(ls_top_offset), Z_thread, -oopSize);  \/\/ pop object\n+\n+  \/\/ The underflow check is elided. The recursive check will always fail\n+  \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n+\n+  \/\/ Check if recursive. (this is a check for the 2nd object on the stack)\n+  z_aghi(top, -oopSize);\n+  z_cg(obj, Address(Z_thread, top));\n+  branch_optimized(bcondEqual, unlocked);\n+\n+  \/\/ Not recursive. Check header for monitor (0b10).\n+  z_lg(mark, Address(obj, mark_offset));\n+  z_tmll(mark, markWord::monitor_value);\n+  z_brnaz(push_and_slow);\n+\n+#ifdef ASSERT\n+  \/\/ Check header not unlocked (0b01).\n+  NearLabel not_unlocked;\n+  z_tmll(mark, markWord::unlocked_value);\n+  z_braz(not_unlocked);\n+  stop(\"lightweight_unlock already unlocked\");\n+  bind(not_unlocked);\n+#endif \/\/ ASSERT\n+\n+  { \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n+    Register unlocked_obj = top;\n+    z_lgr(unlocked_obj, mark);\n+    z_oill(unlocked_obj, markWord::unlocked_value);\n+    z_csg(mark, unlocked_obj, mark_offset, obj);\n+    branch_optimized(Assembler::bcondEqual, unlocked);\n+  }\n+\n+  bind(push_and_slow);\n+\n+  \/\/ Restore lock-stack and handle the unlock in runtime.\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n+  DEBUG_ONLY(z_stg(obj, Address(Z_thread, top));)\n+  z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n+  \/\/ set CC to NE\n+  z_ltgr(obj, obj); \/\/ object shouldn't be null at this point\n+  branch_optimized(bcondAlways, slow);\n+\n+  bind(unlocked);\n+}\n+\n+void MacroAssembler::compiler_fast_lock_lightweight_object(Register obj, Register tmp1, Register tmp2) {\n+  assert_different_registers(obj, tmp1, tmp2);\n+\n+  \/\/ Handle inflated monitor.\n+  NearLabel inflated;\n+  \/\/ Finish fast lock successfully. MUST reach to with flag == NE\n+  NearLabel locked;\n+  \/\/ Finish fast lock unsuccessfully. MUST branch to with flag == EQ\n+  NearLabel slow_path;\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(tmp1, obj);\n+    z_l(tmp1, Address(tmp1, Klass::access_flags_offset()));\n+    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n+    z_nilh(tmp1, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_brne(slow_path);\n+  }\n+\n+  const Register mark          = tmp1;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n+\n+  BLOCK_COMMENT(\"compiler_fast_lightweight_locking {\");\n+  { \/\/ lightweight locking\n+\n+    \/\/ Push lock to the lock stack and finish successfully. MUST reach to with flag == EQ\n+    NearLabel push;\n+\n+    const Register top = tmp2;\n+\n+    \/\/ Check if lock-stack is full.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    compareU32_and_branch(top, (unsigned) LockStack::end_offset() - 1, bcondHigh, slow_path);\n+\n+    \/\/ The underflow check is elided. The recursive check will always fail\n+    \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n+\n+    \/\/ Check if recursive.\n+    z_aghi(top, -oopSize);\n+    z_cg(obj, Address(Z_thread, top));\n+    z_bre(push);\n+\n+    \/\/ Check for monitor (0b10)\n+    z_lg(mark, Address(obj, mark_offset));\n+    z_tmll(mark, markWord::monitor_value);\n+    z_brnaz(inflated);\n+\n+    \/\/ not inflated\n+\n+    { \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n+      assert(mark_offset == 0, \"required to avoid a lea\");\n+      const Register locked_obj = top;\n+      z_oill(mark, markWord::unlocked_value);\n+      z_lgr(locked_obj, mark);\n+      \/\/ Clear lock-bits from locked_obj (locked state)\n+      z_xilf(locked_obj, markWord::unlocked_value);\n+      z_csg(mark, locked_obj, mark_offset, obj);\n+      branch_optimized(Assembler::bcondNotEqual, slow_path);\n+    }\n+\n+    bind(push);\n+\n+    \/\/ After successful lock, push object on lock-stack.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    z_stg(obj, Address(Z_thread, top));\n+    z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n+\n+    z_cgr(obj, obj); \/\/ set the CC to EQ, as it could be changed by alsi\n+    z_bru(locked);\n+  }\n+  BLOCK_COMMENT(\"} compiler_fast_lightweight_locking\");\n+\n+  BLOCK_COMMENT(\"handle_inflated_monitor_lightweight_locking {\");\n+  { \/\/ Handle inflated monitor.\n+    bind(inflated);\n+\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register tagged_monitor = mark;\n+    const Register zero           = tmp2;\n+\n+    \/\/ Try to CAS m->owner from null to current thread.\n+    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+    \/\/ Otherwise, register zero is filled with the current owner.\n+    z_lghi(zero, 0);\n+    z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n+    z_bre(locked);\n+\n+    \/\/ Check if recursive.\n+    z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n+    z_brne(slow_path);\n+\n+    \/\/ Recursive\n+    z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+    z_cgr(zero, zero);\n+    \/\/ z_bru(locked);\n+    \/\/ Uncomment above line in the future, for now jump address is right next to us.\n@@ -5789,0 +5946,18 @@\n+  BLOCK_COMMENT(\"} handle_inflated_monitor_lightweight_locking\");\n+\n+  bind(locked);\n+\n+#ifdef ASSERT\n+  \/\/ Check that locked label is reached with flag == EQ.\n+  NearLabel flag_correct;\n+  z_bre(flag_correct);\n+  stop(\"CC is not set to EQ, it should be - lock\");\n+#endif \/\/ ASSERT\n+\n+  bind(slow_path);\n+\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with flag == NE.\n+  z_brne(flag_correct);\n+  stop(\"CC is not set to NE, it should be - lock\");\n+  bind(flag_correct);\n@@ -5791,4 +5966,5 @@\n-  z_lgr(tmp, hdr);\n-  z_oill(tmp, markWord::unlocked_value);\n-  z_csg(hdr, tmp, oopDesc::mark_offset_in_bytes(), obj);\n-  branch_optimized(Assembler::bcondNotEqual, slow);\n+  \/\/ C2 uses the value of flag (NE vs EQ) to determine the continuation.\n+}\n+\n+void MacroAssembler::compiler_fast_unlock_lightweight_object(Register obj, Register tmp1, Register tmp2) {\n+  assert_different_registers(obj, tmp1, tmp2);\n@@ -5796,1 +5972,23 @@\n-  \/\/ After successful unlock, pop object from lock-stack\n+  \/\/ Handle inflated monitor.\n+  NearLabel inflated, inflated_load_monitor;\n+  \/\/ Finish fast unlock successfully. MUST reach to with flag == EQ.\n+  NearLabel unlocked;\n+  \/\/ Finish fast unlock unsuccessfully. MUST branch to with flag == NE.\n+  NearLabel slow_path;\n+\n+  const Register mark          = tmp1;\n+  const Register top           = tmp2;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n+\n+  BLOCK_COMMENT(\"compiler_fast_lightweight_unlock {\");\n+  { \/\/ Lightweight Unlock\n+\n+    \/\/ Check if obj is top of lock-stack.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+\n+    z_aghi(top, -oopSize);\n+    z_cg(obj, Address(Z_thread, top));\n+    branch_optimized(bcondNotEqual, inflated_load_monitor);\n+\n+    \/\/ Pop lock-stack.\n@@ -5798,4 +5996,3 @@\n-  z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-  z_aghi(tmp, -oopSize);\n-  z_agr(tmp, Z_thread);\n-  z_xc(0, oopSize-1, tmp, 0, tmp);  \/\/ wipe out lock-stack entry\n+    const Register temp_top = tmp1; \/\/ let's not kill top here, we can use for recursive check\n+    z_agrk(temp_top, top, Z_thread);\n+    z_xc(0, oopSize-1, temp_top, 0, temp_top);  \/\/ wipe out lock-stack entry\n@@ -5803,2 +6000,128 @@\n-  z_alsi(in_bytes(JavaThread::lock_stack_top_offset()), Z_thread, -oopSize);  \/\/ pop object\n-  z_cr(tmp, tmp); \/\/ set CC to EQ\n+    z_alsi(in_bytes(ls_top_offset), Z_thread, -oopSize);  \/\/ pop object\n+\n+    \/\/ The underflow check is elided. The recursive check will always fail\n+    \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n+\n+    \/\/ Check if recursive.\n+    z_aghi(top, -oopSize);\n+    z_cg(obj, Address(Z_thread, top));\n+    z_bre(unlocked);\n+\n+    \/\/ Not recursive\n+\n+    \/\/ Check for monitor (0b10).\n+    z_lg(mark, Address(obj, mark_offset));\n+    z_tmll(mark, markWord::monitor_value);\n+    z_brnaz(inflated);\n+\n+#ifdef ASSERT\n+    \/\/ Check header not unlocked (0b01).\n+    NearLabel not_unlocked;\n+    z_tmll(mark, markWord::unlocked_value);\n+    z_braz(not_unlocked);\n+    stop(\"lightweight_unlock already unlocked\");\n+    bind(not_unlocked);\n+#endif \/\/ ASSERT\n+\n+    { \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n+      Register unlocked_obj = top;\n+      z_lgr(unlocked_obj, mark);\n+      z_oill(unlocked_obj, markWord::unlocked_value);\n+      z_csg(mark, unlocked_obj, mark_offset, obj);\n+      branch_optimized(Assembler::bcondEqual, unlocked);\n+    }\n+\n+    \/\/ Restore lock-stack and handle the unlock in runtime.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    DEBUG_ONLY(z_stg(obj, Address(Z_thread, top));)\n+    z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n+    \/\/ set CC to NE\n+    z_ltgr(obj, obj); \/\/ object is not null here\n+    z_bru(slow_path);\n+  }\n+  BLOCK_COMMENT(\"} compiler_fast_lightweight_unlock\");\n+\n+  { \/\/ Handle inflated monitor.\n+\n+    bind(inflated_load_monitor);\n+\n+    z_lg(mark, Address(obj, mark_offset));\n+\n+#ifdef ASSERT\n+    z_tmll(mark, markWord::monitor_value);\n+    z_brnaz(inflated);\n+    stop(\"Fast Unlock not monitor\");\n+#endif \/\/ ASSERT\n+\n+    bind(inflated);\n+\n+#ifdef ASSERT\n+    NearLabel check_done, loop;\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    bind(loop);\n+    z_aghi(top, -oopSize);\n+    compareU32_and_branch(top, in_bytes(JavaThread::lock_stack_base_offset()),\n+                          bcondLow, check_done);\n+    z_cg(obj, Address(Z_thread, top));\n+    z_brne(loop);\n+    stop(\"Fast Unlock lock on stack\");\n+    bind(check_done);\n+#endif \/\/ ASSERT\n+\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register monitor = mark;\n+\n+    NearLabel not_recursive;\n+    const Register recursions = tmp2;\n+\n+    \/\/ Check if recursive.\n+    load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+\n+    \/\/ Recursive unlock\n+    z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+    z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n+    z_bru(unlocked);\n+\n+    bind(not_recursive);\n+\n+    NearLabel not_ok;\n+    \/\/ Check if the entry lists are empty.\n+    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+    z_brne(not_ok);\n+    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+    z_brne(not_ok);\n+\n+    z_release();\n+    z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+\n+    z_bru(unlocked); \/\/ CC = EQ here\n+\n+    bind(not_ok);\n+\n+    \/\/ The owner may be anonymous, and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+    z_bru(slow_path); \/\/ CC = NE here\n+  }\n+\n+  bind(unlocked);\n+\n+#ifdef ASSERT\n+  \/\/ Check that unlocked label is reached with flag == EQ.\n+  NearLabel flag_correct;\n+  z_bre(flag_correct);\n+  stop(\"CC is not set to EQ, it should be - unlock\");\n+#endif \/\/ ASSERT\n+\n+  bind(slow_path);\n+\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with flag == NE.\n+  z_brne(flag_correct);\n+  stop(\"CC is not set to NE, it should be - unlock\");\n+  bind(flag_correct);\n+#endif \/\/ ASSERT\n+\n+  \/\/ C2 uses the value of flag (NE vs EQ) to determine the continuation.\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":408,"deletions":85,"binary":false,"changes":493,"status":"modified"},{"patch":"@@ -730,2 +730,4 @@\n-  void lightweight_lock(Register obj, Register hdr, Register tmp, Label& slow);\n-  void lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow);\n+  void lightweight_lock(Register obj, Register tmp1, Register tmp2, Label& slow);\n+  void lightweight_unlock(Register obj, Register tmp1, Register tmp2, Label& slow);\n+  void compiler_fast_lock_lightweight_object(Register obj, Register tmp1, Register tmp2);\n+  void compiler_fast_unlock_lightweight_object(Register obj, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -9582,0 +9582,1 @@\n+  predicate(LockingMode != LM_LIGHTWEIGHT);\n@@ -9592,0 +9593,1 @@\n+  predicate(LockingMode != LM_LIGHTWEIGHT);\n@@ -9601,0 +9603,32 @@\n+instruct cmpFastLockLightweight(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n+  predicate(LockingMode == LM_LIGHTWEIGHT);\n+  match(Set pcc (FastLock oop box));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  ins_cost(100);\n+  \/\/ TODO: s390 port size(VARIABLE_SIZE);\n+  format %{ \"FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n+  ins_encode %{\n+    __ fast_lock_lightweight($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    \/\/ If locking was successful, cc should indicate 'EQ'.\n+    \/\/ The compiler generates a branch to the runtime call to\n+    \/\/ _complete_monitor_locking_Java for the case where cc is 'NE'.\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct cmpFastUnlockLightweight(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n+  predicate(LockingMode == LM_LIGHTWEIGHT);\n+  match(Set pcc (FastUnlock oop box));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  ins_cost(100);\n+  \/\/ TODO: s390 port size(FIXED_SIZE);\n+  format %{ \"FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n+  ins_encode %{\n+    __ fast_unlock_lightweight($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    \/\/ If unlocking was successful, cc should indicate 'EQ'.\n+    \/\/ The compiler generates a branch to the runtime call to\n+    \/\/ _complete_monitor_unlocking_Java for the case where cc is 'NE'.\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1714,2 +1714,7 @@\n-    \/\/ Fast_lock kills r_temp_1, r_temp_2.\n-    __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n+      __ compiler_fast_lock_lightweight_object(r_oop, r_tmp1, r_tmp2);\n+    } else {\n+      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n+      __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    }\n@@ -1913,2 +1918,7 @@\n-    \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n-    __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n+      __ compiler_fast_unlock_lightweight_object(r_oop, r_tmp1, r_tmp2);\n+    } else {\n+      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n+      __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -416,0 +416,2 @@\n+  constexpr static bool supports_recursive_lightweight_locking() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,0 +223,1 @@\n+#if INCLUDE_ZGC\n@@ -244,0 +245,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5145,1 +5145,1 @@\n-  ExternalAddress buffer((address) b);\n+  AddressLiteral buffer((address) b, external_word_Relocation::spec_for_immediate());\n@@ -5215,1 +5215,1 @@\n-  ExternalAddress buffer((address) b);\n+  AddressLiteral buffer((address) b, external_word_Relocation::spec_for_immediate());\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -252,1 +252,0 @@\n-  __ mov64(rax, 0x1); \/\/ Return 1 (Fig. 5, Step 6 [1] skipped in montgomeryMultiply)\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3528,75 +3528,0 @@\n-bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n-  int mincore_return_value;\n-  const size_t stripe = 1024;  \/\/ query this many pages each time\n-  unsigned char vec[stripe + 1];\n-  \/\/ set a guard\n-  vec[stripe] = 'X';\n-\n-  const size_t page_sz = os::vm_page_size();\n-  uintx pages = size \/ page_sz;\n-\n-  assert(is_aligned(start, page_sz), \"Start address must be page aligned\");\n-  assert(is_aligned(size, page_sz), \"Size must be page aligned\");\n-\n-  committed_start = nullptr;\n-\n-  int loops = checked_cast<int>((pages + stripe - 1) \/ stripe);\n-  int committed_pages = 0;\n-  address loop_base = start;\n-  bool found_range = false;\n-\n-  for (int index = 0; index < loops && !found_range; index ++) {\n-    assert(pages > 0, \"Nothing to do\");\n-    uintx pages_to_query = (pages >= stripe) ? stripe : pages;\n-    pages -= pages_to_query;\n-\n-    \/\/ Get stable read\n-    while ((mincore_return_value = mincore(loop_base, pages_to_query * page_sz, vec)) == -1 && errno == EAGAIN);\n-\n-    \/\/ During shutdown, some memory goes away without properly notifying NMT,\n-    \/\/ E.g. ConcurrentGCThread\/WatcherThread can exit without deleting thread object.\n-    \/\/ Bailout and return as not committed for now.\n-    if (mincore_return_value == -1 && errno == ENOMEM) {\n-      return false;\n-    }\n-\n-    \/\/ If mincore is not supported.\n-    if (mincore_return_value == -1 && errno == ENOSYS) {\n-      return false;\n-    }\n-\n-    assert(vec[stripe] == 'X', \"overflow guard\");\n-    assert(mincore_return_value == 0, \"Range must be valid\");\n-    \/\/ Process this stripe\n-    for (uintx vecIdx = 0; vecIdx < pages_to_query; vecIdx ++) {\n-      if ((vec[vecIdx] & 0x01) == 0) { \/\/ not committed\n-        \/\/ End of current contiguous region\n-        if (committed_start != nullptr) {\n-          found_range = true;\n-          break;\n-        }\n-      } else { \/\/ committed\n-        \/\/ Start of region\n-        if (committed_start == nullptr) {\n-          committed_start = loop_base + page_sz * vecIdx;\n-        }\n-        committed_pages ++;\n-      }\n-    }\n-\n-    loop_base += pages_to_query * page_sz;\n-  }\n-\n-  if (committed_start != nullptr) {\n-    assert(committed_pages > 0, \"Must have committed region\");\n-    assert(committed_pages <= int(size \/ page_sz), \"Can not commit more than it has\");\n-    assert(committed_start >= start && committed_start < start + size, \"Out of range\");\n-    committed_size = page_sz * committed_pages;\n-    return true;\n-  } else {\n-    assert(committed_pages == 0, \"Should not have committed region\");\n-    return false;\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -96,0 +96,3 @@\n+\/* Input\/Output types for mincore(2) *\/\n+typedef LINUX_ONLY(unsigned) char mincore_vec_t;\n+\n@@ -149,0 +152,88 @@\n+bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n+\n+#ifdef _AIX\n+  committed_start = start;\n+  committed_size = size;\n+  return true;\n+#else\n+\n+  int mincore_return_value;\n+  constexpr size_t stripe = 1024;  \/\/ query this many pages each time\n+  mincore_vec_t vec [stripe + 1];\n+\n+  \/\/ set a guard\n+  DEBUG_ONLY(vec[stripe] = 'X');\n+\n+  size_t page_sz = os::vm_page_size();\n+  uintx pages = size \/ page_sz;\n+\n+  assert(is_aligned(start, page_sz), \"Start address must be page aligned\");\n+  assert(is_aligned(size, page_sz), \"Size must be page aligned\");\n+\n+  committed_start = nullptr;\n+\n+  int loops = checked_cast<int>((pages + stripe - 1) \/ stripe);\n+  int committed_pages = 0;\n+  address loop_base = start;\n+  bool found_range = false;\n+\n+  for (int index = 0; index < loops && !found_range; index ++) {\n+    assert(pages > 0, \"Nothing to do\");\n+    uintx pages_to_query = (pages >= stripe) ? stripe : pages;\n+    pages -= pages_to_query;\n+\n+    \/\/ Get stable read\n+    int fail_count = 0;\n+    while ((mincore_return_value = mincore(loop_base, pages_to_query * page_sz, vec)) == -1 && errno == EAGAIN){\n+      if (++fail_count == 1000){\n+        return false;\n+      }\n+    }\n+\n+    \/\/ During shutdown, some memory goes away without properly notifying NMT,\n+    \/\/ E.g. ConcurrentGCThread\/WatcherThread can exit without deleting thread object.\n+    \/\/ Bailout and return as not committed for now.\n+    if (mincore_return_value == -1 && errno == ENOMEM) {\n+      return false;\n+    }\n+\n+    \/\/ If mincore is not supported.\n+    if (mincore_return_value == -1 && errno == ENOSYS) {\n+      return false;\n+    }\n+\n+    assert(vec[stripe] == 'X', \"overflow guard\");\n+    assert(mincore_return_value == 0, \"Range must be valid\");\n+    \/\/ Process this stripe\n+    for (uintx vecIdx = 0; vecIdx < pages_to_query; vecIdx ++) {\n+      if ((vec[vecIdx] & 0x01) == 0) { \/\/ not committed\n+        \/\/ End of current contiguous region\n+        if (committed_start != nullptr) {\n+          found_range = true;\n+          break;\n+        }\n+      } else { \/\/ committed\n+        \/\/ Start of region\n+        if (committed_start == nullptr) {\n+          committed_start = loop_base + page_sz * vecIdx;\n+        }\n+        committed_pages ++;\n+      }\n+    }\n+\n+    loop_base += pages_to_query * page_sz;\n+  }\n+\n+  if (committed_start != nullptr) {\n+    assert(committed_pages > 0, \"Must have committed region\");\n+    assert(committed_pages <= int(size \/ page_sz), \"Can not commit more than it has\");\n+    assert(committed_start >= start && committed_start < start + size, \"Out of range\");\n+    committed_size = page_sz * committed_pages;\n+    return true;\n+  } else {\n+    assert(committed_pages == 0, \"Should not have committed region\");\n+    return false;\n+  }\n+#endif\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -1415,7 +1415,0 @@\n-\n-\n-#ifndef PRODUCT\n-void ArchiveBuilder::assert_is_vm_thread() {\n-  assert(Thread::current()->is_VM_thread(), \"ArchiveBuilder should be used only inside the VMThread\");\n-}\n-#endif\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -346,2 +346,0 @@\n-  static void assert_is_vm_thread() PRODUCT_RETURN;\n-\n@@ -435,1 +433,0 @@\n-    assert_is_vm_thread();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -833,0 +833,2 @@\n+    case JVM_CONSTANT_Methodref:\n+    case JVM_CONSTANT_InterfaceMethodref:\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -261,3 +261,1 @@\n-        if (rfe->is_resolved(Bytecodes::_getstatic) ||\n-            rfe->is_resolved(Bytecodes::_putstatic) ||\n-            rfe->is_resolved(Bytecodes::_getfield) ||\n+        if (rfe->is_resolved(Bytecodes::_getfield) ||\n@@ -270,0 +268,13 @@\n+\n+    Array<ResolvedMethodEntry>* method_entries = cp->cache()->resolved_method_entries();\n+    if (method_entries != nullptr) {\n+      for (int i = 0; i < method_entries->length(); i++) {\n+        ResolvedMethodEntry* rme = method_entries->adr_at(i);\n+        if (rme->is_resolved(Bytecodes::_invokevirtual) ||\n+            rme->is_resolved(Bytecodes::_invokespecial) ||\n+            rme->is_resolved(Bytecodes::_invokeinterface)) {\n+          list.at_put(rme->constant_pool_index(), true);\n+          print = true;\n+        }\n+      }\n+    }\n@@ -279,1 +290,3 @@\n-               cp_tag.value() == JVM_CONSTANT_Fieldref, \"sanity\");\n+               cp_tag.value() == JVM_CONSTANT_Fieldref ||\n+               cp_tag.value() == JVM_CONSTANT_Methodref||\n+               cp_tag.value() == JVM_CONSTANT_InterfaceMethodref, \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -92,1 +92,3 @@\n-  } else if (cp->tag_at(cp_index).is_field()) {\n+  } else if (cp->tag_at(cp_index).is_field() ||\n+             cp->tag_at(cp_index).is_method() ||\n+             cp->tag_at(cp_index).is_interface_method()) {\n@@ -266,0 +268,8 @@\n+      case Bytecodes::_invokespecial:\n+      case Bytecodes::_invokevirtual:\n+      case Bytecodes::_invokeinterface:\n+        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+        }\n+        break;\n@@ -304,0 +314,6 @@\n+  case Bytecodes::_invokevirtual:\n+  case Bytecodes::_invokespecial:\n+  case Bytecodes::_invokeinterface:\n+    InterpreterRuntime::cds_resolve_invoke(bc, raw_index, cp, CHECK);\n+    break;\n+\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -113,0 +113,4 @@\n+  msg.info(\"Method CP entries = %6d, archived = %6d (%5.1f%%), reverted = %6d\",\n+           _num_method_cp_entries, _num_method_cp_entries_archived,\n+           percent_of(_num_method_cp_entries_archived, _num_method_cp_entries),\n+           _num_method_cp_entries_reverted);\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+  int _num_method_cp_entries;\n+  int _num_method_cp_entries_archived;\n+  int _num_method_cp_entries_reverted;\n@@ -87,0 +90,3 @@\n+    _num_method_cp_entries          = 0;\n+    _num_method_cp_entries_archived = 0;\n+    _num_method_cp_entries_reverted = 0;\n@@ -125,0 +131,6 @@\n+  void record_method_cp_entry(bool archived, bool reverted) {\n+    _num_method_cp_entries ++;\n+    _num_method_cp_entries_archived += archived ? 1 : 0;\n+    _num_method_cp_entries_reverted += reverted ? 1 : 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1409,1 +1409,2 @@\n-    MetaspaceShared::unrecoverable_writing_error();\n+    MetaspaceShared::writing_error();\n+    return;\n@@ -1662,1 +1663,1 @@\n-    MetaspaceShared::unrecoverable_writing_error(\"Unable to write to shared archive file.\");\n+    MetaspaceShared::writing_error(\"Unable to write to shared archive file.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -447,0 +447,2 @@\n+  FileMapInfo* _map_info;\n+  StaticArchiveBuilder& _builder;\n@@ -457,1 +459,2 @@\n-  VM_PopulateDumpSharedSpace() : VM_Operation(), _heap_info() {}\n+  VM_PopulateDumpSharedSpace(StaticArchiveBuilder& b) :\n+    VM_Operation(), _heap_info(), _map_info(nullptr), _builder(b) {}\n@@ -462,0 +465,2 @@\n+  ArchiveHeapInfo* heap_info()  { return &_heap_info; }\n+  FileMapInfo* map_info() const { return _map_info; }\n@@ -518,3 +523,2 @@\n-  StaticArchiveBuilder builder;\n-  builder.gather_source_objs();\n-  builder.reserve_buffer();\n+  _builder.gather_source_objs();\n+  _builder.reserve_buffer();\n@@ -522,1 +526,1 @@\n-  CppVtables::dumptime_init(&builder);\n+  CppVtables::dumptime_init(&_builder);\n@@ -524,4 +528,4 @@\n-  builder.sort_metadata_objs();\n-  builder.dump_rw_metadata();\n-  builder.dump_ro_metadata();\n-  builder.relocate_metaspaceobj_embedded_pointers();\n+  _builder.sort_metadata_objs();\n+  _builder.dump_rw_metadata();\n+  _builder.dump_ro_metadata();\n+  _builder.relocate_metaspaceobj_embedded_pointers();\n@@ -529,2 +533,2 @@\n-  dump_java_heap_objects(builder.klasses());\n-  dump_shared_symbol_table(builder.symbols());\n+  dump_java_heap_objects(_builder.klasses());\n+  dump_shared_symbol_table(_builder.symbols());\n@@ -533,1 +537,1 @@\n-  builder.make_klasses_shareable();\n+  _builder.make_klasses_shareable();\n@@ -543,4 +547,0 @@\n-  \/\/ relocate the data so that it can be mapped to MetaspaceShared::requested_base_address()\n-  \/\/ without runtime relocation.\n-  builder.relocate_to_requested();\n-\n@@ -550,15 +550,4 @@\n-  FileMapInfo* mapinfo = new FileMapInfo(static_archive, true);\n-  mapinfo->populate_header(MetaspaceShared::core_region_alignment());\n-  mapinfo->set_serialized_data(serialized_data);\n-  mapinfo->set_cloned_vtables(CppVtables::vtables_serialized_base());\n-  mapinfo->open_for_write();\n-  builder.write_archive(mapinfo, &_heap_info);\n-\n-  if (PrintSystemDictionaryAtExit) {\n-    SystemDictionary::print();\n-  }\n-\n-  if (AllowArchivingWithJavaAgent) {\n-    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n-            \"for testing purposes only and should not be used in a production environment\");\n-  }\n+  _map_info = new FileMapInfo(static_archive, true);\n+  _map_info->populate_header(MetaspaceShared::core_region_alignment());\n+  _map_info->set_serialized_data(serialized_data);\n+  _map_info->set_cloned_vtables(CppVtables::vtables_serialized_base());\n@@ -666,2 +655,1 @@\n-void MetaspaceShared::preload_and_dump() {\n-  EXCEPTION_MARK;\n+void MetaspaceShared::preload_and_dump(TRAPS) {\n@@ -669,1 +657,2 @@\n-  preload_and_dump_impl(THREAD);\n+  StaticArchiveBuilder builder;\n+  preload_and_dump_impl(builder, THREAD);\n@@ -674,2 +663,1 @@\n-      CLEAR_PENDING_EXCEPTION;\n-      MetaspaceShared::unrecoverable_writing_error();\n+      MetaspaceShared::writing_error();\n@@ -679,2 +667,1 @@\n-      CLEAR_PENDING_EXCEPTION;\n-      MetaspaceShared::unrecoverable_writing_error(\"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n+      MetaspaceShared::writing_error(\"Unexpected exception, use -Xlog:cds,exceptions=trace for detail\");\n@@ -771,1 +758,1 @@\n-void MetaspaceShared::preload_and_dump_impl(TRAPS) {\n+void MetaspaceShared::preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) {\n@@ -808,1 +795,1 @@\n-  VM_PopulateDumpSharedSpace op;\n+  VM_PopulateDumpSharedSpace op(builder);\n@@ -810,0 +797,22 @@\n+\n+  if (!write_static_archive(&builder, op.map_info(), op.heap_info())) {\n+    THROW_MSG(vmSymbols::java_io_IOException(), \"Encountered error while dumping\");\n+  }\n+}\n+\n+bool MetaspaceShared::write_static_archive(ArchiveBuilder* builder, FileMapInfo* map_info, ArchiveHeapInfo* heap_info) {\n+  \/\/ relocate the data so that it can be mapped to MetaspaceShared::requested_base_address()\n+  \/\/ without runtime relocation.\n+  builder->relocate_to_requested();\n+\n+  map_info->open_for_write();\n+  if (!map_info->is_open()) {\n+    return false;\n+  }\n+  builder->write_archive(map_info, heap_info);\n+\n+  if (AllowArchivingWithJavaAgent) {\n+    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n+            \"for testing purposes only and should not be used in a production environment\");\n+  }\n+  return true;\n@@ -919,0 +928,7 @@\n+  writing_error(message);\n+  vm_direct_exit(1);\n+}\n+\n+\/\/ This function is called when the JVM is unable to write the specified CDS archive due to a\n+\/\/ an error. The error will be propagated\n+void MetaspaceShared::writing_error(const char* message) {\n@@ -923,1 +939,0 @@\n-  vm_direct_exit(1);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":56,"deletions":41,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+class ArchiveBuilder;\n+class ArchiveHeapInfo;\n@@ -37,0 +39,1 @@\n+class StaticArchiveBuilder;\n@@ -69,1 +72,1 @@\n-  static void preload_and_dump() NOT_CDS_RETURN;\n+  static void preload_and_dump(TRAPS) NOT_CDS_RETURN;\n@@ -75,1 +78,1 @@\n-  static void preload_and_dump_impl(TRAPS) NOT_CDS_RETURN;\n+  static void preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) NOT_CDS_RETURN;\n@@ -108,0 +111,1 @@\n+  static void writing_error(const char* message = nullptr);\n@@ -169,0 +173,1 @@\n+  static bool write_static_archive(ArchiveBuilder* builder, FileMapInfo* map_info, ArchiveHeapInfo* heap_info);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -721,11 +721,4 @@\n-    if (UseVtableBasedCHA) {\n-      target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,\n-                                                                              root_m->get_Method(),\n-                                                                              callee_holder->get_Klass(),\n-                                                                              this->get_Method()));\n-    } else {\n-      if (root_m->is_abstract()) {\n-        return nullptr; \/\/ not supported\n-      }\n-      target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context, root_m->get_Method()));\n-    }\n+    target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,\n+                                                                            root_m->get_Method(),\n+                                                                            callee_holder->get_Klass(),\n+                                                                            this->get_Method()));\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -244,3 +244,8 @@\n-\/\/ unloading can remove entries concurrently soon.\n-template <bool keep_alive = true>\n-class ClassLoaderDataGraphIteratorBase : public StackObj {\n+\/\/ unloading can remove entries concurrently.\n+\/\/ This iterator does not keep the CLD alive.\n+\/\/ Any CLD OopHandles (modules, mirrors, resolved refs)\n+\/\/ resolved must be treated as no keepalive. And requires\n+\/\/ that its CLD's holder is kept alive if they escape the\n+\/\/ caller's safepoint or ClassLoaderDataGraph_lock\n+\/\/ critical section.\n+class ClassLoaderDataGraph::ClassLoaderDataGraphIterator : public StackObj {\n@@ -254,6 +259,2 @@\n-  ClassLoaderDataGraphIteratorBase() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n-    if (keep_alive) {\n-      assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-    } else {\n-      assert_at_safepoint();\n-    }\n+  ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n+    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n@@ -269,4 +270,0 @@\n-      if (keep_alive) {\n-        \/\/ Keep cld that is being returned alive.\n-        Handle(_thread, cld->holder());\n-      }\n@@ -281,3 +278,0 @@\n-using ClassLoaderDataGraphIterator = ClassLoaderDataGraphIteratorBase<true \/* keep_alive *\/>;\n-using ClassLoaderDataGraphIteratorNoKeepAlive = ClassLoaderDataGraphIteratorBase<false \/* keep_alive *\/>;\n-\n@@ -291,7 +285,0 @@\n-void ClassLoaderDataGraph::loaded_cld_do_no_keepalive(CLDClosure* cl) {\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n-  while (ClassLoaderData* cld = iter.get_next()) {\n-    cl->do_cld(cld);\n-  }\n-}\n-\n@@ -321,0 +308,10 @@\n+void ClassLoaderDataGraph::modules_do_keepalive(void f(ModuleEntry*)) {\n+  assert_locked_or_safepoint(Module_lock);\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData* cld = iter.get_next()) {\n+    \/\/ Keep the holder alive.\n+    (void)cld->holder();\n+    cld->modules_do(f);\n+  }\n+}\n+\n@@ -337,1 +334,1 @@\n-void ClassLoaderDataGraph::loaded_classes_do(KlassClosure* klass_closure) {\n+void ClassLoaderDataGraph::loaded_classes_do_keepalive(KlassClosure* klass_closure) {\n@@ -340,0 +337,2 @@\n+    \/\/ Keep the holder alive.\n+    (void)cld->holder();\n@@ -349,1 +348,1 @@\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n+  ClassLoaderDataGraphIterator iter;\n@@ -357,4 +356,0 @@\n-#define FOR_ALL_DICTIONARY(X)   ClassLoaderDataGraphIterator iter; \\\n-                                while (ClassLoaderData* X = iter.get_next()) \\\n-                                  if (X->dictionary() != nullptr)\n-\n@@ -362,6 +357,9 @@\n-  FOR_ALL_DICTIONARY(cld) {\n-    st->print(\"Dictionary for \");\n-    cld->print_value_on(st);\n-    st->cr();\n-    cld->dictionary()->print_on(st);\n-    st->cr();\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData *cld = iter.get_next()) {\n+    if (cld->dictionary() != nullptr) {\n+      st->print(\"Dictionary for \");\n+      cld->print_value_on(st);\n+      st->cr();\n+      cld->dictionary()->print_on(st);\n+      st->cr();\n+    }\n@@ -372,5 +370,8 @@\n-  FOR_ALL_DICTIONARY(cld) {\n-    ResourceMark rm; \/\/ loader_name_and_id\n-    stringStream tempst;\n-    tempst.print(\"System Dictionary for %s class loader\", cld->loader_name_and_id());\n-    cld->dictionary()->print_table_statistics(st, tempst.freeze());\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData *cld = iter.get_next()) {\n+    if (cld->dictionary() != nullptr) {\n+      ResourceMark rm; \/\/ loader_name_and_id\n+      stringStream tempst;\n+      tempst.print(\"System Dictionary for %s class loader\", cld->loader_name_and_id());\n+      cld->dictionary()->print_table_statistics(st, tempst.freeze());\n+    }\n@@ -553,1 +554,1 @@\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n+  ClassLoaderDataGraphIterator iter;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":42,"deletions":41,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-  template <bool keep_alive>\n-  friend class ClassLoaderDataGraphIteratorBase;\n@@ -44,0 +42,2 @@\n+  class ClassLoaderDataGraphIterator;\n+\n@@ -74,0 +74,5 @@\n+  \/\/ All the do suffixed functions do not keep the CLD alive. Any CLD OopHandles\n+  \/\/ (modules, mirrors, resolved refs) resolved must be treated as no keepalive.\n+  \/\/ And requires that its CLD's holder is kept alive if they escape the\n+  \/\/ caller's safepoint or ClassLoaderDataGraph_lock critical section.\n+  \/\/ The do_keepalive suffixed functions will keep all CLDs alive.\n@@ -75,1 +80,0 @@\n-  static void loaded_cld_do_no_keepalive(CLDClosure* cl);\n@@ -84,0 +88,1 @@\n+  static void modules_do_keepalive(void f(ModuleEntry*));\n@@ -86,1 +91,1 @@\n-  static void loaded_classes_do(KlassClosure* klass_closure);\n+  static void loaded_classes_do_keepalive(KlassClosure* klass_closure);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  ClassLoaderDataGraph::loaded_cld_do_no_keepalive(&clsc);\n+  ClassLoaderDataGraph::loaded_cld_do(&clsc);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -791,0 +791,1 @@\n+int java_lang_Class::_init_lock_offset;\n@@ -914,0 +915,6 @@\n+  \/\/ Allocate a simple java object for a lock.\n+  \/\/ This needs to be a java object because during class initialization\n+  \/\/ it can be held across a java call.\n+  typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);\n+  set_init_lock(mirror(), r);\n+\n@@ -1135,0 +1142,4 @@\n+    \/\/ create the init_lock\n+    typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));\n+    set_init_lock(mirror(), r);\n+\n@@ -1199,0 +1210,9 @@\n+oop java_lang_Class::init_lock(oop java_class) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  return java_class->obj_field(_init_lock_offset);\n+}\n+void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_init_lock_offset, init_lock);\n+}\n+\n@@ -1418,0 +1438,5 @@\n+  \/\/ Init lock is a C union with component_mirror.  Only instanceKlass mirrors have\n+  \/\/ init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops\n+  \/\/ GC treats them the same.\n+  _init_lock_offset = _component_mirror_offset;\n+\n@@ -1424,0 +1449,1 @@\n+  f->do_u4((u4*)&_init_lock_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,0 +229,1 @@\n+  static int _init_lock_offset;\n@@ -243,0 +244,1 @@\n+  static void set_init_lock(oop java_class, oop init_lock);\n@@ -295,0 +297,4 @@\n+  static oop  init_lock(oop java_class);\n+  static void clear_init_lock(oop java_class) {\n+    set_init_lock(java_class, nullptr);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-    return _reads->contains(m);\n+    return reads()->contains(m);\n@@ -167,1 +167,1 @@\n-    if (_reads == nullptr) {\n+    if (reads() == nullptr) {\n@@ -169,1 +169,2 @@\n-      _reads = new (mtModule) GrowableArray<ModuleEntry*>(MODULE_READS_SIZE, mtModule);\n+      GrowableArray<ModuleEntry*>* new_reads = new (mtModule) GrowableArray<ModuleEntry*>(MODULE_READS_SIZE, mtModule);\n+      set_reads(new_reads);\n@@ -177,1 +178,1 @@\n-    _reads->append_if_missing(m);\n+    reads()->append_if_missing(m);\n@@ -211,1 +212,1 @@\n-  return ((_reads != nullptr) && !_reads->is_empty());\n+  return ((reads() != nullptr) && !reads()->is_empty());\n@@ -230,1 +231,1 @@\n-    int len = _reads->length();\n+    int len = reads()->length();\n@@ -232,1 +233,1 @@\n-      ModuleEntry* module_idx = _reads->at(idx);\n+      ModuleEntry* module_idx = reads()->at(idx);\n@@ -235,1 +236,1 @@\n-        _reads->delete_at(idx);\n+        reads()->delete_at(idx);\n@@ -249,3 +250,3 @@\n-    int reads_len = _reads->length();\n-    for (int i = 0; i < reads_len; ++i) {\n-      f->do_module(_reads->at(i));\n+    int reads_len = reads()->length();\n+    for (ModuleEntry* m : *reads()) {\n+      f->do_module(m);\n@@ -257,1 +258,1 @@\n-  delete _reads;\n+  delete reads();\n@@ -275,1 +276,2 @@\n-    _is_patched(false) {\n+    _is_patched(false)\n+    DEBUG_ONLY(COMMA _reads_is_archived(false)) {\n@@ -469,1 +471,1 @@\n-  Array<ModuleEntry*>* archived_reads = write_growable_array(_reads);\n+  set_archived_reads(write_growable_array(reads()));\n@@ -477,1 +479,0 @@\n-  _reads = (GrowableArray<ModuleEntry*>*)archived_reads;\n@@ -518,1 +519,1 @@\n-  _reads = restore_growable_array((Array<ModuleEntry*>*)_reads);\n+  set_reads(restore_growable_array(archived_reads()));\n@@ -570,1 +571,1 @@\n-    QuickSort::sort(archived_modules->data(), n, (_sort_Fn)compare_module_by_name, true);\n+    QuickSort::sort(archived_modules->data(), n, compare_module_by_name);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -71,1 +71,5 @@\n-  GrowableArray<ModuleEntry*>* _reads; \/\/ list of modules that are readable by this module\n+\n+  union {\n+    GrowableArray<ModuleEntry*>* _reads;  \/\/ list of modules that are readable by this module\n+    Array<ModuleEntry*>* _archived_reads; \/\/ List of readable modules stored in the CDS archive\n+  };\n@@ -80,0 +84,1 @@\n+  DEBUG_ONLY(bool _reads_is_archived);\n@@ -118,0 +123,16 @@\n+  GrowableArray<ModuleEntry*>* reads() const {\n+    assert(!_reads_is_archived, \"sanity\");\n+    return _reads;\n+  }\n+  void set_reads(GrowableArray<ModuleEntry*>* r) {\n+    _reads = r;\n+    DEBUG_ONLY(_reads_is_archived = false);\n+  }\n+  Array<ModuleEntry*>* archived_reads() const {\n+    assert(_reads_is_archived, \"sanity\");\n+    return _archived_reads;\n+  }\n+  void set_archived_reads(Array<ModuleEntry*>* r) {\n+    _archived_reads = r;\n+    DEBUG_ONLY(_reads_is_archived = true);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -303,1 +303,2 @@\n-    QuickSort::sort(archived_packages->data(), n, (_sort_Fn)compare_package_by_name, true);\n+    \/\/ Always allocate in the same order to produce deterministic archive.\n+    QuickSort::sort(archived_packages->data(), n, compare_package_by_name);\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-\n+  \/\/ Will not keep metadata alive. See ClassLoaderDataGraph::methods_do.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -532,2 +532,2 @@\n-  do_name(intPolyMult_name, \"mult\")                                                                                     \\\n-  do_signature(intPolyMult_signature, \"([J[J[J)I\")                                                                      \\\n+  do_name(intPolyMult_name, \"multImpl\")                                                                                     \\\n+  do_signature(intPolyMult_signature, \"([J[J[J)V\")                                                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -560,0 +560,1 @@\n+  template(int_array_signature,                       \"[I\")                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -230,0 +230,5 @@\n+    \/\/ Further down, just before FLAG_SET_ERGO(), all segment sizes are\n+    \/\/ aligned down to the next lower multiple of min_size. For large page\n+    \/\/ sizes, this may result in (non_nmethod.size == 0) which is not acceptable.\n+    \/\/ Therefore, force non_nmethod.size to at least min_size.\n+    non_nmethod.size = MAX2(non_nmethod.size, min_size);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -116,5 +116,1 @@\n-  if (UseVtableBasedCHA) {\n-    assert_common_4(unique_concrete_method_4, ctxk, uniqm, resolved_klass, resolved_method);\n-  } else {\n-    assert_common_2(unique_concrete_method_2, ctxk, uniqm);\n-  }\n+  assert_common_4(unique_concrete_method_4, ctxk, uniqm, resolved_klass, resolved_method);\n@@ -1477,1 +1473,0 @@\n-    assert(UseVtableBasedCHA, \"required\");\n@@ -1951,1 +1946,0 @@\n-  assert(UseVtableBasedCHA, \"required\");\n@@ -2132,1 +2126,1 @@\n-    if (UseVtableBasedCHA && changes->is_klass_init_change()) {\n+    if (changes->is_klass_init_change()) {\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -847,4 +847,2 @@\n-    if (bs_nm->is_armed(nm)) {\n-      bool alive = bs_nm->nmethod_entry_barrier(nm);\n-      assert(alive, \"should be alive\");\n-    }\n+    bool alive = bs_nm->nmethod_entry_barrier(nm);\n+    assert(alive, \"should be alive\");\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -607,1 +607,1 @@\n-      QuickSort::sort(filtered, num, diff_entries_by_size, false);\n+      QuickSort::sort(filtered, num, diff_entries_by_size);\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-                               : JavaThread(&CompilerThread::thread_entry) {\n+  : JavaThread(&CompilerThread::thread_entry, 0, mtCompiler) {\n@@ -46,3 +46,0 @@\n-  \/\/ Compiler uses resource area for compilation, let's bias it to mtCompiler\n-  resource_area()->bias_to(mtCompiler);\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-  QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx, true);\n+  QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -362,2 +362,1 @@\n-                    compare_cards,\n-                    false);\n+                    compare_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -151,4 +151,0 @@\n-    \/\/ Ensure any loads from the forwardee follow all changes that precede\n-    \/\/ the release-cmpxchg that performed the forwarding, possibly in some\n-    \/\/ other thread.\n-    OrderAccess::acquire();\n@@ -256,4 +252,0 @@\n-  \/\/ Parallel GC claims with a release - so other threads might access this object\n-  \/\/ after claiming and they should see the \"completed\" object.\n-  ContinuationGCSupport::transform_stack_chunk(new_obj);\n-\n@@ -261,2 +253,5 @@\n-  \/\/ Make copy visible to threads reading the forwardee.\n-  oop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_release);\n+  \/\/ Because the forwarding is done with memory_order_relaxed there is no\n+  \/\/ ordering with the above copy.  Clients that get the forwardee must not\n+  \/\/ examine its contents without other synchronization, since the contents\n+  \/\/ may not be up to date for them.\n+  oop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_relaxed);\n@@ -275,0 +270,2 @@\n+    ContinuationGCSupport::transform_stack_chunk(new_obj);\n+\n@@ -298,3 +295,0 @@\n-    \/\/ Ensure loads from the forwardee follow all changes that preceded the\n-    \/\/ release-cmpxchg that performed the forwarding in another thread.\n-    OrderAccess::acquire();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -581,27 +581,0 @@\n-\/\/ The last collection bailed out, we are running out of heap space,\n-\/\/ so we try to allocate the from-space, too.\n-HeapWord* DefNewGeneration::allocate_from_space(size_t size) {\n-  bool should_try_alloc = should_allocate_from_space() || GCLocker::is_active_and_needs_gc();\n-\n-  \/\/ If the Heap_lock is not locked by this thread, this will be called\n-  \/\/ again later with the Heap_lock held.\n-  bool do_alloc = should_try_alloc && (Heap_lock->owned_by_self() || (SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread()));\n-\n-  HeapWord* result = nullptr;\n-  if (do_alloc) {\n-    result = from()->allocate(size);\n-  }\n-\n-  log_trace(gc, alloc)(\"DefNewGeneration::allocate_from_space(\" SIZE_FORMAT \"):  will_fail: %s  heap_lock: %s  free: \" SIZE_FORMAT \"%s%s returns %s\",\n-                        size,\n-                        SerialHeap::heap()->incremental_collection_will_fail(false \/* don't consult_young *\/) ?\n-                          \"true\" : \"false\",\n-                        Heap_lock->is_locked() ? \"locked\" : \"unlocked\",\n-                        from()->free(),\n-                        should_try_alloc ? \"\" : \"  should_allocate_from_space: NOT\",\n-                        do_alloc ? \"  Heap_lock is not owned by self\" : \"\",\n-                        result == nullptr ? \"null\" : \"object\");\n-\n-  return result;\n-}\n-\n@@ -710,2 +683,0 @@\n-\n-    assert(!heap->incremental_collection_failed(), \"Should be clear\");\n@@ -718,7 +689,0 @@\n-    \/\/ Add to-space to the list of space to compact\n-    \/\/ when a promotion failure has occurred.  In that\n-    \/\/ case there can be live objects in to-space\n-    \/\/ as a result of a partial evacuation of eden\n-    \/\/ and from-space.\n-    swap_spaces();   \/\/ For uniformity wrt ParNewGeneration.\n-    heap->set_incremental_collection_failed();\n@@ -886,2 +850,0 @@\n-  DEBUG_ONLY(static bool seen_incremental_collection_failed = false;)\n-\n@@ -889,39 +851,0 @@\n-  \/\/ Check if the heap is approaching full after a collection has\n-  \/\/ been done.  Generally the young generation is empty at\n-  \/\/ a minimum at the end of a collection.  If it is not, then\n-  \/\/ the heap is approaching full.\n-  SerialHeap* gch = SerialHeap::heap();\n-  if (full) {\n-    DEBUG_ONLY(seen_incremental_collection_failed = false;)\n-    if (!collection_attempt_is_safe() && !_eden_space->is_empty()) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), full, not safe, set_failed, set_alloc_from, clear_seen\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      gch->set_incremental_collection_failed(); \/\/ Slight lie: a full gc left us in that state\n-      set_should_allocate_from_space(); \/\/ we seem to be running out of space\n-    } else {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), full, safe, clear_failed, clear_alloc_from, clear_seen\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      gch->clear_incremental_collection_failed(); \/\/ We just did a full collection\n-      clear_should_allocate_from_space(); \/\/ if set\n-    }\n-  } else {\n-#ifdef ASSERT\n-    \/\/ It is possible that incremental_collection_failed() == true\n-    \/\/ here, because an attempted scavenge did not succeed. The policy\n-    \/\/ is normally expected to cause a full collection which should\n-    \/\/ clear that condition, so we should not be here twice in a row\n-    \/\/ with incremental_collection_failed() == true without having done\n-    \/\/ a full collection in between.\n-    if (!seen_incremental_collection_failed &&\n-        gch->incremental_collection_failed()) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), not full, not_seen_failed, failed, set_seen_failed\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      seen_incremental_collection_failed = true;\n-    } else if (seen_incremental_collection_failed) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), not full, seen_failed, will_clear_seen_failed\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      seen_incremental_collection_failed = false;\n-    }\n-#endif \/\/ ASSERT\n-  }\n-\n@@ -930,1 +853,1 @@\n-  gch->counters()->update_counters();\n+  SerialHeap::heap()->counters()->update_counters();\n@@ -970,7 +893,0 @@\n-  if (result == nullptr) {\n-    \/\/ If the eden is full and the last collection bailed out, we are running\n-    \/\/ out of heap space, and we try to allocate the from-space, too.\n-    \/\/ allocate_from_space can't be inlined because that would introduce a\n-    \/\/ circular dependency at compile time.\n-    result = allocate_from_space(word_size);\n-  }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":85,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-  HeapWord* allocate_from_space(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-    _incremental_collection_failed(false),\n@@ -290,2 +289,1 @@\n-         || GCLocker::is_active_and_needs_gc()\n-         || incremental_collection_failed();\n+         || GCLocker::is_active_and_needs_gc();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,5 +94,0 @@\n-  \/\/ Indicates that the most recent previous incremental collection failed.\n-  \/\/ The flag is cleared when an action is taken that might clear the\n-  \/\/ condition that caused that incremental collection to fail.\n-  bool _incremental_collection_failed;\n-\n@@ -258,23 +253,0 @@\n-  \/\/ Returns true if an incremental collection is likely to fail.\n-  \/\/ We optionally consult the young gen, if asked to do so;\n-  \/\/ otherwise we base our answer on whether the previous incremental\n-  \/\/ collection attempt failed with no corrective action as of yet.\n-  bool incremental_collection_will_fail(bool consult_young) {\n-    \/\/ The first disjunct remembers if an incremental collection failed, even\n-    \/\/ when we thought (second disjunct) that it would not.\n-    return incremental_collection_failed() ||\n-           (consult_young && !_young_gen->collection_attempt_is_safe());\n-  }\n-\n-  \/\/ If a generation bails out of an incremental collection,\n-  \/\/ it sets this flag.\n-  bool incremental_collection_failed() const {\n-    return _incremental_collection_failed;\n-  }\n-  void set_incremental_collection_failed() {\n-    _incremental_collection_failed = true;\n-  }\n-  void clear_incremental_collection_failed() {\n-    _incremental_collection_failed = false;\n-  }\n-\n@@ -292,1 +264,0 @@\n-private:\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -103,0 +103,6 @@\n+  if (!is_armed(nm)) {\n+    \/\/ Some other thread got here first and healed the oops\n+    \/\/ and disarmed the nmethod. No need to continue.\n+    return true;\n+  }\n+\n@@ -175,0 +181,3 @@\n+  \/\/ Check for disarmed method here to avoid going into DeoptimizeNMethodBarriersALot code\n+  \/\/ too often. nmethod_entry_barrier checks for disarmed status itself,\n+  \/\/ but we have no visibility into whether the barrier acted or not.\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-  OopMapCache::trigger_cleanup();\n+  OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,0 +391,1 @@\n+    mem_zap_start_padding(mem);\n@@ -398,0 +399,14 @@\n+void ObjArrayAllocator::mem_zap_start_padding(HeapWord* mem) const {\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(element_type);\n+  const size_t header_size_in_bytes = arrayOopDesc::header_size_in_bytes();\n+\n+  const address base = reinterpret_cast<address>(mem) + base_offset_in_bytes;\n+  const address header_end = reinterpret_cast<address>(mem) + header_size_in_bytes;\n+\n+  if (header_end < base) {\n+    const size_t padding_in_bytes = base - header_end;\n+    Copy::fill_to_bytes(header_end, padding_in_bytes, heapPaddingByteVal);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+  void mem_zap_start_padding(HeapWord* mem) const PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-  QuickSort::sort<RegionData>(data, (int)size, compare_by_garbage, false);\n+  QuickSort::sort(data, size, compare_by_garbage);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +106,0 @@\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -110,1 +110,0 @@\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -180,1 +179,0 @@\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -185,1 +183,0 @@\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,4 +156,1 @@\n-  {\n-    ShenandoahHeapLocker locker(heap->lock());\n-    heap->free_set()->log_status();\n-  }\n+  heap->free_set()->log_status_under_lock();\n@@ -774,1 +772,0 @@\n-      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -781,1 +778,0 @@\n-      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -887,1 +883,0 @@\n-      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -894,1 +889,0 @@\n-      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -150,4 +150,1 @@\n-      {\n-        ShenandoahHeapLocker locker(heap->lock());\n-        heap->free_set()->log_status();\n-      }\n+      heap->free_set()->log_status_under_lock();\n@@ -181,3 +178,1 @@\n-      {\n-        ShenandoahHeapLocker locker(heap->lock());\n-        heap->free_set()->log_status();\n+      heap->free_set()->log_status_under_lock();\n@@ -185,4 +180,4 @@\n-        \/\/ Notify Universe about new heap usage. This has implications for\n-        \/\/ global soft refs policy, and we better report it every time heap\n-        \/\/ usage goes down.\n-        heap->update_capacity_and_used_at_gc();\n+      \/\/ Notify Universe about new heap usage. This has implications for\n+      \/\/ global soft refs policy, and we better report it every time heap\n+      \/\/ usage goes down.\n+      heap->update_capacity_and_used_at_gc();\n@@ -190,3 +185,2 @@\n-        \/\/ Signal that we have completed a visit to all live objects.\n-        heap->record_whole_heap_examined_timestamp();\n-      }\n+      \/\/ Signal that we have completed a visit to all live objects.\n+      heap->record_whole_heap_examined_timestamp();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1133,0 +1133,10 @@\n+void ShenandoahFreeSet::log_status_under_lock() {\n+  \/\/ Must not be heap locked, it acquires heap lock only when log is enabled\n+  shenandoah_assert_not_heaplocked();\n+  if (LogTarget(Info, gc, free)::is_enabled()\n+      DEBUG_ONLY(|| LogTarget(Debug, gc, free)::is_enabled())) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    log_status();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -321,0 +321,3 @@\n+  \/\/ log status, assuming lock has already been acquired by the caller.\n+  void log_status();\n+\n@@ -343,1 +346,2 @@\n-  void log_status();\n+  \/\/ Acquire heap lock and log status, assuming heap lock is not acquired by the caller.\n+  void log_status_under_lock();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,9 +35,0 @@\n-\/\/ These are inline variants of Thread::SpinAcquire with optional blocking in VM.\n-\n-class ShenandoahNoBlockOp : public StackObj {\n-public:\n-  ShenandoahNoBlockOp(JavaThread* java_thread) {\n-    assert(java_thread == nullptr, \"Should not pass anything\");\n-  }\n-};\n-\n@@ -47,1 +38,1 @@\n-    contended_lock_internal<ThreadBlockInVM>(JavaThread::cast(thread));\n+    contended_lock_internal<true>(JavaThread::cast(thread));\n@@ -49,1 +40,1 @@\n-    contended_lock_internal<ShenandoahNoBlockOp>(nullptr);\n+    contended_lock_internal<false>(nullptr);\n@@ -53,1 +44,1 @@\n-template<typename BlockOp>\n+template<bool ALLOW_BLOCK>\n@@ -55,2 +46,4 @@\n-  int ctr = 0;\n-  int yields = 0;\n+  assert(!ALLOW_BLOCK || java_thread != nullptr, \"Must have a Java thread when allowing block.\");\n+  \/\/ Spin this much on multi-processor, do not spin on multi-processor.\n+  int ctr = os::is_MP() ? 0xFF : 0;\n+  \/\/ Apply TTAS to avoid more expensive CAS calls if the lock is still held by other thread.\n@@ -59,4 +52,21 @@\n-    if ((++ctr & 0xFFF) == 0) {\n-      BlockOp block(java_thread);\n-      if (yields > 5) {\n-        os::naked_short_sleep(1);\n+    if (ctr > 0 && !SafepointSynchronize::is_synchronizing()) {\n+      \/\/ Lightly contended, spin a little if no safepoint is pending.\n+      SpinPause();\n+      ctr--;\n+    } else if (ALLOW_BLOCK) {\n+      ThreadBlockInVM block(java_thread);\n+      if (SafepointSynchronize::is_synchronizing()) {\n+        \/\/ If safepoint is pending, we want to block and allow safepoint to proceed.\n+        \/\/ Normally, TBIVM above would block us in its destructor.\n+        \/\/\n+        \/\/ But that blocking only happens when TBIVM knows the thread poll is armed.\n+        \/\/ There is a window between announcing a safepoint and arming the thread poll\n+        \/\/ during which trying to continuously enter TBIVM is counter-productive.\n+        \/\/ Under high contention, we may end up going in circles thousands of times.\n+        \/\/ To avoid it, we wait here until local poll is armed and then proceed\n+        \/\/ to TBVIM exit for blocking. We do not SpinPause, but yield to let\n+        \/\/ VM thread to arm the poll sooner.\n+        while (SafepointSynchronize::is_synchronizing() &&\n+               !SafepointMechanism::local_poll_armed(java_thread)) {\n+          os::naked_yield();\n+        }\n@@ -65,1 +75,0 @@\n-        yields++;\n@@ -68,1 +77,1 @@\n-      SpinPause();\n+      os::naked_yield();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":29,"deletions":20,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  volatile Thread* _owner;\n+  Thread* volatile _owner;\n@@ -43,1 +43,1 @@\n-  template<typename BlockOp>\n+  template<bool ALLOW_BLOCK>\n@@ -45,1 +45,0 @@\n-\n@@ -52,2 +51,5 @@\n-    \/\/ Try to lock fast, or dive into contended lock handling.\n-    if (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n+    if ((allow_block_for_safepoint && SafepointSynchronize::is_synchronizing()) ||\n+        (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked)) {\n+      \/\/ 1. Java thread, and there is a pending safepoint. Dive into contended locking\n+      \/\/    immediately without trying anything else, and block.\n+      \/\/ 2. Fast lock fails, dive into contended lock handling.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -481,1 +482,1 @@\n-  assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -491,1 +492,1 @@\n-  assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  OopMapCache::trigger_cleanup();\n+  OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,6 @@\n+  if (!is_armed(nm)) {\n+    \/\/ Some other thread got here first and healed the oops\n+    \/\/ and disarmed the nmethod. No need to continue.\n+    return true;\n+  }\n+\n@@ -39,2 +45,2 @@\n-    \/\/ Some other thread got here first and healed the oops\n-    \/\/ and disarmed the nmethod.\n+    \/\/ Some other thread managed to complete while we were\n+    \/\/ waiting for lock. No need to continue.\n","filename":"src\/hotspot\/share\/gc\/x\/xBarrierSetNMethod.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-    OopMapCache::trigger_cleanup();\n+    OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/x\/xDriver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,7 @@\n+  if (!is_armed(nm)) {\n+    log_develop_trace(gc, nmethod)(\"nmethod: \" PTR_FORMAT \" visited by entry (disarmed before lock)\", p2i(nm));\n+    \/\/ Some other thread got here first and healed the oops\n+    \/\/ and disarmed the nmethod. No need to continue.\n+    return true;\n+  }\n+\n@@ -47,2 +54,2 @@\n-    \/\/ Some other thread got here first and healed the oops\n-    \/\/ and disarmed the nmethod.\n+    \/\/ Some other thread managed to complete while we were\n+    \/\/ waiting for lock. No need to continue.\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-    OopMapCache::trigger_cleanup();\n+    OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,0 +142,2 @@\n+  mem_zap_start_padding(mem);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -835,1 +835,0 @@\n-  ConstantPoolCache* cache = pool->cache();\n@@ -860,0 +859,7 @@\n+  update_invoke_cp_cache_entry(info, bytecode, resolved_method, pool, method_index);\n+}\n+\n+void InterpreterRuntime::update_invoke_cp_cache_entry(CallInfo& info, Bytecodes::Code bytecode,\n+                                                      methodHandle& resolved_method,\n+                                                      constantPoolHandle& pool,\n+                                                      int method_index) {\n@@ -864,0 +870,1 @@\n+  ConstantPoolCache* cache = pool->cache();\n@@ -915,0 +922,27 @@\n+void InterpreterRuntime::cds_resolve_invoke(Bytecodes::Code bytecode, int method_index,\n+                                            constantPoolHandle& pool, TRAPS) {\n+  LinkInfo link_info(pool, method_index, bytecode, CHECK);\n+\n+  if (!link_info.resolved_klass()->is_instance_klass() || InstanceKlass::cast(link_info.resolved_klass())->is_linked()) {\n+    CallInfo call_info;\n+    switch (bytecode) {\n+      case Bytecodes::_invokevirtual:   LinkResolver::cds_resolve_virtual_call  (call_info, link_info, CHECK); break;\n+      case Bytecodes::_invokeinterface: LinkResolver::cds_resolve_interface_call(call_info, link_info, CHECK); break;\n+      case Bytecodes::_invokespecial:   LinkResolver::cds_resolve_special_call  (call_info, link_info, CHECK); break;\n+\n+      default: fatal(\"Unimplemented: %s\", Bytecodes::name(bytecode));\n+    }\n+    methodHandle resolved_method(THREAD, call_info.resolved_method());\n+    guarantee(resolved_method->method_holder()->is_linked(), \"\");\n+    update_invoke_cp_cache_entry(call_info, bytecode, resolved_method, pool, method_index);\n+  } else {\n+    \/\/ FIXME: why a shared class is not linked yet?\n+    \/\/ Can't link it here since there are no guarantees it'll be prelinked on the next run.\n+    ResourceMark rm;\n+    InstanceKlass* resolved_iklass = InstanceKlass::cast(link_info.resolved_klass());\n+    log_info(cds, resolve)(\"Not resolved: class not linked: %s %s %s\",\n+                           resolved_iklass->is_shared() ? \"is_shared\" : \"\",\n+                           resolved_iklass->init_state_name(),\n+                           resolved_iklass->external_name());\n+  }\n+}\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  \/\/ Used by ClassListParser.\n+  \/\/ Used by ClassPrelinker\n@@ -98,0 +98,2 @@\n+  static void cds_resolve_invoke(Bytecodes::Code bytecode, int method_index,\n+                                 constantPoolHandle& pool, TRAPS);\n@@ -108,0 +110,3 @@\n+  static void update_invoke_cp_cache_entry(CallInfo& info, Bytecodes::Code bytecode,\n+                                           methodHandle& resolved_method,\n+                                           constantPoolHandle& pool, int method_index);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -145,1 +145,3 @@\n-  assert(resolved_method->signature() == selected_method->signature(), \"signatures must correspond\");\n+  if (selected_method.not_null()) {\n+    assert(resolved_method->signature() == selected_method->signature(), \"signatures must correspond\");\n+  }\n@@ -154,1 +156,3 @@\n-  CompilationPolicy::compile_if_required(selected_method, THREAD);\n+  if (selected_method.not_null()) {\n+    CompilationPolicy::compile_if_required(selected_method, THREAD);\n+  }\n@@ -1155,0 +1159,4 @@\n+void LinkResolver::cds_resolve_special_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  resolve_special_call(result, Handle(), link_info, CHECK);\n+}\n+\n@@ -1336,1 +1344,11 @@\n-                                 check_null_and_abstract, CHECK);\n+                                 check_null_and_abstract,\n+                                 \/*is_abstract_interpretation*\/ false, CHECK);\n+}\n+\n+void LinkResolver::cds_resolve_virtual_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  Method* resolved_method = linktime_resolve_virtual_method(link_info, CHECK);\n+  runtime_resolve_virtual_method(result, methodHandle(THREAD, resolved_method),\n+                                 link_info.resolved_klass(),\n+                                 Handle(), nullptr,\n+                                 \/*check_null_and_abstract*\/ false,\n+                                 \/*is_abstract_interpretation*\/ true, CHECK);\n@@ -1388,0 +1406,1 @@\n+                                                  bool is_abstract_interpretation,\n@@ -1389,0 +1408,3 @@\n+  \/\/ is_abstract_interpretation is true IFF CDS is resolving method references without\n+  \/\/ running any actual bytecode. Therefore, we don't have an actual recv\/recv_klass, so\n+  \/\/ we cannot check the actual selected_method (which is not needed by CDS anyway).\n@@ -1409,1 +1431,3 @@\n-    selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+    if (!is_abstract_interpretation) {\n+      selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+    }\n@@ -1423,1 +1447,3 @@\n-      selected_method = resolved_method;\n+      if (!is_abstract_interpretation) {\n+        selected_method = resolved_method;\n+      }\n@@ -1425,1 +1451,3 @@\n-      selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+      if (!is_abstract_interpretation) {\n+        selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+      }\n@@ -1429,4 +1457,5 @@\n-  \/\/ check if method exists\n-  if (selected_method.is_null()) {\n-    throw_abstract_method_error(resolved_method, recv_klass, CHECK);\n-  }\n+  if (!is_abstract_interpretation) {\n+    \/\/ check if method exists\n+    if (selected_method.is_null()) {\n+      throw_abstract_method_error(resolved_method, recv_klass, CHECK);\n+    }\n@@ -1434,5 +1463,5 @@\n-  \/\/ check if abstract\n-  if (check_null_and_abstract && selected_method->is_abstract()) {\n-    \/\/ Pass arguments for generating a verbose error message.\n-    throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);\n-  }\n+    \/\/ check if abstract\n+    if (check_null_and_abstract && selected_method->is_abstract()) {\n+      \/\/ Pass arguments for generating a verbose error message.\n+      throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);\n+    }\n@@ -1440,4 +1469,5 @@\n-  if (log_develop_is_enabled(Trace, vtables)) {\n-    trace_method_resolution(\"invokevirtual selected method: receiver-class:\",\n-                            recv_klass, resolved_klass, selected_method(),\n-                            false, vtable_index);\n+    if (log_develop_is_enabled(Trace, vtables)) {\n+      trace_method_resolution(\"invokevirtual selected method: receiver-class:\",\n+                              recv_klass, resolved_klass, selected_method(),\n+                              false, vtable_index);\n+    }\n@@ -1445,0 +1475,1 @@\n+\n@@ -1447,1 +1478,3 @@\n-  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  if (selected_method.not_null()) {\n+    JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  }\n@@ -1457,1 +1490,10 @@\n-                                   recv, recv_klass, check_null_and_abstract, CHECK);\n+                                   recv, recv_klass, check_null_and_abstract,\n+                                   \/*is_abstract_interpretation*\/ false, CHECK);\n+}\n+\n+void LinkResolver::cds_resolve_interface_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);\n+  runtime_resolve_interface_method(result, methodHandle(THREAD, resolved_method), link_info.resolved_klass(),\n+                                   Handle(), nullptr,\n+                                   \/*check_null_and_abstract*\/ false,\n+                                   \/*is_abstract_interpretation*\/ true, CHECK);\n@@ -1476,1 +1518,3 @@\n-                                                    bool check_null_and_abstract, TRAPS) {\n+                                                    bool check_null_and_abstract,\n+                                                    bool is_abstract_interpretation, TRAPS) {\n+  \/\/ is_abstract_interpretation -- see comments in runtime_resolve_virtual_method()\n@@ -1484,1 +1528,1 @@\n-  if (!recv_klass->is_subtype_of(resolved_klass)) {\n+  if (!is_abstract_interpretation && !recv_klass->is_subtype_of(resolved_klass)) {\n@@ -1493,1 +1537,5 @@\n-  methodHandle selected_method = resolved_method;\n+  methodHandle selected_method;\n+\n+  if (!is_abstract_interpretation) {\n+    selected_method = resolved_method;\n+  }\n@@ -1496,1 +1544,1 @@\n-  if (!resolved_method()->is_private()) {\n+  if (!is_abstract_interpretation && !resolved_method()->is_private()) {\n@@ -1542,1 +1590,1 @@\n-    assert(vtable_index == selected_method->vtable_index(), \"sanity check\");\n+    assert(is_abstract_interpretation || vtable_index == selected_method->vtable_index(), \"sanity check\");\n@@ -1559,1 +1607,3 @@\n-  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  if (!is_abstract_interpretation) {\n+    JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  }\n@@ -1827,1 +1877,1 @@\n-  \/\/ a lock to do the final serialization of updates\n+  \/\/ an ObjectLocker to do the final serialization of updates\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":78,"deletions":28,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -245,1 +245,2 @@\n-                                                 bool check_null_and_abstract, TRAPS);\n+                                                 bool check_null_and_abstract,\n+                                                 bool is_abstract_interpretation, TRAPS);\n@@ -251,1 +252,2 @@\n-                                                 bool check_null_and_abstract, TRAPS);\n+                                                 bool check_null_and_abstract,\n+                                                 bool is_abstract_interpretation, TRAPS);\n@@ -328,0 +330,4 @@\n+  static void cds_resolve_virtual_call  (CallInfo& result, const LinkInfo& link_info, TRAPS);\n+  static void cds_resolve_interface_call(CallInfo& result, const LinkInfo& link_info, TRAPS);\n+  static void cds_resolve_special_call  (CallInfo& result, const LinkInfo& link_info, TRAPS);\n+\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -448,2 +448,1 @@\n-  _array  = NEW_C_HEAP_ARRAY(OopMapCacheEntry*, _size, mtClass);\n-  for(int i = 0; i < _size; i++) _array[i] = nullptr;\n+  for(int i = 0; i < size; i++) _array[i] = nullptr;\n@@ -454,1 +453,0 @@\n-  assert(_array != nullptr, \"sanity check\");\n@@ -457,2 +455,0 @@\n-  \/\/ Deallocate array\n-  FREE_C_HEAP_ARRAY(OopMapCacheEntry*, _array);\n@@ -462,1 +458,1 @@\n-  return Atomic::load_acquire(&(_array[i % _size]));\n+  return Atomic::load_acquire(&(_array[i % size]));\n@@ -466,1 +462,1 @@\n-  return Atomic::cmpxchg(&_array[i % _size], old, entry) == old;\n+  return Atomic::cmpxchg(&_array[i % size], old, entry) == old;\n@@ -470,1 +466,1 @@\n-  for (int i = 0; i < _size; i++) {\n+  for (int i = 0; i < size; i++) {\n@@ -481,1 +477,1 @@\n-  for (int i = 0; i < _size; i++) {\n+  for (int i = 0; i < size; i++) {\n@@ -516,1 +512,1 @@\n-    for (int i = 0; i < _probe_depth; i++) {\n+    for (int i = 0; i < probe_depth; i++) {\n@@ -545,1 +541,1 @@\n-  for (int i = 0; i < _probe_depth; i++) {\n+  for (int i = 0; i < probe_depth; i++) {\n@@ -595,3 +591,5 @@\n-void OopMapCache::trigger_cleanup() {\n-  if (has_cleanup_work()) {\n-    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+void OopMapCache::try_trigger_cleanup() {\n+  \/\/ See we can take the lock for the notification without blocking.\n+  \/\/ This allows triggering the cleanup from GC paths, that can hold\n+  \/\/ the service lock for e.g. oop iteration in service thread.\n+  if (has_cleanup_work() && Service_lock->try_lock_without_rank_check()) {\n@@ -599,0 +597,1 @@\n+    Service_lock->unlock();\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,3 +155,2 @@\n-  enum { _size        = 32,     \/\/ Use fixed size for now\n-         _probe_depth = 3       \/\/ probe depth in case of collisions\n-  };\n+  static constexpr int size = 32;        \/\/ Use fixed size for now\n+  static constexpr int probe_depth = 3;  \/\/ probe depth in case of collisions\n@@ -159,1 +158,1 @@\n-  OopMapCacheEntry* volatile * _array;\n+  OopMapCacheEntry* volatile _array[size];\n@@ -186,2 +185,2 @@\n-  \/\/ Request cleanup if work is needed\n-  static void trigger_cleanup();\n+  \/\/ Request cleanup if work is needed and notification is currently possible\n+  static void try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-  } else {\n-    ++last;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunk.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,0 +107,1 @@\n+#if INCLUDE_ZGC\n@@ -108,0 +109,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,1 @@\n+#if INCLUDE_ZGC\n@@ -127,0 +128,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  static_field(CompilerToVM::Data,             sizeof_ZStoreBarrierEntry,              int)                                          \\\n+  ZGC_ONLY(static_field(CompilerToVM::Data,    sizeof_ZStoreBarrierEntry,              int))                                         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-  QuickSort::sort(suggestions, nsuggestions, sc, false);\n+  QuickSort::sort(suggestions, nsuggestions, sc);\n","filename":"src\/hotspot\/share\/logging\/logSelection.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -212,1 +212,6 @@\n-Arena::Arena(MEMFLAGS flag, Tag tag, size_t init_size) : _flags(flag), _tag(tag), _size_in_bytes(0)  {\n+Arena::Arena(MEMFLAGS flag, Tag tag, size_t init_size) :\n+  _flags(flag), _tag(tag),\n+  _size_in_bytes(0),\n+  _first(nullptr), _chunk(nullptr),\n+  _hwm(nullptr), _max(nullptr)\n+{\n@@ -222,9 +227,0 @@\n-Arena::Arena(MEMFLAGS flag, Tag tag) : _flags(flag), _tag(tag), _size_in_bytes(0) {\n-  _chunk = ChunkPool::allocate_chunk(Chunk::init_size, AllocFailStrategy::EXIT_OOM);\n-  _first = _chunk;\n-  _hwm = _chunk->bottom();      \/\/ Save the cached hwm, max\n-  _max = _chunk->top();\n-  MemTracker::record_new_arena(flag);\n-  set_size_in_bytes(Chunk::init_size);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -97,0 +97,5 @@\n+private:\n+  const MEMFLAGS _flags;        \/\/ Memory tracking flags\n+  const Tag _tag;\n+  size_t _size_in_bytes;        \/\/ Size of arena (used for native memory tracking)\n+\n@@ -102,3 +107,0 @@\n-  MEMFLAGS    _flags;           \/\/ Memory tracking flags\n-  const Tag _tag;\n-  uint32_t _init_size;\n@@ -109,0 +111,1 @@\n+\n@@ -111,1 +114,0 @@\n-  size_t _size_in_bytes;        \/\/ Size of arena (used for native memory tracking)\n@@ -127,2 +129,1 @@\n-  Arena(MEMFLAGS memflag, Tag tag = Tag::tag_other);\n-  Arena(MEMFLAGS memflag, Tag tag, size_t init_size);\n+  Arena(MEMFLAGS memflag, Tag tag = Tag::tag_other, size_t init_size = Chunk::init_size);\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,11 +33,0 @@\n-void ResourceArea::bias_to(MEMFLAGS new_flags) {\n-  if (new_flags != _flags) {\n-    size_t size = size_in_bytes();\n-    MemTracker::record_arena_size_change(-ssize_t(size), _flags);\n-    MemTracker::record_arena_free(_flags);\n-    MemTracker::record_new_arena(new_flags);\n-    MemTracker::record_arena_size_change(ssize_t(size), new_flags);\n-    _flags = new_flags;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/resourceArea.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,4 +63,0 @@\n-  \/\/ Bias this resource area to specific memory type\n-  \/\/ (by default, ResourceArea is tagged as mtThread, per-thread general purpose storage)\n-  void bias_to(MEMFLAGS flags);\n-\n@@ -84,1 +80,1 @@\n-      _size_in_bytes(area->_size_in_bytes)\n+      _size_in_bytes(area->size_in_bytes())\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#ifndef SHARE_NMT_ARRAYWITHFREELIST_HPP\n+#define SHARE_NMT_ARRAYWITHFREELIST_HPP\n+\n+#include \"utilities\/growableArray.hpp\"\n+#include <type_traits>\n+\n+\/\/ A flat array of elements E, backed by C-heap, growing on-demand. It allows for\n+\/\/ returning arbitrary elements and keeps them in a freelist. Elements can be uniquely\n+\/\/ identified via array index.\n+template<typename E, MEMFLAGS flag>\n+class ArrayWithFreeList {\n+\n+  \/\/ An E must be trivially copyable and destructible, but it may be constructed\n+  \/\/ however it likes.\n+  constexpr void static_assert_E_satisfies_type_requirements() const {\n+    static_assert(std::is_trivially_copyable<E>::value && std::is_trivially_destructible<E>::value, \"must be\");\n+  }\n+\n+public:\n+  using I = int32_t;\n+  static constexpr const I nil = -1;\n+\n+private:\n+  \/\/ A free list allocator element is either a link to the next free space\n+  \/\/ or an actual element.\n+  union BackingElement {\n+    I link;\n+    E e;\n+  };\n+\n+  GrowableArrayCHeap<BackingElement, flag> _backing_storage;\n+  I _free_start;\n+\n+  bool is_in_bounds(I i) {\n+    return i >= 0 && i < _backing_storage.length();\n+  }\n+\n+public:\n+  NONCOPYABLE(ArrayWithFreeList);\n+\n+  ArrayWithFreeList(int initial_capacity = 8)\n+    : _backing_storage(initial_capacity),\n+    _free_start(nil) {}\n+\n+  template<typename... Args>\n+  I allocate(Args... args) {\n+    static_assert_E_satisfies_type_requirements();\n+    BackingElement* be;\n+    I i;\n+    if (_free_start != nil) {\n+      \/\/ Must point to already existing index\n+      be = &_backing_storage.at(_free_start);\n+      i = _free_start;\n+      _free_start = be->link;\n+    } else {\n+      \/\/ There are no free elements, allocate a new one.\n+      i = _backing_storage.append(BackingElement());\n+      be = _backing_storage.adr_at(i);\n+    }\n+\n+    ::new (be) E{args...};\n+    return i;\n+  }\n+\n+  void deallocate(I i) {\n+    static_assert_E_satisfies_type_requirements();\n+    assert(i == nil || is_in_bounds(i), \"out of bounds free\");\n+    if (i == nil) return;\n+    BackingElement& be_freed = _backing_storage.at(i);\n+    be_freed.link = _free_start;\n+    _free_start = i;\n+  }\n+\n+  E& at(I i) {\n+    static_assert_E_satisfies_type_requirements();\n+    assert(i != nil, \"null pointer dereference\");\n+    assert(is_in_bounds(i), \"out of bounds dereference\");\n+    return _backing_storage.at(i).e;\n+  }\n+};\n+\n+#endif \/\/ SHARE_NMT_ARRAYWITHFREELIST_HPP\n","filename":"src\/hotspot\/share\/nmt\/arrayWithFreeList.hpp","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -340,1 +340,1 @@\n-    stack->print_on(out);\n+    _stackprinter.print_stack(stack);\n@@ -377,1 +377,1 @@\n-    stack->print_on(out);\n+    _stackprinter.print_stack(stack);\n@@ -431,1 +431,1 @@\n-    INDENT_BY(4, stack->print_on(out);)\n+    INDENT_BY(4, _stackprinter.print_stack(stack);)\n@@ -872,1 +872,1 @@\n-  stack->print_on(out);\n+  _stackprinter.print_stack(stack);\n@@ -907,1 +907,1 @@\n-  stack->print_on(out);\n+  _stackprinter.print_stack(stack);\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"nmt\/nativeCallStackPrinter.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"utilities\/nativeCallStack.hpp\"\n@@ -152,1 +154,1 @@\n-\n+  NativeCallStackPrinter _stackprinter;\n@@ -156,1 +158,1 @@\n-     _baseline(baseline) { }\n+     _baseline(baseline), _stackprinter(output) { }\n@@ -232,0 +234,1 @@\n+  NativeCallStackPrinter _stackprinter;\n@@ -235,1 +238,2 @@\n-    MemSummaryDiffReporter(early_baseline, current_baseline, output, scale) { }\n+    MemSummaryDiffReporter(early_baseline, current_baseline, output, scale),\n+    _stackprinter(output) { }\n","filename":"src\/hotspot\/share\/nmt\/memReporter.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  friend class MemoryFileTrackerTest;\n+  friend class NMTMemoryFileTrackerTest;\n@@ -51,1 +51,1 @@\n-    friend class MemoryFileTrackerTest;\n+    friend class NMTMemoryFileTrackerTest;\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"nmt\/nativeCallStackPrinter.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+NativeCallStackPrinter::NativeCallStackPrinter(outputStream* out) :\n+    _text_storage(mtNMT, Arena::Tag::tag_other, 128 * K), _out(out)\n+{}\n+\n+void NativeCallStackPrinter::print_stack(const NativeCallStack* stack) const {\n+  for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+    const address pc = stack->get_frame(i);\n+    if (pc == nullptr) {\n+      break;\n+    }\n+    bool created = false;\n+    const char** cached_frame_text = _cache.put_if_absent(pc, &created);\n+    if (created) {\n+      stringStream ss(4 * K);\n+      stack->print_frame(&ss, pc);\n+      const size_t len = ss.size();\n+      char* store = NEW_ARENA_ARRAY(&_text_storage, char, len + 1);\n+      memcpy(store, ss.base(), len + 1);\n+      (*cached_frame_text) = store;\n+    }\n+    _out->print_raw_cr(*cached_frame_text);\n+  }\n+}\n","filename":"src\/hotspot\/share\/nmt\/nativeCallStackPrinter.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_NATIVECALLSTACKPRINTER_HPP\n+#define SHARE_NMT_NATIVECALLSTACKPRINTER_HPP\n+\n+#include \"memory\/arena.hpp\"\n+#include \"nmt\/memflags.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class outputStream;\n+class NativeCallStack;\n+\n+\/\/ This is a text cache for NativeCallStack frames by PC. When printing tons of\n+\/\/ NativeCallStack instances (e.g. during NMT detail reports), printing through\n+\/\/ this printer speeds up frame description resolution by quite a bit.\n+class NativeCallStackPrinter {\n+  \/\/ Cache-related data are mutable to be able to use NativeCallStackPrinter as\n+  \/\/ inline member in classes with const printing methods.\n+  mutable Arena _text_storage;\n+  mutable ResourceHashtable<address, const char*, 293, AnyObj::C_HEAP, mtNMT> _cache;\n+  outputStream* const _out;\n+public:\n+  NativeCallStackPrinter(outputStream* out);\n+  void print_stack(const NativeCallStack* stack) const;\n+};\n+\n+#endif \/\/ SHARE_NMT_NATIVECALLSTACKPRINTER_HPP\n","filename":"src\/hotspot\/share\/nmt\/nativeCallStackPrinter.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/nmtNativeCallStackStorage.hpp\"\n+\n+NativeCallStackStorage::StackIndex NativeCallStackStorage::put(const NativeCallStack& value) {\n+  int bucket = value.calculate_hash() % _table_size;\n+  TableEntryIndex link = _table[bucket];\n+  while (link != TableEntryStorage::nil) {\n+    TableEntry& l = _entry_storage.at(link);\n+    if (value.equals(get(l.stack))) {\n+      return l.stack;\n+    }\n+    link = l.next;\n+  }\n+  int idx = _stacks.append(value);\n+  StackIndex si{idx};\n+  TableEntryIndex new_link = _entry_storage.allocate(_table[bucket], si);\n+  _table[bucket] = new_link;\n+  return si;\n+}\n+NativeCallStackStorage::NativeCallStackStorage(bool is_detailed_mode, int table_size)\n+  : _table_size(table_size),\n+    _table(nullptr),\n+    _stacks(),\n+    _is_detailed_mode(is_detailed_mode),\n+    _fake_stack() {\n+  if (_is_detailed_mode) {\n+    _table = NEW_C_HEAP_ARRAY(TableEntryIndex, _table_size, mtNMT);\n+    for (int i = 0; i < _table_size; i++) {\n+      _table[i] = TableEntryStorage::nil;\n+    }\n+  }\n+}\n+NativeCallStackStorage::~NativeCallStackStorage() {\n+  FREE_C_HEAP_ARRAY(LinkPtr, _table);\n+}\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -28,2 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/arena.hpp\"\n+#include \"nmt\/arrayWithFreeList.hpp\"\n@@ -43,1 +42,1 @@\n-class NativeCallStackStorage : public CHeapObj<mtNMT> {\n+class NativeCallStackStorage : public CHeapObjBase {\n@@ -47,4 +46,0 @@\n-\n-  private:\n-    static constexpr const int32_t _invalid = -1;\n-\n@@ -52,4 +47,0 @@\n-    StackIndex(int32_t stack_index)\n-      : _stack_index(stack_index) {\n-    }\n-\n@@ -57,0 +48,1 @@\n+    static constexpr const int32_t invalid = -1;\n@@ -62,5 +54,1 @@\n-      return _stack_index == _invalid;\n-    }\n-\n-    StackIndex()\n-      : _stack_index(_invalid) {\n+      return _stack_index == invalid;\n@@ -71,2 +59,8 @@\n-  struct Link : public ArenaObj {\n-    Link* next;\n+  struct TableEntry;\n+  using TableEntryStorage = ArrayWithFreeList<TableEntry, mtNMT>;\n+  using TableEntryIndex = typename TableEntryStorage::I;\n+\n+  TableEntryStorage _entry_storage;\n+\n+  struct TableEntry {\n+    TableEntryIndex next;\n@@ -74,4 +68,0 @@\n-    Link(Link* next, StackIndex v)\n-      : next(next),\n-        stack(v) {\n-    }\n@@ -79,14 +69,0 @@\n-  StackIndex put(const NativeCallStack& value) {\n-    int bucket = value.calculate_hash() % _table_size;\n-    Link* link = _table[bucket];\n-    while (link != nullptr) {\n-      if (value.equals(get(link->stack))) {\n-        return link->stack;\n-      }\n-      link = link->next;\n-    }\n-    int idx = _stacks.append(value);\n-    Link* new_link = new (&_arena) Link(_table[bucket], StackIndex(idx));\n-    _table[bucket] = new_link;\n-    return new_link->stack;\n-  }\n@@ -94,2 +70,2 @@\n-  \/\/ For storage of the Links\n-  Arena _arena;\n+  StackIndex put(const NativeCallStack& value);\n+\n@@ -99,2 +75,2 @@\n-  int _table_size;\n-  Link** _table;\n+  const int _table_size;\n+  TableEntryIndex* _table;\n@@ -110,1 +86,1 @@\n-      return StackIndex();\n+      return StackIndex{StackIndex::invalid};\n@@ -122,10 +98,3 @@\n-  NativeCallStackStorage(bool is_detailed_mode, int table_size = default_table_size)\n-  : _arena(mtNMT), _table_size(table_size), _table(nullptr), _stacks(),\n-    _is_detailed_mode(is_detailed_mode), _fake_stack() {\n-    if (_is_detailed_mode) {\n-      _table = NEW_ARENA_ARRAY(&_arena, Link*, _table_size);\n-      for (int i = 0; i < _table_size; i++) {\n-        _table[i] = nullptr;\n-      }\n-    }\n-  }\n+  NativeCallStackStorage(bool is_detailed_mode, int table_size = default_table_size);\n+\n+  ~NativeCallStackStorage();\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":20,"deletions":51,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -34,1 +33,1 @@\n-#include <stdint.h>\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -56,2 +55,2 @@\n-  friend class VMATreeTest;\n-  friend class TreapTest;\n+  friend class NMTVMATreeTest;\n+  friend class NMTTreapTest;\n@@ -87,0 +86,3 @@\n+\n+  \/\/ A random number\n+  static constexpr const uint64_t _initial_seed = 0xC8DD2114AE0543A3;\n@@ -91,6 +93,3 @@\n-    \/\/ Taken directly off of JFRPrng\n-    static const constexpr uint64_t PrngMult = 0x5DEECE66DLL;\n-    static const constexpr uint64_t PrngAdd = 0xB;\n-    static const constexpr uint64_t PrngModPower = 48;\n-    static const constexpr uint64_t PrngModMask = (static_cast<uint64_t>(1) << PrngModPower) - 1;\n-    _prng_seed = (PrngMult * _prng_seed + PrngAdd) & PrngModMask;\n+    uint64_t first_half = os::next_random(_prng_seed);\n+    uint64_t second_half = os::next_random(_prng_seed >> 32);\n+    _prng_seed = first_half | (second_half << 32);\n@@ -176,1 +175,1 @@\n-    \/\/ We take the ceiling of log_2(N + 1) * 2.5 as our maximum bound.\n+    \/\/ We take the ceiling of log_2(N + 1) * 3 as our maximum bound.\n@@ -178,1 +177,1 @@\n-    const int expected_maximum_depth = ceil((log(this->_node_count+1) \/ log(2)) * 2.5);\n+    const int expected_maximum_depth = ceil(log2i(this->_node_count+1) * 3);\n@@ -228,2 +227,1 @@\n-  Treap(uint64_t seed = static_cast<uint64_t>(os::random())\n-                        | (static_cast<uint64_t>(os::random()) << 32))\n+  Treap()\n@@ -232,1 +230,1 @@\n-    _prng_seed(seed),\n+    _prng_seed(_initial_seed),\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/nativeCallStackPrinter.hpp\"\n@@ -682,0 +683,1 @@\n+  NativeCallStackPrinter      _stackprinter;\n@@ -684,1 +686,1 @@\n-    _p((address)p), _st(st) { }\n+    _p((address)p), _st(st), _stackprinter(st) { }\n@@ -691,1 +693,1 @@\n-        rgn->call_stack()->print_on(_st);\n+        _stackprinter.print_stack(rgn->call_stack());\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  friend class VMATreeTest;\n+  friend class NMTVMATreeTest;\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -59,0 +60,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -177,1 +179,1 @@\n-             method->method_holder()->is_init_thread(JavaThread::current()),\n+             method->method_holder()->is_reentrant_initialization(JavaThread::current()),\n@@ -272,0 +274,1 @@\n+\n@@ -274,2 +277,0 @@\n-  MutexLocker ml(constant_pool()->pool_holder()->init_monitor());\n-  ResolvedMethodEntry* method_entry = resolved_method_entry_at(method_index);\n@@ -277,0 +278,10 @@\n+  JavaThread* current = JavaThread::current();\n+  objArrayHandle resolved_references(current, constant_pool()->resolved_references());\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n+\n+  ResolvedMethodEntry* method_entry = resolved_method_entry_at(method_index);\n@@ -314,1 +325,0 @@\n-    objArrayOop resolved_references = constant_pool()->resolved_references();\n@@ -402,3 +412,1 @@\n-    for (int i = 0; i < _resolved_method_entries->length(); i++) {\n-      resolved_method_entry_at(i)->remove_unshareable_info();\n-    }\n+    remove_resolved_method_entries_if_non_deterministic();\n@@ -442,0 +450,90 @@\n+\n+void ConstantPoolCache::remove_resolved_method_entries_if_non_deterministic() {\n+  ConstantPool* cp = constant_pool();\n+  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(cp);\n+  for (int i = 0; i < _resolved_method_entries->length(); i++) {\n+    ResolvedMethodEntry* rme = _resolved_method_entries->adr_at(i);\n+    int cp_index = rme->constant_pool_index();\n+    bool archived = false;\n+    bool resolved = rme->is_resolved(Bytecodes::_invokevirtual)   ||\n+                    rme->is_resolved(Bytecodes::_invokespecial)   ||\n+                    rme->is_resolved(Bytecodes::_invokeinterface);\n+\n+    \/\/ Just for safety -- this should not happen, but do not archive if we ever see this.\n+    resolved &= !(rme->is_resolved(Bytecodes::_invokehandle) ||\n+                  rme->is_resolved(Bytecodes::_invokestatic));\n+\n+    if (resolved && can_archive_resolved_method(rme)) {\n+      rme->mark_and_relocate(src_cp);\n+      archived = true;\n+    } else {\n+      rme->remove_unshareable_info();\n+    }\n+    if (resolved) {\n+      LogStreamHandle(Trace, cds, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+        Symbol* name = cp->uncached_name_ref_at(cp_index);\n+        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+        log.print(\"%s%s method CP entry [%3d]: %s %s.%s:%s\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  (rme->is_resolved(Bytecodes::_invokeinterface) ? \" interface\" : \"\"),\n+                  cp_index,\n+                  cp->pool_holder()->name()->as_C_string(),\n+                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+        if (archived) {\n+          Klass* resolved_klass = cp->resolved_klass_at(klass_cp_index);\n+          log.print(\" => %s%s\",\n+                    resolved_klass->name()->as_C_string(),\n+                    (rme->is_resolved(Bytecodes::_invokestatic) ? \" *** static\" : \"\"));\n+        }\n+      }\n+      ArchiveBuilder::alloc_stats()->record_method_cp_entry(archived, resolved && !archived);\n+    }\n+  }\n+}\n+\n+bool ConstantPoolCache::can_archive_resolved_method(ResolvedMethodEntry* method_entry) {\n+  InstanceKlass* pool_holder = constant_pool()->pool_holder();\n+  if (!(pool_holder->is_shared_boot_class() || pool_holder->is_shared_platform_class() ||\n+        pool_holder->is_shared_app_class())) {\n+    \/\/ Archiving resolved cp entries for classes from non-builtin loaders\n+    \/\/ is not yet supported.\n+    return false;\n+  }\n+\n+  if (CDSConfig::is_dumping_dynamic_archive()) {\n+    \/\/ InstanceKlass::methods() has been resorted. We need to\n+    \/\/ update the vtable_index in method_entry (not implemented)\n+    return false;\n+  }\n+\n+  if (!method_entry->is_resolved(Bytecodes::_invokevirtual)) {\n+    if (method_entry->method() == nullptr) {\n+      return false;\n+    }\n+    if (method_entry->method()->is_continuation_native_intrinsic()) {\n+      return false; \/\/ FIXME: corresponding stub is generated on demand during method resolution (see LinkResolver::resolve_static_call).\n+    }\n+  }\n+\n+  int cp_index = method_entry->constant_pool_index();\n+  ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(constant_pool());\n+  assert(src_cp->tag_at(cp_index).is_method() || src_cp->tag_at(cp_index).is_interface_method(), \"sanity\");\n+\n+  if (!ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+    return false;\n+  }\n+\n+  if (method_entry->is_resolved(Bytecodes::_invokeinterface) ||\n+      method_entry->is_resolved(Bytecodes::_invokevirtual) ||\n+      method_entry->is_resolved(Bytecodes::_invokespecial)) {\n+    return true;\n+  } else {\n+    \/\/ invokestatic and invokehandle are not supported yet.\n+    return false;\n+  }\n+\n+}\n@@ -590,1 +688,8 @@\n-  MutexLocker ml(THREAD, cpool->pool_holder()->init_monitor());\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  JavaThread* current = THREAD;\n+  objArrayHandle resolved_references(current, cpool->resolved_references());\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n@@ -613,1 +718,11 @@\n-  MutexLocker ml(constant_pool()->pool_holder()->init_monitor());\n+\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  JavaThread* current = JavaThread::current();\n+  constantPoolHandle cp(current, constant_pool());\n+\n+  objArrayHandle resolved_references(current, cp->resolved_references());\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n@@ -617,1 +732,1 @@\n-    return constant_pool()->resolved_reference_from_indy(index);\n+    return cp->resolved_reference_from_indy(index);\n@@ -625,3 +740,1 @@\n-    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-    constantPoolHandle cp(THREAD, constant_pool());\n-    ConstantPool::throw_resolution_error(cp, encoded_index, THREAD);\n+    ConstantPool::throw_resolution_error(cp, encoded_index, current);\n@@ -651,1 +764,0 @@\n-    objArrayOop resolved_references = constant_pool()->resolved_references();\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":126,"deletions":14,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,0 +227,2 @@\n+  void remove_resolved_method_entries_if_non_deterministic();\n+  bool can_archive_resolved_method(ResolvedMethodEntry* method_entry);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -500,3 +501,0 @@\n-static Monitor* create_init_monitor(const char* name) {\n-  return new Monitor(Mutex::safepoint, name);\n-}\n@@ -520,1 +518,0 @@\n-  _init_monitor(create_init_monitor(\"InstanceKlassInitMonitor_lock\")),\n@@ -748,0 +745,22 @@\n+oop InstanceKlass::init_lock() const {\n+  \/\/ return the init lock from the mirror\n+  oop lock = java_lang_Class::init_lock(java_mirror());\n+  \/\/ Prevent reordering with any access of initialization state\n+  OrderAccess::loadload();\n+  assert(lock != nullptr || !is_not_initialized(), \/\/ initialized or in_error state\n+         \"only fully initialized state can have a null lock\");\n+  return lock;\n+}\n+\n+\/\/ Set the initialization lock to null so the object can be GC'ed.  Any racing\n+\/\/ threads to get this lock will see a null lock and will not lock.\n+\/\/ That's okay because they all check for initialized state after getting\n+\/\/ the lock and return.\n+void InstanceKlass::fence_and_clear_init_lock() {\n+  \/\/ make sure previous stores are all done, notably the init_state.\n+  OrderAccess::storestore();\n+  java_lang_Class::clear_init_lock(java_mirror());\n+  assert(!is_not_initialized(), \"class must be initialized now\");\n+}\n+\n+\n@@ -775,43 +794,0 @@\n-void InstanceKlass::check_link_state_and_wait(JavaThread* current) {\n-  MonitorLocker ml(current, _init_monitor);\n-\n-  bool debug_logging_enabled = log_is_enabled(Debug, class, init);\n-\n-  \/\/ Another thread is linking this class, wait.\n-  while (is_being_linked() && !is_init_thread(current)) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" waiting for linking of %s by thread \\\"%s\\\"\",\n-                             current->name(), external_name(), init_thread_name());\n-    }\n-    ml.wait();\n-  }\n-\n-  \/\/ This thread is recursively linking this class, continue\n-  if (is_being_linked() && is_init_thread(current)) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" recursively linking %s\",\n-                             current->name(), external_name());\n-    }\n-    return;\n-  }\n-\n-  \/\/ If this class wasn't linked already, set state to being_linked\n-  if (!is_linked()) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" linking %s\",\n-                             current->name(), external_name());\n-    }\n-    set_init_state(being_linked);\n-    set_init_thread(current);\n-  } else {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" found %s already linked\",\n-                             current->name(), external_name());\n-      }\n-  }\n-}\n-\n@@ -896,2 +872,3 @@\n-    LockLinkState init_lock(this, jt);\n-\n+    HandleMark hm(THREAD);\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -955,1 +932,15 @@\n-      set_initialization_state_and_notify(linked, THREAD);\n+      if (Universe::is_fully_initialized()) {\n+        DeoptimizationScope deopt_scope;\n+        {\n+          \/\/ Now mark all code that assumes the class is not linked.\n+          \/\/ Set state under the Compile_lock also.\n+          MutexLocker ml(THREAD, Compile_lock);\n+\n+          set_init_state(linked);\n+          CodeCache::mark_dependents_on(&deopt_scope, this);\n+        }\n+        \/\/ Perform the deopt handshake outside Compile_lock.\n+        deopt_scope.deoptimize_marked();\n+      } else {\n+        set_init_state(linked);\n+      }\n@@ -1087,1 +1078,0 @@\n-  bool throw_error = false;\n@@ -1096,1 +1086,2 @@\n-    MonitorLocker ml(jt, _init_monitor);\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -1099,1 +1090,4 @@\n-    while (is_being_initialized() && !is_init_thread(jt)) {\n+    \/\/ If we were to use wait() instead of waitInterruptibly() then\n+    \/\/ we might end up throwing IE from link\/symbol resolution sites\n+    \/\/ that aren't expected to throw.  This would wreak havoc.  See 6320309.\n+    while (is_being_initialized() && !is_reentrant_initialization(jt)) {\n@@ -1105,1 +1099,0 @@\n-\n@@ -1108,1 +1101,1 @@\n-      ml.wait();\n+      ol.wait_uninterruptibly(jt);\n@@ -1113,1 +1106,1 @@\n-    if (is_being_initialized() && is_init_thread(jt)) {\n+    if (is_being_initialized() && is_reentrant_initialization(jt)) {\n@@ -1141,1 +1134,13 @@\n-      throw_error = true;\n+\n+      DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n+      ResourceMark rm(THREAD);\n+      Handle cause(THREAD, get_initialization_error(THREAD));\n+\n+      stringStream ss;\n+      ss.print(\"Could not initialize class %s\", external_name());\n+      if (cause.is_null()) {\n+        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n+      } else {\n+        THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n+                        ss.as_string(), cause);\n+      }\n@@ -1155,16 +1160,0 @@\n-  \/\/ Throw error outside lock\n-  if (throw_error) {\n-    DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n-    ResourceMark rm(THREAD);\n-    Handle cause(THREAD, get_initialization_error(THREAD));\n-\n-    stringStream ss;\n-    ss.print(\"Could not initialize class %s\", external_name());\n-    if (cause.is_null()) {\n-      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n-    } else {\n-      THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n-                      ss.as_string(), cause);\n-    }\n-  }\n-\n@@ -1228,1 +1217,1 @@\n-    set_initialization_state_and_notify(fully_initialized, THREAD);\n+    set_initialization_state_and_notify(fully_initialized, CHECK);\n@@ -1261,17 +1250,8 @@\n-void InstanceKlass::set_initialization_state_and_notify(ClassState state, JavaThread* current) {\n-  MonitorLocker ml(current, _init_monitor);\n-\n-  if (state == linked && UseVtableBasedCHA && Universe::is_fully_initialized()) {\n-    DeoptimizationScope deopt_scope;\n-    {\n-      \/\/ Now mark all code that assumes the class is not linked.\n-      \/\/ Set state under the Compile_lock also.\n-      MutexLocker ml(current, Compile_lock);\n-\n-      set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n-      set_init_state(state);\n-\n-      CodeCache::mark_dependents_on(&deopt_scope, this);\n-    }\n-    \/\/ Perform the deopt handshake outside Compile_lock.\n-    deopt_scope.deoptimize_marked();\n+void InstanceKlass::set_initialization_state_and_notify(ClassState state, TRAPS) {\n+  Handle h_init_lock(THREAD, init_lock());\n+  if (h_init_lock() != nullptr) {\n+    ObjectLocker ol(h_init_lock, THREAD);\n+    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n+    set_init_state(state);\n+    fence_and_clear_init_lock();\n+    ol.notify_all(CHECK);\n@@ -1279,0 +1259,1 @@\n+    assert(h_init_lock() != nullptr, \"The initialization state should never be set twice\");\n@@ -1282,1 +1263,0 @@\n-  ml.notify_all();\n@@ -1290,8 +1270,0 @@\n-  \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n-  \/\/ deopt is completed before anyone links this class.\n-  \/\/ Linking is done with _init_monitor held, by loading and deopting with it\n-  \/\/ held we make sure the deopt is completed before linking.\n-  if (!UseVtableBasedCHA) {\n-    init_monitor()->lock();\n-  }\n-\n@@ -1319,4 +1291,0 @@\n-\n-  if (!UseVtableBasedCHA) {\n-    init_monitor()->unlock();\n-  }\n@@ -1325,0 +1293,1 @@\n+\n@@ -2593,1 +2562,0 @@\n-  _init_monitor = nullptr;\n@@ -2697,3 +2665,0 @@\n-\n-  \/\/ restore the monitor\n-  _init_monitor = create_init_monitor(\"InstanceKlassInitMonitorRestored_lock\");\n@@ -2795,3 +2760,0 @@\n-  \/\/ Destroy the init_monitor\n-  delete _init_monitor;\n-\n@@ -3489,1 +3451,1 @@\n-  \"allocated\", \"loaded\", \"being_linked\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n+  \"allocated\", \"loaded\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n@@ -3563,3 +3525,1 @@\n-  if (default_vtable_indices() != nullptr) {\n-    st->print(BULLET\"default vtable indices:   \"); default_vtable_indices()->print_value_on(st);       st->cr();\n-  }\n+  print_on_maybe_null(st, BULLET\"default vtable indices:   \", default_vtable_indices());\n@@ -3592,10 +3552,3 @@\n-  if (class_loader_data() != nullptr) {\n-    st->print(BULLET\"class loader data:  \");\n-    class_loader_data()->print_value_on(st);\n-    st->cr();\n-  }\n-  if (source_file_name() != nullptr) {\n-    st->print(BULLET\"source file:       \");\n-    source_file_name()->print_value_on(st);\n-    st->cr();\n-  }\n+\n+  print_on_maybe_null(st, BULLET\"class loader data:  \", class_loader_data());\n+  print_on_maybe_null(st, BULLET\"source file:       \", source_file_name());\n@@ -3607,4 +3560,4 @@\n-  st->print(BULLET\"class annotations:       \"); class_annotations()->print_value_on(st); st->cr();\n-  st->print(BULLET\"class type annotations:  \"); class_type_annotations()->print_value_on(st); st->cr();\n-  st->print(BULLET\"field annotations:       \"); fields_annotations()->print_value_on(st); st->cr();\n-  st->print(BULLET\"field type annotations:  \"); fields_type_annotations()->print_value_on(st); st->cr();\n+  print_on_maybe_null(st, BULLET\"class annotations:       \", class_annotations());\n+  print_on_maybe_null(st, BULLET\"class type annotations:  \", class_type_annotations());\n+  print_on_maybe_null(st, BULLET\"field annotations:       \", fields_annotations());\n+  print_on_maybe_null(st, BULLET\"field type annotations:  \", fields_type_annotations());\n@@ -3625,5 +3578,1 @@\n-  if (generic_signature() != nullptr) {\n-    st->print(BULLET\"generic signature: \");\n-    generic_signature()->print_value_on(st);\n-    st->cr();\n-  }\n+  print_on_maybe_null(st, BULLET\"generic signature: \", generic_signature());\n@@ -3632,3 +3581,1 @@\n-  if (record_components() != nullptr) {\n-    st->print(BULLET\"record components:     \"); record_components()->print_value_on(st);     st->cr();\n-  }\n+  print_on_maybe_null(st, BULLET\"record components:     \", record_components());\n@@ -4139,3 +4086,0 @@\n-  if (state > loaded) {\n-    assert_lock_strong(_init_monitor);\n-  }\n@@ -4145,2 +4089,1 @@\n-  bool link_failed = _init_state == being_linked && state == loaded;\n-  assert(good_state || state == allocated || link_failed, \"illegal state transition\");\n+  assert(good_state || state == allocated, \"illegal state transition\");\n@@ -4149,1 +4092,1 @@\n-  Atomic::store(&_init_state, state);\n+  _init_state = state;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":86,"deletions":143,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -155,1 +155,0 @@\n-    being_linked,                       \/\/ currently running verifier and rewriter\n@@ -229,0 +228,7 @@\n+  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n+  \/\/ _misc_flags.\n+  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n+\n+  \/\/ Class states are defined as ClassState (see above).\n+  \/\/ Place the _init_state here to utilize the unused 2-byte after\n+  \/\/ _idnum_allocated_count.\n@@ -231,1 +237,1 @@\n-  u1              _reference_type;          \/\/ reference type\n+  u1              _reference_type;                \/\/ reference type\n@@ -236,1 +242,0 @@\n-  Monitor*             _init_monitor;       \/\/ mutual exclusion to _init_state and _init_thread.\n@@ -500,1 +505,0 @@\n-  \/\/ We can safely access the name as long as we hold the _init_monitor.\n@@ -502,1 +506,0 @@\n-    assert(_init_monitor->owned_by_self(), \"Must hold _init_monitor here\");\n@@ -508,9 +511,8 @@\n-  bool is_loaded() const                   { return init_state() >= loaded; }\n-  bool is_linked() const                   { return init_state() >= linked; }\n-  bool is_being_linked() const             { return init_state() == being_linked; }\n-  bool is_initialized() const              { return init_state() == fully_initialized; }\n-  bool is_not_initialized() const          { return init_state() <  being_initialized; }\n-  bool is_being_initialized() const        { return init_state() == being_initialized; }\n-  bool is_in_error_state() const           { return init_state() == initialization_error; }\n-  bool is_init_thread(JavaThread *thread)  { return thread == init_thread(); }\n-  ClassState  init_state() const           { return Atomic::load(&_init_state); }\n+  bool is_loaded() const                   { return _init_state >= loaded; }\n+  bool is_linked() const                   { return _init_state >= linked; }\n+  bool is_initialized() const              { return _init_state == fully_initialized; }\n+  bool is_not_initialized() const          { return _init_state <  being_initialized; }\n+  bool is_being_initialized() const        { return _init_state == being_initialized; }\n+  bool is_in_error_state() const           { return _init_state == initialization_error; }\n+  bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }\n+  ClassState  init_state() const           { return _init_state; }\n@@ -520,15 +522,0 @@\n-  class LockLinkState : public StackObj {\n-    InstanceKlass* _ik;\n-    JavaThread*    _current;\n-   public:\n-    LockLinkState(InstanceKlass* ik, JavaThread* current) : _ik(ik), _current(current) {\n-      ik->check_link_state_and_wait(current);\n-    }\n-    ~LockLinkState() {\n-      if (!_ik->is_linked()) {\n-        \/\/ Reset to loaded if linking failed.\n-        _ik->set_initialization_state_and_notify(loaded, _current);\n-      }\n-    }\n-  };\n-\n@@ -832,1 +819,1 @@\n-  void set_initialization_state_and_notify(ClassState state, JavaThread* current);\n+  void set_initialization_state_and_notify(ClassState state, TRAPS);\n@@ -844,0 +831,1 @@\n+ public:\n@@ -1058,1 +1046,1 @@\n- private:\n+private:\n@@ -1075,0 +1063,6 @@\n+  \/\/ Lock for (1) initialization; (2) access to the ConstantPool of this class.\n+  \/\/ Must be one per class and it has to be a VM internal object so java code\n+  \/\/ cannot lock it (like the mirror).\n+  \/\/ It has to be an object not a Mutex because it's held through java calls.\n+  oop init_lock() const;\n+\n@@ -1084,2 +1078,0 @@\n-\n-  Monitor* init_monitor() const { return _init_monitor; }\n@@ -1087,1 +1079,2 @@\n-  void check_link_state_and_wait(JavaThread* current);\n+  void fence_and_clear_init_lock();\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":27,"deletions":34,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -79,0 +79,9 @@\n+template <typename M>\n+static void print_on_maybe_null(outputStream* st, const char* str, const M* m) {\n+  if (nullptr != m) {\n+    st->print_raw(str);\n+    m->print_value_on(st);\n+    st->cr();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/metadata.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1736,1 +1736,1 @@\n-      QuickSort::sort(methods->data(), length, func, \/*idempotent=*\/false);\n+      QuickSort::sort(methods->data(), length, func);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,15 @@\n+  void copy_from(const ResolvedMethodEntry& other) {\n+    _method = other._method;\n+    _entry_specific = other._entry_specific;\n+    _cpool_index = other._cpool_index;\n+    _number_of_parameters = other._number_of_parameters;\n+    _tos_state = other._tos_state;\n+    _flags = other._flags;\n+    _bytecode1 = other._bytecode1;\n+    _bytecode2 = other._bytecode2;\n+#ifdef ASSERT\n+    _has_interface_klass = other._has_interface_klass;\n+    _has_table_index = other._has_table_index;\n+#endif\n+  }\n+\n@@ -102,0 +117,10 @@\n+    ResolvedMethodEntry(const ResolvedMethodEntry& other) {\n+      copy_from(other);\n+    }\n+\n+    ResolvedMethodEntry& operator=(const ResolvedMethodEntry& other) {\n+      copy_from(other);\n+      return *this;\n+    }\n+\n+\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1953,0 +1953,16 @@\n+\/\/ Check that all locks\/unlocks associated with object come from balanced regions.\n+bool AbstractLockNode::is_balanced() {\n+  Node* obj = obj_node();\n+  for (uint j = 0; j < obj->outcnt(); j++) {\n+    Node* n = obj->raw_out(j);\n+    if (n->is_AbstractLock() &&\n+        n->as_AbstractLock()->obj_node()->eqv_uncast(obj)) {\n+      BoxLockNode* n_box = n->as_AbstractLock()->box_node()->as_BoxLock();\n+      if (n_box->is_unbalanced()) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2059,0 +2075,2 @@\n+            tty->print(\"Obj: \");\n+            obj_node()->dump();\n@@ -2067,0 +2085,2 @@\n+              tty->print(\"Box %d: \", i);\n+              box_node()->dump();\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1157,0 +1157,4 @@\n+  \/\/ Check that all locks\/unlocks associated with object come from balanced regions.\n+  \/\/ They can become unbalanced after coarsening optimization or on OSR entry.\n+  bool is_balanced();\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+enum class AssertionPredicateType;\n@@ -321,0 +322,13 @@\n+ public:\n+  float _prob;                           \/\/ Probability of true path being taken.\n+  float _fcnt;                           \/\/ Frequency counter\n+\n+ private:\n+  NOT_PRODUCT(AssertionPredicateType _assertion_predicate_type;)\n+\n+  void init_node(Node* control, Node* bol) {\n+    init_class_id(Class_If);\n+    init_req(0, control);\n+    init_req(1, bol);\n+  }\n+\n@@ -325,1 +339,0 @@\n-private:\n@@ -416,8 +429,2 @@\n-  float _prob;                  \/\/ Probability of true path being taken.\n-  float _fcnt;                  \/\/ Frequency counter\n-  IfNode( Node *control, Node *b, float p, float fcnt )\n-    : MultiBranchNode(2), _prob(p), _fcnt(fcnt) {\n-    init_class_id(Class_If);\n-    init_req(0,control);\n-    init_req(1,b);\n-  }\n+  IfNode(Node* control, Node* bol, float p, float fcnt);\n+  NOT_PRODUCT(IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);)\n@@ -453,1 +460,1 @@\n-  int is_range_check(Node* &range, Node* &index, jint &offset);\n+  int is_range_check(Node*& range, Node*& index, jint& offset);\n@@ -456,2 +463,7 @@\n-  RangeCheckNode(Node* control, Node *b, float p, float fcnt)\n-    : IfNode(control, b, p, fcnt) {\n+  RangeCheckNode(Node* control, Node* bol, float p, float fcnt) : IfNode(control, bol, p, fcnt) {\n+    init_class_id(Class_RangeCheck);\n+  }\n+\n+#ifndef PRODUCT\n+  RangeCheckNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type)\n+      : IfNode(control, bol, p, fcnt, assertion_predicate_type) {\n@@ -460,0 +472,1 @@\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -577,1 +577,5 @@\n-          if (iff->Opcode() == Op_If && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp()) {\n+          \/\/ We may have Opaque4 node between If and Bool nodes.\n+          \/\/ Bail out in such case - we need to preserve Opaque4 for correct\n+          \/\/ processing predicates after loop opts.\n+          bool can_reduce = (iff->Opcode() == Op_If) && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp();\n+          if (can_reduce) {\n@@ -580,1 +584,3 @@\n-            if ((opc == Op_CmpP || opc == Op_CmpN) && !can_reduce_cmp(n, iff_cmp)) {\n+            can_reduce = (opc == Op_CmpP || opc == Op_CmpN) && can_reduce_cmp(n, iff_cmp);\n+          }\n+          if (!can_reduce) {\n@@ -582,6 +588,3 @@\n-              if (TraceReduceAllocationMerges) {\n-                tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP %d doesn't have simple control.\", n->_idx, _invocation, use->_idx);\n-                n->dump(5);\n-              }\n-#endif\n-              return false;\n+            if (TraceReduceAllocationMerges) {\n+              tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP %d doesn't have simple control.\", n->_idx, _invocation, use->_idx);\n+              n->dump(5);\n@@ -589,0 +592,2 @@\n+#endif\n+            return false;\n@@ -654,1 +659,6 @@\n-    Node* curr_cmp = curr_ctrl->in(0)->in(1)->in(1); \/\/ true\/false -> if -> bool -> cmp\n+    \/\/ can_reduce_check_users() verified graph: true\/false -> if -> bool -> cmp\n+    assert(curr_ctrl->in(0)->Opcode() == Op_If, \"unexpected node %s\", curr_ctrl->in(0)->Name());\n+    Node* bol = curr_ctrl->in(0)->in(1);\n+    assert(bol->is_Bool(), \"unexpected node %s\", bol->Name());\n+    Node* curr_cmp = bol->in(1);\n+    assert(curr_cmp->Opcode() == Op_CmpP || curr_cmp->Opcode() == Op_CmpN, \"unexpected node %s\", curr_cmp->Name());\n@@ -3505,2 +3515,1 @@\n-  BoxLockNode* box = alock->box_node()->as_BoxLock();\n-  if (!box->is_unbalanced() && not_global_escape(alock->obj_node())) {\n+  if (alock->is_balanced() && not_global_escape(alock->obj_node())) {\n@@ -3510,1 +3519,1 @@\n-      box->set_local();\n+      alock->box_node()->as_BoxLock()->set_local();\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -50,0 +50,18 @@\n+IfNode::IfNode(Node* control, Node* bol, float p, float fcnt)\n+    : MultiBranchNode(2),\n+      _prob(p),\n+      _fcnt(fcnt)\n+      NOT_PRODUCT(COMMA _assertion_predicate_type(AssertionPredicateType::None)) {\n+  init_node(control, bol);\n+}\n+\n+#ifndef PRODUCT\n+IfNode::IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type)\n+    : MultiBranchNode(2),\n+      _prob(p),\n+      _fcnt(fcnt),\n+      _assertion_predicate_type(assertion_predicate_type) {\n+  init_node(control, bol);\n+}\n+#endif \/\/ NOT_PRODUCT\n+\n@@ -1825,3 +1843,15 @@\n-\/\/------------------------------dump_spec--------------------------------------\n-void IfNode::dump_spec(outputStream *st) const {\n-  st->print(\"P=%f, C=%f\",_prob,_fcnt);\n+void IfNode::dump_spec(outputStream* st) const {\n+  switch (_assertion_predicate_type) {\n+    case AssertionPredicateType::Init_value:\n+      st->print(\"#Init Value Assertion Predicate  \");\n+      break;\n+    case AssertionPredicateType::Last_value:\n+      st->print(\"#Last Value Assertion Predicate  \");\n+      break;\n+    case AssertionPredicateType::None:\n+      \/\/ No Assertion Predicate\n+      break;\n+    default:\n+      fatal(\"Unknown Assertion Predicate type\");\n+  }\n+  st->print(\"P=%f, C=%f\", _prob, _fcnt);\n@@ -1829,1 +1859,1 @@\n-#endif\n+#endif \/\/ NOT PRODUCT\n@@ -2184,0 +2214,3 @@\n+  if (_useless) {\n+    st->print(\"#useless \");\n+  }\n@@ -2185,1 +2218,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -7583,2 +7583,0 @@\n-  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  set_result(result);\n@@ -7684,1 +7682,1 @@\n-    state = get_state_from_digest_object(digestBase_obj, T_BYTE);\n+    state = get_state_from_digest_object(digestBase_obj, T_LONG);\n@@ -7784,1 +7782,1 @@\n-      elem_type = T_BYTE;\n+      elem_type = T_LONG;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n@@ -125,1 +125,3 @@\n-  virtual void dump_spec(outputStream *st) const { st->print(\"  Lock %d\",_slot); }\n+  virtual void dump_spec(outputStream *st) const {\n+    st->print(\"  Lock slot: %d, Kind: %s\", _slot, _kind_name[(int)_kind]);\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs) {\n+                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs\n+                                                        NOT_PRODUCT (COMMA AssertionPredicateType assertion_predicate_type)) {\n@@ -146,1 +147,2 @@\n-      new_iff = new IfNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt);\n+      new_iff = new IfNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt\n+                           NOT_PRODUCT(COMMA assertion_predicate_type));\n@@ -149,1 +151,2 @@\n-      new_iff = new RangeCheckNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt);\n+      new_iff = new RangeCheckNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt\n+                                   NOT_PRODUCT(COMMA assertion_predicate_type));\n@@ -1155,1 +1158,0 @@\n-  IfProjNode* new_predicate_proj = nullptr;\n@@ -1166,4 +1168,3 @@\n-    new_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr,\n-                                                     reason,\n-                                                     iff->Opcode());\n-    Node* ctrl = new_predicate_proj->in(0)->as_If()->in(0);\n+    IfProjNode* hoisted_check_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason,\n+                                                                           iff->Opcode());\n+    Node* ctrl = hoisted_check_predicate_proj->in(0)->as_If()->in(0);\n@@ -1180,1 +1181,1 @@\n-    IfNode* new_predicate_iff = new_predicate_proj->in(0)->as_If();\n+    IfNode* new_predicate_iff = hoisted_check_predicate_proj->in(0)->as_If();\n@@ -1184,1 +1185,6 @@\n-    C->print_method(PHASE_AFTER_LOOP_PREDICATION_IC, 4, new_predicate_proj->in(0));\n+    invar.map_ctrl(if_success_proj, hoisted_check_predicate_proj); \/\/ Mark hoisted check as invariant\n+\n+    \/\/ Eliminate the old If in the loop body.\n+    dominated_by(hoisted_check_predicate_proj, iff, negated);\n+\n+    C->print_method(PHASE_AFTER_LOOP_PREDICATION_IC, 4, hoisted_check_predicate_proj->in(0));\n@@ -1196,1 +1202,0 @@\n-    range_check_predicate = true;\n@@ -1200,0 +1205,1 @@\n+    IfTrueNode* hoisted_check_proj = if_success_proj->as_IfTrue();\n@@ -1268,2 +1274,10 @@\n-    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_success_proj, parse_predicate_proj, upper_bound_proj, scale,\n-                                                          offset, init, limit, stride, rng, overflow, reason);\n+    IfTrueNode* template_assertion_predicate_proj =\n+        add_template_assertion_predicate(iff, loop, hoisted_check_proj, parse_predicate_proj, upper_bound_proj, scale,\n+                                         offset, init, limit, stride, rng, overflow, reason);\n+\n+    \/\/ Eliminate the old range check in the loop body.\n+    \/\/ When a range check is eliminated, data dependent nodes (Load and range check CastII nodes) are now dependent on 2\n+    \/\/ Hoisted Check Predicates (one for the start of the loop, one for the end) but we can only keep track of one control\n+    \/\/ dependency: pin the data dependent nodes.\n+    eliminate_hoisted_range_check(hoisted_check_proj, template_assertion_predicate_proj);\n+    invar.map_ctrl(hoisted_check_proj, template_assertion_predicate_proj); \/\/ Mark hoisted check as invariant\n@@ -1271,1 +1285,1 @@\n-    C->print_method(PHASE_AFTER_LOOP_PREDICATION_RC, 4, new_predicate_proj->in(0));\n+    C->print_method(PHASE_AFTER_LOOP_PREDICATION_RC, 4, template_assertion_predicate_proj->in(0));\n@@ -1284,9 +1298,0 @@\n-  assert(new_predicate_proj != nullptr, \"sanity\");\n-  \/\/ Success - attach condition (new_predicate_bol) to predicate if\n-  invar.map_ctrl(if_success_proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n-\n-  \/\/ Eliminate the old If in the loop body\n-  \/\/ If a range check is eliminated, data dependent nodes (Load and range check CastII nodes) are now dependent on 2\n-  \/\/ Hoisted Check Predicates (one for the start of the loop, one for the end) but we can only keep track of one control\n-  \/\/ dependency: pin the data dependent nodes.\n-  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con, range_check_predicate);\n@@ -1298,0 +1303,6 @@\n+void PhaseIdealLoop::eliminate_hoisted_range_check(IfTrueNode* hoisted_check_proj,\n+                                                   IfTrueNode* template_assertion_predicate_proj) {\n+  _igvn.replace_input_of(hoisted_check_proj->in(0), 1, _igvn.intcon(1));\n+  rewire_safe_outputs_to_dominator(hoisted_check_proj, template_assertion_predicate_proj, true);\n+}\n+\n@@ -1301,1 +1312,1 @@\n-IfProjNode* PhaseIdealLoop::add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n+IfTrueNode* PhaseIdealLoop::add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n@@ -1315,1 +1326,2 @@\n-  IfProjNode* new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+  IfTrueNode* new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode(),\n+                                                     false NOT_PRODUCT(COMMA AssertionPredicateType::Init_value));\n@@ -1340,1 +1352,2 @@\n-  new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+  new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode(),\n+                                         false NOT_PRODUCT(COMMA AssertionPredicateType::Last_value));\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":39,"deletions":26,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2772,4 +2772,3 @@\n-Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* ctrl,\n-                                                                      const int scale_con, Node* offset, Node* limit,\n-                                                                      jint stride_con, Node* value,\n-                                                                      const bool is_template) {\n+Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(\n+    IdealLoopTree* loop, Node* ctrl, const int scale_con, Node* offset, Node* limit, jint stride_con, Node* value,\n+    const bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n@@ -2996,2 +2995,3 @@\n-          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                       int_limit, stride_con, opaque_init, true);\n+          loop_entry = add_range_check_elimination_assertion_predicate(\n+              loop, loop_entry, scale_con, int_offset, int_limit, stride_con, opaque_init, true\n+              NOT_PRODUCT(COMMA AssertionPredicateType::Init_value));\n@@ -3009,2 +3009,3 @@\n-          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                       int_limit, stride_con, max_value, true);\n+          loop_entry = add_range_check_elimination_assertion_predicate(\n+              loop, loop_entry, scale_con, int_offset, int_limit, stride_con, max_value, true\n+              NOT_PRODUCT(COMMA AssertionPredicateType::Last_value));\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1342,3 +1342,4 @@\n-  IfTrueNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n-                                          Deoptimization::DeoptReason reason, int opcode,\n-                                          bool rewire_uncommon_proj_phi_inputs = false);\n+  IfTrueNode* create_new_if_for_predicate(\n+      ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason, int opcode,\n+      bool rewire_uncommon_proj_phi_inputs = false\n+      NOT_PRODUCT (COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n@@ -1380,1 +1381,1 @@\n-  IfProjNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n+  IfTrueNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n@@ -1384,3 +1385,4 @@\n-  Node* add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* predicate_proj, int scale_con,\n-                                                        Node* offset, Node* limit, int stride_con, Node* value,\n-                                                        bool is_template);\n+  void eliminate_hoisted_range_check(IfTrueNode* hoisted_check_proj, IfTrueNode* template_assertion_predicate_proj);\n+  Node* add_range_check_elimination_assertion_predicate(\n+      IdealLoopTree* loop, Node* predicate_proj, int scale_con, Node* offset, Node* limit, int stride_con, Node* value,\n+      bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n@@ -1538,0 +1540,1 @@\n+  void rewire_safe_outputs_to_dominator(Node* source, Node* dominator, bool pin_array_access_nodes);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -343,1 +343,3 @@\n-  if (iff->outcnt() != 2) return;\n+  if (iff->outcnt() != 2) {\n+    return;\n+  }\n@@ -350,1 +352,1 @@\n-  if (dp == nullptr)\n+  if (dp == nullptr) {\n@@ -352,0 +354,4 @@\n+  }\n+\n+  rewire_safe_outputs_to_dominator(dp, prevdom, pin_array_access_nodes);\n+}\n@@ -353,1 +359,2 @@\n-  IdealLoopTree* old_loop = get_loop(dp);\n+void PhaseIdealLoop::rewire_safe_outputs_to_dominator(Node* source, Node* dominator, const bool pin_array_access_nodes) {\n+  IdealLoopTree* old_loop = get_loop(source);\n@@ -355,2 +362,2 @@\n-  for (DUIterator_Fast imax, i = dp->fast_outs(imax); i < imax; i++) {\n-    Node* cd = dp->fast_out(i); \/\/ Control-dependent node\n+  for (DUIterator_Fast imax, i = source->fast_outs(imax); i < imax; i++) {\n+    Node* out = source->fast_out(i); \/\/ Control-dependent node\n@@ -358,3 +365,3 @@\n-    if (cd->depends_only_on_test() && _igvn.no_dependent_zero_check(cd)) {\n-      assert(cd->in(0) == dp, \"\");\n-      _igvn.replace_input_of(cd, 0, prevdom);\n+    if (out->depends_only_on_test() && _igvn.no_dependent_zero_check(out)) {\n+      assert(out->in(0) == source, \"must be control dependent on source\");\n+      _igvn.replace_input_of(out, 0, dominator);\n@@ -368,1 +375,1 @@\n-        Node* clone = cd->pin_array_access_node();\n+        Node* clone = out->pin_array_access_node();\n@@ -370,3 +377,3 @@\n-          clone = _igvn.register_new_node_with_optimizer(clone, cd);\n-          _igvn.replace_node(cd, clone);\n-          cd = clone;\n+          clone = _igvn.register_new_node_with_optimizer(clone, out);\n+          _igvn.replace_node(out, clone);\n+          out = clone;\n@@ -375,2 +382,2 @@\n-      set_early_ctrl(cd, false);\n-      IdealLoopTree* new_loop = get_loop(get_ctrl(cd));\n+      set_early_ctrl(out, false);\n+      IdealLoopTree* new_loop = get_loop(get_ctrl(out));\n@@ -379,1 +386,1 @@\n-          old_loop->_body.yank(cd);\n+          old_loop->_body.yank(out);\n@@ -382,1 +389,1 @@\n-          new_loop->_body.push(cd);\n+          new_loop->_body.push(out);\n@@ -798,3 +805,11 @@\n-  \/\/ Ignore cost if CMOVE can be moved outside the loop.\n-  if (used_inside_loop && cost >= ConditionalMoveLimit) {\n-    return nullptr;\n+  float infrequent_prob = PROB_UNLIKELY_MAG(3);\n+  \/\/ Ignore cost and blocks frequency if CMOVE can be moved outside the loop.\n+  if (used_inside_loop) {\n+    if (cost >= ConditionalMoveLimit) return nullptr; \/\/ Too much goo\n+\n+    \/\/ BlockLayoutByFrequency optimization moves infrequent branch\n+    \/\/ from hot path. No point in CMOV'ing in such case (110 is used\n+    \/\/ instead of 100 to take into account not exactness of float value).\n+    if (BlockLayoutByFrequency) {\n+      infrequent_prob = MAX2(infrequent_prob, (float)BlockLayoutMinDiamondPercentage\/110.0f);\n+    }\n@@ -804,1 +819,0 @@\n-  constexpr float infrequent_prob = PROB_UNLIKELY_MAG(2);\n@@ -807,1 +821,2 @@\n-  } else if (iff->_prob < infrequent_prob || iff->_prob > (1.0f - infrequent_prob)) {\n+  } else if (iff->_prob < infrequent_prob ||\n+      iff->_prob > (1.0f - infrequent_prob))\n@@ -809,1 +824,0 @@\n-  }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":36,"deletions":22,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2048,1 +2048,1 @@\n-  if (alock->box_node()->as_BoxLock()->is_unbalanced()) {\n+  if (!alock->is_balanced()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -196,0 +196,9 @@\n+#ifndef PRODUCT\n+\/\/ Assertion Predicates are either emitted to check the initial value of a range check in the first iteration or the last\n+\/\/ value of a range check in the last iteration of a loop.\n+enum class AssertionPredicateType {\n+  None, \/\/ Not an Assertion Predicate\n+  Init_value,\n+  Last_value\n+};\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1438,2 +1438,2 @@\n-  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ carry bits in output\n-  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n@@ -1458,1 +1458,1 @@\n-  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012 Red Hat, Inc.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 Red Hat, Inc.\n@@ -3778,1 +3778,1 @@\n-  JavaThread* thread = new JavaThread(true);\n+  JavaThread* thread = JavaThread::create_attaching_thread();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2342,1 +2342,1 @@\n-  ClassLoaderDataGraph::modules_do(&do_module);\n+  ClassLoaderDataGraph::modules_do_keepalive(&do_module);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    ClassLoaderDataGraph::loaded_classes_do(&closure);\n+    ClassLoaderDataGraph::loaded_classes_do_keepalive(&closure);\n","filename":"src\/hotspot\/share\/prims\/jvmtiGetLoadedClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -508,0 +508,1 @@\n+  { \"LockingMode\",                  JDK_Version::jdk(24), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n@@ -524,0 +525,1 @@\n+  { \"UseVtableBasedCHA\",               JDK_Version::undefined(), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -971,3 +971,0 @@\n-  product(bool, UseVtableBasedCHA, true,  DIAGNOSTIC,                       \\\n-          \"Use vtable information during CHA\")                              \\\n-                                                                            \\\n@@ -1960,3 +1957,3 @@\n-          \"Select locking mode: \"                                           \\\n-          \"0: monitors only (LM_MONITOR), \"                                 \\\n-          \"1: monitors & legacy stack-locking (LM_LEGACY), \"                \\\n+          \"(Deprecated) Select locking mode: \"                              \\\n+          \"0: (Deprecated) monitors only (LM_MONITOR), \"                    \\\n+          \"1: (Deprecated) monitors & legacy stack-locking (LM_LEGACY), \"   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,1 @@\n-  HandleArea(HandleArea* prev) : Arena(mtThread, Tag::tag_ha, Chunk::tiny_size) {\n+  HandleArea(MEMFLAGS flags, HandleArea* prev) : Arena(flags, Tag::tag_ha, Chunk::tiny_size) {\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -412,1 +412,2 @@\n-JavaThread::JavaThread() :\n+JavaThread::JavaThread(MEMFLAGS flags) :\n+  Thread(flags),\n@@ -414,1 +415,0 @@\n-\n@@ -528,4 +528,4 @@\n-JavaThread::JavaThread(bool is_attaching_via_jni) : JavaThread() {\n-  if (is_attaching_via_jni) {\n-    _jni_attach_state = _attaching_via_jni;\n-  }\n+JavaThread* JavaThread::create_attaching_thread() {\n+  JavaThread* jt = new JavaThread();\n+  jt->_jni_attach_state = _attaching_via_jni;\n+  return jt;\n@@ -534,1 +534,0 @@\n-\n@@ -637,2 +636,1 @@\n-JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) : JavaThread() {\n-  _jni_attach_state = _not_attaching_via_jni;\n+JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz, MEMFLAGS flags) : JavaThread(flags) {\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -481,3 +481,2 @@\n-  JavaThread();                            \/\/ delegating constructor\n-  JavaThread(bool is_attaching_via_jni);   \/\/ for main thread and JNI attached threads\n-  JavaThread(ThreadFunction entry_point, size_t stack_size = 0);\n+  JavaThread(MEMFLAGS flags = mtThread);   \/\/ delegating constructor\n+  JavaThread(ThreadFunction entry_point, size_t stack_size = 0, MEMFLAGS flags = mtThread);\n@@ -486,0 +485,3 @@\n+  \/\/ Factory method to create a new JavaThread whose attach state is \"is attaching\"\n+  static JavaThread* create_attaching_thread();\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,0 +81,4 @@\n+#ifdef LINUX\n+#include \"osContainer_linux.hpp\"\n+#endif\n+\n@@ -275,7 +279,0 @@\n-#if !defined(LINUX) && !defined(_WINDOWS)\n-bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n-  committed_start = start;\n-  committed_size = size;\n-  return true;\n-}\n-#endif\n@@ -2067,0 +2064,13 @@\n+julong os::used_memory() {\n+#ifdef LINUX\n+  if (OSContainer::is_containerized()) {\n+    jlong mem_usage = OSContainer::memory_usage_in_bytes();\n+    if (mem_usage > 0) {\n+      return mem_usage;\n+    }\n+  }\n+#endif\n+  return os::physical_memory() - os::available_memory();\n+}\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -339,0 +339,1 @@\n+  static julong used_memory();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1339,1 +1339,1 @@\n-           callee_method->method_holder()->is_init_thread(current),\n+           callee_method->method_holder()->is_reentrant_initialization(current),\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -824,0 +824,10 @@\n+void ObjectSynchronizer::waitUninterruptibly(Handle obj, jlong millis, TRAPS) {\n+  if (millis < 0) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"timeout value is negative\");\n+  }\n+  ObjectSynchronizer::inflate(THREAD,\n+                              obj(),\n+                              inflate_cause_wait)->wait(millis, false, THREAD);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -122,0 +122,5 @@\n+  \/\/ Special internal-use-only method for use by JVM infrastructure\n+  \/\/ that needs to wait() on a java-level object but that can't risk\n+  \/\/ throwing unexpected InterruptedExecutionExceptions.\n+  static void waitUninterruptibly(Handle obj, jlong Millis, TRAPS);\n+\n@@ -228,0 +233,1 @@\n+  void wait_uninterruptibly(TRAPS)  { ObjectSynchronizer::waitUninterruptibly(_obj, 0, CHECK); } \/\/ wait forever\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-Thread::Thread() {\n+Thread::Thread(MEMFLAGS flags) {\n@@ -81,1 +81,1 @@\n-  set_resource_area(new (mtThread)ResourceArea());\n+  set_resource_area(new (flags) ResourceArea(flags));\n@@ -83,1 +83,1 @@\n-  set_handle_area(new (mtThread) HandleArea(nullptr));\n+  set_handle_area(new (flags) HandleArea(flags, nullptr));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -280,1 +280,1 @@\n-  Thread();\n+  Thread(MEMFLAGS flag = mtThread);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -821,1 +821,1 @@\n-    MetaspaceShared::preload_and_dump();\n+    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -208,2 +208,3 @@\n-    else if (thread()->osthread()->get_state() == CONDVAR_WAIT) {\n-      \/\/ We are waiting on the native class initialization monitor.\n+    else if (thread()->osthread()->get_state() == OBJECT_WAIT) {\n+      \/\/ We are waiting on an Object monitor but Object.wait() isn't the\n+      \/\/ top-frame, so we should be waiting on a Class initialization monitor.\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -249,0 +249,1 @@\n+  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n@@ -2166,1 +2167,0 @@\n-  declare_constant(InstanceKlass::being_linked)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -995,1 +995,1 @@\n-  VM_PrintClasses vmop(output(), _verbose.is_set());\n+  VM_PrintClasses vmop(output(), _verbose.value());\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1092,0 +1092,8 @@\n+  \/\/ Also provide a pointer to the init_lock if present, so there aren't unreferenced int[0]\n+  \/\/ arrays.\n+  oop init_lock = ik->init_lock();\n+  if (init_lock != nullptr) {\n+    field_count++;\n+    size += sizeof(address);\n+  }\n+\n@@ -1129,0 +1137,8 @@\n+\n+  \/\/ Add init lock to the end if the class is not yet initialized\n+  oop init_lock = ik->init_lock();\n+  if (init_lock != nullptr) {\n+    writer->write_symbolID(vmSymbols::init_lock_name());         \/\/ name\n+    writer->write_u1(sig2tag(vmSymbols::int_array_signature())); \/\/ type\n+    writer->write_objectID(init_lock);\n+  }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,3 +75,2 @@\n-void NativeCallStack::print_on(outputStream* out) const {\n-  DEBUG_ONLY(assert_not_fake();)\n-  address pc;\n+\n+void NativeCallStack::print_frame(outputStream* out, address pc) const {\n@@ -80,26 +79,15 @@\n-  if (is_empty()) {\n-    out->print(\"[BOOTSTRAP]\");\n-  } else {\n-    for (int frame = 0; frame < NMT_TrackingStackDepth; frame ++) {\n-      pc = get_frame(frame);\n-      if (pc == nullptr) break;\n-      out->print(\"[\" PTR_FORMAT \"]\", p2i(pc));\n-      \/\/ Print function and library; shorten library name to just its last component\n-      \/\/ for brevity, and omit it completely for libjvm.so\n-      bool function_printed = false;\n-      if (os::dll_address_to_function_name(pc, buf, sizeof(buf), &offset)) {\n-        out->print(\"%s+0x%x\", buf, offset);\n-        function_printed = true;\n-      }\n-      if ((!function_printed || !os::address_is_in_vm(pc)) &&\n-          os::dll_address_to_library_name(pc, buf, sizeof(buf), &offset)) {\n-        const char* libname = strrchr(buf, os::file_separator()[0]);\n-        if (libname != nullptr) {\n-          libname++;\n-        } else {\n-          libname = buf;\n-        }\n-        out->print(\" in %s\", libname);\n-        if (!function_printed) {\n-          out->print(\"+0x%x\", offset);\n-        }\n+  int     line;\n+  const bool pc_in_VM = os::address_is_in_vm(pc);\n+  out->print(\"[\" PTR_FORMAT \"]\", p2i(pc));\n+  \/\/ Print function and library; shorten library name to just its last component\n+  \/\/ for brevity, and omit it completely for libjvm.so\n+  bool function_printed = false;\n+  if (os::dll_address_to_function_name(pc, buf, sizeof(buf), &offset)) {\n+    out->print(\"%s+0x%x\", buf, offset);\n+    function_printed = true;\n+    if (Decoder::get_source_info(pc, buf, sizeof(buf), &line, false)) {\n+      \/\/ For intra-vm functions, we omit the full path\n+      const char* s = buf;\n+      if (pc_in_VM) {\n+        s = strrchr(s, os::file_separator()[0]);\n+        s = (s != nullptr) ? s + 1 : buf;\n@@ -107,6 +95,14 @@\n-\n-      \/\/ Note: we deliberately omit printing source information here. NativeCallStack::print_on()\n-      \/\/ can be called thousands of times as part of NMT detail reporting, and source printing\n-      \/\/ can slow down reporting by a factor of 5 or more depending on platform (see JDK-8296931).\n-\n-      out->cr();\n+      out->print(\"   (%s:%d)\", s, line);\n+    }\n+  }\n+  if ((!function_printed || !pc_in_VM) &&\n+      os::dll_address_to_library_name(pc, buf, sizeof(buf), &offset)) {\n+    const char* libname = strrchr(buf, os::file_separator()[0]);\n+    if (libname != nullptr) {\n+      libname++;\n+    } else {\n+      libname = buf;\n+    }\n+    out->print(\" in %s\", libname);\n+    if (!function_printed) {\n+      out->print(\"+0x%x\", offset);\n@@ -116,0 +112,8 @@\n+\n+void NativeCallStack::print_on(outputStream* out) const {\n+  DEBUG_ONLY(assert_not_fake();)\n+  for (int i = 0; i < NMT_TrackingStackDepth && _stack[i] != nullptr; i++) {\n+    print_frame(out, _stack[i]);\n+  }\n+  out->cr();\n+}\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":40,"deletions":36,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -126,0 +127,1 @@\n+  void print_frame(outputStream* out, address pc) const;\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"runtime\/globals.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -36,4 +36,2 @@\n-  static void swap(T* array, size_t x, size_t y) {\n-    T tmp = array[x];\n-    array[x] = array[y];\n-    array[y] = tmp;\n+  static void swap_elements(T* array, size_t x, size_t y) {\n+    swap(array[x], array[y]);\n@@ -43,3 +41,1 @@\n-  \/\/ We swap in these three values at the right place in the array. This\n-  \/\/ means that this method not only returns the index of the pivot\n-  \/\/ element. It also alters the array so that:\n+  \/\/ We swap these three values as needed so that\n@@ -47,1 +43,3 @@\n-  \/\/ A side effect of this is that arrays of length <= 3 are sorted.\n+  \/\/ As a result, the first and last elements are placed in the proper\n+  \/\/ partition, and arrays of length <= 3 are sorted.\n+  \/\/ The middle index is returned, designating that element as the pivot.\n@@ -56,1 +54,1 @@\n-      swap(array, 0, middle_index);\n+      swap_elements(array, 0, middle_index);\n@@ -59,1 +57,1 @@\n-      swap(array, 0, last_index);\n+      swap_elements(array, 0, last_index);\n@@ -62,1 +60,1 @@\n-      swap(array, middle_index, last_index);\n+      swap_elements(array, middle_index, last_index);\n@@ -65,1 +63,1 @@\n-    \/\/ of the fist, last and middle values. Use this as pivot.\n+    \/\/ of the first, last and middle values. Use this as pivot.\n@@ -69,1 +67,1 @@\n-  template<bool idempotent, class T, class C>\n+  template<class T, class C>\n@@ -77,1 +75,1 @@\n-        assert(left_index < length, \"reached end of partition\");\n+        assert(left_index < (length - 1), \"reached end of partition\");\n@@ -82,1 +80,0 @@\n-\n@@ -84,3 +81,1 @@\n-        if (!idempotent || comparator(array[left_index], array[right_index]) != 0) {\n-          swap(array, left_index, right_index);\n-        }\n+        swap_elements(array, left_index, right_index);\n@@ -91,3 +86,0 @@\n-\n-    ShouldNotReachHere();\n-    return 0;\n@@ -96,2 +88,3 @@\n-  template<bool idempotent, class T, class C>\n-  static void inner_sort(T* array, size_t length, C comparator) {\n+ public:\n+  template<class T, class C>\n+  static void sort(T* array, size_t length, C comparator) {\n@@ -106,1 +99,1 @@\n-    size_t split = partition<idempotent>(array, pivot, length, comparator);\n+    size_t split = partition(array, pivot, length, comparator);\n@@ -108,18 +101,2 @@\n-    inner_sort<idempotent>(array, first_part_length, comparator);\n-    inner_sort<idempotent>(&array[first_part_length], length - first_part_length, comparator);\n-  }\n-\n- public:\n-  \/\/ The idempotent parameter prevents the sort from\n-  \/\/ reordering a previous valid sort by not swapping\n-  \/\/ fields that compare as equal. This requires extra\n-  \/\/ calls to the comparator, so the performance\n-  \/\/ impact depends on the comparator.\n-  template<class T, class C>\n-  static void sort(T* array, size_t length, C comparator, bool idempotent) {\n-    \/\/ Switch \"idempotent\" from function parameter to template parameter\n-    if (idempotent) {\n-      inner_sort<true>(array, length, comparator);\n-    } else {\n-      inner_sort<false>(array, length, comparator);\n-    }\n+    sort(array, first_part_length, comparator);\n+    sort(&array[first_part_length], length - first_part_length, comparator);\n@@ -129,1 +106,0 @@\n-\n","filename":"src\/hotspot\/share\/utilities\/quickSort.hpp","additions":21,"deletions":45,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -888,5 +888,3 @@\n-        try {\n-            FloatToDecimal.appendTo(f, this);\n-        } catch (IOException e) {\n-            throw new AssertionError(e);\n-        }\n+        ensureCapacityInternal(count + FloatToDecimal.MAX_CHARS);\n+        FloatToDecimal toDecimal = isLatin1() ? FloatToDecimal.LATIN1 : FloatToDecimal.UTF16;\n+        count = toDecimal.putDecimal(value, count, f);\n@@ -894,1 +892,0 @@\n-\n@@ -910,5 +907,3 @@\n-        try {\n-            DoubleToDecimal.appendTo(d, this);\n-        } catch (IOException e) {\n-            throw new AssertionError(e);\n-        }\n+        ensureCapacityInternal(count + DoubleToDecimal.MAX_CHARS);\n+        DoubleToDecimal toDecimal = isLatin1() ? DoubleToDecimal.LATIN1 : DoubleToDecimal.UTF16;\n+        count = toDecimal.putDecimal(value, count, d);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n- *     MemoryLayout.paddingLayout(32),\n+ *     MemoryLayout.paddingLayout(4),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n- *     ... POINT_ARR_X.get(segment, 0L, (long)i) ...\n+ *     ... POINT_ARR_X.get(points, 0L, (long)i) ...\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.InnerClassLambdaMetafactory.MethodBody;\n@@ -42,0 +43,1 @@\n+import java.util.function.Consumer;\n@@ -69,0 +71,2 @@\n+    private static final Consumer<FieldBuilder> STATIC_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_STATIC);\n+    private static final Consumer<FieldBuilder> FINAL_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_FINAL);\n@@ -616,56 +620,61 @@\n-            return ClassFile.of().build(classDesc, clb -> {\n-                clb.withFlags(ACC_FINAL | ACC_SUPER)\n-                   .withSuperclass(superClassDesc)\n-                   .with(SourceFileAttribute.of(classDesc.displayName()))\n-\n-                \/\/ emit static types and BMH_SPECIES fields\n-                   .withField(sdFieldName, CD_SPECIES_DATA, ACC_STATIC);\n-\n-                \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n-                class Var {\n-                    final int index;\n-                    final String name;\n-                    final Class<?> type;\n-                    final ClassDesc desc;\n-                    final BasicType basicType;\n-                    final int slotIndex;\n-                    Var(int index, int slotIndex) {\n-                        this.index = index;\n-                        this.slotIndex = slotIndex;\n-                        name = null; type = null; desc = null;\n-                        basicType = BasicType.V_TYPE;\n-                    }\n-                    Var(String name, Class<?> type, Var prev) {\n-                        int slotIndex = prev.nextSlotIndex();\n-                        int index = prev.nextIndex();\n-                        if (name == null)  name = \"x\";\n-                        if (name.endsWith(\"#\"))\n-                            name = name.substring(0, name.length()-1) + index;\n-                        assert(!type.equals(void.class));\n-                        this.index = index;\n-                        this.name = name;\n-                        this.type = type;\n-                        this.desc = classDesc(type);\n-                        this.basicType = BasicType.basicType(type);\n-                        this.slotIndex = slotIndex;\n-                    }\n-                    Var lastOf(List<Var> vars) {\n-                        int n = vars.size();\n-                        return (n == 0 ? this : vars.get(n-1));\n-                    }\n-                    <X> List<Var> fromTypes(List<X> types) {\n-                        Var prev = this;\n-                        ArrayList<Var> result = new ArrayList<>(types.size());\n-                        int i = 0;\n-                        for (X x : types) {\n-                            String vn = name;\n-                            Class<?> vt;\n-                            if (x instanceof Class<?> cl) {\n-                                vt = cl;\n-                                \/\/ make the names friendlier if debugging\n-                                assert((vn = vn + \"_\" + (i++)) != null);\n-                            } else {\n-                                @SuppressWarnings(\"unchecked\")\n-                                Var v = (Var) x;\n-                                vn = v.name;\n-                                vt = v.type;\n+            return ClassFile.of().build(classDesc, new Consumer<ClassBuilder>() {\n+                @Override\n+                public void accept(ClassBuilder clb) {\n+                    clb.withFlags(ACC_FINAL | ACC_SUPER)\n+                       .withSuperclass(superClassDesc)\n+                       .with(SourceFileAttribute.of(classDesc.displayName()))\n+\n+                    \/\/ emit static types and BMH_SPECIES fields\n+                       .withField(sdFieldName, CD_SPECIES_DATA, STATIC_FIELD_FLAGS);\n+\n+                    \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n+                    class Var {\n+                        final int index;\n+                        final String name;\n+                        final Class<?> type;\n+                        final ClassDesc desc;\n+                        final BasicType basicType;\n+                        final int slotIndex;\n+                        Var(int index, int slotIndex) {\n+                            this.index = index;\n+                            this.slotIndex = slotIndex;\n+                            name = null; type = null; desc = null;\n+                            basicType = BasicType.V_TYPE;\n+                        }\n+                        Var(String name, Class<?> type, Var prev) {\n+                            int slotIndex = prev.nextSlotIndex();\n+                            int index = prev.nextIndex();\n+                            if (name == null)  name = \"x\";\n+                            if (name.endsWith(\"#\"))\n+                                name = name.substring(0, name.length()-1) + index;\n+                            assert(!type.equals(void.class));\n+                            this.index = index;\n+                            this.name = name;\n+                            this.type = type;\n+                            this.desc = classDesc(type);\n+                            this.basicType = BasicType.basicType(type);\n+                            this.slotIndex = slotIndex;\n+                        }\n+                        Var lastOf(List<Var> vars) {\n+                            int n = vars.size();\n+                            return (n == 0 ? this : vars.get(n-1));\n+                        }\n+                        <X> List<Var> fromTypes(List<X> types) {\n+                            Var prev = this;\n+                            ArrayList<Var> result = new ArrayList<>(types.size());\n+                            int i = 0;\n+                            for (X x : types) {\n+                                String vn = name;\n+                                Class<?> vt;\n+                                if (x instanceof Class<?> cl) {\n+                                    vt = cl;\n+                                    \/\/ make the names friendlier if debugging\n+                                    assert((vn = vn + \"_\" + (i++)) != null);\n+                                } else {\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    Var v = (Var) x;\n+                                    vn = v.name;\n+                                    vt = v.type;\n+                                }\n+                                prev = new Var(vn, vt, prev);\n+                                result.add(prev);\n@@ -673,2 +682,1 @@\n-                            prev = new Var(vn, vt, prev);\n-                            result.add(prev);\n+                            return result;\n@@ -676,37 +684,0 @@\n-                        return result;\n-                    }\n-\n-                    int slotSize() { return basicType.basicTypeSlots(); }\n-                    int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n-                    int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n-                    boolean isInHeap() { return slotIndex < 0; }\n-                    void emitLoadInstruction(CodeBuilder cob) {\n-                        cob.loadLocal(basicType.btKind, slotIndex);\n-                    }\n-                }\n-\n-                final Var NO_THIS = new Var(0, 0),\n-                        AFTER_THIS = new Var(0, 1),\n-                        IN_HEAP = new Var(0, -1);\n-\n-                \/\/ figure out the field types\n-                final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n-                final List<Var> fields = new ArrayList<>(fieldTypes.size());\n-                {\n-                    Var nextF = IN_HEAP;\n-                    for (Class<?> ft : fieldTypes) {\n-                        String fn = chooseFieldName(ft, nextF.nextIndex());\n-                        nextF = new Var(fn, ft, nextF);\n-                        fields.add(nextF);\n-                    }\n-                }\n-\n-                \/\/ emit bound argument fields\n-                for (Var field : fields) {\n-                    clb.withField(field.name, field.desc, ACC_FINAL);\n-                }\n-\n-                \/\/ emit implementation of speciesData()\n-                clb.withMethodBody(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n-                        cob -> cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n-                                  .areturn());\n@@ -714,11 +685,7 @@\n-                \/\/ figure out the constructor arguments\n-                MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n-                MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n-\n-                \/\/ emit constructor\n-                clb.withMethodBody(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE, cob -> {\n-                    cob.aload(0); \/\/ this\n-\n-                    final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n-                    for (Var ca : ctorArgs) {\n-                        ca.emitLoadInstruction(cob);\n+                        int slotSize() { return basicType.basicTypeSlots(); }\n+                        int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n+                        int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n+                        boolean isInHeap() { return slotIndex < 0; }\n+                        void emitLoadInstruction(CodeBuilder cob) {\n+                            cob.loadLocal(basicType.btKind, slotIndex);\n+                        }\n@@ -727,11 +694,14 @@\n-                    \/\/ super(ca...)\n-                    cob.invokespecial(superClassDesc, INIT_NAME, methodDesc(superCtorType));\n-\n-                    \/\/ store down fields\n-                    Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n-                    for (Var f : fields) {\n-                        \/\/ this.argL1 = argL1\n-                        cob.aload(0);  \/\/ this\n-                        lastFV = new Var(f.name, f.type, lastFV);\n-                        lastFV.emitLoadInstruction(cob);\n-                        cob.putfield(classDesc, f.name, f.desc);\n+                    final Var NO_THIS = new Var(0, 0),\n+                            AFTER_THIS = new Var(0, 1),\n+                            IN_HEAP = new Var(0, -1);\n+\n+                    \/\/ figure out the field types\n+                    final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n+                    final List<Var> fields = new ArrayList<>(fieldTypes.size());\n+                    {\n+                        Var nextF = IN_HEAP;\n+                        for (Class<?> ft : fieldTypes) {\n+                            String fn = chooseFieldName(ft, nextF.nextIndex());\n+                            nextF = new Var(fn, ft, nextF);\n+                            fields.add(nextF);\n+                        }\n@@ -740,12 +710,3 @@\n-                    cob.return_();\n-                });\n-\n-                \/\/ emit make()  ...factory method wrapping constructor\n-                MethodType ftryType = thisCtorType.changeReturnType(topClass());\n-                clb.withMethodBody(\"make\", methodDesc(ftryType), ACC_STATIC, cob -> {\n-                    \/\/ make instance\n-                    cob.new_(classDesc)\n-                       .dup();\n-                    \/\/ load factory method arguments:  ctarg... and arg...\n-                    for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n-                        v.emitLoadInstruction(cob);\n+                    \/\/ emit bound argument fields\n+                    for (Var field : fields) {\n+                        clb.withField(field.name, field.desc, FINAL_FIELD_FLAGS);\n@@ -754,40 +715,7 @@\n-                    \/\/ finally, invoke the constructor and return\n-                    cob.invokespecial(classDesc, INIT_NAME, methodDesc(thisCtorType))\n-                       .areturn();\n-                });\n-\n-                \/\/ For each transform, emit the customized override of the transform method.\n-                \/\/ This method mixes together some incoming arguments (from the transform's\n-                \/\/ static type signature) with the field types themselves, and passes\n-                \/\/ the resulting mish-mosh of values to a method handle produced by\n-                \/\/ the species itself.  (Typically this method handle is the factory\n-                \/\/ method of this species or a related one.)\n-                for (int i = 0; i < TRANSFORM_NAMES.size(); i++) {\n-                    final int whichtm = i;\n-                    final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n-                    final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n-                    final int        TMODS = TRANSFORM_MODS.get(whichtm);\n-                    clb.withMethod(TNAME, methodDesc(TTYPE), (TMODS & ACC_PPP) | ACC_FINAL, mb -> {\n-                        mb.with(ExceptionsAttribute.ofSymbols(CD_Throwable))\n-                          .withCode(cob -> {\n-                            \/\/ return a call to the corresponding \"transform helper\", something like this:\n-                            \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n-                            cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n-                               .loadConstant(whichtm)\n-                               .invokevirtual(CD_SPECIES_DATA, \"transformHelper\", MTD_TRANFORM_HELPER);\n-\n-                            List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n-                            List<Var> tfields = new ArrayList<>(fields);\n-                            \/\/ mix them up and load them for the transform helper:\n-                            List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n-                            ClassDesc[] helperTypes = new ClassDesc[helperArgs.size()];\n-                            for (int hi = 0; hi < helperTypes.length; hi++) {\n-                                Var ha = helperArgs.get(hi);\n-                                helperTypes[hi] = ha.basicType.basicTypeWrapper().basicClassDescriptor();\n-                                if (ha.isInHeap()) {\n-                                    assert(tfields.contains(ha));\n-                                    cob.aload(0);\n-                                    cob.getfield(classDesc, ha.name, ha.desc);\n-                                } else {\n-                                    assert(targs.contains(ha));\n-                                    ha.emitLoadInstruction(cob);\n+                    \/\/ emit implementation of speciesData()\n+                    clb.withMethod(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                                            .areturn();\n@@ -795,10 +723,108 @@\n-                            }\n-\n-                            \/\/ jump into the helper (which is probably a factory method)\n-                            final Class<?> rtype = TTYPE.returnType();\n-                            if (!rtype.isPrimitive()) {\n-                                cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", MethodTypeDescImpl.ofValidated(CD_Object, helperTypes))\n-                                   .checkcast(classDesc(rtype))\n-                                   .areturn();\n-                            } else {\n-                                throw newInternalError(\"NYI: transform of type \"+rtype);\n+                            }));\n+\n+                    \/\/ figure out the constructor arguments\n+                    MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n+                    MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n+\n+                    \/\/ emit constructor\n+                    clb.withMethod(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    cob.aload(0); \/\/ this\n+\n+                                    final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n+                                    for (Var ca : ctorArgs) {\n+                                        ca.emitLoadInstruction(cob);\n+                                    }\n+\n+                                    \/\/ super(ca...)\n+                                    cob.invokespecial(superClassDesc, INIT_NAME, methodDesc(superCtorType));\n+\n+                                    \/\/ store down fields\n+                                    Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n+                                    for (Var f : fields) {\n+                                        \/\/ this.argL1 = argL1\n+                                        cob.aload(0);  \/\/ this\n+                                        lastFV = new Var(f.name, f.type, lastFV);\n+                                        lastFV.emitLoadInstruction(cob);\n+                                        cob.putfield(classDesc, f.name, f.desc);\n+                                    }\n+\n+                                    cob.return_();\n+                                }\n+                            }));\n+\n+                    \/\/ emit make()  ...factory method wrapping constructor\n+                    MethodType ftryType = thisCtorType.changeReturnType(topClass());\n+                    clb.withMethod(\"make\", methodDesc(ftryType), ACC_STATIC,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    \/\/ make instance\n+                                    cob.new_(classDesc)\n+                                            .dup();\n+                                    \/\/ load factory method arguments:  ctarg... and arg...\n+                                    for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n+                                        v.emitLoadInstruction(cob);\n+                                    }\n+\n+                                    \/\/ finally, invoke the constructor and return\n+                                    cob.invokespecial(classDesc, INIT_NAME, methodDesc(thisCtorType))\n+                                            .areturn();\n+                                }\n+                            }));\n+\n+                    \/\/ For each transform, emit the customized override of the transform method.\n+                    \/\/ This method mixes together some incoming arguments (from the transform's\n+                    \/\/ static type signature) with the field types themselves, and passes\n+                    \/\/ the resulting mish-mosh of values to a method handle produced by\n+                    \/\/ the species itself.  (Typically this method handle is the factory\n+                    \/\/ method of this species or a related one.)\n+                    for (int i = 0; i < TRANSFORM_NAMES.size(); i++) {\n+                        final int whichtm = i;\n+                        final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n+                        final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n+                        final int        TMODS = TRANSFORM_MODS.get(whichtm);\n+                        clb.withMethod(TNAME, methodDesc(TTYPE), (TMODS & ACC_PPP) | ACC_FINAL, new Consumer<MethodBuilder>() {\n+                            @Override\n+                            public void accept(MethodBuilder mb) {\n+                                mb.with(ExceptionsAttribute.ofSymbols(CD_Throwable))\n+                                  .withCode(new Consumer<CodeBuilder>() {\n+                                    @Override\n+                                    public void accept(CodeBuilder cob) {\n+                                        \/\/ return a call to the corresponding \"transform helper\", something like this:\n+                                        \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n+                                        cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                                                .loadConstant(whichtm)\n+                                                .invokevirtual(CD_SPECIES_DATA, \"transformHelper\", MTD_TRANFORM_HELPER);\n+\n+                                        List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n+                                        List<Var> tfields = new ArrayList<>(fields);\n+                                        \/\/ mix them up and load them for the transform helper:\n+                                        List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n+                                        ClassDesc[] helperTypes = new ClassDesc[helperArgs.size()];\n+                                        for (int hi = 0; hi < helperTypes.length; hi++) {\n+                                            Var ha = helperArgs.get(hi);\n+                                            helperTypes[hi] = ha.basicType.basicTypeWrapper().basicClassDescriptor();\n+                                            if (ha.isInHeap()) {\n+                                                assert(tfields.contains(ha));\n+                                                cob.aload(0);\n+                                                cob.getfield(classDesc, ha.name, ha.desc);\n+                                            } else {\n+                                                assert(targs.contains(ha));\n+                                                ha.emitLoadInstruction(cob);\n+                                            }\n+                                        }\n+\n+                                        \/\/ jump into the helper (which is probably a factory method)\n+                                        final Class<?> rtype = TTYPE.returnType();\n+                                        if (!rtype.isPrimitive()) {\n+                                            cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", MethodTypeDescImpl.ofValidated(CD_Object, helperTypes))\n+                                                    .checkcast(classDesc(rtype))\n+                                                    .areturn();\n+                                        } else {\n+                                            throw newInternalError(\"NYI: transform of type \"+rtype);\n+                                        }\n+                                    }\n+                                });\n@@ -807,1 +833,1 @@\n-                    });\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":206,"deletions":180,"binary":false,"changes":386,"status":"modified"},{"patch":"@@ -511,2 +511,1 @@\n-        List<ProxyMethod> sigmethods = proxyMethods.computeIfAbsent(sig,\n-                _ -> new ArrayList<>(3));\n+        List<ProxyMethod> sigmethods = proxyMethodsFor(sig);\n@@ -534,0 +533,4 @@\n+    private List<ProxyMethod> proxyMethodsFor(String sig) {\n+        return proxyMethods.computeIfAbsent(sig, _ -> new ArrayList<>(3));\n+    }\n+\n@@ -540,4 +543,1 @@\n-        String sig = pm.shortSignature;\n-        List<ProxyMethod> sigmethods = proxyMethods.computeIfAbsent(sig,\n-                _ -> new ArrayList<>(3));\n-        sigmethods.add(pm);\n+        proxyMethodsFor(pm.shortSignature).add(pm);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-     *        domain parameters. See the ParameterSpec Names section in the\n+     *        domain parameters. See the ECGenParameterSpec section in the\n@@ -50,1 +50,1 @@\n-     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#parameterspec-names\">\n+     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#ecgenparameterspec\">\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/ECGenParameterSpec.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,4 +33,4 @@\n- * parameter set name. For example, NamedParameterSpec.X25519 represents the\n- * parameter set identified by the string \"X25519\". These strings are defined\n- * in the <a href=\n- * \"{@docRoot}\/..\/specs\/security\/standard-names.html#parameterspec-names\">\n+ * parameter set name. For example, {@code NamedParameterSpec.X25519}\n+ * represents the parameter set identified by the string \"X25519\". These\n+ * strings are defined in the <a href=\n+ * \"{@docRoot}\/..\/specs\/security\/standard-names.html#namedparameterspec\">\n@@ -80,1 +80,1 @@\n-     *        ParameterSpec Names section in the\n+     *        NamedParameterSpec section in the\n@@ -82,1 +82,1 @@\n-     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#parameterspec-names\">\n+     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#namedparameterspec\">\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/NamedParameterSpec.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,2 +121,13 @@\n-     * @param mdName       the algorithm name of the hash function\n-     * @param mgfName      the algorithm name of the mask generation function\n+     * @param mdName       the algorithm name of the hash function. See the\n+     *         PSSParameterSpec section of the\n+     *         <a href=\n+     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#pssparameterspec\">\n+     *         Java Security Standard Algorithm Names Specification<\/a>\n+     *         for information about standard names for the hash function.\n+     * @param mgfName      the algorithm name of the mask generation function.\n+     *         See the PSSParameterSpec section of the\n+     *         <a href=\n+     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#pssparameterspec\">\n+     *         Java Security Standard Algorithm Names Specification<\/a>\n+     *         for information about standard names for the mask generation\n+     *         function.\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/PSSParameterSpec.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1727,1 +1727,1 @@\n-                digitList, false, false, status);\n+                digitList, false, false, status).fullPos();\n@@ -1735,20 +1735,0 @@\n-\n-        \/\/ If parse integer only is true and the parsing is broken at\n-        \/\/ decimal point, then pass\/ignore all digits and move pointer\n-        \/\/ at the start of suffix, to process the suffix part\n-        if (isParseIntegerOnly() && position < text.length()\n-                && text.charAt(position) == symbols.getDecimalSeparator()) {\n-            position++; \/\/ Pass decimal character\n-            for (; position < text.length(); ++position) {\n-                char ch = text.charAt(position);\n-                int digit = ch - symbols.getZeroDigit();\n-                if (digit < 0 || digit > 9) {\n-                    digit = Character.digit(ch, 10);\n-                    \/\/ Parse all digit characters\n-                    if (!(digit >= 0 && digit <= 9)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n@@ -2375,0 +2355,2 @@\n+     * @implSpec This implementation does not set the {@code ParsePosition} index\n+     * to the position of the decimal symbol, but rather the end of the string.\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2153,4 +2153,1 @@\n-     *   <li> {@link #isParseIntegerOnly()} returns {@code true}, and the decimal\n-     *   separator is found\n-     *   <li> {@link #isGroupingUsed()} returns {@code true} and {@link\n-     *   #isParseIntegerOnly()} returns {@code false}, and the grouping\n+     *   <li> {@link #isGroupingUsed()} returns {@code true} and the grouping\n@@ -2382,1 +2379,2 @@\n-        position = subparseNumber(text, position, digits, true, isExponent, status);\n+        NumericPosition pos = subparseNumber(text, position, digits, true, isExponent, status);\n+        position = pos.fullPos;\n@@ -2425,3 +2423,9 @@\n-            \/\/ No failures, thus increment the index by the suffix\n-            parsePosition.index = position +\n-                    (gotPositive ? positiveSuffix.length() : negativeSuffix.length());\n+            \/\/ When parsing integer only, index should be int pos\n+            \/\/ If intPos is 0, the entire value was integer\n+            if (isParseIntegerOnly() && pos.intPos > 0) {\n+                parsePosition.index = pos.intPos;\n+            } else {\n+                \/\/ increment the index by the suffix\n+                parsePosition.index = position +\n+                        (gotPositive ? positiveSuffix.length() : negativeSuffix.length());\n+            }\n@@ -2440,0 +2444,13 @@\n+    \/**\n+     * NumericPosition is a helper record class that stores two indices of interest.\n+     * {@code fullPos} is either the first unparseable character or -1 in case\n+     * of no valid number parsed. {@code intPos} reflects the position of\n+     * a parsed decimal symbol, if one exists. When parsing with {@code isParseIntegerOnly()},\n+     * {@code fullPos} is used to match the suffix, and reset the {@code ParsePosition}\n+     * index to {@code intPos}.\n+     *\n+     * @param fullPos an index that reflects the full traversal of the numerical String\n+     * @param intPos an index that reflects the position of a parsed decimal symbol.\n+     *\/\n+    record NumericPosition(int fullPos, int intPos) {}\n+\n@@ -2452,2 +2469,2 @@\n-     * @return returns the position of the first unparseable character or\n-     *         -1 in case of no valid number parsed\n+     * @return returns a {@code NumericPosition} that stores both a full\n+     *         traversal index, and an int only index.\n@@ -2455,3 +2472,3 @@\n-    int subparseNumber(String text, int position,\n-                       DigitList digits, boolean checkExponent,\n-                       boolean isExponent, boolean[] status) {\n+    NumericPosition subparseNumber(String text, int position,\n+                                   DigitList digits, boolean checkExponent,\n+                                   boolean isExponent, boolean[] status) {\n@@ -2460,0 +2477,1 @@\n+        int intIndex = 0;\n@@ -2519,1 +2537,1 @@\n-                    return position;\n+                    return new NumericPosition(position, intIndex);\n@@ -2541,1 +2559,3 @@\n-                        digits.append((char)(digit + '0'));\n+                        if (!sawDecimal || !isParseIntegerOnly()) {\n+                            digits.append((char)(digit + '0'));\n+                        }\n@@ -2546,1 +2566,3 @@\n-                    digits.append((char)(digit + '0'));\n+                    if (!sawDecimal || !isParseIntegerOnly()) {\n+                        digits.append((char) (digit + '0'));\n+                    }\n@@ -2553,1 +2575,2 @@\n-                        return groupingViolationIndex(position, prevSeparatorIndex);\n+                        return new NumericPosition(\n+                                groupingViolationIndex(position, prevSeparatorIndex), intIndex);\n@@ -2557,1 +2580,1 @@\n-                    if (isParseIntegerOnly() || sawDecimal) {\n+                    if (sawDecimal) {\n@@ -2560,0 +2583,1 @@\n+                    intIndex = position;\n@@ -2566,1 +2590,1 @@\n-                            return startPos;\n+                            return new NumericPosition(startPos, intIndex);\n@@ -2571,1 +2595,2 @@\n-                            return groupingViolationIndex(position, prevSeparatorIndex);\n+                            return new NumericPosition(\n+                                    groupingViolationIndex(position, prevSeparatorIndex), intIndex);\n@@ -2624,1 +2649,2 @@\n-                    return groupingViolationIndex(position - 1, prevSeparatorIndex);\n+                    return new NumericPosition(\n+                            groupingViolationIndex(position - 1, prevSeparatorIndex), intIndex);\n@@ -2639,2 +2665,3 @@\n-            \/\/ Adjust for exponent, if any\n-            if (exponent != 0) {\n+            \/\/ If parsing integer only, adjust exponent if it occurs\n+            \/\/ in integer portion, otherwise ignore it\n+            if (!sawDecimal || !isParseIntegerOnly()) {\n@@ -2649,1 +2676,1 @@\n-                return -1;\n+                return new NumericPosition(-1, intIndex);\n@@ -2652,1 +2679,1 @@\n-        return position;\n+        return new NumericPosition(position, intIndex);\n@@ -2920,1 +2947,2 @@\n-     * \"123\" is parsed into 1.23.\n+     * \"123\" is parsed into 1.23. If {@code isParseIntegerOnly()} returns {@code true},\n+     * \"123\" is parsed into 1.\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":54,"deletions":26,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -471,1 +471,3 @@\n-     * Returns true if this format will parse numbers as integers only.\n+     * Returns {@code true} if this format will parse numbers as integers only.\n+     * The {@code ParsePosition} index will be set to the position of the decimal\n+     * symbol. The exact format accepted by the parse operation is locale dependent.\n@@ -473,4 +475,1 @@\n-     * string \"1234.\" would be parsed as the integer value 1234 and parsing\n-     * would stop at the \".\" character.  Of course, the exact format accepted\n-     * by the parse operation is locale dependent and determined by sub-classes\n-     * of NumberFormat.\n+     * string \"123.45\" would be parsed as the integer value 123.\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -35,0 +36,2 @@\n+import sun.nio.cs.ISO_8859_1;\n+\n@@ -38,1 +41,13 @@\n-public final class DoubleToDecimal {\n+public final class DoubleToDecimal extends ToDecimal {\n+    \/**\n+     * Use LATIN1 encoding to process the in-out byte[] str\n+     *\n+     *\/\n+    public static final DoubleToDecimal LATIN1 = new DoubleToDecimal(true);\n+\n+    \/**\n+     * Use UTF16 encoding to process the in-out byte[] str\n+     *\n+     *\/\n+    public static final DoubleToDecimal UTF16  = new DoubleToDecimal(false);\n+\n@@ -94,10 +109,0 @@\n-    \/* Used for left-to-tight digit extraction *\/\n-    private static final int MASK_28 = (1 << 28) - 1;\n-\n-    private static final int NON_SPECIAL    = 0;\n-    private static final int PLUS_ZERO      = 1;\n-    private static final int MINUS_ZERO     = 2;\n-    private static final int PLUS_INF       = 3;\n-    private static final int MINUS_INF      = 4;\n-    private static final int NAN            = 5;\n-\n@@ -113,7 +118,2 @@\n-    private final byte[] bytes;\n-\n-    \/* Index into bytes of rightmost valid character *\/\n-    private int index;\n-\n-    private DoubleToDecimal(boolean noChars) {\n-        bytes = noChars ? null : new byte[MAX_CHARS];\n+    private DoubleToDecimal(boolean latin1) {\n+        super(latin1);\n@@ -131,1 +131,8 @@\n-        return new DoubleToDecimal(false).toDecimalString(v);\n+        byte[] str = new byte[MAX_CHARS];\n+        int pair = LATIN1.toDecimal(str, 0, v, null);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            int size = pair & 0xFF;\n+            return new String(str, 0, size, ISO_8859_1.INSTANCE);\n+        }\n+        return special(type);\n@@ -152,1 +159,2 @@\n-        new DoubleToDecimal(true).toDecimal(v, fd);\n+        byte[] str = new byte[MAX_CHARS];\n+        LATIN1.toDecimal(str, 0, v, fd);\n@@ -156,1 +164,1 @@\n-     * Appends the rendering of the {@code v} to {@code app}.\n+     * Appends the rendering of the {@code v} to {@code str}.\n@@ -160,1 +168,0 @@\n-     * {@link Appendable#append(CharSequence) appended} to {@code app}.\n@@ -162,2 +169,3 @@\n-     * @param v the {@code double} whose rendering is appended.\n-     * @param app the {@link Appendable} to append to.\n+     * @param str the String byte array to append to\n+     * @param index the index into str\n+     * @param v the {@code double} whose rendering is into str.\n@@ -166,4 +174,2 @@\n-    public static Appendable appendTo(double v, Appendable app)\n-            throws IOException {\n-        return new DoubleToDecimal(false).appendDecimalTo(v, app);\n-    }\n+    public int putDecimal(byte[] str, int index, double v) {\n+        assert 0 <= index && index <= length(str) - MAX_CHARS : \"Trusted caller missed bounds check\";\n@@ -171,34 +177,4 @@\n-    private String toDecimalString(double v) {\n-        return switch (toDecimal(v, null)) {\n-            case NON_SPECIAL -> charsToString();\n-            case PLUS_ZERO -> \"0.0\";\n-            case MINUS_ZERO -> \"-0.0\";\n-            case PLUS_INF -> \"Infinity\";\n-            case MINUS_INF -> \"-Infinity\";\n-            default -> \"NaN\";\n-        };\n-    }\n-\n-    private Appendable appendDecimalTo(double v, Appendable app)\n-            throws IOException {\n-        switch (toDecimal(v, null)) {\n-            case NON_SPECIAL:\n-                char[] chars = new char[index + 1];\n-                for (int i = 0; i < chars.length; ++i) {\n-                    chars[i] = (char) bytes[i];\n-                }\n-                if (app instanceof StringBuilder builder) {\n-                    return builder.append(chars);\n-                }\n-                if (app instanceof StringBuffer buffer) {\n-                    return buffer.append(chars);\n-                }\n-                for (char c : chars) {\n-                    app.append(c);\n-                }\n-                return app;\n-            case PLUS_ZERO: return app.append(\"0.0\");\n-            case MINUS_ZERO: return app.append(\"-0.0\");\n-            case PLUS_INF: return app.append(\"Infinity\");\n-            case MINUS_INF: return app.append(\"-Infinity\");\n-            default: return app.append(\"NaN\");\n+        int pair = toDecimal(str, index, v, null);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            return index + (pair & 0xFF);\n@@ -206,0 +182,1 @@\n+        return putSpecial(str, index, type);\n@@ -209,1 +186,1 @@\n-     * Returns\n+     * Returns size in the lower byte, type in the high byte, where type is\n@@ -215,0 +192,1 @@\n+     *     otherwise NON_SPECIAL\n@@ -216,1 +194,1 @@\n-    private int toDecimal(double v, FormattedFPDecimal fd) {\n+    private int toDecimal(byte[] str, int index, double v, FormattedFPDecimal fd) {\n@@ -230,1 +208,1 @@\n-            index = -1;\n+            int start = index;\n@@ -233,1 +211,1 @@\n-                 * fd != null implies bytes == null and bits >= 0\n+                 * fd != null implies str == null and bits >= 0\n@@ -236,1 +214,1 @@\n-                append('-');\n+                index = putChar(str, index, '-');\n@@ -246,1 +224,1 @@\n-                        return toChars(f, 0, fd);\n+                        return toChars(str, index, f, 0, fd) - start;\n@@ -249,1 +227,1 @@\n-                return toDecimal(-mq, c, 0, fd);\n+                return toDecimal(str, index, -mq, c, 0, fd) - start;\n@@ -253,3 +231,3 @@\n-                return t < C_TINY\n-                       ? toDecimal(Q_MIN, 10 * t, -1, fd)\n-                       : toDecimal(Q_MIN, t, 0, fd);\n+                return (t < C_TINY\n+                        ? toDecimal(str, index, Q_MIN, 10 * t, -1, fd)\n+                        : toDecimal(str, index, Q_MIN, t, 0, fd)) - start;\n@@ -265,1 +243,1 @@\n-    private int toDecimal(int q, long c, int dk, FormattedFPDecimal fd) {\n+    private int toDecimal(byte[] str, int index, int q, long c, int dk, FormattedFPDecimal fd) {\n@@ -330,1 +308,1 @@\n-                return toChars(upin ? sp10 : tp10, k, fd);\n+                return toChars(str, index, upin ? sp10 : tp10, k, fd);\n@@ -345,1 +323,1 @@\n-            return toChars(uin ? s : t, k + dk, fd);\n+            return toChars(str, index, uin ? s : t, k + dk, fd);\n@@ -352,1 +330,1 @@\n-        return toChars(cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n+        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n@@ -371,1 +349,1 @@\n-    private int toChars(long f, int e, FormattedFPDecimal fd) {\n+    private int toChars(byte[] str, int index, long f, int e, FormattedFPDecimal fd) {\n@@ -384,1 +362,1 @@\n-            return NON_SPECIAL;\n+            return index;\n@@ -416,1 +394,1 @@\n-            return toChars1(h, m, l, e);\n+            return toChars1(str, index, h, m, l, e);\n@@ -419,1 +397,1 @@\n-            return toChars2(h, m, l, e);\n+            return toChars2(str, index, h, m, l, e);\n@@ -421,1 +399,1 @@\n-        return toChars3(h, m, l, e);\n+        return toChars3(str, index, h, m, l, e);\n@@ -424,1 +402,1 @@\n-    private int toChars1(int h, int m, int l, int e) {\n+    private int toChars1(byte[] str, int index, int h, int m, int l, int e) {\n@@ -430,1 +408,1 @@\n-        appendDigit(h);\n+        index = putDigit(str, index, h);\n@@ -436,1 +414,1 @@\n-            appendDigit(t >>> 28);\n+            index = putDigit(str, index, t >>> 28);\n@@ -439,1 +417,1 @@\n-        append('.');\n+        index = putChar(str, index, '.');\n@@ -442,1 +420,1 @@\n-            appendDigit(t >>> 28);\n+            index = putDigit(str, index, t >>> 28);\n@@ -445,2 +423,1 @@\n-        lowDigits(l);\n-        return NON_SPECIAL;\n+        return lowDigits(str, index, l);\n@@ -449,1 +426,1 @@\n-    private int toChars2(int h, int m, int l, int e) {\n+    private int toChars2(byte[] str, int index, int h, int m, int l, int e) {\n@@ -451,2 +428,2 @@\n-        appendDigit(0);\n-        append('.');\n+        index = putDigit(str, index, 0);\n+        index = putChar(str, index, '.');\n@@ -454,1 +431,1 @@\n-            appendDigit(0);\n+            index = putDigit(str, index, 0);\n@@ -456,4 +433,3 @@\n-        appendDigit(h);\n-        append8Digits(m);\n-        lowDigits(l);\n-        return NON_SPECIAL;\n+        index = putDigit(str, index, h);\n+        index = put8Digits(str, index, m);\n+        return lowDigits(str, index, l);\n@@ -462,1 +438,1 @@\n-    private int toChars3(int h, int m, int l, int e) {\n+    private int toChars3(byte[] str, int index, int h, int m, int l, int e) {\n@@ -464,6 +440,5 @@\n-        appendDigit(h);\n-        append('.');\n-        append8Digits(m);\n-        lowDigits(l);\n-        exponent(e - 1);\n-        return NON_SPECIAL;\n+        index = putDigit(str, index, h);\n+        index = putChar(str, index, '.');\n+        index = put8Digits(str, index, m);\n+        index = lowDigits(str, index, l);\n+        return exponent(str, index, e - 1);\n@@ -472,1 +447,1 @@\n-    private void lowDigits(int l) {\n+    private int lowDigits(byte[] str, int index, int l) {\n@@ -474,1 +449,1 @@\n-            append8Digits(l);\n+            index = put8Digits(str, index, l);\n@@ -476,1 +451,1 @@\n-        removeTrailingZeroes();\n+        return removeTrailingZeroes(str, index);\n@@ -479,39 +454,2 @@\n-    private void append8Digits(int m) {\n-        \/*\n-         * Left-to-right digits extraction:\n-         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n-         *\/\n-        int y = y(m);\n-        for (int i = 0; i < 8; ++i) {\n-            int t = 10 * y;\n-            appendDigit(t >>> 28);\n-            y = t & MASK_28;\n-        }\n-    }\n-\n-    private void removeTrailingZeroes() {\n-        while (bytes[index] == '0') {\n-            --index;\n-        }\n-        \/* ... but do not remove the one directly to the right of '.' *\/\n-        if (bytes[index] == '.') {\n-            ++index;\n-        }\n-    }\n-\n-    private int y(int a) {\n-        \/*\n-         * Algorithm 1 in [3] needs computation of\n-         *     floor((a + 1) 2^n \/ b^k) - 1\n-         * with a < 10^8, b = 10, k = 8, n = 28.\n-         * Noting that\n-         *     (a + 1) 2^n <= 10^8 2^28 < 10^17\n-         * For n = 17, m = 8 the table in section 10 of [1] leads to:\n-         *\/\n-        return (int) (multiplyHigh(\n-                (long) (a + 1) << 28,\n-                193_428_131_138_340_668L) >>> 20) - 1;\n-    }\n-\n-    private void exponent(int e) {\n-        append('E');\n+    private int exponent(byte[] str, int index, int e) {\n+        index = putChar(str, index, 'E');\n@@ -519,1 +457,1 @@\n-            append('-');\n+            index = putChar(str, index, '-');\n@@ -523,2 +461,1 @@\n-            appendDigit(e);\n-            return;\n+            return putDigit(str, index, e);\n@@ -533,1 +470,1 @@\n-            appendDigit(d);\n+            index = putDigit(str, index, d);\n@@ -541,6 +478,2 @@\n-        appendDigit(d);\n-        appendDigit(e - 10 * d);\n-    }\n-\n-    private void append(int c) {\n-        bytes[++index] = (byte) c;\n+        index = putDigit(str, index, d);\n+        return putDigit(str, index, e - 10 * d);\n@@ -548,11 +481,0 @@\n-\n-    private void appendDigit(int d) {\n-        bytes[++index] = (byte) ('0' + d);\n-    }\n-\n-    \/* Using the deprecated constructor enhances performance *\/\n-    @SuppressWarnings(\"deprecation\")\n-    private String charsToString() {\n-        return new String(bytes, 0, 0, index + 1);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleToDecimal.java","additions":89,"deletions":167,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -35,0 +36,2 @@\n+import sun.nio.cs.ISO_8859_1;\n+\n@@ -38,1 +41,13 @@\n-public final class FloatToDecimal {\n+public final class FloatToDecimal extends ToDecimal {\n+    \/**\n+     * Use LATIN1 encoding to process the in-out byte[] str\n+     *\n+     *\/\n+    public static final FloatToDecimal LATIN1 = new FloatToDecimal(true);\n+\n+    \/**\n+     * Use UTF16 encoding to process the in-out byte[] str\n+     *\n+     *\/\n+    public static final FloatToDecimal UTF16  = new FloatToDecimal(false);\n+\n@@ -94,10 +109,0 @@\n-    \/* Used for left-to-tight digit extraction *\/\n-    private static final int MASK_28 = (1 << 28) - 1;\n-\n-    private static final int NON_SPECIAL    = 0;\n-    private static final int PLUS_ZERO      = 1;\n-    private static final int MINUS_ZERO     = 2;\n-    private static final int PLUS_INF       = 3;\n-    private static final int MINUS_INF      = 4;\n-    private static final int NAN            = 5;\n-\n@@ -113,6 +118,2 @@\n-    private final byte[] bytes = new byte[MAX_CHARS];\n-\n-    \/* Index into bytes of rightmost valid character *\/\n-    private int index;\n-\n-    private FloatToDecimal() {\n+    private FloatToDecimal(boolean latin1) {\n+        super(latin1);\n@@ -130,1 +131,8 @@\n-        return new FloatToDecimal().toDecimalString(v);\n+        byte[] str = new byte[MAX_CHARS];\n+        int pair = LATIN1.toDecimal(str, 0, v);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            int size = pair & 0xFF;\n+            return new String(str, 0, size, ISO_8859_1.INSTANCE);\n+        }\n+        return special(type);\n@@ -134,1 +142,1 @@\n-     * Appends the rendering of the {@code v} to {@code app}.\n+     * Appends the rendering of the {@code v} to {@code str}.\n@@ -137,2 +145,1 @@\n-     * {@link #toString(float) rendered} and the resulting string were then\n-     * {@link Appendable#append(CharSequence) appended} to {@code app}.\n+     * {@link #toString(double) rendered} and the resulting string were then\n@@ -140,2 +147,3 @@\n-     * @param v the {@code float} whose rendering is appended.\n-     * @param app the {@link Appendable} to append to.\n+     * @param str the String byte array to append to\n+     * @param index the index into str\n+     * @param v the {@code float} whose rendering is into str.\n@@ -144,4 +152,2 @@\n-    public static Appendable appendTo(float v, Appendable app)\n-            throws IOException {\n-        return new FloatToDecimal().appendDecimalTo(v, app);\n-    }\n+    public int putDecimal(byte[] str, int index, float v) {\n+        assert 0 <= index && index <= length(str) - MAX_CHARS : \"Trusted caller missed bounds check\";\n@@ -149,34 +155,4 @@\n-    private String toDecimalString(float v) {\n-        return switch (toDecimal(v)) {\n-            case NON_SPECIAL -> charsToString();\n-            case PLUS_ZERO -> \"0.0\";\n-            case MINUS_ZERO -> \"-0.0\";\n-            case PLUS_INF -> \"Infinity\";\n-            case MINUS_INF -> \"-Infinity\";\n-            default -> \"NaN\";\n-        };\n-    }\n-\n-    private Appendable appendDecimalTo(float v, Appendable app)\n-            throws IOException {\n-        switch (toDecimal(v)) {\n-            case NON_SPECIAL:\n-                char[] chars = new char[index + 1];\n-                for (int i = 0; i < chars.length; ++i) {\n-                    chars[i] = (char) bytes[i];\n-                }\n-                if (app instanceof StringBuilder builder) {\n-                    return builder.append(chars);\n-                }\n-                if (app instanceof StringBuffer buffer) {\n-                    return buffer.append(chars);\n-                }\n-                for (char c : chars) {\n-                    app.append(c);\n-                }\n-                return app;\n-            case PLUS_ZERO: return app.append(\"0.0\");\n-            case MINUS_ZERO: return app.append(\"-0.0\");\n-            case PLUS_INF: return app.append(\"Infinity\");\n-            case MINUS_INF: return app.append(\"-Infinity\");\n-            default: return app.append(\"NaN\");\n+        int pair = toDecimal(str, index, v);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            return index + (pair & 0xFF);\n@@ -184,0 +160,1 @@\n+        return putSpecial(str, index, type);\n@@ -188,0 +165,2 @@\n+     *     Combine type and size, the first byte is size, the second byte is type\n+     *\n@@ -194,1 +173,1 @@\n-    private int toDecimal(float v) {\n+    private int toDecimal(byte[] str, int index, float v) {\n@@ -208,1 +187,1 @@\n-            index = -1;\n+            int start = index;\n@@ -210,1 +189,1 @@\n-                append('-');\n+                index = putChar(str, index, '-');\n@@ -220,1 +199,1 @@\n-                        return toChars(f, 0);\n+                        return toChars(str, index, f, 0) - start;\n@@ -223,1 +202,1 @@\n-                return toDecimal(-mq, c, 0);\n+                return toDecimal(str, index, -mq, c, 0) - start;\n@@ -227,3 +206,3 @@\n-                return t < C_TINY\n-                       ? toDecimal(Q_MIN, 10 * t, -1)\n-                       : toDecimal(Q_MIN, t, 0);\n+                return (t < C_TINY\n+                        ? toDecimal(str, index, Q_MIN, 10 * t, -1)\n+                        : toDecimal(str, index, Q_MIN, t, 0)) - start;\n@@ -239,1 +218,1 @@\n-    private int toDecimal(int q, int c, int dk) {\n+    private int toDecimal(byte[] str, int index, int q, int c, int dk) {\n@@ -303,1 +282,1 @@\n-                return toChars(upin ? sp10 : tp10, k);\n+                return toChars(str, index, upin ? sp10 : tp10, k);\n@@ -318,1 +297,1 @@\n-            return toChars(uin ? s : t, k + dk);\n+            return toChars(str, index, uin ? s : t, k + dk);\n@@ -325,1 +304,1 @@\n-        return toChars(cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n@@ -341,1 +320,1 @@\n-    private int toChars(int f, int e) {\n+    private int toChars(byte[] str, int index, int f, int e) {\n@@ -376,1 +355,1 @@\n-            return toChars1(h, l, e);\n+            return toChars1(str, index, h, l, e);\n@@ -379,1 +358,1 @@\n-            return toChars2(h, l, e);\n+            return toChars2(str, index, h, l, e);\n@@ -381,1 +360,1 @@\n-        return toChars3(h, l, e);\n+        return toChars3(str, index, h, l, e);\n@@ -384,1 +363,1 @@\n-    private int toChars1(int h, int l, int e) {\n+    private int toChars1(byte[] str, int index, int h, int l, int e) {\n@@ -390,1 +369,1 @@\n-        appendDigit(h);\n+        index = putDigit(str, index, h);\n@@ -396,1 +375,1 @@\n-            appendDigit(t >>> 28);\n+            index = putDigit(str, index, t >>> 28);\n@@ -399,1 +378,1 @@\n-        append('.');\n+        index = putChar(str, index, '.');\n@@ -402,1 +381,1 @@\n-            appendDigit(t >>> 28);\n+            index = putDigit(str, index, t >>> 28);\n@@ -405,2 +384,1 @@\n-        removeTrailingZeroes();\n-        return NON_SPECIAL;\n+        return removeTrailingZeroes(str, index);\n@@ -409,1 +387,1 @@\n-    private int toChars2(int h, int l, int e) {\n+    private int toChars2(byte[] str, int index, int h, int l, int e) {\n@@ -411,2 +389,2 @@\n-        appendDigit(0);\n-        append('.');\n+        index = putDigit(str, index, 0);\n+        index = putChar(str, index, '.');\n@@ -414,1 +392,1 @@\n-          appendDigit(0);\n+            index = putDigit(str, index, 0);\n@@ -416,4 +394,3 @@\n-        appendDigit(h);\n-        append8Digits(l);\n-        removeTrailingZeroes();\n-        return NON_SPECIAL;\n+        index = putDigit(str, index, h);\n+        index = put8Digits(str, index, l);\n+        return removeTrailingZeroes(str, index);\n@@ -422,1 +399,1 @@\n-    private int toChars3(int h, int l, int e) {\n+    private int toChars3(byte[] str, int index, int h, int l, int e) {\n@@ -424,6 +401,5 @@\n-        appendDigit(h);\n-        append('.');\n-        append8Digits(l);\n-        removeTrailingZeroes();\n-        exponent(e - 1);\n-        return NON_SPECIAL;\n+        index = putDigit(str, index, h);\n+        index = putChar(str, index, '.');\n+        index = put8Digits(str, index, l);\n+        index = removeTrailingZeroes(str, index);\n+        return exponent(str, index, e - 1);\n@@ -432,39 +408,2 @@\n-    private void append8Digits(int m) {\n-        \/*\n-         * Left-to-right digits extraction:\n-         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n-         *\/\n-        int y = y(m);\n-        for (int i = 0; i < 8; ++i) {\n-            int t = 10 * y;\n-            appendDigit(t >>> 28);\n-            y = t & MASK_28;\n-        }\n-    }\n-\n-    private void removeTrailingZeroes() {\n-        while (bytes[index] == '0') {\n-            --index;\n-        }\n-        \/* ... but do not remove the one directly to the right of '.' *\/\n-        if (bytes[index] == '.') {\n-            ++index;\n-        }\n-    }\n-\n-    private int y(int a) {\n-        \/*\n-         * Algorithm 1 in [3] needs computation of\n-         *     floor((a + 1) 2^n \/ b^k) - 1\n-         * with a < 10^8, b = 10, k = 8, n = 28.\n-         * Noting that\n-         *     (a + 1) 2^n <= 10^8 2^28 < 10^17\n-         * For n = 17, m = 8 the table in section 10 of [1] leads to:\n-         *\/\n-        return (int) (multiplyHigh(\n-                (long) (a + 1) << 28,\n-                193_428_131_138_340_668L) >>> 20) - 1;\n-    }\n-\n-    private void exponent(int e) {\n-        append('E');\n+    private int exponent(byte[] str, int index, int e) {\n+        index = putChar(str, index, 'E');\n@@ -472,1 +411,1 @@\n-            append('-');\n+            index = putChar(str, index, '-');\n@@ -476,2 +415,1 @@\n-            appendDigit(e);\n-            return;\n+            return putDigit(str, index, e);\n@@ -484,6 +422,2 @@\n-        appendDigit(d);\n-        appendDigit(e - 10 * d);\n-    }\n-\n-    private void append(int c) {\n-        bytes[++index] = (byte) c;\n+        index = putDigit(str, index, d);\n+        return putDigit(str, index, e - 10 * d);\n@@ -491,11 +425,0 @@\n-\n-    private void appendDigit(int d) {\n-        bytes[++index] = (byte) ('0' + d);\n-    }\n-\n-    \/* Using the deprecated constructor enhances performance *\/\n-    @SuppressWarnings(\"deprecation\")\n-    private String charsToString() {\n-        return new String(bytes, 0, 0, index + 1);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatToDecimal.java","additions":82,"deletions":159,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.math;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+import static java.lang.Math.multiplyHigh;\n+\n+abstract sealed class ToDecimal permits DoubleToDecimal, FloatToDecimal {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    \/* Used for left-to-tight digit extraction *\/\n+    static final int MASK_28 = (1 << 28) - 1;\n+\n+    static final int NON_SPECIAL = 0 << 8;\n+    static final int PLUS_ZERO   = 1 << 8;\n+    static final int MINUS_ZERO  = 2 << 8;\n+    static final int PLUS_INF    = 3 << 8;\n+    static final int MINUS_INF   = 4 << 8;\n+    static final int NAN         = 5 << 8;\n+\n+    \/**\n+     * The identifier of the encoding used to encode the bytes. If latin1 is true, the encoding is LATIN1, false is UTF16\n+     *\n+     *\/\n+    private final boolean latin1;\n+\n+    ToDecimal(boolean latin1) {\n+        this.latin1 = latin1;\n+    }\n+\n+    final int putChar(byte[] str, int index, int c) {\n+        if (latin1) {\n+            str[index] = (byte) c;\n+        } else {\n+            JLA.putCharUTF16(str, index, (char) c);\n+        }\n+        return index + 1;\n+    }\n+\n+    final int putDigit(byte[] str, int index, int d) {\n+        return putChar(str, index, (byte) ('0' + d));\n+    }\n+\n+    final int put8Digits(byte[] str, int index, int m) {\n+        \/*\n+         * Left-to-right digits extraction:\n+         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n+         *\/\n+        if (latin1) {\n+            put8DigitsLatin1(str, index, m);\n+        } else {\n+            put8DigitsUTF16 (str, index, m);\n+        }\n+        return index + 8;\n+    }\n+\n+    private static void put8DigitsLatin1(byte[] str, int index, int m) {\n+        int y = y(m);\n+        for (int i = 0; i < 8; ++i) {\n+            int t = 10 * y;\n+            str[index + i] = (byte) ('0' + (t >>> 28));\n+            y = t & MASK_28;\n+        }\n+    }\n+\n+    private static void put8DigitsUTF16(byte[] str, int index, int m) {\n+        int y = y(m);\n+        for (int i = 0; i < 8; ++i) {\n+            int t = 10 * y;\n+            JLA.putCharUTF16(str, index + i, '0' + (t >>> 28));\n+            y = t & MASK_28;\n+        }\n+    }\n+\n+    static int y(int a) {\n+        \/*\n+         * Algorithm 1 in [3] needs computation of\n+         *     floor((a + 1) 2^n \/ b^k) - 1\n+         * with a < 10^8, b = 10, k = 8, n = 28.\n+         * Noting that\n+         *     (a + 1) 2^n <= 10^8 2^28 < 10^17\n+         * For n = 17, m = 8 the table in section 10 of [1] leads to:\n+         *\/\n+        return (int) (multiplyHigh(\n+                (long) (a + 1) << 28,\n+                193_428_131_138_340_668L) >>> 20) - 1;\n+    }\n+\n+    final int removeTrailingZeroes(byte[] str, int index) {\n+        if (latin1) {\n+            while (str[index - 1] == '0') {\n+                --index;\n+            }\n+            \/* ... but do not remove the one directly to the right of '.' *\/\n+            if (str[index - 1] == '.') {\n+                ++index;\n+            }\n+        } else {\n+            while (JLA.getUTF16Char(str, index - 1) == '0') {\n+                --index;\n+            }\n+            \/* ... but do not remove the one directly to the right of '.' *\/\n+            if (JLA.getUTF16Char(str, index - 1) == '.') {\n+                ++index;\n+            }\n+        }\n+        return index;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    final int putSpecial(byte[] str, int index, int type) {\n+        String s = special(type);\n+        int length = s.length();\n+        if (latin1) {\n+            s.getBytes(0, length, str, index);\n+        } else {\n+            for (int i = 0; i < length; ++i) {\n+                putChar(str, index + i, s.charAt(i));\n+            }\n+        }\n+        return index + length;\n+    }\n+\n+    final int length(byte[] str) {\n+        return str.length >> (latin1 ? 0 : 1);\n+    }\n+\n+    static String special(int type) {\n+        return switch (type) {\n+            case PLUS_ZERO  -> \"0.0\";\n+            case MINUS_ZERO -> \"-0.0\";\n+            case PLUS_INF   -> \"Infinity\";\n+            case MINUS_INF  -> \"-Infinity\";\n+            default         -> \"NaN\";\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/ToDecimal.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,3 @@\n+            if (expected > count) {\n+                throw new IOException(\"Premature EOF\");\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MeteredStream.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1948,0 +1948,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -657,0 +657,3 @@\n+        \/\/ wait for any accept operation to complete before trying to close\n+        acceptLock.lock();\n+        acceptLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1219,0 +1219,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    private final int blockSize;\n+    protected final int blockSize;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DigestBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n@@ -33,2 +36,0 @@\n-import static sun.security.provider.ByteArrayAccess.b2lLittle;\n-import static sun.security.provider.ByteArrayAccess.l2bLittle;\n@@ -51,1 +52,1 @@\n-    private static final int DM = 5; \/\/ dimension of lanes\n+    private static final int DM = 5; \/\/ dimension of state matrix\n@@ -68,2 +69,5 @@\n-    private byte[] state = new byte[WIDTH];\n-    private long[] lanes = new long[DM*DM];\n+    private long[] state = new long[DM*DM];\n+\n+    static final VarHandle asLittleEndian\n+            = MethodHandles.byteArrayViewVarHandle(long[].class,\n+            ByteOrder.LITTLE_ENDIAN).withInvokeExactBehavior();\n@@ -94,4 +98,6 @@\n-       for (int i = 0; i < buffer.length; i++) {\n-           state[i] ^= b[ofs++];\n-       }\n-       keccak();\n+        for (int i = 0; i < blockSize \/ 8; i++) {\n+            state[i] ^= (long) asLittleEndian.get(b, ofs);\n+            ofs += 8;\n+        }\n+\n+        keccak();\n@@ -105,0 +111,1 @@\n+        byte[] byteState = new byte[8];\n@@ -106,1 +113,1 @@\n-            setPaddingBytes(suffix, buffer, (int)(bytesProcessed % buffer.length));\n+            setPaddingBytes(suffix, buffer, (int)(bytesProcessed % blockSize));\n@@ -111,1 +118,1 @@\n-        int availableBytes = buffer.length;\n+        int availableBytes = blockSize; \/\/ i.e. buffer.length\n@@ -114,1 +121,4 @@\n-            System.arraycopy(state, 0, out, ofs, availableBytes);\n+            for (int i = 0; i < availableBytes \/ 8 ; i++) {\n+                asLittleEndian.set(out, ofs, state[i]);\n+                ofs += 8;\n+            }\n@@ -116,1 +126,0 @@\n-            ofs += availableBytes;\n@@ -119,1 +128,13 @@\n-        System.arraycopy(state, 0, out, ofs, numBytes);\n+        int numLongs = (numBytes + 7) \/ 8;\n+\n+        for (int i = 0; i < numLongs - 1; i++) {\n+            asLittleEndian.set(out, ofs, state[i]);\n+            ofs += 8;\n+        }\n+        if (numBytes == numLongs * 8) {\n+            asLittleEndian.set(out, ofs, state[numLongs - 1]);\n+        } else {\n+            asLittleEndian.set(byteState, 0, state[numLongs - 1]);\n+            System.arraycopy(byteState, 0,\n+                    out, ofs, numBytes - (numLongs - 1) * 8);\n+        }\n@@ -126,2 +147,1 @@\n-        Arrays.fill(state, (byte)0);\n-        Arrays.fill(lanes, 0L);\n+        Arrays.fill(state, 0L);\n@@ -147,24 +167,0 @@\n-    \/**\n-     * Utility function for transforming the specified byte array 's'\n-     * into array of lanes 'm' as defined in section 3.1.2.\n-     *\/\n-    private static void bytes2Lanes(byte[] s, long[] m) {\n-        int sOfs = 0;\n-        \/\/ Conversion traverses along x-axis before y-axis\n-        for (int y = 0; y < DM; y++, sOfs += 40) {\n-            b2lLittle(s, sOfs, m, DM*y, 40);\n-        }\n-    }\n-\n-    \/**\n-     * Utility function for transforming the specified array of\n-     * lanes 'm' into a byte array 's' as defined in section 3.1.3.\n-     *\/\n-    private static void lanes2Bytes(long[] m, byte[] s) {\n-        int sOfs = 0;\n-        \/\/ Conversion traverses along x-axis before y-axis\n-        for (int y = 0; y < DM; y++, sOfs += 40) {\n-            l2bLittle(m, DM*y, s, sOfs, 40);\n-        }\n-    }\n-\n@@ -176,3 +172,0 @@\n-        \/\/ convert the 200-byte state into 25 lanes\n-        bytes2Lanes(state, lanes);\n-\n@@ -182,5 +175,5 @@\n-        a0 = lanes[0]; a1 = lanes[1]; a2 = lanes[2]; a3 = lanes[3]; a4 = lanes[4];\n-        a5 = lanes[5]; a6 = lanes[6]; a7 = lanes[7]; a8 = lanes[8]; a9 = lanes[9];\n-        a10 = lanes[10]; a11 = lanes[11]; a12 = lanes[12]; a13 = lanes[13]; a14 = lanes[14];\n-        a15 = lanes[15]; a16 = lanes[16]; a17 = lanes[17]; a18 = lanes[18]; a19 = lanes[19];\n-        a20 = lanes[20]; a21 = lanes[21]; a22 = lanes[22]; a23 = lanes[23]; a24 = lanes[24];\n+        a0 = state[0]; a1 = state[1]; a2 = state[2]; a3 = state[3]; a4 = state[4];\n+        a5 = state[5]; a6 = state[6]; a7 = state[7]; a8 = state[8]; a9 = state[9];\n+        a10 = state[10]; a11 = state[11]; a12 = state[12]; a13 = state[13]; a14 = state[14];\n+        a15 = state[15]; a16 = state[16]; a17 = state[17]; a18 = state[18]; a19 = state[19];\n+        a20 = state[20]; a21 = state[21]; a22 = state[22]; a23 = state[23]; a24 = state[24];\n@@ -290,8 +283,5 @@\n-        lanes[0] = a0; lanes[1] = a1; lanes[2] = a2; lanes[3] = a3; lanes[4] = a4;\n-        lanes[5] = a5; lanes[6] = a6; lanes[7] = a7; lanes[8] = a8; lanes[9] = a9;\n-        lanes[10] = a10; lanes[11] = a11; lanes[12] = a12; lanes[13] = a13; lanes[14] = a14;\n-        lanes[15] = a15; lanes[16] = a16; lanes[17] = a17; lanes[18] = a18; lanes[19] = a19;\n-        lanes[20] = a20; lanes[21] = a21; lanes[22] = a22; lanes[23] = a23; lanes[24] = a24;\n-\n-        \/\/ convert the resulting 25 lanes back into 200-byte state\n-        lanes2Bytes(lanes, state);\n+        state[0] = a0; state[1] = a1; state[2] = a2; state[3] = a3; state[4] = a4;\n+        state[5] = a5; state[6] = a6; state[7] = a7; state[8] = a8; state[9] = a9;\n+        state[10] = a10; state[11] = a11; state[12] = a12; state[13] = a13; state[14] = a14;\n+        state[15] = a15; state[16] = a16; state[17] = a17; state[18] = a18; state[19] = a19;\n+        state[20] = a20; state[21] = a21; state[22] = a22; state[23] = a23; state[24] = a24;\n@@ -303,1 +293,0 @@\n-        copy.lanes = new long[DM*DM];\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA3.java","additions":47,"deletions":58,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,2 +171,2 @@\n-                int remains = (limit - offset) + (count - position);\n-                int fragLen = Math.min(fragLimit, remains);\n+                int remains = (limit - offset);\n+                int fragLen = Math.min(fragLimit - count + position, remains);\n@@ -176,1 +176,1 @@\n-                if (remains < fragLimit) {\n+                if (remains < fragLen) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketOutputRecord.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    protected int multByInt(long[] a, long b) {\n+    protected void multByInt(long[] a, long b) {\n@@ -98,1 +98,0 @@\n-        return 0;\n@@ -107,1 +106,1 @@\n-    protected abstract int mult(long[] a, long[] b, long[] r);\n+    protected abstract void mult(long[] a, long[] b, long[] r);\n@@ -115,1 +114,1 @@\n-    protected abstract int square(long[] a, long[] r);\n+    protected abstract void square(long[] a, long[] r);\n@@ -625,2 +624,2 @@\n-            int numAdds = mult(limbs, b.limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, numAdds);\n+            mult(limbs, b.limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, 0);\n@@ -638,2 +637,2 @@\n-            int numAdds = IntegerPolynomial.this.square(limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, numAdds);\n+            IntegerPolynomial.this.square(limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, 0);\n@@ -754,1 +753,2 @@\n-            numAdds = mult(limbs, b.limbs, limbs);\n+            mult(limbs, b.limbs, limbs);\n+            numAdds = 0;\n@@ -767,1 +767,2 @@\n-            numAdds += multByInt(limbs, value);\n+            multByInt(limbs, value);\n+            numAdds = 0;\n@@ -827,1 +828,2 @@\n-            numAdds = IntegerPolynomial.this.square(limbs, limbs);\n+            IntegerPolynomial.this.square(limbs, limbs);\n+            numAdds = 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    protected void mult(long[] a, long[] b, long[] r) {\n@@ -76,1 +76,0 @@\n-        return 0;\n@@ -103,1 +102,1 @@\n-    protected int square(long[] a, long[] r) {\n+    protected void square(long[] a, long[] r) {\n@@ -126,1 +125,0 @@\n-        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial1305.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    protected void mult(long[] a, long[] b, long[] r) {\n@@ -139,1 +139,0 @@\n-        return 0;\n@@ -192,1 +191,1 @@\n-    protected int square(long[] a, long[] r) {\n+    protected void square(long[] a, long[] r) {\n@@ -203,1 +202,0 @@\n-        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialModBinP.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -106,2 +107,2 @@\n-        int numAdds = mult(vLimbs, h, montLimbs);\n-        return new ImmutableElement(montLimbs, numAdds);\n+        mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, 0);\n@@ -117,18 +118,0 @@\n-    \/*\n-     * This function is used by IntegerPolynomial.setProduct(SmallValue v) to\n-     * multiply by a small constant (i.e. (int) 1,2,3,4). Instead of doing a\n-     * montgomery conversion followed by a montgomery multiplication, just use\n-     * the spare top (64-BITS_PER_LIMB) bits to multiply by a constant. (See [1]\n-     * Section 4 )\n-     *\n-     * Will return an unreduced value\n-     *\/\n-    @Override\n-    protected int multByInt(long[] a, long b) {\n-        assert (b < (1 << BITS_PER_LIMB));\n-        for (int i = 0; i < a.length; i++) {\n-            a[i] *= b;\n-        }\n-        return (int) (b - 1);\n-    }\n-\n@@ -166,2 +149,2 @@\n-    protected int square(long[] a, long[] r) {\n-        return mult(a, a, r);\n+    protected void square(long[] a, long[] r) {\n+        mult(a, a, r);\n@@ -170,0 +153,1 @@\n+\n@@ -177,0 +161,7 @@\n+    @Override\n+    protected void mult(long[] a, long[] b, long[] r) {\n+        multImpl(a, b, r);\n+        reducePositive(r);\n+    }\n+\n+    @ForceInline\n@@ -178,1 +169,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    private void multImpl(long[] a, long[] b, long[] r) {\n@@ -411,30 +402,10 @@\n-        c6 += d2 + dd1 + (c5 >>> BITS_PER_LIMB);\n-        c7 += d3 + dd2 + (c6 >>> BITS_PER_LIMB);\n-        c8 += d4 + dd3 + (c7 >>> BITS_PER_LIMB);\n-        c9 = dd4 + (c8 >>> BITS_PER_LIMB);\n-\n-        c5 &= LIMB_MASK;\n-        c6 &= LIMB_MASK;\n-        c7 &= LIMB_MASK;\n-        c8 &= LIMB_MASK;\n-\n-        \/\/ At this point, the result could overflow by one modulus.\n-        c0 = c5 - modulus[0];\n-        c1 = c6 - modulus[1] + (c0 >> BITS_PER_LIMB);\n-        c0 &= LIMB_MASK;\n-        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB);\n-        c1 &= LIMB_MASK;\n-        c3 = c8 - modulus[3] + (c2 >> BITS_PER_LIMB);\n-        c2 &= LIMB_MASK;\n-        c4 = c9 - modulus[4] + (c3 >> BITS_PER_LIMB);\n-        c3 &= LIMB_MASK;\n-\n-        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n-\n-        r[0] = ((c5 & mask) | (c0 & ~mask));\n-        r[1] = ((c6 & mask) | (c1 & ~mask));\n-        r[2] = ((c7 & mask) | (c2 & ~mask));\n-        r[3] = ((c8 & mask) | (c3 & ~mask));\n-        r[4] = ((c9 & mask) | (c4 & ~mask));\n-\n-        return 0;\n+        c6 += d2 + dd1;\n+        c7 += d3 + dd2;\n+        c8 += d4 + dd3;\n+        c9 = dd4;\n+\n+        r[0] = c5;\n+        r[1] = c6;\n+        r[2] = c7;\n+        r[3] = c8;\n+        r[4] = c9;\n@@ -519,2 +490,2 @@\n-        int numAdds = mult(vLimbs, h, montLimbs);\n-        return new ImmutableElement(montLimbs, numAdds);\n+        mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, 0);\n@@ -559,0 +530,23 @@\n+\n+    \/\/ Used when limbs a could overflow by one modulus.\n+    @ForceInline\n+    protected void reducePositive(long[] a) {\n+        long aa0 = a[0];\n+        long aa1 = a[1] + (aa0>>BITS_PER_LIMB);\n+        long aa2 = a[2] + (aa1>>BITS_PER_LIMB);\n+        long aa3 = a[3] + (aa2>>BITS_PER_LIMB);\n+        long aa4 = a[4] + (aa3>>BITS_PER_LIMB);\n+\n+        long c0 = a[0] - modulus[0];\n+        long c1 = a[1] - modulus[1] + (c0 >> BITS_PER_LIMB);\n+        long c2 = a[2] - modulus[2] + (c1 >> BITS_PER_LIMB);\n+        long c3 = a[3] - modulus[3] + (c2 >> BITS_PER_LIMB);\n+        long c4 = a[4] - modulus[4] + (c3 >> BITS_PER_LIMB);\n+        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n+\n+        a[0] = ((aa0 & mask) | (c0 & ~mask)) & LIMB_MASK;\n+        a[1] = ((aa1 & mask) | (c1 & ~mask)) & LIMB_MASK;\n+        a[2] = ((aa2 & mask) | (c2 & ~mask)) & LIMB_MASK;\n+        a[3] = ((aa3 & mask) | (c3 & ~mask)) & LIMB_MASK;\n+        a[4] = ((aa4 & mask) | (c4 & ~mask));\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256.java","additions":49,"deletions":55,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -290,0 +290,1 @@\n+ZWG=ZWG\n@@ -515,0 +516,1 @@\n+zwg=Zimbabwe Gold\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/CurrencyNames.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-dataVersion=176\n+dataVersion=177\n@@ -59,2 +59,2 @@\n-    XPT962-XSU994-XTS963-XUA965-XXX999-YER886-YUM891-ZAR710-ZMK894-ZMW967-ZWD716-ZWL932-\\\n-    ZWN942-ZWR935\n+    XPT962-XSU994-XTS963-XUA965-XXX999-YER886-YUM891-ZAR710-ZMK894-ZMW967-ZWD716-ZWG924-\\\n+    ZWL932-ZWN942-ZWR935\n@@ -585,1 +585,1 @@\n-ZW=ZWL\n+ZW=ZWG\n","filename":"src\/java.base\/share\/data\/currency\/CurrencyData.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-File-Date: 2024-05-16\n+File-Date: 2024-06-14\n@@ -48012,0 +48012,1 @@\n+Deprecated: 2024-06-08\n@@ -48013,0 +48014,1 @@\n+Comments: Preferred tag is cls\n@@ -48388,0 +48390,1 @@\n+Deprecated: 2024-06-08\n@@ -48391,0 +48394,1 @@\n+Comments: Preferred tag is vsn\n","filename":"src\/java.base\/share\/data\/lsrdata\/language-subtag-registry.txt","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -204,0 +204,3 @@\n+        \/\/ wait for any write operation to complete before trying to close\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,0 +203,3 @@\n+        \/\/ wait for any read operation to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,1 @@\n+import sun.lwawt.LWKeyboardFocusManagerPeer;\n@@ -1059,0 +1060,5 @@\n+\n+        Window currFocus = LWKeyboardFocusManagerPeer.getInstance().getCurrentFocusedWindow();\n+        if (!blocked && (target == currFocus)) {\n+            requestWindowFocus();\n+        }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformWindow.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,0 +295,3 @@\n+        \/**\n+         * @since 10\n+         *\/\n@@ -1181,0 +1184,3 @@\n+        \/**\n+         * @since 10\n+         *\/\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Path2D.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,0 +111,2 @@\n+ *\n+ * @since 1.1\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,0 +186,2 @@\n+     *\n+     * @since 11\n@@ -208,0 +210,2 @@\n+     *\n+     * @since 11\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultComboBoxModel.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -533,0 +533,2 @@\n+     *\n+     * @since 11\n@@ -555,0 +557,2 @@\n+     *\n+     * @since 11\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultListModel.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1464,0 +1464,2 @@\n+         *\n+         * @since 16\n@@ -1564,0 +1566,2 @@\n+         *\n+         * @since 17\n@@ -1575,0 +1579,2 @@\n+         *\n+         * @since 17\n@@ -1593,0 +1599,2 @@\n+         *\n+         * @since 17\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSlider.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,2 @@\n+ *\n+ * @since 1.2\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,0 +153,4 @@\n+     *\n+     * @since 16\n+     * @deprecated This constructor was exposed erroneously and will be removed in a future release.\n+     *             Use {@link #BasicSliderUI(JSlider)} instead.\n@@ -154,0 +158,1 @@\n+    @Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSliderUI.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,0 +142,2 @@\n+ *\n+ * @since 1.5\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -651,0 +651,2 @@\n+     *\n+     * @since 20\n@@ -660,0 +662,2 @@\n+     *\n+     * @since 20\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultEditorKit.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -525,0 +525,1 @@\n+    jboolean doIt = JNI_FALSE;\n@@ -580,1 +581,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -608,1 +609,1 @@\n-        return JNI_FALSE;\n+        return doIt;\n@@ -622,1 +623,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -664,1 +665,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -673,1 +674,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -687,1 +688,1 @@\n-                        return JNI_FALSE;\n+                        return doIt;\n@@ -693,0 +694,1 @@\n+        doIt = JNI_TRUE;\n@@ -711,1 +713,1 @@\n-    return JNI_TRUE;\n+    return doIt;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4649,3 +4649,0 @@\n-            if (pt.isErroneous()) {\n-                return types.createErrorType(site);\n-            }\n@@ -4760,0 +4757,4 @@\n+            if (pt.isErroneous()) {\n+                owntype = types.createErrorType(owntype);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-        UNLAMBDA(8),\n-        LOWER(9),\n+        LOWER(8),\n+        UNLAMBDA(9),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import com.sun.tools.javac.code.Symbol.TypeSymbol;\n@@ -48,1 +47,0 @@\n-import com.sun.tools.javac.code.Type.TypeVar;\n@@ -51,1 +49,0 @@\n-import com.sun.tools.javac.comp.Lower.BasicFreeVarCollector;\n@@ -53,1 +50,0 @@\n-import com.sun.tools.javac.jvm.*;\n@@ -56,1 +52,0 @@\n-import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -75,1 +70,0 @@\n-import javax.lang.model.type.TypeKind;\n@@ -129,3 +123,0 @@\n-    \/** lambda proxy is a dynamic nestmate *\/\n-    private final boolean nestmateLambdas;\n-\n@@ -178,1 +169,0 @@\n-        nestmateLambdas = Target.instance(context).runtimeUseNestAccess();\n@@ -287,0 +277,1 @@\n+        cdef = analyzer.analyzeAndPreprocessClass((JCClassDecl) cdef);\n@@ -300,4 +291,0 @@\n-        if (tree.sym.owner.kind == PCK) {\n-            \/\/analyze class\n-            tree = analyzer.analyzeAndPreprocessClass(tree);\n-        }\n@@ -421,3 +408,1 @@\n-        if (localContext.methodReferenceReceiver != null) {\n-            syntheticInits.append(localContext.methodReferenceReceiver);\n-        } else if (!sym.isStatic()) {\n+        if (!sym.isStatic()) {\n@@ -436,5 +421,0 @@\n-        \/\/ add captured outer this instances (used only when `this' capture itself is illegal)\n-        for (Symbol fv : localContext.getSymbolMap(CAPTURED_OUTER_THIS).keySet()) {\n-            JCExpression captured_local = make.QualThis(fv.type);\n-            syntheticInits.append(captured_local);\n-        }\n@@ -556,48 +536,0 @@\n-    \/**\n-     * Translate qualified `this' references within a lambda to the mapped identifier\n-     * @param tree\n-     *\/\n-    @Override\n-    public void visitSelect(JCFieldAccess tree) {\n-        if (context == null || !analyzer.lambdaFieldAccessFilter(tree)) {\n-            super.visitSelect(tree);\n-        } else {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;\n-                JCTree ltree = lambdaContext.translate(tree);\n-                if (ltree != null) {\n-                    result = ltree;\n-                } else {\n-                    super.visitSelect(tree);\n-                }\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Translate instance creation expressions with implicit enclosing instances\n-     * @param tree\n-     *\/\n-    @Override\n-    public void visitNewClass(JCNewClass tree) {\n-        if (context == null || !analyzer.lambdaNewClassFilter(context, tree)) {\n-            super.visitNewClass(tree);\n-        } else {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;\n-                tree = lambdaContext.translate(tree);\n-                super.visitNewClass(tree);\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-    }\n-\n@@ -728,1 +660,1 @@\n-        return deser;\n+        return lower.translateMethod(attrEnv, deser, make);\n@@ -860,30 +792,0 @@\n-    \/**\n-     * Set varargsElement field on a given tree (must be either a new class tree\n-     * or a method call tree)\n-     *\/\n-    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {\n-        if (varargsElement != null) {\n-            switch (tree.getTag()) {\n-                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;\n-                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;\n-                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;\n-                default: throw new AssertionError();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Convert method\/constructor arguments by inserting appropriate cast\n-     * as required by type-erasure - this is needed when bridging a lambda\/method\n-     * reference, as the bridged signature might require downcast to be compatible\n-     * with the generated signature.\n-     *\/\n-    private List<JCExpression> convertArgs(Symbol meth, List<JCExpression> args, Type varargsElement) {\n-       Assert.check(meth.kind == MTH);\n-       List<Type> formals = types.erasure(meth.type).getParameterTypes();\n-       if (varargsElement != null) {\n-           Assert.check((meth.flags() & VARARGS) != 0);\n-       }\n-       return transTypes.translateArgs(args, formals, varargsElement, attrEnv);\n-    }\n-\n@@ -892,207 +794,0 @@\n-    \/**\n-     * Converts a method reference which cannot be used directly into a lambda\n-     *\/\n-    private class MemberReferenceToLambda {\n-\n-        private final JCMemberReference tree;\n-        private final ReferenceTranslationContext localContext;\n-        private final Symbol owner;\n-        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n-        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n-\n-        private JCExpression receiverExpression = null;\n-\n-        MemberReferenceToLambda(JCMemberReference tree, ReferenceTranslationContext localContext, Symbol owner) {\n-            this.tree = tree;\n-            this.localContext = localContext;\n-            this.owner = owner;\n-        }\n-\n-        JCLambda lambda() {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                \/\/body generation - this can be either a method call or a\n-                \/\/new instance creation expression, depending on the member reference kind\n-                VarSymbol rcvr = addParametersReturnReceiver();\n-                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n-                        ? expressionInvoke(rcvr)\n-                        : expressionNew();\n-\n-                JCLambda slam = make.Lambda(params.toList(), expr);\n-                slam.target = tree.target;\n-                slam.type = tree.type;\n-                slam.pos = tree.pos;\n-                return slam;\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-\n-        \/**\n-         * Generate the parameter list for the converted member reference.\n-         *\n-         * @return The receiver variable symbol, if any\n-         *\/\n-        VarSymbol addParametersReturnReceiver() {\n-            Type samDesc = localContext.bridgedRefSig();\n-            List<Type> samPTypes = samDesc.getParameterTypes();\n-            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n-\n-            \/\/ Determine the receiver, if any\n-            VarSymbol rcvr;\n-            switch (tree.kind) {\n-                case BOUND:\n-                    \/\/ The receiver is explicit in the method reference\n-                    rcvr = addParameter(\"rec$\", tree.getQualifierExpression().type, false);\n-                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n-                    break;\n-                case UNBOUND:\n-                    \/\/ The receiver is the first parameter, extract it and\n-                    \/\/ adjust the SAM and unerased type lists accordingly\n-                    rcvr = addParameter(\"rec$\", samDesc.getParameterTypes().head, false);\n-                    samPTypes = samPTypes.tail;\n-                    descPTypes = descPTypes.tail;\n-                    break;\n-                default:\n-                    rcvr = null;\n-                    break;\n-            }\n-            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n-            int implSize = implPTypes.size();\n-            int samSize = samPTypes.size();\n-            \/\/ Last parameter to copy from referenced method, exclude final var args\n-            int last = localContext.needsVarArgsConversion() ? implSize - 1 : implSize;\n-\n-            \/\/ Failsafe -- assure match-up\n-            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();\n-\n-            \/\/ Use parameter types of the implementation method unless the unerased\n-            \/\/ SAM parameter type is an intersection type, in that case use the\n-            \/\/ erased SAM parameter type so that the supertype relationship\n-            \/\/ the implementation method parameters is not obscured.\n-            \/\/ Note: in this loop, the lists implPTypes, samPTypes, and descPTypes\n-            \/\/ are used as pointers to the current parameter type information\n-            \/\/ and are thus not usable afterwards.\n-            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n-                \/\/ By default use the implementation method parameter type\n-                Type parmType = implPTypes.head;\n-                if (checkForIntersection) {\n-                    if (descPTypes.head.getKind() == TypeKind.INTERSECTION) {\n-                        parmType = samPTypes.head;\n-                    }\n-                    \/\/ If the unerased parameter type is a type variable whose\n-                    \/\/ bound is an intersection (eg. <T extends A & B>) then\n-                    \/\/ use the SAM parameter type\n-                    if (descPTypes.head.getKind() == TypeKind.TYPEVAR) {\n-                        TypeVar tv = (TypeVar) descPTypes.head;\n-                        if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n-                            parmType = samPTypes.head;\n-                        }\n-                    }\n-                }\n-                addParameter(\"x$\" + i, parmType, true);\n-\n-                \/\/ Advance to the next parameter\n-                implPTypes = implPTypes.tail;\n-                samPTypes = samPTypes.tail;\n-                descPTypes = descPTypes.tail;\n-            }\n-            \/\/ Flatten out the var args\n-            for (int i = last; i < samSize; ++i) {\n-                addParameter(\"xva$\" + i, tree.varargsElement, true);\n-            }\n-\n-            return rcvr;\n-        }\n-\n-        JCExpression getReceiverExpression() {\n-            return receiverExpression;\n-        }\n-\n-        private JCExpression makeReceiver(VarSymbol rcvr) {\n-            if (rcvr == null) return null;\n-            JCExpression rcvrExpr = make.Ident(rcvr);\n-            boolean protAccess =\n-                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, owner);\n-            Type rcvrType = tree.ownerAccessible && !protAccess ? tree.sym.enclClass().type\n-                                                                : tree.expr.type;\n-            if (rcvrType == syms.arrayClass.type) {\n-                \/\/ Map the receiver type to the actually type, not just \"array\"\n-                rcvrType = tree.getQualifierExpression().type;\n-            }\n-            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {\n-                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);\n-            }\n-            return rcvrExpr;\n-        }\n-\n-        \/**\n-         * determine the receiver of the method call - the receiver can\n-         * be a type qualifier, the synthetic receiver parameter or 'super'.\n-         *\/\n-        private JCExpression expressionInvoke(VarSymbol rcvr) {\n-            JCExpression qualifier =\n-                    (rcvr != null) ?\n-                        makeReceiver(rcvr) :\n-                        tree.getQualifierExpression();\n-\n-            \/\/create the qualifier expression\n-            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n-            select.sym = tree.sym;\n-            select.type = tree.sym.erasure(types);\n-\n-            \/\/create the method call expression\n-            JCExpression apply = make.Apply(List.nil(), select,\n-                    convertArgs(tree.sym, args.toList(), tree.varargsElement)).\n-                    setType(tree.sym.erasure(types).getReturnType());\n-\n-            apply = transTypes.coerce(attrEnv, apply,\n-                    types.erasure(localContext.tree.referentType.getReturnType()));\n-\n-            setVarargsIfNeeded(apply, tree.varargsElement);\n-            return apply;\n-        }\n-\n-        \/**\n-         * Lambda body to use for a 'new'.\n-         *\/\n-        private JCExpression expressionNew() {\n-            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n-                \/\/create the array creation expression\n-                JCNewArray newArr = make.NewArray(\n-                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n-                        List.of(make.Ident(params.first())),\n-                        null);\n-                newArr.type = tree.getQualifierExpression().type;\n-                return newArr;\n-            } else {\n-                \/\/create the instance creation expression\n-                \/\/note that method reference syntax does not allow an explicit\n-                \/\/enclosing class (so the enclosing class is null)\n-                \/\/ but this may need to be patched up later with the proxy for the outer this\n-                JCNewClass newClass = make.NewClass(null,\n-                        List.nil(),\n-                        make.Type(tree.getQualifierExpression().type),\n-                        convertArgs(tree.sym, args.toList(), tree.varargsElement),\n-                        null);\n-                newClass.constructor = tree.sym;\n-                newClass.constructorType = tree.sym.erasure(types);\n-                newClass.type = tree.getQualifierExpression().type;\n-                setVarargsIfNeeded(newClass, tree.varargsElement);\n-                return newClass;\n-            }\n-        }\n-\n-        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n-            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n-            vsym.pos = tree.pos;\n-            params.append(make.VarDef(vsym, null));\n-            if (genArg) {\n-                args.append(make.Ident(vsym));\n-            }\n-            return vsym;\n-        }\n-    }\n-\n@@ -1241,5 +936,0 @@\n-        \/**\n-         * List of types undergoing construction, i.e., in an early construction context.\n-         *\/\n-        private List<ClassSymbol> typesUnderConstruction;\n-\n@@ -1276,1 +966,0 @@\n-            typesUnderConstruction = List.nil();\n@@ -1281,19 +970,0 @@\n-        @Override\n-        public void visitApply(JCMethodInvocation tree) {\n-            super.visitApply(tree);\n-            if (TreeInfo.isConstructorCall(tree)) {\n-                Assert.check(typesUnderConstruction.head == currentClass());\n-                typesUnderConstruction = typesUnderConstruction.tail;   \/\/ end of early construction context\n-            }\n-        }\n-            \/\/ where\n-            private ClassSymbol currentClass() {\n-                for (Frame frame : frameStack) {\n-                    if (frame.tree.hasTag(JCTree.Tag.CLASSDEF)) {\n-                        JCClassDecl cdef = (JCClassDecl) frame.tree;\n-                        return cdef.sym;\n-                    }\n-                }\n-                return null;\n-            }\n-\n@@ -1332,15 +1002,0 @@\n-                    if (tree.sym.hasOuterInstance()) {\n-                        \/\/if a class is defined within a lambda, the lambda must capture\n-                        \/\/its enclosing instance (if any)\n-                        TranslationContext<?> localContext = context();\n-                        final TypeSymbol outerInstanceSymbol = tree.sym.type.getEnclosingType().tsym;\n-                        while (localContext != null && !localContext.owner.isStatic()) {\n-                            if (localContext.tree.hasTag(LAMBDA)) {\n-                                JCTree block = capturedDecl(localContext.depth, outerInstanceSymbol);\n-                                if (block == null) break;\n-                                ((LambdaTranslationContext)localContext)\n-                                        .addSymbol(outerInstanceSymbol, CAPTURED_THIS);\n-                            }\n-                            localContext = localContext.prev;\n-                        }\n-                    }\n@@ -1401,10 +1056,1 @@\n-            analyzeLambda(tree, \"lambda.stat\");\n-        }\n-\n-        private void analyzeLambda(JCLambda tree, JCExpression methodReferenceReceiver) {\n-            \/\/ Translation of the receiver expression must occur first\n-            JCExpression rcvr = translate(methodReferenceReceiver);\n-            LambdaTranslationContext context = analyzeLambda(tree, \"mref.stat.1\");\n-            if (rcvr != null) {\n-                context.methodReferenceReceiver = rcvr;\n-            }\n+            analyzeLambda(tree, tree.wasMethodReference ? \"mref.stat.1\" : \"lambda.stat\");\n@@ -1437,1 +1083,0 @@\n-            List<ClassSymbol> prevTypesUnderConstruction = typesUnderConstruction;\n@@ -1440,2 +1085,0 @@\n-                if (TreeInfo.isConstructor(tree))       \/\/ start early construction context (Object() notwithstanding)\n-                    typesUnderConstruction = typesUnderConstruction.prepend(currentClass());\n@@ -1444,25 +1087,0 @@\n-            } finally {\n-                frameStack = prevStack;\n-                typesUnderConstruction = prevTypesUnderConstruction;\n-            }\n-        }\n-\n-        @Override\n-        public void visitNewClass(JCNewClass tree) {\n-            TypeSymbol def = tree.type.tsym;\n-            boolean inReferencedClass = currentlyInClass(def);\n-            boolean isLocal = def.isDirectlyOrIndirectlyLocal();\n-            if ((inReferencedClass && isLocal || lambdaNewClassFilter(context(), tree))) {\n-                TranslationContext<?> localContext = context();\n-                final TypeSymbol outerInstanceSymbol = tree.type.getEnclosingType().tsym;\n-                while (localContext != null  && !localContext.owner.isStatic()) {\n-                    if (localContext.tree.hasTag(LAMBDA)) {\n-                        if (outerInstanceSymbol != null) {\n-                            JCTree block = capturedDecl(localContext.depth, outerInstanceSymbol);\n-                            if (block == null) break;\n-                        }\n-                        ((LambdaTranslationContext)localContext)\n-                                .addSymbol(outerInstanceSymbol, CAPTURED_THIS);\n-                    }\n-                    localContext = localContext.prev;\n-                }\n@@ -1470,44 +1088,2 @@\n-            super.visitNewClass(tree);\n-            if (context() != null && !inReferencedClass && isLocal) {\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context();\n-                captureLocalClassDefs(def, lambdaContext);\n-            }\n-        }\n-        \/\/where\n-            void captureLocalClassDefs(Symbol csym, final LambdaTranslationContext lambdaContext) {\n-                JCClassDecl localCDef = localClassDefs.get(csym);\n-                if (localCDef != null && lambdaContext.freeVarProcessedLocalClasses.add(csym)) {\n-                    BasicFreeVarCollector fvc = lower.new BasicFreeVarCollector() {\n-                        @Override\n-                        void addFreeVars(ClassSymbol c) {\n-                            captureLocalClassDefs(c, lambdaContext);\n-                        }\n-                        @Override\n-                        void visitSymbol(Symbol sym) {\n-                            if (sym.kind == VAR &&\n-                                    sym.owner.kind == MTH &&\n-                                    ((VarSymbol)sym).getConstValue() == null) {\n-                                TranslationContext<?> localContext = context();\n-                                while (localContext != null) {\n-                                    if (localContext.tree.getTag() == LAMBDA) {\n-                                        JCTree block = capturedDecl(localContext.depth, sym);\n-                                        if (block == null) break;\n-                                        ((LambdaTranslationContext)localContext).addSymbol(sym, CAPTURED_VAR);\n-                                    }\n-                                    localContext = localContext.prev;\n-                                }\n-                            }\n-                        }\n-                    };\n-                    fvc.scan(localCDef);\n-                }\n-        }\n-        \/\/where\n-        boolean currentlyInClass(Symbol csym) {\n-            for (Frame frame : frameStack) {\n-                if (frame.tree.hasTag(JCTree.Tag.CLASSDEF)) {\n-                    JCClassDecl cdef = (JCClassDecl) frame.tree;\n-                    if (cdef.sym == csym) {\n-                        return true;\n-                    }\n-                }\n+            finally {\n+                frameStack = prevStack;\n@@ -1515,1 +1091,0 @@\n-            return false;\n@@ -1534,9 +1109,3 @@\n-            if (rcontext.needsConversionToLambda()) {\n-                 \/\/ Convert to a lambda, and process as such\n-                MemberReferenceToLambda conv = new MemberReferenceToLambda(tree, rcontext, owner());\n-                analyzeLambda(conv.lambda(), conv.getReceiverExpression());\n-            } else {\n-                super.visitReference(tree);\n-                if (dumpLambdaToMethodStats) {\n-                    log.note(tree, Notes.MrefStat(rcontext.needsAltMetafactory(), null));\n-                }\n+            super.visitReference(tree);\n+            if (dumpLambdaToMethodStats) {\n+                log.note(tree, Notes.MrefStat(rcontext.needsAltMetafactory(), null));\n@@ -1776,36 +1345,0 @@\n-        \/**\n-         *  This is used to filter out those select nodes that need to be adjusted\n-         *  when translating away lambda expressions - at the moment, this is the\n-         *  set of nodes that select `this' (qualified this)\n-         *\/\n-        private boolean lambdaFieldAccessFilter(JCFieldAccess fAccess) {\n-            return (context instanceof LambdaTranslationContext lambdaContext)\n-                    && !fAccess.sym.isStatic()\n-                    && fAccess.name == names._this\n-                    && (fAccess.sym.owner.kind == TYP)\n-                    && !lambdaContext.translatedSymbols.get(CAPTURED_OUTER_THIS).isEmpty();\n-        }\n-\n-        \/**\n-         * This is used to filter out those new class expressions that need to\n-         * be qualified with an enclosing tree\n-         *\/\n-        private boolean lambdaNewClassFilter(TranslationContext<?> context, JCNewClass tree) {\n-            if (context != null\n-                    && tree.encl == null\n-                    && tree.def == null\n-                    && !tree.type.getEnclosingType().hasTag(NONE)) {\n-                Type encl = tree.type.getEnclosingType();\n-                Type current = context.owner.enclClass().type;\n-                while (!current.hasTag(NONE)) {\n-                    if (current.tsym.isSubClass(encl.tsym, types)) {\n-                        return true;\n-                    }\n-                    current = current.getEnclosingType();\n-                }\n-                return false;\n-            } else {\n-                return false;\n-            }\n-        }\n-\n@@ -1921,12 +1454,0 @@\n-            \/**\n-             * to prevent recursion, track local classes processed\n-             *\/\n-            final Set<Symbol> freeVarProcessedLocalClasses;\n-\n-            \/**\n-             * For method references converted to lambdas.  The method\n-             * reference receiver expression. Must be treated like a captured\n-             * variable.\n-             *\/\n-            JCExpression methodReferenceReceiver;\n-\n@@ -1963,7 +1484,4 @@\n-                translatedSymbols.put(PARAM, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(LOCAL_VAR, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_OUTER_THIS, new LinkedHashMap<Symbol, Symbol>());\n-\n-                freeVarProcessedLocalClasses = new HashSet<>();\n+                translatedSymbols.put(PARAM, new LinkedHashMap<>());\n+                translatedSymbols.put(LOCAL_VAR, new LinkedHashMap<>());\n+                translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap<>());\n+                translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap<>());\n@@ -2069,10 +1587,0 @@\n-                    case CAPTURED_OUTER_THIS:\n-                        Name name = names.fromString(sym.flatName().toString().replace('.', '$') + names.dollarThis);\n-                        ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, name, types.erasure(sym.type), translatedSym) {\n-                            @Override\n-                            public Symbol baseSymbol() {\n-                                \/\/keep mapping with original captured symbol\n-                                return sym;\n-                            }\n-                        };\n-                        break;\n@@ -2117,8 +1625,0 @@\n-                if (skind == CAPTURED_THIS && sym != null && sym.kind == TYP && !typesUnderConstruction.isEmpty()) {\n-                    ClassSymbol currentClass = currentClass();\n-                    if (currentClass != null && typesUnderConstruction.contains(currentClass)) {\n-                        \/\/ reference must be to enclosing outer instance, mutate capture kind.\n-                        Assert.check(sym != currentClass); \/\/ should have been caught right in Attr\n-                        skind = CAPTURED_OUTER_THIS;\n-                    }\n-                }\n@@ -2148,14 +1648,0 @@\n-                        case CAPTURED_OUTER_THIS:\n-                            Optional<Symbol> proxy = m.keySet().stream()\n-                                    .filter(out -> lambdaIdent.sym.isMemberOf(out.type.tsym, types))\n-                                    .reduce((a, b) -> a.isEnclosedBy((ClassSymbol)b) ? a : b);\n-                            if (proxy.isPresent()) {\n-                                \/\/ Transform outer instance variable references anchoring them to the captured synthetic.\n-                                Symbol tSym = m.get(proxy.get());\n-                                JCExpression t = make.Ident(tSym).setType(lambdaIdent.sym.owner.type);\n-                                t = make.Select(t, lambdaIdent.name);\n-                                t.setType(lambdaIdent.type);\n-                                TreeInfo.setSymbol(t, lambdaIdent.sym);\n-                                return t;\n-                            }\n-                            break;\n@@ -2167,29 +1653,0 @@\n-            \/* Translate away qualified this expressions, anchoring them to synthetic parameters that\n-               capture the qualified this handle. `fieldAccess' is guaranteed to one such.\n-            *\/\n-            public JCTree translate(JCFieldAccess fieldAccess) {\n-                Assert.check(fieldAccess.name == names._this);\n-                Map<Symbol, Symbol> m = translatedSymbols.get(LambdaSymbolKind.CAPTURED_OUTER_THIS);\n-                if (m.containsKey(fieldAccess.sym.owner)) {\n-                    Symbol tSym = m.get(fieldAccess.sym.owner);\n-                    JCExpression t = make.Ident(tSym).setType(fieldAccess.sym.owner.type);\n-                    return t;\n-                }\n-                return null;\n-            }\n-\n-            \/* Translate away naked new instance creation expressions with implicit enclosing instances,\n-               anchoring them to synthetic parameters that stand proxy for the qualified outer this handle.\n-            *\/\n-            public JCNewClass translate(JCNewClass newClass) {\n-                Assert.check(newClass.clazz.type.tsym.hasOuterInstance() && newClass.encl == null);\n-                Map<Symbol, Symbol> m = translatedSymbols.get(LambdaSymbolKind.CAPTURED_OUTER_THIS);\n-                final Type enclosingType = newClass.clazz.type.getEnclosingType();\n-                if (m.containsKey(enclosingType.tsym)) {\n-                      Symbol tSym = m.get(enclosingType.tsym);\n-                      JCExpression encl = make.Ident(tSym).setType(enclosingType);\n-                      newClass.encl = encl;\n-                }\n-                return newClass;\n-            }\n-\n@@ -2233,4 +1690,0 @@\n-                for (Symbol thisSym : getSymbolMap(CAPTURED_OUTER_THIS).values()) {\n-                    params.append(make.VarDef((VarSymbol) thisSym, null));\n-                    parameterSymbols.append((VarSymbol) thisSym);\n-                }\n@@ -2262,4 +1715,1 @@\n-         * This class retains all the useful information about a method reference;\n-         * the contents of this class are filled by the LambdaAnalyzer visitor,\n-         * and the used by the main translation routines in order to adjust method\n-         * references (i.e. in case a bridge is needed)\n+         * Simple subclass modelling the translation context of a method reference.\n@@ -2269,2 +1719,0 @@\n-            final boolean isSuper;\n-\n@@ -2273,85 +1721,0 @@\n-                this.isSuper = tree.hasKind(ReferenceKind.SUPER);\n-            }\n-\n-            boolean needsVarArgsConversion() {\n-                return tree.varargsElement != null;\n-            }\n-\n-            \/**\n-             * @return Is this an array operation like clone()\n-             *\/\n-            boolean isArrayOp() {\n-                return tree.sym.owner == syms.arrayClass;\n-            }\n-\n-            boolean receiverAccessible() {\n-                \/\/hack needed to workaround 292 bug (7087658)\n-                \/\/when 292 issue is fixed we should remove this and change the backend\n-                \/\/code to always generate a method handle to an accessible method\n-                return tree.ownerAccessible;\n-            }\n-\n-            \/**\n-             * This method should be called only when target release <= 14\n-             * where LambdaMetaFactory does not spin nestmate classes.\n-             *\n-             * This method should be removed when --release 14 is not supported.\n-             *\/\n-            boolean isPrivateInOtherClass() {\n-                assert !nestmateLambdas;\n-                return  (tree.sym.flags() & PRIVATE) != 0 &&\n-                        !types.isSameType(\n-                              types.erasure(tree.sym.enclClass().asType()),\n-                              types.erasure(owner.enclClass().asType()));\n-            }\n-\n-            \/**\n-             * Erasure destroys the implementation parameter subtype\n-             * relationship for intersection types.\n-             * Have similar problems for union types too.\n-             *\/\n-            boolean interfaceParameterIsIntersectionOrUnionType() {\n-                List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n-                for (; tl.nonEmpty(); tl = tl.tail) {\n-                    Type pt = tl.head;\n-                    if (isIntersectionOrUnionType(pt))\n-                        return true;\n-                }\n-                return false;\n-            }\n-\n-            boolean isIntersectionOrUnionType(Type t) {\n-                switch (t.getKind()) {\n-                    case INTERSECTION:\n-                    case UNION:\n-                        return true;\n-                    case TYPEVAR:\n-                        TypeVar tv = (TypeVar) t;\n-                        return isIntersectionOrUnionType(tv.getUpperBound());\n-                }\n-                return false;\n-            }\n-\n-            \/**\n-             * Does this reference need to be converted to a lambda\n-             * (i.e. var args need to be expanded or \"super\" is used)\n-             *\/\n-            final boolean needsConversionToLambda() {\n-                return interfaceParameterIsIntersectionOrUnionType() ||\n-                        isSuper ||\n-                        needsVarArgsConversion() ||\n-                        isArrayOp() ||\n-                        (!nestmateLambdas && isPrivateInOtherClass()) ||\n-                        isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, owner) ||\n-                        !receiverAccessible() ||\n-                        (tree.getMode() == ReferenceMode.NEW &&\n-                          tree.kind != ReferenceKind.ARRAY_CTOR &&\n-                          (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n-            }\n-\n-            Type generatedRefSig() {\n-                return types.erasure(tree.sym.type);\n-            }\n-\n-            Type bridgedRefSig() {\n-                return types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);\n@@ -2371,2 +1734,1 @@\n-        CAPTURED_THIS,  \/\/ class symbols to translated synthetic parameters (for captured member access)\n-        CAPTURED_OUTER_THIS; \/\/ used when `this' capture is illegal, but outer this capture is legit (JDK-8129740)\n+        CAPTURED_THIS;  \/\/ class symbols to translated synthetic parameters (for captured member access)\n@@ -2378,1 +1740,0 @@\n-                case CAPTURED_OUTER_THIS:\n@@ -2420,6 +1781,0 @@\n-    private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n-                                                                          Symbol currentClass) {\n-        return ((targetReference.flags() & PROTECTED) != 0 &&\n-                targetReference.packge() != currentClass.packge());\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":15,"deletions":660,"binary":false,"changes":675,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -38,0 +40,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -39,0 +42,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n@@ -65,0 +69,3 @@\n+\n+import javax.lang.model.type.TypeKind;\n+\n@@ -106,0 +113,1 @@\n+    private int variableIndex = 0;\n@@ -173,0 +181,5 @@\n+    \/**\n+     * The current expected return type.\n+     *\/\n+    Type currentRestype;\n+\n@@ -189,6 +202,0 @@\n-    \/** A map from local variable symbols to their translation (as per LambdaToMethod).\n-     * This is required when a capturing local class is created from a lambda (in which\n-     * case the captured symbols should be replaced with the translated lambda symbols).\n-     *\/\n-    Map<Symbol, Symbol> lambdaTranslationMap = null;\n-\n@@ -1236,8 +1243,4 @@\n-            if (lambdaTranslationMap != null && lambdaTranslationMap.get(sym) != null) {\n-                return make.at(tree.pos).Ident(lambdaTranslationMap.get(sym));\n-            } else {\n-                \/\/ Otherwise replace the variable by its proxy.\n-                sym = proxies.get(sym);\n-                Assert.check(sym != null && (sym.flags_field & FINAL) != 0);\n-                tree = make.at(tree.pos).Ident(sym);\n-            }\n+            \/\/ Otherwise replace the variable by its proxy.\n+            sym = proxies.get(sym);\n+            Assert.check(sym != null && (sym.flags_field & FINAL) != 0);\n+            tree = make.at(tree.pos).Ident(sym);\n@@ -1328,8 +1331,0 @@\n-            } else if (sym.owner.kind == MTH && lambdaTranslationMap != null) {\n-                \/\/sym is a local variable - check the lambda translation map to\n-                \/\/see if sym has been translated to something else in the current\n-                \/\/scope (by LambdaToMethod)\n-                Symbol translatedSym = lambdaTranslationMap.get(sym.baseSymbol());\n-                if (translatedSym != null) {\n-                    tree = make.at(tree.pos).Ident(translatedSym);\n-                }\n@@ -2782,0 +2777,1 @@\n+        Type prevRestype = currentRestype;\n@@ -2784,0 +2780,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -2785,0 +2782,1 @@\n+            currentRestype = types.erasure(tree.type.getReturnType());\n@@ -2787,0 +2785,1 @@\n+            variableIndex = 0;\n@@ -2789,0 +2788,1 @@\n+            currentRestype = prevRestype;\n@@ -2791,0 +2791,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -2869,10 +2870,1 @@\n-            Map<Symbol, Symbol> prevLambdaTranslationMap =\n-                    lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = (tree.sym.flags() & SYNTHETIC) != 0 &&\n-                        tree.sym.name.startsWith(names.lambda) ?\n-                        makeTranslationMap(tree) : null;\n-                super.visitMethodDef(tree);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n+            super.visitMethodDef(tree);\n@@ -2904,11 +2896,0 @@\n-    \/\/where\n-        private Map<Symbol, Symbol> makeTranslationMap(JCMethodDecl tree) {\n-            Map<Symbol, Symbol> translationMap = new HashMap<>();\n-            for (JCVariableDecl vd : tree.params) {\n-                Symbol p = vd.sym;\n-                if (p != p.baseSymbol()) {\n-                    translationMap.put(p.baseSymbol(), p);\n-                }\n-            }\n-            return translationMap;\n-        }\n@@ -2976,1 +2957,1 @@\n-                    names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n+                    names.fromString(\"tmp\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -3135,7 +3116,1 @@\n-            Map<Symbol, Symbol> prevLambdaTranslationMap = lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = null;\n-                translate(tree.def);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n+            translate(tree.def);\n@@ -3361,0 +3336,3 @@\n+        if (tree.args.stream().anyMatch(c -> c == null)) {\n+            throw new AssertionError(\"Whooops before: \" + tree);\n+        }\n@@ -3848,0 +3826,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -3857,3 +3836,7 @@\n-        if (tree.init != null) tree.init = translate(tree.init, tree.type);\n-        result = tree;\n-        currentMethodSym = oldMethodSym;\n+        try {\n+            if (tree.init != null) tree.init = translate(tree.init, tree.type);\n+            result = tree;\n+        } finally {\n+            currentMethodSym = oldMethodSym;\n+            variableIndex = prevVariableIndex;\n+        }\n@@ -3871,2 +3854,8 @@\n-        super.visitBlock(tree);\n-        currentMethodSym = oldMethodSym;\n+        int prevVariableIndex = variableIndex;\n+        try {\n+            variableIndex = 0;\n+            super.visitBlock(tree);\n+        } finally {\n+            currentMethodSym = oldMethodSym;\n+            variableIndex = prevVariableIndex;\n+        }\n@@ -3899,2 +3888,1 @@\n-                                  types.erasure(currentMethodDef\n-                                                .restype.type));\n+                                  currentRestype);\n@@ -3904,0 +3892,345 @@\n+    @Override\n+    public void visitLambda(JCLambda tree) {\n+        Type prevRestype = currentRestype;\n+        try {\n+            currentRestype = types.erasure(tree.getDescriptorType(types)).getReturnType();\n+            tree.body = tree.getBodyKind() == BodyKind.EXPRESSION ?\n+                    translate((JCExpression) tree.body, currentRestype) :\n+                    translate(tree.body);\n+        } finally {\n+            currentRestype = prevRestype;\n+        }\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        if (needsConversionToLambda(tree)) {\n+            \/\/ Convert to a lambda, and process as such\n+            MemberReferenceToLambda conv = new MemberReferenceToLambda(tree);\n+            result = translate(conv.lambda());\n+        } else {\n+            super.visitReference(tree);\n+        }\n+    }\n+    \/\/ where\n+        boolean needsVarArgsConversion(JCMemberReference tree) {\n+            return tree.varargsElement != null;\n+        }\n+\n+        \/**\n+         * @return Is this an array operation like clone()\n+         *\/\n+        boolean isArrayOp(JCMemberReference tree) {\n+            return tree.sym.owner == syms.arrayClass;\n+        }\n+\n+        boolean receiverAccessible(JCMemberReference tree) {\n+            \/\/hack needed to workaround 292 bug (7087658)\n+            \/\/when 292 issue is fixed we should remove this and change the backend\n+            \/\/code to always generate a method handle to an accessible method\n+            return tree.ownerAccessible;\n+        }\n+\n+        \/**\n+         * Erasure destroys the implementation parameter subtype\n+         * relationship for intersection types.\n+         * Have similar problems for union types too.\n+         *\/\n+        boolean interfaceParameterIsIntersectionOrUnionType(JCMemberReference tree) {\n+            List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n+            for (; tl.nonEmpty(); tl = tl.tail) {\n+                Type pt = tl.head;\n+                if (isIntersectionOrUnionType(pt))\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        boolean isIntersectionOrUnionType(Type t) {\n+            switch (t.getKind()) {\n+                case INTERSECTION:\n+                case UNION:\n+                    return true;\n+                case TYPEVAR:\n+                    TypeVar tv = (TypeVar) t;\n+                    return isIntersectionOrUnionType(tv.getUpperBound());\n+            }\n+            return false;\n+        }\n+\n+        private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n+                                                                              Symbol currentClass) {\n+            return ((targetReference.flags() & PROTECTED) != 0 &&\n+                    targetReference.packge() != currentClass.packge());\n+        }\n+\n+        \/**\n+         * This method should be called only when target release <= 14\n+         * where LambdaMetaFactory does not spin nestmate classes.\n+         *\n+         * This method should be removed when --release 14 is not supported.\n+         *\/\n+        boolean isPrivateInOtherClass(JCMemberReference tree) {\n+            assert !target.runtimeUseNestAccess();\n+            return  (tree.sym.flags() & PRIVATE) != 0 &&\n+                    !types.isSameType(\n+                            types.erasure(tree.sym.enclClass().asType()),\n+                            types.erasure(currentClass.asType()));\n+        }\n+\n+        \/**\n+         * Does this reference need to be converted to a lambda\n+         * (i.e. var args need to be expanded or \"super\" is used)\n+         *\/\n+        boolean needsConversionToLambda(JCMemberReference tree) {\n+            return interfaceParameterIsIntersectionOrUnionType(tree) ||\n+                    tree.hasKind(ReferenceKind.SUPER) ||\n+                    needsVarArgsConversion(tree) ||\n+                    isArrayOp(tree) ||\n+                    (!target.runtimeUseNestAccess() && isPrivateInOtherClass(tree)) ||\n+                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass) ||\n+                    !receiverAccessible(tree) ||\n+                    (tree.getMode() == ReferenceMode.NEW &&\n+                            tree.kind != ReferenceKind.ARRAY_CTOR &&\n+                            (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n+        }\n+\n+    \/**\n+     * Converts a method reference which cannot be used directly into a lambda\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private final MethodSymbol owner = new MethodSymbol(0, names.empty, Type.noType, currentClass);\n+\n+        private JCExpression receiverExpression = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree) {\n+            this.tree = tree;\n+        }\n+\n+        JCExpression lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                slam.wasMethodReference = true;\n+                if (receiverExpression != null) {\n+                    \/\/ use a let expression so that the receiver expression is evaluated eagerly\n+                    return make.at(tree.pos).LetExpr(\n+                            make.VarDef(rcvr, translate(receiverExpression)), slam).setType(tree.type);\n+                } else {\n+                    return slam;\n+                }\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            Type samDesc = types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);\n+            List<Type> samPTypes = samDesc.getParameterTypes();\n+            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+\n+            \/\/ Determine the receiver, if any\n+            VarSymbol rcvr;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    \/\/ The receiver is explicit in the method reference\n+                    rcvr = new VarSymbol(SYNTHETIC, names.fromString(\"rec$\"), tree.getQualifierExpression().type, owner);\n+                    rcvr.pos = tree.pos;\n+                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    rcvr = addParameter(\"rec$\", samDesc.getParameterTypes().head, false);\n+                    samPTypes = samPTypes.tail;\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+                default:\n+                    rcvr = null;\n+                    break;\n+            }\n+            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n+            int implSize = implPTypes.size();\n+            int samSize = samPTypes.size();\n+            \/\/ Last parameter to copy from referenced method, exclude final var args\n+            int last = needsVarArgsConversion(tree) ? implSize - 1 : implSize;\n+\n+            \/\/ Failsafe -- assure match-up\n+            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();\n+\n+            \/\/ Use parameter types of the implementation method unless the unerased\n+            \/\/ SAM parameter type is an intersection type, in that case use the\n+            \/\/ erased SAM parameter type so that the supertype relationship\n+            \/\/ the implementation method parameters is not obscured.\n+            \/\/ Note: in this loop, the lists implPTypes, samPTypes, and descPTypes\n+            \/\/ are used as pointers to the current parameter type information\n+            \/\/ and are thus not usable afterwards.\n+            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n+                \/\/ By default use the implementation method parameter type\n+                Type parmType = implPTypes.head;\n+                if (checkForIntersection) {\n+                    if (descPTypes.head.getKind() == TypeKind.INTERSECTION) {\n+                        parmType = samPTypes.head;\n+                    }\n+                    \/\/ If the unerased parameter type is a type variable whose\n+                    \/\/ bound is an intersection (eg. <T extends A & B>) then\n+                    \/\/ use the SAM parameter type\n+                    if (descPTypes.head.getKind() == TypeKind.TYPEVAR) {\n+                        TypeVar tv = (TypeVar) descPTypes.head;\n+                        if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n+                            parmType = samPTypes.head;\n+                        }\n+                    }\n+                }\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                implPTypes = implPTypes.tail;\n+                samPTypes = samPTypes.tail;\n+                descPTypes = descPTypes.tail;\n+            }\n+            \/\/ Flatten out the var args\n+            for (int i = last; i < samSize; ++i) {\n+                addParameter(\"xva$\" + i, tree.varargsElement, true);\n+            }\n+\n+            return rcvr;\n+        }\n+\n+        private JCExpression makeReceiver(VarSymbol rcvr) {\n+            if (rcvr == null) return null;\n+            JCExpression rcvrExpr = make.Ident(rcvr);\n+            boolean protAccess =\n+                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass);\n+            Type rcvrType = tree.ownerAccessible && !protAccess ? tree.sym.enclClass().type\n+                    : tree.expr.type;\n+            if (rcvrType == syms.arrayClass.type) {\n+                \/\/ Map the receiver type to the actually type, not just \"array\"\n+                rcvrType = tree.getQualifierExpression().type;\n+            }\n+            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {\n+                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);\n+            }\n+            return rcvrExpr;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol rcvr) {\n+            JCExpression qualifier =\n+                    (rcvr != null) ?\n+                            makeReceiver(rcvr) :\n+                            tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.sym.erasure(types);\n+\n+            \/\/create the method call expression\n+            JCExpression apply = make.Apply(List.nil(), select,\n+                            convertArgs(tree.sym, args.toList(), tree.varargsElement)).\n+                    setType(tree.sym.erasure(types).getReturnType());\n+\n+            apply = transTypes.coerce(attrEnv, apply,\n+                    types.erasure(tree.referentType.getReturnType()));\n+\n+            setVarargsIfNeeded(apply, tree.varargsElement);\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n+                        List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCNewClass newClass = make.NewClass(null,\n+                        List.nil(),\n+                        make.Type(tree.getQualifierExpression().type),\n+                        convertArgs(tree.sym, args.toList(), tree.varargsElement),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.sym.erasure(types);\n+                newClass.type = tree.getQualifierExpression().type;\n+                setVarargsIfNeeded(newClass, tree.varargsElement);\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n+            vsym.pos = tree.pos;\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+    }\n+\n+    \/**\n+     * Convert method\/constructor arguments by inserting appropriate cast\n+     * as required by type-erasure - this is needed when bridging a lambda\/method\n+     * reference, as the bridged signature might require downcast to be compatible\n+     * with the generated signature.\n+     *\/\n+    private List<JCExpression> convertArgs(Symbol meth, List<JCExpression> args, Type varargsElement) {\n+        Assert.check(meth.kind == MTH);\n+        List<Type> formals = types.erasure(meth.type).getParameterTypes();\n+        if (varargsElement != null) {\n+            Assert.check((meth.flags() & VARARGS) != 0);\n+        }\n+        return transTypes.translateArgs(args, formals, varargsElement, attrEnv);\n+    }\n+\n+    \/**\n+     * Set varargsElement field on a given tree (must be either a new class tree\n+     * or a method call tree)\n+     *\/\n+    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {\n+        if (varargsElement != null) {\n+            switch (tree.getTag()) {\n+                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;\n+                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;\n+                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;\n+                default: throw new AssertionError();\n+            }\n+        }\n+    }\n+\n@@ -4021,1 +4354,1 @@\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -4178,1 +4511,1 @@\n-                                               names.fromString(\"s\" + tree.pos + target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + target.syntheticNameChar()),\n@@ -4184,1 +4517,1 @@\n-                                                 names.fromString(\"tmp\" + tree.pos + target.syntheticNameChar()),\n+                                                 names.fromString(\"tmp\" + variableIndex++ + target.syntheticNameChar()),\n@@ -4326,1 +4659,1 @@\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -4384,1 +4717,1 @@\n-        if (tree.name == names._class) {\n+        if (tree.name == names._class && tree.selected.type.isPrimitiveOrVoid()) {\n@@ -4460,0 +4793,1 @@\n+            currentRestype = null;\n@@ -4489,0 +4823,1 @@\n+            currentRestype = null;\n@@ -4508,0 +4843,19 @@\n+\n+    \/\/ needed for the lambda deserialization method, which is expressed as a big switch on strings\n+    public JCMethodDecl translateMethod(Env<AttrContext> env, JCMethodDecl methodDecl, TreeMaker make) {\n+        try {\n+            this.attrEnv = env;\n+            this.make = make;\n+            this.currentClass = methodDecl.sym.enclClass();\n+            proxies = new HashMap<>();\n+            return translate(methodDecl);\n+        } finally {\n+            this.attrEnv = null;\n+            this.make = null;\n+            this.currentClass = null;\n+            \/\/ the two fields below are set when visiting the method\n+            this.currentMethodSym = null;\n+            this.currentMethodDef = null;\n+            this.proxies = null;\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":417,"deletions":63,"binary":false,"changes":480,"status":"modified"},{"patch":"@@ -1621,8 +1621,0 @@\n-            if (scanner.hasLambdas) {\n-                if (shouldStop(CompileState.UNLAMBDA))\n-                    return;\n-\n-                env.tree = LambdaToMethod.instance(context).translateTopLevelClass(env, env.tree, localMake);\n-                compileStates.put(env, CompileState.UNLAMBDA);\n-            }\n-\n@@ -1650,0 +1642,10 @@\n+            if (scanner.hasLambdas) {\n+                if (shouldStop(CompileState.UNLAMBDA))\n+                    return;\n+\n+                for (JCTree def : cdefs) {\n+                    LambdaToMethod.instance(context).translateTopLevelClass(env, def, localMake);\n+                }\n+                compileStates.put(env, CompileState.UNLAMBDA);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2923,1 +2923,1 @@\n-                    case NULL: case IDENTIFIER: case TRUE: case FALSE:\n+                    case NULL: case IDENTIFIER: case UNDERSCORE: case TRUE: case FALSE:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2016,0 +2016,1 @@\n+        public boolean wasMethodReference;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -347,0 +347,1 @@\n+            result = tree;\n@@ -352,0 +353,1 @@\n+            result = tree;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,0 +167,5 @@\n+    \/\/ CTS mode variant used by the token, as described in Addendum to NIST\n+    \/\/ Special Publication 800-38A, \"Recommendation for Block Cipher Modes\n+    \/\/ of Operation: Three Variants of Ciphertext Stealing for CBC Mode\".\n+    private Token.CTSVariant ctsVariant = null;\n+\n@@ -324,0 +329,4 @@\n+    Token.CTSVariant getCTSVariant() {\n+        return ctsVariant;\n+    }\n+\n@@ -475,0 +484,2 @@\n+            case \"cipherTextStealingVariant\"->\n+                ctsVariant = parseEnumEntry(Token.CTSVariant.class, st.sval);\n@@ -630,0 +641,11 @@\n+    private <E extends Enum<E>> E parseEnumEntry(Class<E> enumClass,\n+            String keyword) throws IOException {\n+        String value = parseStringEntry(keyword);\n+        try {\n+            return Enum.valueOf(enumClass, value);\n+        } catch (IllegalArgumentException ignored) {\n+            throw excToken(keyword + \" must be one of \" +\n+                    Arrays.toString(enumClass.getEnumConstants()) + \", read:\");\n+        }\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * This class is designed to support ECB, CBC, CTR with NoPadding\n+ * This class is designed to support ECB, CBC, CTR, CTS with NoPadding\n@@ -63,11 +63,3 @@\n-    \/\/ mode constant for ECB mode\n-    private static final int MODE_ECB = 3;\n-    \/\/ mode constant for CBC mode\n-    private static final int MODE_CBC = 4;\n-    \/\/ mode constant for CTR mode\n-    private static final int MODE_CTR = 5;\n-\n-    \/\/ padding constant for NoPadding\n-    private static final int PAD_NONE = 5;\n-    \/\/ padding constant for PKCS5Padding\n-    private static final int PAD_PKCS5 = 6;\n+    \/\/ mode and padding constants\n+    private enum Mode {ECB \/* or stream ciphers *\/, CBC, CTR, CTS}\n+    private enum Pad {NONE, PKCS5}\n@@ -149,2 +141,2 @@\n-    \/\/ mode, one of MODE_* above (MODE_ECB for stream ciphers)\n-    private int blockMode;\n+    \/\/ mode, Mode.ECB for stream ciphers\n+    private final Mode blockMode;\n@@ -155,2 +147,2 @@\n-    \/\/ padding type, on of PAD_* above (PAD_NONE for stream ciphers)\n-    private int paddingType;\n+    \/\/ padding type, Pad.NONE for stream ciphers\n+    private Pad paddingType;\n@@ -166,1 +158,1 @@\n-    \/\/ original IV, if in MODE_CBC or MODE_CTR\n+    \/\/ original IV, if in Mode.CBC, Mode.CTR or Mode.CTS\n@@ -211,2 +203,1 @@\n-        this.blockMode =\n-            (algoParts.length > 1 ? parseMode(algoParts[1]) : MODE_ECB);\n+        blockMode = algoParts.length > 1 ? parseMode(algoParts[1]) : Mode.ECB;\n@@ -230,1 +221,1 @@\n-    private int parseMode(String mode) throws NoSuchAlgorithmException {\n+    private Mode parseMode(String mode) throws NoSuchAlgorithmException {\n@@ -232,12 +223,11 @@\n-        return switch (mode) {\n-            case \"ECB\" -> MODE_ECB;\n-            case \"CBC\" -> {\n-                if (blockSize == 0) {\n-                    throw new NoSuchAlgorithmException\n-                            (\"CBC mode not supported with stream ciphers\");\n-                }\n-                yield MODE_CBC;\n-            }\n-            case \"CTR\" -> MODE_CTR;\n-            default -> throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n-        };\n+        Mode result;\n+        try {\n+            result = Mode.valueOf(mode);\n+        } catch (IllegalArgumentException ignored) {\n+            throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n+        }\n+        if (blockSize == 0 && result != Mode.ECB) {\n+            throw new NoSuchAlgorithmException(\n+                    result + \" mode not supported with stream ciphers\");\n+        }\n+        return result;\n@@ -253,1 +243,10 @@\n-            paddingType = PAD_NONE;\n+            paddingType = Pad.NONE;\n+            if (blockMode == Mode.CTS) {\n+                \/\/ Buffer at least two blocks (where the last one may be\n+                \/\/ partial). When using NSS, buffer one more block to avoid\n+                \/\/ NSS Bug 1823875: \"AES CTS decryption does not update\n+                \/\/ its own context's IV on full blocks input\"\n+                \/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1823875#c2\n+                int bufferedBlocks = P11Util.isNSS(token) ? 3 : 2;\n+                padBuffer = new byte[bufferedBlocks * blockSize];\n+            }\n@@ -255,3 +254,3 @@\n-            if (this.blockMode == MODE_CTR) {\n-                throw new NoSuchPaddingException\n-                    (\"PKCS#5 padding not supported with CTR mode\");\n+            if (blockMode == Mode.CTR || blockMode == Mode.CTS) {\n+                throw new NoSuchPaddingException(\"PKCS#5 padding not \" +\n+                        \"supported with \" + blockMode + \" mode\");\n@@ -259,1 +258,1 @@\n-            paddingType = PAD_PKCS5;\n+            paddingType = Pad.PKCS5;\n@@ -374,1 +373,1 @@\n-        if (blockMode == MODE_ECB) { \/\/ ECB or stream cipher\n+        if (blockMode == Mode.ECB) { \/\/ ECB or stream cipher\n@@ -384,1 +383,1 @@\n-        } else { \/\/ MODE_CBC or MODE_CTR\n+        } else { \/\/ Mode.CBC, Mode.CTR or Mode.CTS\n@@ -387,5 +386,3 @@\n-                    String exMsg =\n-                        (blockMode == MODE_CBC ?\n-                         \"IV must be specified for decryption in CBC mode\" :\n-                         \"IV must be specified for decryption in CTR mode\");\n-                    throw new InvalidAlgorithmParameterException(exMsg);\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"IV must be specified for decryption in \" +\n+                            blockMode + \" mode\");\n@@ -436,0 +433,3 @@\n+            if (padBuffer != null) {\n+                Arrays.fill(padBuffer, (byte) 0);\n+            }\n@@ -490,1 +490,1 @@\n-            CK_MECHANISM mechParams = (blockMode == MODE_CTR ?\n+            CK_MECHANISM mechParams = (blockMode == Mode.CTR ?\n@@ -515,1 +515,3 @@\n-        if (blockSize != 0 && blockMode != MODE_CTR) {\n+        if (blockMode == Mode.CTS) {\n+            result -= getCTSMustBeBuffered(result);\n+        } else if (blockSize != 0 && blockMode != Mode.CTR) {\n@@ -529,1 +531,1 @@\n-        if (blockSize != 0 && encrypt && paddingType != PAD_NONE) {\n+        if (blockSize != 0 && encrypt && paddingType != Pad.NONE) {\n@@ -607,1 +609,50 @@\n-            if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+            if (blockMode == Mode.CTS) {\n+                \/\/ decide how to split the total data (totalInLen) between\n+                \/\/ the token (dataForP11Update) and padBuffer\n+                \/\/ (newPadBufferLen)\n+                int totalInLen = padBufferLen + inLen;\n+                newPadBufferLen = getCTSMustBeBuffered(totalInLen);\n+                int dataForP11Update = totalInLen - newPadBufferLen;\n+                if (dataForP11Update > 0 && padBufferLen > 0) {\n+                    \/\/ there is data for the token and part of it is in\n+                    \/\/ padBuffer\n+                    int flushFromPadBuffer;\n+                    int fillLen = getBytesToCompleteBlock(padBufferLen);\n+                    if (dataForP11Update >= padBufferLen + fillLen) {\n+                        \/\/ flush the whole padBuffer\n+                        if (fillLen > 0) {\n+                            \/\/ complete the last padBuffer block from the\n+                            \/\/ input\n+                            bufferInputBytes(in, inOfs, fillLen);\n+                            inOfs += fillLen;\n+                            inLen -= fillLen;\n+                        }\n+                        flushFromPadBuffer = padBufferLen;\n+                    } else {\n+                        \/\/ There is not enough input data available to\n+                        \/\/ complete the padBuffer to a multiple of block\n+                        \/\/ size. Flush part of the padBuffer (up to a\n+                        \/\/ multiple of blockSize) now. Shift the remaining\n+                        \/\/ padBuffer data and buffer more up to completing\n+                        \/\/ newPadBufferLen later.\n+                        flushFromPadBuffer = dataForP11Update;\n+                    }\n+                    if (encrypt) {\n+                        k = token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, flushFromPadBuffer,\n+                                0, out, outOfs, outLen);\n+                    } else {\n+                        k = token.p11.C_DecryptUpdate(session.id(),\n+                                0, padBuffer, 0, flushFromPadBuffer,\n+                                0, out, outOfs, outLen);\n+                    }\n+                    padBufferLen -= flushFromPadBuffer;\n+                    if (padBufferLen > 0) {\n+                        \/\/ shift remaining data to the padBuffer start\n+                        System.arraycopy(padBuffer, flushFromPadBuffer,\n+                                padBuffer, 0, padBufferLen);\n+                    }\n+                }\n+                newPadBufferLen -= padBufferLen;\n+                inLen -= newPadBufferLen;\n+            } else if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n@@ -652,1 +703,2 @@\n-            if (paddingObj != null && newPadBufferLen > 0) {\n+            if ((blockMode == Mode.CTS || paddingObj != null) &&\n+                    newPadBufferLen > 0) {\n@@ -718,1 +770,50 @@\n-                if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+                if (blockMode == Mode.CTS) {\n+                    \/\/ decide how to split the total data (totalInLen) between\n+                    \/\/ the token (dataForP11Update) and padBuffer\n+                    \/\/ (newPadBufferLen)\n+                    int totalInLen = padBufferLen + inLen;\n+                    newPadBufferLen = getCTSMustBeBuffered(totalInLen);\n+                    int dataForP11Update = totalInLen - newPadBufferLen;\n+                    if (dataForP11Update > 0 && padBufferLen > 0) {\n+                        \/\/ there is data for the token and part of it is in\n+                        \/\/ padBuffer\n+                        int flushFromPadBuffer;\n+                        int fillLen = getBytesToCompleteBlock(padBufferLen);\n+                        if (dataForP11Update >= padBufferLen + fillLen) {\n+                            \/\/ flush the whole padBuffer\n+                            if (fillLen > 0) {\n+                                \/\/ complete the last padBuffer block from the\n+                                \/\/ input\n+                                bufferInputBytes(inBuffer, fillLen);\n+                                inOfs += fillLen;\n+                                inLen -= fillLen;\n+                            }\n+                            flushFromPadBuffer = padBufferLen;\n+                        } else {\n+                            \/\/ There is not enough input data available to\n+                            \/\/ complete the padBuffer to a multiple of block\n+                            \/\/ size. Flush part of the padBuffer (up to a\n+                            \/\/ multiple of blockSize) now. Shift the remaining\n+                            \/\/ padBuffer data and buffer more up to completing\n+                            \/\/ newPadBufferLen later.\n+                            flushFromPadBuffer = dataForP11Update;\n+                        }\n+                        if (encrypt) {\n+                            k = token.p11.C_EncryptUpdate(session.id(),\n+                                    0, padBuffer, 0, flushFromPadBuffer,\n+                                    outAddr, outArray, outOfs, outLen);\n+                        } else {\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, flushFromPadBuffer,\n+                                    outAddr, outArray, outOfs, outLen);\n+                        }\n+                        padBufferLen -= flushFromPadBuffer;\n+                        if (padBufferLen > 0) {\n+                            \/\/ shift remaining data to the padBuffer start\n+                            System.arraycopy(padBuffer, flushFromPadBuffer,\n+                                    padBuffer, 0, padBufferLen);\n+                        }\n+                    }\n+                    newPadBufferLen -= padBufferLen;\n+                    inLen -= newPadBufferLen;\n+                } else if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n@@ -771,1 +872,2 @@\n-                if (paddingObj != null && newPadBufferLen > 0) {\n+                if ((blockMode == Mode.CTS || paddingObj != null) &&\n+                        newPadBufferLen > 0) {\n@@ -833,0 +935,4 @@\n+                } else if (blockMode == Mode.CTS) {\n+                    k = token.p11.C_EncryptUpdate(session.id(),\n+                            0, padBuffer, 0, padBufferLen,\n+                            0, out, outOfs, outLen);\n@@ -842,0 +948,3 @@\n+                if (blockMode == Mode.CTS) {\n+                    convertCTSVariant(null, out, outOfs + k);\n+                }\n@@ -866,0 +975,8 @@\n+                    if (blockMode == Mode.CTS) {\n+                        convertCTSVariant(null, padBuffer, padBufferLen);\n+                        k = token.p11.C_DecryptUpdate(session.id(),\n+                                0, padBuffer, 0, padBufferLen,\n+                                0, out, outOfs, outLen);\n+                        outOfs += k;\n+                        outLen -= k;\n+                    }\n@@ -867,1 +984,1 @@\n-                    k = token.p11.C_DecryptFinal(session.id(), 0, out, outOfs,\n+                    k += token.p11.C_DecryptFinal(session.id(), 0, out, outOfs,\n@@ -931,0 +1048,4 @@\n+                    } else if (blockMode == Mode.CTS) {\n+                       k = token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, padBufferLen,\n+                                outAddr, outArray, outOfs, outLen);\n@@ -940,0 +1061,3 @@\n+                    if (blockMode == Mode.CTS) {\n+                        convertCTSVariant(outBuffer, outArray, outOfs + k);\n+                    }\n@@ -945,1 +1069,0 @@\n-\n@@ -967,0 +1090,8 @@\n+                        if (blockMode == Mode.CTS) {\n+                            convertCTSVariant(null, padBuffer, padBufferLen);\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, padBufferLen,\n+                                    outAddr, outArray, outOfs, outLen);\n+                            outOfs += k;\n+                            outLen -= k;\n+                        }\n@@ -968,1 +1099,1 @@\n-                        k = token.p11.C_DecryptFinal(session.id(),\n+                        k += token.p11.C_DecryptFinal(session.id(),\n@@ -991,0 +1122,77 @@\n+    private int getBytesToCompleteBlock(int availableBytes) {\n+        int partBlock = availableBytes & (blockSize - 1);\n+        return partBlock == 0 ? 0 : blockSize - partBlock;\n+    }\n+\n+    private int getCTSMustBeBuffered(int availableBytes) {\n+        return Math.min(availableBytes,\n+                padBuffer.length - getBytesToCompleteBlock(availableBytes));\n+    }\n+\n+    \/**\n+     * The ciphertext ordering for the three variants can be depicted as\n+     * follows, where 'p' is the penultimate block (which may be partial\n+     * or full), and 'f' the full final block:\n+     *\n+     *                    'p' is a partial block   'p' is a full block\n+     *                   ------------------------ ---------------------\n+     *   CS1 (NIST)     |     .... pp ffff       |    .... pppp ffff\n+     *   CS2 (Schneier) |     .... ffff pp       |    .... pppp ffff\n+     *   CS3 (Kerberos) |     .... ffff pp       |    .... ffff pppp\n+     *\n+     * After encryption, we get the ciphertext from the token formatted as\n+     * specified in the SunPKCS11 'cipherTextStealingVariant' configuration\n+     * property. Conversely, before decryption, the ciphertext has to be passed\n+     * to the token according to the previous formatting. This method converts\n+     * the ciphertext between the format used by the token and the one used by\n+     * SunJCE's \"AES\/CTS\/NoPadding\" implementation (CS3 as described by RFC\n+     * 2040, section 8).\n+     *\/\n+    private void convertCTSVariant(ByteBuffer ciphertextBuf,\n+            byte[] ciphertextArr, int ciphertextEnd) {\n+        if (padBufferLen == blockSize) {\n+            \/\/ No reordering needed for a single block\n+            return;\n+        }\n+        assert token.ctsVariant != null : \"CTS algorithms should not be \" +\n+                \"registered if the CTS variant of the token is unknown\";\n+        if (token.ctsVariant == Token.CTSVariant.CS3) {\n+            \/\/ Already CS3\n+            return;\n+        }\n+        int pad = padBufferLen % blockSize;\n+        if (token.ctsVariant == Token.CTSVariant.CS2 && pad != 0) {\n+            \/\/ CS2 and 'p' is a partial block, equal to CS3\n+            return;\n+        }\n+        if (ciphertextArr != null) {\n+            ciphertextBuf = ByteBuffer.wrap(ciphertextArr);\n+        }\n+        if (ciphertextBuf != null) {\n+            \/\/ No assumptions should be made about the current ciphertextBuf\n+            \/\/ position. Additionally, if ciphertextBuf was not created here,\n+            \/\/ the position should not be altered. To ensure this, use offsets\n+            \/\/ to read and write bytes from the last two blocks (i.e. absolute\n+            \/\/ ByteBuffer operations). Other blocks should not be modified.\n+            pad = pad == 0 ? blockSize : pad;\n+            if (encrypt) {\n+                \/\/ .... pp[pp] ffff -> .... ffff pp[pp]\n+                swapLastTwoBlocks(ciphertextBuf, ciphertextEnd, pad, blockSize);\n+            } else {\n+                \/\/ .... ffff pp[pp] -> .... pp[pp] ffff\n+                swapLastTwoBlocks(ciphertextBuf, ciphertextEnd, blockSize, pad);\n+            }\n+        }\n+    }\n+\n+    private static void swapLastTwoBlocks(ByteBuffer ciphertextBuf,\n+            int ciphertextEnd, int prevBlockLen, int lastBlockLen) {\n+        \/\/ .... prevBlock lastBlock -> .... lastBlock prevBlock\n+        int prevBlockStart = ciphertextEnd - prevBlockLen - lastBlockLen;\n+        byte[] prevBlockBackup = new byte[prevBlockLen];\n+        ciphertextBuf.get(prevBlockStart, prevBlockBackup);\n+        ciphertextBuf.put(prevBlockStart, ciphertextBuf,\n+                ciphertextEnd - lastBlockLen, lastBlockLen);\n+        ciphertextBuf.put(ciphertextEnd - prevBlockLen, prevBlockBackup);\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":263,"deletions":55,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -863,0 +863,9 @@\n+        d(CIP, \"AES\/CTS\/NoPadding\",             P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_128\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_192\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_256\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+\n@@ -1293,1 +1302,7 @@\n-\n+            if (longMech == CKM_AES_CTS && token.ctsVariant == null) {\n+                if (showInfo) {\n+                    System.out.println(\"DISABLED due to an unspecified \" +\n+                            \"cipherTextStealingVariant in configuration\");\n+                }\n+                continue;\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+    public enum CTSVariant {CS1, CS2, CS3}\n@@ -68,0 +69,2 @@\n+    final transient CTSVariant ctsVariant;\n+\n@@ -149,0 +152,1 @@\n+        ctsVariant = getCTSVariant();\n@@ -415,0 +419,13 @@\n+    private CTSVariant getCTSVariant() {\n+        CTSVariant ctsVariant = config.getCTSVariant();\n+        if (ctsVariant != null) {\n+            return ctsVariant;\n+        }\n+        \/\/ 'cipherTextStealingVariant' needs an explicit value for the\n+        \/\/ CKM_AES_CTS mechanism to be enabled. In the case of NSS we know\n+        \/\/ that this value is 'CS1', so we can set it for the user. See:\n+        \/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=373108#c7\n+        \/\/ https:\/\/github.com\/nss-dev\/nss\/blob\/NSS_3_99_RTM\/lib\/freebl\/cts.c#L65\n+        return P11Util.isNSS(this) ? CTSVariant.CS1 : null;\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-  private static int CLASS_STATE_BEING_LINKED;\n@@ -104,1 +103,0 @@\n-    CLASS_STATE_BEING_LINKED = db.lookupIntConstant(\"InstanceKlass::being_linked\").intValue();\n@@ -161,1 +159,0 @@\n-     public static final ClassState BEING_LINKED = new ClassState(\"beingLinked\");\n@@ -185,2 +182,0 @@\n-     } else if (state == CLASS_STATE_BEING_LINKED) {\n-        return ClassState.BEING_LINKED;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        String path = System.getenv(\"PATH\");\n+        String path = \"\/usr\/bin\" + File.pathSeparator + \"\/bin\";\/\/was: System.getenv(\"PATH\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/OSUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+    \/\/ The set of common CPU registers available on all x64 platforms.\n@@ -88,3 +89,1 @@\n-        r8, r9, r10, r11, r12, r13, r14, r15,\n-        r16, r17, r18, r19, r20, r21, r22, r23,\n-        r24, r25, r26, r27, r28, r29, r30, r31\n+        r8, r9, r10, r11, r12, r13, r14, r15\n@@ -165,2 +164,0 @@\n-        r16,  r17,  r18,   r19,   r20,   r21,   r22,   r23,\n-        r24,  r25,  r26,   r27,   r28,   r29,   r30,   r31,\n@@ -182,0 +179,2 @@\n+        r16,  r17,  r18,   r19,   r20,   r21,   r22,   r23,\n+        r24,  r25,  r26,   r27,   r28,   r29,   r30,   r31,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.vm.ci.common.JVMCIError;\n@@ -84,0 +85,7 @@\n+        \/\/ registers is expected to mention all registers in order of their encoding.\n+        for (int i = 0; i < registers.size(); ++i) {\n+            if (registers.get(i).number != i) {\n+                Register reg = registers.get(i);\n+                throw new JVMCIError(\"%s: %d != %d\", reg, reg.number, i);\n+            }\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/Architecture.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-    flex: 2.6 1 0;\n+    flex: 3 1 0;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-                        for (var flag : info.flags()) {\n+                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS)) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,6 @@\n+import java.lang.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Modifier;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.Set;\n@@ -41,0 +47,20 @@\n+    private static final Map<AccessFlag.Location, Integer> LOCATION_MASKS;\n+\n+    static {\n+        var map = new EnumMap<AccessFlag.Location, Integer>(AccessFlag.Location.class);\n+        for (var loc : AccessFlag.Location.values()) {\n+            map.put(loc, 0);\n+        }\n+\n+        for (var flag : AccessFlag.values()) {\n+            for (var loc : flag.locations()) {\n+                map.compute(loc, (_, v) -> v | flag.mask());\n+            }\n+        }\n+\n+        \/\/ Peculiarities from AccessFlag.maskToAccessFlag\n+        map.compute(AccessFlag.Location.METHOD, (_, v) -> v | Modifier.STRICT);\n+\n+        LOCATION_MASKS = map;\n+    }\n+\n@@ -49,0 +75,14 @@\n+    protected Set<AccessFlag> flagsReportUnknown(AccessFlags flags) {\n+        return maskToAccessFlagsReportUnknown(flags.flagsMask(), flags.location());\n+    }\n+\n+    protected Set<AccessFlag> maskToAccessFlagsReportUnknown(int mask, AccessFlag.Location location) {\n+        try {\n+            return AccessFlag.maskToAccessFlags(mask, location);\n+        } catch (IllegalArgumentException ex) {\n+            mask &= LOCATION_MASKS.get(location);\n+            report(\"Access Flags: \" + ex.getMessage());\n+            return AccessFlag.maskToAccessFlags(mask, location);\n+        }\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/BasicWriter.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-        writeModifiers(flags.flags().stream().filter(fl -> fl.sourceModifier())\n+        writeModifiers(flagsReportUnknown(flags).stream().filter(fl -> fl.sourceModifier())\n@@ -449,1 +449,1 @@\n-                    flags.flags().stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n+                    flagsReportUnknown(flags).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n@@ -481,1 +481,1 @@\n-        for (var f : AccessFlags.ofMethod(flags).flags())\n+        for (var f : flagsReportUnknown(m.flags()))\n@@ -564,1 +564,1 @@\n-            for (var f : AccessFlags.ofMethod(flags).flags()) {\n+            for (var f : flagsReportUnknown(m.flags())) {\n@@ -797,11 +797,3 @@\n-    private static Set<String> getClassModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n-                ? mask & ~ACC_ABSTRACT : mask).flags());\n-    }\n-\n-    private static Set<String> getMethodModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofMethod(mask).flags());\n-    }\n-\n-    private static Set<String> getFieldModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofField(mask).flags());\n+    private Set<String> getClassModifiers(int mask) {\n+        return getModifiers(flagsReportUnknown(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n+                ? mask & ~ACC_ABSTRACT : mask)));\n@@ -817,2 +809,2 @@\n-    private static Set<String> getClassFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofClass(mask).flags());\n+    private Set<String> getClassFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofClass(mask)));\n@@ -821,2 +813,2 @@\n-    private static Set<String> getMethodFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofMethod(mask).flags());\n+    private Set<String> getMethodFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofMethod(mask)));\n@@ -825,2 +817,2 @@\n-    private static Set<String> getFieldFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofField(mask).flags());\n+    private Set<String> getFieldFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofField(mask)));\n@@ -843,36 +835,0 @@\n-    public static enum AccessFlag {\n-        ACC_PUBLIC      (ClassFile.ACC_PUBLIC,       \"public\",       true,  true,  true,  true ),\n-        ACC_PRIVATE     (ClassFile.ACC_PRIVATE,      \"private\",      false, true,  true,  true ),\n-        ACC_PROTECTED   (ClassFile.ACC_PROTECTED,    \"protected\",    false, true,  true,  true ),\n-        ACC_STATIC      (ClassFile.ACC_STATIC,       \"static\",       false, true,  true,  true ),\n-        ACC_FINAL       (ClassFile.ACC_FINAL,        \"final\",        true,  true,  true,  true ),\n-        ACC_SUPER       (ClassFile.ACC_SUPER,        null,           true,  false, false, false),\n-        ACC_SYNCHRONIZED(ClassFile.ACC_SYNCHRONIZED, \"synchronized\", false, false, false, true ),\n-        ACC_VOLATILE    (ClassFile.ACC_VOLATILE,     \"volatile\",     false, false, true,  false),\n-        ACC_BRIDGE      (ClassFile.ACC_BRIDGE,       null,           false, false, false, true ),\n-        ACC_TRANSIENT   (ClassFile.ACC_TRANSIENT,    \"transient\",    false, false, true,  false),\n-        ACC_VARARGS     (ClassFile.ACC_VARARGS,      null,           false, false, false, true ),\n-        ACC_NATIVE      (ClassFile.ACC_NATIVE,       \"native\",       false, false, false, true ),\n-        ACC_INTERFACE   (ClassFile.ACC_INTERFACE,    null,           true,   true, false, false),\n-        ACC_ABSTRACT    (ClassFile.ACC_ABSTRACT,     \"abstract\",     true,   true, false, true ),\n-        ACC_STRICT      (ClassFile.ACC_STRICT,       \"strictfp\",     false, false, false, true ),\n-        ACC_SYNTHETIC   (ClassFile.ACC_SYNTHETIC,    null,           true,  true,  true,  true ),\n-        ACC_ANNOTATION  (ClassFile.ACC_ANNOTATION,   null,           true,   true, false, false),\n-        ACC_ENUM        (ClassFile.ACC_ENUM,         null,           true,   true, true,  false),\n-        ACC_MODULE      (ClassFile.ACC_MODULE,       null,           true,  false, false, false);\n-\n-        public final int flag;\n-        public final String modifier;\n-        public final boolean isClass, isInnerClass, isField, isMethod;\n-\n-        AccessFlag(int flag, String modifier, boolean isClass,\n-                boolean isInnerClass, boolean isField, boolean isMethod) {\n-            this.flag = flag;\n-            this.modifier = modifier;\n-            this.isClass = isClass;\n-            this.isInnerClass = isInnerClass;\n-            this.isField = isField;\n-            this.isMethod = isMethod;\n-        }\n-    }\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":13,"deletions":57,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -870,1 +870,1 @@\n-                if (className.indexOf('.') > 0) {\n+                if (className.indexOf('.') > 0 || className.indexOf('\/') > 0) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/JavapTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-        \/\/ JVM::getChunkStartNanos() may return a bumped timestamp, +1 ns or +2 ns.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMSupport.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.Map;\n+import java.util.HashMap;\n@@ -59,0 +61,1 @@\n+    private final Map<String, Long> waste = new HashMap<>();\n@@ -181,0 +184,10 @@\n+        if (Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG)) {\n+            \/\/ Log largest waste first\n+            waste.entrySet().stream()\n+                 .sorted((a, b) -> b.getValue().compareTo(a.getValue()))\n+                 .forEach(entry -> {\n+                     String msg = \"Total chunk waste by \" + entry.getKey() + \": \" + entry.getValue() + \" bytes.\";\n+                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG, msg);\n+                 });\n+        }\n+        waste.clear();\n@@ -219,0 +232,14 @@\n+        if (Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG)) {\n+            for (CheckpointPool pool : event.getPools()) {\n+                for (PoolEntry pe : pool.getEntries()) {\n+                    if (!pe.isTouched()) {\n+                        String name = pe.getType().getName();\n+                        long amount = pe.getEndPosition() - pe.getStartPosition();\n+                        waste.merge(pe.getType().getName(), amount, Long::sum);\n+                        String msg = \"Unreferenced constant ID \" + pe.getId() +\n+                                     \" of type \"+ name + \" using \" + amount + \" bytes.\";\n+                        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, msg);\n+                    }\n+                }\n+            }\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/ChunkWriter.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -157,1 +157,6 @@\n-            terminal = TerminalBuilder.builder().inputStreamWrapper(in -> {\n+            \/\/on platforms which are known to be fully supported by\n+            \/\/the FFMTerminalProvider, do not permit the ExecTerminalProvider:\n+            boolean allowExecTerminal = !OSUtils.IS_WINDOWS &&\n+                                        !OSUtils.IS_LINUX &&\n+                                        !OSUtils.IS_OSX;\n+            terminal = TerminalBuilder.builder().exec(allowExecTerminal).inputStreamWrapper(in -> {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -252,1 +252,0 @@\n-         * @since 14\n@@ -254,0 +253,1 @@\n+         * @since 17\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Snippet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,0 +161,2 @@\n+     *\n+     * @since 10\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysis.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -253,0 +253,2 @@\n+     *\n+     * @since 10\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/tool\/JavaShellToolBuilder.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+ *\n+ * @since 1.5\n","filename":"src\/jdk.jsobject\/share\/classes\/netscape\/javascript\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+@Deprecated(since=\"24\", forRemoval=true)\n","filename":"src\/jdk.jstatd\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,2 @@\n+        System.err.println(\"WARNING: jstatd is deprecated and will be removed in a future release.\");\n+\n","filename":"src\/jdk.jstatd\/share\/classes\/sun\/tools\/jstatd\/Jstatd.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,3 @@\n-\\f[B]Note:\\f[R] This command is experimental and unsupported.\n+\\f[B]WARNING:\\f[R] This command is experimental, unsupported, and\n+deprecated.\n+It will be removed in a future release.\n","filename":"src\/jdk.jstatd\/share\/man\/jstatd.1","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-      QuickSort::sort(to_release, nrelease, PointerCompare(), false);\n+      QuickSort::sort(to_release, nrelease, PointerCompare());\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"unittest.hpp\"\n+#include \"nmt\/arrayWithFreeList.hpp\"\n+\n+using A = ArrayWithFreeList<int, mtTest>;\n+\n+class ArrayWithFreeListTest  : public testing::Test {\n+};\n+\n+\/\/ A linked list which sets the allocator itself\n+template<typename E>\n+struct LL {\n+  struct Node;\n+  using NodeAllocator = ArrayWithFreeList<Node, mtTest>;\n+  using NodePtr = typename NodeAllocator::I;\n+  NodeAllocator alloc;\n+  struct Node {\n+    E e;\n+    NodePtr next;\n+  };\n+\n+  NodePtr start;\n+  LL()\n+  : start{NodeAllocator::nil} {\n+  }\n+\n+  void push(E e) {\n+    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n+    NodePtr& current = start;\n+    if (current == NodeAllocator::nil) {\n+      current = new_element;\n+      return;\n+    }\n+    alloc.at(new_element).next = current;\n+    current = new_element;\n+  };\n+\n+  E pop() {\n+    assert(start != NodeAllocator::nil, \"must be\");\n+    Node& n = alloc.at(start);\n+    E e = n.e;\n+    NodePtr next_start = n.next;\n+    alloc.deallocate(start);\n+    start = next_start;\n+    return e;\n+  }\n+};\n+\n+\/\/ A linked list which is capable of having multiple different allocators. This is done through higher-kinded types.\n+\/\/ That's a very fancy word that means that a templated type like Foo<E> can be passed around like only Foo at first\n+\/\/ and then be 'applied' to some E. Think of it like passing around a lambda or function pointer, but on a template level,\n+\/\/ where Foo is a function that can be called on some type with the return type being Foo<E>.\n+template<typename E, template<typename, MEMFLAGS> class Allocator>\n+struct LL2 {\n+  struct Node;\n+  using NodeAllocator = Allocator<Node, mtTest>;\n+  using NodePtr = typename NodeAllocator::I;\n+  NodeAllocator alloc;\n+  struct Node {\n+    E e;\n+    NodePtr next;\n+  };\n+\n+  NodePtr start;\n+  LL2()\n+    : start(NodeAllocator::nil) {\n+  }\n+\n+  void push(E e) {\n+    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n+    NodePtr& current = start;\n+    if (current == NodeAllocator::nil) {\n+      current = new_element;\n+      return;\n+    }\n+    alloc.at(new_element).next = current;\n+    current = new_element;\n+  };\n+\n+  E pop() {\n+    assert(start != NodeAllocator::nil, \"must be\");\n+    Node& n = alloc.at(start);\n+    E e = n.e;\n+    NodePtr next_start = n.next;\n+    alloc.deallocate(start);\n+    start = next_start;\n+    return e;\n+  }\n+};\n+\n+template<typename List>\n+void test_with_list(List& list) {\n+  list.push(1);\n+  list.push(2);\n+  EXPECT_EQ(2, list.pop());\n+  EXPECT_EQ(1, list.pop());\n+}\n+\n+TEST_VM_F(ArrayWithFreeListTest, TestLinkedLists) {\n+  {\n+    LL<int> list;\n+    test_with_list(list);\n+  }\n+  {\n+    LL2<int, ArrayWithFreeList> list;\n+    test_with_list(list);\n+  }\n+}\n+\n+TEST_VM_F(ArrayWithFreeListTest, FreeingShouldReuseMemory) {\n+  A alloc;\n+  A::I i = alloc.allocate(1);\n+  int* x = &alloc.at(i);\n+  alloc.deallocate(i);\n+  i = alloc.allocate(1);\n+  int* y = &alloc.at(i);\n+  EXPECT_EQ(x, y);\n+}\n+\n+TEST_VM_F(ArrayWithFreeListTest, FreeingInTheMiddleWorks) {\n+  A alloc;\n+  A::I i0 = alloc.allocate(0);\n+  A::I i1 = alloc.allocate(0);\n+  A::I i2 = alloc.allocate(0);\n+  int* p1 = &alloc.at(i1);\n+  alloc.deallocate(i1);\n+  A::I i3 = alloc.allocate(0);\n+  EXPECT_EQ(p1, &alloc.at(i3));\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_arrayWithFreeList.cpp","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-class MemoryFileTrackerTest : public testing::Test {\n+class NMTMemoryFileTrackerTest : public testing::Test {\n@@ -51,1 +51,1 @@\n-TEST_VM_F(MemoryFileTrackerTest, Basics) {\n+TEST_VM_F(NMTMemoryFileTrackerTest, Basics) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_memoryfiletracker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class NativeCallStackStorageTest : public testing::Test {};\n+class NMTNativeCallStackStorageTest : public testing::Test {};\n@@ -34,1 +34,1 @@\n-TEST_VM_F(NativeCallStackStorageTest, DoNotStoreStackIfNotDetailed) {\n+TEST_VM_F(NMTNativeCallStackStorageTest, DoNotStoreStackIfNotDetailed) {\n@@ -43,1 +43,1 @@\n-TEST_VM_F(NativeCallStackStorageTest, CollisionsReceiveDifferentIndexes) {\n+TEST_VM_F(NMTNativeCallStackStorageTest, CollisionsReceiveDifferentIndexes) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_nativecallstackstorage.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-class TreapTest : public testing::Test {\n+class NMTTreapTest : public testing::Test {\n@@ -150,1 +150,1 @@\n-TEST_VM_F(TreapTest, InsertingDuplicatesResultsInOneValue) {\n+TEST_VM_F(NMTTreapTest, InsertingDuplicatesResultsInOneValue) {\n@@ -154,1 +154,1 @@\n-TEST_VM_F(TreapTest, TreapOughtNotLeak) {\n+TEST_VM_F(NMTTreapTest, TreapOughtNotLeak) {\n@@ -158,1 +158,1 @@\n-TEST_VM_F(TreapTest, TestVisitors) {\n+TEST_VM_F(NMTTreapTest, TestVisitors) {\n@@ -262,1 +262,1 @@\n-TEST_VM_F(TreapTest, TestFind) {\n+TEST_VM_F(NMTTreapTest, TestFind) {\n@@ -266,1 +266,1 @@\n-TEST_VM_F(TreapTest, TestClosestLeq) {\n+TEST_VM_F(NMTTreapTest, TestClosestLeq) {\n@@ -292,1 +292,1 @@\n-TEST_VM_F(TreapTest, VerifyItThroughStressTest) {\n+TEST_VM_F(NMTTreapTest, VerifyItThroughStressTest) {\n@@ -303,1 +303,3 @@\n-      verify_it(treap);\n+      if (i % 100 == 0) {\n+        verify_it(treap);\n+      }\n@@ -312,1 +314,3 @@\n-      verify_it(treap);\n+      if (i % 100 == 0) {\n+        verify_it(treap);\n+      }\n@@ -318,2 +322,2 @@\n-    constexpr const int five_million = 5000000;\n-    for (int i = 0; i < five_million; i++) {\n+    constexpr const int one_hundred_thousand = 100000;\n+    for (int i = 0; i < one_hundred_thousand; i++) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_treap.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-class VMATreeTest : public testing::Test {\n+class NMTVMATreeTest : public testing::Test {\n@@ -44,1 +44,1 @@\n-  VMATreeTest() : ncs(true) {\n+  NMTVMATreeTest() : ncs(true) {\n@@ -175,1 +175,1 @@\n-TEST_VM_F(VMATreeTest, OverlappingReservationsResultInTwoNodes) {\n+TEST_VM_F(NMTVMATreeTest, OverlappingReservationsResultInTwoNodes) {\n@@ -185,1 +185,1 @@\n-TEST_VM_F(VMATreeTest, LowLevel) {\n+TEST_VM_F(NMTVMATreeTest, LowLevel) {\n@@ -271,1 +271,1 @@\n-TEST_VM_F(VMATreeTest, SummaryAccounting) {\n+TEST_VM_F(NMTVMATreeTest, SummaryAccounting) {\n@@ -419,1 +419,1 @@\n-TEST_VM_F(VMATreeTest, TestConsistencyWithSimpleTracker) {\n+TEST_VM_F(NMTVMATreeTest, TestConsistencyWithSimpleTracker) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -199,0 +199,36 @@\n+\n+  static void test_committed_in_range(size_t num_pages, size_t pages_to_touch) {\n+    bool result;\n+    size_t committed_size;\n+    address committed_start;\n+    size_t index;\n+\n+    const size_t page_sz = os::vm_page_size();\n+    const size_t size = num_pages * page_sz;\n+\n+    char* base = os::reserve_memory(size, !ExecMem, mtTest);\n+    ASSERT_NE(base, (char*)nullptr);\n+\n+    result = os::commit_memory(base, size, !ExecMem);\n+    ASSERT_TRUE(result);\n+\n+    result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+    ASSERT_FALSE(result);\n+\n+    \/\/ Touch pages\n+    for (index = 0; index < pages_to_touch; index ++) {\n+      base[index * page_sz] = 'a';\n+    }\n+\n+    result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+    ASSERT_TRUE(result);\n+    ASSERT_EQ(pages_to_touch * page_sz, committed_size);\n+    ASSERT_EQ(committed_start, (address)base);\n+\n+    os::uncommit_memory(base, size, false);\n+\n+    result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+    ASSERT_FALSE(result);\n+\n+    os::release_memory(base, size);\n+  }\n@@ -217,0 +253,7 @@\n+\n+#if !defined(_WINDOWS) && !defined(_AIX)\n+TEST_VM(CommittedVirtualMemory, test_committed_in_range){\n+  CommittedVirtualMemoryTest::test_committed_in_range(1024, 1024);\n+  CommittedVirtualMemoryTest::test_committed_in_range(2, 1);\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-static bool sort_and_compare(int* arrayToSort, int* expectedResult, size_t length, C comparator, bool idempotent = false) {\n-  QuickSort::sort(arrayToSort, length, comparator, idempotent);\n+static bool sort_and_compare(int* arrayToSort, int* expectedResult, size_t length, C comparator) {\n+  QuickSort::sort(arrayToSort, length, comparator);\n@@ -56,12 +56,0 @@\n-static int test_even_odd_comparator(int a, int b) {\n-  bool a_is_odd = ((a % 2) == 1);\n-  bool b_is_odd = ((b % 2) == 1);\n-  if (a_is_odd == b_is_odd) {\n-    return 0;\n-  }\n-  if (a_is_odd) {\n-    return -1;\n-  }\n-  return 1;\n-}\n-\n@@ -129,44 +117,0 @@\n-  {\n-    int test_array[] = {2,8,1,4};\n-    int expected_array[] = {1,4,2,8};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 4, test_even_odd_comparator));\n-  }\n-}\n-\n-TEST(QuickSort, idempotent) {\n-  {\n-    \/\/ An array of lenght 3 is only sorted by find_pivot. Make sure that it is idempotent.\n-    int test_array[] = {1, 4, 8};\n-    int expected_array[] = {1, 4, 8};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 3, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {1, 7, 9, 4, 8, 2};\n-    int expected_array[] = {1, 7, 9, 4, 8, 2};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {1, 9, 7, 4, 2, 8};\n-    int expected_array[] = {1, 9, 7, 4, 2, 8};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {7, 9, 1, 2, 8, 4};\n-    int expected_array[] = {7, 9, 1, 2, 8, 4};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {7, 1, 9, 2, 4, 8};\n-    int expected_array[] = {7, 1, 9, 2, 4, 8};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {9, 1, 7, 4, 8, 2};\n-    int expected_array[] = {9, 1, 7, 4, 8, 2};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {9, 7, 1, 4, 2, 8};\n-    int expected_array[] = {9, 7, 1, 4, 2, 8};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n@@ -189,12 +133,0 @@\n-\n-    \/\/ Make sure sorting is idempotent.\n-    \/\/ Both test_array and expected_array are sorted by the test_comparator.\n-    \/\/ Now sort them once with the test_even_odd_comparator. Then sort the\n-    \/\/ test_array one more time with test_even_odd_comparator and verify that\n-    \/\/ it is idempotent.\n-    QuickSort::sort(expected_array, length, test_even_odd_comparator, true);\n-    QuickSort::sort(test_array, length, test_even_odd_comparator, true);\n-    EXPECT_TRUE(compare_arrays(test_array, expected_array, length));\n-    QuickSort::sort(test_array, length, test_even_odd_comparator, true);\n-    EXPECT_TRUE(compare_arrays(test_array, expected_array, length));\n-\n","filename":"test\/hotspot\/gtest\/utilities\/test_quicksort.cpp","additions":2,"deletions":70,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -118,2 +118,0 @@\n-\n-vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain007\/chain007.java 8298991 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-generational-zgc.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-\n-vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain007\/chain007.java 8298991 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+compiler\/c2\/irTests\/TestIfMinMax.java 8334816 generic-all\n@@ -72,0 +73,2 @@\n+compiler\/uncommontrap\/DeoptReallocFailure.java 8335308 windows-x64\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * @requires vm.debug == true & vm.compiler1.enabled\n- * @run main\/othervm -XX:TraceLinearScanLevel=4 compiler.c1.TestTraceLinearScanLevel\n+ * @requires vm.debug == true & vm.compiler1.enabled & vm.compMode != \"Xcomp\"\n+ * @run main\/othervm -Xbatch -XX:TraceLinearScanLevel=4 compiler.c1.TestTraceLinearScanLevel\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestTraceLinearScanLevel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @requires !vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/AbstractRootMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @requires !vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/DefaultRootMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @requires !vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/StrengthReduceInterfaceCall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.gcbarriers;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.DontInline;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+\/**\n+ * @test\n+ * @bug 8231569\n+ * @summary Test that Shenandoah barriers are expanded correctly\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.Shenandoah\n+ * @run main compiler.gcbarriers.TestShenandoahBarrierExpansion\n+ *\/\n+public class TestShenandoahBarrierExpansion {\n+    public static void main(String[] args) {\n+        TestFramework test = new TestFramework(TestShenandoahBarrierExpansion.class);\n+        test.addFlags(\"-XX:+UseShenandoahGC\");\n+        test.start();\n+    }\n+\n+    private static Object staticField;\n+    @Test\n+    @IR(failOn = IRNode.IF, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = { IRNode.IF, \"2\" }, phase = CompilePhase.BARRIER_EXPANSION)\n+    public Object testLoadFieldObject() {\n+        return staticField;\n+    }\n+\n+    private static A staticField2 = new A();\n+    @Test\n+    @IR(counts = { IRNode.IF, \"1\" }, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = { IRNode.IF, \"3\" }, phase = CompilePhase.BARRIER_EXPANSION)\n+    private static int testLoadObjectFieldWithNullCheck() {\n+        return staticField2.intField;\n+    }\n+\n+    private static A staticField3 = new A();\n+    @Test\n+    @IR(counts = { IRNode.IF, \"2\" }, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = { IRNode.IF, \"6\" }, phase = CompilePhase.BARRIER_EXPANSION)\n+    private static int testLoadTwoObjectFieldsWithNullCheck() {\n+        return staticField2.intField + staticField3.intField;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.IF, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = { IRNode.IF, \"3\" }, phase = CompilePhase.BARRIER_EXPANSION)\n+    private static void testLoadTwoFieldObjectAndEscape() {\n+        final A field2 = staticField2;\n+        final A field3 = staticField3;\n+        notInlined(field2, field3);\n+    }\n+\n+    @DontInline\n+    private static void notInlined(A field2, A field3) {\n+        \/\/ noop\n+    }\n+\n+    private static class A {\n+        public int intField;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestShenandoahBarrierExpansion.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334421\n+ * @summary C2 incorrectly marks not-escaped locks for elimination after\n+ *          coarsened locks were eliminated and created unbalanced regions.\n+ * @requires vm.compMode != \"Xint\"\n+ * @run main\/othervm -XX:-TieredCompilation TestCoarsenedAndNotEscapedLocksElimination\n+ * @run main TestCoarsenedAndNotEscapedLocksElimination\n+ *\/\n+\n+import java.util.Vector;\n+\n+class TestVector extends Vector<Object> {\n+\n+    TestVector() {\n+        super();\n+    }\n+\n+    TestVector(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    TestVector(int initialCapacity, int capacityIncrement) {\n+        super(initialCapacity, capacityIncrement);\n+    }\n+\n+    Object[] getElementData () {\n+        return elementData; \/\/ access protected field\n+    }\n+}\n+\n+public class TestCoarsenedAndNotEscapedLocksElimination {\n+\n+    public static void main(String[] strArr) {\n+        TestCoarsenedAndNotEscapedLocksElimination tc = new TestCoarsenedAndNotEscapedLocksElimination();\n+        String result = null;\n+        for (int i = 0; i < 12000; ++i) {\n+            result = tc.test();\n+            if (result != null) break;\n+        }\n+        System.out.println(result == null? \"passed\" : result);\n+    }\n+\n+    int [][] vector_types = {\n+       {-1, -1},\n+       {0, -1},\n+       {1, -1},\n+       {2, -1},\n+       {1025, -1},\n+       {0, -2},\n+       {1, -2},\n+       {2, -2},\n+       {1025, -2},\n+       {0, 0},\n+       {1, 0},\n+       {2, 0},\n+       {1025, 0},\n+       {0, 1},\n+       {1, 1},\n+       {2, 1},\n+       {1025, 1},\n+       {0, 1025 },\n+       {1, 1025 },\n+       {2, 1025 },\n+       {1025, 1025 }\n+    };\n+\n+    Object [] elems = {\n+        null,\n+        new Object(),\n+        new Vector(),\n+        new Object[0]\n+    };\n+\n+    int cntr = 0, mode = 0;\n+\n+    void reset() {\n+        cntr = 0;\n+        mode = 0;\n+    }\n+\n+    TestVector nextVector() {\n+        if (cntr == vector_types.length) {\n+            return null;\n+        } else {\n+            TestVector vect;\n+            if (vector_types[cntr][0] < 0) {\n+                vect = new TestVector();\n+            } else if (vector_types[cntr][1] == -2) {\n+                vect = new TestVector(vector_types[cntr][0]);\n+            } else {\n+                vect = new TestVector(vector_types[cntr][0], vector_types[cntr][1]);\n+            }\n+            if (mode == 1) {\n+                vect.addElement(null);\n+                vect.addElement(new Object());\n+                vect.addElement(new Vector());\n+                vect.addElement(new Object[0]);\n+            } else if (mode == 2) {\n+                int cap = vect.capacity();\n+                vect.addElement(null);\n+                for (int i = 0; i < cap; i++) {\n+                    vect.addElement(new Object());\n+                }\n+            }\n+            if (++mode == 3) {\n+                mode = 0;\n+                cntr++;\n+            }\n+            return vect;\n+        }\n+    }\n+\n+    public String test() {\n+        reset();\n+        TestVector vect = (TestVector)nextVector();\n+        while (vect != null) {\n+            Object [] backup_array = new Object[vect.size()];\n+            System.arraycopy(vect.getElementData(),0,backup_array,0,vect.size());\n+\n+            int old_size = vect.size();\n+            vect.setSize(vect.size());\n+            if (vect.size() != old_size) {\n+                return \"Vector: \"+vect+\" size changed after setSize(size())\";\n+            }\n+            for (int i = 0; i < vect.size(); i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size())\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            vect.setSize(vect.size()*2);\n+            if (vect.size() != old_size*2) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(size()*2)\";\n+            }\n+            for (int i = 0; i < old_size; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size()*2)\";\n+                }\n+            }\n+            for (int i = old_size; i < old_size*2; i++) {\n+                if (vect.elementAt(i) != null) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element not null after setSize(size()*2)\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            int old_cap = vect.capacity();\n+            vect.setSize(vect.capacity()+1);\n+            if (vect.size() != old_cap+1) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(capacity()+1)\";\n+            }\n+            for (int i = 0; i < old_size && i < backup_array.length; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(capacity()+1)\";\n+                }\n+            }\n+            for (int i = old_size; i < old_cap + 1; i++) {\n+                if (vect.elementAt(i) != null) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element not null after setSize(capacity()+1)\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            vect.setSize(vect.size()\/2);\n+            if (vect.size() != old_size\/2) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(size()\/2)\";\n+            }\n+            for (int i = 0; i < old_size\/2 && i < backup_array.length; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size()\/2)\";\n+                }\n+            }\n+\n+            vect = nextVector();\n+        }\n+        return null;\n+    }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestCoarsenedAndNotEscapedLocksElimination.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -362,0 +362,1 @@\n+        applyIf = {\"AlignVector\", \"false\"}, \/\/ a[i] and a[i+1] cannot both be aligned.\n@@ -379,0 +380,1 @@\n+        applyIf = {\"AlignVector\", \"false\"}, \/\/ a[i] and a[i+1] cannot both be aligned.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCompatibleUseDefTypeSize.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+            {\"LockingMode\", \"1\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test id=special\n- * @summary Run invocation tests with old CHA (-XX:-UseVtableBasedCHA)\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile invokespecial\/Checker.java invokespecial\/ClassGenerator.java invokespecial\/Generator.java\n- *\n- * @run driver\/timeout=1800 invocationOldCHATests special\n- *\/\n-\n-\/*\n- * @test id=virtual\n- * @summary Run invocation tests with old CHA (-XX:-UseVtableBasedCHA)\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile invokevirtual\/Checker.java invokevirtual\/ClassGenerator.java invokevirtual\/Generator.java\n- *\n- * @run driver\/timeout=1800 invocationOldCHATests virtual\n- *\/\n-\n-\/*\n- * @test id=interface\n- * @summary Run invocation tests with old CHA (-XX:-UseVtableBasedCHA)\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile invokeinterface\/Checker.java invokeinterface\/ClassGenerator.java invokeinterface\/Generator.java\n- *\n- * @run driver\/timeout=1800 invocationOldCHATests interface\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-\n-public class invocationOldCHATests {\n-\n-    public static void runTest(String whichTests, String classFileVersion) throws Throwable {\n-        System.out.println(\"\\nOld CHA invocation tests, Tests: \" + whichTests +\n-                           \", class file version: \" + classFileVersion);\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xmx128M\",\n-            \"-Xcomp\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseVtableBasedCHA\",\n-            \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n-            whichTests, \"--classfile_version=\" + classFileVersion);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        try {\n-            output.shouldContain(\"EXECUTION STATUS: PASSED\");\n-            output.shouldHaveExitValue(0);\n-        } catch (Throwable e) {\n-            System.out.println(\n-                \"\\nNote that an entry such as 'B.m\/C.m' in the failure chart means that\" +\n-                \" the test case failed because method B.m was invoked but the test \" +\n-                \"expected method C.m to be invoked. Similarly, a result such as 'AME\/C.m'\" +\n-                \" means that an AbstractMethodError exception was thrown but the test\" +\n-                \" case expected method C.m to be invoked.\");\n-            System.out.println(\n-                \"\\nAlso note that passing --dump to invoke*.Generator will\" +\n-                \" dump the generated classes (for debugging purposes).\\n\");\n-\n-            throw e;\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        if (args.length < 1) {\n-            throw new IllegalArgumentException(\"Should provide the test name\");\n-        }\n-        String testName = args[0];\n-\n-        \/\/ Get current major class file version and test with it.\n-        byte klassbuf[] = InMemoryJavaCompiler.compile(\"blah\", \"public class blah { }\");\n-        int major_version = klassbuf[6] << 8 | klassbuf[7];\n-\n-        switch (testName) {\n-            case \"special\":\n-                runTest(\"invokespecial.Generator\", String.valueOf(major_version));\n-                break;\n-            case \"virtual\":\n-                runTest(\"invokevirtual.Generator\", String.valueOf(major_version));\n-                break;\n-            case \"interface\":\n-                runTest(\"invokeinterface.Generator\", String.valueOf(major_version));\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unknown test name: \" + testName);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/invocationOldCHATests.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,2 @@\n+    private static final boolean expectSourceInformation = Platform.isLinux() || Platform.isWindows();\n+\n@@ -124,2 +126,3 @@\n-            if (Platform.isWindows() || Platform.isARM()) {\n-                return; \/\/ we are done\n+            if (!Platform.isWindows() && !Platform.isARM()) {\n+                output.reportDiagnosticSummary();\n+                throw new RuntimeException(\"Expected symbol missing from output: \" + expectedSymbol);\n@@ -127,2 +130,0 @@\n-            output.reportDiagnosticSummary();\n-            throw new RuntimeException(\"Expected symbol missing from output: \" + expectedSymbol);\n@@ -133,9 +134,11 @@\n-        if (okToHaveAllocateHeap) {\n-            System.out.print(stackTraceAllocateHeap);\n-            if (stackTraceMatches(stackTraceAllocateHeap, output)) {\n-                return;\n-            }\n-        } else {\n-            System.out.print(stackTraceDefault);\n-            if (stackTraceMatches(stackTraceDefault, output)) {\n-                return;\n+        String toMatch = okToHaveAllocateHeap ? stackTraceAllocateHeap : stackTraceDefault;\n+        if (!stackTraceMatches(toMatch, output)) {\n+            output.reportDiagnosticSummary();\n+            throw new RuntimeException(\"Expected stack trace missing from output\");\n+        }\n+\n+        System.out.println(\"Looking for source information:\");\n+        if (expectSourceInformation) {\n+            if (!stackTraceMatches(\".*moduleEntry.cpp.*\", output)) {\n+                output.reportDiagnosticSummary();\n+                throw new RuntimeException(\"Expected source information missing from output\");\n@@ -144,3 +147,0 @@\n-        \/\/ Failed to match so dump all the output\n-        output.reportDiagnosticSummary();\n-        throw new RuntimeException(\"Expected stack trace missing from output\");\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CheckForProperDetailStackTrace.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+import static jdk.test.lib.Platform.isLinux;\n+import static jdk.test.lib.Platform.isWindows;\n+\n@@ -36,1 +39,1 @@\n- * @test\n+ * @test id=preTouch\n@@ -42,1 +45,11 @@\n- * @run driver TestAlwaysPreTouchStacks\n+ * @run driver TestAlwaysPreTouchStacks preTouch\n+ *\/\n+\n+\/*\n+ * @test id=noPreTouch\n+ * @summary Test that only touched committed memory is reported as thread stack usage.\n+ * @requires os.family != \"aix\"\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver TestAlwaysPreTouchStacks noPreTouch\n@@ -93,0 +106,8 @@\n+            boolean preTouch;\n+            if (args.length == 1 && args[0].equals(\"noPreTouch\")){\n+                preTouch = false;\n+            } else if (args.length == 1 && args[0].equals(\"preTouch\")){\n+                preTouch = true;\n+            } else {\n+                throw new RuntimeException(\"Invalid test input. Must be 'preTouch' or 'noPreTouch'.\");\n+            }\n@@ -97,1 +118,0 @@\n-                    \"-XX:+AlwaysPreTouchStacks\",\n@@ -99,0 +119,3 @@\n+            if (preTouch){\n+                vmArgs.add(\"-XX:+AlwaysPreTouchStacks\");\n+            }\n@@ -113,2 +136,2 @@\n-            \/\/ We want to see, in the final NMT printout, a committed thread stack size very close to reserved\n-            \/\/ stack size. Like this:\n+            \/\/ If using -XX:+AlwaysPreTouchStacks, we want to see, in the final NMT printout,\n+            \/\/ a committed thread stack size very close to reserved stack size. Like this:\n@@ -138,1 +161,1 @@\n-                    if ((double)committed < ((double)reserved * 0.75)) {\n+                    if (preTouch && (double)committed < ((double)reserved * 0.75)) {\n@@ -140,0 +163,2 @@\n+                    } else if (!preTouch && (double)committed > ((double)reserved * 0.50)){\n+                        throw new RuntimeException(\"Expected a lower ratio between stack committed and reserved.\");\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestAlwaysPreTouchStacks.java","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,1 @@\n-    \/\/ final static String IN_OBJECT_WAIT = \"in Object.wait()\";\n-    final static String IN_CONVAR_WAIT = \"waiting on condition\";\n+    final static String IN_OBJECT_WAIT = \"in Object.wait()\";\n@@ -143,1 +142,1 @@\n-                    if (!line.contains(IN_CONVAR_WAIT)) {\n+                    if (!line.contains(IN_OBJECT_WAIT)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestThreadDumpClassInitMonitor.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8306580\n+ * @summary Test the writing error when archive file cannot be created\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver StaticWritingError\n+ *\/\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class StaticWritingError {\n+    public static void main(String[] args) throws Exception {\n+        String directoryName = \"nosuchdir\";\n+        String archiveName = \"staticWritingError.jsa\";\n+\n+        \/\/ Perform static dump and attempt to write archive in unwritable directory\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-Xlog:cds\")\n+            .setArchiveName(directoryName + File.separator + archiveName);\n+        OutputAnalyzer out = CDSTestUtils.createArchive(opts);\n+        out.shouldHaveExitValue(1);\n+        out.shouldContain(\"Unable to create shared archive file\");\n+        out.shouldContain(\"Encountered error while dumping\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/StaticWritingError.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -72,1 +72,1 @@\n-                              .shouldContain(\"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n+                              .shouldContain(\"Unexpected exception, use -Xlog:cds,exceptions=trace for detail\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/ExceptionDuringDumpAtObjectsInitPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+          \/\/ Class References ---\n+\n@@ -73,0 +75,2 @@\n+          \/\/ Field References ---\n+\n@@ -83,1 +87,0 @@\n-\n@@ -88,0 +91,35 @@\n+          \/\/ Method References ---\n+\n+            \/\/ Should resolve references to own constructor\n+            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp ResolvedConstantsApp.<init>:\")\n+            \/\/ Should resolve references to super constructor\n+            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp java\/lang\/Object.<init>:\")\n+\n+            \/\/ Should resolve interface methods in VM classes\n+            .shouldMatch(\"cds,resolve.*archived interface method .* ResolvedConstantsApp java\/lang\/Runnable.run:\")\n+\n+            \/\/ Should resolve references to own non-static method (private or public)\n+            .shouldMatch(\"archived method.*: ResolvedConstantsBar ResolvedConstantsBar.doBar:\")\n+            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.privateInstanceCall:\")\n+            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.publicInstanceCall:\")\n+\n+            \/\/ Should not resolve references to static method\n+            .shouldNotMatch(\" archived method CP entry.*: ResolvedConstantsApp ResolvedConstantsApp.staticCall:\")\n+\n+            \/\/ Should resolve references to method in super type\n+            .shouldMatch(\" archived method CP entry.*: ResolvedConstantsBar ResolvedConstantsFoo.doBar:\")\n+\n+            \/\/ App class cannot resolve references to methods in boot classes:\n+            \/\/    When the app class loader tries to resolve a class X that's normally loaded by\n+            \/\/    the boot loader, it's possible for the app class loader to get a different copy of\n+            \/\/    X (by using MethodHandles.Lookup.defineClass(), etc). Therefore, let's be on\n+            \/\/    the side of safety and revert all such references.\n+            \/\/\n+            \/\/    This will be addressed in JDK-8315737.\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsApp java\/io\/PrintStream.println:\")\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsBar java\/lang\/Class.getName:\")\n+\n+            \/\/ Should not resolve methods in unrelated classes.\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsApp ResolvedConstantsBar.doit:\")\n+\n+          \/\/ End ---\n@@ -95,1 +133,5 @@\n-        Object a = new ResolvedConstantsApp();\n+        ResolvedConstantsApp app = new ResolvedConstantsApp();\n+        ResolvedConstantsApp.staticCall();\n+        app.privateInstanceCall();\n+        app.publicInstanceCall();\n+        Object a = app;\n@@ -104,0 +146,4 @@\n+    private static void staticCall() {}\n+    private void privateInstanceCall() {}\n+    public void publicInstanceCall() {}\n+\n@@ -127,0 +173,2 @@\n+\n+        ((ResolvedConstantsFoo)this).doBar(this);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -619,1 +619,0 @@\n-javax\/net\/ssl\/SSLSession\/CertMsgCheck.java                      8326705 generic-all\n@@ -623,2 +622,0 @@\n-security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java#teliasonerarootcav1  8333640 generic-all\n-\n@@ -722,3 +719,0 @@\n-java\/util\/Locale\/LocaleProvidersRun.java                        8268379 macosx-x64\n-sun\/util\/locale\/provider\/CalendarDataRegression.java            8268379 macosx-x64\n-\n@@ -786,1 +780,0 @@\n-java\/awt\/print\/Dialog\/RestoreActiveWindowTest\/RestoreActiveWindowTest.java 8185429 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -254,0 +254,2 @@\n+# Tests in this group are manual as they depend on external infra\n+# and may fail with external reasons, for instance - change in CA test portal.\n@@ -621,0 +623,1 @@\n+    :jdk_security_infra \\\n@@ -664,1 +667,1 @@\n-   -:jdk_security\n\\ No newline at end of file\n+   -:jdk_security\n","filename":"test\/jdk\/TEST.groups","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8333542\n+ * @summary Missed breakpoint due to JVM not blocking other threads while\n+ *          delivering a ClassPrepareEvent.\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g BreakpointOnClassPrepare.java\n+ * @run driver BreakpointOnClassPrepare SUSPEND_NONE\n+ * @run driver BreakpointOnClassPrepare SUSPEND_EVENT_THREAD\n+ * @run driver BreakpointOnClassPrepare SUSPEND_ALL\n+ *\/\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+\n+import java.util.*;\n+\n+\/\/ The debuggee spawns 50 threads that call LoadedClass.foo(). The debugger enables\n+\/\/ ClassPrepareEvent for LoadedClass, and sets a breakpoint on LoadedClass.foo() when\n+\/\/ the ClassPrepareEvent arrives. The debugger expects 50 breakpoints to be hit.\n+\/\/ This verifies that the thread that causes the generation of the ClassPrepareEvent\n+\/\/ has properly blocked all other threads from executing LoadedClass.foo() until the\n+\/\/ ClassPrepareEvent has been delivered.\n+\n+class LoadedClass {\n+    static void foo(int k) {\n+        System.out.println(\"HIT = \" + k); \/\/ set breakpoint here\n+    }\n+}\n+\n+class BreakpointOnClassPrepareTarg {\n+    public static void main(String[] args) throws InterruptedException {\n+        System.out.println(\"Start\");\n+        Thread threads[] = new Thread[BreakpointOnClassPrepare.NUM_BREAKPOINTS];\n+        for (int i = 0; i < BreakpointOnClassPrepare.NUM_BREAKPOINTS; i++) {\n+            int k = i;\n+            Thread t = DebuggeeWrapper.newThread(() -> {\n+                System.out.println(\"k = \" + k);\n+                LoadedClass.foo(k);\n+            });\n+            threads[i] = t;\n+            t.setDaemon(true);\n+            t.setName(\"MyThread-\" + k);\n+            t.start();\n+        }\n+\n+        for (int i = 0; i < BreakpointOnClassPrepare.NUM_BREAKPOINTS; i++) {\n+            try {\n+                Thread t = threads[i];\n+                t.join();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        System.out.println(\"Finish\");\n+    }\n+}\n+\n+    \/********** test program **********\/\n+\n+public class BreakpointOnClassPrepare extends TestScaffold {\n+    ClassType targetClass;\n+    ThreadReference mainThread;\n+\n+    BreakpointOnClassPrepare(String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args)      throws Exception {\n+        new BreakpointOnClassPrepare(args).startTests();\n+    }\n+\n+    \/********** event handlers **********\/\n+\n+    static final int NUM_BREAKPOINTS = 50;\n+    int bkptCount;\n+    BreakpointRequest bkptRequest;\n+\n+    public void breakpointReached(BreakpointEvent event) {\n+        bkptCount++;\n+        String threadInfo;\n+        try {\n+            threadInfo = event.thread().toString();\n+        } catch (ObjectCollectedException e) {\n+            \/\/ It's possible the Thread already terminated and was collected\n+            \/\/ if the SUSPEND_NONE policy was used.\n+            threadInfo = \"(thread collected)\";\n+        }\n+        System.out.println(\"Got BreakpointEvent: \" + bkptCount + \" for thread \" + threadInfo);\n+    }\n+\n+    public void vmDisconnected(VMDisconnectEvent event) {\n+        println(\"Got VMDisconnectEvent\");\n+    }\n+\n+    \/********** test core **********\/\n+\n+    protected void runTests() throws Exception {\n+        \/* Determine which suspend policy to use. *\/\n+        int policy;\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Invalid number of args: \" + args.length);\n+        }\n+        String policyString = args[0];\n+        if (policyString.equals(\"SUSPEND_NONE\")) {\n+            policy = EventRequest.SUSPEND_NONE;\n+        } else if (policyString.equals(\"SUSPEND_ALL\")) {\n+            policy = EventRequest.SUSPEND_ALL;\n+        } else if (policyString.equals(\"SUSPEND_EVENT_THREAD\")) {\n+            policy = EventRequest.SUSPEND_EVENT_THREAD;\n+        } else {\n+            throw new RuntimeException(\"Invalid suspend policy: \" + policyString);\n+        }\n+\n+        \/* Stop when the target is loaded. *\/\n+        BreakpointEvent bpe = startToMain(\"BreakpointOnClassPrepareTarg\");\n+\n+        \/* Stop when \"LoadedClass\" is loaded. *\/\n+        EventRequestManager erm = vm().eventRequestManager();\n+        ClassPrepareEvent cpe = resumeToPrepareOf(\"LoadedClass\");\n+        println(\"Got ClassPrepareEvent: \" + cpe);\n+\n+        \/* Set a breakpoint for each time LoadedClass.foo() is called. *\/\n+        ClassType loadedClass = (ClassType)cpe.referenceType() ;\n+        Location loc1 = findMethodLocation(loadedClass,  \"foo\", \"(I)V\", 1);\n+        bkptRequest = erm.createBreakpointRequest(loc1);\n+        bkptRequest.setSuspendPolicy(policy);\n+        bkptRequest.enable();\n+\n+        listenUntilVMDisconnect();\n+\n+        if (!testFailed && bkptCount == NUM_BREAKPOINTS) {\n+            println(\"BreakpointOnClassPrepare: passed\");\n+        } else {\n+            throw new Exception(\"BreakpointOnClassPrepare: failed. bkptCount == \" + bkptCount);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/BreakpointOnClassPrepare.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -292,0 +292,1 @@\n+        new EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target()                .run();\n@@ -416,0 +417,1 @@\n+        new EARelockingSimpleWithAccessInOtherThread_02_DynamicCall()                 .run(this);\n@@ -1854,0 +1856,89 @@\n+\/\/ The debugger reads and publishes an object with eliminated locking to an instance field.\n+\/\/ A 2nd thread in the debuggee finds it there and changes its state using a synchronized method.\n+\/\/ Without eager relocking the accesses are unsynchronized which can be observed.\n+\/\/ This is a variant of EARelockingSimpleWithAccessInOtherThread with a dynamic call (not devirtualized).\n+class EARelockingSimpleWithAccessInOtherThread_02_DynamicCall extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        String l1ClassName = EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target.SyncCounter.class.getName();\n+        ObjectReference ctr = getLocalRef(bpe.thread().frame(2), l1ClassName, \"l1\");\n+        setField(testCase, \"sharedCounter\", ctr);\n+        terminateEndlessLoop();\n+    }\n+}\n+\n+class EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target extends EATestCaseBaseTarget {\n+\n+    public static final BrkPtDispatchA[] disp =\n+        {new BrkPtDispatchA(), new BrkPtDispatchB(), new BrkPtDispatchC(), new BrkPtDispatchD()};\n+\n+    public static class BrkPtDispatchA {\n+        public EATestCaseBaseTarget testCase;\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchB extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchC extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchD extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() {\n+            testCase.dontinline_brkpt();\n+        }\n+    }\n+\n+    public static class SyncCounter {\n+        private int val;\n+        public synchronized int inc() { return val++; }\n+    }\n+\n+    public volatile SyncCounter sharedCounter;\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+        for (BrkPtDispatchA d : disp) {\n+            d.testCase = this;\n+        }\n+        doLoop = true;\n+        new Thread(() -> {\n+                while (doLoop) {\n+                    SyncCounter ctr = sharedCounter;\n+                    if (ctr != null) {\n+                        ctr.inc();\n+                    }\n+                }\n+            }).start();\n+    }\n+\n+    public int dispCount;\n+    public void dontinline_testMethod() {\n+        SyncCounter l1 = new SyncCounter();\n+        synchronized (l1) {      \/\/ Eliminated locking\n+            l1.inc();\n+            \/\/ Use different types for the subsequent call to prevent devirtualization.\n+            BrkPtDispatchA d = disp[(dispCount++) & 3];\n+            d.dontinline_brkpt();  \/\/ Dynamic call. Debugger publishes l1 to sharedCounter.\n+            iResult = l1.inc();    \/\/ Changes by the 2nd thread will be observed if l1\n+                                   \/\/ was not relocked before passing it to the debugger.\n+        }\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 1;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334366\n+ * @key headful printer\n+ * @summary Verifies original pageobject is returned unmodified\n+ *          on cancelling pagedialog\n+ * @requires (os.family == \"windows\")\n+ * @run main PageDialogCancelTest\n+ *\/\n+\n+import java.awt.Robot;\n+import java.awt.event.KeyEvent;\n+import java.awt.print.PageFormat;\n+import java.awt.print.PrinterJob;\n+\n+public class PageDialogCancelTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        PrinterJob pj = PrinterJob.getPrinterJob();\n+        PageFormat oldFormat = new PageFormat();\n+        Robot robot = new Robot();\n+        Thread t1 = new Thread(() -> {\n+            robot.delay(2000);\n+            robot.keyPress(KeyEvent.VK_ESCAPE);\n+            robot.keyRelease(KeyEvent.VK_ESCAPE);\n+            robot.waitForIdle();\n+        });\n+        t1.start();\n+        PageFormat newFormat = pj.pageDialog(oldFormat);\n+        if (!newFormat.equals(oldFormat)) {\n+            throw new RuntimeException(\"Original PageFormat not returned on cancelling PageDialog\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PageDialogCancelTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-                os.write (reply2.getBytes());\n+                os.write ((reply2+\"HelloAgain\").getBytes());\n","filename":"test\/jdk\/java\/net\/Authenticator\/BasicTest4.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+        \/\/ retains only network interface whose bound addresses match\n@@ -67,2 +68,17 @@\n-                                      .map(nif -> new Object[] { new InetSocketAddress(a, 0), nif })\n-                                      .forEach(list::add) );\n+                .filter(nif -> nif.inetAddresses().toList().contains(a))\n+                .map(nif -> new Object[] { new InetSocketAddress(a, 0), nif })\n+                .forEach(list::add) );\n+        \/\/ any network interface should work with the wildcard address\n+        nc.multicastInterfaces(true)\n+                .map(nif -> new Object[] {new InetSocketAddress(0), nif})\n+                .forEach(list::add);\n+        return list.stream().toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider(name = \"interfaces\")\n+    public Object[][] interfaces() throws Exception {\n+        List<Object[]> list = new ArrayList<>();\n+        NetworkConfiguration nc = NetworkConfiguration.probe();\n+        nc.multicastInterfaces(true)\n+                .map(nif -> new Object[] {nif})\n+                .forEach(list::add);\n@@ -85,2 +101,2 @@\n-    @Test(dataProvider = \"scenarios\")\n-    public void testSetGetInterfaceUnbound(InetSocketAddress ignore, NetworkInterface nif)\n+    @Test(dataProvider = \"interfaces\")\n+    public void testSetGetInterfaceUnbound(NetworkInterface nif)\n@@ -109,2 +125,2 @@\n-    @Test(dataProvider = \"scenarios\")\n-    public void testSetGetOptionUnbound(InetSocketAddress ignore, NetworkInterface nif)\n+    @Test(dataProvider = \"interfaces\")\n+    public void testSetGetOptionUnbound(NetworkInterface nif)\n@@ -142,2 +158,2 @@\n-    public void testGettInterfaceUnbound() throws Exception {\n-        out.println(\"\\n\\n--- testGettInterfaceUnbound \");\n+    public void testGetInterfaceUnbound() throws Exception {\n+        out.println(\"\\n\\n--- testGetInterfaceUnbound \");\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/IPMulticastIF.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8335135\n+ * @library \/test\/lib\n+ * @summary Check that reading from inputStream throws an IOException\n+ *          if the fixed response stream is closed before reading all bytes.\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+\n+public class TruncatedFixedResponse implements Runnable {\n+\n+    ServerSocket ss;\n+\n+    \/*\n+     * Our \"http\" server to return a truncated fixed response\n+     *\/\n+    public void run() {\n+        try {\n+            Socket s = ss.accept();\n+\n+            BufferedReader in = new BufferedReader(\n+                    new InputStreamReader(s.getInputStream()));\n+            while (true) {\n+                String req = in.readLine();\n+                if (req.isEmpty()) {\n+                    break;\n+                }\n+            }\n+            PrintStream out = new PrintStream(\n+                    new BufferedOutputStream(s.getOutputStream()));\n+\n+            \/* send the header *\/\n+            out.print(\"HTTP\/1.1 200\\r\\n\");\n+            out.print(\"Content-Length: 100\\r\\n\");\n+            out.print(\"Content-Type: text\/html\\r\\n\");\n+            out.print(\"\\r\\n\");\n+            out.print(\"Some content, but too short\");\n+            out.close();\n+            s.close();\n+            ss.close();\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    TruncatedFixedResponse() throws Exception {\n+        \/* start the server *\/\n+        ss = new ServerSocket();\n+        ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        new Thread(this).start();\n+\n+        \/* establish http connection to server *\/\n+        URL url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(ss.getLocalPort())\n+                .path(\"\/foo\")\n+                .toURL();\n+        HttpURLConnection http = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY);\n+\n+        try (InputStream in = http.getInputStream()) {\n+            while (in.read() != -1) {\n+                \/\/ discard response\n+            }\n+            throw new AssertionError(\"Expected IOException was not thrown\");\n+        } catch (IOException ex) {\n+            System.out.println(\"Got expected exception: \" + ex);\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        new TruncatedFixedResponse();\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/URLConnection\/TruncatedFixedResponse.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,2 @@\n-            ByteBuffer src = ByteBuffer.wrap(\"hello\".getBytes(\"UTF-8\"));\n+            String str = \"hello \" + System.nanoTime();\n+            ByteBuffer src = ByteBuffer.wrap(str.getBytes(\"UTF-8\"));\n@@ -145,0 +146,1 @@\n+            src.flip();\n@@ -160,0 +162,5 @@\n+                        if (src.mismatch(dst) != -1) {\n+                            System.out.println(\"src: \" + src + \"not equal to dst: \" + dst);\n+                            dst.clear();\n+                            continue;\n+                        }\n@@ -163,1 +170,2 @@\n-                            assertTrue(senderPort != localPort, \"Unexpected message\");\n+                            assertTrue(senderPort != localPort,\n+                                    \"Unexpected message: localPort=\" + localPort);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Loopback.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,484 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ClosedSelectorException;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8334719\n+ * @summary verifies that if a registered channel has in-progress operations, then\n+ *          the Selector during its deferred close implementation won't prematurely release\n+ *          the channel's resources\n+ *\n+ * @comment we use a patched java.net.InetSocketAddress to allow the test to intentionally\n+ *          craft some delays at specific locations in the implementation of InetSocketAddress\n+ *          to trigger race conditions\n+ * @compile\/module=java.base java\/net\/InetSocketAddress.java\n+ * @run junit\/othervm DeferredCloseTest\n+ *\/\n+public class DeferredCloseTest {\n+\n+    private static final int NUM_ITERATIONS = 10;\n+    private static final InetSocketAddress BIND_ADDR = new InetSocketAddress(\n+            InetAddress.getLoopbackAddress(), 0);\n+\n+    @BeforeAll\n+    public static void beforeAll() throws Exception {\n+        \/\/ configure our patched java.net.InetSocketAddress implementation\n+        \/\/ to introduce delay in certain methods which get invoked\n+        \/\/ internally from the DC.send() implementation\n+        InetSocketAddress.enableDelay();\n+    }\n+\n+    @AfterAll\n+    public static void afterAll() throws Exception {\n+        \/\/ delays in patched InetSocketAddress are no longer needed\n+        InetSocketAddress.disableDelay();\n+    }\n+\n+    private static Stream<Arguments> dcOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.send() till there's a ClosedChannelException\n+                        \"DC.send()\",\n+                        null,\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                \/\/ We send to ourselves. Target, content and\n+                                \/\/ receipt of the Datagram isn't of importance\n+                                \/\/ in this test.\n+                                SocketAddress target = dc.getLocalAddress();\n+                                System.out.println(\"DC: \" + dc + \" sending to \" + target);\n+                                while (true) {\n+                                    bb.clear();\n+                                    dc.send(bb, target);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.receive() till there's a ClosedChannelException\n+                        \"DC.receive()\",\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            try {\n+                                SocketAddress target = dc.getLocalAddress();\n+                                ByteBuffer sendBB = ByteBuffer.allocate(100);\n+                                \/\/ first send() a few datagrams so that subsequent\n+                                \/\/ receive() does receive them and thus triggers\n+                                \/\/ the potential race with the deferred close\n+                                for (int i = 0; i < 5; i++) {\n+                                    sendBB.clear();\n+                                    dc.send(sendBB, target);\n+                                }\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        },\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            try {\n+                                ByteBuffer rcvBB = ByteBuffer.allocate(10);\n+                                while (true) {\n+                                    rcvBB.clear();\n+                                    dc.receive(rcvBB);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for DatagramChannel.\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"dcOperations\")\n+    public void testDatagramChannel(String opName, Function<DatagramChannel, Void> preOp,\n+                                    Function<DatagramChannel, Void> dcOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s DatagramChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     DatagramChannel dc = DatagramChannel.open()) {\n+                    \/\/ create a non-blocking bound DatagramChannel\n+                    dc.bind(BIND_ADDR);\n+                    dc.configureBlocking(false);\n+                    \/\/ register the DatagramChannel with a selector\n+                    \/\/ (doesn't matter the interestOps)\n+                    SelectionKey key = dc.register(sel, SelectionKey.OP_READ);\n+                    if (preOp != null) {\n+                        preOp.apply(dc);\n+                    }\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start operation on the DC\n+                        opStartLatch.countDown();\n+                        return dcOperation.apply(dc);\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private static Stream<Arguments> scOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        \"SC.write()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" writing\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.write(bb);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        \"SC.read()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" reading\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.read(bb);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for SocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"scOperations\")\n+    public void testSocketChannel(String opName, Function<SocketChannel, Void> scOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(3)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     SocketChannel sc = SocketChannel.open()) {\n+                    \/\/ create and bind a SocketChannel\n+                    sc.bind(BIND_ADDR);\n+                    \/\/ stay in blocking mode till the SocketChannel is connected\n+                    sc.configureBlocking(true);\n+                    Future<SocketChannel> acceptedChannel;\n+                    SocketChannel conn;\n+                    \/\/ create a remote server and connect to it\n+                    try (ServerSocketChannel server = ServerSocketChannel.open()) {\n+                        server.bind(BIND_ADDR);\n+                        SocketAddress remoteAddr = server.getLocalAddress();\n+                        acceptedChannel = executor.submit(new ConnAcceptor(server));\n+                        System.out.println(\"connecting to \" + remoteAddr);\n+                        sc.connect(remoteAddr);\n+                        conn = acceptedChannel.get();\n+                    }\n+                    try (conn) {\n+                        \/\/ switch to non-blocking\n+                        sc.configureBlocking(false);\n+                        System.out.println(\"switched to non-blocking: \" + sc);\n+                        \/\/ register the SocketChannel with a selector\n+                        \/\/ (doesn't matter the interestOps)\n+                        SelectionKey key = sc.register(sel, SelectionKey.OP_READ);\n+                        CountDownLatch opStartLatch = new CountDownLatch(1);\n+                        runTest(executor, key, () -> {\n+                            \/\/ notify that we will now start operation on the SC\n+                            opStartLatch.countDown();\n+                            return scOperation.apply(sc);\n+                        }, opStartLatch);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for ServerSocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testServerSocketChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s ServerSocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+                    \/\/ create and bind a ServerSocketChannel\n+                    ssc.bind(BIND_ADDR);\n+                    ssc.configureBlocking(false);\n+                    \/\/ register the ServerSocketChannel with a selector\n+                    SelectionKey key = ssc.register(sel, SelectionKey.OP_ACCEPT);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start accept()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SSC.accept() till there's a ClosedChannelException\n+                        try {\n+                            while (true) {\n+                                ssc.accept();\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SinkChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testSinkChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SinkChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SinkChannel sink = pipe.sink()) {\n+                    sink.configureBlocking(false);\n+                    SelectionKey key = sink.register(sel, SelectionKey.OP_WRITE);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start write()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                sink.write(bb);\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SourceChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testSourceChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SourceChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SourceChannel source = pipe.source()) {\n+                    source.configureBlocking(false);\n+                    SelectionKey key = source.register(sel, SelectionKey.OP_READ);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start read()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                source.read(bb);\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * SelectableChannel implementations internally have a deferred close implementation. When a\n+     * channel is registered with a Selector and close() is invoked on the channel from a certain\n+     * thread, then the implementation of close() defers the actual close if the channel has\n+     * in-progress operations (for example, read\/write\/send\/receive and such) in some other thread.\n+     * A subsequent operation through the Selector (like Selector.select()) then completes the\n+     * deferred close (waiting for any in-progress operations to complete). This test method\n+     * verifies that the deferred close implementation doesn't prematurely close and release\n+     * the resources used by the channel, while there are in-progress operations.\n+     * <p>\n+     * Launches 2 threads, T1 and T2. When T1 and T2 are in progress, this method closes the\n+     * channel that is registered with the Selector.\n+     * T1 is running the channelOperation (which keeps running operations on the channel).\n+     * T2 is running a task which keeps invoking Selector.select(), until the channel is closed.\n+     * When T2 notices that the channel is closed, it cancels the selectionKey and then\n+     * invokes one last Selector.select() operation to finish the deferred close of the channel.\n+     *\/\n+    private static void runTest(ExecutorService executor, SelectionKey selectionKey,\n+                                Callable<Void> channelOperation, CountDownLatch chanOpStartLatch)\n+            throws Exception {\n+\n+        SelectableChannel channel = selectionKey.channel();\n+        assertFalse(channel.isBlocking(), \"channel isn't non-blocking: \" + channel);\n+        selectionKey.selector().selectNow();\n+        \/\/ run the channel operations\n+        Future<?> channelOpResult = executor.submit(channelOperation);\n+        CountDownLatch selectorTaskStartLatch = new CountDownLatch(1);\n+        \/\/ run the Selector.select() task\n+        Future<?> selectorTaskResult = executor.submit(\n+                new SelectorTask(selectionKey, selectorTaskStartLatch));\n+        \/\/ await for the channel operation task and the selector task to start\n+        chanOpStartLatch.await();\n+        selectorTaskStartLatch.await();\n+        \/\/ close the channel while it's still registered with the Selector,\n+        \/\/ so that the close is deferred by the channel implementations.\n+        System.out.println(\"closing channel: \" + channel);\n+        assertTrue(channel.isOpen(), \"channel already closed: \" + channel);\n+        assertTrue(channel.isRegistered(), \"channel isn't registered: \" + channel);\n+        channel.close();\n+        \/\/ wait for the operation on the channel and the selector task to complete\n+        channelOpResult.get();\n+        selectorTaskResult.get();\n+    }\n+\n+    \/*\n+     * Keeps invoking Selector.select() until the channel is closed, after which\n+     * it cancels the SelectionKey and does one last Selector.select() to finish\n+     * the deferred close.\n+     *\/\n+    private static final class SelectorTask implements Callable<Void> {\n+        private final SelectionKey selectionKey;\n+        private final CountDownLatch startedLatch;\n+\n+        private SelectorTask(SelectionKey selectionKey, CountDownLatch startedLatch) {\n+            this.selectionKey = Objects.requireNonNull(selectionKey);\n+            this.startedLatch = startedLatch;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            try {\n+                Selector selector = selectionKey.selector();\n+                SelectableChannel channel = selectionKey.channel();\n+                \/\/ notify that the task has started\n+                startedLatch.countDown();\n+                while (true) {\n+                    selector.select(10);\n+                    if (!channel.isOpen()) {\n+                        \/\/ the channel is (defer) closed, cancel the registration and then\n+                        \/\/ issue a select() so that the Selector finishes the deferred\n+                        \/\/ close of the channel.\n+                        System.out.println(\"channel: \" + channel + \" isn't open,\" +\n+                                \" now cancelling key: \" + selectionKey);\n+                        selectionKey.cancel();\n+                        System.out.println(\"initiating select after key cancelled: \" + selectionKey);\n+                        selector.select(5);\n+                        break;\n+                    }\n+                }\n+            } catch (ClosedSelectorException _) {\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static final class ConnAcceptor implements Callable<SocketChannel> {\n+        private final ServerSocketChannel serverSocketChannel;\n+\n+        private ConnAcceptor(ServerSocketChannel serverSocketChannel) {\n+            this.serverSocketChannel = serverSocketChannel;\n+        }\n+\n+        @Override\n+        public SocketChannel call() throws Exception {\n+            SocketChannel accepted = serverSocketChannel.accept();\n+            System.out.println(\"Accepted connection: \" + accepted);\n+            return accepted;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredClose\/DeferredCloseTest.java","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.net;\n+\n+\n+import java.util.Locale;\n+\n+\/\/ Patched implementation only meant to be used in certain tests\n+public class InetSocketAddress extends SocketAddress {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 5076001401234631237L;\n+\n+    private static boolean enableDelay;\n+\n+    static {\n+        System.out.println(\"patched InetSocketAddress class in use\");\n+    }\n+\n+    private final String hostname;\n+    private final InetAddress addr;\n+    private final int port;\n+\n+    public InetSocketAddress(int port) {\n+        this(InetAddress.anyLocalAddress(), port);\n+    }\n+\n+    public InetSocketAddress(InetAddress addr, int port) {\n+        this(null,\n+                addr == null ? InetAddress.anyLocalAddress() : addr,\n+                checkPort(port));\n+    }\n+\n+    public InetSocketAddress(String hostname, int port) {\n+        checkHost(hostname);\n+        InetAddress addr = null;\n+        String host = null;\n+        try {\n+            addr = InetAddress.getByName(hostname);\n+        } catch (UnknownHostException e) {\n+            host = hostname;\n+        }\n+        this.hostname = host;\n+        this.addr = addr;\n+        this.port = checkPort(port);\n+    }\n+\n+    public static InetSocketAddress createUnresolved(String host, int port) {\n+        return new InetSocketAddress(checkHost(host), null, checkPort(port));\n+    }\n+\n+    public static void enableDelay() {\n+        enableDelay = true;\n+    }\n+\n+    public static void disableDelay() {\n+        enableDelay = false;\n+    }\n+\n+    private InetSocketAddress(String hostname, InetAddress addr, int port) {\n+        this.hostname = hostname;\n+        this.addr = addr;\n+        this.port = port;\n+        if (enableDelay) {\n+            doDelay();\n+        }\n+    }\n+\n+    \/**\n+     * Gets the port number.\n+     *\n+     * @return the port number.\n+     *\/\n+    public final int getPort() {\n+        if (enableDelay) {\n+            doDelay();\n+        }\n+        return this.port;\n+    }\n+\n+    \/**\n+     * Gets the {@code InetAddress}.\n+     *\n+     * @return the InetAddress or {@code null} if it is unresolved.\n+     *\/\n+    public final InetAddress getAddress() {\n+        return this.addr;\n+    }\n+\n+    public final String getHostName() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            return addr.getHostName();\n+        }\n+        return null;\n+    }\n+\n+    public final String getHostString() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            if (addr.holder().getHostName() != null) {\n+                return addr.holder().getHostName();\n+            } else {\n+                return addr.getHostAddress();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public final boolean isUnresolved() {\n+        return addr == null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String formatted;\n+        if (isUnresolved()) {\n+            formatted = hostname + \"\/<unresolved>\";\n+        } else {\n+            formatted = addr.toString();\n+            if (addr instanceof Inet6Address) {\n+                int i = formatted.lastIndexOf(\"\/\");\n+                formatted = formatted.substring(0, i + 1)\n+                        + \"[\" + formatted.substring(i + 1) + \"]\";\n+            }\n+        }\n+        return formatted + \":\" + port;\n+    }\n+\n+    @Override\n+    public final boolean equals(Object other) {\n+        if (!(other instanceof InetSocketAddress that)) {\n+            return false;\n+        }\n+        boolean sameIP;\n+        if (addr != null) {\n+            sameIP = addr.equals(that.addr);\n+        } else if (hostname != null) {\n+            sameIP = (that.addr == null) &&\n+                    hostname.equalsIgnoreCase(that.hostname);\n+        } else {\n+            sameIP = (that.addr == null) && (that.hostname == null);\n+        }\n+        return sameIP && (port == that.port);\n+    }\n+\n+    @Override\n+    public final int hashCode() {\n+        if (addr != null) {\n+            return addr.hashCode() + port;\n+        }\n+        if (hostname != null) {\n+            return hostname.toLowerCase(Locale.ROOT).hashCode() + port;\n+        }\n+        return port;\n+    }\n+\n+    private static int checkPort(int port) {\n+        if (port < 0 || port > 0xFFFF)\n+            throw new IllegalArgumentException(\"port out of range:\" + port);\n+        return port;\n+    }\n+\n+    private static String checkHost(String hostname) {\n+        if (hostname == null)\n+            throw new IllegalArgumentException(\"hostname can't be null\");\n+        return hostname;\n+    }\n+\n+    private static void doDelay() {\n+        System.out.println(\"intentional delay injected in InetSocketAddress\");\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredClose\/java.base\/java\/net\/InetSocketAddress.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,2 @@\n-\/* @test\n- * @bug 8011536 8151430 8316304\n+\/* @test id=tmp\n+ * @bug 8011536 8151430 8316304 8334339\n@@ -27,1 +27,1 @@\n- *     that support it.\n+ *     that support it, tests using \/tmp directory.\n@@ -33,0 +33,9 @@\n+\/* @test id=cwd\n+ * @summary Basic test for creationTime attribute on platforms\/file systems\n+ *     that support it, tests using the test scratch directory, the test\n+ *     scratch directory maybe at diff disk partition to \/tmp on linux.\n+ * @library  ..\/.. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main CreationTime .\n+ *\/\n+\n@@ -41,0 +50,1 @@\n+import jtreg.SkippedException;\n@@ -71,2 +81,8 @@\n-            err.println(\"File creation time reported as: \" + creationTime);\n-            throw new RuntimeException(\"Expected to be close to: \" + now);\n+            System.out.println(\"creationTime.toMillis() == \" + creationTime.toMillis());\n+            \/\/ If the file system doesn't support birth time, then skip this test\n+            if (creationTime.toMillis() == 0) {\n+                throw new SkippedException(\"birth time not support for: \" + file);\n+            } else {\n+                err.println(\"File creation time reported as: \" + creationTime);\n+                throw new RuntimeException(\"Expected to be close to: \" + now);\n+            }\n@@ -98,1 +114,1 @@\n-        System.out.println(\"supportsCreationTimeRead == \" + supportsCreationTimeRead);\n+        System.out.println(top + \" supportsCreationTimeRead == \" + supportsCreationTimeRead);\n@@ -130,1 +146,6 @@\n-        Path dir = TestUtil.createTemporaryDirectory();\n+        Path dir;\n+        if (args.length == 0) {\n+            dir = TestUtil.createTemporaryDirectory();\n+        } else {\n+            dir = TestUtil.createTemporaryDirectory(args[0]);\n+        }\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/CreationTime.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4018937 8008577 8174269\n+ * @bug 4018937 8008577 8174269 8333755\n@@ -32,2 +32,6 @@\n-import java.text.*;\n-import java.util.*;\n+import java.text.DecimalFormat;\n+import java.text.Format;\n+import java.text.MessageFormat;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n@@ -546,1 +550,5 @@\n-         * DecimalFormat.parse() for some cases.\n+         * DecimalFormat.parse() for some cases. This is because parsing integer\n+         * only will return a successful parse for the subformat, but since the index\n+         * returned is not equal to the length, at the MessageFormat level, this\n+         * will be interpreted as a failed parse, and so the DecimalFormat index\n+         * should be reflected as the MessageFormat errorIndex.\n@@ -551,5 +559,3 @@\n-        {2, 0},         \/\/ parsing stopped at '(' because cannot find ')'\n-        {2, 0},         \/\/ parsing stopped at the first numeric\n-                        \/\/ because cannot find '%'\n-        {2, 0},         \/\/ parsing stopped at the first numeric\n-                        \/\/ because cannot find '%'\n+        {30, 0},        \/\/ parsing stopped at '.'\n+        {31, 0},        \/\/ parsing stopped at '.'\n+        {32, 0},        \/\/ parsing stopped at '.'\n@@ -558,1 +564,0 @@\n-\n@@ -561,2 +566,1 @@\n-                        \/\/ because cannot find '%'\n-        {2, 0},         \/\/ parsing stopped at '(' because cannot find ')'\n+        {57, 0},        \/\/ parsing stopped at '.'\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/BigDecimalParse.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8327640 8331485\n+ * @bug 8327640 8331485 8333755\n@@ -37,0 +37,1 @@\n+import org.junit.jupiter.api.BeforeEach;\n@@ -75,11 +76,12 @@\n-\n-\n-    \/\/ All NumberFormats should parse strictly\n-    static {\n-        dFmt.setStrict(true);\n-        pFmt.setStrict(true);\n-        cFmt.setStrict(true);\n-        cmpctFmt.setStrict(true);\n-        \/\/ To effectively test strict compactNumberFormat parsing\n-        cmpctFmt.setParseIntegerOnly(false);\n-        cmpctFmt.setGroupingUsed(true);\n+    private static final NumberFormat[] FORMATS = new NumberFormat[]{dFmt, cFmt, pFmt, cmpctFmt};\n+\n+    \/\/ Restore defaults before runs\n+    @BeforeEach\n+    void beforeEach() {\n+        for (NumberFormat fmt : FORMATS) {\n+            fmt.setStrict(true);\n+            fmt.setParseIntegerOnly(false);\n+            fmt.setGroupingUsed(true);\n+        }\n+        \/\/ Grouping Size is not defined at NumberFormat level\n+        \/\/ Compact needs to manually init grouping size\n@@ -117,0 +119,14 @@\n+\n+    \/\/ 8333755: Check that parsing with integer only against a suffix value works\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void integerOnlyParseWithSuffixTest() {\n+        \/\/ Some pattern with a suffix\n+        DecimalFormat fmt = new DecimalFormat(\"0.00b\");\n+        fmt.setParseIntegerOnly(true);\n+        assertEquals(5d, successParse(fmt, \"5.55b\", 1));\n+        assertEquals(5d, successParse(fmt, \"5b\", 2));\n+        assertEquals(5555d, successParse(fmt, \"5,555.55b\", 5));\n+        assertEquals(5d, successParse(fmt, \"5.55E55b\", 1));\n+    }\n+\n@@ -173,1 +189,0 @@\n-        dFmt.setGroupingUsed(true);\n@@ -176,2 +191,3 @@\n-    \/\/ Exception should be thrown if decimal separator occurs anywhere\n-    \/\/ Don't pass badParseStrings for same reason as previous method.\n+    \/\/ 8333755: Parsing behavior should follow normal strict behavior\n+    \/\/ However the index returned, should be before decimal point\n+    \/\/ and the value parsed equal to the integer portion\n@@ -179,4 +195,2 @@\n-    @MethodSource({\"validParseStrings\", \"integerOnlyParseStrings\"})\n-    public void numFmtStrictIntegerOnlyUsed(String toParse) {\n-        \/\/ When integer only is true, if a decimal separator is found,\n-        \/\/ a failure should occur\n+    @MethodSource(\"validIntegerOnlyParseStrings\")\n+    public void numFmtStrictIntegerOnlyUsedTest(String toParse, Number expVal) {\n@@ -184,3 +198,3 @@\n-        int failIndex = toParse.indexOf(dfs.getDecimalSeparator());\n-        if (failIndex > -1) {\n-            failParse(dFmt, toParse, failIndex);\n+        int expectedIndex = toParse.indexOf(dfs.getDecimalSeparator());\n+        if (expectedIndex > -1) {\n+            assertEquals(successParse(dFmt, toParse, expectedIndex), expVal);\n@@ -188,1 +202,1 @@\n-            successParse(dFmt, toParse);\n+            assertEquals(successParse(dFmt, toParse), expVal);\n@@ -190,1 +204,9 @@\n-        dFmt.setParseIntegerOnly(false);\n+    }\n+\n+    \/\/ 8333755: Parsing behavior should follow normal strict behavior\n+    \/\/ when it comes to failures.\n+    @ParameterizedTest\n+    @MethodSource(\"badParseStrings\")\n+    public void numFmtStrictIntegerOnlyUsedFailTest(String toParse, int expectedErrorIndex) {\n+        dFmt.setParseIntegerOnly(true);\n+        failParse(dFmt, toParse, expectedErrorIndex);\n@@ -273,0 +295,12 @@\n+    @ParameterizedTest\n+    @MethodSource({\"validIntegerOnlyParseStrings\", \"compactValidIntegerOnlyParseStrings\"})\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseIntOnlyTest(String toParse, double expectedValue) {\n+        \/\/ compact does not accept exponents\n+        if (toParse.indexOf('E') > -1) {\n+            return;\n+        }\n+        cmpctFmt.setParseIntegerOnly(true);\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, toParse.length()));\n+    }\n+\n@@ -282,1 +316,7 @@\n-    private double successParse(NumberFormat fmt, String toParse) {\n+    private Number successParse(NumberFormat fmt, String toParse) {\n+        return successParse(fmt, toParse, toParse.length());\n+    }\n+\n+    \/\/ Overloaded method that allows for an expected ParsePosition index value\n+    \/\/ that is not the string length.\n+    private Number successParse(NumberFormat fmt, String toParse, int expectedIndex) {\n@@ -295,1 +335,1 @@\n-        assertEquals(toParse.length(), pp.getIndex(),\n+        assertEquals(expectedIndex, pp.getIndex(),\n@@ -391,1 +431,3 @@\n-                Arguments.of(\"1,234,a\", 5))\n+                Arguments.of(\"1,234,a\", 5),\n+                \/\/ Double decimal\n+                Arguments.of(\"1,234..5\", 5))\n@@ -400,0 +442,2 @@\n+                Arguments.of(\"1,234.55\", 1234.55d),\n+                Arguments.of(\"1,234.5\", 1234.5d),\n@@ -417,4 +461,3 @@\n-    \/\/ Separate test data set for integer only. Can not use \"badParseStrings\", as\n-    \/\/ there is test data where the failure may occur from some other issue,\n-    \/\/ not related to grouping\n-    private static Stream<Arguments> integerOnlyParseStrings() {\n+    \/\/ Separate test data set for integer only.\n+    \/\/ Valid parse strings, that would parse successfully for integer\/non-integer parse\n+    private static Stream<Arguments> validIntegerOnlyParseStrings() {\n@@ -422,6 +465,9 @@\n-                Arguments.of(\"234.a\"),\n-                Arguments.of(\"234.a1\"),\n-                Arguments.of(\"234.1\"),\n-                Arguments.of(\"234.1a\"),\n-                Arguments.of(\"234.\"))\n-                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0]))));\n+                Arguments.of(\"234\", 234d),\n+                Arguments.of(\"234.\", 234d),\n+                Arguments.of(\"234.1\", 234d),\n+                Arguments.of(\"1,234.1\", 1234d),\n+                Arguments.of(\"234.12345\", 234d),\n+                Arguments.of(\"234.543E23\", 234d),\n+                Arguments.of(\"234,000.55E22\", 234000d),\n+                Arguments.of(\"234E22\", 234E22))\n+                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n@@ -517,0 +563,6 @@\n+    private static Stream<Arguments> compactValidIntegerOnlyParseStrings() {\n+        return validIntegerOnlyParseStrings().map(args -> Arguments.of(\n+                args.get()[0] + \"K\", (double) args.get()[1] * 1000)\n+        );\n+    }\n+\n@@ -529,1 +581,4 @@\n-            } else if (c == '0') {\n+            } else if (c == 'E') {\n+                sb.append(dfs.getExponentSeparator());\n+            }\n+            else if (c == '0') {\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictParseTest.java","additions":93,"deletions":38,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    static final String datafile = \"tablea1.txt\";\n+    static final String datafile = \"ISO4217-list-one.txt\";\n","filename":"test\/jdk\/java\/util\/Currency\/CheckDataVersion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *      8264792\n+ *      8264792 8334653\n@@ -62,1 +62,1 @@\n-    \/\/ 'tablea1.txt' should be up-to-date before testing\n+    \/\/ 'ISO4217-list-one.txt' should be up-to-date before testing\n","filename":"test\/jdk\/java\/util\/Currency\/CurrencyTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n-# Amendments up until ISO 4217 AMENDMENT NUMBER 176\n-#   (As of 06 December 2023)\n+# Amendments up until ISO 4217 AMENDMENT NUMBER 177\n+#   (As of 20 June 2024)\n@@ -9,1 +9,1 @@\n-DATAVERSION=176\n+DATAVERSION=177\n@@ -279,1 +279,1 @@\n-ZW\tZWL\t932\t2\n+ZW\tZWG\t924\t2\n","filename":"test\/jdk\/java\/util\/Currency\/ISO4217-list-one.txt","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/util\/Currency\/tablea1.txt","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *      8208746 8209775 8264792 8274658 8283277 8296239 8321480\n+ *      8208746 8209775 8264792 8274658 8283277 8296239 8321480 8334653\n@@ -63,1 +63,2 @@\n- * based on ISO 4217. The golden-data file (ISO 4217 data) 'tablea1.txt' has the following\n+ * based on ISO 4217. The golden-data file, 'ISO4217-list-one.txt', based on the\n+ * “List one: Currency, fund and precious metal codes” has the following\n@@ -71,1 +72,1 @@\n-            \"test.src\", \".\"), \"tablea1.txt\");\n+            \"test.src\", \".\"), \"ISO4217-list-one.txt\");\n@@ -92,1 +93,1 @@\n-                    + \"YUM-ZMK-ZWD-ZWN-ZWR\";\n+                    + \"YUM-ZMK-ZWD-ZWL-ZWN-ZWR\";\n","filename":"test\/jdk\/java\/util\/Currency\/ValidateISO4217.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *      8327631 8332424\n+ *      8327631 8332424 8334418\n@@ -30,1 +30,1 @@\n- *          (LSR Revision: 2024-05-16) with Locale and Locale.LanguageRange\n+ *          (LSR Revision: 2024-06-14) with Locale and Locale.LanguageRange\n","filename":"test\/jdk\/java\/util\/Locale\/LanguageSubtagRegistryTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,6 +43,12 @@\n-        if (server.getSession(client1).getSessionContext() == null) {\n-            for (Exception e : server.getExceptionList()) {\n-                System.out.println(\"Looking at \" + e.getClass() + \" \" +\n-                    e.getMessage());\n-                if (e.getMessage().contains(args[0])) {\n-                    System.out.println(\"Found correct exception: \" + args[0] +\n+\n+        server.getSession(client1).getSessionContext();\n+        server.done();\n+\n+        var eList = server.getExceptionList();\n+        System.out.println(\"Exception list size is \" + eList.size());\n+\n+        for (Exception e : eList) {\n+            System.out.println(\"Looking at \" + e.getClass() + \" \" +\n+                e.getMessage());\n+            if (e.getMessage().contains(args[0])) {\n+                System.out.println(\"Found correct exception: \" + args[0] +\n@@ -50,4 +56,3 @@\n-                    return;\n-                } else {\n-                    System.out.println(\"No \\\"\" + args[0] + \"\\\" found.\");\n-                }\n+                return;\n+            } else {\n+                System.out.println(\"No \\\"\" + args[0] + \"\\\" found.\");\n@@ -55,2 +60,0 @@\n-\n-            throw new Exception(\"Failed to find expected alert: \" + args[0]);\n@@ -58,0 +61,2 @@\n+\n+        throw new Exception(\"Failed to find expected alert: \" + args[0]);\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CertMsgCheck.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile);\n+            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+                \"\/\" + pathToStores + \"\/\" + keyStoreFile);\n@@ -116,2 +116,2 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile);\n+            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+                \"\/\" + pathToStores + \"\/\" + trustStoreFile);\n@@ -151,1 +151,0 @@\n-        boolean exit = false;\n@@ -160,1 +159,2 @@\n-                sslContext.init(TLSBase.getKeyManager(builder.km), TLSBase.getTrustManager(builder.tm), null);\n+                sslContext.init(TLSBase.getKeyManager(builder.km),\n+                    TLSBase.getTrustManager(builder.tm), null);\n@@ -166,1 +166,1 @@\n-                System.err.println(e.getMessage());\n+                System.err.println(\"Failure during server initialization\");\n@@ -181,0 +181,1 @@\n+                            System.out.println(\"Caught \" + e.getMessage());\n@@ -206,1 +207,2 @@\n-                sslContext.init(TLSBase.getKeyManager(km), TLSBase.getTrustManager(tm), null);\n+                sslContext.init(TLSBase.getKeyManager(km),\n+                    TLSBase.getTrustManager(tm), null);\n@@ -212,1 +214,1 @@\n-                System.err.println(e.getMessage());\n+                System.err.println(\"Failure during server initialization\");\n@@ -227,0 +229,1 @@\n+                                System.out.println(\"Caught \" + e.getMessage());\n@@ -228,0 +231,1 @@\n+                                exceptionList.add(e);\n@@ -242,1 +246,1 @@\n-                t.interrupt();\n+                t.join(5000);\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-                Files.walk(JRT.getPath(\"modules\/java.base\/java\")),\n+                Files.walk(JRT.getPath(\"modules\/java.base\/java\/util\")),\n@@ -143,0 +143,1 @@\n+                || m == Transforms.NoOpTransform.CLASS_REMAPPER\n@@ -193,1 +194,0 @@\n-    }\n@@ -195,4 +195,1 @@\n-    @ParameterizedTest\n-    @MethodSource(\"corpus\")\n-    void testReadAndTransform(Path path) throws IOException {\n-        byte[] bytes = Files.readAllBytes(path);\n+        \/\/ test read and transform\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- * @run main\/othervm -XX:TLABSize=2k jdk.jfr.jvm.TestWaste\n+ * @run main\/othervm -Xlog:jfr+system+parser=debug -XX:TLABSize=2k jdk.jfr.jvm.TestWaste\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestWaste.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp\n@@ -32,1 +32,1 @@\n- * @run main\/othervm\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n@@ -45,3 +45,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca1 CRL\n@@ -56,3 +56,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca2 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca2 CRL\n@@ -67,3 +67,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca3 CRL\n@@ -78,3 +78,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca4 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca4 CRL\n@@ -89,3 +89,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca CRL\n@@ -100,3 +100,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass3ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass3ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca CRL\n@@ -111,3 +111,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop comodorsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodorsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop comodorsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop comodorsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodorsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop comodorsaca CRL\n@@ -122,3 +122,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop comodoeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodoeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop comodoeccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop comodoeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodoeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop comodoeccca CRL\n@@ -133,3 +133,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop usertrustrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrustrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop usertrustrsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop usertrustrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrustrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop usertrustrsaca CRL\n@@ -144,3 +144,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop usertrusteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrusteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop usertrusteccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop usertrusteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrusteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop usertrusteccca CRL\n@@ -155,2 +155,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx1 DEFAULT\n@@ -165,2 +165,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx2 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx2 DEFAULT\n@@ -175,3 +175,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsignrootcar6 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignrootcar6 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsignrootcar6 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsignrootcar6 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignrootcar6 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop globalsignrootcar6 CRL\n@@ -186,3 +186,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop entrustrootcaec1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcaec1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop entrustrootcaec1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop entrustrootcaec1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcaec1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop entrustrootcaec1 CRL\n@@ -197,3 +197,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop entrustrootcag4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcag4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop entrustrootcag4 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop entrustrootcag4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcag4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop entrustrootcag4 CRL\n@@ -208,3 +208,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop godaddyrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop godaddyrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop godaddyrootg2ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop godaddyrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop godaddyrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop godaddyrootg2ca CRL\n@@ -219,3 +219,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop starfieldrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop starfieldrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop starfieldrootg2ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop starfieldrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop starfieldrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop starfieldrootg2ca CRL\n@@ -230,2 +230,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsigneccrootcar4 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigneccrootcar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsigneccrootcar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigneccrootcar4 DEFAULT\n@@ -240,2 +240,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar1 DEFAULT\n@@ -250,2 +250,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar2 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar2 DEFAULT\n@@ -260,2 +260,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar3 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar3 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar3 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar3 DEFAULT\n@@ -270,2 +270,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar4 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar4 DEFAULT\n@@ -280,3 +280,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop microsoftecc2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftecc2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop microsoftecc2017 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop microsoftecc2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftecc2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop microsoftecc2017 CRL\n@@ -291,3 +291,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop microsoftrsa2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftrsa2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop microsoftrsa2017 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop microsoftrsa2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftrsa2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop microsoftrsa2017 CRL\n@@ -302,3 +302,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca1g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca1g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop quovadisrootca1g3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca1g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca1g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop quovadisrootca1g3 CRL\n@@ -313,3 +313,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca2g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca2g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop quovadisrootca2g3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca2g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca2g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop quovadisrootca2g3 CRL\n@@ -324,3 +324,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca3g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca3g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop quovadisrootca3g3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca3g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca3g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop quovadisrootca3g3 CRL\n@@ -335,3 +335,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop digicerttlseccrootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlseccrootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop digicerttlseccrootg5 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop digicerttlseccrootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlseccrootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop digicerttlseccrootg5 CRL\n@@ -346,3 +346,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop digicerttlsrsarootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlsrsarootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop digicerttlsrsarootg5 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop digicerttlsrsarootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlsrsarootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop digicerttlsrsarootg5 CRL\n@@ -357,3 +357,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop sslrootrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop sslrootrsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop sslrootrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop sslrootrsaca CRL\n@@ -368,3 +368,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop sslrootevrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootevrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop sslrootevrsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop sslrootevrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootevrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop sslrootevrsaca CRL\n@@ -379,3 +379,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop sslrooteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrooteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop sslrooteccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop sslrooteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrooteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop sslrooteccca CRL\n@@ -390,3 +390,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop teliasonerarootcav1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliasonerarootcav1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop teliasonerarootcav1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop teliasonerarootcav1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliasonerarootcav1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop teliasonerarootcav1 CRL\n@@ -401,3 +401,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop twcaglobalrootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop twcaglobalrootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop twcaglobalrootca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop twcaglobalrootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop twcaglobalrootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop twcaglobalrootca CRL\n@@ -412,3 +412,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop certignarootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certignarootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop certignarootca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop certignarootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certignarootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop certignarootca CRL\n@@ -423,3 +423,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustcommercialca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustcommercialca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustcommercialca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustcommercialca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustcommercialca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustcommercialca CRL\n@@ -434,3 +434,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustnetworkingca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustnetworkingca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustnetworkingca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustnetworkingca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustnetworkingca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustnetworkingca CRL\n@@ -445,3 +445,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustpremiumca CRL\n@@ -456,3 +456,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumeccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustpremiumeccca CRL\n@@ -467,3 +467,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop teliarootcav2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliarootcav2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop teliarootcav2 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop teliarootcav2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliarootcav2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop teliarootcav2 CRL\n@@ -478,3 +478,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop emsignrootcag1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsignrootcag1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop emsignrootcag1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop emsignrootcag1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsignrootcag1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop emsignrootcag1 CRL\n@@ -489,3 +489,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop emsigneccrootcag3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsigneccrootcag3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop emsigneccrootcag3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop emsigneccrootcag3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsigneccrootcag3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop emsigneccrootcag3 CRL\n@@ -500,2 +500,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop certainlyrootr1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyrootr1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop certainlyrootr1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyrootr1 DEFAULT\n@@ -510,2 +510,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop certainlyroote1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyroote1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop certainlyroote1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyroote1 DEFAULT\n@@ -520,3 +520,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsignr46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignr46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsignr46 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsignr46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignr46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop globalsignr46 CRL\n@@ -531,3 +531,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsigne46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigne46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsigne46 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsigne46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigne46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop globalsigne46 CRL\n@@ -537,1 +537,3 @@\n- * Collection of certificate validation tests for interoperability with external CAs\n+ * Collection of certificate validation tests for interoperability with external CAs.\n+ * These tests are marked as manual as they depend on external infrastructure and may fail\n+ * with external reasons, for instance - change in CA test portal.\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":135,"deletions":133,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath CertignaCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CertignaCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CertignaCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CertignaCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CertignaCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath DTrustCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath DTrustCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath DTrustCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath DTrustCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/DTrustCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=ocsp,certpath DigicertCSRootG5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath DigicertCSRootG5 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=ocsp,certpath DigicertCSRootG5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath DigicertCSRootG5 CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/DigicertCSRootG5.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath EmSignRootG2CA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath EmSignRootG2CA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath EmSignRootG2CA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath EmSignRootG2CA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/EmSignRootG2CA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath HaricaCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath HaricaCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath HaricaCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath HaricaCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/HaricaCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath LuxTrustCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath LuxTrustCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath LuxTrustCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath LuxTrustCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/LuxTrustCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm HttpsURLConnectionTest https:\/\/github.com KeychainStore-Root\n+ * @run main\/othervm\/manual HttpsURLConnectionTest https:\/\/github.com KeychainStore-Root\n","filename":"test\/jdk\/security\/infra\/javax\/net\/ssl\/HttpsURLConnectionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,1 +176,1 @@\n-                    is.read ();\n+                    System.out.println(\"client got expected exception: \"+ioe);\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveStream\/KeepAliveStreamCloseWithWrongContentLength.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.security.Provider;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @bug 8330842\n+ * @summary test AES CTS multipart operations with SunPKCS11\n+ * @library \/test\/lib ..\n+ * @run main\/othervm\/timeout=120 TestCipherTextStealingMultipart\n+ *\/\n+\n+public class TestCipherTextStealingMultipart extends PKCS11Test {\n+    private static final String LF = System.lineSeparator();\n+    private static final String ALGORITHM = \"AES\/CTS\/NoPadding\";\n+    private static final int BLOCK_SIZE = 16;\n+    private static final Key KEY =\n+            new SecretKeySpec(\"AbCdEfGhIjKlMnOp\".getBytes(), \"AES\");\n+    private static final IvParameterSpec IV =\n+            new IvParameterSpec(\"1234567890aBcDeF\".getBytes());\n+\n+    private static final StringBuilder chunksDesc = new StringBuilder();\n+    private static Provider sunPKCS11;\n+    private static Cipher sunJCECipher;\n+\n+    private static byte[][] generateChunks(int totalLength, int[] chunkSizes) {\n+        chunksDesc.setLength(0);\n+        chunksDesc.append(\"Testing with \").append(totalLength)\n+                .append(\" bytes distributed in \").append(chunkSizes.length)\n+                .append(\" multipart updates:\").append(LF);\n+        int byteIdx = 0;\n+        byte[][] plaintextChunks = new byte[chunkSizes.length][];\n+        for (int chunkIdx = 0; chunkIdx < chunkSizes.length; chunkIdx++) {\n+            byte[] chunk = new byte[chunkSizes[chunkIdx]];\n+            for (int i = 0; i < chunk.length; i++) {\n+                chunk[i] = (byte) ('A' + byteIdx++ \/ BLOCK_SIZE);\n+            }\n+            chunksDesc.append(\"  \").append(repr(chunk)).append(LF);\n+            plaintextChunks[chunkIdx] = chunk;\n+        }\n+        return plaintextChunks;\n+    }\n+\n+    private static byte[] computeExpected(byte[] jointPlaintext)\n+            throws Exception {\n+        byte[] ciphertext = sunJCECipher.doFinal(jointPlaintext);\n+        if (ciphertext.length != jointPlaintext.length) {\n+            throw new Exception(\"In CTS mode, ciphertext and plaintext should\" +\n+                    \" have the same length. However, SunJCE's CTS cipher \" +\n+                    \"returned a ciphertext of \" + ciphertext.length + \" bytes\" +\n+                    \" and plaintext has \" + jointPlaintext.length + \" bytes.\");\n+        }\n+        return ciphertext;\n+    }\n+\n+    private static byte[] join(byte[][] inputChunks, int totalLength) {\n+        ByteBuffer outputBuf = ByteBuffer.allocate(totalLength);\n+        for (byte[] inputChunk : inputChunks) {\n+            outputBuf.put(inputChunk);\n+        }\n+        return outputBuf.array();\n+    }\n+\n+    private static byte[][] split(byte[] input, int[] chunkSizes) {\n+        ByteBuffer inputBuf = ByteBuffer.wrap(input);\n+        byte[][] outputChunks = new byte[chunkSizes.length][];\n+        for (int chunkIdx = 0; chunkIdx < chunkSizes.length; chunkIdx++) {\n+            byte[] chunk = new byte[chunkSizes[chunkIdx]];\n+            inputBuf.get(chunk);\n+            outputChunks[chunkIdx] = chunk;\n+        }\n+        return outputChunks;\n+    }\n+\n+    private enum CheckType {CIPHERTEXT, PLAINTEXT}\n+\n+    private enum OutputType {BYTE_ARRAY, DIRECT_BYTE_BUFFER}\n+\n+    private static void check(CheckType checkType, OutputType outputType,\n+            byte[] expected, ByteBuffer actualBuf) throws Exception {\n+        byte[] actual;\n+        if (actualBuf.hasArray()) {\n+            actual = actualBuf.array();\n+        } else {\n+            actual = new byte[actualBuf.position()];\n+            actualBuf.position(0).get(actual);\n+        }\n+        if (!Arrays.equals(actual, expected)) {\n+            throw new Exception(\"After \" + switch (checkType) {\n+                case CIPHERTEXT -> \"encrypting\";\n+                case PLAINTEXT -> \"decrypting\";\n+            } + \" into a \" + switch (outputType) {\n+                case BYTE_ARRAY -> \"byte[]\";\n+                case DIRECT_BYTE_BUFFER -> \"direct ByteBuffer\";\n+            } + \", \" + checkType.name().toLowerCase() + \"s don't match:\" + LF +\n+                    \"  Expected: \" + repr(expected) + LF +\n+                    \"    Actual: \" + repr(actual));\n+        }\n+    }\n+\n+    private static ByteBuffer encryptOrDecryptMultipart(int operation,\n+            OutputType outputType, byte[][] inputChunks, int totalLength)\n+            throws Exception {\n+        Cipher cipher = Cipher.getInstance(ALGORITHM, sunPKCS11);\n+        cipher.init(operation, KEY, IV);\n+        ByteBuffer output = null;\n+        int outOfs = 1;\n+        switch (outputType) {\n+            case BYTE_ARRAY -> {\n+                output = ByteBuffer.allocate(totalLength);\n+                for (byte[] inputChunk : inputChunks) {\n+                    output.put(cipher.update(inputChunk));\n+                }\n+                \/\/ Check that the output array offset does not affect the\n+                \/\/ penultimate block length calculation.\n+                byte[] tmpOut = new byte[cipher.getOutputSize(0) + outOfs];\n+                cipher.doFinal(tmpOut, outOfs);\n+                output.put(tmpOut, outOfs, tmpOut.length - outOfs);\n+            }\n+            case DIRECT_BYTE_BUFFER -> {\n+                output = ByteBuffer.allocateDirect(totalLength);\n+                for (byte[] inputChunk : inputChunks) {\n+                    cipher.update(ByteBuffer.wrap(inputChunk), output);\n+                }\n+                \/\/ Check that the output array offset does not affect the\n+                \/\/ penultimate block length calculation.\n+                ByteBuffer tmpOut = ByteBuffer.allocateDirect(\n+                        cipher.getOutputSize(0) + outOfs);\n+                tmpOut.position(outOfs);\n+                cipher.doFinal(ByteBuffer.allocate(0), tmpOut);\n+                tmpOut.position(outOfs);\n+                output.put(tmpOut);\n+            }\n+        }\n+        return output;\n+    }\n+\n+    private static void doMultipart(int... chunkSizes) throws Exception {\n+        int totalLength = IntStream.of(chunkSizes).sum();\n+        byte[][] plaintextChunks = generateChunks(totalLength, chunkSizes);\n+        byte[] jointPlaintext = join(plaintextChunks, totalLength);\n+        byte[] expectedCiphertext = computeExpected(jointPlaintext);\n+        byte[][] ciphertextChunks = split(expectedCiphertext, chunkSizes);\n+\n+        for (OutputType outputType : OutputType.values()) {\n+            \/\/ Encryption test\n+            check(CheckType.CIPHERTEXT, outputType, expectedCiphertext,\n+                    encryptOrDecryptMultipart(Cipher.ENCRYPT_MODE, outputType,\n+                            plaintextChunks, totalLength));\n+            \/\/ Decryption test\n+            check(CheckType.PLAINTEXT, outputType, jointPlaintext,\n+                    encryptOrDecryptMultipart(Cipher.DECRYPT_MODE, outputType,\n+                            ciphertextChunks, totalLength));\n+        }\n+    }\n+\n+    private static String repr(byte[] data) {\n+        if (data == null) {\n+            return \"<null>\";\n+        }\n+        if (data.length == 0) {\n+            return \"<empty []>\";\n+        }\n+        String lenRepr = \" (\" + data.length + \" bytes)\";\n+        for (byte b : data) {\n+            if (b < 32 || b > 126) {\n+                return HexFormat.ofDelimiter(\":\").formatHex(data) + lenRepr;\n+            }\n+        }\n+        return new String(data, StandardCharsets.US_ASCII) + lenRepr;\n+    }\n+\n+    private static void initialize() throws Exception {\n+        sunJCECipher = Cipher.getInstance(ALGORITHM, \"SunJCE\");\n+        sunJCECipher.init(Cipher.ENCRYPT_MODE, KEY, IV);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        initialize();\n+        main(new TestCipherTextStealingMultipart(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        sunPKCS11 = p;\n+        try {\n+            \/\/ Test relevant combinations for 2, 3, and 4 update operations\n+            int aesBSize = 16;\n+            int[] points = new int[]{1, aesBSize - 1, aesBSize, aesBSize + 1};\n+            for (int size1 : points) {\n+                for (int size2 : points) {\n+                    if (size1 + size2 >= aesBSize) {\n+                        doMultipart(size1, size2);\n+                    }\n+                    for (int size3 : points) {\n+                        if (size1 + size2 + size3 >= aesBSize) {\n+                            doMultipart(size1, size2, size3);\n+                        }\n+                        for (int size4 : points) {\n+                            if (size1 + size2 + size3 + size4 >= aesBSize) {\n+                                doMultipart(size1, size2, size3, size4);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            doMultipart(17, 17, 17, 17, 17);\n+            doMultipart(4, 2, 7, 1, 6, 12);\n+            doMultipart(2, 15, 21, 26, 31, 26, 5, 30);\n+            doMultipart(7, 12, 26, 8, 15, 2, 17, 16, 21, 2, 32, 29);\n+            doMultipart(6, 7, 6, 1, 5, 16, 14, 1, 10, 16, 17, 8, 1, 13, 12);\n+            doMultipart(16, 125, 19, 32, 32, 16, 17,\n+                    31, 19, 13, 16, 16, 32, 16, 16);\n+            doMultipart(5, 30, 11, 9, 6, 14, 20, 6,\n+                    5, 18, 31, 33, 15, 29, 7, 9);\n+            doMultipart(105, 8, 21, 27, 30, 101, 15, 20,\n+                    23, 33, 26, 6, 8, 2, 13, 17);\n+        } catch (Exception e) {\n+            System.out.print(chunksDesc);\n+            throw e;\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherTextStealingMultipart.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4898461 6604496\n+ * @bug 4898461 6604496 8330842\n@@ -83,1 +83,2 @@\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200)\n+        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 3200),\n@@ -86,1 +87,1 @@\n-    private static StringBuffer debugBuf = new StringBuffer();\n+    private static final StringBuffer debugBuf = new StringBuffer();\n@@ -131,4 +132,1 @@\n-            if (debugBuf != null) {\n-                System.out.println(debugBuf.toString());\n-                debugBuf = new StringBuffer();\n-            }\n+            System.out.println(debugBuf);\n@@ -174,2 +172,1 @@\n-        perfOut(\"stream InBuf + stream OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"stream InBuf + stream OutBuf\", endTime - startTime);\n@@ -187,2 +184,1 @@\n-        perfOut(\"non-direct InBuf + non-direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"non-direct InBuf + non-direct OutBuf\", endTime - startTime);\n@@ -200,2 +196,1 @@\n-        perfOut(\"direct InBuf + direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"direct InBuf + direct OutBuf\", endTime - startTime);\n@@ -218,2 +213,1 @@\n-        perfOut(\"direct InBuf + non-direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"direct InBuf + non-direct OutBuf\", endTime - startTime);\n@@ -234,2 +228,1 @@\n-        perfOut(\"non-direct InBuf + direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"non-direct InBuf + direct OutBuf\", endTime - startTime);\n@@ -241,1 +234,1 @@\n-        debugBuf = null;\n+        debugBuf.setLength(0);\n@@ -244,4 +237,2 @@\n-    private static void perfOut(String msg) {\n-        if (debugBuf != null) {\n-            debugBuf.append(\"PERF>\" + msg);\n-        }\n+    private static void perfOut(String msg, long elapsed) {\n+        debugOut(\"PERF> \" + msg + \", elapsed: \" + elapsed + \" ns\\n\");\n@@ -251,3 +242,1 @@\n-        if (debugBuf != null) {\n-            debugBuf.append(msg);\n-        }\n+        debugBuf.append(msg);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphers.java","additions":15,"deletions":26,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4898484 6604496 8001284\n+ * @bug 4898484 6604496 8001284 8330842\n@@ -71,1 +71,3 @@\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65)\n+        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 1600),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 65),\n@@ -74,1 +76,1 @@\n-    private static StringBuffer debugBuf;\n+    private static final StringBuffer debugBuf = new StringBuffer();\n@@ -114,3 +116,1 @@\n-            if (debugBuf != null) {\n-                System.out.println(debugBuf.toString());\n-            }\n+            System.out.println(debugBuf);\n@@ -125,1 +125,0 @@\n-        debugBuf = new StringBuffer();\n@@ -217,1 +216,1 @@\n-        debugBuf = null;\n+        debugBuf.setLength(0);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphersNoPad.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -794,2 +794,2 @@\n-                        .orElseThrow(() -> new SkippedException(\n-                        \"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + path));\n+                        .orElseThrow(() ->\n+                            new RuntimeException(\"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + path));\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-        assertEquals(stdout.size(), 1, \"Output should contain one line\");\n+        assertEquals(stdout.size(), 2, \"Output should contain two lines\"); \/\/ includes deprecation warning\n","filename":"test\/jdk\/sun\/tools\/jstatd\/JstatdTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -389,1 +389,0 @@\n-        vmOptFinalFlag(map, \"UseVtableBasedCHA\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334433\n+ * @summary Verify that when running JShell on platforms that support FFMTerminalProvider,\n+ *          no new processes are spawned.\n+ * @requires os.family == \"windows\" | os.family == \"mac\" | os.family == \"linux\"\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavaTask TerminalNoExecTest\n+ * @run main TerminalNoExecTest\n+ *\/\n+\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jshell.tool.JavaShellToolBuilder;\n+\n+import toolbox.ToolBox;\n+\n+public class TerminalNoExecTest {\n+\n+    public static void main(String... args) throws Exception {\n+        if (args.length > 0) {\n+            AtomicBoolean spawnedNewProcess = new AtomicBoolean();\n+            try (var rs = new RecordingStream()) {\n+                rs.enable(\"jdk.ProcessStart\").withoutThreshold();\n+                rs.onEvent(evt -> {\n+                    System.err.println(\"evt: \" + evt);\n+                    spawnedNewProcess.set(true);\n+                });\n+                rs.startAsync();\n+                JavaShellToolBuilder.builder().run(\"--execution=local\", \"--no-startup\");\n+                rs.stop();\n+            }\n+            if (spawnedNewProcess.get()) {\n+                System.err.println(\"Spawned a new process!\");\n+                System.exit(1);\n+            }\n+            System.exit(0);\n+        } else {\n+            Path testScript = Paths.get(\"do-exit\");\n+            try (Writer w = Files.newBufferedWriter(testScript)) {\n+                w.append(\"\/exit\\n\");\n+            }\n+\n+            ToolBox tb = new ToolBox();\n+            Process target =\n+                new ProcessBuilder(tb.getJDKTool(\"java\").toString(),\n+                                   \"-classpath\", System.getProperty(\"java.class.path\"),\n+                                   TerminalNoExecTest.class.getName(),\n+                                   \"run-test\")\n+                        .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                        .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n+                        .redirectInput(testScript.toFile())\n+                        .start();\n+\n+            target.waitFor();\n+\n+            int exitCode = target.exitValue();\n+\n+            if (exitCode != 0) {\n+                throw new AssertionError(\"Incorrect exit value, expected 0, got: \" + exitCode);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/jdk\/jshell\/TerminalNoExecTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- *      8239536 8247456 8246774 8238173 8292625 8306560\n+ *      8239536 8247456 8246774 8238173 8292625 8306560 8328536\n@@ -967,0 +967,7 @@\n+    @Test\n+    public void testSwitchExpressionYieldUnknownType() {\n+        test(a -> assertCommandOutputContains(a,\n+                \"I m(I i, int x) { return switch (x) { default -> i; }; } \",\n+                \"created method m(I,int), however, it cannot be referenced until class I is declared\"));\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333766\n+ * @summary Test for compiler crash when anonymous class created in early lambda\n+ *\/\n+\n+public class AnonSuperLambdaCrash {\n+    class Inner {\n+        Inner() {\n+            this(() -> new Object() { { AnonSuperLambdaCrash.this.hashCode(); } });\n+        }\n+        Inner(Runnable r) {\n+            r.run();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new AnonSuperLambdaCrash().new Inner();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/AnonSuperLambdaCrash.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+public class EarlyLocalTest1 {\n+\n+    class Test {\n+        Test() {\n+            class InnerLocal { }\n+            Runnable r = () -> new InnerLocal();\n+            r.run();\n+            super();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest1().new Test();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest1.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+public class EarlyLocalTest4 {\n+\n+    class Test {\n+        Test() {\n+            class InnerLocal { }\n+            Runnable r = new Runnable() {\n+                public void run() {\n+                    new InnerLocal();\n+                }\n+            };\n+            r.run();\n+            super();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest4().new Test();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest4.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class EarlyLocalTest5 {\n+\n+    int y;\n+\n+    class Test extends AtomicReference<Runnable> {\n+        Test(int x) {\n+            class Foo implements Runnable {\n+                public void run() {\n+                    System.out.println(x + y);\n+                }\n+            }\n+            super(new Foo());\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest5().new Test(42);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest5.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class EarlyLocalTest6 {\n+\n+    int y;\n+\n+    class Test extends AtomicReference<Runnable> {\n+        Test(int x) {\n+            super(new Runnable() {\n+                public void run() {\n+                    System.out.println(x + y);\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest6().new Test(42);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest6.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class EarlyLocalTest7 {\n+\n+    int y;\n+\n+    class Test extends AtomicReference<Runnable> {\n+        Test(int x) {\n+            super(() -> System.out.println(x + y));\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest7().new Test(42);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest7.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8334037\n+ * @summary Test for compiler crash when local class created in early lambda\n+ * @enablePreview\n+ *\/\n+\n+public class LambdaLocalEarlyCrash {\n+    interface A { }\n+\n+    class Inner {\n+       Inner() {\n+          this(() -> {\n+             class Local {\n+                void g() {\n+                   m();\n+                }\n+             }\n+             new Local().g(); \/\/ error\n+          });\n+       }\n+\n+       Inner(Runnable tr) {\n+          tr.run();\n+       }\n+    }\n+\n+    void m() {\n+       System.out.println(\"Hello\");\n+    }\n+\n+    public static void main(String[] args) {\n+       new LambdaLocalEarlyCrash().new Inner();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/LambdaLocalEarlyCrash.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8194743\n+ * @bug 8334252\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/LambdaOuterCapture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+T7188968.java:20:9: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -5,0 +6,2 @@\n+T7188968.java:22:9: compiler.warn.unchecked.meth.invocation.applied: kindname.constructor, <init>, java.util.List<X>,java.lang.Object, java.util.List,unknown, kindname.class, T7188968.Foo\n+T7188968.java:22:19: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), java.util.List, java.util.List<X>\n@@ -6,0 +9,2 @@\n+T7188968.java:23:20: compiler.warn.unchecked.meth.invocation.applied: kindname.method, makeFoo, java.util.List<Z>,java.lang.Object, java.util.List,unknown, kindname.class, T7188968.Foo\n+T7188968.java:23:21: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), java.util.List, java.util.List<Z>\n@@ -7,1 +12,1 @@\n-1 warning\n+6 warnings\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/7188968\/T7188968.out","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-MethodReference23.java:53:16: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: Inner1, , MethodReference23)\n+MethodReference23.java:53:16: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: Inner1, MethodReference23, MethodReference23)\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference23.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,15 @@\n-                    this(name, moonsCount, java.lang.invoke.LambdaMetafactory.metafactory(name, Universe.Galaxy.this, Universe.Galaxy.SolarSystem.this));\n+                    this(name, moonsCount, ()->{\n+                        String n = name;\n+                        StringBuffer buf = new StringBuffer();\n+                        buf.append(\"This planet belongs to the galaxy \" + Galaxy.this.name + \" with \" + starsCount + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the galaxy \" + Universe.Galaxy.this.name + \" with \" + starsCount() + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the galaxy \" + Galaxy.this.name() + \" with \" + starsCount() + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the galaxy \" + Universe.Galaxy.this.name() + \" with \" + (Universe.Galaxy.this).starsCount() + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + SolarSystem.this.name + \" with \" + planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + Galaxy.SolarSystem.this.name + \" with \" + planetsCount() + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + (SolarSystem.this).name + \" with \" + planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + Universe.Galaxy.SolarSystem.this.name + \" with \" + Universe.Galaxy.SolarSystem.this.planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + Universe.Galaxy.SolarSystem.this.name.toLowerCase().toUpperCase() + \" with \" + Universe.Galaxy.SolarSystem.this.planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + copy(Universe.Galaxy.SolarSystem.this).name.toLowerCase().toUpperCase() + \" with \" + Universe.Galaxy.SolarSystem.this.planetsCount + \" planets\\n\");\n+                        if (!buf.toString().equals(output)) throw new AssertionError(\"Unexpected value\\n\" + buf);\n+                    });\n@@ -79,16 +93,0 @@\n-                \n-                \/*synthetic*\/ private static void lambda$new$0(\/*synthetic*\/ final String name, \/*synthetic*\/ final Universe.Galaxy Universe$Galaxy$this, \/*synthetic*\/ final Universe.Galaxy.SolarSystem Universe$Galaxy$SolarSystem$this) {\n-                    String n = name;\n-                    StringBuffer buf = new StringBuffer();\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name + \" with \" + Universe$Galaxy$this.starsCount + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name + \" with \" + Universe$Galaxy$this.starsCount() + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name() + \" with \" + Universe$Galaxy$this.starsCount() + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name() + \" with \" + (Universe$Galaxy$this).starsCount() + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount() + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + (Universe$Galaxy$SolarSystem$this).name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name.toLowerCase().toUpperCase() + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.copy(Universe$Galaxy$SolarSystem$this).name.toLowerCase().toUpperCase() + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    if (!buf.toString().equals(output)) throw new AssertionError(\"Unexpected value\\n\" + buf);\n-                }\n","filename":"test\/langtools\/tools\/javac\/lambda\/T8129740\/Universe.java.out","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-MethodRefToInnerWithoutOuter.java:22:31: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: TestString, , MethodRefToInnerBase)\n+MethodRefToInnerWithoutOuter.java:22:31: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: TestString, java.lang.String, MethodRefToInnerBase)\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/MethodRefToInnerWithoutOuter.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,0 +206,31 @@\n+    @Test\n+    public void testErroneousTarget() throws Exception {\n+        String code = \"\"\"\n+                      public class C {\n+                          public Undefined g(Undefined u) {\n+                              return switch (0) {\n+                                  default -> u;\n+                              };\n+                          }\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL, 1)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"C.java:2:24: compiler.err.cant.resolve.location: kindname.class, Undefined, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:12: compiler.err.cant.resolve.location: kindname.class, Undefined, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"2 errors\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335136\n+ * @summary Underscore as parameter name in one-parameter functional types fails to compile in yield statement if not enclosed in parentheses\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.JavacTask toolbox.ToolBox toolbox.Task\n+ * @run main ExpressionSwitchUnderscoreAfterYield\n+ *\/\n+\n+import toolbox.*;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class ExpressionSwitchUnderscoreAfterYield extends TestRunner {\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    private final Path ROOT = Path.of(\".\");\n+\n+    public ExpressionSwitchUnderscoreAfterYield() {\n+        super(System.err);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new ExpressionSwitchUnderscoreAfterYield().runTests();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(f -> {\n+            if (f.getName().endsWith(\"_ShouldFailToCompile\")) {\n+                return new Object[]{\n+                        List.of(\n+                                FailParams.UNDERSCORE_YIELDED,\n+                                FailParams.ASSIGNMENT_TO_UNDERSCORE_IN_YIELD\n+                        )\n+                };\n+            }\n+            return new Object[0];\n+        });\n+    }\n+\n+    @Test\n+    public void testUnderscoreAsParameterNameInLambda_ShouldCompileFine() throws Exception {\n+        var code = \"\"\"\n+                        import java.util.function.*;\n+                        \\s\n+                        public class Test {\n+                            public static void main(String[] args) {\n+                                Consumer<Object> result = switch (1) {\n+                                    case 1 -> {\n+                                        yield _ -> {};\n+                                    }\n+                                    default -> null;\n+                                };\n+                            }\n+                        }\n+                        \"\"\";\n+        tb.writeJavaFiles(ROOT, code);\n+        new toolbox.JavacTask(tb)\n+                .files(tb.findJavaFiles(ROOT))\n+                .run(Task.Expect.SUCCESS);\n+    }\n+\n+    public record FailParams(String code, List<String> expectedDiagnosticMessage) {\n+        public static FailParams UNDERSCORE_YIELDED = new FailParams(\n+                \"\"\"\n+                        public class Test {\n+                            public static void main(String[] args) {\n+                                Object result = switch (1) {\n+                                    case 1 -> {\n+                                        yield _;\n+                                    }\n+                                    default -> null;\n+                                };\n+                            }\n+                        }\n+                        \"\"\",\n+                List.of(\"Test.java:5:23: compiler.err.use.of.underscore.not.allowed.non.variable\", \"1 error\")\n+        );\n+\n+        public static FailParams ASSIGNMENT_TO_UNDERSCORE_IN_YIELD = new FailParams(\n+                \"\"\"\n+                        public class Test {\n+                            public static void main(String[] args) {\n+                                Object result = switch (1) {\n+                                    case 1 -> {\n+                                        yield _ = 1;\n+                                    }\n+                                    default -> null;\n+                                };\n+                            }\n+                        }\n+                        \"\"\",\n+                List.of(\"Test.java:5:23: compiler.err.use.of.underscore.not.allowed.non.variable\", \"1 error\")\n+        );\n+    }\n+\n+    @Test\n+    public void testUnderscoreAsParameterNameInLambda_ShouldFailToCompile(List<FailParams> params) throws Exception {\n+        for (var param : params) {\n+            tb.writeJavaFiles(ROOT, param.code);\n+            Task.Result result = new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\")\n+                    .files(tb.findJavaFiles(ROOT))\n+                    .run(Task.Expect.FAIL);\n+            tb.checkEqual(param.expectedDiagnosticMessage, result.getOutputLines(Task.OutputKind.DIRECT));\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchUnderscoreAfterYield.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8333748\n+ * @summary javap should not fail if reserved access flag bits are set to 1\n+ * @library \/tools\/lib\n+ * @modules jdk.jdeps\/com.sun.tools.javap\n+ * @enablePreview\n+ * @run junit UndefinedAccessFlagTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import toolbox.JavapTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class UndefinedAccessFlagTest {\n+\n+    final ToolBox toolBox = new ToolBox();\n+\n+    enum TestLocation {\n+        NONE(false), CLASS, FIELD, METHOD, INNER_CLASS(false);\n+\n+        final boolean fails;\n+        TestLocation() { this(true); }\n+        TestLocation(boolean fails) { this.fails = fails; }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(TestLocation.class)\n+    void test(TestLocation location) throws Throwable {\n+        var cf = of();\n+        ClassModel cm;\n+        try (var is = UndefinedAccessFlagTest.class.getResourceAsStream(\n+            \"\/UndefinedAccessFlagTest$SampleInnerClass.class\"\n+        )) {\n+            cm = cf.parse(is.readAllBytes());\n+        }\n+        var bytes = cf.transform(cm, (cb, ce) -> {\n+            switch (ce) {\n+                case AccessFlags flags when location == TestLocation.CLASS -> cb\n+                    .withFlags(flags.flagsMask() | ACC_PRIVATE);\n+                case FieldModel f when location == TestLocation.FIELD -> cb\n+                    .transformField(f, (fb, fe) -> {\n+                        if (fe instanceof AccessFlags flags) {\n+                            fb.withFlags(flags.flagsMask() | ACC_SYNCHRONIZED);\n+                        } else {\n+                            fb.with(fe);\n+                        }\n+                    });\n+                case MethodModel m when location == TestLocation.METHOD -> cb\n+                    .transformMethod(m, (mb, me) -> {\n+                        if (me instanceof AccessFlags flags) {\n+                            mb.withFlags(flags.flagsMask() | ACC_INTERFACE);\n+                        } else {\n+                            mb.with(me);\n+                        }\n+                    });\n+                case InnerClassesAttribute attr when location == TestLocation.INNER_CLASS -> cb\n+                    .with(InnerClassesAttribute.of(attr.classes().stream()\n+                        .map(ic -> InnerClassInfo.of(ic.innerClass(), ic.outerClass(), ic.innerName(), ic.flagsMask() | 0x0020))\n+                        .toList()));\n+                default -> cb.with(ce);\n+            }\n+        });\n+\n+        Files.write(Path.of(\"transformed.class\"), bytes);\n+\n+        var lines = new JavapTask(toolBox)\n+            .classes(\"transformed.class\")\n+            .options(\"-c\", \"-p\", \"-v\")\n+            .run(location.fails ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        \/\/ No termination when access flag error happens\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"java.lang.String field;\")));\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"UndefinedAccessFlagTest$SampleInnerClass();\")));\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"void method();\")));\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"SampleInnerClass=class UndefinedAccessFlagTest$SampleInnerClass of class UndefinedAccessFlagTest\")));\n+\n+        \/\/ Remove non-error lines\n+        assertTrue(lines.removeIf(st -> !st.startsWith(\"Error:\")));\n+        \/\/ Desired locations has errors\n+        assertTrue(location == TestLocation.NONE || !lines.isEmpty());\n+        \/\/ Access Flag errors only\n+        assertTrue(lines.stream().allMatch(l -> l.contains(\"Access Flags:\")), () -> String.join(\"\\n\", lines));\n+    }\n+\n+    static class SampleInnerClass {\n+        String field;\n+        void method() {}\n+    }\n+}\n","filename":"test\/langtools\/tools\/javap\/UndefinedAccessFlagTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Random;\n@@ -51,0 +52,23 @@\n+    @Param(\"500\")\n+    private int size;\n+\n+    private char[] chars;\n+    private char[] res;\n+\n+    @Setup\n+    public void setup() {\n+        Random r  = new Random(0);\n+        chars     = new char[size];\n+        res       = new char[size];\n+        for (int i = 0; i < size; i++) {\n+            chars[i] = (char)r.nextInt(Character.MAX_VALUE + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void reverseBytes() {\n+        for (int i = 0; i < size; i++) {\n+            res[i] = Character.reverseBytes(chars[i]);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Characters.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+public class Shorts {\n+\n+    @Param(\"500\")\n+    private int size;\n+\n+    private short[] shorts;\n+    private short[] res;\n+\n+    @Setup\n+    public void setup() {\n+        Random r  = new Random(0);\n+        shorts     = new short[size];\n+        res       = new short[size];\n+        for (int i = 0; i < size; i++) {\n+            shorts[i] = (short)(r.nextInt(Character.MAX_VALUE + 1) + Short.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void reverseBytes() {\n+        for (int i = 0; i < size; i++) {\n+            res[i] = Short.reverseBytes(shorts[i]);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Shorts.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -244,11 +244,60 @@\n-    public String toStringCharWithFloat8() {\n-        StringBuilder result = new StringBuilder();\n-        result.append(113.110F);\n-        result.append(156456.36435637F);\n-        result.append(65436434.64632F);\n-        result.append(42654634.64540F);\n-        result.append(63464351.64537F);\n-        result.append(634564.645711F);\n-        result.append(64547.64311F);\n-        result.append(4763456341.64531F);\n-        return result.toString();\n+    public int appendWithFloat8Latin1() {\n+        StringBuilder buf = sbLatin1;\n+        buf.setLength(0);\n+        buf.append(113.110F);\n+        buf.append(156456.36435637F);\n+        buf.append(65436434.64632F);\n+        buf.append(42654634.64540F);\n+        buf.append(63464351.64537F);\n+        buf.append(634564.645711F);\n+        buf.append(64547.64311F);\n+        buf.append(4763456341.64531F);\n+        return buf.length();\n+    }\n+\n+\n+    @Benchmark\n+    public int appendWithFloat8Utf16() {\n+        StringBuilder buf = sbUtf16;\n+        buf.setLength(0);\n+        buf.append(113.110F);\n+        buf.append(156456.36435637F);\n+        buf.append(65436434.64632F);\n+        buf.append(42654634.64540F);\n+        buf.append(63464351.64537F);\n+        buf.append(634564.645711F);\n+        buf.append(64547.64311F);\n+        buf.append(4763456341.64531F);\n+        return buf.length();\n+    }\n+\n+\n+    @Benchmark\n+    public int appendWithDouble8Latin1() {\n+        StringBuilder buf = sbLatin1;\n+        buf.setLength(0);\n+        buf.append(0.3005216476500575D);\n+        buf.append(0.39727691577802204D);\n+        buf.append(0.9869700323149287D);\n+        buf.append(42654634.645403256D);\n+        buf.append(63464351.645371353D);\n+        buf.append(634564.645711246D);\n+        buf.append(64547.6431172363D);\n+        buf.append(4763456341.64531675D);\n+        return buf.length();\n+    }\n+\n+\n+    @Benchmark\n+    public int appendWithDouble8Utf16() {\n+        StringBuilder buf = sbUtf16;\n+        buf.setLength(0);\n+        buf.append(0.3005216476500575D);\n+        buf.append(0.39727691577802204D);\n+        buf.append(0.9869700323149287D);\n+        buf.append(42654634.645403256D);\n+        buf.append(63464351.645371353D);\n+        buf.append(634564.645711246D);\n+        buf.append(64547.6431172363D);\n+        buf.append(4763456341.64531675D);\n+        return buf.length();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringBuilders.java","additions":60,"deletions":11,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.vm.compiler;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.random.RandomGeneratorFactory;\n-import org.openjdk.jmh.annotations.*;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@Fork(value = 1)\n-public class CMove {\n-    static final int SIZE = 1000000;\n-\n-    @Param({\"0.003\", \"0.006\", \"0.01\", \"0.02\", \"0.03\", \"0.06\", \"0.1\", \"0.2\", \"0.3\", \"0.6\"})\n-    double freq;\n-\n-    boolean[] conds;\n-\n-    @Setup(Level.Iteration)\n-    public void setup() {\n-        var r = RandomGeneratorFactory.getDefault().create(1);\n-        conds = new boolean[SIZE];\n-        for (int i = 0; i < SIZE; i++) {\n-            conds[i] = r.nextDouble() < freq;\n-        }\n-    }\n-\n-    @Benchmark\n-    public void run(Blackhole bh) {\n-        for (int i = 0; i < conds.length; i++) {\n-            bh.consume(conds[i] ? 2 : 1);\n-        }\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/CMove.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1)\n+public abstract class VectorLoadToStoreForwarding {\n+    @Param({\"2048\"})\n+    public int SIZE;\n+\n+    private int[] aI;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        aI = new int[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            aI[i] = r.nextInt();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_00() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 0] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_01() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 1] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_02() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 2] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_03() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 3] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_04() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 4] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_05() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 5] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_06() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 6] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_07() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 7] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_08() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 8] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_09() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 9] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_10() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 10] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_11() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 11] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_12() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 12] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_13() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 13] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_14() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 14] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_15() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 15] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_16() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 16] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_17() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 17] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_18() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 18] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_19() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 19] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_20() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 20] + 1;\n+        }\n+    }\n+\n+    @Fork(value = 1, jvmArgsPrepend = {\n+        \"-XX:+UseSuperWord\"\n+    })\n+    public static class VectorLoadToStoreForwardingSuperWord extends VectorLoadToStoreForwarding {}\n+\n+    @Fork(value = 1, jvmArgsPrepend = {\n+        \"-XX:-UseSuperWord\"\n+    })\n+    public static class VectorLoadToStoreForwardingNoSuperWord extends VectorLoadToStoreForwarding {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorLoadToStoreForwarding.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"}]}