{"files":[{"patch":"@@ -19,0 +19,2 @@\n+\/.project\/\n+\/.settings\/\n","filename":".gitignore","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,0 +224,6 @@\n+  # Linux x86_64 needs higher binutils after 8265783\n+  # (this really is a dependency on as version, but we take ld as a check for a general binutils version)\n+  if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\"; then\n+    TOOLCHAIN_MINIMUM_LD_VERSION_gcc=\"2.25\"\n+  fi\n+\n@@ -680,0 +686,1 @@\n+    AC_MSG_NOTICE([comparing linker version to minimum version $TOOLCHAIN_MINIMUM_LD_VERSION])\n@@ -682,1 +689,1 @@\n-          AC_MSG_WARN([You are using a linker older than $TOOLCHAIN_MINIMUM_LD_VERSION. This is not a supported configuration.])\n+          AC_MSG_ERROR([You are using a linker older than $TOOLCHAIN_MINIMUM_LD_VERSION. This is not a supported configuration.])\n","filename":"make\/autoconf\/toolchain.m4","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -186,1 +186,0 @@\n-      biasedLocking.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2441,4 +2441,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -2557,0 +2553,25 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  \/\/ JDK-8183543: When taking the number of available registers as int\n+  \/\/ register pressure threshold, the jtreg test:\n+  \/\/ test\/hotspot\/jtreg\/compiler\/regalloc\/TestC2IntPressure.java\n+  \/\/ failed due to C2 compilation failure with\n+  \/\/ \"COMPILE SKIPPED: failed spill-split-recycle sanity check\".\n+  \/\/\n+  \/\/ A derived pointer is live at CallNode and then is flagged by RA\n+  \/\/ as a spilled LRG. Spilling heuristics(Spill-USE) explicitly skip\n+  \/\/ derived pointers and lastly fail to spill after reaching maximum\n+  \/\/ number of iterations. Lowering the default pressure threshold to\n+  \/\/ (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become\n+  \/\/ a high register pressure area of the code so that split_DEF can\n+  \/\/ generate DefinitionSpillCopy for the derived pointer.\n+  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n+  return (INTPRESSURE == -1) ? default_int_pressure_threshold : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  \/\/ _FLOAT_REG_mask is generated by adlc from the float_reg register class.\n+  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;\n+}\n+\n@@ -3770,4 +3791,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_enter(box, oop, disp_hdr, tmp, true, cont);\n-    }\n-\n@@ -3844,4 +3861,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_exit(oop, tmp, cont);\n-    }\n-\n@@ -8869,5 +8882,0 @@\n-\n-\/\/ storeLConditional is used by PhaseMacroExpand::expand_lock_node\n-\/\/ when attempting to rebias a lock towards the current thread.  We\n-\/\/ must use the acquire form of cmpxchg in order to guarantee acquire\n-\/\/ semantics in this case.\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -3278,2 +3278,0 @@\n-class BiasedLockingCounters;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -364,2 +364,4 @@\n-  __ lea(rscratch2, ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n-  __ incrementw(Address(rscratch2));\n+  if (PrintC1Statistics) {\n+    __ lea(rscratch2, ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n+    __ incrementw(Address(rscratch2));\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2580,4 +2580,0 @@\n-    Register scratch = noreg;\n-    if (UseBiasedLocking) {\n-      scratch = op->scratch_opr()->as_register();\n-    }\n@@ -2586,1 +2582,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -334,5 +334,0 @@\n-  \/\/ Need a scratch register for biased locking\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if (UseBiasedLocking) {\n-    scratch = new_register(T_INT);\n-  }\n@@ -347,1 +342,1 @@\n-  monitor_enter(obj.result(), lock, syncTempOpr(), scratch,\n+  monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -64,1 +63,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register scratch, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -85,5 +84,0 @@\n-  if (UseBiasedLocking) {\n-    assert(scratch != noreg, \"should have scratch register at this point\");\n-    biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &slow_case);\n-  }\n-\n@@ -125,4 +119,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    lea(rscratch2, ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-    addmw(Address(rscratch2, 0), 1, rscratch1);\n-  }\n@@ -139,6 +129,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -150,4 +134,2 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ load object\n+  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n@@ -182,7 +164,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1, t2);\n-    ldr(t1, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t\n-    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t\n+  mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  \/\/ scratch : scratch register, contents destroyed\n@@ -63,1 +62,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register scratch, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                32);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  24);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_globals_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                                thread->get_thread_name(), frame.sp(), nm->verified_entry_point());\n+                                thread->name(), frame.sp(), nm->verified_entry_point());\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -757,4 +756,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, done, &slow_case);\n-    }\n-\n@@ -772,11 +767,1 @@\n-    if (PrintBiasedLockingStatistics) {\n-      Label fast;\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, fast, &fail);\n-      bind(fast);\n-      atomic_incw(Address((address)BiasedLocking::fast_path_entry_count_addr()),\n-                  rscratch2, rscratch1, tmp);\n-      b(done);\n-      bind(fail);\n-    } else {\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, done, \/*fallthrough*\/NULL);\n-    }\n+    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, done, \/*fallthrough*\/NULL);\n@@ -819,6 +804,0 @@\n-\n-    if (PrintBiasedLockingStatistics) {\n-      br(Assembler::NE, slow_case);\n-      atomic_incw(Address((address)BiasedLocking::fast_path_entry_count_addr()),\n-                  rscratch2, rscratch1, tmp);\n-    }\n@@ -875,4 +854,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(obj_reg, header_reg, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -445,172 +444,0 @@\n-void MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                          Register obj_reg,\n-                                          Register swap_reg,\n-                                          Register tmp_reg,\n-                                          bool swap_reg_contains_mark,\n-                                          Label& done,\n-                                          Label* slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(lock_reg, obj_reg, swap_reg);\n-\n-  if (PrintBiasedLockingStatistics && counters == NULL)\n-    counters = BiasedLocking::counters();\n-\n-  assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg, rscratch1, rscratch2, noreg);\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());\n-  Address klass_addr     (obj_reg, oopDesc::klass_offset_in_bytes());\n-  Address saved_mark_addr(lock_reg, 0);\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-  if (!swap_reg_contains_mark) {\n-    ldr(swap_reg, mark_addr);\n-  }\n-  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::NE, cas_label);\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-  load_prototype_header(tmp_reg, obj_reg);\n-  orr(tmp_reg, tmp_reg, rthread);\n-  eor(tmp_reg, swap_reg, tmp_reg);\n-  andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));\n-  if (counters != NULL) {\n-    Label around;\n-    cbnz(tmp_reg, around);\n-    atomic_incw(Address((address)counters->biased_lock_entry_count_addr()), tmp_reg, rscratch1, rscratch2);\n-    b(done);\n-    bind(around);\n-  } else {\n-    cbz(tmp_reg, done);\n-  }\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);\n-  cbnz(rscratch1, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);\n-  cbnz(rscratch1, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  {\n-    Label here;\n-    mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-    andr(swap_reg, swap_reg, rscratch1);\n-    orr(tmp_reg, swap_reg, rthread);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, this means that\n-    \/\/ another thread succeeded in biasing it toward itself and we\n-    \/\/ need to revoke that bias. The revocation will occur in the\n-    \/\/ interpreter runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->anonymously_biased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    orr(tmp_reg, rthread, tmp_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, then another thread\n-    \/\/ succeeded in biasing it toward itself and we need to revoke that\n-    \/\/ bias. The revocation will occur in the runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->rebiased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here, nope;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, &nope);\n-    bind(here);\n-\n-    \/\/ Fall through to the normal CAS-based lock, because no matter what\n-    \/\/ the result of the above CAS, some thread must have succeeded in\n-    \/\/ removing the bias bit from the object's header.\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->revoked_lock_entry_count_addr()), tmp_reg,\n-                  rscratch1, rscratch2);\n-    }\n-    bind(nope);\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  ldr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-  andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-  cmp(temp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::EQ, done);\n-}\n-\n@@ -3838,5 +3665,0 @@\n-void MacroAssembler::load_prototype_header(Register dst, Register src) {\n-  load_klass(dst, src);\n-  ldr(dst, Address(dst, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":178,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -108,14 +108,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg is killed.\n-  \/\/ tmp_reg must be supplied and must not be rscratch1 or rscratch2\n-  \/\/ Optional slow case is for implementations (interpreter and C1) which branch to\n-  \/\/ slow case directly. Leaves condition codes set for C2's Fast_Lock node.\n-  void biased_locking_enter(Register lock_reg, Register obj_reg,\n-                            Register swap_reg, Register tmp_reg,\n-                            bool swap_reg_contains_mark,\n-                            Label& done, Label* slow_case = NULL,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit (Register obj_reg, Register temp_reg, Label& done);\n-\n-\n@@ -850,2 +836,0 @@\n-  void load_prototype_header(Register dst, Register src);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1776,4 +1776,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -1927,5 +1923,0 @@\n-\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, old_hdr, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5686,0 +5686,1 @@\n+   *  c_rarg6   - isMIME\n@@ -5768,6 +5769,7 @@\n-    Register src   = c_rarg0;  \/\/ source array\n-    Register soff  = c_rarg1;  \/\/ source start offset\n-    Register send  = c_rarg2;  \/\/ source end offset\n-    Register dst   = c_rarg3;  \/\/ dest array\n-    Register doff  = c_rarg4;  \/\/ position for writing to dest array\n-    Register isURL = c_rarg5;  \/\/ Base64 or URL character set\n+    Register src    = c_rarg0;  \/\/ source array\n+    Register soff   = c_rarg1;  \/\/ source start offset\n+    Register send   = c_rarg2;  \/\/ source end offset\n+    Register dst    = c_rarg3;  \/\/ dest array\n+    Register doff   = c_rarg4;  \/\/ position for writing to dest array\n+    Register isURL  = c_rarg5;  \/\/ Base64 or URL character set\n+    Register isMIME = c_rarg6;  \/\/ Decoding MIME block - unused in this implementation\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3556,5 +3556,1 @@\n-    if (UseBiasedLocking) {\n-      __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));\n-    } else {\n-      __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n-    }\n+    __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1004,4 +1004,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -1103,0 +1099,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 12 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 30 : FLOATPRESSURE;\n+}\n+\n@@ -5457,1 +5463,0 @@\n-    \/\/ used by biased locking only. Requires a membar.\n@@ -8957,1 +8962,0 @@\n-  predicate(!(UseBiasedLocking && !UseOptoBiasInlining));\n@@ -8969,16 +8973,0 @@\n-instruct cmpFastLock_noBiasInline(flagsRegP pcc, iRegP object, iRegP box, iRegP scratch2,\n-                                  iRegP scratch, iRegP scratch3) %{\n-  match(Set pcc (FastLock object box));\n-  predicate(UseBiasedLocking && !UseOptoBiasInlining);\n-\n-  effect(TEMP scratch, TEMP scratch2, TEMP scratch3);\n-  ins_cost(DEFAULT_COST*5);\n-\n-  format %{ \"FASTLOCK  $object, $box; KILL $scratch, $scratch2, $scratch3\" %}\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register, $scratch$$Register, $scratch2$$Register, $scratch3$$Register);\n-  %}\n-  ins_pipe(long_memory_op);\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":10,"deletions":22,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm_32.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-    __ unlock_object(R2, R1, R0, Rtemp, *stub->entry());\n+    __ unlock_object(R2, R1, R0, *stub->entry());\n@@ -2432,2 +2432,0 @@\n-  Register tmp = op->scratch_opr()->is_illegal() ? noreg :\n-                 op->scratch_opr()->as_pointer_register();\n@@ -2439,1 +2437,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, tmp, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n@@ -2444,1 +2442,1 @@\n-    __ unlock_object(hdr, obj, lock, tmp, *op->stub()->entry());\n+    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -415,8 +415,0 @@\n-  \/\/ Need a scratch register for biased locking on arm\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if(UseBiasedLocking) {\n-    scratch = new_pointer_register();\n-  } else {\n-    scratch = atomicLockOpr();\n-  }\n-\n@@ -429,1 +421,1 @@\n-  monitor_enter(obj.result(), lock, hdr, scratch,\n+  monitor_enter(obj.result(), lock, hdr, LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -93,5 +92,1 @@\n-  if(UseBiasedLocking && !len->is_valid()) {\n-    ldr(tmp, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    mov(tmp, (intptr_t)markWord::prototype().value());\n-  }\n+  mov(tmp, (intptr_t)markWord::prototype().value());\n@@ -190,3 +185,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj,\n-                                   Register disp_hdr, Register tmp1,\n-                                   Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -197,1 +190,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr, tmp1, tmp2);\n+  assert_different_registers(hdr, obj, disp_hdr, tmp2);\n@@ -214,4 +207,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(obj, hdr\/*scratched*\/, tmp1, false, tmp2, done, slow_case);\n-  }\n-\n@@ -237,2 +226,3 @@\n-  \/\/ If 'eq' then OK for recursive fast locking: store 0 into a lock record.\n-  str(tmp2, Address(disp_hdr, mark_offset), eq);\n+  \/\/ If still 'eq' then recursive locking OK\n+  \/\/ set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8267042)\n+  str(tmp2, Address(disp_hdr, mark_offset));\n@@ -251,7 +241,0 @@\n-\n-#ifndef PRODUCT\n-  if (PrintBiasedLockingStatistics) {\n-    cond_atomic_inc32(al, BiasedLocking::fast_path_entry_count_addr());\n-  }\n-#endif \/\/ !PRODUCT\n-\n@@ -263,5 +246,1 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj,\n-                                      Register disp_hdr, Register tmp,\n-                                      Label& slow_case) {\n-  \/\/ Note: this method is not using its 'tmp' argument\n-\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -276,5 +255,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, obj_offset));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n@@ -289,4 +263,2 @@\n-  if(!UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, obj_offset));\n-  }\n+  \/\/ load object\n+  ldr(obj, Address(disp_hdr, obj_offset));\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":9,"deletions":37,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  int lock_object(Register hdr, Register obj, Register disp_hdr, Register tmp, Label& slow_case);\n+  int lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n@@ -64,1 +64,1 @@\n-  void unlock_object(Register hdr, Register obj, Register disp_hdr, Register tmp, Label& slow_case);\n+  void unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-void C2_MacroAssembler::fast_lock(Register Roop, Register Rbox, Register Rscratch, Register Rscratch2, Register scratch3) {\n+void C2_MacroAssembler::fast_lock(Register Roop, Register Rbox, Register Rscratch, Register Rscratch2) {\n@@ -100,8 +100,0 @@\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    assert(scratch3 != noreg, \"need extra temporary for -XX:-UseOptoBiasInlining\");\n-    biased_locking_enter(Roop, Rmark, Rscratch, false, scratch3, done, done);\n-    \/\/ Fall through if lock not biased otherwise branch to done\n-  }\n-\n-  \/\/ Invariant: Rmark loaded below does not contain biased lock pattern\n-\n@@ -151,4 +143,0 @@\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_exit(Roop, Rscratch, done);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  void fast_lock(Register obj, Register box, Register scratch, Register scratch2, Register scratch3 = noreg);\n+  void fast_lock(Register obj, Register box, Register scratch, Register scratch2);\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                30);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  12);\n","filename":"src\/hotspot\/cpu\/arm\/c2_globals_arm.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -893,5 +892,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(Robj, Rmark\/*scratched*\/, R0, false, Rtemp, done, slow_case);\n-    }\n-\n-\n@@ -915,6 +909,0 @@\n-#ifndef PRODUCT\n-    if (PrintBiasedLockingStatistics) {\n-      cond_atomic_inc32(al, BiasedLocking::fast_path_entry_count_addr());\n-    }\n-#endif \/\/!PRODUCT\n-\n@@ -965,7 +953,0 @@\n-\n-#ifndef PRODUCT\n-    if (PrintBiasedLockingStatistics) {\n-      cond_atomic_inc32(eq, BiasedLocking::fast_path_entry_count_addr());\n-    }\n-#endif \/\/ !PRODUCT\n-\n@@ -1013,4 +994,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(Robj, Rmark, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1291,215 +1290,0 @@\n-\n-\/\/ Building block for CAS cases of biased locking: makes CAS and records statistics.\n-\/\/ The slow_case label is used to transfer control if CAS fails. Otherwise leaves condition codes set.\n-void MacroAssembler::biased_locking_enter_with_cas(Register obj_reg, Register old_mark_reg, Register new_mark_reg,\n-                                                 Register tmp, Label& slow_case, int* counter_addr) {\n-\n-  cas_for_lock_acquire(old_mark_reg, new_mark_reg, obj_reg, tmp, slow_case);\n-#ifdef ASSERT\n-  breakpoint(ne); \/\/ Fallthrough only on success\n-#endif\n-#ifndef PRODUCT\n-  if (counter_addr != NULL) {\n-    cond_atomic_inc32(al, counter_addr);\n-  }\n-#endif \/\/ !PRODUCT\n-}\n-\n-void MacroAssembler::biased_locking_enter(Register obj_reg, Register swap_reg, Register tmp_reg,\n-                                          bool swap_reg_contains_mark,\n-                                          Register tmp2,\n-                                          Label& done, Label& slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  \/\/ obj_reg must be preserved (at least) if the bias locking fails\n-  \/\/ tmp_reg is a temporary register\n-  \/\/ swap_reg was used as a temporary but contained a value\n-  \/\/   that was used afterwards in some call pathes. Callers\n-  \/\/   have been fixed so that swap_reg no longer needs to be\n-  \/\/   saved.\n-  \/\/ Rtemp in no longer scratched\n-\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(obj_reg, swap_reg, tmp_reg, tmp2);\n-  guarantee(swap_reg!=tmp_reg, \"invariant\");\n-  assert(tmp_reg != noreg, \"must supply tmp_reg\");\n-\n-#ifndef PRODUCT\n-  if (PrintBiasedLockingStatistics && (counters == NULL)) {\n-    counters = BiasedLocking::counters();\n-  }\n-#endif\n-\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr(obj_reg, oopDesc::mark_offset_in_bytes());\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-\n-  if (!swap_reg_contains_mark) {\n-    ldr(swap_reg, mark_addr);\n-  }\n-\n-  \/\/ On MP platform loads could return 'stale' values in some cases.\n-  \/\/ That is acceptable since either CAS or slow case path is taken in the worst case.\n-\n-  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markWord::biased_lock_pattern);\n-\n-  b(cas_label, ne);\n-\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-  load_klass(tmp_reg, obj_reg);\n-  ldr(tmp_reg, Address(tmp_reg, Klass::prototype_header_offset()));\n-  orr(tmp_reg, tmp_reg, Rthread);\n-  eor(tmp_reg, tmp_reg, swap_reg);\n-\n-  bics(tmp_reg, tmp_reg, ((int) markWord::age_mask_in_place));\n-\n-#ifndef PRODUCT\n-  if (counters != NULL) {\n-    cond_atomic_inc32(eq, counters->biased_lock_entry_count_addr());\n-  }\n-#endif \/\/ !PRODUCT\n-\n-  b(done, eq);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  tst(tmp_reg, markWord::biased_lock_mask_in_place);\n-  b(try_revoke_bias, ne);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  tst(tmp_reg, markWord::epoch_mask_in_place);\n-  b(try_rebias, ne);\n-\n-  \/\/ tmp_reg has the age, epoch and pattern bits cleared\n-  \/\/ The remaining (owner) bits are (Thread ^ current_owner)\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-\n-  \/\/ Note that we know the owner is not ourself. Hence, success can\n-  \/\/ only happen when the owner bits is 0\n-\n-  \/\/ until the assembler can be made smarter, we need to make some assumptions about the values\n-  \/\/ so we can optimize this:\n-  assert((markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place) == 0x1ff, \"biased bitmasks changed\");\n-\n-  mov(swap_reg, AsmOperand(swap_reg, lsl, 23));\n-  mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); \/\/ markWord with thread bits cleared (for CAS)\n-\n-  orr(tmp_reg, swap_reg, Rthread); \/\/ new mark\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,\n-        (counters != NULL) ? counters->anonymously_biased_lock_entry_count_addr() : NULL);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  b(done);\n-\n-  bind(try_rebias);\n-\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-\n-  \/\/ tmp_reg low (not owner) bits are (age: 0 | pattern&epoch: prototype^swap_reg)\n-\n-  eor(tmp_reg, tmp_reg, swap_reg); \/\/ OK except for owner bits (age preserved !)\n-\n-  \/\/ owner bits 'random'. Set them to Rthread.\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsl, 23));\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsr, 23));\n-\n-  orr(tmp_reg, tmp_reg, Rthread); \/\/ new mark\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,\n-        (counters != NULL) ? counters->rebiased_lock_entry_count_addr() : NULL);\n-\n-  \/\/ If the biasing toward our thread failed, then another thread\n-  \/\/ succeeded in biasing it toward itself and we need to revoke that\n-  \/\/ bias. The revocation will occur in the runtime in the slow case.\n-\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-\n-  \/\/ tmp_reg low (not owner) bits are (age: 0 | pattern&epoch: prototype^swap_reg)\n-\n-  eor(tmp_reg, tmp_reg, swap_reg); \/\/ OK except for owner bits (age preserved !)\n-\n-  \/\/ owner bits 'random'. Clear them\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsl, 23));\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsr, 23));\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, cas_label,\n-        (counters != NULL) ? counters->revoked_lock_entry_count_addr() : NULL);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-\n-  bind(cas_label);\n-}\n-\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register tmp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  ldr(tmp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-  andr(tmp_reg, tmp_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markWord::biased_lock_pattern);\n-  b(done, eq);\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":0,"deletions":216,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-class BiasedLockingCounters;\n-\n@@ -362,23 +360,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg must be supplied.\n-  \/\/ tmp_reg must be supplied.\n-  \/\/ Done label is branched to with condition code EQ set if the lock is\n-  \/\/ biased and we acquired it. Slow case label is branched to with\n-  \/\/ condition code NE set if the lock is biased but we failed to acquire\n-  \/\/ it. Otherwise fall through.\n-  \/\/ Notes:\n-  \/\/ - swap_reg and tmp_reg are scratched\n-  \/\/ - Rtemp was (implicitly) scratched and can now be specified as the tmp2\n-  void biased_locking_enter(Register obj_reg, Register swap_reg, Register tmp_reg,\n-                            bool swap_reg_contains_mark,\n-                            Register tmp2,\n-                            Label& done, Label& slow_case,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit(Register obj_reg, Register temp_reg, Label& done);\n-\n-  \/\/ Building block for CAS cases of biased locking: makes CAS and records statistics.\n-  \/\/ Optional slow_case label is used to transfer control if CAS fails. Otherwise leaves condition codes set.\n-  void biased_locking_enter_with_cas(Register obj_reg, Register old_mark_reg, Register new_mark_reg,\n-                                     Register tmp, Label& slow_case, int* counter_addr);\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -865,5 +865,0 @@\n-    if (UseBiasedLocking) {\n-      assert(is_power_of_2(markWord::biased_lock_bit_in_place), \"adjust this code\");\n-      __ tbnz(Rtemp, exact_log2(markWord::biased_lock_bit_in_place), slow_case);\n-    }\n-\n@@ -1154,1 +1149,1 @@\n-  Label slow_lock, slow_lock_biased, lock_done, fast_lock;\n+  Label slow_lock, lock_done, fast_lock;\n@@ -1161,4 +1156,0 @@\n-    if(UseBiasedLocking) {\n-      __ biased_locking_enter(sync_obj, tmp, disp_hdr\/*scratched*\/, false, Rtemp, lock_done, slow_lock_biased);\n-    }\n-\n@@ -1183,2 +1174,3 @@\n-    \/\/ If still 'eq' then recursive locking OK: set displaced header to 0\n-    __ str(Rtemp, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()), eq);\n+    \/\/ If still 'eq' then recursive locking OK\n+    \/\/ set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8267042)\n+    __ str(Rtemp, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));\n@@ -1245,6 +1237,0 @@\n-    if(UseBiasedLocking) {\n-      __ biased_locking_exit(sync_obj, Rtemp, unlock_done);\n-      \/\/ disp_hdr may not have been saved on entry with biased locking\n-      __ sub(disp_hdr, FP, lock_slot_fp_offset);\n-    }\n-\n@@ -1306,5 +1292,0 @@\n-    if(UseBiasedLocking) {\n-      __ bind(slow_lock_biased);\n-      __ sub(disp_hdr, FP, lock_slot_fp_offset);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":4,"deletions":23,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3970,5 +3970,1 @@\n-    if (UseBiasedLocking) {\n-      __ ldr(Rtemp, Address(Rklass, Klass::prototype_header_offset()));\n-    } else {\n-      __ mov_slow(Rtemp, (intptr_t)markWord::prototype().value());\n-    }\n+    __ mov_slow(Rtemp, (intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,2 +97,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -351,13 +351,0 @@\n-\n-bool VM_Version::use_biased_locking() {\n-  get_os_cpu_info();\n-  \/\/ The cost of CAS on uniprocessor ARM v6 and later is low compared to the\n-  \/\/ overhead related to slightly longer Biased Locking execution path.\n-  \/\/ Testing shows no improvement when running with Biased Locking enabled\n-  \/\/ on an ARMv6 and higher uniprocessor systems.  The situation is different on\n-  \/\/ ARMv5 and MP systems.\n-  \/\/\n-  \/\/ Therefore the Biased Locking is enabled on ARMv5 and ARM MP only.\n-  \/\/\n-  return (!os::is_MP() && (arm_arch() > 5)) ? false : true;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -494,6 +494,8 @@\n-  const address counter = (address)&Runtime1::_arraycopy_slowcase_cnt;\n-  const Register tmp = R3, tmp2 = R4;\n-  int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);\n-  __ lwz(tmp2, simm16_offs, tmp);\n-  __ addi(tmp2, tmp2, 1);\n-  __ stw(tmp2, simm16_offs, tmp);\n+  if (PrintC1Statistics) {\n+    const address counter = (address)&Runtime1::_arraycopy_slowcase_cnt;\n+    const Register tmp = R3, tmp2 = R4;\n+    int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);\n+    __ lwz(tmp2, simm16_offs, tmp);\n+    __ addi(tmp2, tmp2, 1);\n+    __ stw(tmp2, simm16_offs, tmp);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -118,4 +117,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(CCR0, Roop, Rmark, Rscratch, R0, done, &slow_int);\n-  }\n-\n@@ -167,6 +162,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Load the object out of the BasicObjectLock.\n-    ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n-    verify_oop(Roop, FILE_AND_LINE);\n-    biased_locking_exit(CCR0, Roop, R0, done);\n-  }\n@@ -177,5 +166,4 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ Load object.\n-    ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n-    verify_oop(Roop, FILE_AND_LINE);\n-  }\n+\n+  \/\/ Load object.\n+  ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n+  verify_oop(Roop, FILE_AND_LINE);\n@@ -225,5 +213,1 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    ld(t1, in_bytes(Klass::prototype_header_offset()), klass);\n-  } else {\n-    load_const_optimized(t1, (intx)markWord::prototype().value());\n-  }\n+  load_const_optimized(t1, (intx)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                28);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  26);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_globals_ppc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -946,4 +946,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(CCR0, object, displaced_header, tmp, current_header, done, &slow_case);\n-    }\n-\n@@ -1051,7 +1047,0 @@\n-    if (UseBiasedLocking) {\n-      \/\/ The object address from the monitor is in object.\n-      ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor);\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-      biased_locking_exit(CCR0, object, displaced_header, free_slot);\n-    }\n-\n@@ -1073,1 +1062,1 @@\n-    if (!UseBiasedLocking) { ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor); }\n+    ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -2076,212 +2075,0 @@\n-\/\/ Supports temp2_reg = R0.\n-void MacroAssembler::biased_locking_enter(ConditionRegister cr_reg, Register obj_reg,\n-                                          Register mark_reg, Register temp_reg,\n-                                          Register temp2_reg, Label& done, Label* slow_case) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-#ifdef ASSERT\n-  assert_different_registers(obj_reg, mark_reg, temp_reg, temp2_reg);\n-#endif\n-\n-  Label cas_label;\n-\n-  \/\/ Branch to done if fast path fails and no slow_case provided.\n-  Label *slow_case_int = (slow_case != NULL) ? slow_case : &done;\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n-         \"biased locking makes assumptions about bit layout\");\n-\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::total_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-\n-  andi(temp_reg, mark_reg, markWord::biased_lock_mask_in_place);\n-  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n-  bne(cr_reg, cas_label);\n-\n-  load_klass(temp_reg, obj_reg);\n-\n-  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  orr(temp_reg, R16_thread, temp_reg);\n-  xorr(temp_reg, mark_reg, temp_reg);\n-  andr(temp_reg, temp_reg, temp2_reg);\n-  cmpdi(cr_reg, temp_reg, 0);\n-  if (PrintBiasedLockingStatistics) {\n-    Label l;\n-    bne(cr_reg, l);\n-    load_const(temp2_reg, (address) BiasedLocking::biased_lock_entry_count_addr());\n-    lwzx(mark_reg, temp2_reg);\n-    addi(mark_reg, mark_reg, 1);\n-    stwx(mark_reg, temp2_reg);\n-    \/\/ restore mark_reg\n-    ld(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-    bind(l);\n-  }\n-  beq(cr_reg, done);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  andi(temp2_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-  cmpwi(cr_reg, temp2_reg, 0);\n-  bne(cr_reg, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-\n-  int shift_amount = 64 - markWord::epoch_shift;\n-  \/\/ rotate epoch bits to right (little) end and set other bits to 0\n-  \/\/ [ big part | epoch | little part ] -> [ 0..0 | epoch ]\n-  rldicl_(temp2_reg, temp_reg, shift_amount, 64 - markWord::epoch_bits);\n-  \/\/ branch if epoch bits are != 0, i.e. they differ, because the epoch has been incremented\n-  bne(CCR0, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  andi(mark_reg, mark_reg, (markWord::biased_lock_mask_in_place |\n-                                markWord::age_mask_in_place |\n-                                markWord::epoch_mask_in_place));\n-  orr(temp_reg, R16_thread, mark_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ CmpxchgX sets cr_reg to cmpX(temp2_reg, mark_reg).\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-           \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-           \/*where=*\/obj_reg,\n-           MacroAssembler::MemBarAcq,\n-           MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-           noreg, slow_case_int); \/\/ bail out if failed\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::anonymously_biased_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-  b(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  load_klass(temp_reg, obj_reg);\n-  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n-  orr(temp2_reg, R16_thread, temp2_reg);\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  orr(temp_reg, temp2_reg, temp_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-                 \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-                 \/*where=*\/obj_reg,\n-                 MacroAssembler::MemBarAcq,\n-                 MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-                 noreg, slow_case_int); \/\/ bail out if failed\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::rebiased_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  load_klass(temp_reg, obj_reg);\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n-  orr(temp_reg, temp_reg, temp2_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ CmpxchgX sets cr_reg to cmpX(temp2_reg, mark_reg).\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-                 \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-                 \/*where=*\/obj_reg,\n-                 MacroAssembler::MemBarAcq,\n-                 MacroAssembler::cmpxchgx_hint_acquire_lock());\n-\n-  \/\/ reload markWord in mark_reg before continuing with lightweight locking\n-  ld(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (PrintBiasedLockingStatistics) {\n-    Label l;\n-    bne(cr_reg, l);\n-    load_const(temp2_reg, (address) BiasedLocking::revoked_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-    bind(l);\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit (ConditionRegister cr_reg, Register mark_addr, Register temp_reg, Label& done) {\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-\n-  ld(temp_reg, 0, mark_addr);\n-  andi(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-\n-  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n-  beq(cr_reg, done);\n-}\n-\n@@ -2698,1 +2485,0 @@\n-  assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -2705,1 +2491,1 @@\n-  andi_(R0, mark_word, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  andi_(R0, mark_word, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral\n@@ -2723,4 +2509,4 @@\n-  ld(mark_word, oopDesc::mark_offset_in_bytes(), obj);      \/\/ Reload in transaction, conflicts need to be tracked.\n-  andi(R0, mark_word, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpwi(flag, R0, markWord::unlocked_value);                \/\/ bits = 001 unlocked\n-  beq(flag, DONE_LABEL);                                    \/\/ all done if unlocked\n+  ld(mark_word, oopDesc::mark_offset_in_bytes(), obj);   \/\/ Reload in transaction, conflicts need to be tracked.\n+  andi(R0, mark_word, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+  cmpwi(flag, R0, markWord::unlocked_value);             \/\/ bits = 01 unlocked\n+  beq(flag, DONE_LABEL);                                 \/\/ all done if unlocked\n@@ -2840,1 +2626,0 @@\n-                                               bool try_bias,\n@@ -2861,4 +2646,0 @@\n-  if (try_bias) {\n-    biased_locking_enter(flag, oop, displaced_header, temp, current_header, cont);\n-  }\n-\n@@ -2967,1 +2748,1 @@\n-                                                 bool try_bias, bool use_rtm) {\n+                                                 bool use_rtm) {\n@@ -2973,4 +2754,0 @@\n-  if (try_bias) {\n-    biased_locking_exit(flag, oop, current_header, cont);\n-  }\n-\n@@ -2979,1 +2756,0 @@\n-    assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -2981,6 +2757,6 @@\n-    ld(current_header, oopDesc::mark_offset_in_bytes(), oop);      \/\/ fetch markword\n-    andi(R0, current_header, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-    cmpwi(flag, R0, markWord::unlocked_value);                     \/\/ bits = 001 unlocked\n-    bne(flag, L_regular_unlock);                                   \/\/ else RegularLock\n-    tend_();                                                       \/\/ otherwise end...\n-    b(cont);                                                       \/\/ ... and we're done\n+    ld(current_header, oopDesc::mark_offset_in_bytes(), oop);   \/\/ fetch markword\n+    andi(R0, current_header, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+    cmpwi(flag, R0, markWord::unlocked_value);                  \/\/ bits = 01 unlocked\n+    bne(flag, L_regular_unlock);                                \/\/ else RegularLock\n+    tend_();                                                    \/\/ otherwise end...\n+    b(cont);                                                    \/\/ ... and we're done\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":12,"deletions":236,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -592,18 +592,0 @@\n-  \/\/ Biased locking support\n-  \/\/ Upon entry,obj_reg must contain the target object, and mark_reg\n-  \/\/ must contain the target object's header.\n-  \/\/ Destroys mark_reg if an attempt is made to bias an anonymously\n-  \/\/ biased lock. In this case a failure will go either to the slow\n-  \/\/ case or fall through with the notEqual condition code set with\n-  \/\/ the expectation that the slow case in the runtime will be called.\n-  \/\/ In the fall-through case where the CAS-based lock is done,\n-  \/\/ mark_reg is not destroyed.\n-  void biased_locking_enter(ConditionRegister cr_reg, Register obj_reg, Register mark_reg, Register temp_reg,\n-                            Register temp2_reg, Label& done, Label* slow_case = NULL);\n-  \/\/ Upon entry, the base register of mark_addr must contain the oop.\n-  \/\/ Destroys temp_reg.\n-  \/\/ If allow_delay_slot_filling is set to true, the next instruction\n-  \/\/ emitted after this one will go in an annulled delay slot if the\n-  \/\/ biased locking exit case failed.\n-  void biased_locking_exit(ConditionRegister cr_reg, Register mark_addr, Register temp_reg, Label& done);\n-\n@@ -658,1 +640,0 @@\n-                                 bool try_bias = UseBiasedLocking,\n@@ -666,1 +647,1 @@\n-                                   bool try_bias = UseBiasedLocking, bool use_rtm = false);\n+                                   bool use_rtm = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2196,4 +2196,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -2366,0 +2362,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 26 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 28 : FLOATPRESSURE;\n+}\n+\n@@ -12120,2 +12126,1 @@\n-                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0,\n-                                 UseBiasedLocking && !UseOptoBiasInlining);\n+                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0);\n@@ -12139,1 +12144,0 @@\n-                                 \/*Biased Locking*\/ false,\n@@ -12142,1 +12146,1 @@\n-                                 \/*TM*\/ true, ra_->C->profile_rtm());\n+                                 \/*RTM*\/ true, ra_->C->profile_rtm());\n@@ -12159,1 +12163,0 @@\n-                                   UseBiasedLocking && !UseOptoBiasInlining,\n@@ -12177,1 +12180,1 @@\n-                                   \/*Biased Locking*\/ false, \/*TM*\/ true);\n+                                   \/*RTM*\/ true);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2157,8 +2157,0 @@\n-#   ifdef ASSERT\n-    if (UseBiasedLocking) {\n-      \/\/ Making the box point to itself will make it clear it went unused\n-      \/\/ but also be obviously invalid.\n-      __ std(r_box, 0, r_box);\n-    }\n-#   endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3760,0 +3760,1 @@\n+    Register isMIME = R9_ARG7; \/\/ boolean, if non-zero indicates use of RFC 2045 MIME encoding - not used\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3796,5 +3796,1 @@\n-    if (UseBiasedLocking) {\n-      __ ld(Rscratch, in_bytes(Klass::prototype_header_offset()), RinstanceKlass);\n-    } else {\n-      __ load_const_optimized(Rscratch, markWord::prototype().value(), R0);\n-    }\n+    __ load_const_optimized(Rscratch, markWord::prototype().value(), R0);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -381,5 +381,1 @@\n-    \/\/ If CPU or OS do not support TM:\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n-    \/\/ VM_Version_init() is executed after UseBiasedLocking is used\n-    \/\/ in Thread::allocate().\n+    \/\/ If CPU or OS do not support RTM:\n@@ -402,2 +398,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n@@ -547,21 +541,0 @@\n-bool VM_Version::use_biased_locking() {\n-#if INCLUDE_RTM_OPT\n-  \/\/ RTM locking is most useful when there is high lock contention and\n-  \/\/ low data contention. With high lock contention the lock is usually\n-  \/\/ inflated and biased locking is not suitable for that case.\n-  \/\/ RTM locking code requires that biased locking is off.\n-  \/\/ Note: we can't switch off UseBiasedLocking in get_processor_features()\n-  \/\/ because it is used by Thread::allocate() which is called before\n-  \/\/ VM_Version::initialize().\n-  if (UseRTMLocking && UseBiasedLocking) {\n-    if (FLAG_IS_DEFAULT(UseBiasedLocking)) {\n-      FLAG_SET_DEFAULT(UseBiasedLocking, false);\n-    } else {\n-      warning(\"Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.\" );\n-      UseBiasedLocking = false;\n-    }\n-  }\n-#endif\n-  return UseBiasedLocking;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -96,3 +96,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -457,2 +457,4 @@\n-  __ load_const_optimized(Z_R1_scratch, (address)&Runtime1::_arraycopy_slowcase_cnt);\n-  __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);\n+  if (PrintC1Statistics) {\n+    __ load_const_optimized(Z_R1_scratch, (address)&Runtime1::_arraycopy_slowcase_cnt);\n+    __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -100,4 +99,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(obj, hdr, Z_R1_scratch, Z_R0_scratch, done, &slow_case);\n-  }\n-\n@@ -113,7 +108,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Unimplemented();\n-#if 0\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-#endif\n-  }\n@@ -153,6 +141,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Load object.\n-    z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -163,4 +145,2 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ Load object.\n-    z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ Load object.\n+  z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n@@ -196,7 +176,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1);\n-    z_lg(t1, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t.\n-    load_const_optimized(t1, (intx)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t.\n+  load_const_optimized(t1, (intx)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                15);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  10); \/\/ Medium size register set, 6 special purpose regs, 3 SOE regs.\n","filename":"src\/hotspot\/cpu\/s390\/c2_globals_s390.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1008,4 +1007,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(object, displaced_header, Z_R1, Z_R0, done, &slow_case);\n-  }\n-\n@@ -1119,6 +1114,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ The object address from the monitor is in object.\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-    biased_locking_exit(object, displaced_header, done);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -3131,188 +3130,1 @@\n-\/\/ Semantics are dependent on the slow_case label:\n-\/\/   If the slow_case label is not NULL, failure to biased-lock the object\n-\/\/   transfers control to the location of the slow_case label. If the\n-\/\/   object could be biased-locked, control is transferred to the done label.\n-\/\/   The condition code is unpredictable.\n-\/\/\n-\/\/   If the slow_case label is NULL, failure to biased-lock the object results\n-\/\/   in a transfer of control to the done label with a condition code of not_equal.\n-\/\/   If the biased-lock could be successfully obtained, control is transfered to\n-\/\/   the done label with a condition code of equal.\n-\/\/   It is mandatory to react on the condition code At the done label.\n-\/\/\n-void MacroAssembler::biased_locking_enter(Register  obj_reg,\n-                                          Register  mark_reg,\n-                                          Register  temp_reg,\n-                                          Register  temp2_reg,    \/\/ May be Z_RO!\n-                                          Label    &done,\n-                                          Label    *slow_case) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(obj_reg, mark_reg, temp_reg, temp2_reg);\n-\n-  Label cas_label; \/\/ Try, if implemented, CAS locking. Fall thru to slow path otherwise.\n-\n-  BLOCK_COMMENT(\"biased_locking_enter {\");\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid.\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits.\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n-         \"biased locking makes assumptions about bit layout\");\n-  z_lr(temp_reg, mark_reg);\n-  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n-  z_chi(temp_reg, markWord::biased_lock_pattern);\n-  z_brne(cas_label);  \/\/ Try cas if object is not biased, i.e. cannot be biased locked.\n-\n-  load_prototype_header(temp_reg, obj_reg);\n-  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n-\n-  z_ogr(temp_reg, Z_thread);\n-  z_xgr(temp_reg, mark_reg);\n-  z_ngr(temp_reg, temp2_reg);\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::biased_lock_entry_count_addr(), mark_reg, temp2_reg);\n-    \/\/ Restore mark_reg.\n-    z_lg(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-  }\n-  branch_optimized(Assembler::bcondEqual, done);  \/\/ Biased lock obtained, return success.\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-  Address mark_addr = Address(obj_reg, oopDesc::mark_offset_in_bytes());\n-\n-  \/\/----------------------------------------------------------------------------\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  z_tmll(temp_reg, markWord::biased_lock_mask_in_place);\n-  z_brnaz(try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  z_tmll(temp_reg, markWord::epoch_mask_in_place);\n-  z_brnaz(try_rebias);\n-\n-  \/\/----------------------------------------------------------------------------\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place |\n-         markWord::epoch_mask_in_place);\n-  z_lgr(temp_reg, Z_thread);\n-  z_llgfr(mark_reg, mark_reg);\n-  z_ogr(temp_reg, mark_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::anonymously_biased_lock_entry_count_addr(),\n-                         temp_reg, temp2_reg);\n-  }\n-  if (slow_case != NULL) {\n-    branch_optimized(Assembler::bcondNotEqual, *slow_case); \/\/ Biased lock not obtained, need to go the long way.\n-  }\n-  branch_optimized(Assembler::bcondAlways, done);           \/\/ Biased lock status given in condition code.\n-\n-  \/\/----------------------------------------------------------------------------\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-\n-  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-  load_prototype_header(temp_reg, obj_reg);\n-  z_llgfr(mark_reg, mark_reg);\n-\n-  z_ogr(temp_reg, Z_thread);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::rebiased_lock_entry_count_addr(), temp_reg, temp2_reg);\n-  }\n-  if (slow_case != NULL) {\n-    branch_optimized(Assembler::bcondNotEqual, *slow_case);  \/\/ Biased lock not obtained, need to go the long way.\n-  }\n-  z_bru(done);           \/\/ Biased lock status given in condition code.\n-\n-  \/\/----------------------------------------------------------------------------\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  load_prototype_header(temp_reg, obj_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (PrintBiasedLockingStatistics) {\n-    \/\/ z_cgr(mark_reg, temp2_reg);\n-    increment_counter_eq((address) BiasedLocking::revoked_lock_entry_count_addr(), temp_reg, temp2_reg);\n-  }\n-\n-  bind(cas_label);\n-  BLOCK_COMMENT(\"} biased_locking_enter\");\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register mark_addr, Register temp_reg, Label& done) {\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  BLOCK_COMMENT(\"biased_locking_exit {\");\n-\n-  z_lg(temp_reg, 0, mark_addr);\n-  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n-\n-  z_chi(temp_reg, markWord::biased_lock_pattern);\n-  z_bre(done);\n-  BLOCK_COMMENT(\"} biased_locking_exit\");\n-}\n-\n-void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {\n+void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2) {\n@@ -3337,4 +3149,0 @@\n-  if (try_bias) {\n-    biased_locking_enter(oop, displacedHeader, temp, Z_R0, done);\n-  }\n-\n@@ -3405,1 +3213,1 @@\n-void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {\n+void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2) {\n@@ -3415,4 +3223,0 @@\n-  if (try_bias) {\n-    biased_locking_exit(oop, currentHeader, done);\n-  }\n-\n@@ -3836,6 +3640,0 @@\n-void MacroAssembler::load_prototype_header(Register Rheader, Register Rsrc_oop) {\n-  assert_different_registers(Rheader, Rsrc_oop);\n-  load_klass(Rheader, Rsrc_oop);\n-  z_lg(Rheader, Address(Rheader, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":2,"deletions":204,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -721,20 +721,3 @@\n-  \/\/ Biased locking support\n-  \/\/ Upon entry,obj_reg must contain the target object, and mark_reg\n-  \/\/ must contain the target object's header.\n-  \/\/ Destroys mark_reg if an attempt is made to bias an anonymously\n-  \/\/ biased lock. In this case a failure will go either to the slow\n-  \/\/ case or fall through with the notEqual condition code set with\n-  \/\/ the expectation that the slow case in the runtime will be called.\n-  \/\/ In the fall-through case where the CAS-based lock is done,\n-  \/\/ mark_reg is not destroyed.\n-  void biased_locking_enter(Register obj_reg, Register mark_reg, Register temp_reg,\n-                            Register temp2_reg, Label& done, Label* slow_case = NULL);\n-  \/\/ Upon entry, the base register of mark_addr must contain the oop.\n-  \/\/ Destroys temp_reg.\n-  \/\/ If allow_delay_slot_filling is set to true, the next instruction\n-  \/\/ emitted after this one will go in an annulled delay slot if the\n-  \/\/ biased locking exit case failed.\n-  void biased_locking_exit(Register mark_addr, Register temp_reg, Label& done);\n-\n-  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias = UseBiasedLocking);\n-  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias = UseBiasedLocking);\n+\n+  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2);\n+  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2);\n@@ -785,1 +768,0 @@\n-  void load_prototype_header(Register Rheader, Register Rsrc_oop);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1557,4 +1557,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -1668,0 +1664,11 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  \/\/ Medium size register set, 6 special purpose regs, 3 SOE regs.\n+  return (INTPRESSURE == -1) ? 10 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 15 : FLOATPRESSURE;\n+}\n+\n@@ -9812,2 +9819,1 @@\n-  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,\n-                                             UseBiasedLocking && !UseOptoBiasInlining); %}\n+  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n@@ -9821,1 +9827,1 @@\n-  \/\/ TODO: s390 port size(FIXED_SIZE);  \/\/ emitted code depends on UseBiasedLocking being on\/off.\n+  \/\/ TODO: s390 port size(FIXED_SIZE);\n@@ -9823,2 +9829,1 @@\n-  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,\n-                                               UseBiasedLocking && !UseOptoBiasInlining); %}\n+  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1876,7 +1876,0 @@\n-#ifdef ASSERT\n-    if (UseBiasedLocking)\n-      \/\/ Making the box point to itself will make it clear it went unused\n-      \/\/ but also be obviously invalid.\n-      __ z_stg(r_box, 0, r_box);\n-#endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3816,8 +3816,2 @@\n-    if (UseBiasedLocking) {\n-      Register prototype = RobjectFields;\n-      __ z_lg(prototype, Address(iklass, Klass::prototype_header_offset()));\n-      __ z_stg(prototype, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));\n-    } else {\n-      __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),\n-                     (long)markWord::prototype().value());\n-    }\n+    __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),\n+                   (long)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -3833,0 +3832,8 @@\n+void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x7D, (0xC0 | encode));\n+}\n+\n@@ -4552,0 +4559,9 @@\n+void Assembler::vpmaddubsw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {\n+assert(vector_len == AVX_128bit? VM_Version::supports_avx() :\n+       vector_len == AVX_256bit? VM_Version::supports_avx2() :\n+       vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = simd_prefix_and_encode(dst, src1, src2, VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x04, (0xC0 | encode));\n+}\n+\n@@ -4860,0 +4876,9 @@\n+void Assembler::evptestmb(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.66.0F.W0 DB \/r\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x26, (0xC0 | encode));\n+}\n+\n@@ -9407,0 +9432,7 @@\n+void Assembler::shrxl(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF7, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-class BiasedLockingCounters;\n-\n@@ -1702,0 +1700,1 @@\n+  void evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1815,0 +1814,2 @@\n+  void vpmaddubsw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+\n@@ -1882,0 +1883,2 @@\n+  void evptestmb(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+\n@@ -2143,0 +2146,1 @@\n+  void shrxl(Register dst, Register src1, Register src2);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -546,1 +546,3 @@\n-  __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n+  if (PrintC1Statistics) {\n+    __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3515,4 +3515,0 @@\n-    Register scratch = noreg;\n-    if (UseBiasedLocking) {\n-      scratch = op->scratch_opr()->as_register();\n-    }\n@@ -3521,1 +3517,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -291,5 +291,0 @@\n-  \/\/ Need a scratch register for biased locking on x86\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if (UseBiasedLocking) {\n-    scratch = new_register(T_INT);\n-  }\n@@ -304,1 +299,1 @@\n-  monitor_enter(obj.result(), lock, syncTempOpr(), scratch,\n+  monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -41,1 +40,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register scratch, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -64,5 +63,0 @@\n-  if (UseBiasedLocking) {\n-    assert(scratch != noreg, \"should have scratch register at this point\");\n-    biased_locking_enter(disp_hdr, obj, hdr, scratch, rklass_decode_tmp, false, done, &slow_case);\n-  }\n-\n@@ -81,4 +75,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-  }\n@@ -119,6 +109,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -131,4 +115,3 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ load object\n-    movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ load object\n+  movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+\n@@ -162,8 +145,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1, t2);\n-    movptr(t1, Address(klass, Klass::prototype_header_offset()));\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t\n+  movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  \/\/ scratch : scratch register, contents destroyed\n@@ -54,1 +53,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register scratch, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -237,1 +236,0 @@\n-  assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -247,1 +245,1 @@\n-  testptr(tmpReg, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  testptr(tmpReg, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral\n@@ -262,2 +260,2 @@\n-  andptr(tmpReg, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpptr(tmpReg, markWord::unlocked_value);            \/\/ bits = 001 unlocked\n+  andptr(tmpReg, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+  cmpptr(tmpReg, markWord::unlocked_value);         \/\/ bits = 01 unlocked\n@@ -450,1 +448,0 @@\n-                                 BiasedLockingCounters* counters,\n@@ -465,4 +462,0 @@\n-  if (counters != NULL) {\n-    atomic_incl(ExternalAddress((address)counters->total_entry_count_addr()), scrReg);\n-  }\n-\n@@ -476,3 +469,0 @@\n-  \/\/ * biased\n-  \/\/    -- by Self\n-  \/\/    -- by other\n@@ -496,10 +486,0 @@\n-  \/\/ it's stack-locked, biased or neutral\n-  \/\/ TODO: optimize away redundant LDs of obj->mark and improve the markword triage\n-  \/\/ order to reduce the number of conditional branches in the most common cases.\n-  \/\/ Beware -- there's a subtle invariant that fetch of the markword\n-  \/\/ at [FETCH], below, will never observe a biased encoding (*101b).\n-  \/\/ If this invariant is not held we risk exclusion (safety) failure.\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_enter(boxReg, objReg, tmpReg, scrReg, cx1Reg, false, DONE_LABEL, NULL, counters);\n-  }\n-\n@@ -515,1 +495,1 @@\n-  testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral|biased\n+  testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral\n@@ -523,4 +503,0 @@\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)counters->fast_path_entry_count_addr()));\n-  }\n@@ -536,4 +512,0 @@\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)counters->fast_path_entry_count_addr()));\n-  }\n@@ -662,6 +634,0 @@\n-  \/\/ Critically, the biased locking test must have precedence over\n-  \/\/ and appear before the (box->dhw == 0) recursive stack-lock test.\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_exit(objReg, tmpReg, DONE_LABEL);\n-  }\n-\n@@ -670,1 +636,0 @@\n-    assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -673,2 +638,2 @@\n-    andptr(tmpReg, markWord::biased_lock_mask_in_place);              \/\/ look at 3 lock bits\n-    cmpptr(tmpReg, markWord::unlocked_value);                         \/\/ bits = 001 unlocked\n+    andptr(tmpReg, markWord::lock_mask_in_place);                     \/\/ look at 2 lock bits\n+    cmpptr(tmpReg, markWord::unlocked_value);                         \/\/ bits = 01 unlocked\n@@ -741,1 +706,1 @@\n-  \/\/ It's not inflated and it's not recursively stack-locked and it's not biased.\n+  \/\/ It's not inflated and it's not recursively stack-locked.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":7,"deletions":42,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-                 BiasedLockingCounters* counters,\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-define_pd_global(intx,  INTPRESSURE,                 13);\n-define_pd_global(intx,  FLOATPRESSURE,               14);\n@@ -61,2 +59,0 @@\n-define_pd_global(intx,  INTPRESSURE,                 6);\n-define_pd_global(intx,  FLOATPRESSURE,               6);\n","filename":"src\/hotspot\/cpu\/x86\/c2_globals_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-                               jth->get_thread_name(), callers_rsp, nm->verified_entry_point());\n+                               jth->name(), callers_rsp, nm->verified_entry_point());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1208,2 +1207,1 @@\n-    const Register tmp_reg = rbx; \/\/ Will be passed to biased_locking_enter to avoid a\n-                                  \/\/ problematic case where tmp_reg = no_reg.\n+    const Register tmp_reg = rbx;\n@@ -1230,4 +1228,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, rklass_decode_tmp, false, done, &slow_case);\n-    }\n-\n@@ -1248,4 +1242,0 @@\n-    if (PrintBiasedLockingStatistics) {\n-      cond_inc32(Assembler::zero,\n-                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n-    }\n@@ -1288,5 +1278,0 @@\n-\n-    if (PrintBiasedLockingStatistics) {\n-      cond_inc32(Assembler::zero,\n-                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n-    }\n@@ -1344,4 +1329,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(obj_reg, header_reg, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1283,194 +1282,0 @@\n-void MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                          Register obj_reg,\n-                                          Register swap_reg,\n-                                          Register tmp_reg,\n-                                          Register tmp_reg2,\n-                                          bool swap_reg_contains_mark,\n-                                          Label& done,\n-                                          Label* slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert(swap_reg == rax, \"swap_reg must be rax for cmpxchgq\");\n-  assert(tmp_reg != noreg, \"tmp_reg must be supplied\");\n-  assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());\n-  NOT_LP64( Address saved_mark_addr(lock_reg, 0); )\n-\n-  if (PrintBiasedLockingStatistics && counters == NULL) {\n-    counters = BiasedLocking::counters();\n-  }\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-  if (!swap_reg_contains_mark) {\n-    movptr(swap_reg, mark_addr);\n-  }\n-  movptr(tmp_reg, swap_reg);\n-  andptr(tmp_reg, markWord::biased_lock_mask_in_place);\n-  cmpptr(tmp_reg, markWord::biased_lock_pattern);\n-  jcc(Assembler::notEqual, cas_label);\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-#ifndef _LP64\n-  \/\/ Note that because there is no current thread register on x86_32 we\n-  \/\/ need to store off the mark word we read out of the object to\n-  \/\/ avoid reloading it and needing to recheck invariants below. This\n-  \/\/ store is unfortunate but it makes the overall code shorter and\n-  \/\/ simpler.\n-  movptr(saved_mark_addr, swap_reg);\n-#endif\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-#ifdef _LP64\n-  orptr(tmp_reg, r15_thread);\n-  xorptr(tmp_reg, swap_reg);\n-  Register header_reg = tmp_reg;\n-#else\n-  xorptr(tmp_reg, swap_reg);\n-  get_thread(swap_reg);\n-  xorptr(swap_reg, tmp_reg);\n-  Register header_reg = swap_reg;\n-#endif\n-  andptr(header_reg, ~((int) markWord::age_mask_in_place));\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->biased_lock_entry_count_addr()));\n-  }\n-  jcc(Assembler::equal, done);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  testptr(header_reg, markWord::biased_lock_mask_in_place);\n-  jcc(Assembler::notZero, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  testptr(header_reg, markWord::epoch_mask_in_place);\n-  jccb(Assembler::notZero, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  NOT_LP64( movptr(swap_reg, saved_mark_addr); )\n-  andptr(swap_reg,\n-         markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-#ifdef _LP64\n-  movptr(tmp_reg, swap_reg);\n-  orptr(tmp_reg, r15_thread);\n-#else\n-  get_thread(tmp_reg);\n-  orptr(tmp_reg, swap_reg);\n-#endif\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->anonymously_biased_lock_entry_count_addr()));\n-  }\n-  if (slow_case != NULL) {\n-    jcc(Assembler::notZero, *slow_case);\n-  }\n-  jmp(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-#ifdef _LP64\n-  orptr(tmp_reg, r15_thread);\n-#else\n-  get_thread(swap_reg);\n-  orptr(tmp_reg, swap_reg);\n-  movptr(swap_reg, saved_mark_addr);\n-#endif\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ If the biasing toward our thread failed, then another thread\n-  \/\/ succeeded in biasing it toward itself and we need to revoke that\n-  \/\/ bias. The revocation will occur in the runtime in the slow case.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->rebiased_lock_entry_count_addr()));\n-  }\n-  if (slow_case != NULL) {\n-    jcc(Assembler::notZero, *slow_case);\n-  }\n-  jmp(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  NOT_LP64( movptr(swap_reg, saved_mark_addr); )\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->revoked_lock_entry_count_addr()));\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-  andptr(temp_reg, markWord::biased_lock_mask_in_place);\n-  cmpptr(temp_reg, markWord::biased_lock_pattern);\n-  jcc(Assembler::equal, done);\n-}\n-\n@@ -4735,5 +4540,0 @@\n-void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {\n-  load_klass(dst, src, tmp);\n-  movptr(dst, Address(dst, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":200,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -359,2 +359,0 @@\n-  void load_prototype_header(Register dst, Register src, Register tmp);\n-\n@@ -676,15 +674,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg must be rax, and is killed.\n-  \/\/ tmp_reg is optional. If it is supplied (i.e., != noreg) it will\n-  \/\/ be killed; if not supplied, push\/pop will be used internally to\n-  \/\/ allocate a temporary (inefficient, avoid if possible).\n-  \/\/ Optional slow case is for implementations (interpreter and C1) which branch to\n-  \/\/ slow case directly. Leaves condition codes set for C2's Fast_Lock node.\n-  void biased_locking_enter(Register lock_reg, Register obj_reg,\n-                            Register swap_reg, Register tmp_reg,\n-                            Register tmp_reg2, bool swap_reg_contains_mark,\n-                            Label& done, Label* slow_case = NULL,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit (Register obj_reg, Register temp_reg, Label& done);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,6 +65,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Check if biased and fall through to runtime if so\n-    __ testptr(result, markWord::biased_lock_bit_in_place);\n-    __ jcc(Assembler::notZero, slowCase);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1826,5 +1826,0 @@\n-    if (UseBiasedLocking) {\n-      \/\/ Note that oop_handle_reg is trashed during this call\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, oop_handle_reg, noreg, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -1863,5 +1858,0 @@\n-\n-    if (UseBiasedLocking) {\n-      \/\/ Re-fetch oop_handle_reg as we trashed it above\n-      __ movptr(oop_handle_reg, Address(rsp, wordSize));\n-    }\n@@ -1996,4 +1986,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, rbx, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2073,4 +2073,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, rscratch2, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -2227,5 +2223,0 @@\n-\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, old_hdr, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5685,0 +5685,644 @@\n+  \/\/ base64 AVX512vbmi tables\n+  address base64_vbmi_lookup_lo_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x3f8080803e808080, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0x8080808080803d3c, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_lookup_hi_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x0605040302010080, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x8080808080191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1a80, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0x8080808080333231, relocInfo::none);\n+    return start;\n+  }\n+  address base64_vbmi_lookup_lo_url_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64url\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x80803e8080808080, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0x8080808080803d3c, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_lookup_hi_url_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64url\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x0605040302010080, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x3f80808080191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1a80, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0x8080808080333231, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_pack_vec_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"pack_vec_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x090a040506000102, relocInfo::none);\n+    __ emit_data64(0x161011120c0d0e08, relocInfo::none);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_0_1_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_0_1_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x090a040506000102, relocInfo::none);\n+    __ emit_data64(0x161011120c0d0e08, relocInfo::none);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_1_2_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_1_2_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    __ emit_data64(0x5c5d5e58595a5455, relocInfo::none);\n+    __ emit_data64(0x696a646566606162, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_2_3_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_2_3_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    __ emit_data64(0x5c5d5e58595a5455, relocInfo::none);\n+    __ emit_data64(0x696a646566606162, relocInfo::none);\n+    __ emit_data64(0x767071726c6d6e68, relocInfo::none);\n+    __ emit_data64(0x7c7d7e78797a7475, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_decoding_table_addr() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"decoding_table_base64\");\n+    address start = __ pc();\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0x3fffffff3effffff, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0xffffffffffff3d3c, relocInfo::none);\n+    __ emit_data64(0x06050403020100ff, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0xffffffffff191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1aff, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0xffffffffff333231, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+\n+    \/\/ URL table\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffff3effffffffff, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0xffffffffffff3d3c, relocInfo::none);\n+    __ emit_data64(0x06050403020100ff, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x3fffffffff191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1aff, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0xffffffffff333231, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    return start;\n+  }\n+\n+\n+\/\/ Code for generating Base64 decoding.\n+\/\/\n+\/\/ Based on the article (and associated code) from https:\/\/arxiv.org\/abs\/1910.05109.\n+\/\/\n+\/\/ Intrinsic function prototype in Base64.java:\n+\/\/ private void decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, isMIME) {\n+  address generate_base64_decodeBlock() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"implDecode\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    \/\/ Save callee-saved registers before using them\n+    __ push(r12);\n+    __ push(r13);\n+    __ push(r14);\n+    __ push(r15);\n+    __ push(rbx);\n+\n+    \/\/ arguments\n+    const Register source = c_rarg0; \/\/ Source Array\n+    const Register start_offset = c_rarg1; \/\/ start offset\n+    const Register end_offset = c_rarg2; \/\/ end offset\n+    const Register dest = c_rarg3; \/\/ destination array\n+    const Register isMIME = rbx;\n+\n+#ifndef _WIN64\n+    const Register dp = c_rarg4;  \/\/ Position for writing to dest array\n+    const Register isURL = c_rarg5;\/\/ Base64 or URL character set\n+    __ movl(isMIME, Address(rbp, 2 * wordSize));\n+#else\n+    const Address  dp_mem(rbp, 6 * wordSize);  \/\/ length is on stack on Win64\n+    const Address isURL_mem(rbp, 7 * wordSize);\n+    const Register isURL = r10;      \/\/ pick the volatile windows register\n+    const Register dp = r12;\n+    __ movl(dp, dp_mem);\n+    __ movl(isURL, isURL_mem);\n+    __ movl(isMIME, Address(rbp, 8 * wordSize));\n+#endif\n+\n+    const XMMRegister lookup_lo = xmm5;\n+    const XMMRegister lookup_hi = xmm6;\n+    const XMMRegister errorvec = xmm7;\n+    const XMMRegister pack16_op = xmm9;\n+    const XMMRegister pack32_op = xmm8;\n+    const XMMRegister input0 = xmm3;\n+    const XMMRegister input1 = xmm20;\n+    const XMMRegister input2 = xmm21;\n+    const XMMRegister input3 = xmm19;\n+    const XMMRegister join01 = xmm12;\n+    const XMMRegister join12 = xmm11;\n+    const XMMRegister join23 = xmm10;\n+    const XMMRegister translated0 = xmm2;\n+    const XMMRegister translated1 = xmm1;\n+    const XMMRegister translated2 = xmm0;\n+    const XMMRegister translated3 = xmm4;\n+\n+    const XMMRegister merged0 = xmm2;\n+    const XMMRegister merged1 = xmm1;\n+    const XMMRegister merged2 = xmm0;\n+    const XMMRegister merged3 = xmm4;\n+    const XMMRegister merge_ab_bc0 = xmm2;\n+    const XMMRegister merge_ab_bc1 = xmm1;\n+    const XMMRegister merge_ab_bc2 = xmm0;\n+    const XMMRegister merge_ab_bc3 = xmm4;\n+\n+    const XMMRegister pack24bits = xmm4;\n+\n+    const Register length = r14;\n+    const Register output_size = r13;\n+    const Register output_mask = r15;\n+    const KRegister input_mask = k1;\n+\n+    const XMMRegister input_initial_valid_b64 = xmm0;\n+    const XMMRegister tmp = xmm10;\n+    const XMMRegister mask = xmm0;\n+    const XMMRegister invalid_b64 = xmm1;\n+\n+    Label L_process256, L_process64, L_process64Loop, L_exit, L_processdata, L_loadURL;\n+    Label L_continue, L_finalBit, L_padding, L_donePadding, L_bruteForce;\n+    Label L_forceLoop, L_bottomLoop, L_checkMIME, L_exit_no_vzero;\n+\n+    \/\/ calculate length from offsets\n+    __ movl(length, end_offset);\n+    __ subl(length, start_offset);\n+    __ push(dest);          \/\/ Save for return value calc\n+\n+    \/\/ If AVX512 VBMI not supported, just compile non-AVX code\n+    if(VM_Version::supports_avx512_vbmi() &&\n+       VM_Version::supports_avx512bw()) {\n+      __ cmpl(length, 128);     \/\/ 128-bytes is break-even for AVX-512\n+      __ jcc(Assembler::lessEqual, L_bruteForce);\n+\n+      __ cmpl(isMIME, 0);\n+      __ jcc(Assembler::notEqual, L_bruteForce);\n+\n+      \/\/ Load lookup tables based on isURL\n+      __ cmpl(isURL, 0);\n+      __ jcc(Assembler::notZero, L_loadURL);\n+\n+      __ evmovdquq(lookup_lo, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_lo_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(lookup_hi, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_hi_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ BIND(L_continue);\n+\n+      __ movl(r15, 0x01400140);\n+      __ evpbroadcastd(pack16_op, r15, Assembler::AVX_512bit);\n+\n+      __ movl(r15, 0x00011000);\n+      __ evpbroadcastd(pack32_op, r15, Assembler::AVX_512bit);\n+\n+      __ cmpl(length, 0xff);\n+      __ jcc(Assembler::lessEqual, L_process64);\n+\n+      \/\/ load masks required for decoding data\n+      __ BIND(L_processdata);\n+      __ evmovdquq(join01, ExternalAddress(StubRoutines::x86::base64_vbmi_join_0_1_addr()), Assembler::AVX_512bit,r13);\n+      __ evmovdquq(join12, ExternalAddress(StubRoutines::x86::base64_vbmi_join_1_2_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(join23, ExternalAddress(StubRoutines::x86::base64_vbmi_join_2_3_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ align(32);\n+      __ BIND(L_process256);\n+      \/\/ Grab input data\n+      __ evmovdquq(input0, Address(source, start_offset, Address::times_1, 0x00), Assembler::AVX_512bit);\n+      __ evmovdquq(input1, Address(source, start_offset, Address::times_1, 0x40), Assembler::AVX_512bit);\n+      __ evmovdquq(input2, Address(source, start_offset, Address::times_1, 0x80), Assembler::AVX_512bit);\n+      __ evmovdquq(input3, Address(source, start_offset, Address::times_1, 0xc0), Assembler::AVX_512bit);\n+\n+      \/\/ Copy the low part of the lookup table into the destination of the permutation\n+      __ evmovdquq(translated0, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated1, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated2, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated3, lookup_lo, Assembler::AVX_512bit);\n+\n+      \/\/ Translate the base64 input into \"decoded\" bytes\n+      __ evpermt2b(translated0, input0, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated1, input1, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated2, input2, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated3, input3, lookup_hi, Assembler::AVX_512bit);\n+\n+      \/\/ OR all of the translations together to check for errors (high-order bit of byte set)\n+      __ vpternlogd(input0, 0xfe, input1, input2, Assembler::AVX_512bit);\n+\n+      __ vpternlogd(input3, 0xfe, translated0, translated1, Assembler::AVX_512bit);\n+      __ vpternlogd(input0, 0xfe, translated1, translated2, Assembler::AVX_512bit);\n+      __ vpor(errorvec, input3, input0, Assembler::AVX_512bit);\n+\n+      \/\/ Check if there was an error - if so, try 64-byte chunks\n+      __ evpmovb2m(k3, errorvec, Assembler::AVX_512bit);\n+      __ kortestql(k3, k3);\n+      __ jcc(Assembler::notZero, L_process64);\n+\n+      \/\/ The merging and shuffling happens here\n+      \/\/ We multiply each byte pair [00dddddd | 00cccccc | 00bbbbbb | 00aaaaaa]\n+      \/\/ Multiply [00cccccc] by 2^6 added to [00dddddd] to get [0000cccc | ccdddddd]\n+      \/\/ The pack16_op is a vector of 0x01400140, so multiply D by 1 and C by 0x40\n+      __ vpmaddubsw(merge_ab_bc0, translated0, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc1, translated1, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc2, translated2, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc3, translated3, pack16_op, Assembler::AVX_512bit);\n+\n+      \/\/ Now do the same with packed 16-bit values.\n+      \/\/ We start with [0000cccc | ccdddddd | 0000aaaa | aabbbbbb]\n+      \/\/ pack32_op is 0x00011000 (2^12, 1), so this multiplies [0000aaaa | aabbbbbb] by 2^12\n+      \/\/ and adds [0000cccc | ccdddddd] to yield [00000000 | aaaaaabb | bbbbcccc | ccdddddd]\n+      __ vpmaddwd(merged0, merge_ab_bc0, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged1, merge_ab_bc1, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged2, merge_ab_bc2, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged3, merge_ab_bc3, pack32_op, Assembler::AVX_512bit);\n+\n+      \/\/ The join vectors specify which byte from which vector goes into the outputs\n+      \/\/ One of every 4 bytes in the extended vector is zero, so we pack them into their\n+      \/\/ final positions in the register for storing (256 bytes in, 192 bytes out)\n+      __ evpermt2b(merged0, join01, merged1, Assembler::AVX_512bit);\n+      __ evpermt2b(merged1, join12, merged2, Assembler::AVX_512bit);\n+      __ evpermt2b(merged2, join23, merged3, Assembler::AVX_512bit);\n+\n+      \/\/ Store result\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x00), merged0, Assembler::AVX_512bit);\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x40), merged1, Assembler::AVX_512bit);\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x80), merged2, Assembler::AVX_512bit);\n+\n+      __ addptr(source, 0x100);\n+      __ addptr(dest, 0xc0);\n+      __ subl(length, 0x100);\n+      __ cmpl(length, 64 * 4);\n+      __ jcc(Assembler::greaterEqual, L_process256);\n+\n+      \/\/ At this point, we've decoded 64 * 4 * n bytes.\n+      \/\/ The remaining length will be <= 64 * 4 - 1.\n+      \/\/ UNLESS there was an error decoding the first 256-byte chunk.  In this\n+      \/\/ case, the length will be arbitrarily long.\n+      \/\/\n+      \/\/ Note that this will be the path for MIME-encoded strings.\n+\n+      __ BIND(L_process64);\n+\n+      __ evmovdquq(pack24bits, ExternalAddress(StubRoutines::x86::base64_vbmi_pack_vec_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ cmpl(length, 63);\n+      __ jcc(Assembler::lessEqual, L_finalBit);\n+\n+      __ align(32);\n+      __ BIND(L_process64Loop);\n+\n+      \/\/ Handle first 64-byte block\n+\n+      __ evmovdquq(input0, Address(source, start_offset), Assembler::AVX_512bit);\n+      __ evmovdquq(translated0, lookup_lo, Assembler::AVX_512bit);\n+      __ evpermt2b(translated0, input0, lookup_hi, Assembler::AVX_512bit);\n+\n+      __ vpor(errorvec, translated0, input0, Assembler::AVX_512bit);\n+\n+      \/\/ Check for error and bomb out before updating dest\n+      __ evpmovb2m(k3, errorvec, Assembler::AVX_512bit);\n+      __ kortestql(k3, k3);\n+      __ jcc(Assembler::notZero, L_exit);\n+\n+      \/\/ Pack output register, selecting correct byte ordering\n+      __ vpmaddubsw(merge_ab_bc0, translated0, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged0, merge_ab_bc0, pack32_op, Assembler::AVX_512bit);\n+      __ vpermb(merged0, pack24bits, merged0, Assembler::AVX_512bit);\n+\n+      __ evmovdquq(Address(dest, dp), merged0, Assembler::AVX_512bit);\n+\n+      __ subl(length, 64);\n+      __ addptr(source, 64);\n+      __ addptr(dest, 48);\n+\n+      __ cmpl(length, 64);\n+      __ jcc(Assembler::greaterEqual, L_process64Loop);\n+\n+      __ cmpl(length, 0);\n+      __ jcc(Assembler::lessEqual, L_exit);\n+\n+      __ BIND(L_finalBit);\n+      \/\/ Now have 1 to 63 bytes left to decode\n+\n+      \/\/ I was going to let Java take care of the final fragment\n+      \/\/ however it will repeatedly call this routine for every 4 bytes\n+      \/\/ of input data, so handle the rest here.\n+      __ movq(rax, -1);\n+      __ bzhiq(rax, rax, length);    \/\/ Input mask in rax\n+\n+      __ movl(output_size, length);\n+      __ shrl(output_size, 2);   \/\/ Find (len \/ 4) * 3 (output length)\n+      __ lea(output_size, Address(output_size, output_size, Address::times_2, 0));\n+      \/\/ output_size in r13\n+\n+      \/\/ Strip pad characters, if any, and adjust length and mask\n+      __ cmpb(Address(source, length, Address::times_1, -1), '=');\n+      __ jcc(Assembler::equal, L_padding);\n+\n+      __ BIND(L_donePadding);\n+\n+      \/\/ Output size is (64 - output_size), output mask is (all 1s >> output_size).\n+      __ kmovql(input_mask, rax);\n+      __ movq(output_mask, -1);\n+      __ bzhiq(output_mask, output_mask, output_size);\n+\n+      \/\/ Load initial input with all valid base64 characters.  Will be used\n+      \/\/ in merging source bytes to avoid masking when determining if an error occurred.\n+      __ movl(rax, 0x61616161);\n+      __ evpbroadcastd(input_initial_valid_b64, rax, Assembler::AVX_512bit);\n+\n+      \/\/ A register containing all invalid base64 decoded values\n+      __ movl(rax, 0x80808080);\n+      __ evpbroadcastd(invalid_b64, rax, Assembler::AVX_512bit);\n+\n+      \/\/ input_mask is in k1\n+      \/\/ output_size is in r13\n+      \/\/ output_mask is in r15\n+      \/\/ zmm0 - free\n+      \/\/ zmm1 - 0x00011000\n+      \/\/ zmm2 - 0x01400140\n+      \/\/ zmm3 - errorvec\n+      \/\/ zmm4 - pack vector\n+      \/\/ zmm5 - lookup_lo\n+      \/\/ zmm6 - lookup_hi\n+      \/\/ zmm7 - errorvec\n+      \/\/ zmm8 - 0x61616161\n+      \/\/ zmm9 - 0x80808080\n+\n+      \/\/ Load only the bytes from source, merging into our \"fully-valid\" register\n+      __ evmovdqub(input_initial_valid_b64, input_mask, Address(source, start_offset, Address::times_1, 0x0), true, Assembler::AVX_512bit);\n+\n+      \/\/ Decode all bytes within our merged input\n+      __ evmovdquq(tmp, lookup_lo, Assembler::AVX_512bit);\n+      __ evpermt2b(tmp, input_initial_valid_b64, lookup_hi, Assembler::AVX_512bit);\n+      __ vporq(mask, tmp, input_initial_valid_b64, Assembler::AVX_512bit);\n+\n+      \/\/ Check for error.  Compare (decoded | initial) to all invalid.\n+      \/\/ If any bytes have their high-order bit set, then we have an error.\n+      __ evptestmb(k2, mask, invalid_b64, Assembler::AVX_512bit);\n+      __ kortestql(k2, k2);\n+\n+      \/\/ If we have an error, use the brute force loop to decode what we can (4-byte chunks).\n+      __ jcc(Assembler::notZero, L_bruteForce);\n+\n+      \/\/ Shuffle output bytes\n+      __ vpmaddubsw(tmp, tmp, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(tmp, tmp, pack32_op, Assembler::AVX_512bit);\n+\n+      __ vpermb(tmp, pack24bits, tmp, Assembler::AVX_512bit);\n+      __ kmovql(k1, output_mask);\n+      __ evmovdqub(Address(dest, dp), k1, tmp, true, Assembler::AVX_512bit);\n+\n+      __ addptr(dest, output_size);\n+\n+      __ BIND(L_exit);\n+      __ vzeroupper();\n+      __ pop(rax);             \/\/ Get original dest value\n+      __ subptr(dest, rax);      \/\/ Number of bytes converted\n+      __ movptr(rax, dest);\n+      __ pop(rbx);\n+      __ pop(r15);\n+      __ pop(r14);\n+      __ pop(r13);\n+      __ pop(r12);\n+      __ leave();\n+      __ ret(0);\n+\n+      __ BIND(L_loadURL);\n+      __ evmovdquq(lookup_lo, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_lo_url_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(lookup_hi, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_hi_url_addr()), Assembler::AVX_512bit, r13);\n+      __ jmp(L_continue);\n+\n+      __ BIND(L_padding);\n+      __ decrementq(output_size, 1);\n+      __ shrq(rax, 1);\n+\n+      __ cmpb(Address(source, length, Address::times_1, -2), '=');\n+      __ jcc(Assembler::notEqual, L_donePadding);\n+\n+      __ decrementq(output_size, 1);\n+      __ shrq(rax, 1);\n+      __ jmp(L_donePadding);\n+\n+      __ align(32);\n+      __ BIND(L_bruteForce);\n+    }   \/\/ End of if(avx512_vbmi)\n+\n+    \/\/ Use non-AVX code to decode 4-byte chunks into 3 bytes of output\n+\n+    \/\/ Register state (Linux):\n+    \/\/ r12-15 - saved on stack\n+    \/\/ rdi - src\n+    \/\/ rsi - sp\n+    \/\/ rdx - sl\n+    \/\/ rcx - dst\n+    \/\/ r8 - dp\n+    \/\/ r9 - isURL\n+\n+    \/\/ Register state (Windows):\n+    \/\/ r12-15 - saved on stack\n+    \/\/ rcx - src\n+    \/\/ rdx - sp\n+    \/\/ r8 - sl\n+    \/\/ r9 - dst\n+    \/\/ r12 - dp\n+    \/\/ r10 - isURL\n+\n+    \/\/ Registers (common):\n+    \/\/ length (r14) - bytes in src\n+\n+    const Register decode_table = r11;\n+    const Register out_byte_count = rbx;\n+    const Register byte1 = r13;\n+    const Register byte2 = r15;\n+    const Register byte3 = WINDOWS_ONLY(r8) NOT_WINDOWS(rdx);\n+    const Register byte4 = WINDOWS_ONLY(r10) NOT_WINDOWS(r9);\n+\n+    __ shrl(length, 2);    \/\/ Multiple of 4 bytes only - length is # 4-byte chunks\n+    __ cmpl(length, 0);\n+    __ jcc(Assembler::lessEqual, L_exit_no_vzero);\n+\n+    __ shll(isURL, 8);    \/\/ index into decode table based on isURL\n+    __ lea(decode_table, ExternalAddress(StubRoutines::x86::base64_decoding_table_addr()));\n+    __ addptr(decode_table, isURL);\n+\n+    __ jmp(L_bottomLoop);\n+\n+    __ align(32);\n+    __ BIND(L_forceLoop);\n+    __ shll(byte1, 18);\n+    __ shll(byte2, 12);\n+    __ shll(byte3, 6);\n+    __ orl(byte1, byte2);\n+    __ orl(byte1, byte3);\n+    __ orl(byte1, byte4);\n+\n+    __ addptr(source, 4);\n+\n+    __ movb(Address(dest, dp, Address::times_1, 2), byte1);\n+    __ shrl(byte1, 8);\n+    __ movb(Address(dest, dp, Address::times_1, 1), byte1);\n+    __ shrl(byte1, 8);\n+    __ movb(Address(dest, dp, Address::times_1, 0), byte1);\n+\n+    __ addptr(dest, 3);\n+    __ decrementl(length, 1);\n+    __ jcc(Assembler::zero, L_exit_no_vzero);\n+\n+    __ BIND(L_bottomLoop);\n+    __ load_unsigned_byte(byte1, Address(source, start_offset, Address::times_1, 0x00));\n+    __ load_unsigned_byte(byte2, Address(source, start_offset, Address::times_1, 0x01));\n+    __ load_signed_byte(byte1, Address(decode_table, byte1));\n+    __ load_signed_byte(byte2, Address(decode_table, byte2));\n+    __ load_unsigned_byte(byte3, Address(source, start_offset, Address::times_1, 0x02));\n+    __ load_unsigned_byte(byte4, Address(source, start_offset, Address::times_1, 0x03));\n+    __ load_signed_byte(byte3, Address(decode_table, byte3));\n+    __ load_signed_byte(byte4, Address(decode_table, byte4));\n+\n+    __ mov(rax, byte1);\n+    __ orl(rax, byte2);\n+    __ orl(rax, byte3);\n+    __ orl(rax, byte4);\n+    __ jcc(Assembler::positive, L_forceLoop);\n+\n+    __ BIND(L_exit_no_vzero);\n+    __ pop(rax);             \/\/ Get original dest value\n+    __ subptr(dest, rax);      \/\/ Number of bytes converted\n+    __ movptr(rax, dest);\n+    __ pop(rbx);\n+    __ pop(r15);\n+    __ pop(r14);\n+    __ pop(r13);\n+    __ pop(r12);\n+    __ leave();\n+    __ ret(0);\n+\n+    return start;\n+  }\n+\n+\n@@ -6971,0 +7615,13 @@\n+      if(VM_Version::supports_avx512_vbmi() &&\n+         VM_Version::supports_avx512bw()) {\n+        StubRoutines::x86::_lookup_lo_base64 = base64_vbmi_lookup_lo_addr();\n+        StubRoutines::x86::_lookup_hi_base64 = base64_vbmi_lookup_hi_addr();\n+        StubRoutines::x86::_lookup_lo_base64url = base64_vbmi_lookup_lo_url_addr();\n+        StubRoutines::x86::_lookup_hi_base64url = base64_vbmi_lookup_hi_url_addr();\n+        StubRoutines::x86::_pack_vec_base64 = base64_vbmi_pack_vec_addr();\n+        StubRoutines::x86::_join_0_1_base64 = base64_vbmi_join_0_1_addr();\n+        StubRoutines::x86::_join_1_2_base64 = base64_vbmi_join_1_2_addr();\n+        StubRoutines::x86::_join_2_3_base64 = base64_vbmi_join_2_3_addr();\n+      }\n+      StubRoutines::x86::_decoding_table_base64 = base64_decoding_table_addr();\n+      StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":657,"deletions":0,"binary":false,"changes":657,"status":"modified"},{"patch":"@@ -76,0 +76,9 @@\n+address StubRoutines::x86::_lookup_lo_base64 = NULL;\n+address StubRoutines::x86::_lookup_hi_base64 = NULL;\n+address StubRoutines::x86::_lookup_lo_base64url = NULL;\n+address StubRoutines::x86::_lookup_hi_base64url = NULL;\n+address StubRoutines::x86::_pack_vec_base64 = NULL;\n+address StubRoutines::x86::_join_0_1_base64 = NULL;\n+address StubRoutines::x86::_join_1_2_base64 = NULL;\n+address StubRoutines::x86::_join_2_3_base64 = NULL;\n+address StubRoutines::x86::_decoding_table_base64 = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -194,0 +194,9 @@\n+  static address _lookup_lo_base64;\n+  static address _lookup_hi_base64;\n+  static address _lookup_lo_base64url;\n+  static address _lookup_hi_base64url;\n+  static address _pack_vec_base64;\n+  static address _join_0_1_base64;\n+  static address _join_1_2_base64;\n+  static address _join_2_3_base64;\n+  static address _decoding_table_base64;\n@@ -339,0 +348,9 @@\n+  static address base64_vbmi_lookup_lo_addr() { return _lookup_lo_base64; }\n+  static address base64_vbmi_lookup_hi_addr() { return _lookup_hi_base64; }\n+  static address base64_vbmi_lookup_lo_url_addr() { return _lookup_lo_base64url; }\n+  static address base64_vbmi_lookup_hi_url_addr() { return _lookup_hi_base64url; }\n+  static address base64_vbmi_pack_vec_addr() { return _pack_vec_base64; }\n+  static address base64_vbmi_join_0_1_addr() { return _join_0_1_base64; }\n+  static address base64_vbmi_join_1_2_addr() { return _join_1_2_base64; }\n+  static address base64_vbmi_join_2_3_addr() { return _join_2_3_base64; }\n+  static address base64_decoding_table_addr() { return _decoding_table_base64; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4026,9 +4026,3 @@\n-    if (UseBiasedLocking) {\n-      __ pop(rcx);   \/\/ get saved klass back in the register.\n-      __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n-      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n-    } else {\n-      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()),\n-                (intptr_t)markWord::prototype().value()); \/\/ header\n-      __ pop(rcx);   \/\/ get saved klass back in the register.\n-    }\n+    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n+              (intptr_t)markWord::prototype().value()); \/\/ header\n+    __ pop(rcx);   \/\/ get saved klass back in the register.\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1015,4 +1015,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n-    \/\/ VM_Version_init() is executed after UseBiasedLocking is used\n-    \/\/ in Thread::allocate().\n@@ -1026,2 +1022,0 @@\n-      \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-      \/\/ setting during arguments processing. See use_biased_locking().\n@@ -1065,2 +1059,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n@@ -1739,21 +1731,0 @@\n-bool VM_Version::use_biased_locking() {\n-#if INCLUDE_RTM_OPT\n-  \/\/ RTM locking is most useful when there is high lock contention and\n-  \/\/ low data contention.  With high lock contention the lock is usually\n-  \/\/ inflated and biased locking is not suitable for that case.\n-  \/\/ RTM locking code requires that biased locking is off.\n-  \/\/ Note: we can't switch off UseBiasedLocking in get_processor_features()\n-  \/\/ because it is used by Thread::allocate() which is called before\n-  \/\/ VM_Version::initialize().\n-  if (UseRTMLocking && UseBiasedLocking) {\n-    if (FLAG_IS_DEFAULT(UseBiasedLocking)) {\n-      FLAG_SET_DEFAULT(UseBiasedLocking, false);\n-    } else {\n-      warning(\"Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.\" );\n-      UseBiasedLocking = false;\n-    }\n-  }\n-#endif\n-  return UseBiasedLocking;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -750,3 +750,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1901,12 +1901,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  int float_pressure_threshold = default_pressure_threshold;\n-#ifdef _LP64\n-  if (UseAVX > 2) {\n-    \/\/ Increase pressure threshold on machines with AVX3 which have\n-    \/\/ 2x more XMM registers.\n-    float_pressure_threshold = default_pressure_threshold * 2;\n-  }\n-#endif\n-  return float_pressure_threshold;\n-}\n-\n@@ -4847,1 +4835,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4880,1 +4869,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4914,1 +4904,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4947,1 +4938,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4980,1 +4972,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5013,1 +5006,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5048,1 +5042,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5082,1 +5077,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5115,1 +5111,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5149,1 +5146,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5182,1 +5180,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5215,1 +5214,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5363,1 +5363,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5397,1 +5398,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5421,1 +5423,2 @@\n-  predicate(VM_Version::supports_avx512dq());\n+  predicate(VM_Version::supports_avx512dq() &&\n+              (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5506,1 +5509,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5539,1 +5543,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5610,1 +5615,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5643,1 +5649,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5827,0 +5834,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -5850,0 +5858,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -6462,1 +6471,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -6496,1 +6506,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -6530,1 +6541,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -7950,0 +7962,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -7974,0 +7987,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -8051,0 +8065,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":49,"deletions":34,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -1443,0 +1443,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 6 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 6 : FLOATPRESSURE;\n+}\n+\n@@ -13670,1 +13680,1 @@\n-                 _counters, _rtm_counters, _stack_rtm_counters,\n+                 _rtm_counters, _stack_rtm_counters,\n@@ -13685,1 +13695,1 @@\n-                 $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);\n+                 $scr$$Register, noreg, noreg, NULL, NULL, NULL, false, false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+extern RegMask _FLOAT_REG_mask;\n@@ -353,0 +354,1 @@\n+RegMask _FLOAT_REG_mask;\n@@ -428,0 +430,4 @@\n+  \/\/ _FLOAT_REG_LEGACY_mask\/_FLOAT_REG_EVEX_mask is generated by adlc\n+  \/\/ from the float_reg_legacy\/float_reg_evex register class.\n+  _FLOAT_REG_mask = VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask;\n+\n@@ -1761,0 +1767,14 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? _INT_REG_mask.Size() : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  \/\/ After experiment around with different values, the following default threshold\n+  \/\/ works best for LCM's register pressure scheduling on x64.\n+  uint dec_count  = VM_Version::supports_evex() ? 4 : 2;\n+  uint default_float_pressure_threshold = _FLOAT_REG_mask.Size() - dec_count;\n+  return (FLOATPRESSURE == -1) ? default_float_pressure_threshold : FLOATPRESSURE;\n+}\n+\n@@ -12910,1 +12930,1 @@\n-                 _counters, _rtm_counters, _stack_rtm_counters,\n+                 _rtm_counters, _stack_rtm_counters,\n@@ -12925,1 +12945,1 @@\n-                 $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);\n+                 $scr$$Register, $cx1$$Register, noreg, NULL, NULL, NULL, false, false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/assembler_zero.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    get_interpreterState()->set_thread(thread->as_Java_thread());\n+    get_interpreterState()->set_thread(JavaThread::cast(thread));\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2291,1 +2291,1 @@\n-    thread->as_Java_thread()->set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo->ContextRecord->PC_NAME);\n+    JavaThread::cast(thread)->set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo->ContextRecord->PC_NAME);\n@@ -2585,1 +2585,1 @@\n-    JavaThread* thread = t->as_Java_thread();\n+    JavaThread* thread = JavaThread::cast(t);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,1 +232,0 @@\n-  AD.addInclude(AD._CPP_file, \"runtime\/biasedLocking.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1529,1 +1529,0 @@\n-        fprintf(fp, \"  ((MachFastLockNode*)n%d)->_counters = _counters;\\n\", cnt);\n@@ -3944,1 +3943,0 @@\n-    fprintf(fp_cpp, \"%s node->_counters = _leaf->as_FastLock()->counters();\\n\", indent);\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -351,2 +350,5 @@\n-  NOT_PRODUCT(_new_instance_slowcase_cnt++;)\n-\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_instance_slowcase_cnt++;\n+  }\n+#endif\n@@ -366,1 +368,5 @@\n-  NOT_PRODUCT(_new_type_array_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_type_array_slowcase_cnt++;\n+  }\n+#endif\n@@ -384,2 +390,5 @@\n-  NOT_PRODUCT(_new_object_array_slowcase_cnt++;)\n-\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_object_array_slowcase_cnt++;\n+  }\n+#endif\n@@ -403,2 +412,5 @@\n-  NOT_PRODUCT(_new_multi_array_slowcase_cnt++;)\n-\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_multi_array_slowcase_cnt++;\n+  }\n+#endif\n@@ -656,1 +668,5 @@\n-  NOT_PRODUCT(_throw_range_check_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_range_check_exception_count++;\n+  }\n+#endif\n@@ -666,1 +682,5 @@\n-  NOT_PRODUCT(_throw_index_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_index_exception_count++;\n+  }\n+#endif\n@@ -674,1 +694,5 @@\n-  NOT_PRODUCT(_throw_div0_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_div0_exception_count++;\n+  }\n+#endif\n@@ -680,1 +704,5 @@\n-  NOT_PRODUCT(_throw_null_pointer_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_null_pointer_exception_count++;\n+  }\n+#endif\n@@ -686,1 +714,5 @@\n-  NOT_PRODUCT(_throw_class_cast_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_class_cast_exception_count++;\n+  }\n+#endif\n@@ -694,1 +726,5 @@\n-  NOT_PRODUCT(_throw_incompatible_class_change_error_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_incompatible_class_change_error_count++;\n+  }\n+#endif\n@@ -701,1 +737,5 @@\n-  NOT_PRODUCT(_monitorenter_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _monitorenter_slowcase_cnt++;\n+  }\n+#endif\n@@ -711,1 +751,5 @@\n-  NOT_PRODUCT(_monitorexit_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _monitorexit_slowcase_cnt++;\n+  }\n+#endif\n@@ -863,1 +907,5 @@\n-  NOT_PRODUCT(_patch_code_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _patch_code_slowcase_cnt++;\n+  }\n+#endif\n@@ -1258,1 +1306,5 @@\n-  NOT_PRODUCT(_patch_code_slowcase_cnt++);\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _patch_code_slowcase_cnt++;\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":70,"deletions":18,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -140,2 +140,0 @@\n-  assert(!p->mark().has_bias_pattern(),\n-         \"this object should never have been locked\");  \/\/ so identity_hash won't safepoin\n@@ -419,5 +417,1 @@\n-    if (UseBiasedLocking) {\n-      oopDesc::set_mark(mem, k->prototype_header());\n-    } else {\n-      oopDesc::set_mark(mem, markWord::prototype());\n-    }\n+    oopDesc::set_mark(mem, markWord::prototype());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -695,2 +695,3 @@\n-            \/\/ Method name and signature are verified above, when iterating NameAndType_info.\n-            \/\/ Need only to be sure signature is non-zero length and the right type.\n+            \/\/ Method name and signature are individually verified above, when iterating\n+            \/\/ NameAndType_info.  Need to check here that signature is non-zero length and\n+            \/\/ the right type.\n@@ -701,1 +702,1 @@\n-          \/\/ 4509014: If a class method name begins with '<', it must be \"<init>\"\n+          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature.\n@@ -703,8 +704,10 @@\n-          if (tag == JVM_CONSTANT_Methodref &&\n-              name_len != 0 &&\n-              name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n-              name != vmSymbols::object_initializer_name()) {\n-            classfile_parse_error(\n-              \"Bad method name at constant pool index %u in class file %s\",\n-              name_ref_index, THREAD);\n-            return;\n+          if (tag == JVM_CONSTANT_Methodref && name_len != 0 &&\n+              name->char_at(0) == JVM_SIGNATURE_SPECIAL) {\n+            if (name != vmSymbols::object_initializer_name()) {\n+              classfile_parse_error(\n+                \"Bad method name at constant pool index %u in class file %s\",\n+                name_ref_index, THREAD);\n+              return;\n+            } else if (!Signature::is_void_method(signature)) { \/\/ must have void signature.\n+              throwIllegalSignature(\"Method\", name, signature, CHECK);\n+            }\n@@ -2084,1 +2087,0 @@\n-      ik->set_prototype_header(markWord::prototype());\n@@ -2297,0 +2299,1 @@\n+    verify_legal_name_with_signature(name, signature, CHECK_NULL);\n@@ -5046,0 +5049,26 @@\n+\/\/ Check that the signature is compatible with the method name.  For example,\n+\/\/ check that <init> has a void signature.\n+void ClassFileParser::verify_legal_name_with_signature(const Symbol* name,\n+                                                       const Symbol* signature,\n+                                                       TRAPS) const {\n+  if (!_need_verify) {\n+    return;\n+  }\n+\n+  \/\/ Class initializers cannot have args for class format version >= 51.\n+  if (name == vmSymbols::class_initializer_name() &&\n+      signature != vmSymbols::void_method_signature() &&\n+      _major_version >= JAVA_7_VERSION) {\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+    return;\n+  }\n+\n+  int sig_length = signature->utf8_length();\n+  if (name->utf8_length() > 0 &&\n+      name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n+      sig_length > 0 &&\n+      signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+  }\n+}\n+\n@@ -5057,8 +5086,0 @@\n-  \/\/ Class initializers cannot have args for class format version >= 51.\n-  if (name == vmSymbols::class_initializer_name() &&\n-      signature != vmSymbols::void_method_signature() &&\n-      _major_version >= JAVA_7_VERSION) {\n-    throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n-    return 0;\n-  }\n-\n@@ -5087,11 +5108,4 @@\n-      if (name->utf8_length() > 0 && name->char_at(0) == JVM_SIGNATURE_SPECIAL) {\n-        \/\/ All internal methods must return void\n-        if ((length == 1) && (p[0] == JVM_SIGNATURE_VOID)) {\n-          return args_size;\n-        }\n-      } else {\n-        \/\/ Now we better just have a return value\n-        nextp = skip_over_field_signature(p, true, length, CHECK_0);\n-        if (nextp && ((int)length == (nextp - p))) {\n-          return args_size;\n-        }\n+      \/\/ Now we better just have a return value\n+      nextp = skip_over_field_signature(p, true, length, CHECK_0);\n+      if (nextp && ((int)length == (nextp - p))) {\n+        return args_size;\n@@ -5102,1 +5116,1 @@\n-  throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n+  throwIllegalSignature(\"Method\", name, signature, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":46,"deletions":32,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -465,0 +465,3 @@\n+  void verify_legal_name_with_signature(const Symbol* name,\n+                                        const Symbol* signature,\n+                                        TRAPS) const;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -456,1 +456,1 @@\n-   do_signature(decodeBlock_signature, \"([BII[BIZ)I\")                                                                   \\\n+   do_signature(decodeBlock_signature, \"([BII[BIZZ)I\")                                                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1080,6 +1080,0 @@\n-\/\/ Just marks the methods in this class as needing deoptimization\n-void CodeCache::mark_for_evol_deoptimization(InstanceKlass* dependee) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n-}\n-\n-\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -274,1 +274,0 @@\n-  static void mark_for_evol_deoptimization(InstanceKlass* dependee);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    return thread->as_Java_thread()->thread_state() == _thread_in_vm;\n+    return JavaThread::cast(thread)->thread_state() == _thread_in_vm;\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1599,2 +1599,12 @@\n-  if (is_not_entrant() && can_convert_to_zombie()) {\n-    return;\n+  {\n+    MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ When the nmethod is acquired from the CodeCache iterator, it can racingly become zombie\n+    \/\/ before this code is called. Filter them out here under the CompiledMethod_lock.\n+    if (!is_alive()) {\n+      return;\n+    }\n+    \/\/ As for is_alive() nmethods, we also don't want them to racingly become zombie once we\n+    \/\/ release this lock, so we check that this is not going to be the case.\n+    if (is_not_entrant() && can_convert_to_zombie()) {\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,2 +272,1 @@\n-  \/\/ locate the owner and stack slot for the BasicLock so that we can\n-  \/\/ properly revoke the bias of the owner if necessary. They are\n+  \/\/ locate the owner and stack slot for the BasicLock. They are\n@@ -278,5 +277,2 @@\n-  \/\/ sharing between platforms. Note that currently biased locking\n-  \/\/ will never cause Class instances to be biased but this code\n-  \/\/ handles the static synchronized case as well.\n-  \/\/ JVMTI's GetLocalInstance() also uses these offsets to find the receiver\n-  \/\/ for non-static native wrapper frames.\n+  \/\/ sharing between platforms. JVMTI's GetLocalInstance() uses these\n+  \/\/ offsets to find the receiver for non-static native wrapper frames.\n@@ -739,1 +735,1 @@\n-  \/\/ UseBiasedLocking support\n+  \/\/ JVMTI's GetLocalInstance() support\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1011,1 +1011,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1013,1 +1013,1 @@\n-        tty->print_cr(\"Added initial compiler thread %s\", ct->get_thread_name());\n+        tty->print_cr(\"Added initial compiler thread %s\", ct->name());\n@@ -1032,1 +1032,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1034,1 +1034,1 @@\n-        tty->print_cr(\"Added initial compiler thread %s\", ct->get_thread_name());\n+        tty->print_cr(\"Added initial compiler thread %s\", ct->name());\n@@ -1119,1 +1119,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1122,1 +1122,1 @@\n-                      ct->get_thread_name(), (int)(available_memory\/M), (int)(available_cc_np\/M));\n+                      ct->name(), (int)(available_memory\/M), (int)(available_cc_np\/M));\n@@ -1140,1 +1140,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1143,1 +1143,1 @@\n-                      ct->get_thread_name(), (int)(available_memory\/M), (int)(available_cc_p\/M));\n+                      ct->name(), (int)(available_memory\/M), (int)(available_cc_p\/M));\n@@ -1279,1 +1279,1 @@\n-        vframeStream vfst(thread->as_Java_thread());\n+        vframeStream vfst(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -53,2 +55,6 @@\n-  \/\/ The remembered set needs the heap regions set up.\n-  HeapRegionRemSet::setup_remset_size();\n+  SpaceAlignment = HeapRegion::GrainBytes;\n+  HeapAlignment = calculate_heap_alignment(SpaceAlignment);\n+\n+  \/\/ We need to initialize card set configuration as soon as heap region size is\n+  \/\/ known as it depends on it and is used really early.\n+  initialize_card_set_configuration();\n@@ -58,1 +64,1 @@\n-    FLAG_SET_ERGO(G1EagerReclaimRemSetThreshold, G1RSetSparseRegionEntries);\n+    FLAG_SET_ERGO(G1EagerReclaimRemSetThreshold, G1RemSetArrayOfCardsEntries);\n@@ -60,3 +66,0 @@\n-\n-  SpaceAlignment = HeapRegion::GrainBytes;\n-  HeapAlignment = calculate_heap_alignment(SpaceAlignment);\n@@ -93,0 +96,2 @@\n+  } else if (strcmp(type, \"young-evac-fail\") == 0) {\n+    G1HeapVerifier::enable_verification_type(G1HeapVerifier::G1VerifyYoungEvacFail);\n@@ -101,1 +106,1 @@\n-                            \"young-normal, concurrent-start, mixed, remark, cleanup and full\", type);\n+                            \"young-normal, young-evac-fail, concurrent-start, mixed, remark, cleanup and full\", type);\n@@ -122,0 +127,34 @@\n+\n+void G1Arguments::initialize_card_set_configuration() {\n+  assert(HeapRegion::LogOfHRGrainBytes != 0, \"not initialized\");\n+  \/\/ Array of Cards card set container globals.\n+  const int LOG_M = 20;\n+  uint region_size_log_mb = (uint)MAX2(HeapRegion::LogOfHRGrainBytes - LOG_M, 0);\n+\n+  if (FLAG_IS_DEFAULT(G1RemSetArrayOfCardsEntries)) {\n+    uint num_cards_in_inline_ptr = G1CardSetConfiguration::num_cards_in_inline_ptr(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift);\n+    FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries, MAX2(num_cards_in_inline_ptr * 2,\n+                                                    G1RemSetArrayOfCardsEntriesBase * (1u << (region_size_log_mb + 1))));\n+  }\n+\n+  \/\/ Round to next 8 byte boundary for array to maximize space usage.\n+  size_t const cur_size = G1CardSetArray::size_in_bytes(G1RemSetArrayOfCardsEntries);\n+  FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries,\n+                G1RemSetArrayOfCardsEntries + (uint)(align_up(cur_size, G1CardSetAllocOptions::BufferAlignment) - cur_size) \/ sizeof(G1CardSetArray::EntryDataType));\n+\n+  \/\/ Howl card set container globals.\n+  if (FLAG_IS_DEFAULT(G1RemSetHowlNumBuckets)) {\n+    FLAG_SET_ERGO(G1RemSetHowlNumBuckets, G1CardSetHowl::num_buckets(HeapRegion::CardsPerRegion,\n+                                                                     G1RemSetArrayOfCardsEntries,\n+                                                                     G1RemSetHowlMaxNumBuckets));\n+  }\n+\n+  if (FLAG_IS_DEFAULT(G1RemSetHowlMaxNumBuckets)) {\n+    FLAG_SET_ERGO(G1RemSetHowlMaxNumBuckets, MAX2(G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets));\n+  } else if (G1RemSetHowlMaxNumBuckets < G1RemSetHowlNumBuckets) {\n+    FormatBuffer<> buf(\"Maximum Howl card set container bucket size %u smaller than requested bucket size %u\",\n+                       G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets);\n+    vm_exit_during_initialization(buf);\n+  }\n+}\n+\n@@ -199,0 +238,8 @@\n+\n+  \/\/ Verify that the maximum parallelism isn't too high to eventually overflow\n+  \/\/ the refcount in G1CardSetContainer.\n+  uint max_parallel_refinement_threads = G1ConcRefinementThreads + G1DirtyCardQueueSet::num_par_ids();\n+  uint const divisor = 3;  \/\/ Safe divisor; we increment by 2 for each claim, but there is a small initial value.\n+  if (max_parallel_refinement_threads > UINTPTR_MAX \/ divisor) {\n+    vm_exit_during_initialization(\"Too large parallelism for remembered sets.\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":54,"deletions":7,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  static void initialize_card_set_configuration();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,887 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"gc\/g1\/g1FromCardCache.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+\n+G1CardSet::CardSetPtr G1CardSet::FullCardSet = (G1CardSet::CardSetPtr)-1;\n+\n+G1CardSetConfiguration::G1CardSetConfiguration() :\n+  _inline_ptr_bits_per_card(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift) {\n+\n+  \/\/ Array of Cards card set container size calculation\n+  _num_cards_in_array = G1RemSetArrayOfCardsEntries;\n+\n+  \/\/ Full card set container size calculation\n+  _max_cards_in_card_set = (uint)HeapRegion::CardsPerRegion;\n+  assert(is_power_of_2(_max_cards_in_card_set),\n+        \"max_cards_in_card_set must be a power of 2: %u\", _max_cards_in_card_set);\n+  _cards_in_howl_threshold = _max_cards_in_card_set * (double)G1RemSetCoarsenHowlToFullPercent \/ 100;\n+\n+  \/\/ Howl card set container size calculation.\n+  _num_buckets_in_howl = G1RemSetHowlNumBuckets;\n+\n+  \/\/ Howl Bitmap card set container size calculation.\n+  _num_cards_in_howl_bitmap = G1CardSetHowl::bitmap_size(_max_cards_in_card_set, _num_buckets_in_howl);\n+  _log2_num_cards_in_howl_bitmap = log2i_exact(_num_cards_in_howl_bitmap);\n+  _cards_in_howl_bitmap_threshold = _num_cards_in_howl_bitmap * (double)G1RemSetCoarsenHowlBitmapToHowlFullPercent \/ 100;\n+  _bitmap_hash_mask = ~(~(0) << _log2_num_cards_in_howl_bitmap);\n+\n+  log_configuration();\n+}\n+\n+G1CardSetConfiguration::G1CardSetConfiguration(uint inline_ptr_bits_per_card,\n+                                               uint num_cards_in_array,\n+                                               double cards_in_bitmap_threshold,\n+                                               uint max_buckets_in_howl,\n+                                               double cards_in_howl_threshold,\n+                                               uint max_cards_in_cardset) :\n+  _inline_ptr_bits_per_card(inline_ptr_bits_per_card),\n+  _num_cards_in_array(num_cards_in_array),\n+  _max_cards_in_card_set(max_cards_in_cardset),\n+  _cards_in_howl_threshold(max_cards_in_cardset * cards_in_howl_threshold) {\n+\n+  assert(is_power_of_2(_max_cards_in_card_set),\n+        \"max_cards_in_card_set must be a power of 2: %u\", _max_cards_in_card_set);\n+\n+  _num_buckets_in_howl = G1CardSetHowl::num_buckets(_max_cards_in_card_set, _num_cards_in_array, max_buckets_in_howl);\n+\n+  _num_cards_in_howl_bitmap = G1CardSetHowl::bitmap_size(_max_cards_in_card_set, _num_buckets_in_howl);\n+  _cards_in_howl_bitmap_threshold = _num_cards_in_howl_bitmap * cards_in_bitmap_threshold;\n+  _log2_num_cards_in_howl_bitmap = log2i_exact(_num_cards_in_howl_bitmap);\n+  _bitmap_hash_mask = ~(~(0) << _log2_num_cards_in_howl_bitmap);\n+\n+  log_configuration();\n+}\n+\n+void G1CardSetConfiguration::log_configuration() {\n+  log_debug_p(gc, remset)(\"Card Set container configuration: \"\n+                          \"InlinePtr #elems %u size %zu \"\n+                          \"Array Of Cards #elems %u size %zu \"\n+                          \"Howl #buckets %u coarsen threshold %u \"\n+                          \"Howl Bitmap #elems %u size %zu coarsen threshold %u\",\n+                          num_cards_in_inline_ptr(), sizeof(void*),\n+                          num_cards_in_array(), G1CardSetArray::size_in_bytes(num_cards_in_array()),\n+                          num_buckets_in_howl(), cards_in_howl_threshold(),\n+                          num_cards_in_howl_bitmap(), G1CardSetBitMap::size_in_bytes(num_cards_in_howl_bitmap()), cards_in_howl_bitmap_threshold());\n+}\n+\n+uint G1CardSetConfiguration::num_cards_in_inline_ptr() const {\n+  return num_cards_in_inline_ptr(_inline_ptr_bits_per_card);\n+}\n+\n+uint G1CardSetConfiguration::num_cards_in_inline_ptr(uint bits_per_card) {\n+  return G1CardSetInlinePtr::max_cards_in_inline_ptr(bits_per_card);\n+}\n+\n+G1CardSetAllocOptions* G1CardSetConfiguration::mem_object_alloc_options() {\n+  G1CardSetAllocOptions* result = NEW_C_HEAP_ARRAY(G1CardSetAllocOptions, num_mem_object_types(), mtGC);\n+\n+  result[0] = { (uint)CardSetHash::get_node_size() };\n+  result[1] = { (uint)G1CardSetArray::size_in_bytes(num_cards_in_array()), 2, 256 };\n+  result[2] = { (uint)G1CardSetBitMap::size_in_bytes(num_cards_in_howl_bitmap()), 2, 256 };\n+  result[3] = { (uint)G1CardSetHowl::size_in_bytes(num_buckets_in_howl()), 2, 256 };\n+\n+  return result;\n+}\n+\n+const char* G1CardSetConfiguration::mem_object_type_name_str(uint index) {\n+  const char* names[] = { \"Node\", \"Array\", \"Bitmap\", \"Howl\" };\n+  return names[index];\n+}\n+\n+void G1CardSetCoarsenStats::reset() {\n+  STATIC_ASSERT(ARRAY_SIZE(_coarsen_from) == ARRAY_SIZE(_coarsen_collision));\n+  for (uint i = 0; i < ARRAY_SIZE(_coarsen_from); i++) {\n+    _coarsen_from[i] = 0;\n+    _coarsen_collision[i] = 0;\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::subtract_from(G1CardSetCoarsenStats& other) {\n+  STATIC_ASSERT(ARRAY_SIZE(_coarsen_from) == ARRAY_SIZE(_coarsen_collision));\n+  for (uint i = 0; i < ARRAY_SIZE(_coarsen_from); i++) {\n+    _coarsen_from[i] = other._coarsen_from[i] - _coarsen_from[i];\n+    _coarsen_collision[i] = other._coarsen_collision[i] - _coarsen_collision[i];\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::record_coarsening(uint tag, bool collision) {\n+  assert(tag < ARRAY_SIZE(_coarsen_from), \"tag %u out of bounds\", tag);\n+  Atomic::inc(&_coarsen_from[tag], memory_order_relaxed);\n+  if (collision) {\n+    Atomic::inc(&_coarsen_collision[tag], memory_order_relaxed);\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::print_on(outputStream* out) {\n+  out->print_cr(\"Inline->AoC %zu (%zu) \"\n+                \"AoC->Howl %zu (%zu) \"\n+                \"Howl->Full %zu (%zu) \"\n+                \"Inline->AoC %zu (%zu) \"\n+                \"AoC->BitMap %zu (%zu) \"\n+                \"BitMap->Full %zu (%zu) \",\n+                _coarsen_from[0], _coarsen_collision[0],\n+                _coarsen_from[1], _coarsen_collision[1],\n+                \/\/ There is no BitMap at the first level so we can't .\n+                _coarsen_from[3], _coarsen_collision[3],\n+                _coarsen_from[4], _coarsen_collision[4],\n+                _coarsen_from[5], _coarsen_collision[5],\n+                _coarsen_from[6], _coarsen_collision[6]\n+               );\n+}\n+\n+class G1CardSetHashTable : public CHeapObj<mtGCCardSet> {\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  \/\/ Did we insert at least one element in the table?\n+  bool volatile _inserted_elem;\n+\n+  G1CardSetMemoryManager* _mm;\n+  CardSetHash _table;\n+\n+  class G1CardSetHashTableLookUp : public StackObj {\n+    uint _region_idx;\n+  public:\n+    explicit G1CardSetHashTableLookUp(uint region_idx) : _region_idx(region_idx) { }\n+\n+    uintx get_hash() const { return _region_idx; }\n+\n+    bool equals(G1CardSetHashTableValue* value, bool* is_dead) {\n+      *is_dead = false;\n+      return value->_region_idx == _region_idx;\n+    }\n+  };\n+\n+  class G1CardSetHashTableFound : public StackObj {\n+    G1CardSetHashTableValue* _value;\n+  public:\n+    void operator()(G1CardSetHashTableValue* value) {\n+      _value = value;\n+    }\n+\n+    G1CardSetHashTableValue* value() const { return _value; }\n+  };\n+\n+  class G1CardSetHashTableScan : public StackObj {\n+    G1CardSet::G1CardSetPtrIterator* _scan_f;\n+  public:\n+    explicit G1CardSetHashTableScan(G1CardSet::G1CardSetPtrIterator* f) : _scan_f(f) { }\n+\n+    bool operator()(G1CardSetHashTableValue* value) {\n+      _scan_f->do_cardsetptr(value->_region_idx, value->_num_occupied, value->_card_set);\n+      return true;\n+    }\n+  };\n+\n+\n+public:\n+  static const size_t InitialLogTableSize = 2;\n+\n+  G1CardSetHashTable(G1CardSetMemoryManager* mm,\n+                     size_t initial_log_table_size = InitialLogTableSize) :\n+    _inserted_elem(false),\n+    _mm(mm),\n+    _table(mm, initial_log_table_size) {\n+  }\n+\n+  ~G1CardSetHashTable() {\n+    reset();\n+  }\n+\n+  G1CardSetHashTableValue* get_or_add(uint region_idx, bool* should_grow) {\n+    G1CardSetHashTableLookUp lookup(region_idx);\n+    G1CardSetHashTableFound found;\n+\n+    if (_table.get(Thread::current(), lookup, found)) {\n+      return found.value();\n+    }\n+\n+    G1CardSetHashTableValue value(region_idx, G1CardSetInlinePtr());\n+    bool inserted = _table.insert_get(Thread::current(), lookup, value, found, should_grow);\n+\n+    if (!_inserted_elem && inserted) {\n+      \/\/ It does not matter to us who is setting the flag so a regular atomic store\n+      \/\/ is sufficient.\n+      Atomic::store(&_inserted_elem, true);\n+    }\n+\n+    return found.value();\n+  }\n+\n+  CardSetPtr get(uint region_idx) {\n+    G1CardSetHashTableLookUp lookup(region_idx);\n+    G1CardSetHashTableFound found;\n+\n+    if (_table.get(Thread::current(), lookup, found)) {\n+      return found.value()->_card_set;\n+    }\n+    return nullptr;\n+  }\n+\n+  void iterate_safepoint(G1CardSet::G1CardSetPtrIterator* cl2) {\n+    G1CardSetHashTableScan cl(cl2);\n+    _table.do_safepoint_scan(cl);\n+  }\n+\n+  void iterate(G1CardSet::G1CardSetPtrIterator* cl2) {\n+    G1CardSetHashTableScan cl(cl2);\n+    _table.do_scan(Thread::current(), cl);\n+  }\n+\n+  void reset() {\n+    if (Atomic::load(&_inserted_elem)) {\n+       _table.unsafe_reset(InitialLogTableSize);\n+      Atomic::store(&_inserted_elem, false);\n+    }\n+  }\n+\n+  void print(outputStream* os) {\n+    os->print(\"TBL \" PTR_FORMAT \" size %zu mem %zu \", p2i(&_table), _table.get_size_log2(Thread::current()), _table.get_mem_size(Thread::current()));\n+  }\n+\n+  void grow() {\n+    size_t new_limit = _table.get_size_log2(Thread::current()) + 1;\n+    _table.grow(Thread::current(), new_limit);\n+  }\n+\n+  size_t mem_size() {\n+    return sizeof(*this) +\n+      _table.get_mem_size(Thread::current()) - sizeof(_table);\n+  }\n+\n+  size_t log_table_size() { return _table.get_size_log2(Thread::current()); }\n+};\n+\n+void* G1CardSetHashTableConfig::allocate_node(void* context, size_t size, Value const& value) {\n+  G1CardSetMemoryManager* mm = (G1CardSetMemoryManager*)context;\n+  return mm->allocate_node();\n+}\n+\n+void G1CardSetHashTableConfig::free_node(void* context, void* memory, Value const& value) {\n+  G1CardSetMemoryManager* mm = (G1CardSetMemoryManager*)context;\n+  mm->free_node(memory);\n+}\n+\n+G1CardSetCoarsenStats G1CardSet::_coarsen_stats;\n+G1CardSetCoarsenStats G1CardSet::_last_coarsen_stats;\n+\n+G1CardSet::G1CardSet(G1CardSetConfiguration* config, G1CardSetMemoryManager* mm) :\n+  _mm(mm),\n+  _config(config),\n+  _table(new G1CardSetHashTable(mm)),\n+  _num_occupied(0) {\n+}\n+\n+G1CardSet::~G1CardSet() {\n+  delete _table;\n+  _mm->flush();\n+}\n+\n+uint G1CardSet::card_set_type_to_mem_object_type(uintptr_t type) const {\n+  assert(type == G1CardSet::CardSetArrayOfCards ||\n+         type == G1CardSet::CardSetBitMap ||\n+         type == G1CardSet::CardSetHowl, \"should not allocate card set type %zu\", type);\n+\n+  return (uint)type;\n+}\n+\n+uint8_t* G1CardSet::allocate_mem_object(uintptr_t type) {\n+  return _mm->allocate(card_set_type_to_mem_object_type(type));\n+}\n+\n+void G1CardSet::free_mem_object(CardSetPtr card_set) {\n+  assert(card_set != G1CardSet::FreeCardSet, \"should not free Free card set\");\n+  assert(card_set != G1CardSet::FullCardSet, \"should not free Full card set\");\n+\n+  uintptr_t type = card_set_type(card_set);\n+  void* value = strip_card_set_type(card_set);\n+\n+  assert(type == G1CardSet::CardSetArrayOfCards ||\n+         type == G1CardSet::CardSetBitMap ||\n+         type == G1CardSet::CardSetHowl, \"should not free card set type %zu\", type);\n+\n+#ifdef ASSERT\n+  if (type == G1CardSet::CardSetArrayOfCards ||\n+      type == G1CardSet::CardSetBitMap ||\n+      type == G1CardSet::CardSetHowl) {\n+    G1CardSetContainer* card_set = (G1CardSetContainer*)value;\n+    assert((card_set->refcount() == 1), \"must be\");\n+  }\n+#endif\n+\n+  _mm->free(card_set_type_to_mem_object_type(type), value);\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::acquire_card_set(CardSetPtr volatile* card_set_addr) {\n+  \/\/ Update reference counts under RCU critical section to avoid a\n+  \/\/ use-after-cleapup bug where we increment a reference count for\n+  \/\/ an object whose memory has already been cleaned up and reused.\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+  while (true) {\n+    \/\/ Get cardsetptr and increment refcount atomically wrt to memory reuse.\n+    CardSetPtr card_set = Atomic::load_acquire(card_set_addr);\n+    uint cs_type = card_set_type(card_set);\n+    if (card_set == FullCardSet || cs_type == CardSetInlinePtr) {\n+      return card_set;\n+    }\n+\n+    G1CardSetContainer* card_set_on_heap = (G1CardSetContainer*)strip_card_set_type(card_set);\n+\n+    if (card_set_on_heap->try_increment_refcount()) {\n+      assert(card_set_on_heap->refcount() >= 3, \"Smallest value is 3\");\n+      return card_set;\n+    }\n+  }\n+}\n+\n+bool G1CardSet::release_card_set(CardSetPtr card_set) {\n+  uint cs_type = card_set_type(card_set);\n+  if (card_set == FullCardSet || cs_type == CardSetInlinePtr) {\n+    return false;\n+  }\n+\n+  G1CardSetContainer* card_set_on_heap = (G1CardSetContainer*)strip_card_set_type(card_set);\n+  return card_set_on_heap->decrement_refcount() == 1;\n+}\n+\n+void G1CardSet::release_and_maybe_free_card_set(CardSetPtr card_set) {\n+  if (release_card_set(card_set)) {\n+    free_mem_object(card_set);\n+  }\n+}\n+\n+void G1CardSet::release_and_must_free_card_set(CardSetPtr card_set) {\n+  bool should_free = release_card_set(card_set);\n+  assert(should_free, \"should have been the only one having a reference\");\n+  free_mem_object(card_set);\n+}\n+\n+class G1ReleaseCardsets : public StackObj {\n+  G1CardSet* _card_set;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  void coarsen_to_full(CardSetPtr* card_set_addr) {\n+    while (true) {\n+      CardSetPtr cur_card_set = Atomic::load_acquire(card_set_addr);\n+      uint cs_type = G1CardSet::card_set_type(cur_card_set);\n+      if (cur_card_set == G1CardSet::FullCardSet) {\n+        return;\n+      }\n+\n+      CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, G1CardSet::FullCardSet);\n+\n+      if (old_value == cur_card_set) {\n+        _card_set->release_and_maybe_free_card_set(cur_card_set);\n+        return;\n+      }\n+    }\n+  }\n+\n+public:\n+  explicit G1ReleaseCardsets(G1CardSet* card_set) : _card_set(card_set) { }\n+\n+  void operator ()(CardSetPtr* card_set_addr) {\n+    coarsen_to_full(card_set_addr);\n+  }\n+};\n+\n+G1AddCardResult G1CardSet::add_to_array(CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetArray* array = card_set_ptr<G1CardSetArray>(card_set);\n+  return array->add(card_in_region);\n+}\n+\n+G1AddCardResult G1CardSet::add_to_howl(CardSetPtr parent_card_set,\n+                                                uint card_region,\n+                                                uint card_in_region,\n+                                                bool increment_total) {\n+  G1CardSetHowl* howl = card_set_ptr<G1CardSetHowl>(parent_card_set);\n+\n+  G1AddCardResult add_result;\n+  CardSetPtr to_transfer = nullptr;\n+  CardSetPtr card_set;\n+\n+  uint bucket = _config->howl_bucket_index(card_in_region);\n+  volatile CardSetPtr* bucket_entry = howl->get_card_set_addr(bucket);\n+\n+  while (true) {\n+    if (Atomic::load(&howl->_num_entries) >= _config->cards_in_howl_threshold()) {\n+      return Overflow;\n+    }\n+\n+    card_set = acquire_card_set(bucket_entry);\n+    add_result = add_to_card_set(bucket_entry, card_set, card_region, card_in_region);\n+\n+    if (add_result != Overflow) {\n+      break;\n+    }\n+    \/\/ Card set has overflown. Coarsen or retry.\n+    bool coarsened = coarsen_card_set(bucket_entry, card_set, card_in_region, true \/* within_howl *\/);\n+    _coarsen_stats.record_coarsening(card_set_type(card_set) + G1CardSetCoarsenStats::CoarsenHowlOffset, !coarsened);\n+    if (coarsened) {\n+      \/\/ We have been the one coarsening this card set (and in the process added that card).\n+      add_result = Added;\n+      to_transfer = card_set;\n+      break;\n+    }\n+    \/\/ Somebody else beat us to coarsening. Retry.\n+    release_and_maybe_free_card_set(card_set);\n+  }\n+\n+  if (increment_total && add_result == Added) {\n+    Atomic::inc(&howl->_num_entries, memory_order_relaxed);\n+  }\n+\n+  if (to_transfer != nullptr) {\n+    transfer_cards_in_howl(parent_card_set, to_transfer, card_region);\n+  }\n+\n+  release_and_maybe_free_card_set(card_set);\n+  return add_result;\n+}\n+\n+G1AddCardResult G1CardSet::add_to_bitmap(CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetBitMap* bitmap = card_set_ptr<G1CardSetBitMap>(card_set);\n+  uint card_offset = _config->howl_bitmap_offset(card_in_region);\n+  return bitmap->add(card_offset, _config->cards_in_howl_bitmap_threshold(), _config->num_cards_in_howl_bitmap());\n+}\n+\n+G1AddCardResult G1CardSet::add_to_inline_ptr(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetInlinePtr value(card_set_addr, card_set);\n+  return value.add(card_in_region, _config->inline_ptr_bits_per_card(), _config->num_cards_in_inline_ptr());\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::create_coarsened_array_of_cards(uint card_in_region, bool within_howl) {\n+  uint8_t* data = nullptr;\n+  CardSetPtr new_card_set;\n+  if (within_howl) {\n+    uint const size_in_bits = _config->num_cards_in_howl_bitmap();\n+    uint card_offset = _config->howl_bitmap_offset(card_in_region);\n+    data = allocate_mem_object(CardSetBitMap);\n+    new (data) G1CardSetBitMap(card_offset, size_in_bits);\n+    new_card_set = make_card_set_ptr(data, CardSetBitMap);\n+  } else {\n+    data = allocate_mem_object(CardSetHowl);\n+    new (data) G1CardSetHowl(card_in_region, _config);\n+    new_card_set = make_card_set_ptr(data, CardSetHowl);\n+  }\n+  return new_card_set;\n+}\n+\n+bool G1CardSet::coarsen_card_set(volatile CardSetPtr* card_set_addr,\n+                                 CardSetPtr cur_card_set,\n+                                 uint card_in_region,\n+                                 bool within_howl) {\n+  CardSetPtr new_card_set = nullptr;\n+\n+  switch (card_set_type(cur_card_set)) {\n+    case CardSetArrayOfCards : {\n+      new_card_set = create_coarsened_array_of_cards(card_in_region, within_howl);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      new_card_set = FullCardSet;\n+      break;\n+    }\n+    case CardSetInlinePtr: {\n+      uint const size = _config->num_cards_in_array();\n+      uint8_t* data = allocate_mem_object(CardSetArrayOfCards);\n+      new (data) G1CardSetArray(card_in_region, size);\n+      new_card_set = make_card_set_ptr(data, CardSetArrayOfCards);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      new_card_set = FullCardSet; \/\/ anything will do at this point.\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, new_card_set); \/\/ Memory order?\n+  if (old_value == cur_card_set) {\n+    \/\/ Success. Indicate that the cards from the current card set must be transferred\n+    \/\/ by this caller.\n+    \/\/ Release the hash table reference to the card. The caller still holds the\n+    \/\/ reference to this card set, so it can never be released (and we do not need to\n+    \/\/ check its result).\n+    bool should_free = release_card_set(cur_card_set);\n+    assert(!should_free, \"must have had more than one reference\");\n+    \/\/ Free containers if cur_card_set is CardSetHowl\n+    if (card_set_type(cur_card_set) == CardSetHowl) {\n+      G1ReleaseCardsets rel(this);\n+      card_set_ptr<G1CardSetHowl>(cur_card_set)->iterate(rel, _config->num_buckets_in_howl());\n+    }\n+    return true;\n+  } else {\n+    \/\/ Somebody else beat us to coarsening that card set. Exit, but clean up first.\n+    if (new_card_set != FullCardSet) {\n+      assert(new_card_set != nullptr, \"must not be\");\n+      release_and_must_free_card_set(new_card_set);\n+    }\n+    return false;\n+  }\n+}\n+\n+class G1TransferCard : public StackObj {\n+  G1CardSet* _card_set;\n+  uint _region_idx;\n+public:\n+  G1TransferCard(G1CardSet* card_set, uint region_idx) : _card_set(card_set), _region_idx(region_idx) { }\n+\n+  void operator ()(uint card_idx) {\n+    _card_set->add_card(_region_idx, card_idx, false);\n+  }\n+};\n+\n+void G1CardSet::transfer_cards(G1CardSetHashTableValue* table_entry, CardSetPtr source_card_set, uint card_region) {\n+  assert(source_card_set != FullCardSet, \"Should not need to transfer from full\");\n+  \/\/ Need to transfer old entries unless there is a Full card set in place now, i.e.\n+  \/\/ the old type has been CardSetBitMap. \"Full\" contains all elements anyway.\n+  if (card_set_type(source_card_set) != CardSetHowl) {\n+    G1TransferCard iter(this, card_region);\n+    iterate_cards_during_transfer(source_card_set, iter);\n+  } else {\n+    assert(card_set_type(source_card_set) == CardSetHowl, \"must be\");\n+    \/\/ Need to correct for that the Full remembered set occupies more cards than the\n+    \/\/ AoCS before.\n+    Atomic::add(&_num_occupied, _config->max_cards_in_region() - table_entry->_num_occupied, memory_order_relaxed);\n+  }\n+}\n+\n+void G1CardSet::transfer_cards_in_howl(CardSetPtr parent_card_set,\n+                                                     CardSetPtr source_card_set,\n+                                                     uint card_region) {\n+  assert(card_set_type(parent_card_set) == CardSetHowl, \"must be\");\n+  assert(source_card_set != FullCardSet, \"Should not need to transfer from full\");\n+  \/\/ Need to transfer old entries unless there is a Full card set in place now, i.e.\n+  \/\/ the old type has been CardSetBitMap.\n+  if (card_set_type(source_card_set) != CardSetBitMap) {\n+    \/\/ We only need to transfer from anything below CardSetBitMap.\n+    G1TransferCard iter(this, card_region);\n+    iterate_cards_during_transfer(source_card_set, iter);\n+  } else {\n+    uint diff = _config->num_cards_in_howl_bitmap() - card_set_ptr<G1CardSetBitMap>(source_card_set)->num_bits_set();\n+\n+    \/\/ Need to correct for that the Full remembered set occupies more cards than the\n+    \/\/ bitmap before.\n+    \/\/ We add 1 element less because the values will be incremented\n+    \/\/ in G1CardSet::add_card for the current addition or where already incremented in\n+    \/\/ G1CardSet::add_to_howl after coarsening.\n+    diff -= 1;\n+\n+    G1CardSetHowl* howling_array = card_set_ptr<G1CardSetHowl>(parent_card_set);\n+    Atomic::add(&howling_array->_num_entries, diff, memory_order_relaxed);\n+\n+    bool should_grow_table = false;\n+    G1CardSetHashTableValue* table_entry = get_or_add_card_set(card_region, &should_grow_table);\n+    Atomic::add(&table_entry->_num_occupied, diff, memory_order_relaxed);\n+\n+    Atomic::add(&_num_occupied, diff, memory_order_relaxed);\n+  }\n+}\n+\n+G1AddCardResult G1CardSet::add_to_card_set(volatile CardSetPtr* card_set_addr, CardSetPtr card_set,  uint card_region, uint card_in_region, bool increment_total) {\n+  assert(card_set_addr != nullptr, \"Cannot add to empty cardset\");\n+\n+  G1AddCardResult add_result;\n+\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      add_result = add_to_inline_ptr(card_set_addr, card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetArrayOfCards : {\n+      add_result = add_to_array(card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      add_result = add_to_bitmap(card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      assert(CardSetHowl == card_set_type(FullCardSet), \"must be\");\n+      if (card_set == FullCardSet) {\n+        return Found;\n+      }\n+      add_result = add_to_howl(card_set, card_region, card_in_region, increment_total);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  return add_result;\n+}\n+\n+G1CardSetHashTableValue* G1CardSet::get_or_add_card_set(uint card_region, bool* should_grow_table) {\n+  return _table->get_or_add(card_region, should_grow_table);\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::get_card_set(uint card_region) {\n+  return _table->get(card_region);\n+}\n+\n+G1AddCardResult G1CardSet::add_card(uint card_region, uint card_in_region, bool increment_total) {\n+  G1AddCardResult add_result;\n+  CardSetPtr to_transfer = nullptr;\n+  CardSetPtr card_set;\n+\n+  bool should_grow_table = false;\n+  G1CardSetHashTableValue* table_entry = get_or_add_card_set(card_region, &should_grow_table);\n+  while (true) {\n+    card_set = acquire_card_set(&table_entry->_card_set);\n+    add_result = add_to_card_set(&table_entry->_card_set, card_set, card_region, card_in_region, increment_total);\n+\n+    if (add_result != Overflow) {\n+      break;\n+    }\n+    \/\/ Card set has overflown. Coarsen or retry.\n+    bool coarsened = coarsen_card_set(&table_entry->_card_set, card_set, card_in_region);\n+    _coarsen_stats.record_coarsening(card_set_type(card_set), !coarsened);\n+    if (coarsened) {\n+      \/\/ We have been the one coarsening this card set (and in the process added that card).\n+      add_result = Added;\n+      to_transfer = card_set;\n+      break;\n+    }\n+    \/\/ Somebody else beat us to coarsening. Retry.\n+    release_and_maybe_free_card_set(card_set);\n+  }\n+\n+  if (increment_total && add_result == Added) {\n+    Atomic::inc(&table_entry->_num_occupied, memory_order_relaxed);\n+    Atomic::inc(&_num_occupied, memory_order_relaxed);\n+  }\n+  if (should_grow_table) {\n+    _table->grow();\n+  }\n+  if (to_transfer != nullptr) {\n+    transfer_cards(table_entry, to_transfer, card_region);\n+  }\n+\n+  release_and_maybe_free_card_set(card_set);\n+\n+  return add_result;\n+}\n+\n+bool G1CardSet::contains_card(uint card_region, uint card_in_region) {\n+  assert(card_in_region < _config->max_cards_in_region(),\n+         \"Card %u is beyond max %u\", card_in_region, _config->max_cards_in_region());\n+\n+  \/\/ Protect the card set from reclamation.\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+  CardSetPtr card_set = get_card_set(card_region);\n+  if (card_set == nullptr) {\n+    return false;\n+  } else if (card_set == FullCardSet) {\n+    \/\/ contains_card() is not a performance critical method so we do not hide that\n+    \/\/ case in the switch below.\n+    return true;\n+  }\n+\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      return ptr.contains(card_in_region, _config->inline_ptr_bits_per_card());\n+    }\n+    case CardSetArrayOfCards :  return card_set_ptr<G1CardSetArray>(card_set)->contains(card_in_region);\n+    case CardSetBitMap: return card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_in_region, _config->num_cards_in_howl_bitmap());\n+    case CardSetHowl: {\n+      G1CardSetHowl* howling_array = card_set_ptr<G1CardSetHowl>(card_set);\n+\n+      return howling_array->contains(card_in_region, _config);\n+    }\n+  }\n+  ShouldNotReachHere();\n+  return false;\n+}\n+\n+void G1CardSet::print_info(outputStream* st, uint card_region, uint card_in_region) {\n+  CardSetPtr card_set = get_card_set(card_region);\n+  if (card_set == nullptr) {\n+    st->print(\"NULL card set\");\n+    return;\n+  } else if (card_set == FullCardSet) {\n+    st->print(\"FULL card set)\");\n+    return;\n+  }\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      st->print(\"InlinePtr not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetArrayOfCards :  {\n+      st->print(\"AoC not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      st->print(\"BitMap not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      st->print(\"CardSetHowl not containing %u\", card_in_region);\n+      break;\n+    }\n+    default: st->print(\"Unknown card set type %u\", card_set_type(card_set)); ShouldNotReachHere(); break;\n+  }\n+}\n+\n+template <class CardVisitor>\n+void G1CardSet::iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& found) {\n+  uint type = card_set_type(card_set);\n+  assert(type == CardSetInlinePtr || type == CardSetArrayOfCards,\n+         \"invalid card set type %d to transfer from\",\n+         card_set_type(card_set));\n+\n+  switch (type) {\n+    case CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      ptr.iterate(found, _config->inline_ptr_bits_per_card());\n+      return;\n+    }\n+    case CardSetArrayOfCards : {\n+      card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      return;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void G1CardSet::iterate_containers(G1CardSetPtrIterator* found, bool at_safepoint) {\n+  if (at_safepoint) {\n+    _table->iterate_safepoint(found);\n+  } else {\n+    _table->iterate(found);\n+  }\n+}\n+\n+template <typename Closure>\n+class G1ContainerCards {\n+  Closure& _iter;\n+  uint _region_idx;\n+\n+public:\n+  G1ContainerCards(Closure& iter, uint region_idx) : _iter(iter), _region_idx(region_idx) { }\n+\n+  bool start_iterate(uint tag) { return true; }\n+\n+  void operator()(uint card_idx) {\n+    _iter.do_card(_region_idx, card_idx);\n+  }\n+\n+  void operator()(uint card_idx, uint length) {\n+    for (uint i = 0; i < length; i++) {\n+      _iter.do_card(_region_idx, card_idx);\n+    }\n+  }\n+};\n+\n+void G1CardSet::iterate_cards(G1CardSetCardIterator& iter) {\n+  G1CardSetMergeCardIterator<G1CardSetCardIterator, G1ContainerCards> cl(this, iter);\n+  iterate_containers(&cl);\n+}\n+\n+bool G1CardSet::occupancy_less_or_equal_to(size_t limit) const {\n+  return occupied() <= limit;\n+}\n+\n+bool G1CardSet::is_empty() const {\n+  return _num_occupied == 0;\n+}\n+\n+size_t G1CardSet::occupied() const {\n+  return _num_occupied;\n+}\n+\n+size_t G1CardSet::num_containers() {\n+  class GetNumberOfContainers : public G1CardSetPtrIterator {\n+  public:\n+    size_t _count;\n+\n+    GetNumberOfContainers() : G1CardSetPtrIterator(), _count(0) { }\n+\n+    void do_cardsetptr(uint region_idx, size_t num_occupied, CardSetPtr card_set) override {\n+      _count++;\n+    }\n+  } cl;\n+\n+  iterate_containers(&cl);\n+  return cl._count;\n+}\n+\n+G1CardSetCoarsenStats G1CardSet::coarsen_stats() {\n+  return _coarsen_stats;\n+}\n+\n+void G1CardSet::print_coarsen_stats(outputStream* out) {\n+  _last_coarsen_stats.subtract_from(_coarsen_stats);\n+  out->print(\"Coarsening (recent): \");\n+  _last_coarsen_stats.print_on(out);\n+  out->print(\"Coarsening (all): \");\n+  _coarsen_stats.print_on(out);\n+}\n+\n+size_t G1CardSet::mem_size() const {\n+  return sizeof(*this) +\n+         _table->mem_size() +\n+         _mm->mem_size();\n+}\n+\n+size_t G1CardSet::wasted_mem_size() const {\n+  return _mm->wasted_mem_size();\n+}\n+\n+size_t G1CardSet::static_mem_size() {\n+  return sizeof(FullCardSet) + sizeof(_coarsen_stats);\n+}\n+\n+void G1CardSet::clear() {\n+  _table->reset();\n+  _num_occupied = 0;\n+  _mm->flush();\n+}\n+\n+void G1CardSet::print(outputStream* os) {\n+  _table->print(os);\n+  _mm->print(os);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":887,"deletions":0,"binary":false,"changes":887,"status":"added"},{"patch":"@@ -0,0 +1,376 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSET_HPP\n+#define SHARE_GC_G1_G1CARDSET_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/padded.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/concurrentHashTable.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+\n+class G1CardSetAllocOptions;\n+class G1CardSetBufferList;\n+class G1CardSetHashTable;\n+class G1CardSetHashTableValue;\n+class G1CardSetMemoryManager;\n+class Mutex;\n+\n+\/\/ The result of an attempt to add a card to that card set.\n+enum G1AddCardResult {\n+  Overflow,  \/\/ The card set is more than full. The entry may have been added. Need\n+             \/\/ Coarsen and retry.\n+  Found,     \/\/ The card is already in the set.\n+  Added      \/\/ The card has been added to the set by this attempt.\n+};\n+\n+class G1CardSetConfiguration {\n+  uint _inline_ptr_bits_per_card;\n+  uint _num_cards_in_array;\n+  uint _num_cards_in_howl_bitmap;\n+  uint _num_buckets_in_howl;\n+  uint _max_cards_in_card_set;\n+  uint _cards_in_howl_threshold;\n+  uint _cards_in_howl_bitmap_threshold;\n+  uint _log2_num_cards_in_howl_bitmap;\n+  size_t _bitmap_hash_mask;\n+\n+  void log_configuration();\n+public:\n+\n+  \/\/ Initialize card set configuration from globals.\n+  G1CardSetConfiguration();\n+  \/\/ Initialize card set configuration from parameters.\n+  G1CardSetConfiguration(uint inline_ptr_bits_per_card,\n+                         uint num_cards_in_array,\n+                         double cards_in_bitmap_threshold,\n+                         uint max_buckets_in_howl,\n+                         double cards_in_howl_threshold,\n+                         uint max_cards_in_cardset);\n+\n+  \/\/ Inline pointer configuration\n+  uint inline_ptr_bits_per_card() const { return _inline_ptr_bits_per_card; }\n+  uint num_cards_in_inline_ptr() const;\n+  static uint num_cards_in_inline_ptr(uint bits_per_card);\n+\n+  \/\/ Array of Cards configuration\n+  bool use_cards_in_array() const { return _num_cards_in_array != 0; } \/\/ Unused for now\n+  \/\/ Number of cards in \"Array of Cards\" set; 0 to disable.\n+  \/\/ Always coarsen to next level if full, so no specific threshold.\n+  uint num_cards_in_array() const { return _num_cards_in_array; }\n+\n+  \/\/ Bitmap within Howl card set container configuration\n+  bool use_cards_in_howl_bitmap() const { return _num_cards_in_howl_bitmap != 0; } \/\/ Unused for now\n+  uint num_cards_in_howl_bitmap() const { return _num_cards_in_howl_bitmap; }\n+  \/\/ (Approximate) Number of cards in bitmap to coarsen Howl Bitmap to Howl Full.\n+  uint cards_in_howl_bitmap_threshold() const { return _cards_in_howl_bitmap_threshold; }\n+  uint log2_num_cards_in_howl_bitmap() const {return _log2_num_cards_in_howl_bitmap;}\n+\n+  \/\/ Howl card set container configuration\n+  uint num_buckets_in_howl() const { return _num_buckets_in_howl; }\n+  \/\/ Threshold at which to turn howling arrays into Full.\n+  uint cards_in_howl_threshold() const { return _cards_in_howl_threshold; }\n+  uint howl_bitmap_offset(uint card_idx) const { return card_idx & _bitmap_hash_mask; }\n+  \/\/ Given a card index, return the bucket in the array of card sets.\n+  uint howl_bucket_index(uint card_idx) { return card_idx >> _log2_num_cards_in_howl_bitmap; }\n+\n+  \/\/ Full card configuration\n+  \/\/ Maximum number of cards in a non-full card set for a single region. Card sets\n+  \/\/ with more entries per region are coarsened to Full.\n+  uint max_cards_in_region() const { return _max_cards_in_card_set; }\n+\n+  \/\/ Memory object types configuration\n+  \/\/ Number of distinctly sized memory objects on the card set heap.\n+  \/\/ Currently contains CHT-Nodes, ArrayOfCards, BitMaps, Howl\n+  static constexpr uint num_mem_object_types() { return 4; }\n+  \/\/ Returns the memory allocation options for the memory objects on the card set heap. The returned\n+  \/\/ array must be freed by the caller.\n+  G1CardSetAllocOptions* mem_object_alloc_options();\n+\n+  \/\/ For a given memory object, get a descriptive name.\n+  static const char* mem_object_type_name_str(uint index);\n+};\n+\n+\/\/ Collects coarsening statistics: how many attempts of each kind and how many\n+\/\/ failed due to a competing thread doing the coarsening first.\n+class G1CardSetCoarsenStats {\n+public:\n+  \/\/ Number of entries in the statistics tables: since we index with the source\n+  \/\/ cardset of the coarsening, this is the total number of combinations of\n+  \/\/ card sets - 1.\n+  static constexpr size_t NumCoarsenCategories = 7;\n+  \/\/ Coarsening statistics for the possible CardSetPtr in the Howl card set\n+  \/\/ start from this offset.\n+  static constexpr size_t CoarsenHowlOffset = 4;\n+\n+private:\n+  \/\/ Indices are \"from\" indices.\n+  size_t _coarsen_from[NumCoarsenCategories];\n+  size_t _coarsen_collision[NumCoarsenCategories];\n+\n+public:\n+  G1CardSetCoarsenStats() { reset(); }\n+\n+  void reset();\n+\n+  void subtract_from(G1CardSetCoarsenStats& other);\n+\n+  \/\/ Record a coarsening for the given tag\/category. Collision should be true if\n+  \/\/ this coarsening lost the race to do the coarsening of that category.\n+  void record_coarsening(uint tag, bool collision);\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Sparse set of card indexes comprising a remembered set on the Java heap. Card\n+\/\/ size is assumed to be card table card size.\n+\/\/\n+\/\/ Technically it is implemented using a ConcurrentHashTable that stores a card\n+\/\/ set container for every region containing at least one card.\n+\/\/\n+\/\/ There are in total five different containers, encoded in the ConcurrentHashTable\n+\/\/ node as CardSetPtr. A CardSetPtr may cover the whole region or just a part of\n+\/\/ it.\n+\/\/ See its description below for more information.\n+class G1CardSet : public CHeapObj<mtGCCardSet> {\n+  friend class G1CardSetTest;\n+  friend class G1CardSetMtTestTask;\n+\n+  template <typename Closure, template <typename> class CardorRanges>\n+  friend class G1CardSetMergeCardIterator;\n+\n+  friend class G1TransferCard;\n+\n+  friend class G1ReleaseCardsets;\n+\n+  static G1CardSetCoarsenStats _coarsen_stats; \/\/ Coarsening statistics since VM start.\n+  static G1CardSetCoarsenStats _last_coarsen_stats; \/\/ Coarsening statistics at last GC.\n+public:\n+  \/\/ Two lower bits are used to encode the card storage types\n+  static const uintptr_t CardSetPtrHeaderSize = 2;\n+\n+  \/\/ CardSetPtr represents the card storage type of a given covered area. It encodes\n+  \/\/ a type in the LSBs, in addition to having a few significant values.\n+  \/\/\n+  \/\/ Possible encodings:\n+  \/\/\n+  \/\/ 0...00000 free               (Empty, should never happen)\n+  \/\/ 1...11111 full               All card indexes in the whole area this CardSetPtr covers are part of this container.\n+  \/\/ X...XXX00 inline-ptr-cards   A handful of card indexes covered by this CardSetPtr are encoded within the CardSetPtr.\n+  \/\/ X...XXX01 array of cards     The container is a contiguous array of card indexes.\n+  \/\/ X...XXX10 bitmap             The container uses a bitmap to determine whether a given index is part of this set.\n+  \/\/ X...XXX11 howl               This is a card set container containing an array of CardSetPtr, with each CardSetPtr\n+  \/\/                              limited to a sub-range of the original range. Currently only one level of this\n+  \/\/                              container is supported.\n+  typedef void* CardSetPtr;\n+  \/\/ Coarsening happens in the order below:\n+  \/\/ CardSetInlinePtr -> CardSetArrayOfCards -> CardSetHowl -> Full\n+  \/\/ Corsening of containers inside the CardSetHowl happens in the order:\n+  \/\/ CardSetInlinePtr -> CardSetArrayOfCards -> CardSetBitMap -> Full\n+  static const uintptr_t CardSetInlinePtr      = 0x0;\n+  static const uintptr_t CardSetArrayOfCards   = 0x1;\n+  static const uintptr_t CardSetBitMap         = 0x2;\n+  static const uintptr_t CardSetHowl           = 0x3;\n+\n+  \/\/ The special sentinel values\n+  static constexpr CardSetPtr FreeCardSet = nullptr;\n+  \/\/ Unfortunately we can't make (G1CardSet::CardSetPtr)-1 constexpr because\n+  \/\/ reinterpret_casts are forbidden in constexprs. Use a regular static instead.\n+  static CardSetPtr FullCardSet;\n+\n+  static const uintptr_t CardSetPtrTypeMask    = ((uintptr_t)1 << CardSetPtrHeaderSize) - 1;\n+\n+  static CardSetPtr strip_card_set_type(CardSetPtr ptr) { return (CardSetPtr)((uintptr_t)ptr & ~CardSetPtrTypeMask); }\n+\n+  static uint card_set_type(CardSetPtr ptr) { return (uintptr_t)ptr & CardSetPtrTypeMask; }\n+\n+  template <class T>\n+  static T* card_set_ptr(CardSetPtr ptr);\n+\n+private:\n+  G1CardSetMemoryManager* _mm;\n+  G1CardSetConfiguration* _config;\n+\n+  G1CardSetHashTable* _table;\n+\n+  \/\/ Total number of cards in this card set. This is a best-effort value, i.e. there may\n+  \/\/ be (slightly) more cards in the card set than this value in reality.\n+  size_t _num_occupied;\n+\n+  CardSetPtr make_card_set_ptr(void* value, uintptr_t type);\n+\n+  CardSetPtr acquire_card_set(CardSetPtr volatile* card_set_addr);\n+  \/\/ Returns true if the card set should be released\n+  bool release_card_set(CardSetPtr card_set);\n+  \/\/ Release card set and free if needed.\n+  void release_and_maybe_free_card_set(CardSetPtr card_set);\n+  \/\/ Release card set and free (and it must be freeable).\n+  void release_and_must_free_card_set(CardSetPtr card_set);\n+\n+  \/\/ Coarsens the CardSet cur_card_set to the next level; tries to replace the\n+  \/\/ previous CardSet with a new one which includes the given card_in_region.\n+  \/\/ coarsen_card_set does not transfer cards from cur_card_set\n+  \/\/ to the new card_set. Transfer is achieved by transfer_cards.\n+  \/\/ Returns true if this was the thread that coarsened the CardSet (and added the card).\n+  bool coarsen_card_set(CardSetPtr volatile* card_set_addr,\n+                        CardSetPtr cur_card_set,\n+                        uint card_in_region, bool within_howl = false);\n+\n+  CardSetPtr create_coarsened_array_of_cards(uint card_in_region, bool within_howl);\n+\n+  \/\/ Transfer entries from source_card_set to a recently installed coarser storage type\n+  \/\/ We only need to transfer anything finer than CardSetBitMap. \"Full\" contains\n+  \/\/ all elements anyway.\n+  void transfer_cards(G1CardSetHashTableValue* table_entry, CardSetPtr source_card_set, uint card_region);\n+  void transfer_cards_in_howl(CardSetPtr parent_card_set, CardSetPtr source_card_set, uint card_region);\n+\n+  G1AddCardResult add_to_card_set(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_region, uint card, bool increment_total = true);\n+\n+  G1AddCardResult add_to_inline_ptr(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_array(CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_bitmap(CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_howl(CardSetPtr parent_card_set, uint card_region, uint card_in_region, bool increment_total = true);\n+\n+  G1CardSetHashTableValue* get_or_add_card_set(uint card_region, bool* should_grow_table);\n+  CardSetPtr get_card_set(uint card_region);\n+\n+  \/\/ Iterate over cards of a card set container during transfer of the cards from\n+  \/\/ one container to another. Executes\n+  \/\/\n+  \/\/     void operator ()(uint card_idx)\n+  \/\/\n+  \/\/ on the given class.\n+  template <class CardVisitor>\n+  void iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& found);\n+\n+  \/\/ Iterate over the container, calling a method on every card or card range contained\n+  \/\/ in the card container.\n+  \/\/ For every container, first calls\n+  \/\/\n+  \/\/   void start_iterate(uint tag, uint region_idx);\n+  \/\/\n+  \/\/ Then for every card or card range it calls\n+  \/\/\n+  \/\/   void do_card(uint card_idx);\n+  \/\/   void do_card_range(uint card_idx, uint length);\n+  \/\/\n+  \/\/ where card_idx is the card index within that region_idx passed before in\n+  \/\/ start_iterate().\n+  \/\/\n+  template <class CardOrRangeVisitor>\n+  void iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found);\n+\n+  uint card_set_type_to_mem_object_type(uintptr_t type) const;\n+  uint8_t* allocate_mem_object(uintptr_t type);\n+  void free_mem_object(CardSetPtr card_set);\n+\n+public:\n+  G1CardSetConfiguration* config() const { return _config; }\n+\n+  \/\/ Create a new remembered set for a particular heap region.\n+  G1CardSet(G1CardSetConfiguration* config, G1CardSetMemoryManager* mm);\n+  virtual ~G1CardSet();\n+\n+  \/\/ Adds the given card to this set, returning an appropriate result. If added,\n+  \/\/ updates the total count.\n+  G1AddCardResult add_card(uint card_region, uint card_in_region, bool increment_total = true);\n+\n+  bool contains_card(uint card_region, uint card_in_region);\n+\n+  void print_info(outputStream* st, uint card_region, uint card_in_region);\n+\n+  \/\/ Returns whether this remembered set (and all sub-sets) have an occupancy\n+  \/\/ that is less or equal to the given occupancy.\n+  bool occupancy_less_or_equal_to(size_t limit) const;\n+\n+  \/\/ Returns whether this remembered set (and all sub-sets) does not contain any entry.\n+  bool is_empty() const;\n+\n+  \/\/ Returns the number of cards contained in this remembered set.\n+  size_t occupied() const;\n+\n+  size_t num_containers();\n+\n+  static G1CardSetCoarsenStats coarsen_stats();\n+  static void print_coarsen_stats(outputStream* out);\n+\n+  \/\/ Returns size of the actual remembered set containers in bytes.\n+  size_t mem_size() const;\n+  size_t wasted_mem_size() const;\n+  \/\/ Returns the size of static data in bytes.\n+  static size_t static_mem_size();\n+\n+  \/\/ Clear the entire contents of this remembered set.\n+  void clear();\n+\n+  void print(outputStream* os);\n+\n+  \/\/ Various iterators - should be made inlineable somehow.\n+  class G1CardSetPtrIterator {\n+  public:\n+    virtual void do_cardsetptr(uint region_idx, size_t num_occupied, CardSetPtr card_set) = 0;\n+  };\n+\n+  void iterate_containers(G1CardSetPtrIterator* iter, bool safepoint = false);\n+\n+  class G1CardSetCardIterator {\n+  public:\n+    virtual void do_card(uint region_idx, uint card_idx) = 0;\n+  };\n+\n+  void iterate_cards(G1CardSetCardIterator& iter);\n+\n+  \/\/ Iterate all cards for card set merging. Must be a CardOrRangeVisitor as\n+  \/\/ explained above.\n+  template <class CardOrRangeVisitor>\n+  void iterate_for_merge(CardOrRangeVisitor& cl);\n+};\n+\n+class G1CardSetHashTableValue {\n+public:\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  const uint _region_idx;\n+  uint volatile _num_occupied;\n+  CardSetPtr volatile _card_set;\n+\n+  G1CardSetHashTableValue(uint region_idx, CardSetPtr card_set) : _region_idx(region_idx), _num_occupied(0), _card_set(card_set) { }\n+};\n+\n+class G1CardSetHashTableConfig : public StackObj {\n+public:\n+  using Value = G1CardSetHashTableValue;\n+\n+  static uintx get_hash(Value const& value, bool* is_dead) {\n+    *is_dead = false;\n+    return value._region_idx;\n+  }\n+  static void* allocate_node(void* context, size_t size, Value const& value);\n+  static void free_node(void* context, void* memory, Value const& value);\n+};\n+\n+typedef ConcurrentHashTable<G1CardSetHashTableConfig, mtGCCardSet> CardSetHash;\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":376,"deletions":0,"binary":false,"changes":376,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSET_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSET_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+template <class T>\n+inline T* G1CardSet::card_set_ptr(CardSetPtr ptr) {\n+  return (T*)strip_card_set_type(ptr);\n+}\n+\n+inline G1CardSet::CardSetPtr G1CardSet::make_card_set_ptr(void* value, uintptr_t type) {\n+  assert(card_set_type(value) == 0, \"Given ptr \" PTR_FORMAT \" already has type bits set\", p2i(value));\n+  return (CardSetPtr)((uintptr_t)value | type);\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSet::iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found) {\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedInline)) {\n+        G1CardSetInlinePtr ptr(card_set);\n+        ptr.iterate(found, _config->inline_ptr_bits_per_card());\n+      }\n+      return;\n+    }\n+    case CardSetArrayOfCards : {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedArrayOfCards)) {\n+        card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      }\n+      return;\n+    }\n+    case CardSetBitMap: {\n+      \/\/ There is no first-level bitmap spanning the whole area.\n+      ShouldNotReachHere();\n+      return;\n+    }\n+    case CardSetHowl: {\n+      assert(card_set_type(FullCardSet) == CardSetHowl, \"Must be\");\n+      if (card_set == FullCardSet) {\n+        if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedFull)) {\n+          found(0, _config->max_cards_in_region());\n+        }\n+        return;\n+      }\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedHowl)) {\n+        card_set_ptr<G1CardSetHowl>(card_set)->iterate(found, _config);\n+      }\n+      return;\n+    }\n+  }\n+  log_error(gc)(\"Unkown card set type %u\", card_set_type(card_set));\n+  ShouldNotReachHere();\n+}\n+\n+template <typename Closure>\n+class G1ContainerCardsOrRanges {\n+  Closure& _iter;\n+  uint _region_idx;\n+\n+public:\n+  G1ContainerCardsOrRanges(Closure& iter, uint region_idx) : _iter(iter), _region_idx(region_idx) { }\n+\n+  bool start_iterate(uint tag) {\n+    return _iter.start_iterate(tag, _region_idx);\n+  }\n+\n+  void operator()(uint card_idx) {\n+    _iter.do_card(card_idx);\n+  }\n+\n+  void operator()(uint card_idx, uint length) {\n+    _iter.do_card_range(card_idx, length);\n+  }\n+};\n+\n+template <typename Closure, template <typename> class CardOrRanges>\n+class G1CardSetMergeCardIterator : public G1CardSet::G1CardSetPtrIterator {\n+  G1CardSet* _card_set;\n+  Closure& _iter;\n+\n+public:\n+\n+  G1CardSetMergeCardIterator(G1CardSet* card_set, Closure& iter) : _card_set(card_set), _iter(iter) { }\n+\n+  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+    CardOrRanges<Closure> cl(_iter, region_idx);\n+    _card_set->iterate_cards_or_ranges_in_container(card_set, cl);\n+  }\n+};\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n+  G1CardSetMergeCardIterator<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(this, cl);\n+  iterate_containers(&cl2, true \/* at_safepoint *\/);\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.inline.hpp","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n+#define SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+\n+#include \"runtime\/thread.inline.hpp\"\n+\n+class G1CardSetInlinePtr : public StackObj {\n+  friend class G1CardSetContainersTest;\n+\n+  typedef G1CardSet::CardSetPtr CardSetPtr;\n+\n+  CardSetPtr volatile * _value_addr;\n+  CardSetPtr _value;\n+\n+  static const uint SizeFieldLen = 3;\n+  static const uint SizeFieldPos = 2;\n+  static const uint HeaderSize = G1CardSet::CardSetPtrHeaderSize + SizeFieldLen;\n+\n+  static const uint BitsInValue = sizeof(CardSetPtr) * BitsPerByte;\n+\n+  static const uintptr_t SizeFieldMask = (((uint)1 << SizeFieldLen) - 1) << SizeFieldPos;\n+\n+  static uint8_t card_pos_for(uint const idx, uint const bits_per_card) {\n+    return (idx * bits_per_card + HeaderSize);\n+  }\n+\n+  static CardSetPtr merge(CardSetPtr orig_value, uint card_in_region, uint idx, uint bits_per_card);\n+\n+  static uint card_at(CardSetPtr value, uint const idx, uint const bits_per_card) {\n+    uint8_t card_pos = card_pos_for(idx, bits_per_card);\n+    uint result = ((uintptr_t)value >> card_pos) & (((uintptr_t)1 << bits_per_card) - 1);\n+    return result;\n+  }\n+public:\n+  G1CardSetInlinePtr() : _value_addr(nullptr), _value((CardSetPtr)G1CardSet::CardSetInlinePtr) { }\n+\n+  G1CardSetInlinePtr(CardSetPtr value) : _value_addr(nullptr), _value(value) {\n+    assert(((uintptr_t)_value & G1CardSet::CardSetInlinePtr) == G1CardSet::CardSetInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInPtr.\", p2i(_value));\n+  }\n+\n+  G1CardSetInlinePtr(CardSetPtr volatile* value_addr, CardSetPtr value) : _value_addr(value_addr), _value(value) {\n+    assert(((uintptr_t)_value & G1CardSet::CardSetInlinePtr) == G1CardSet::CardSetInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInPtr.\", p2i(_value));\n+  }\n+\n+  G1AddCardResult add(uint const card_idx, uint const bits_per_card, uint const max_cards_in_inline_ptr);\n+\n+  bool contains(uint const card_idx, uint const bits_per_card);\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found, uint const bits_per_card);\n+\n+  operator CardSetPtr () { return _value; }\n+\n+  static uint max_cards_in_inline_ptr(uint bits_per_card) {\n+    return (BitsInValue - HeaderSize) \/ bits_per_card;\n+  }\n+\n+  static uint num_cards_in(CardSetPtr value) {\n+    return ((uintptr_t)value & SizeFieldMask) >> SizeFieldPos;\n+  }\n+};\n+\n+\n+\/\/ Common base class for card set containers where the memory for the entries is\n+\/\/ managed on the (C-)heap. Depending on the current use, one of the two overlapping\n+\/\/ members are used:\n+\/\/\n+\/\/ While such an object is assigned to a card set container, we utilize the\n+\/\/ reference count for memory management.\n+\/\/\n+\/\/ In this case the object is one of three states:\n+\/\/ 1: Live: The object is visible to other threads, thus can\n+\/\/    safely be accessed by other threads (_ref_count >= 3).\n+\/\/ 2: Dead: The object is visible to only a single thread and may be\n+\/\/    safely reclaimed (_ref_count == 1).\n+\/\/ 3: Reclaimed: The object's memory has been reclaimed ((_ref_count & 0x1) == 0).\n+\/\/ To maintain these constraints, live objects should have ((_ref_count & 0x1) == 1),\n+\/\/ which requires that we increment the reference counts by 2 starting at _ref_count = 3.\n+\/\/\n+\/\/ When such an object is on a free list, we reuse the same field for linking\n+\/\/ together those free objects.\n+\/\/\n+\/\/ All but inline pointers are of this kind. For those, card entries are stored\n+\/\/ directly in the CardSetPtr of the ConcurrentHashTable node.\n+class G1CardSetContainer {\n+private:\n+  union {\n+    G1CardSetContainer* _next;\n+    uintptr_t _ref_count;\n+  };\n+\n+public:\n+  G1CardSetContainer() : _ref_count(3) { }\n+\n+  uintptr_t refcount() const { return Atomic::load_acquire(&_ref_count); }\n+\n+  bool try_increment_refcount();\n+\n+  \/\/ Decrement refcount potentially while racing increment, so we need\n+  \/\/ to check the value after attempting to decrement.\n+  uintptr_t decrement_refcount();\n+\n+  G1CardSetContainer* next() {\n+    return _next;\n+  }\n+\n+  G1CardSetContainer** next_addr() {\n+    return &_next;\n+  }\n+\n+  void set_next(G1CardSetContainer* next) {\n+    _next = next;\n+  }\n+};\n+\n+class G1CardSetArray : public G1CardSetContainer {\n+public:\n+  typedef uint16_t EntryDataType;\n+  typedef uint EntryCountType;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+private:\n+  EntryCountType _size;\n+  EntryCountType volatile _num_entries;\n+  EntryDataType _data[2];\n+\n+  static const EntryCountType LockBitMask = (EntryCountType)1 << (sizeof(EntryCountType) * BitsPerByte - 1);\n+  static const EntryCountType EntryMask = LockBitMask - 1;\n+\n+  class G1CardSetArrayLocker : public StackObj {\n+    EntryCountType volatile* _value;\n+    EntryCountType volatile _original_value;\n+    bool _success;\n+  public:\n+    G1CardSetArrayLocker(EntryCountType volatile* value);\n+\n+    EntryCountType num_entries() const { return _original_value; }\n+    void inc_num_entries() { _success = true; }\n+\n+    ~G1CardSetArrayLocker() {\n+      assert(((_original_value + _success) & EntryMask) == (EntryCountType)(_original_value + _success), \"precondition!\" );\n+\n+      Atomic::release_store(_value, (EntryCountType)(_original_value + _success));\n+    }\n+  };\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _data);\n+  }\n+\n+public:\n+  G1CardSetArray(uint const card_in_region, EntryCountType num_elems);\n+\n+  G1AddCardResult add(uint card_idx);\n+\n+  bool contains(uint card_idx);\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found);\n+\n+  size_t num_entries() const { return _num_entries & EntryMask; }\n+  size_t max_entries() const { return _size; }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetArray>(); }\n+\n+  static size_t size_in_bytes(size_t num_cards) {\n+    return header_size_in_bytes() + sizeof(EntryDataType) * num_cards;\n+  }\n+};\n+\n+class G1CardSetBitMap : public G1CardSetContainer {\n+  size_t _num_bits_set;\n+  BitMap::bm_word_t _bits[1];\n+\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _bits);\n+  }\n+\n+public:\n+  G1CardSetBitMap(uint const card_in_region, uint const size_in_bits);\n+\n+  G1AddCardResult add(uint card_idx, size_t threshold, size_t size_in_bits);\n+\n+  bool contains(uint card_idx, size_t size_in_bits) {\n+    BitMapView bm(_bits, size_in_bits);\n+    return bm.at(card_idx);\n+  }\n+\n+  uint num_bits_set() const { return (uint)_num_bits_set; }\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found, size_t const size_in_bits, uint offset);\n+\n+  uint next(uint const idx, size_t const size_in_bits) {\n+    BitMapView bm(_bits, size_in_bits);\n+    return static_cast<uint>(bm.get_next_one_offset(idx));\n+  }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetBitMap>(); }\n+\n+  static size_t size_in_bytes(size_t size_in_bits) { return header_size_in_bytes() + BitMap::calc_size_in_words(size_in_bits) * BytesPerWord; }\n+};\n+\n+class G1CardSetHowl : public G1CardSetContainer {\n+public:\n+  typedef uint EntryCountType;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+  EntryCountType volatile _num_entries;\n+private:\n+  CardSetPtr _buckets[2];\n+  \/\/ Do not add class member variables beyond this point\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _buckets);\n+  }\n+\n+  \/\/ Iterates over the given CardSetPtr with at index in this Howl card set,\n+  \/\/ applying a CardOrRangeVisitor on it.\n+  template <class CardOrRangeVisitor>\n+  void iterate_cardset(CardSetPtr const card_set, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config);\n+\n+public:\n+  G1CardSetHowl(EntryCountType card_in_region, G1CardSetConfiguration* config);\n+\n+  CardSetPtr* get_card_set_addr(EntryCountType index) {\n+    return &_buckets[index];\n+  }\n+\n+  bool contains(uint card_idx, G1CardSetConfiguration* config);\n+\n+  \/\/ Iterates over all CardSetPtrs in this Howl card set, applying a CardOrRangeVisitor\n+  \/\/ on it.\n+  template <class CardOrRangeVisitor>\n+  void iterate(CardOrRangeVisitor& found, G1CardSetConfiguration* config);\n+\n+  \/\/ Iterates over all CardSetPtrs in this Howl card set. Calls\n+  \/\/\n+  \/\/   void operator ()(CardSetPtr* card_set_addr);\n+  \/\/\n+  \/\/ on all of them.\n+  template <class CardSetPtrVisitor>\n+  void iterate(CardSetPtrVisitor& found, uint num_card_sets);\n+\n+  static EntryCountType num_buckets(size_t size_in_bits, size_t num_cards_in_array, size_t max_buckets);\n+\n+  static EntryCountType bitmap_size(size_t size_in_bits, uint num_buckets) {\n+    EntryCountType num_cards = (EntryCountType)size_in_bits \/ num_buckets;\n+    return round_up_power_of_2(num_cards);\n+  }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetHowl>(); }\n+\n+  static size_t size_in_bytes(size_t num_arrays) {\n+    return header_size_in_bytes() + sizeof(CardSetPtr) * num_arrays;\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -0,0 +1,341 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n+\n+inline G1CardSetInlinePtr::CardSetPtr G1CardSetInlinePtr::merge(CardSetPtr orig_value, uint card_in_region, uint idx, uint bits_per_card) {\n+  assert((idx & (SizeFieldMask >> SizeFieldPos)) == idx, \"Index %u too large to fit into size field\", idx);\n+  assert(card_in_region < ((uint)1 << bits_per_card), \"Card %u too large to fit into card value field\", card_in_region);\n+\n+  uint8_t card_pos = card_pos_for(idx, bits_per_card);\n+  assert(card_pos + bits_per_card < BitsInValue, \"Putting card at pos %u with %u bits would extend beyond pointer\", card_pos, bits_per_card);\n+\n+  \/\/ Check that we do not touch any fields we do not own.\n+  uintptr_t mask = ((((uintptr_t)1 << bits_per_card) - 1) << card_pos);\n+  assert(((uintptr_t)orig_value & mask) == 0, \"The bits in the new range should be empty; orig_value \" PTR_FORMAT \" mask \" PTR_FORMAT, p2i(orig_value), mask);\n+\n+  uintptr_t value = ((uintptr_t)(idx + 1) << SizeFieldPos) | ((uintptr_t)card_in_region << card_pos);\n+  uintptr_t res = (((uintptr_t)orig_value & ~SizeFieldMask) | value);\n+  return (CardSetPtr)res;\n+}\n+\n+inline G1AddCardResult G1CardSetInlinePtr::add(uint card_idx, uint bits_per_card, uint max_cards_in_inline_ptr) {\n+  assert(_value_addr != nullptr, \"No value address available, cannot add to set.\");\n+\n+  while (true) {\n+    uint num_elems = num_cards_in(_value);\n+    \/\/ Check if the card is already stored in the pointer.\n+    if (contains(card_idx, bits_per_card)) {\n+      return Found;\n+    }\n+    \/\/ Check if there is actually enough space.\n+    if (num_elems >= max_cards_in_inline_ptr) {\n+      return Overflow;\n+    }\n+    CardSetPtr new_value = merge(_value, card_idx, num_elems, bits_per_card);\n+    CardSetPtr old_value = Atomic::cmpxchg(_value_addr, _value, new_value, memory_order_relaxed);\n+    if (_value == old_value) {\n+      return Added;\n+    }\n+    \/\/ Update values and retry.\n+    _value = old_value;\n+    \/\/ The value of the pointer may have changed to something different than\n+    \/\/ an inline card set. Exit then instead of overwriting.\n+    if (G1CardSet::card_set_type(_value) != G1CardSet::CardSetInlinePtr) {\n+      return Overflow;\n+    }\n+  }\n+}\n+\n+inline bool G1CardSetInlinePtr::contains(uint card_idx, uint bits_per_card) {\n+  uint num_elems = num_cards_in(_value);\n+  uintptr_t const card_mask = (1 << bits_per_card) - 1;\n+\n+  uintptr_t value = ((uintptr_t)_value) >> card_pos_for(0, bits_per_card);\n+  \/\/ Check if the card is already stored in the pointer.\n+  for (uint cur_idx = 0; cur_idx < num_elems; cur_idx++) {\n+    if ((value & card_mask) == card_idx) {\n+      return true;\n+    }\n+    value >>= bits_per_card;\n+  }\n+  return false;\n+}\n+\n+template <class CardVisitor>\n+inline void G1CardSetInlinePtr::iterate(CardVisitor& found, uint bits_per_card) {\n+  uint const num_elems = num_cards_in(_value);\n+  uintptr_t const card_mask = (1 << bits_per_card) - 1;\n+\n+  uintptr_t value = ((uintptr_t)_value) >> card_pos_for(0, bits_per_card);\n+  for (uint cur_idx = 0; cur_idx < num_elems; cur_idx++) {\n+    found(value & card_mask);\n+    value >>= bits_per_card;\n+  }\n+}\n+\n+inline bool G1CardSetContainer::try_increment_refcount() {\n+  uintptr_t old_value = refcount();\n+  while (true) {\n+    if (old_value < 3 || (old_value & 0x1) == 0) {  \/\/ reclaimed,  reference counts are odd numbers starting at 3\n+      return false; \/\/ dead, can't revive.\n+    }\n+\n+    uintptr_t new_value = old_value + 2;\n+    uintptr_t ref_count = Atomic::cmpxchg(&_ref_count, old_value, new_value);\n+    if (ref_count == old_value) {\n+      return true;\n+    }\n+    old_value = ref_count;\n+  }\n+}\n+\n+inline uintptr_t G1CardSetContainer::decrement_refcount() {\n+  uintptr_t old_value = refcount();\n+  assert((old_value & 0x1) != 0 && old_value >= 3, \"precondition\");\n+  return Atomic::sub(&_ref_count, 2u);\n+}\n+\n+inline G1CardSetArray::G1CardSetArray(uint card_in_region, EntryCountType num_elems) :\n+  G1CardSetContainer(),\n+  _size(num_elems),\n+  _num_entries(1) {\n+  assert(_size > 0, \"CardSetArray of size 0 not supported.\");\n+  assert(_size < LockBitMask, \"Only support CardSetArray of size %u or smaller.\", LockBitMask - 1);\n+  _data[0] = card_in_region;\n+}\n+\n+inline G1CardSetArray::G1CardSetArrayLocker::G1CardSetArrayLocker(EntryCountType volatile* value) :\n+  _value(value),\n+  _success(false) {\n+  SpinYield s;\n+  EntryCountType original_value = (*_value) & EntryMask;\n+  while (true) {\n+    EntryCountType old_value = Atomic::cmpxchg(_value,\n+                                               original_value,\n+                                               (EntryCountType)(original_value | LockBitMask));\n+    if (old_value == original_value) {\n+      \/\/ Succeeded locking the array.\n+      _original_value = original_value;\n+      break;\n+    }\n+    \/\/ Failed. Retry (with the lock bit stripped again).\n+    original_value = old_value & EntryMask;\n+    s.wait();\n+  }\n+}\n+\n+inline G1AddCardResult G1CardSetArray::add(uint card_idx) {\n+  assert(card_idx < (1u << (sizeof(_data[0]) * BitsPerByte)),\n+         \"Card index %u does not fit card element.\", card_idx);\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+  EntryCountType idx = 0;\n+  for (; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return Found;\n+    }\n+  }\n+\n+  \/\/ Since we did not find the card, lock.\n+  G1CardSetArrayLocker x(&_num_entries);\n+\n+  \/\/ Reload number of entries from the G1CardSetArrayLocker as it might have changed.\n+  \/\/ It already read the actual value with the necessary synchronization.\n+  num_entries = x.num_entries();\n+  \/\/ Look if the elements added while waiting for the lock are the same as our card.\n+  for (; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return Found;\n+    }\n+  }\n+\n+  \/\/ Check if there is space left.\n+  if (num_entries == _size) {\n+    return Overflow;\n+  }\n+\n+  _data[num_entries] = card_idx;\n+\n+  x.inc_num_entries();\n+\n+  return Added;\n+}\n+\n+inline bool G1CardSetArray::contains(uint card_idx) {\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+\n+  for (EntryCountType idx = 0; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+template <class CardVisitor>\n+void G1CardSetArray::iterate(CardVisitor& found) {\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+  for (EntryCountType idx = 0; idx < num_entries; idx++) {\n+    found(_data[idx]);\n+  }\n+}\n+\n+inline G1CardSetBitMap::G1CardSetBitMap(uint card_in_region, uint size_in_bits) :\n+  G1CardSetContainer(), _num_bits_set(1) {\n+  assert(size_in_bits % (sizeof(_bits[0]) * BitsPerByte) == 0,\n+         \"Size %u should be aligned to bitmap word size.\", size_in_bits);\n+  BitMapView bm(_bits, size_in_bits);\n+  bm.clear();\n+  bm.set_bit(card_in_region);\n+}\n+\n+inline G1AddCardResult G1CardSetBitMap::add(uint card_idx, size_t threshold, size_t size_in_bits) {\n+  BitMapView bm(_bits, size_in_bits);\n+  if (_num_bits_set >= threshold) {\n+    return bm.at(card_idx) ? Found : Overflow;\n+  }\n+  if (bm.par_set_bit(card_idx)) {\n+    Atomic::inc(&_num_bits_set, memory_order_relaxed);\n+    return Added;\n+  }\n+  return Found;\n+}\n+\n+template <class CardVisitor>\n+inline void G1CardSetBitMap::iterate(CardVisitor& found, size_t size_in_bits, uint offset) {\n+  BitMapView bm(_bits, size_in_bits);\n+  BitMap::idx_t idx = bm.get_next_one_offset(0);\n+  while (idx != size_in_bits) {\n+    found((offset | (uint)idx));\n+    idx = bm.get_next_one_offset(idx + 1);\n+  }\n+}\n+\n+inline G1CardSetHowl::G1CardSetHowl(EntryCountType card_in_region, G1CardSetConfiguration* config) :\n+  G1CardSetContainer(),\n+  _num_entries((config->num_cards_in_array() + 1)) \/* Card Transfer will not increment _num_entries *\/ {\n+  EntryCountType num_buckets = config->num_buckets_in_howl();\n+  EntryCountType bucket = config->howl_bucket_index(card_in_region);\n+  for (uint i = 0; i < num_buckets; ++i) {\n+    _buckets[i] = G1CardSetInlinePtr();\n+    if (i == bucket) {\n+      G1CardSetInlinePtr value(&_buckets[i], _buckets[i]);\n+      value.add(card_in_region, config->inline_ptr_bits_per_card(), config->num_cards_in_inline_ptr());\n+    }\n+  }\n+}\n+\n+inline bool G1CardSetHowl::contains(uint card_idx, G1CardSetConfiguration* config) {\n+  EntryCountType bucket = config->howl_bucket_index(card_idx);\n+  CardSetPtr* array_entry = get_card_set_addr(bucket);\n+  CardSetPtr card_set = Atomic::load_acquire(array_entry);\n+\n+  switch (G1CardSet::card_set_type(card_set)) {\n+    case G1CardSet::CardSetArrayOfCards : {\n+      return G1CardSet::card_set_ptr<G1CardSetArray>(card_set)->contains(card_idx);\n+    }\n+    case G1CardSet::CardSetBitMap: {\n+      uint card_offset = config->howl_bitmap_offset(card_idx);\n+      return G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_offset, config->num_cards_in_howl_bitmap());\n+    }\n+    case G1CardSet::CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      return ptr.contains(card_idx, config->inline_ptr_bits_per_card());\n+    }\n+    case G1CardSet::CardSetHowl: {\/\/ Fullcard set entry\n+      assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSetHowl::iterate(CardOrRangeVisitor& found, G1CardSetConfiguration* config) {\n+  for (uint i = 0; i < config->num_buckets_in_howl(); ++i) {\n+    iterate_cardset(_buckets[i], i, found, config);\n+  }\n+}\n+\n+template <class CardSetPtrVisitor>\n+inline void G1CardSetHowl::iterate(CardSetPtrVisitor& found, uint num_card_sets) {\n+  for (uint i = 0; i < num_card_sets; ++i) {\n+    found(&_buckets[i]);\n+  }\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSetHowl::iterate_cardset(CardSetPtr const card_set, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config) {\n+  switch (G1CardSet::card_set_type(card_set)) {\n+    case G1CardSet::CardSetInlinePtr: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlInline)) {\n+        G1CardSetInlinePtr ptr(card_set);\n+        ptr.iterate(found, config->inline_ptr_bits_per_card());\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetArrayOfCards : {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlArrayOfCards)) {\n+        G1CardSet::card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetBitMap: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlBitmap)) {\n+        uint offset = index << config->log2_num_cards_in_howl_bitmap();\n+        G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->iterate(found, config->num_cards_in_howl_bitmap(), offset);\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetHowl: { \/\/ actually FullCardSet\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlFull)) {\n+        assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n+        uint offset = index << config->log2_num_cards_in_howl_bitmap();\n+        for (uint i = 0; i < config->max_cards_in_region(); i++) {\n+          found((offset | (uint)i));\n+        }\n+      }\n+      return;\n+    }\n+  }\n+}\n+\n+inline G1CardSetHowl::EntryCountType G1CardSetHowl::num_buckets(size_t size_in_bits, size_t num_cards_in_array, size_t max_num_buckets) {\n+  size_t size_bitmap_bytes = BitMap::calc_size_in_words(size_in_bits) * BytesPerWord;\n+  \/\/ Ensure that in the worst case arrays consume half the memory size\n+  \/\/ of storing the entire bitmap\n+  size_t max_size_arrays_bytes = size_bitmap_bytes \/ 2;\n+  size_t size_array_bytes = num_cards_in_array * sizeof(G1CardSetArray::EntryDataType);\n+  size_t num_arrays = max_size_arrays_bytes \/ size_array_bytes;\n+  \/\/ We use shifts and masks for indexing the array. So round down to the next\n+  \/\/ power of two to not use more than expected memory.\n+  num_arrays = round_down_power_of_2(MAX2((size_t)1, MIN2(num_arrays, max_num_buckets)));\n+  return (EntryCountType)num_arrays;\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":341,"deletions":0,"binary":false,"changes":341,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"heapRegionRemSet.hpp\"\n+#include \"ci\/ciUtilities.hpp\"\n+\n+constexpr const char* G1CardSetFreeMemoryTask::_state_names[];\n+\n+const char* G1CardSetFreeMemoryTask::get_state_name(State value) const {\n+  return _state_names[static_cast<std::underlying_type_t<State>>(value)];\n+}\n+\n+bool G1CardSetFreeMemoryTask::deadline_exceeded(jlong deadline) {\n+  return os::elapsed_counter() >= deadline;\n+}\n+\n+static size_t keep_size(size_t free, size_t used, double percent) {\n+  size_t to_keep = used * percent;\n+  return MIN2(free, to_keep);\n+}\n+\n+bool G1CardSetFreeMemoryTask::calculate_return_infos(jlong deadline) {\n+  \/\/ Ignore the deadline in this step as it is very short.\n+\n+  G1CardSetMemoryStats used = _total_used;\n+  G1CardSetMemoryStats free = G1CardSetFreePool::free_list_sizes();\n+\n+  _return_info = new G1ReturnMemoryProcessorSet(used.num_pools());\n+  for (uint i = 0; i < used.num_pools(); i++) {\n+    size_t return_to_vm_size = keep_size(free._num_mem_sizes[i],\n+                                         used._num_mem_sizes[i],\n+                                         G1RemSetFreeMemoryKeepExcessRatio);\n+    log_trace(gc, task)(\"Card Set Free Memory: Type %s: Free: %zu (%zu) \"\n+                        \"Used: %zu Keep: %zu\",\n+                        G1CardSetConfiguration::mem_object_type_name_str(i),\n+                        free._num_mem_sizes[i], free._num_buffers[i],\n+                        used._num_mem_sizes[i], return_to_vm_size);\n+\n+    _return_info->append(new G1ReturnMemoryProcessor(return_to_vm_size));\n+  }\n+\n+  G1CardSetFreePool::update_unlink_processors(_return_info);\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::return_memory_to_vm(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_vm()) {\n+      if (info->return_to_vm(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::return_memory_to_os(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_os()) {\n+      if (info->return_to_os(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::cleanup_return_infos() {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+     G1ReturnMemoryProcessor* info = _return_info->at(i);\n+     delete info;\n+  }\n+  delete _return_info;\n+\n+  _return_info = nullptr;\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::free_excess_card_set_memory() {\n+  jlong start = os::elapsed_counter();\n+  jlong end = start +\n+              (os::elapsed_frequency() \/ 1000) * G1RemSetFreeMemoryStepDurationMillis;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Step start %1.3f end %1.3f\",\n+                      TimeHelper::counter_to_millis(start), TimeHelper::counter_to_millis(end));\n+\n+  State next_state;\n+\n+  do {\n+    switch (_state) {\n+      case State::CalculateUsed: {\n+        if (calculate_return_infos(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToVM;\n+        break;\n+      }\n+      case State::ReturnToVM: {\n+        if (return_memory_to_vm(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToOS;\n+        break;\n+      }\n+      case State::ReturnToOS: {\n+        if (return_memory_to_os(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::Cleanup;\n+        break;\n+      }\n+      case State::Cleanup: {\n+        cleanup_return_infos();\n+        next_state = State::Inactive;\n+        break;\n+      }\n+      default:\n+        log_error(gc, task)(\"Should not try to free excess card set memory in %s state\", get_state_name(_state));\n+        ShouldNotReachHere();\n+        break;\n+    }\n+\n+    set_state(next_state);\n+  } while (_state != State::Inactive && !deadline_exceeded(end));\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Step took %1.3fms, done %s\",\n+                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n+                      bool_to_str(_state == State::CalculateUsed));\n+\n+  return is_active();\n+}\n+\n+void G1CardSetFreeMemoryTask::set_state(State new_state) {\n+  log_trace(gc, task)(\"Card Set Free Memory: State change from %s to %s\",\n+                      get_state_name(_state),\n+                      get_state_name(new_state));\n+  _state = new_state;\n+}\n+\n+bool G1CardSetFreeMemoryTask::is_active() const {\n+  return _state != State::Inactive;\n+}\n+\n+jlong G1CardSetFreeMemoryTask::reschedule_delay_ms() const {\n+  return G1RemSetFreeMemoryRescheduleDelayMillis;\n+}\n+\n+G1CardSetFreeMemoryTask::G1CardSetFreeMemoryTask(const char* name) :\n+  G1ServiceTask(name), _state(State::CalculateUsed), _return_info(nullptr) { }\n+\n+void G1CardSetFreeMemoryTask::execute() {\n+  SuspendibleThreadSetJoiner sts;\n+\n+  if (free_excess_card_set_memory()) {\n+    schedule(reschedule_delay_ms());\n+  }\n+}\n+\n+void G1CardSetFreeMemoryTask::notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n+                                               G1CardSetMemoryStats* collection_set_candidate_stats) {\n+  assert_at_safepoint_on_vm_thread();\n+\n+  _total_used = *young_gen_stats;\n+  _total_used.add(*collection_set_candidate_stats);\n+\n+  if (!is_active()) {\n+    set_state(State::CalculateUsed);\n+    G1CollectedHeap::heap()->service_thread()->schedule_task(this, 0);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.cpp","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n+#define SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n+\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+class G1CardSetBuffer;\n+\n+\/\/ Task handling deallocation of free card set memory.\n+class G1CardSetFreeMemoryTask : public G1ServiceTask {\n+\n+  enum class State : uint {\n+    Inactive,\n+    CalculateUsed,\n+    ReturnToVM,\n+    ReturnToOS,\n+    Cleanup\n+  };\n+\n+  static constexpr const char* _state_names[] = { \"Invalid\",\n+                                                  \"CalculateUsed\",\n+                                                  \"ReturnToVM\",\n+                                                  \"ReturnToOS\",\n+                                                  \"Cleanup\" };\n+\n+  const char* get_state_name(State value) const;\n+\n+  State _state;\n+\n+  \/\/ Current total card set memory usage.\n+  G1CardSetMemoryStats _total_used;\n+\n+  typedef G1CardSetFreePool::G1ReturnMemoryProcessor G1ReturnMemoryProcessor;\n+  typedef G1CardSetFreePool::G1ReturnMemoryProcessorSet G1ReturnMemoryProcessorSet;\n+\n+  G1ReturnMemoryProcessorSet* _return_info;\n+\n+  \/\/ Returns whether the given deadline has passed.\n+  bool deadline_exceeded(jlong deadline);\n+\n+  \/\/ Methods for the tasks to be done. They all return true if that step has\n+  \/\/ completed.\n+  bool calculate_return_infos(jlong deadline);\n+  bool return_memory_to_vm(jlong deadline);\n+  bool return_memory_to_os(jlong deadline);\n+  bool cleanup_return_infos();\n+\n+  \/\/ Free excess card set memory, main method. Returns true if there is more work\n+  \/\/ to do.\n+  bool free_excess_card_set_memory();\n+\n+  void set_state(State new_state);\n+  \/\/ Returns whether we are currently processing a recent request.\n+  bool is_active() const;\n+\n+  \/\/ The delay used to reschedule this task if not all work has been completed.\n+  jlong reschedule_delay_ms() const;\n+\n+public:\n+  explicit G1CardSetFreeMemoryTask(const char* name);\n+\n+  void execute() override;\n+\n+  \/\/ Notify the task of new used remembered set memory statistics for the young\n+  \/\/ generation and the collection set candidate sets.\n+  void notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n+                        G1CardSetMemoryStats* collection_set_candidate_stats);\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,478 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+G1CardSetBuffer::G1CardSetBuffer(uint elem_size, uint num_instances, G1CardSetBuffer* next) :\n+    _elem_size(elem_size), _num_elems(num_instances), _next(next), _next_allocate(0) {\n+\n+  _buffer = NEW_C_HEAP_ARRAY(char, (size_t)_num_elems * elem_size, mtGCCardSet);\n+}\n+\n+G1CardSetBuffer::~G1CardSetBuffer() {\n+  FREE_C_HEAP_ARRAY(mtGCCardSet, _buffer);\n+}\n+\n+void* G1CardSetBuffer::get_new_buffer_elem() {\n+  if (_next_allocate >= _num_elems) {\n+    return nullptr;\n+  }\n+  uint result = Atomic::fetch_and_add(&_next_allocate, 1u, memory_order_relaxed);\n+  if (result >= _num_elems) {\n+    return nullptr;\n+  }\n+  void* r = _buffer + (uint)result * _elem_size;\n+  return r;\n+}\n+\n+void G1CardSetBufferList::bulk_add(G1CardSetBuffer& first, G1CardSetBuffer& last, size_t num, size_t mem_size) {\n+  _list.prepend(first, last);\n+  Atomic::add(&_num_buffers, num, memory_order_relaxed);\n+  Atomic::add(&_mem_size, mem_size, memory_order_relaxed);\n+}\n+\n+void G1CardSetBufferList::print_on(outputStream* out, const char* prefix) {\n+  out->print_cr(\"%s: buffers %zu size %zu\", prefix, Atomic::load(&_num_buffers), Atomic::load(&_mem_size));\n+}\n+\n+G1CardSetBuffer* G1CardSetBufferList::get() {\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+\n+  G1CardSetBuffer* result = _list.pop();\n+  if (result != nullptr) {\n+    Atomic::dec(&_num_buffers, memory_order_relaxed);\n+    Atomic::sub(&_mem_size, result->mem_size(), memory_order_relaxed);\n+  }\n+  return result;\n+}\n+\n+G1CardSetBuffer* G1CardSetBufferList::get_all(size_t& num_buffers, size_t& mem_size) {\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+\n+  G1CardSetBuffer* result = _list.pop_all();\n+  num_buffers = Atomic::load(&_num_buffers);\n+  mem_size = Atomic::load(&_mem_size);\n+\n+  if (result != nullptr) {\n+    Atomic::sub(&_num_buffers, num_buffers, memory_order_relaxed);\n+    Atomic::sub(&_mem_size, mem_size, memory_order_relaxed);\n+  }\n+  return result;\n+}\n+\n+void G1CardSetBufferList::free_all() {\n+  size_t num_freed = 0;\n+  size_t mem_size_freed = 0;\n+  G1CardSetBuffer* cur;\n+\n+  while ((cur = _list.pop()) != nullptr) {\n+    mem_size_freed += cur->mem_size();\n+    num_freed++;\n+    delete cur;\n+  }\n+\n+  Atomic::sub(&_num_buffers, num_freed, memory_order_relaxed);\n+  Atomic::sub(&_mem_size, mem_size_freed, memory_order_relaxed);\n+}\n+\n+template <class Elem>\n+G1CardSetAllocator<Elem>::G1CardSetAllocator(const char* name,\n+                                             const G1CardSetAllocOptions& buffer_options,\n+                                             G1CardSetBufferList* free_buffer_list) :\n+  _alloc_options(buffer_options),\n+  _first(nullptr),\n+  _last(nullptr),\n+  _num_buffers(0),\n+  _mem_size(0),\n+  _free_buffer_list(free_buffer_list),\n+  _transfer_lock(false),\n+  _free_nodes_list(),\n+  _pending_nodes_list(),\n+  _num_pending_nodes(0),\n+  _num_free_nodes(0),\n+  _num_allocated_nodes(0),\n+  _num_available_nodes(0)\n+{\n+  assert(elem_size() >= sizeof(G1CardSetContainer), \"Element instance size %u for allocator %s too small\",\n+         elem_size(), name);\n+  assert(_free_buffer_list != nullptr, \"precondition!\");\n+}\n+\n+template <class Elem>\n+bool G1CardSetAllocator<Elem>::try_transfer_pending() {\n+  \/\/ Attempt to claim the lock.\n+  if (Atomic::load_acquire(&_transfer_lock) || \/\/ Skip CAS if likely to fail.\n+      Atomic::cmpxchg(&_transfer_lock, false, true)) {\n+    return false;\n+  }\n+  \/\/ Have the lock; perform the transfer.\n+\n+  \/\/ Claim all the pending nodes.\n+  G1CardSetContainer* first = _pending_nodes_list.pop_all();\n+\n+  if (first != nullptr) {\n+    \/\/ Prepare to add the claimed nodes, and update _num_pending_nodes.\n+    G1CardSetContainer* last = first;\n+    Atomic::load_acquire(&_num_pending_nodes);\n+\n+    uint count = 1;\n+    for (G1CardSetContainer* next = first->next(); next != nullptr; next = next->next()) {\n+      last = next;\n+      ++count;\n+    }\n+\n+    Atomic::sub(&_num_pending_nodes, count);\n+\n+    \/\/ Wait for any in-progress pops to avoid ABA for them.\n+    GlobalCounter::write_synchronize();\n+    \/\/ Add synchronized nodes to _free_node_list.\n+    \/\/ Update count first so there can be no underflow in allocate().\n+    Atomic::add(&_num_free_nodes, count);\n+    _free_nodes_list.prepend(*first, *last);\n+  }\n+  Atomic::release_store(&_transfer_lock, false);\n+  return true;\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::free(Elem* elem) {\n+  assert(elem != nullptr, \"precondition\");\n+  assert(elem_size() >= sizeof(G1CardSetContainer), \"size mismatch\");\n+  \/\/ Desired minimum transfer batch size.  There is relatively little\n+  \/\/ importance to the specific number.  It shouldn't be too big, else\n+  \/\/ we're wasting space when the release rate is low.  If the release\n+  \/\/ rate is high, we might accumulate more than this before being\n+  \/\/ able to start a new transfer, but that's okay.  Also note that\n+  \/\/ the allocation rate and the release rate are going to be fairly\n+  \/\/ similar, due to how the buffers are used. - kbarret\n+  uint const trigger_transfer = 10;\n+\n+  uint pending_count = Atomic::add(&_num_pending_nodes, 1u, memory_order_relaxed);\n+\n+  G1CardSetContainer* node =  reinterpret_cast<G1CardSetContainer*>(reinterpret_cast<char*>(elem));\n+\n+  node->set_next(nullptr);\n+  assert(node->next() == nullptr, \"precondition\");\n+\n+  _pending_nodes_list.push(*node);\n+\n+  if (pending_count > trigger_transfer) {\n+    try_transfer_pending();\n+  }\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::drop_all() {\n+  _free_nodes_list.pop_all();\n+  _pending_nodes_list.pop_all();\n+  G1CardSetBuffer* cur = Atomic::load_acquire(&_first);\n+\n+  if (cur != nullptr) {\n+    assert(_last != nullptr, \"If there is at least one element, there must be a last one.\");\n+\n+    G1CardSetBuffer* first = cur;\n+#ifdef ASSERT\n+    \/\/ Check list consistency.\n+    G1CardSetBuffer* last = cur;\n+    uint num_buffers = 0;\n+    size_t mem_size = 0;\n+    while (cur != nullptr) {\n+      mem_size += cur->mem_size();\n+      num_buffers++;\n+\n+      G1CardSetBuffer* next = cur->next();\n+      last = cur;\n+      cur = next;\n+    }\n+#endif\n+    assert(num_buffers == _num_buffers, \"Buffer count inconsistent %u %u\", num_buffers, _num_buffers);\n+    assert(mem_size == _mem_size, \"Memory size inconsistent\");\n+    assert(last == _last, \"Inconsistent last element\");\n+\n+    _free_buffer_list->bulk_add(*first, *_last, _num_buffers, _mem_size);\n+  }\n+\n+  _first = nullptr;\n+  _last = nullptr;\n+  _num_available_nodes = 0;\n+  _num_allocated_nodes = 0;\n+  _num_pending_nodes = 0;\n+  _num_buffers = 0;\n+  _mem_size = 0;\n+  _num_free_nodes = 0;\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::print(outputStream* os) {\n+  os->print(\"MA \" PTR_FORMAT \": %u elems pending (allocated %u available %u) used %.3f highest %u buffers %u size %zu \",\n+                p2i(this), _num_pending_nodes, _num_allocated_nodes, _num_available_nodes, percent_of(_num_allocated_nodes - _num_pending_nodes, _num_available_nodes), _first != nullptr ? _first->num_elems() : 0, _num_buffers, mem_size());\n+}\n+\n+G1CardSetMemoryStats::G1CardSetMemoryStats() {\n+  clear();\n+}\n+\n+G1CardSetMemoryStats::G1CardSetMemoryStats(void(*fn)(const void*,uint,size_t&,size_t&), const void* context) {\n+  clear();\n+  for (uint i = 0; i < num_pools(); i++) {\n+    fn(context, i, _num_mem_sizes[i], _num_buffers[i]);\n+  }\n+}\n+\n+void G1CardSetMemoryStats::clear() {\n+  for (uint i = 0; i < num_pools(); i++) {\n+    _num_mem_sizes[i] = 0;\n+    _num_buffers[i] = 0;\n+  }\n+}\n+\n+void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n+  uint num_free_lists = _freelist_pool.num_free_lists();\n+\n+  for (uint i = 0; i < num_free_lists; i++) {\n+    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n+  }\n+}\n+\n+void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n+  assert(_source == nullptr, \"already visited\");\n+  if (_return_to_vm_size > 0) {\n+    _source = source;\n+  } else {\n+    assert(_source == nullptr, \"must be\");\n+  }\n+  if (source->mem_size() > _return_to_vm_size) {\n+    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n+  } else {\n+    assert(_first == nullptr, \"must be\");\n+  }\n+  \/\/ Above we were racing with other threads getting the contents of the free list,\n+  \/\/ so while we might have been asked to return something to the OS initially,\n+  \/\/ the free list might be empty anyway. In this case just reset internal values\n+  \/\/ used for checking whether there is work available.\n+  if (_first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n+  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n+  assert(_first != nullptr, \"must have element to return\");\n+\n+  size_t keep_size = 0;\n+  size_t keep_num = 0;\n+\n+  G1CardSetBuffer* cur = _first;\n+  G1CardSetBuffer* last = nullptr;\n+\n+  while (cur != nullptr && _return_to_vm_size > 0) {\n+    size_t cur_size = cur->mem_size();\n+    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n+\n+    keep_size += cur_size;\n+    keep_num++;\n+\n+    last = cur;\n+    cur = cur->next();\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  assert(_first != nullptr, \"must be\");\n+  assert(last != nullptr, \"must be\");\n+\n+  last->set_next(nullptr);\n+\n+  \/\/ Wait for any in-progress pops to avoid ABA for them.\n+  GlobalCounter::write_synchronize();\n+  _source->bulk_add(*_first, *last, keep_num, keep_size);\n+  _first = cur;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n+\n+  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n+  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n+  \/\/ inconsistent.\n+  \/\/ So also check if we actually already at the end of the list for the exit\n+  \/\/ condition.\n+  if (_return_to_vm_size == 0 || _first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+  return _source != nullptr;\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n+  assert(finished_return_to_vm(), \"not finished returning to VM\");\n+  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n+\n+  \/\/ Now delete the rest.\n+  size_t num_delete = 0;\n+  size_t mem_size_deleted = 0;\n+\n+  while (_first != nullptr) {\n+    G1CardSetBuffer* next = _first->next();\n+    num_delete++;\n+    mem_size_deleted += _first->mem_size();\n+    delete _first;\n+    _first = next;\n+\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n+\n+  return _first != nullptr;\n+}\n+\n+G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n+\n+G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n+  _num_free_lists(num_free_lists) {\n+\n+  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    new (&_free_lists[i]) G1CardSetBufferList();\n+  }\n+}\n+\n+G1CardSetFreePool::~G1CardSetFreePool() {\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    _free_lists[i].~G1CardSetBufferList();\n+  }\n+  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n+}\n+\n+static void collect_mem_sizes(const void* context, uint i, size_t& mem_size, size_t& num_buffers) {\n+  ((G1CardSetFreePool*)context)->get_size(i, mem_size, num_buffers);\n+}\n+\n+void G1CardSetFreePool::get_size(uint i, size_t& mem_size, size_t& num_buffers) const {\n+  mem_size = _free_lists[i].mem_size();\n+  num_buffers = _free_lists[i].num_buffers();\n+}\n+\n+G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n+  return G1CardSetMemoryStats(collect_mem_sizes, this);\n+}\n+\n+size_t G1CardSetFreePool::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    result += _free_lists[i].mem_size();\n+  }\n+  return result;\n+}\n+\n+void G1CardSetFreePool::print_on(outputStream* out) {\n+  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n+    _free_lists[i].print_on(out, fmt);\n+  }\n+}\n+\n+G1CardSetMemoryManager::G1CardSetMemoryManager(G1CardSetConfiguration* config,\n+                                               G1CardSetFreePool* free_list_pool) : _config(config) {\n+\n+  _allocators = NEW_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainer>,\n+                                 _config->num_mem_object_types(),\n+                                 mtGC);\n+  G1CardSetAllocOptions* alloc_options = _config->mem_object_alloc_options();\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    new (&_allocators[i]) G1CardSetAllocator<G1CardSetContainer>(_config->mem_object_type_name_str(i),\n+                                                                 alloc_options[i],\n+                                                                 free_list_pool->free_list(i));\n+  }\n+  FREE_C_HEAP_ARRAY(size_t, alloc_options);\n+}\n+\n+uint G1CardSetMemoryManager::num_mem_object_types() const {\n+  return _config->num_mem_object_types();\n+}\n+\n+\n+G1CardSetMemoryManager::~G1CardSetMemoryManager() {\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].~G1CardSetAllocator();\n+  }\n+  FREE_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainer>, _allocators);\n+}\n+\n+void G1CardSetMemoryManager::free(uint type, void* value) {\n+  assert(type < num_mem_object_types(), \"must be\");\n+  _allocators[type].free((G1CardSetContainer*)value);\n+}\n+\n+void G1CardSetMemoryManager::flush() {\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].drop_all();\n+  }\n+}\n+\n+void G1CardSetMemoryManager::print(outputStream* os) {\n+  os->print_cr(\"MM \" PTR_FORMAT \" size %zu\", p2i(this), sizeof(*this));\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].print(os);\n+  }\n+}\n+\n+size_t G1CardSetMemoryManager::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result += _allocators[i].mem_size();\n+  }\n+  return sizeof(*this) -\n+    (sizeof(G1CardSetAllocator<G1CardSetContainer>) * num_mem_object_types()) +\n+    result;\n+}\n+\n+size_t G1CardSetMemoryManager::wasted_mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result += _allocators[i].wasted_mem_size();\n+  }\n+  return result;\n+}\n+\n+G1CardSetMemoryStats G1CardSetMemoryManager::memory_stats() const {\n+  G1CardSetMemoryStats result;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result._num_mem_sizes[i] += _allocators[i].mem_size();\n+    result._num_buffers[i] += _allocators[i].num_buffers();\n+  }\n+  return result;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":478,"deletions":0,"binary":false,"changes":478,"status":"added"},{"patch":"@@ -0,0 +1,384 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETMEMORY_HPP\n+#define SHARE_GC_G1_G1CARDSETMEMORY_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+\n+class G1CardSetConfiguration;\n+class outputStream;\n+\n+\/\/ Collects G1CardSetAllocator options\/heuristics. Called by G1CardSetAllocator\n+\/\/ to determine the next size of the allocated G1CardSetBuffer.\n+class G1CardSetAllocOptions {\n+  uint _elem_size;\n+  uint _initial_num_elems;\n+  \/\/ Defines a limit to the number of elements in the buffer\n+  uint _max_num_elems;\n+\n+  uint exponential_expand(uint prev_num_elems) {\n+    return clamp(prev_num_elems * 2, _initial_num_elems, _max_num_elems);\n+  }\n+\n+public:\n+  static const uint BufferAlignment = 8;\n+  static const uint MinimumBufferSize = 8;\n+  static const uint MaximumBufferSize =  UINT_MAX \/ 2;\n+\n+  G1CardSetAllocOptions(uint elem_size, uint initial_num_elems = MinimumBufferSize, uint max_num_elems = MaximumBufferSize) :\n+    _elem_size(align_up(elem_size, BufferAlignment)),\n+    _initial_num_elems(initial_num_elems),\n+    _max_num_elems(max_num_elems) {\n+  }\n+\n+  uint next_num_elems(uint prev_num_elems) {\n+    return exponential_expand(prev_num_elems);\n+  }\n+\n+  uint elem_size () const {return _elem_size;}\n+};\n+\n+\/\/ A single buffer\/arena containing _num_elems blocks of memory of _elem_size.\n+\/\/ G1CardSetBuffers can be linked together using a singly linked list.\n+class G1CardSetBuffer : public CHeapObj<mtGCCardSet> {\n+  uint _elem_size;\n+  uint _num_elems;\n+\n+  G1CardSetBuffer* volatile _next;\n+\n+  char* _buffer;  \/\/ Actual data.\n+\n+  \/\/ Index into the next free block to allocate into. Full if equal (or larger)\n+  \/\/ to _num_elems (can be larger because we atomically increment this value and\n+  \/\/ check only afterwards if the allocation has been successful).\n+  uint volatile _next_allocate;\n+\n+public:\n+  G1CardSetBuffer(uint elem_size, uint num_elems, G1CardSetBuffer* next);\n+  ~G1CardSetBuffer();\n+\n+  G1CardSetBuffer* volatile* next_addr() { return &_next; }\n+\n+  void* get_new_buffer_elem();\n+\n+  uint num_elems() const { return _num_elems; }\n+\n+  G1CardSetBuffer* next() const { return _next; }\n+\n+  void set_next(G1CardSetBuffer* next) {\n+    assert(next != this, \" loop condition\");\n+    _next = next;\n+  }\n+\n+  void reset(G1CardSetBuffer* next) {\n+    _next_allocate = 0;\n+    assert(next != this, \" loop condition\");\n+    set_next(next);\n+    memset((void*)_buffer, 0, (size_t)_num_elems * _elem_size);\n+  }\n+\n+  uint elem_size() const { return _elem_size; }\n+\n+  size_t mem_size() const { return sizeof(*this) + (size_t)_num_elems * _elem_size; }\n+\n+  bool is_full() const { return _next_allocate >= _num_elems; }\n+};\n+\n+\/\/ Set of (free) G1CardSetBuffers. The assumed usage is that allocation\n+\/\/ to it and removal of elements is strictly separate, but every action may be\n+\/\/ performed by multiple threads at the same time.\n+\/\/ Counts and memory usage are current on a best-effort basis if accessed concurrently.\n+class G1CardSetBufferList {\n+  static G1CardSetBuffer* volatile* next_ptr(G1CardSetBuffer& node) {\n+    return node.next_addr();\n+  }\n+  typedef LockFreeStack<G1CardSetBuffer, &next_ptr> NodeStack;\n+\n+  NodeStack _list;\n+\n+  volatile size_t _num_buffers;\n+  volatile size_t _mem_size;\n+\n+public:\n+  G1CardSetBufferList() : _list(), _num_buffers(0), _mem_size(0) { }\n+  ~G1CardSetBufferList() { free_all(); }\n+\n+  void bulk_add(G1CardSetBuffer& first, G1CardSetBuffer& last, size_t num, size_t mem_size);\n+  void add(G1CardSetBuffer& elem) { _list.prepend(elem); }\n+\n+  G1CardSetBuffer* get();\n+  G1CardSetBuffer* get_all(size_t& num_buffers, size_t& mem_size);\n+\n+  \/\/ Give back all memory to the OS.\n+  void free_all();\n+\n+  void print_on(outputStream* out, const char* prefix = \"\");\n+\n+  size_t num_buffers() const { return Atomic::load(&_num_buffers); }\n+  size_t mem_size() const { return Atomic::load(&_mem_size); }\n+};\n+\n+\/\/ Arena-like allocator for (card set) heap memory objects (Elem elements).\n+\/\/\n+\/\/ Actual allocation from the C heap occurs on G1CardSetBuffer basis, i.e. sets\n+\/\/ of elements. The assumed allocation pattern for these G1CardSetBuffer elements\n+\/\/ is assumed to be strictly two-phased:\n+\/\/\n+\/\/ - in the first phase, G1CardSetBuffers are allocated from the C heap (or a free\n+\/\/ list given at initialization time). This allocation may occur in parallel. This\n+\/\/ typically corresponds to a single mutator phase, but may extend over multiple.\n+\/\/\n+\/\/ - in the second phase, G1CardSetBuffers are given back in bulk to the free list.\n+\/\/ This is typically done during a GC pause.\n+\/\/\n+\/\/ Some third party is responsible for giving back memory from the free list to\n+\/\/ the operating system.\n+\/\/\n+\/\/ Allocation and deallocation in the first phase on G1CardSetContainer basis\n+\/\/ may occur by multiple threads at once.\n+\/\/\n+\/\/ Allocation occurs from an internal free list of G1CardSetContainers first,\n+\/\/ only then trying to bump-allocate from the current G1CardSetBuffer. If there is\n+\/\/ none, this class allocates a new G1CardSetBuffer (allocated from the C heap,\n+\/\/ asking the G1CardSetAllocOptions instance about sizes etc) and uses that one.\n+\/\/\n+\/\/ The G1CardSetContainerOnHeaps free list is a linked list of G1CardSetContainers\n+\/\/ within all G1CardSetBuffer instances allocated so far. It uses a separate\n+\/\/ pending list and global synchronization to avoid the ABA problem when the\n+\/\/ user frees a memory object.\n+\/\/\n+\/\/ The class also manages a few counters for statistics using atomic operations.\n+\/\/ Their values are only consistent within each other with extra global\n+\/\/ synchronization.\n+\/\/\n+\/\/ Since it is expected that every CardSet (and in extension each region) has its\n+\/\/ own set of allocators, there is intentionally no padding between them to save\n+\/\/ memory.\n+template <class Elem>\n+class G1CardSetAllocator {\n+  \/\/ G1CardSetBuffer management.\n+\n+  \/\/ G1CardSetAllocOptions provides parameters for allocation buffer\n+  \/\/ sizing and expansion.\n+  G1CardSetAllocOptions _alloc_options;\n+\n+  G1CardSetBuffer* volatile _first;       \/\/ The (start of the) list of all buffers.\n+  G1CardSetBuffer* _last;                 \/\/ The last element of the list of all buffers.\n+  volatile uint _num_buffers;             \/\/ Number of assigned buffers to this allocator.\n+  volatile size_t _mem_size;              \/\/ Memory used by all buffers.\n+\n+  G1CardSetBufferList* _free_buffer_list; \/\/ The global free buffer list to\n+                                          \/\/ preferentially get new buffers from.\n+\n+  \/\/ G1CardSetContainer node management within the G1CardSetBuffers allocated\n+  \/\/ by this allocator.\n+\n+  static G1CardSetContainer* volatile* next_ptr(G1CardSetContainer& node);\n+  typedef LockFreeStack<G1CardSetContainer, &G1CardSetAllocator::next_ptr> NodeStack;\n+\n+  volatile bool _transfer_lock;\n+  NodeStack _free_nodes_list;\n+  NodeStack _pending_nodes_list;\n+\n+  volatile uint _num_pending_nodes;   \/\/ Number of nodes in the pending list.\n+  volatile uint _num_free_nodes;      \/\/ Number of nodes in the free list.\n+\n+  volatile uint _num_allocated_nodes; \/\/ Number of total nodes allocated and in use.\n+  volatile uint _num_available_nodes; \/\/ Number of nodes available in all buffers (allocated + free + pending + not yet used).\n+\n+  \/\/ Try to transfer nodes from _pending_nodes_list to _free_nodes_list, with a\n+  \/\/ synchronization delay for any in-progress pops from the _free_nodes_list\n+  \/\/ to solve ABA here.\n+  bool try_transfer_pending();\n+\n+  uint num_free_elems() const;\n+\n+  G1CardSetBuffer* create_new_buffer(G1CardSetBuffer* const prev);\n+\n+  uint elem_size() const { return _alloc_options.elem_size(); }\n+\n+public:\n+  G1CardSetAllocator(const char* name,\n+                     const G1CardSetAllocOptions& buffer_options,\n+                     G1CardSetBufferList* free_buffer_list);\n+  ~G1CardSetAllocator() {\n+    drop_all();\n+  }\n+\n+  Elem* allocate();\n+  void free(Elem* elem);\n+\n+  \/\/ Deallocate all buffers to the free buffer list and reset this allocator. Must\n+  \/\/ be called in a globally synchronized area.\n+  void drop_all();\n+\n+  uint num_buffers() const;\n+\n+  size_t mem_size() const {\n+    return sizeof(*this) +\n+      num_buffers() * sizeof(G1CardSetBuffer) + (size_t)_num_available_nodes * elem_size();\n+  }\n+\n+  size_t wasted_mem_size() const {\n+    return ((size_t)_num_available_nodes - (_num_allocated_nodes - _num_pending_nodes)) * elem_size();\n+  }\n+\n+  void print(outputStream* os);\n+};\n+\n+\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n+\/\/ used for each. Note that statistics are typically not taken atomically so there\n+\/\/ can be inconsistencies. The user must be prepared for them.\n+class G1CardSetMemoryStats {\n+public:\n+\n+  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n+  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n+\n+  \/\/ Returns all-zero statistics.\n+  G1CardSetMemoryStats();\n+  \/\/ For every element in the set (indicated by i), call fn to provide the\n+  \/\/ memory size and number of buffers for that i'th buffer list.\n+  G1CardSetMemoryStats(void (*fn)(const void* context, uint i, size_t& mem_size, size_t& num_buffers), const void* context);\n+\n+  void add(G1CardSetMemoryStats const other) {\n+    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n+    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n+      _num_mem_sizes[i] += other._num_mem_sizes[i];\n+      _num_buffers[i] += other._num_buffers[i];\n+    }\n+  }\n+\n+  void clear();\n+\n+  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n+};\n+\n+\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n+class G1CardSetFreePool {\n+  \/\/ The global free pool.\n+  static G1CardSetFreePool _freelist_pool;\n+\n+  uint _num_free_lists;\n+  G1CardSetBufferList* _free_lists;\n+\n+public:\n+  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n+  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n+\n+  class G1ReturnMemoryProcessor;\n+  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n+\n+  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n+\n+  explicit G1CardSetFreePool(uint num_free_lists);\n+  ~G1CardSetFreePool();\n+\n+  G1CardSetBufferList* free_list(uint i) {\n+    assert(i < _num_free_lists, \"must be\");\n+    return &_free_lists[i];\n+  }\n+\n+  uint num_free_lists() const { return _num_free_lists; }\n+\n+  \/\/ Return sizes for free list i in this free list pool.\n+  void get_size(uint i, size_t& mem_size, size_t& num_buffers) const;\n+\n+  G1CardSetMemoryStats memory_sizes() const;\n+  size_t mem_size() const;\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Data structure containing current in-progress state for returning memory to the\n+\/\/ operating system for a single G1CardSetBufferList.\n+class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n+  G1CardSetBufferList* _source;\n+  size_t _return_to_vm_size;\n+\n+  G1CardSetBuffer* _first;\n+  size_t _unlinked_bytes;\n+  size_t _num_unlinked;\n+\n+public:\n+  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n+    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n+  }\n+\n+  \/\/ Updates the instance members about the given card set buffer list for the purpose\n+  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n+  \/\/ nothing to return to the VM, do not set the source list.\n+  void visit_free_list(G1CardSetBufferList* source);\n+\n+  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n+  bool finished_return_to_os() const { return _first == nullptr; }\n+\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_vm() re-adds buffers to the respective free list.\n+  bool return_to_vm(jlong deadline);\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_os() gives back buffers to the OS.\n+  bool return_to_os(jlong deadline);\n+};\n+\n+class G1CardSetMemoryManager : public CHeapObj<mtGCCardSet> {\n+  G1CardSetConfiguration* _config;\n+\n+  G1CardSetAllocator<G1CardSetContainer>* _allocators;\n+\n+  uint num_mem_object_types() const;\n+public:\n+  G1CardSetMemoryManager(G1CardSetConfiguration* config,\n+                         G1CardSetFreePool* free_list_pool);\n+\n+  virtual ~G1CardSetMemoryManager();\n+\n+  \/\/ Allocate and free a memory object of given type.\n+  inline uint8_t* allocate(uint type);\n+  void free(uint type, void* value);\n+\n+  \/\/ Allocate and free a hash table node.\n+  inline uint8_t* allocate_node();\n+  inline void free_node(void* value);\n+\n+  void flush();\n+\n+  void print(outputStream* os);\n+\n+  size_t mem_size() const;\n+  size_t wasted_mem_size() const;\n+\n+  G1CardSetMemoryStats memory_stats() const;\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETMEMORY_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"utilities\/globalCounter.inline.hpp\"\n+\n+template <class Elem>\n+G1CardSetContainer* volatile* G1CardSetAllocator<Elem>::next_ptr(G1CardSetContainer& node) {\n+  return node.next_addr();\n+}\n+\n+template <class Elem>\n+G1CardSetBuffer* G1CardSetAllocator<Elem>::create_new_buffer(G1CardSetBuffer* const prev) {\n+\n+  \/\/ Take an existing buffer if available.\n+  G1CardSetBuffer* next = _free_buffer_list->get();\n+  if (next == nullptr) {\n+    uint prev_num_elems = (prev != nullptr) ? prev->num_elems() : 0;\n+    uint num_elems = _alloc_options.next_num_elems(prev_num_elems);\n+    next = new G1CardSetBuffer(elem_size(), num_elems, prev);\n+  } else {\n+    assert(elem_size() == next->elem_size() , \"Mismatch %d != %d Elem %zu\", elem_size(), next->elem_size(), sizeof(Elem));\n+    next->reset(prev);\n+  }\n+\n+  \/\/ Install it as current allocation buffer.\n+  G1CardSetBuffer* old = Atomic::cmpxchg(&_first, prev, next);\n+  if (old != prev) {\n+    \/\/ Somebody else installed the buffer, use that one.\n+    delete next;\n+    return old;\n+  } else {\n+    \/\/ Did we install the first element in the list? If so, this is also the last.\n+    if (prev == nullptr) {\n+      _last = next;\n+    }\n+    \/\/ Successfully installed the buffer into the list.\n+    Atomic::inc(&_num_buffers, memory_order_relaxed);\n+    Atomic::add(&_mem_size, next->mem_size(), memory_order_relaxed);\n+    Atomic::add(&_num_available_nodes, next->num_elems(), memory_order_relaxed);\n+    return next;\n+  }\n+}\n+\n+template <class Elem>\n+Elem* G1CardSetAllocator<Elem>::allocate() {\n+  assert(elem_size() > 0, \"instance size not set.\");\n+\n+  if (num_free_elems() > 0) {\n+    \/\/ Pop under critical section to deal with ABA problem\n+    \/\/ Other solutions to the same problem are more complicated (ref counting, HP)\n+    GlobalCounter::CriticalSection cs(Thread::current());\n+\n+    G1CardSetContainer* node = _free_nodes_list.pop();\n+    if (node != nullptr) {\n+      Elem* elem = reinterpret_cast<Elem*>(reinterpret_cast<char*>(node));\n+      Atomic::sub(&_num_free_nodes, 1u);\n+      guarantee(is_aligned(elem, 8), \"result \" PTR_FORMAT \" not aligned\", p2i(elem));\n+      return elem;\n+    }\n+  }\n+\n+  G1CardSetBuffer* cur = Atomic::load_acquire(&_first);\n+  if (cur == nullptr) {\n+    cur = create_new_buffer(cur);\n+  }\n+\n+  while (true) {\n+    Elem* elem = (Elem*)cur->get_new_buffer_elem();\n+    if (elem != nullptr) {\n+      Atomic::inc(&_num_allocated_nodes, memory_order_relaxed);\n+      guarantee(is_aligned(elem, 8), \"result \" PTR_FORMAT \" not aligned\", p2i(elem));\n+      return elem;\n+    }\n+    \/\/ The buffer is full. Next round.\n+    assert(cur->is_full(), \"must be\");\n+    cur = create_new_buffer(cur);\n+  }\n+}\n+\n+inline uint8_t* G1CardSetMemoryManager::allocate(uint type) {\n+  assert(type < num_mem_object_types(), \"must be\");\n+  return (uint8_t*)_allocators[type].allocate();\n+}\n+\n+inline uint8_t* G1CardSetMemoryManager::allocate_node() {\n+  return allocate(0);\n+}\n+\n+inline void G1CardSetMemoryManager::free_node(void* value) {\n+  free(0, value);\n+}\n+\n+template <class Elem>\n+inline uint G1CardSetAllocator<Elem>::num_buffers() const {\n+  return Atomic::load(&_num_buffers);\n+}\n+\n+template <class Elem>\n+inline uint G1CardSetAllocator<Elem>::num_free_elems() const {\n+  return Atomic::load(&_num_free_nodes);\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.inline.hpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -105,1 +105,1 @@\n-  inline size_t mark_region_dirty(size_t start_card_index, size_t num_cards);\n+  inline size_t mark_range_dirty(size_t start_card_index, size_t num_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-inline size_t G1CardTable::mark_region_dirty(size_t start_card_index, size_t num_cards) {\n+inline size_t G1CardTable::mark_range_dirty(size_t start_card_index, size_t num_cards) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeBlobClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n@@ -71,1 +72,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -150,1 +151,1 @@\n-  return new HeapRegion(hrs_index, bot(), mr);\n+  return new HeapRegion(hrs_index, bot(), mr, &_card_set_config);\n@@ -1439,0 +1440,1 @@\n+  _free_card_set_memory_task(NULL),\n@@ -1475,0 +1477,1 @@\n+  _card_set_config(),\n@@ -1744,0 +1747,3 @@\n+  _free_card_set_memory_task = new G1CardSetFreeMemoryTask(\"Card Set Free Memory Task\");\n+  _service_thread->register_task(_free_card_set_memory_task);\n+\n@@ -2624,0 +2630,3 @@\n+\n+  _free_card_set_memory_task->notify_new_stats(&_young_gen_card_set_stats,\n+                                               &_collection_set_candidates_card_set_stats);\n@@ -2845,0 +2854,3 @@\n+  if (evacuation_failed()) {\n+    type = (G1HeapVerifier::G1VerifyType)(type | G1HeapVerifier::G1VerifyYoungEvacFail);\n+  }\n@@ -2961,1 +2973,0 @@\n-\n@@ -2970,1 +2981,0 @@\n-\n@@ -2975,1 +2985,0 @@\n-\n@@ -3064,6 +3073,0 @@\n-    \/\/ We must call G1MonitoringSupport::update_sizes() in the same scoping level\n-    \/\/ as an active TraceMemoryManagerStats object (i.e. before the destructor for the\n-    \/\/ TraceMemoryManagerStats is called) so that the G1 memory pools are updated\n-    \/\/ before any GC notifications are raised.\n-    g1mm()->update_sizes();\n-\n@@ -3322,0 +3325,9 @@\n+bool G1CollectedHeap::should_sample_collection_set_candidates() const {\n+  G1CollectionSetCandidates* candidates = G1CollectedHeap::heap()->collection_set()->candidates();\n+  return candidates != NULL && candidates->num_remaining() > 0;\n+}\n+\n+void G1CollectedHeap::set_collection_set_candidates_stats(G1CardSetMemoryStats& stats) {\n+  _collection_set_candidates_card_set_stats = stats;\n+}\n+\n@@ -3329,0 +3341,11 @@\n+    G1CardSetMemoryStats _card_set_stats;\n+\n+    void sample_card_set_size(HeapRegion* hr) {\n+      \/\/ Sample card set sizes for young gen and humongous before GC: this makes\n+      \/\/ the policy to give back memory to the OS keep the most recent amount of\n+      \/\/ memory for these regions.\n+      if (hr->is_young() || hr->is_starts_humongous()) {\n+        _card_set_stats.add(hr->rem_set()->card_set_memory_stats());\n+      }\n+    }\n+\n@@ -3401,0 +3424,2 @@\n+      sample_card_set_size(hr);\n+\n@@ -3431,0 +3456,4 @@\n+\n+    G1CardSetMemoryStats card_set_stats() const {\n+      return _card_set_stats;\n+    }\n@@ -3437,0 +3466,3 @@\n+\n+  G1CardSetMemoryStats _all_card_set_stats;\n+\n@@ -3448,0 +3480,3 @@\n+\n+    MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n+    _all_card_set_stats.add(cl.card_set_stats());\n@@ -3465,0 +3500,4 @@\n+\n+  G1CardSetMemoryStats all_card_set_stats() const {\n+    return _all_card_set_stats;\n+  }\n@@ -3492,0 +3531,2 @@\n+    _young_gen_card_set_stats = g1_prep_task.all_card_set_stats();\n+\n@@ -3766,0 +3807,1 @@\n+  rem_set()->print_coarsen_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":53,"deletions":11,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n@@ -69,0 +71,1 @@\n+class G1CardSetFreeMemoryTask;\n@@ -161,0 +164,1 @@\n+  G1CardSetFreeMemoryTask* _free_card_set_memory_task;\n@@ -176,0 +180,5 @@\n+  \/\/ Young gen memory statistics before GC.\n+  G1CardSetMemoryStats _young_gen_card_set_stats;\n+  \/\/ Collection set candidates memory statistics after GC.\n+  G1CardSetMemoryStats _collection_set_candidates_card_set_stats;\n+\n@@ -270,0 +279,3 @@\n+  bool should_sample_collection_set_candidates() const;\n+  void set_collection_set_candidates_stats(G1CardSetMemoryStats& stats);\n+\n@@ -843,0 +855,2 @@\n+  \/\/ Global card set configuration\n+  G1CardSetConfiguration _card_set_config;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -42,1 +43,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -1695,1 +1696,1 @@\n-        thread->as_Java_thread()->nmethods_do(&_code_cl);\n+        JavaThread::cast(thread)->nmethods_do(&_code_cl);\n@@ -2950,1 +2951,1 @@\n-  _total_remset_bytes += HeapRegionRemSet::fl_mem_size() + HeapRegionRemSet::static_mem_size();\n+  _total_remset_bytes += G1CardSetFreePool::free_list_pool()->mem_size() + HeapRegionRemSet::static_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -48,1 +48,0 @@\n-#include \"utilities\/lockFreeQueue.inline.hpp\"\n@@ -50,0 +49,1 @@\n+#include \"utilities\/nonblockingQueue.inline.hpp\"\n@@ -134,2 +134,2 @@\n-\/\/ the _completed queue, using the LockFreeQueue::try_pop() underneath.\n-\/\/ It has a restriction that it may return NULL when there are objects\n+\/\/ the _completed queue, using the NonblockingQueue::try_pop() underneath.\n+\/\/ It has a limitation that it may return NULL when there are objects\n@@ -138,1 +138,0 @@\n-  using Status = LockFreeQueuePopStatus;\n@@ -140,0 +139,1 @@\n+  BufferNode* result = NULL;\n@@ -150,13 +150,1 @@\n-    Pair<Status, BufferNode*> pop_result = _completed.try_pop();\n-    switch (pop_result.first) {\n-      case Status::success:\n-        return pop_result.second;\n-      case Status::operation_in_progress:\n-        \/\/ Returning NULL instead retrying, in order to mitigate the\n-        \/\/ chance of spinning for a long time. In the case of getting a\n-        \/\/ buffer to refine, it is also OK to return NULL when there is\n-        \/\/ an interfering concurrent push\/append operation.\n-        return NULL;\n-      case Status::lost_race:\n-        break;  \/\/ Try again.\n-    }\n+    if (_completed.try_pop(&result)) return result;\n@@ -180,2 +168,3 @@\n-  BufferNode* cur = _completed.top();\n-  for ( ; cur != NULL; cur = cur->next()) {\n+  for (BufferNode* cur = _completed.first();\n+       !_completed.is_end(cur);\n+       cur = cur->next()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"utilities\/lockFreeQueue.hpp\"\n+#include \"utilities\/nonblockingQueue.hpp\"\n@@ -167,3 +167,3 @@\n-  \/\/ LockFreeQueue has inner padding of one cache line.\n-  LockFreeQueue<BufferNode, &BufferNode::next_ptr> _completed;\n-  \/\/ Add a trailer padding after LockFreeQueue.\n+  \/\/ NonblockingQueue has inner padding of one cache line.\n+  NonblockingQueue<BufferNode, &BufferNode::next_ptr> _completed;\n+  \/\/ Add a trailer padding after NonblockingQueue.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -189,4 +188,0 @@\n-  \/\/ We should save the marks of the currently locked biased monitors.\n-  \/\/ The marking doesn't preserve the marks of biased objects.\n-  BiasedLocking::preserve_marks();\n-\n@@ -219,2 +214,0 @@\n-  BiasedLocking::restore_marks();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,4 +111,1 @@\n-      \/\/ since it will be restored by preserved marks. There is an exception\n-      \/\/ with BiasedLocking, in this case forwardee() will return NULL\n-      \/\/ even if the mark-word is used. This is no problem since\n-      \/\/ forwardee() will return NULL in the compaction phase as well.\n+      \/\/ since it will be restored by preserved marks.\n@@ -119,3 +116,2 @@\n-      assert(object->mark() == markWord::prototype_for_klass(object->klass()) || \/\/ Correct mark\n-             object->mark_must_be_preserved() || \/\/ Will be restored by PreservedMarksSet\n-             (UseBiasedLocking && object->has_bias_pattern()), \/\/ Will be restored by BiasedLocking\n+      assert(object->mark() == markWord::prototype() || \/\/ Correct mark\n+             object->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n@@ -123,1 +119,1 @@\n-             p2i(object), object->mark().value(), markWord::prototype_for_klass(object->klass()).value());\n+             p2i(object), object->mark().value(), markWord::prototype().value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -83,3 +83,2 @@\n-    assert(obj->mark() == markWord::prototype_for_klass(obj->klass()) || \/\/ Correct mark\n-           obj->mark_must_be_preserved() || \/\/ Will be restored by PreservedMarksSet\n-           (UseBiasedLocking && obj->has_bias_pattern()), \/\/ Will be restored by BiasedLocking\n+    assert(obj->mark() == markWord::prototype() || \/\/ Correct mark\n+           obj->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n@@ -87,1 +86,1 @@\n-           p2i(obj), obj->mark().value(), markWord::prototype_for_klass(obj->klass()).value());\n+           p2i(obj), obj->mark().value(), markWord::prototype().value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -54,5 +54,0 @@\n-  \/\/ We must call G1MonitoringSupport::update_sizes() in the same scoping level\n-  \/\/ as an active TraceMemoryManagerStats object (i.e. before the destructor for the\n-  \/\/ TraceMemoryManagerStats is called) so that the G1 memory pools are updated\n-  \/\/ before any GC notifications are raised.\n-  _g1h->g1mm()->update_sizes();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+constexpr const char* G1GCPhaseTimes::GCMergeRSWorkItemsStrings[];\n+\n@@ -74,4 +76,3 @@\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Sparse:\", MergeRSMergedSparse);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Fine:\", MergeRSMergedFine);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Coarse:\", MergeRSMergedCoarse);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Dirty Cards:\", MergeRSDirtyCards);\n+  for (uint i = 0; i < MergeRSContainersSentinel; i++) {\n+    _gc_par_phases[MergeRS]->create_thread_work_items(GCMergeRSWorkItemsStrings[i], i);\n+  }\n@@ -80,4 +81,3 @@\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Sparse:\", MergeRSMergedSparse);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Fine:\", MergeRSMergedFine);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Coarse:\", MergeRSMergedCoarse);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Dirty Cards:\", MergeRSDirtyCards);\n+  for (uint i = 0; i < MergeRSContainersSentinel; i++) {\n+    _gc_par_phases[OptMergeRS]->create_thread_work_items(GCMergeRSWorkItemsStrings[i], i);\n+  }\n@@ -137,0 +137,2 @@\n+  _gc_par_phases[SampleCollectionSetCandidates] = new WorkerDataArray<double>(\"SampleCandidates\", \"Sample CSet Candidates (ms):\", max_gc_threads);\n+\n@@ -173,0 +175,1 @@\n+  _recorded_sample_collection_set_candidates_time_ms = 0.0;\n@@ -452,0 +455,1 @@\n+                        _recorded_sample_collection_set_candidates_time_ms +\n@@ -475,0 +479,2 @@\n+  debug_time(\"Sample Collection Set Candidates\", _recorded_sample_collection_set_candidates_time_ms);\n+  trace_phase(_gc_par_phases[RedirtyCards]);\n@@ -488,0 +494,3 @@\n+  if (G1CollectedHeap::heap()->should_sample_collection_set_candidates()) {\n+    debug_phase(_gc_par_phases[SampleCollectionSetCandidates], 1);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    SampleCollectionSetCandidates,\n@@ -100,5 +101,11 @@\n-  enum GCMergeRSWorkTimes {\n-    MergeRSMergedSparse,\n-    MergeRSMergedFine,\n-    MergeRSMergedCoarse,\n-    MergeRSDirtyCards\n+  enum GCMergeRSWorkItems : uint {\n+    MergeRSMergedInline = 0,\n+    MergeRSMergedArrayOfCards,\n+    MergeRSMergedHowl,\n+    MergeRSMergedFull,\n+    MergeRSHowlInline,\n+    MergeRSHowlArrayOfCards,\n+    MergeRSHowlBitmap,\n+    MergeRSHowlFull,\n+    MergeRSDirtyCards,\n+    MergeRSContainersSentinel\n@@ -107,0 +114,5 @@\n+  static constexpr const char* GCMergeRSWorkItemsStrings[MergeRSContainersSentinel] =\n+    { \"Merged Inline\", \"Merged ArrayOfCards\", \"Merged Howl\", \"Merged Full\",\n+      \"Merged Howl Inline\", \"Merged Howl ArrayOfCards\", \"Merged Howl BitMap\", \"Merged Howl Full\",\n+      \"Dirty Cards\" };\n+\n@@ -176,0 +188,2 @@\n+  double _recorded_sample_collection_set_candidates_time_ms;\n+\n@@ -332,0 +346,4 @@\n+  void record_sample_collection_set_candidates_time_ms(double time_ms) {\n+    _recorded_sample_collection_set_candidates_time_ms = time_ms;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-  return (_enabled_verification_types & type) == type;\n+  return (_enabled_verification_types & type) != 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,3 +48,4 @@\n-    G1VerifyRemark          =  8, \/\/ -XX:VerifyGCType=remark\n-    G1VerifyCleanup         = 16, \/\/ -XX:VerifyGCType=cleanup\n-    G1VerifyFull            = 32, \/\/ -XX:VerifyGCType=full\n+    G1VerifyYoungEvacFail   =  8, \/\/ -XX:VerifyGCType=young-evac-fail\n+    G1VerifyRemark          = 16, \/\/ -XX:VerifyGCType=remark\n+    G1VerifyCleanup         = 32, \/\/ -XX:VerifyGCType=cleanup\n+    G1VerifyFull            = 64, \/\/ -XX:VerifyGCType=full\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -346,0 +346,1 @@\n+  _g1mm(g1mm),\n@@ -350,0 +351,4 @@\n+\n+G1MonitoringScope::~G1MonitoringScope() {\n+  _g1mm->update_sizes();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -241,0 +241,1 @@\n+  G1MonitoringSupport* _g1mm;\n@@ -245,0 +246,1 @@\n+  ~G1MonitoringScope();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -53,0 +53,2 @@\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n@@ -48,1 +49,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -384,3 +384,1 @@\n-    if (!_region_scan_chunks[chunk_idx]) {\n-      _region_scan_chunks[chunk_idx] = true;\n-    }\n+    _region_scan_chunks[chunk_idx] = true;\n@@ -1064,1 +1062,1 @@\n-\/\/ Small ring buffer used for prefetching cards for read\/write from the card\n+\/\/ Small ring buffer used for prefetching cards for write from the card\n@@ -1066,1 +1064,1 @@\n-template <class T, bool for_write>\n+template <class T>\n@@ -1099,5 +1097,1 @@\n-    if (for_write) {\n-      Prefetch::write(elem, 0);\n-    } else {\n-      Prefetch::read(elem, 0);\n-    }\n+    Prefetch::write(elem, 0);\n@@ -1114,1 +1108,27 @@\n-  \/\/ Visitor for remembered sets, dropping entries onto the card table.\n+  class G1MergeCardSetStats {\n+    size_t _merged[G1GCPhaseTimes::MergeRSContainersSentinel];\n+\n+  public:\n+    G1MergeCardSetStats() {\n+      for (uint i = 0; i < ARRAY_SIZE(_merged); i++) {\n+        _merged[i] = 0;\n+      }\n+    }\n+\n+    void inc_card_set_merged(uint tag) {\n+      assert(tag < ARRAY_SIZE(_merged), \"tag out of bounds %u\", tag);\n+      _merged[tag]++;\n+    }\n+\n+    void inc_cards_dirty(size_t increment = 1) {\n+      _merged[G1GCPhaseTimes::MergeRSDirtyCards] += increment;\n+    }\n+\n+    size_t merged(uint i) const { return _merged[i]; }\n+  };\n+\n+  \/\/ Visitor for remembered sets. Several methods of it are called by a region's\n+  \/\/ card set iterator to drop card set remembered set entries onto the card.\n+  \/\/ table. This is in addition to being the HeapRegionClosure to iterate over\n+  \/\/ all region's remembered sets.\n+  \/\/\n@@ -1124,5 +1144,1 @@\n-    uint _merged_sparse;\n-    uint _merged_fine;\n-    uint _merged_coarse;\n-\n-    size_t _cards_dirty;\n+    G1MergeCardSetStats _stats;\n@@ -1134,1 +1150,1 @@\n-    class G1MergeCardSetCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true> {\n+    class G1MergeCardSetCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue> {\n@@ -1141,1 +1157,1 @@\n-        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true>(G1CardTable::dirty_card_val()),\n+        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue>(G1CardTable::dirty_card_val()),\n@@ -1163,1 +1179,1 @@\n-        _cards_dirty++;\n+        _stats.inc_cards_dirty();\n@@ -1168,4 +1184,0 @@\n-    void start_iterate(uint const region_idx) {\n-      _region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n-    }\n-\n@@ -1173,0 +1185,1 @@\n+\n@@ -1176,4 +1189,1 @@\n-      _merged_sparse(0),\n-      _merged_fine(0),\n-      _merged_coarse(0),\n-      _cards_dirty(0),\n+      _stats(),\n@@ -1181,2 +1191,1 @@\n-      _merge_card_set_cache(this) {\n-    }\n+      _merge_card_set_cache(this) { }\n@@ -1191,24 +1200,7 @@\n-    void next_coarse_prt(uint const region_idx) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_coarse++;\n-\n-      start_iterate(region_idx);\n-      _cards_dirty += _ct->mark_region_dirty(_region_base_idx, HeapRegion::CardsPerRegion);\n-      _scan_state->set_chunk_region_dirty(_region_base_idx);\n-    }\n-\n-    void next_fine_prt(uint const region_idx, BitMap* bm) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_fine++;\n-\n-      start_iterate(region_idx);\n-      BitMap::idx_t cur = bm->get_next_one_offset(0);\n-      while (cur != bm->size()) {\n-        do_card((uint)cur);\n-        cur = bm->get_next_one_offset(cur + 1);\n+    \/\/ Returns whether the given region actually needs iteration.\n+    bool start_iterate(uint const tag, uint const region_idx) {\n+      assert(tag < G1GCPhaseTimes::MergeRSDirtyCards, \"invalid tag %u\", tag);\n+      if (remember_if_interesting(region_idx)) {\n+        _region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n+        _stats.inc_card_set_merged(tag);\n+        return true;\n@@ -1216,0 +1208,1 @@\n+      return false;\n@@ -1218,11 +1211,6 @@\n-    void next_sparse_prt(uint const region_idx, SparsePRTEntry::card_elem_t* cards, uint const num_cards) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_sparse++;\n-\n-      start_iterate(region_idx);\n-      for (uint i = 0; i < num_cards; i++) {\n-        do_card(cards[i]);\n-      }\n+    void do_card_range(uint const start_card_idx, uint const length) {\n+      assert(start_card_idx == 0, \"must be\");\n+      assert(length == HeapRegion::CardsPerRegion, \"must be\");\n+      size_t num_dirtied = _ct->mark_range_dirty(_region_base_idx, HeapRegion::CardsPerRegion);\n+      _stats.inc_cards_dirty(num_dirtied);\n+      _scan_state->set_chunk_region_dirty(_region_base_idx);\n@@ -1231,1 +1219,1 @@\n-    \/\/ Helper to put the remembered set cards for these regions onto the card\n+    \/\/ Helper to merge the cards in the card set for the given region onto the card\n@@ -1245,1 +1233,1 @@\n-    void dump_rem_set_for_region(HeapRegion* r) {\n+    void merge_card_set_for_region(HeapRegion* r) {\n@@ -1250,1 +1238,1 @@\n-        rem_set->iterate_prts(*this);\n+        rem_set->iterate_for_merge(*this);\n@@ -1258,1 +1246,1 @@\n-      dump_rem_set_for_region(r);\n+      merge_card_set_for_region(r);\n@@ -1263,5 +1251,1 @@\n-    size_t merged_sparse() const { return _merged_sparse; }\n-    size_t merged_fine() const { return _merged_fine; }\n-    size_t merged_coarse() const { return _merged_coarse; }\n-\n-    size_t cards_dirty() const { return _cards_dirty; }\n+    G1MergeCardSetStats stats() const { return _stats; }\n@@ -1273,1 +1257,2 @@\n-    G1MergeCardSetClosure _cl;\n+    G1RemSetScanState* _scan_state;\n+    G1MergeCardSetStats _merge_stats;\n@@ -1276,1 +1261,1 @@\n-    G1FlushHumongousCandidateRemSets(G1RemSetScanState* scan_state) : _cl(scan_state) { }\n+    G1FlushHumongousCandidateRemSets(G1RemSetScanState* scan_state) : _scan_state(scan_state), _merge_stats() { }\n@@ -1290,1 +1275,6 @@\n-      _cl.dump_rem_set_for_region(r);\n+      G1MergeCardSetStats stats;\n+      {\n+        G1MergeCardSetClosure cl(_scan_state);\n+        cl.merge_card_set_for_region(r);\n+        stats = cl.stats();\n+      }\n@@ -1310,5 +1300,1 @@\n-    size_t merged_sparse() const { return _cl.merged_sparse(); }\n-    size_t merged_fine() const { return _cl.merged_fine(); }\n-    size_t merged_coarse() const { return _cl.merged_coarse(); }\n-\n-    size_t cards_dirty() const { return _cl.cards_dirty(); }\n+    size_t merged(uint i) const { return _merge_stats.merged(i); }\n@@ -1319,1 +1305,0 @@\n-    friend class G1MergeLogBufferCardsCache;\n@@ -1327,17 +1312,0 @@\n-    class G1MergeLogBufferCardsCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false> {\n-      G1MergeLogBufferCardsClosure* const _merge_log_buffer_cl;\n-\n-    public:\n-      G1MergeLogBufferCardsCache(G1MergeLogBufferCardsClosure* const merge_log_buffer_cl) :\n-        \/\/ Initially set dummy card value to Clean to avoid any actual work if we\n-        \/\/ try to process it.\n-        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false>(G1CardTable::clean_card_val()),\n-        _merge_log_buffer_cl(merge_log_buffer_cl) { }\n-\n-      ~G1MergeLogBufferCardsCache() {\n-        for (uint i = 0; i < CacheSize; i++) {\n-          _merge_log_buffer_cl->process_card(push(&_dummy_card));\n-        }\n-      }\n-    } _merge_log_buffer_cache;\n-\n@@ -1358,2 +1326,1 @@\n-      _cards_skipped(0),\n-      _merge_log_buffer_cache(this)\n+      _cards_skipped(0)\n@@ -1376,2 +1343,1 @@\n-        CardValue* to_process = _merge_log_buffer_cache.push(card_ptr);\n-        process_card(to_process);\n+        process_card(card_ptr);\n@@ -1445,4 +1411,3 @@\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);\n+      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n+        p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged(i), i);\n+      }\n@@ -1454,2 +1419,6 @@\n-      G1MergeCardSetClosure cl(_scan_state);\n-      g1h->collection_set_iterate_increment_from(&cl, &_hr_claimer, worker_id);\n+      G1MergeCardSetStats stats;\n+      {\n+        G1MergeCardSetClosure cl(_scan_state);\n+        g1h->collection_set_iterate_increment_from(&cl, &_hr_claimer, worker_id);\n+        stats = cl.stats();\n+      }\n@@ -1457,4 +1426,3 @@\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);\n+      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n+        p->record_or_add_thread_work_item(merge_remset_phase, worker_id, stats.merged(i), i);\n+      }\n@@ -1489,1 +1457,3 @@\n-  size_t num_visited_cards = _scan_state->num_visited_cards();\n+  LogTarget(Debug, gc, remset) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n@@ -1491,1 +1461,1 @@\n-  size_t total_dirty_region_cards = _scan_state->num_cards_in_dirty_regions();\n+    size_t num_visited_cards = _scan_state->num_visited_cards();\n@@ -1493,10 +1463,13 @@\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  size_t total_old_region_cards =\n-    (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * HeapRegion::CardsPerRegion;\n-\n-  log_debug(gc,remset)(\"Visited cards \" SIZE_FORMAT \" Total dirty \" SIZE_FORMAT \" (%.2lf%%) Total old \" SIZE_FORMAT \" (%.2lf%%)\",\n-                       num_visited_cards,\n-                       total_dirty_region_cards,\n-                       percent_of(num_visited_cards, total_dirty_region_cards),\n-                       total_old_region_cards,\n-                       percent_of(num_visited_cards, total_old_region_cards));\n+    size_t total_dirty_region_cards = _scan_state->num_cards_in_dirty_regions();\n+\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    size_t total_old_region_cards =\n+      (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * HeapRegion::CardsPerRegion;\n+\n+    ls.print_cr(\"Visited cards \" SIZE_FORMAT \" Total dirty \" SIZE_FORMAT \" (%.2lf%%) Total old \" SIZE_FORMAT \" (%.2lf%%)\",\n+                num_visited_cards,\n+                total_dirty_region_cards,\n+                percent_of(num_visited_cards, total_dirty_region_cards),\n+                total_old_region_cards,\n+                percent_of(num_visited_cards, total_old_region_cards));\n+  }\n@@ -1534,3 +1507,1 @@\n-  if (log_is_enabled(Debug, gc, remset)) {\n-    print_merge_heap_roots_stats();\n-  }\n+  print_merge_heap_roots_stats();\n@@ -1551,0 +1522,9 @@\n+void G1RemSet::print_coarsen_stats() {\n+  LogTarget(Debug, gc, remset) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+\n+    G1CardSet::print_coarsen_stats(&ls);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":109,"deletions":129,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -110,0 +110,4 @@\n+  \/\/ Cleans the card table from temporary duplicate detection information.\n+  void cleanup_after_scan_heap_roots();\n+  \/\/ Print coarsening stats.\n+  void print_coarsen_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -34,1 +35,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -51,0 +52,1 @@\n+\n@@ -53,1 +55,1 @@\n-  _num_coarsenings = HeapRegionRemSet::n_coarsenings();\n+  _coarsenings = HeapRegionRemSet::coarsen_stats();\n@@ -71,1 +73,1 @@\n-  _num_coarsenings(0),\n+  _coarsenings(),\n@@ -91,1 +93,1 @@\n-  _num_coarsenings = other->num_coarsenings();\n+  _coarsenings = other->_coarsenings;\n@@ -102,1 +104,1 @@\n-  _num_coarsenings = other->num_coarsenings() - _num_coarsenings;\n+  _coarsenings.subtract_from(other->_coarsenings);\n@@ -115,0 +117,1 @@\n+  size_t _rs_wasted_mem_size;\n@@ -118,0 +121,1 @@\n+  size_t _amount_tracked;\n@@ -139,0 +143,1 @@\n+  size_t amount_tracked() const { return _amount_tracked; }\n@@ -142,2 +147,2 @@\n-  RegionTypeCounter(const char* name) : _name(name), _rs_mem_size(0), _cards_occupied(0),\n-    _amount(0), _code_root_mem_size(0), _code_root_elems(0) { }\n+  RegionTypeCounter(const char* name) : _name(name), _rs_wasted_mem_size(0), _rs_mem_size(0), _cards_occupied(0),\n+    _amount(0), _amount_tracked(0), _code_root_mem_size(0), _code_root_elems(0) { }\n@@ -145,2 +150,3 @@\n-  void add(size_t rs_mem_size, size_t cards_occupied, size_t code_root_mem_size,\n-    size_t code_root_elems) {\n+  void add(size_t rs_wasted_mem_size, size_t rs_mem_size, size_t cards_occupied,\n+           size_t code_root_mem_size, size_t code_root_elems, bool tracked) {\n+    _rs_wasted_mem_size += rs_wasted_mem_size;\n@@ -152,0 +158,1 @@\n+    _amount_tracked += tracked ? 1 : 0;\n@@ -154,0 +161,1 @@\n+  size_t rs_wasted_mem_size() const { return _rs_wasted_mem_size; }\n@@ -161,4 +169,5 @@\n-    out->print_cr(\"    \" SIZE_FORMAT_W(8) \"%s (%5.1f%%) by \" SIZE_FORMAT \" %s regions\",\n-        byte_size_in_proper_unit(rs_mem_size()),\n-        proper_unit_for_byte_size(rs_mem_size()),\n-        rs_mem_size_percent_of(total), amount(), _name);\n+    out->print_cr(\"    \" SIZE_FORMAT_W(8) \" (%5.1f%%) by \" SIZE_FORMAT \" \"\n+                  \"(\" SIZE_FORMAT \") %s regions wasted \" SIZE_FORMAT,\n+                  rs_mem_size(), rs_mem_size_percent_of(total),\n+                  amount_tracked(), amount(),\n+                  _name, rs_wasted_mem_size());\n@@ -168,2 +177,4 @@\n-    out->print_cr(\"     \" SIZE_FORMAT_W(8) \" (%5.1f%%) entries by \" SIZE_FORMAT \" %s regions\",\n-        cards_occupied(), cards_occupied_percent_of(total), amount(), _name);\n+    out->print_cr(\"     \" SIZE_FORMAT_W(8) \" (%5.1f%%) entries by \" SIZE_FORMAT \" \"\n+                  \"(\" SIZE_FORMAT \") %s regions\",\n+                  cards_occupied(), cards_occupied_percent_of(total),\n+                  amount_tracked(), amount(), _name);\n@@ -198,0 +209,1 @@\n+  size_t total_rs_wasted_mem_sz() const     { return _all.rs_wasted_mem_size(); }\n@@ -225,0 +237,1 @@\n+    size_t rs_wasted_mem_sz = hrrs->wasted_mem_size();\n@@ -252,2 +265,4 @@\n-    current->add(rs_mem_sz, occupied_cards, code_root_mem_sz, code_root_elems);\n-    _all.add(rs_mem_sz, occupied_cards, code_root_mem_sz, code_root_elems);\n+    current->add(rs_wasted_mem_sz, rs_mem_sz, occupied_cards,\n+                 code_root_mem_sz, code_root_elems, r->rem_set()->is_tracked());\n+    _all.add(rs_wasted_mem_sz, rs_mem_sz, occupied_cards,\n+             code_root_mem_sz, code_root_elems, r->rem_set()->is_tracked());\n@@ -262,6 +277,5 @@\n-    out->print_cr(\"  Total per region rem sets sizes = \" SIZE_FORMAT \"%s.\"\n-                  \" Max = \" SIZE_FORMAT \"%s.\",\n-                  byte_size_in_proper_unit(total_rs_mem_sz()),\n-                  proper_unit_for_byte_size(total_rs_mem_sz()),\n-                  byte_size_in_proper_unit(max_rs_mem_sz()),\n-                  proper_unit_for_byte_size(max_rs_mem_sz()));\n+    out->print_cr(\"  Total per region rem sets sizes = \" SIZE_FORMAT\n+                  \" Max = \" SIZE_FORMAT \" wasted = \" SIZE_FORMAT,\n+                  total_rs_mem_sz(),\n+                  max_rs_mem_sz(),\n+                  total_rs_wasted_mem_sz());\n@@ -272,7 +286,0 @@\n-    out->print_cr(\"   Static structures = \" SIZE_FORMAT \"%s,\"\n-                  \" free_lists = \" SIZE_FORMAT \"%s.\",\n-                  byte_size_in_proper_unit(HeapRegionRemSet::static_mem_size()),\n-                  proper_unit_for_byte_size(HeapRegionRemSet::static_mem_size()),\n-                  byte_size_in_proper_unit(HeapRegionRemSet::fl_mem_size()),\n-                  proper_unit_for_byte_size(HeapRegionRemSet::fl_mem_size()));\n-\n@@ -288,1 +295,1 @@\n-                  \"size = \" SIZE_FORMAT \"%s, occupied = \" SIZE_FORMAT \"%s.\",\n+                  \"size = \" SIZE_FORMAT \" occupied = \" SIZE_FORMAT,\n@@ -290,4 +297,6 @@\n-                  byte_size_in_proper_unit(rem_set->mem_size()),\n-                  proper_unit_for_byte_size(rem_set->mem_size()),\n-                  byte_size_in_proper_unit(rem_set->occupied()),\n-                  proper_unit_for_byte_size(rem_set->occupied()));\n+                  rem_set->mem_size(),\n+                  rem_set->occupied());\n+\n+    HeapRegionRemSet::print_static_mem_size(out);\n+    G1CardSetFreePool::free_list_pool()->print_on(out);\n+\n@@ -322,1 +331,2 @@\n-  out->print_cr(\"  Did \" SIZE_FORMAT \" coarsenings.\", num_coarsenings());\n+  out->print(\"Coarsening: \");\n+  _coarsenings.print_on(out);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n@@ -36,1 +37,1 @@\n-  size_t _num_coarsenings;\n+  G1CardSetCoarsenStats _coarsenings;\n@@ -68,4 +69,0 @@\n-\n-  size_t num_coarsenings() const {\n-    return _num_coarsenings;\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n@@ -44,0 +46,3 @@\n+  if (SampleCollectionSetCandidatesTask::should_execute()) {\n+    add_serial_task(new SampleCollectionSetCandidatesTask());\n+  }\n@@ -67,0 +72,26 @@\n+bool G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::should_execute() {\n+  return G1CollectedHeap::heap()->should_sample_collection_set_candidates();\n+}\n+\n+double G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::worker_cost() const {\n+  return should_execute() ? 1.0 : AlmostNoWork;\n+}\n+\n+class G1SampleCollectionSetCandidatesClosure : public HeapRegionClosure {\n+public:\n+  G1CardSetMemoryStats _total;\n+\n+  bool do_heap_region(HeapRegion* r) override {\n+    _total.add(r->rem_set()->card_set_memory_stats());\n+    return false;\n+  }\n+};\n+\n+void G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::do_work(uint worker_id) {\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+\n+  G1SampleCollectionSetCandidatesClosure cl;\n+  g1h->collection_set()->candidates()->iterate(&cl);\n+  g1h->set_collection_set_candidates_stats(cl._total);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+\/\/ - Sample Collection Set Candidates (s)\n@@ -46,0 +47,1 @@\n+  class SampleCollectionSetCandidatesTask;\n@@ -71,0 +73,10 @@\n+class G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask : public G1AbstractSubTask {\n+public:\n+  SampleCollectionSetCandidatesTask() : G1AbstractSubTask(G1GCPhaseTimes::SampleCollectionSetCandidates) { }\n+\n+  static bool should_execute();\n+\n+  double worker_cost() const override;\n+  void do_work(uint worker_id) override;\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,2 +133,2 @@\n-          \"Each time the rset update queue increases by this amount \"       \\\n-          \"activate the next refinement thread if available. \"              \\\n+          \"Each time the remembered set update queue increases by this \"    \\\n+          \"amount activate the next refinement thread if available. \"       \\\n@@ -141,1 +141,2 @@\n-          \"process RS update buffers during the collection pause.\")         \\\n+          \"processing remembered set update buffers during the collection \" \\\n+          \"pause.\")                                                         \\\n@@ -156,20 +157,34 @@\n-  develop(intx, G1RSetRegionEntriesBase, 256,                               \\\n-          \"Max number of regions in a fine-grain table per MB.\")            \\\n-          range(1, max_jint\/wordSize)                                       \\\n-                                                                            \\\n-  product(intx, G1RSetRegionEntries, 0,                                     \\\n-          \"Max number of regions for which we keep bitmaps.\"                \\\n-          \"Will be set ergonomically by default\")                           \\\n-          range(0, max_jint\/wordSize)                                       \\\n-          constraint(G1RSetRegionEntriesConstraintFunc,AfterErgo)           \\\n-                                                                            \\\n-  develop(intx, G1RSetSparseRegionEntriesBase, 4,                           \\\n-          \"Max number of entries per region in a sparse table \"             \\\n-          \"per MB.\")                                                        \\\n-          range(1, max_jint\/wordSize)                                       \\\n-                                                                            \\\n-  product(intx, G1RSetSparseRegionEntries, 0,                               \\\n-          \"Max number of entries per region in a sparse table.\"             \\\n-          \"Will be set ergonomically by default.\")                          \\\n-          range(0, max_jint\/wordSize)                                       \\\n-          constraint(G1RSetSparseRegionEntriesConstraintFunc,AfterErgo)     \\\n+  develop(uint, G1RemSetArrayOfCardsEntriesBase, 4,                         \\\n+          \"Maximum number of entries per region in the Array of Cards \"     \\\n+          \"card set container per MB of a heap region.\")                    \\\n+          range(1, 65536)                                                   \\\n+                                                                            \\\n+  product(uint, G1RemSetArrayOfCardsEntries, 0,  EXPERIMENTAL,              \\\n+          \"Maximum number of entries per Array of Cards card set \"          \\\n+          \"container. Will be set ergonomically by default.\")               \\\n+          range(0, 65536)                                                   \\\n+          constraint(G1RemSetArrayOfCardsEntriesConstraintFunc,AfterErgo)   \\\n+                                                                            \\\n+  product(uint, G1RemSetHowlMaxNumBuckets, 8, EXPERIMENTAL,                 \\\n+          \"Maximum number of buckets per Howl card set container. The \"     \\\n+          \"default gives at worst bitmaps of size 8k. This showed to be a \" \\\n+          \"good tradeoff between bitmap size (waste) and cacheability of \"  \\\n+          \"the bucket array. Must be a power of two.\")                      \\\n+          range(1, 1024)                                                    \\\n+          constraint(G1RemSetHowlMaxNumBucketsConstraintFunc,AfterErgo)     \\\n+                                                                            \\\n+  product(uint, G1RemSetHowlNumBuckets, 0, EXPERIMENTAL,                    \\\n+          \"Number of buckets per Howl card set container. Must be a power \" \\\n+          \"of two. Will be set ergonomically by default.\")                  \\\n+          range(0, 1024)                                                    \\\n+          constraint(G1RemSetHowlNumBucketsConstraintFunc,AfterErgo)        \\\n+                                                                            \\\n+  product(uint, G1RemSetCoarsenHowlBitmapToHowlFullPercent, 90, EXPERIMENTAL, \\\n+          \"Percentage at which to coarsen a Howl bitmap to Howl full card \" \\\n+          \"set container.\")                                                 \\\n+          range(1, 100)                                                     \\\n+                                                                            \\\n+  product(uint, G1RemSetCoarsenHowlToFullPercent, 90, EXPERIMENTAL,         \\\n+          \"Percentage at which to coarsen a Howl card set to Full card \"    \\\n+          \"set container.\")                                                 \\\n+          range(1, 100)                                                     \\\n@@ -193,1 +208,1 @@\n-          \"The number of parallel rem set update threads. \"                 \\\n+          \"The number of parallel remembered set update threads. \"          \\\n@@ -312,1 +327,17 @@\n-  product(bool, G1AllowPreventiveGC, true, DIAGNOSTIC,                       \\\n+  product(uint, G1RemSetFreeMemoryRescheduleDelayMillis, 10, EXPERIMENTAL,  \\\n+          \"Time after which the card set free memory task reschedules \"     \\\n+          \"itself if there is work remaining.\")                             \\\n+          range(1, UINT_MAX)                                                \\\n+                                                                            \\\n+  product(double, G1RemSetFreeMemoryStepDurationMillis, 1, EXPERIMENTAL,    \\\n+          \"The amount of time that the free memory task should spend \"      \\\n+          \"before a pause of G1RemSetFreeMemoryRescheduleDelayMillis \"      \\\n+          \"length.\")                                                        \\\n+          range(1e-3, 1e+6)                                                 \\\n+                                                                            \\\n+  product(double, G1RemSetFreeMemoryKeepExcessRatio, 0.1, EXPERIMENTAL,     \\\n+          \"The percentage of free card set memory that G1 should keep as \"  \\\n+          \"percentage of the currently used memory.\")                       \\\n+          range(0.0, 1.0)                                                   \\\n+                                                                            \\\n+  product(bool, G1AllowPreventiveGC, true, DIAGNOSTIC,                      \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":57,"deletions":26,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -229,1 +229,2 @@\n-                       MemRegion mr) :\n+                       MemRegion mr,\n+                       G1CardSetConfiguration* config) :\n@@ -255,1 +256,1 @@\n-  _rem_set = new HeapRegionRemSet(bot, this);\n+  _rem_set = new HeapRegionRemSet(this, config);\n@@ -613,0 +614,2 @@\n+          LogStream ls(log.error());\n+          to->rem_set()->print_info(&ls, p);\n@@ -617,1 +620,0 @@\n-          LogStream ls(log.error());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+class G1CardSetConfiguration;\n+class G1CardSetMemoryManager;\n@@ -284,1 +286,4 @@\n-  HeapRegion(uint hrm_index, G1BlockOffsetTable* bot, MemRegion mr);\n+  HeapRegion(uint hrm_index,\n+             G1BlockOffsetTable* bot,\n+             MemRegion mr,\n+             G1CardSetConfiguration* config);\n@@ -448,0 +453,1 @@\n+  void set_rem_set(HeapRegionRemSet* rem_set) { _rem_set = rem_set; }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include <cstdio>\n+\n@@ -31,1 +33,0 @@\n-#include \"gc\/g1\/sparsePRT.inline.hpp\"\n@@ -47,346 +48,8 @@\n-PerRegionTable* PerRegionTable::alloc(HeapRegion* hr) {\n-  PerRegionTable* fl = _free_list;\n-  while (fl != NULL) {\n-    PerRegionTable* nxt = fl->next();\n-    PerRegionTable* res = Atomic::cmpxchg(&_free_list, fl, nxt);\n-    if (res == fl) {\n-      fl->init(hr, true);\n-      return fl;\n-    } else {\n-      fl = _free_list;\n-    }\n-  }\n-  assert(fl == NULL, \"Loop condition.\");\n-  return new PerRegionTable(hr);\n-}\n-\n-PerRegionTable* volatile PerRegionTable::_free_list = NULL;\n-\n-size_t OtherRegionsTable::_max_fine_entries = 0;\n-size_t OtherRegionsTable::_mod_max_fine_entries_mask = 0;\n-size_t OtherRegionsTable::_fine_eviction_stride = 0;\n-size_t OtherRegionsTable::_fine_eviction_sample_size = 0;\n-\n-OtherRegionsTable::OtherRegionsTable(Mutex* m) :\n-  _g1h(G1CollectedHeap::heap()),\n-  _m(m),\n-  _num_occupied(0),\n-  _coarse_map(mtGC),\n-  _has_coarse_entries(false),\n-  _fine_grain_regions(NULL),\n-  _n_fine_entries(0),\n-  _first_all_fine_prts(NULL),\n-  _last_all_fine_prts(NULL),\n-  _fine_eviction_start(0),\n-  _sparse_table()\n-{\n-  typedef PerRegionTable* PerRegionTablePtr;\n-\n-  if (_max_fine_entries == 0) {\n-    assert(_mod_max_fine_entries_mask == 0, \"Both or none.\");\n-    size_t max_entries_log = (size_t)log2i(G1RSetRegionEntries);\n-    _max_fine_entries = (size_t)1 << max_entries_log;\n-    _mod_max_fine_entries_mask = _max_fine_entries - 1;\n-\n-    assert(_fine_eviction_sample_size == 0\n-           && _fine_eviction_stride == 0, \"All init at same time.\");\n-    _fine_eviction_sample_size = MAX2((size_t)4, max_entries_log);\n-    _fine_eviction_stride = _max_fine_entries \/ _fine_eviction_sample_size;\n-  }\n-\n-  _fine_grain_regions = NEW_C_HEAP_ARRAY(PerRegionTablePtr, _max_fine_entries, mtGC);\n-  for (size_t i = 0; i < _max_fine_entries; i++) {\n-    _fine_grain_regions[i] = NULL;\n-  }\n-}\n-\n-void OtherRegionsTable::link_to_all(PerRegionTable* prt) {\n-  \/\/ We always append to the beginning of the list for convenience;\n-  \/\/ the order of entries in this list does not matter.\n-  if (_first_all_fine_prts != NULL) {\n-    prt->set_next(_first_all_fine_prts);\n-  } else {\n-    \/\/ this is the first element we insert. Adjust the \"last\" pointer\n-    _last_all_fine_prts = prt;\n-    assert(prt->next() == NULL, \"just checking\");\n-  }\n-  _first_all_fine_prts = prt;\n-\n-  assert(_first_all_fine_prts == prt, \"just checking\");\n-  assert((_first_all_fine_prts == NULL && _last_all_fine_prts == NULL) ||\n-         (_first_all_fine_prts != NULL && _last_all_fine_prts != NULL),\n-         \"just checking\");\n-  assert(_last_all_fine_prts == NULL || _last_all_fine_prts->next() == NULL,\n-         \"just checking\");\n-}\n-\n-CardIdx_t OtherRegionsTable::card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr) {\n-  assert(hr->is_in_reserved(within_region),\n-         \"HeapWord \" PTR_FORMAT \" is outside of region %u [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-         p2i(within_region), hr->hrm_index(), p2i(hr->bottom()), p2i(hr->end()));\n-  CardIdx_t result = (CardIdx_t)(pointer_delta((HeapWord*)within_region, hr->bottom()) >> (CardTable::card_shift - LogHeapWordSize));\n-  return result;\n-}\n-\n-void OtherRegionsTable::add_reference(OopOrNarrowOopStar from, uint tid) {\n-  \/\/ Note that this may be a continued H region.\n-  HeapRegion* from_hr = _g1h->heap_region_containing(from);\n-  RegionIdx_t from_hrm_ind = (RegionIdx_t) from_hr->hrm_index();\n-\n-  \/\/ If the region is already coarsened, return.\n-  if (is_region_coarsened(from_hrm_ind)) {\n-    assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the Coarse table\", p2i(from));\n-    return;\n-  }\n-\n-  size_t num_added_by_coarsening = 0;\n-  \/\/ Otherwise find a per-region table to add it to.\n-  size_t ind = from_hrm_ind & _mod_max_fine_entries_mask;\n-  PerRegionTable* prt = find_region_table(ind, from_hr);\n-  if (prt == NULL) {\n-    MutexLocker x(_m, Mutex::_no_safepoint_check_flag);\n-\n-    \/\/ Rechecking if the region is coarsened, while holding the lock.\n-    if (is_region_coarsened(from_hrm_ind)) {\n-      assert(contains_reference_locked(from), \"We just found \" PTR_FORMAT \" in the Coarse table\", p2i(from));\n-      return;\n-    }\n-\n-    \/\/ Confirm that it's really not there...\n-    prt = find_region_table(ind, from_hr);\n-    if (prt == NULL) {\n-\n-      CardIdx_t card_index = card_within_region(from, from_hr);\n-\n-      SparsePRT::AddCardResult result = _sparse_table.add_card(from_hrm_ind, card_index);\n-      if (result != SparsePRT::overflow) {\n-        if (result == SparsePRT::added) {\n-          Atomic::inc(&_num_occupied, memory_order_relaxed);\n-        }\n-        assert(contains_reference_locked(from), \"We just added \" PTR_FORMAT \" to the Sparse table\", p2i(from));\n-        return;\n-      }\n-\n-      \/\/ Sparse PRT returned overflow (sparse table is full)\n-\n-      if (_n_fine_entries == _max_fine_entries) {\n-        prt = delete_region_table(num_added_by_coarsening);\n-        \/\/ There is no need to clear the links to the 'all' list here:\n-        \/\/ prt will be reused immediately, i.e. remain in the 'all' list.\n-        prt->init(from_hr, false \/* clear_links_to_all_list *\/);\n-      } else {\n-        prt = PerRegionTable::alloc(from_hr);\n-        link_to_all(prt);\n-      }\n-\n-      PerRegionTable* first_prt = _fine_grain_regions[ind];\n-      prt->set_collision_list_next(first_prt);\n-      \/\/ The assignment into _fine_grain_regions allows the prt to\n-      \/\/ start being used concurrently. In addition to\n-      \/\/ collision_list_next which must be visible (else concurrent\n-      \/\/ parsing of the list, if any, may fail to see other entries),\n-      \/\/ the content of the prt must be visible (else for instance\n-      \/\/ some mark bits may not yet seem cleared or a 'later' update\n-      \/\/ performed by a concurrent thread could be undone when the\n-      \/\/ zeroing becomes visible). This requires store ordering.\n-      Atomic::release_store(&_fine_grain_regions[ind], prt);\n-      _n_fine_entries++;\n-\n-      \/\/ Transfer from sparse to fine-grain. The cards from the sparse table\n-      \/\/ were already added to the total in _num_occupied.\n-      SparsePRTEntry *sprt_entry = _sparse_table.get_entry(from_hrm_ind);\n-      assert(sprt_entry != NULL, \"There should have been an entry\");\n-      for (int i = 0; i < sprt_entry->num_valid_cards(); i++) {\n-        CardIdx_t c = sprt_entry->card(i);\n-        prt->add_card(c);\n-      }\n-      \/\/ Now we can delete the sparse entry.\n-      bool res = _sparse_table.delete_entry(from_hrm_ind);\n-      assert(res, \"It should have been there.\");\n-    }\n-    assert(prt != NULL && prt->hr() == from_hr, \"consequence\");\n-  }\n-  \/\/ Note that we can't assert \"prt->hr() == from_hr\", because of the\n-  \/\/ possibility of concurrent reuse.  But see head comment of\n-  \/\/ OtherRegionsTable for why this is OK.\n-  assert(prt != NULL, \"Inv\");\n-\n-  if (prt->add_reference(from)) {\n-    num_added_by_coarsening++;\n-  }\n-  Atomic::add(&_num_occupied, num_added_by_coarsening, memory_order_relaxed);\n-  assert(contains_reference(from), \"We just added \" PTR_FORMAT \" to the PRT (%d)\", p2i(from), prt->contains_reference(from));\n-}\n-\n-PerRegionTable*\n-OtherRegionsTable::find_region_table(size_t ind, HeapRegion* hr) const {\n-  assert(ind < _max_fine_entries, \"Preconditions.\");\n-  PerRegionTable* prt = _fine_grain_regions[ind];\n-  while (prt != NULL && prt->hr() != hr) {\n-    prt = prt->collision_list_next();\n-  }\n-  \/\/ Loop postcondition is the method postcondition.\n-  return prt;\n-}\n-\n-jint OtherRegionsTable::_n_coarsenings = 0;\n-\n-PerRegionTable* OtherRegionsTable::delete_region_table(size_t& added_by_deleted) {\n-  assert(_m->owned_by_self(), \"Precondition\");\n-  assert(_n_fine_entries == _max_fine_entries, \"Precondition\");\n-  PerRegionTable* max = NULL;\n-  jint max_occ = 0;\n-  PerRegionTable** max_prev = NULL;\n-\n-  size_t i = _fine_eviction_start;\n-  for (size_t k = 0; k < _fine_eviction_sample_size; k++) {\n-    size_t ii = i;\n-    \/\/ Make sure we get a non-NULL sample.\n-    while (_fine_grain_regions[ii] == NULL) {\n-      ii++;\n-      if (ii == _max_fine_entries) ii = 0;\n-      guarantee(ii != i, \"We must find one.\");\n-    }\n-    PerRegionTable** prev = &_fine_grain_regions[ii];\n-    PerRegionTable* cur = *prev;\n-    while (cur != NULL) {\n-      jint cur_occ = cur->occupied();\n-      if (max == NULL || cur_occ > max_occ) {\n-        max = cur;\n-        max_prev = prev;\n-        max_occ = cur_occ;\n-      }\n-      prev = cur->collision_list_next_addr();\n-      cur = cur->collision_list_next();\n-    }\n-    i = i + _fine_eviction_stride;\n-    if (i >= _n_fine_entries) i = i - _n_fine_entries;\n-  }\n-\n-  _fine_eviction_start++;\n-\n-  if (_fine_eviction_start >= _n_fine_entries) {\n-    _fine_eviction_start -= _n_fine_entries;\n-  }\n-\n-  guarantee(max != NULL, \"Since _n_fine_entries > 0\");\n-  guarantee(max_prev != NULL, \"Since max != NULL.\");\n-\n-  \/\/ Ensure the corresponding coarse bit is set.\n-  size_t max_hrm_index = (size_t) max->hr()->hrm_index();\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    _coarse_map.at_put(max_hrm_index, true);\n-  } else {\n-    \/\/ This will lazily initialize an uninitialized bitmap\n-    _coarse_map.reinitialize(G1CollectedHeap::heap()->max_reserved_regions());\n-    assert(!_coarse_map.at(max_hrm_index), \"No coarse entries\");\n-    _coarse_map.at_put(max_hrm_index, true);\n-    \/\/ Release store guarantees that the bitmap has initialized before any\n-    \/\/ concurrent reader will ever see _has_coarse_entries is true\n-    \/\/ (when read with load_acquire)\n-    Atomic::release_store(&_has_coarse_entries, true);\n-  }\n-\n-  added_by_deleted = HeapRegion::CardsPerRegion - max_occ;\n-  \/\/ Unsplice.\n-  *max_prev = max->collision_list_next();\n-  Atomic::inc(&_n_coarsenings);\n-  _n_fine_entries--;\n-  return max;\n-}\n-\n-bool OtherRegionsTable::occupancy_less_or_equal_than(size_t limit) const {\n-  return occupied() <= limit;\n-}\n-\n-bool OtherRegionsTable::is_empty() const {\n-  return occupied() == 0;\n-}\n-\n-size_t OtherRegionsTable::occupied() const {\n-  return _num_occupied;\n-}\n-\n-size_t OtherRegionsTable::mem_size() const {\n-  size_t sum = 0;\n-  \/\/ all PRTs are of the same size so it is sufficient to query only one of them.\n-  if (_first_all_fine_prts != NULL) {\n-    assert(_last_all_fine_prts != NULL &&\n-      _first_all_fine_prts->mem_size() == _last_all_fine_prts->mem_size(), \"check that mem_size() is constant\");\n-    sum += _first_all_fine_prts->mem_size() * _n_fine_entries;\n-  }\n-  sum += (sizeof(PerRegionTable*) * _max_fine_entries);\n-  sum += (_coarse_map.size_in_words() * HeapWordSize);\n-  sum += (_sparse_table.mem_size());\n-  sum += sizeof(OtherRegionsTable) - sizeof(_sparse_table); \/\/ Avoid double counting above.\n-  return sum;\n-}\n-\n-size_t OtherRegionsTable::static_mem_size() {\n-  return G1FromCardCache::static_mem_size();\n-}\n-\n-size_t OtherRegionsTable::fl_mem_size() {\n-  return PerRegionTable::fl_mem_size();\n-}\n-\n-void OtherRegionsTable::clear() {\n-  \/\/ if there are no entries, skip this step\n-  if (_first_all_fine_prts != NULL) {\n-    guarantee(_first_all_fine_prts != NULL && _last_all_fine_prts != NULL, \"just checking\");\n-    PerRegionTable::bulk_free(_first_all_fine_prts, _last_all_fine_prts);\n-    memset(_fine_grain_regions, 0, _max_fine_entries * sizeof(_fine_grain_regions[0]));\n-  } else {\n-    guarantee(_first_all_fine_prts == NULL && _last_all_fine_prts == NULL, \"just checking\");\n-  }\n-\n-  _first_all_fine_prts = _last_all_fine_prts = NULL;\n-  _sparse_table.clear();\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    _coarse_map.clear();\n-  }\n-  _n_fine_entries = 0;\n-  Atomic::store(&_has_coarse_entries, false);\n-\n-  _num_occupied = 0;\n-}\n-\n-bool OtherRegionsTable::contains_reference(OopOrNarrowOopStar from) const {\n-  \/\/ Cast away const in this case.\n-  MutexLocker x((Mutex*)_m, Mutex::_no_safepoint_check_flag);\n-  return contains_reference_locked(from);\n-}\n-\n-bool OtherRegionsTable::contains_reference_locked(OopOrNarrowOopStar from) const {\n-  HeapRegion* hr = _g1h->heap_region_containing(from);\n-  RegionIdx_t hr_ind = (RegionIdx_t) hr->hrm_index();\n-  \/\/ Is this region in the coarse map?\n-  if (is_region_coarsened(hr_ind)) return true;\n-\n-  PerRegionTable* prt = find_region_table(hr_ind & _mod_max_fine_entries_mask,\n-                                          hr);\n-  if (prt != NULL) {\n-    return prt->contains_reference(from);\n-  } else {\n-    CardIdx_t card_index = card_within_region(from, hr);\n-    return _sparse_table.contains_card(hr_ind, card_index);\n-  }\n-}\n-\n-\/\/ A load_acquire on _has_coarse_entries - coupled with the release_store in\n-\/\/ delete_region_table - guarantees we don't access _coarse_map before\n-\/\/ it's been properly initialized.\n-bool OtherRegionsTable::is_region_coarsened(RegionIdx_t from_hrm_ind) const {\n-  return Atomic::load_acquire(&_has_coarse_entries) && _coarse_map.at(from_hrm_ind);\n-}\n-\n-HeapRegionRemSet::HeapRegionRemSet(G1BlockOffsetTable* bot,\n-                                   HeapRegion* hr)\n-  : _bot(bot),\n-    _code_roots(),\n-    _m(Mutex::leaf, FormatBuffer<128>(\"HeapRegionRemSet lock #%u\", hr->hrm_index()), true, Mutex::_safepoint_check_never),\n-    _other_regions(&_m),\n-    _hr(hr),\n-    _state(Untracked)\n-{\n-}\n+HeapRegionRemSet::HeapRegionRemSet(HeapRegion* hr,\n+                                   G1CardSetConfiguration* config) :\n+  _m(Mutex::leaf + 1, FormatBuffer<128>(\"HeapRegionRemSet lock #%u\", hr->hrm_index()), true, Monitor::_safepoint_check_never),\n+  _code_roots(),\n+  _card_set_mm(config, G1CardSetFreePool::free_list_pool()),\n+  _card_set(config, &_card_set_mm),\n+  _hr(hr),\n+  _state(Untracked) { }\n@@ -398,14 +61,0 @@\n-void HeapRegionRemSet::setup_remset_size() {\n-  const int LOG_M = 20;\n-  guarantee(HeapRegion::LogOfHRGrainBytes >= LOG_M, \"Code assumes the region size >= 1M, but is \" SIZE_FORMAT \"B\", HeapRegion::GrainBytes);\n-\n-  int region_size_log_mb = HeapRegion::LogOfHRGrainBytes - LOG_M;\n-  if (FLAG_IS_DEFAULT(G1RSetSparseRegionEntries)) {\n-    G1RSetSparseRegionEntries = G1RSetSparseRegionEntriesBase * ((size_t)1 << (region_size_log_mb + 1));\n-  }\n-  if (FLAG_IS_DEFAULT(G1RSetRegionEntries)) {\n-    G1RSetRegionEntries = G1RSetRegionEntriesBase * (region_size_log_mb + 1);\n-  }\n-  guarantee(G1RSetSparseRegionEntries > 0 && G1RSetRegionEntries > 0 , \"Sanity\");\n-}\n-\n@@ -422,1 +71,1 @@\n-  _other_regions.clear();\n+  _card_set.clear();\n@@ -427,0 +76,4 @@\n+void HeapRegionRemSet::print_static_mem_size(outputStream* out) {\n+  out->print_cr(\"  Static structures = \" SIZE_FORMAT, HeapRegionRemSet::static_mem_size());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":15,"deletions":362,"binary":false,"changes":377,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -34,240 +36,1 @@\n-\/\/ Remembered set for a heap region.  Represent a set of \"cards\" that\n-\/\/ contain pointers into the owner heap region.  Cards are defined somewhat\n-\/\/ abstractly, in terms of what the \"BlockOffsetTable\" in use can parse.\n-\n-class G1CollectedHeap;\n-class G1BlockOffsetTable;\n-class G1CardLiveData;\n-class HeapRegion;\n-class PerRegionTable;\n-class SparsePRT;\n-class nmethod;\n-\n-\/\/ The \"_coarse_map\" is a bitmap with one bit for each region, where set\n-\/\/ bits indicate that the corresponding region may contain some pointer\n-\/\/ into the owning region.\n-\n-\/\/ The \"_fine_grain_entries\" array is an open hash table of PerRegionTables\n-\/\/ (PRTs), indicating regions for which we're keeping the RS as a set of\n-\/\/ cards.  The strategy is to cap the size of the fine-grain table,\n-\/\/ deleting an entry and setting the corresponding coarse-grained bit when\n-\/\/ we would overflow this cap.\n-\n-\/\/ We use a mixture of locking and lock-free techniques here.  We allow\n-\/\/ threads to locate PRTs without locking, but threads attempting to alter\n-\/\/ a bucket list obtain a lock.  This means that any failing attempt to\n-\/\/ find a PRT must be retried with the lock.  It might seem dangerous that\n-\/\/ a read can find a PRT that is concurrently deleted.  This is all right,\n-\/\/ because:\n-\/\/\n-\/\/   1) We only actually free PRT's at safe points (though we reuse them at\n-\/\/      other times).\n-\/\/   2) We find PRT's in an attempt to add entries.  If a PRT is deleted,\n-\/\/      it's _coarse_map bit is set, so the that we were attempting to add\n-\/\/      is represented.  If a deleted PRT is re-used, a thread adding a bit,\n-\/\/      thinking the PRT is for a different region, does no harm.\n-\n-class OtherRegionsTable {\n-  G1CollectedHeap* _g1h;\n-  Mutex*           _m;\n-\n-  size_t volatile _num_occupied;\n-\n-  \/\/ These are protected by \"_m\".\n-  CHeapBitMap   _coarse_map;\n-  bool volatile _has_coarse_entries;\n-  static jint   _n_coarsenings;\n-\n-  PerRegionTable** _fine_grain_regions;\n-  size_t           _n_fine_entries;\n-\n-  \/\/ The fine grain remembered sets are linked together using\n-  \/\/ their 'next' fields.\n-  \/\/ This allows fast bulk freeing of all the fine grain remembered\n-  \/\/ set entries, and fast finding of all of them without iterating\n-  \/\/ over the _fine_grain_regions table.\n-  PerRegionTable * _first_all_fine_prts;\n-  PerRegionTable * _last_all_fine_prts;\n-\n-  \/\/ Used to sample a subset of the fine grain PRTs to determine which\n-  \/\/ PRT to evict and coarsen.\n-  size_t        _fine_eviction_start;\n-  static size_t _fine_eviction_stride;\n-  static size_t _fine_eviction_sample_size;\n-\n-  SparsePRT   _sparse_table;\n-\n-  \/\/ These are static after init.\n-  static size_t _max_fine_entries;\n-  static size_t _mod_max_fine_entries_mask;\n-\n-  \/\/ Requires \"prt\" to be the first element of the bucket list appropriate\n-  \/\/ for \"hr\".  If this list contains an entry for \"hr\", return it,\n-  \/\/ otherwise return \"NULL\".\n-  PerRegionTable* find_region_table(size_t ind, HeapRegion* hr) const;\n-\n-  \/\/ Find, delete, and return a candidate PerRegionTable, if any exists,\n-  \/\/ adding the deleted region to the coarse bitmap.  Requires the caller\n-  \/\/ to hold _m, and the fine-grain table to be full.\n-  PerRegionTable* delete_region_table(size_t& added_by_deleted);\n-\n-  \/\/ link\/add the given fine grain remembered set into the \"all\" list\n-  void link_to_all(PerRegionTable * prt);\n-\n-  bool contains_reference_locked(OopOrNarrowOopStar from) const;\n-\n-public:\n-  \/\/ Create a new remembered set. The given mutex is used to ensure consistency.\n-  OtherRegionsTable(Mutex* m);\n-\n-  template <class Closure>\n-  void iterate(Closure& v);\n-\n-  \/\/ Returns the card index of the given within_region pointer relative to the bottom\n-  \/\/ of the given heap region.\n-  static CardIdx_t card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr);\n-  \/\/ Adds the reference from \"from to this remembered set.\n-  void add_reference(OopOrNarrowOopStar from, uint tid);\n-\n-  \/\/ Returns whether the remembered set contains the given reference.\n-  bool contains_reference(OopOrNarrowOopStar from) const;\n-\n-  \/\/ Returns whether this remembered set (and all sub-sets) have an occupancy\n-  \/\/ that is less or equal than the given occupancy.\n-  bool occupancy_less_or_equal_than(size_t limit) const;\n-\n-  \/\/ Returns whether this remembered set (and all sub-sets) does not contain any entry.\n-  bool is_empty() const;\n-\n-  \/\/ Returns the number of cards contained in this remembered set.\n-  size_t occupied() const;\n-\n-  static jint n_coarsenings() { return _n_coarsenings; }\n-\n-  \/\/ Returns size of the actual remembered set containers in bytes.\n-  size_t mem_size() const;\n-  \/\/ Returns the size of static data in bytes.\n-  static size_t static_mem_size();\n-  \/\/ Returns the size of the free list content in bytes.\n-  static size_t fl_mem_size();\n-\n-  \/\/ Clear the entire contents of this remembered set.\n-  void clear();\n-\n-  \/\/ Safe for use by concurrent readers outside _m\n-  bool is_region_coarsened(RegionIdx_t from_hrm_ind) const;\n-};\n-\n-class PerRegionTable: public CHeapObj<mtGC> {\n-  friend class OtherRegionsTable;\n-\n-  HeapRegion*     _hr;\n-  CHeapBitMap     _bm;\n-  jint            _occupied;\n-\n-  \/\/ next pointer for free\/allocated 'all' list\n-  PerRegionTable* _next;\n-\n-  \/\/ next pointer in collision list\n-  PerRegionTable * _collision_list_next;\n-\n-  \/\/ Global free list of PRTs\n-  static PerRegionTable* volatile _free_list;\n-\n-protected:\n-  PerRegionTable(HeapRegion* hr) :\n-    _hr(hr),\n-    _bm(HeapRegion::CardsPerRegion, mtGC),\n-    _occupied(0),\n-    _next(NULL),\n-    _collision_list_next(NULL)\n-  {}\n-\n-public:\n-  \/\/ We need access in order to union things into the base table.\n-  BitMap* bm() { return &_bm; }\n-\n-  HeapRegion* hr() const { return Atomic::load_acquire(&_hr); }\n-\n-  jint occupied() const {\n-    return _occupied;\n-  }\n-\n-  void init(HeapRegion* hr, bool clear_links_to_all_list);\n-\n-  inline bool add_reference(OopOrNarrowOopStar from);\n-\n-  inline bool add_card(CardIdx_t from_card_index);\n-\n-  \/\/ (Destructively) union the bitmap of the current table into the given\n-  \/\/ bitmap (which is assumed to be of the same size.)\n-  void union_bitmap_into(BitMap* bm) {\n-    bm->set_union(_bm);\n-  }\n-\n-  \/\/ Mem size in bytes.\n-  size_t mem_size() const {\n-    return sizeof(PerRegionTable) + _bm.size_in_words() * HeapWordSize;\n-  }\n-\n-  \/\/ Requires \"from\" to be in \"hr()\".\n-  bool contains_reference(OopOrNarrowOopStar from) const {\n-    assert(hr()->is_in_reserved(from), \"Precondition.\");\n-    size_t card_ind = pointer_delta(from, hr()->bottom(),\n-                                    G1CardTable::card_size);\n-    return _bm.at(card_ind);\n-  }\n-\n-  \/\/ Bulk-free the PRTs from prt to last, assumes that they are\n-  \/\/ linked together using their _next field.\n-  static void bulk_free(PerRegionTable* prt, PerRegionTable* last) {\n-    while (true) {\n-      PerRegionTable* fl = _free_list;\n-      last->set_next(fl);\n-      PerRegionTable* res = Atomic::cmpxchg(&_free_list, fl, prt);\n-      if (res == fl) {\n-        return;\n-      }\n-    }\n-    ShouldNotReachHere();\n-  }\n-\n-  static void free(PerRegionTable* prt) {\n-    bulk_free(prt, prt);\n-  }\n-\n-  \/\/ Returns an initialized PerRegionTable instance.\n-  static PerRegionTable* alloc(HeapRegion* hr);\n-\n-  PerRegionTable* next() const { return _next; }\n-  void set_next(PerRegionTable* next) { _next = next; }\n-\n-  \/\/ Accessor and Modification routines for the pointer for the\n-  \/\/ singly linked collision list that links the PRTs within the\n-  \/\/ OtherRegionsTable::_fine_grain_regions hash table.\n-  \/\/\n-\n-  PerRegionTable* collision_list_next() const {\n-    return _collision_list_next;\n-  }\n-\n-  void set_collision_list_next(PerRegionTable* next) {\n-    _collision_list_next = next;\n-  }\n-\n-  PerRegionTable** collision_list_next_addr() {\n-    return &_collision_list_next;\n-  }\n-\n-  static size_t fl_mem_size() {\n-    PerRegionTable* cur = _free_list;\n-    size_t res = 0;\n-    while (cur != NULL) {\n-      res += cur->mem_size();\n-      cur = cur->next();\n-    }\n-    return res;\n-  }\n-\n-  static void test_fl_mem_size();\n-};\n+class outputStream;\n@@ -278,3 +41,1 @@\n-private:\n-  G1BlockOffsetTable* _bot;\n-\n+  Mutex _m;\n@@ -285,1 +46,1 @@\n-  Mutex _m;\n+  G1CardSetMemoryManager _card_set_mm;\n@@ -287,1 +48,2 @@\n-  OtherRegionsTable _other_regions;\n+  \/\/ The set of cards in the Java heap\n+  G1CardSet _card_set;\n@@ -291,0 +53,1 @@\n+  inline void split_card(OopOrNarrowOopStar from, uint& card_region, uint& card_within_region) const;\n@@ -294,1 +57,1 @@\n-  HeapRegionRemSet(G1BlockOffsetTable* bot, HeapRegion* hr);\n+  HeapRegionRemSet(HeapRegion* hr, G1CardSetConfiguration* config);\n@@ -297,1 +60,3 @@\n-  static void setup_remset_size();\n+  bool cardset_is_empty() const {\n+    return _card_set.is_empty();\n+  }\n@@ -300,1 +65,1 @@\n-    return (strong_code_roots_list_length() == 0) && _other_regions.is_empty();\n+    return (strong_code_roots_list_length() == 0) && cardset_is_empty();\n@@ -304,1 +69,1 @@\n-    return (strong_code_roots_list_length() == 0) && _other_regions.occupancy_less_or_equal_than(occ);\n+    return (strong_code_roots_list_length() == 0) && _card_set.occupancy_less_or_equal_to(occ);\n@@ -307,8 +72,5 @@\n-  \/\/ For each PRT in the card (remembered) set call one of the following methods\n-  \/\/ of the given closure:\n-  \/\/\n-  \/\/ set_full_region_dirty(uint region_idx) - pass the region index for coarse PRTs\n-  \/\/ set_bitmap_dirty(uint region_idx, BitMap* bitmap) - pass the region index and bitmap for fine PRTs\n-  \/\/ set_cards_dirty(uint region_idx, elem_t* cards, uint num_cards) - pass region index and cards for sparse PRTs\n-  template <class Closure>\n-  inline void iterate_prts(Closure& cl);\n+  \/\/ Iterate the card based remembered set for merging them into the card table.\n+  \/\/ The passed closure must be a CardOrRangeVisitor; we use a template parameter\n+  \/\/ to pass it in to facilitate inlining as much as possible.\n+  template <class CardOrRangeVisitor>\n+  inline void iterate_for_merge(CardOrRangeVisitor& cl);\n@@ -317,1 +79,1 @@\n-    return _other_regions.occupied();\n+    return _card_set.occupied();\n@@ -320,1 +82,2 @@\n-  static jint n_coarsenings() { return OtherRegionsTable::n_coarsenings(); }\n+  \/\/ Coarsening statistics since VM start.\n+  static G1CardSetCoarsenStats coarsen_stats() { return G1CardSet::coarsen_stats(); }\n@@ -342,8 +105,3 @@\n-  void set_state_empty() {\n-    guarantee(SafepointSynchronize::is_at_safepoint() || !is_tracked(), \"Should only set to Untracked during safepoint but is %s.\", get_state_str());\n-    if (_state == Untracked) {\n-      return;\n-    }\n-    clear_fcc();\n-    _state = Untracked;\n-  }\n+  inline void set_state_empty();\n+  inline void set_state_updating();\n+  inline void set_state_complete();\n@@ -351,27 +109,1 @@\n-  void set_state_updating() {\n-    guarantee(SafepointSynchronize::is_at_safepoint() && !is_tracked(), \"Should only set to Updating from Untracked during safepoint but is %s\", get_state_str());\n-    clear_fcc();\n-    _state = Updating;\n-  }\n-\n-  void set_state_complete() {\n-    clear_fcc();\n-    _state = Complete;\n-  }\n-\n-  void add_reference(OopOrNarrowOopStar from, uint tid) {\n-    RemSetState state = _state;\n-    if (state == Untracked) {\n-      return;\n-    }\n-\n-    uint cur_idx = _hr->hrm_index();\n-    uintptr_t from_card = uintptr_t(from) >> CardTable::card_shift;\n-\n-    if (G1FromCardCache::contains_or_replace(tid, cur_idx, from_card)) {\n-      assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the FromCardCache\", p2i(from));\n-      return;\n-    }\n-\n-    _other_regions.add_reference(from, tid);\n-  }\n+  inline void add_reference(OopOrNarrowOopStar from, uint tid);\n@@ -384,2 +116,4 @@\n-  \/\/ The actual # of bytes this hr_remset takes up.\n-  \/\/ Note also includes the strong code root set.\n+  G1CardSetMemoryStats card_set_memory_stats() const { return _card_set_mm.memory_stats(); }\n+\n+  \/\/ The actual # of bytes this hr_remset takes up. Also includes the strong code\n+  \/\/ root set.\n@@ -387,5 +121,2 @@\n-    MutexLocker x(&_m, Mutex::_no_safepoint_check_flag);\n-    return _other_regions.mem_size()\n-      \/\/ This correction is necessary because the above includes the second\n-      \/\/ part.\n-      + (sizeof(HeapRegionRemSet) - sizeof(OtherRegionsTable))\n+    return _card_set.mem_size()\n+      + (sizeof(HeapRegionRemSet) - sizeof(G1CardSet)) \/\/ Avoid double-counting G1CardSet.\n@@ -395,0 +126,4 @@\n+  size_t wasted_mem_size() {\n+    return _card_set.wasted_mem_size();\n+  }\n+\n@@ -398,1 +133,1 @@\n-    return OtherRegionsTable::static_mem_size() + G1CodeRootSet::static_mem_size();\n+    return G1CardSet::static_mem_size() + G1CodeRootSet::static_mem_size() + sizeof(G1CardSetFreePool);\n@@ -401,5 +136,1 @@\n-  \/\/ Returns the memory occupancy of all free_list data structures associated\n-  \/\/ with remembered sets.\n-  static size_t fl_mem_size() {\n-    return OtherRegionsTable::fl_mem_size();\n-  }\n+  static void print_static_mem_size(outputStream* out);\n@@ -407,3 +138,3 @@\n-  bool contains_reference(OopOrNarrowOopStar from) const {\n-    return _other_regions.contains_reference(from);\n-  }\n+  inline bool contains_reference(OopOrNarrowOopStar from);\n+\n+  inline void print_info(outputStream* st, OopOrNarrowOopStar from);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":43,"deletions":312,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -31,1 +33,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -35,3 +36,8 @@\n-template <class Closure>\n-inline void HeapRegionRemSet::iterate_prts(Closure& cl) {\n-  _other_regions.iterate(cl);\n+void HeapRegionRemSet::set_state_empty() {\n+  guarantee(SafepointSynchronize::is_at_safepoint() || !is_tracked(),\n+            \"Should only set to Untracked during safepoint but is %s.\", get_state_str());\n+  if (_state == Untracked) {\n+    return;\n+  }\n+  clear_fcc();\n+  _state = Untracked;\n@@ -40,6 +46,5 @@\n-inline bool PerRegionTable::add_card(CardIdx_t from_card_index) {\n-  if (_bm.par_set_bit(from_card_index)) {\n-    Atomic::inc(&_occupied, memory_order_relaxed);\n-    return true;\n-  }\n-  return false;\n+void HeapRegionRemSet::set_state_updating() {\n+  guarantee(SafepointSynchronize::is_at_safepoint() && !is_tracked(),\n+            \"Should only set to Updating from Untracked during safepoint but is %s\", get_state_str());\n+  clear_fcc();\n+  _state = Updating;\n@@ -48,13 +53,3 @@\n-inline bool PerRegionTable::add_reference(OopOrNarrowOopStar from) {\n-  \/\/ Must make this robust in case \"from\" is not in \"_hr\", because of\n-  \/\/ concurrency.\n-\n-  HeapRegion* loc_hr = hr();\n-  \/\/ If the test below fails, then this table was reused concurrently\n-  \/\/ with this operation.  This is OK, since the old table was coarsened,\n-  \/\/ and adding a bit to the new table is never incorrect.\n-  if (loc_hr->is_in_reserved(from)) {\n-    CardIdx_t from_card = OtherRegionsTable::card_within_region(from, loc_hr);\n-    return add_card(from_card);\n-  }\n-  return false;\n+void HeapRegionRemSet::set_state_complete() {\n+  clear_fcc();\n+  _state = Complete;\n@@ -63,10 +58,4 @@\n-inline void PerRegionTable::init(HeapRegion* hr, bool clear_links_to_all_list) {\n-  if (clear_links_to_all_list) {\n-    set_next(NULL);\n-  }\n-  _collision_list_next = NULL;\n-  _occupied = 0;\n-  _bm.clear();\n-  \/\/ Make sure that the bitmap clearing above has been finished before publishing\n-  \/\/ this PRT to concurrent threads.\n-  Atomic::release_store(&_hr, hr);\n+\n+template <class CardOrRangeVisitor>\n+inline void HeapRegionRemSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n+  _card_set.iterate_for_merge(cl);\n@@ -75,15 +64,10 @@\n-template <class Closure>\n-void OtherRegionsTable::iterate(Closure& cl) {\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    BitMap::idx_t cur = _coarse_map.get_next_one_offset(0);\n-    while (cur != _coarse_map.size()) {\n-      cl.next_coarse_prt((uint)cur);\n-      cur = _coarse_map.get_next_one_offset(cur + 1);\n-    }\n-  }\n-  {\n-    PerRegionTable* cur = _first_all_fine_prts;\n-    while (cur != NULL) {\n-      cl.next_fine_prt(cur->hr()->hrm_index(), cur->bm());\n-      cur = cur->next();\n-    }\n+void HeapRegionRemSet::split_card(OopOrNarrowOopStar from, uint& card_region, uint& card_within_region) const {\n+  HeapRegion* hr = G1CollectedHeap::heap()->heap_region_containing(from);\n+  card_region = hr->hrm_index();\n+  card_within_region = (uint)(pointer_delta((HeapWord*)from, hr->bottom()) >> (CardTable::card_shift - LogHeapWordSize));\n+}\n+\n+void HeapRegionRemSet::add_reference(OopOrNarrowOopStar from, uint tid) {\n+  RemSetState state = _state;\n+  if (state == Untracked) {\n+    return;\n@@ -91,6 +75,9 @@\n-  {\n-    SparsePRTBucketIter iter(&_sparse_table);\n-    SparsePRTEntry* cur;\n-    while (iter.has_next(cur)) {\n-      cl.next_sparse_prt(cur->r_ind(), cur->cards(), cur->num_valid_cards());\n-    }\n+\n+  uint cur_idx = _hr->hrm_index();\n+  uintptr_t from_card = uintptr_t(from) >> CardTable::card_shift;\n+\n+  if (G1FromCardCache::contains_or_replace(tid, cur_idx, from_card)) {\n+    \/\/ We can't check whether the card is in the remembered set - the card container\n+    \/\/ may be coarsened just now.\n+    \/\/assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the FromCardCache\", p2i(from));\n+   return;\n@@ -98,0 +85,25 @@\n+\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  _card_set.add_card(card_region, card_within_region);\n+}\n+\n+bool HeapRegionRemSet::contains_reference(OopOrNarrowOopStar from) {\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  return _card_set.contains_card(card_region, card_within_region);\n+}\n+\n+void HeapRegionRemSet::print_info(outputStream* st, OopOrNarrowOopStar from) {\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  _card_set.print_info(st, card_region, card_within_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":67,"deletions":55,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-JVMFlag::Error G1RSetRegionEntriesConstraintFunc(intx value, bool verbose) {\n+JVMFlag::Error G1RemSetArrayOfCardsEntriesConstraintFunc(uint value, bool verbose) {\n@@ -34,1 +34,1 @@\n-  \/\/ Default value of G1RSetRegionEntries=0 means will be set ergonomically.\n+  \/\/ Default value of G1RemSetArrayOfCardsEntries=0 means will be set ergonomically.\n@@ -36,1 +36,1 @@\n-  if (FLAG_IS_CMDLINE(G1RSetRegionEntries) && (value < 1)) {\n+  if (FLAG_IS_CMDLINE(G1RemSetArrayOfCardsEntries) && (value < 1)) {\n@@ -38,2 +38,2 @@\n-                        \"G1RSetRegionEntries (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to 1\\n\",\n+                        \"G1RemSetArrayOfCardsEntries (%u) must be \"\n+                        \"greater than or equal to 1.\\n\",\n@@ -47,1 +47,1 @@\n-JVMFlag::Error G1RSetSparseRegionEntriesConstraintFunc(intx value, bool verbose) {\n+JVMFlag::Error G1RemSetHowlNumBucketsConstraintFunc(uint value, bool verbose) {\n@@ -50,3 +50,4 @@\n-  \/\/ Default value of G1RSetSparseRegionEntries=0 means will be set ergonomically.\n-  \/\/ Minimum value is 1.\n-  if (FLAG_IS_CMDLINE(G1RSetSparseRegionEntries) && (value < 1)) {\n+  if (!FLAG_IS_CMDLINE(G1RemSetHowlNumBuckets)) {\n+    return JVMFlag::SUCCESS;\n+  }\n+  if (value == 0 || !is_power_of_2(G1RemSetHowlNumBuckets)) {\n@@ -54,2 +55,2 @@\n-                        \"G1RSetSparseRegionEntries (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to 1\\n\",\n+                        \"G1RemSetHowlNumBuckets (%u) must be a power of two \"\n+                        \"and greater than or equal to 1.\\n\",\n@@ -58,1 +59,8 @@\n-  } else {\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error G1RemSetHowlMaxNumBucketsConstraintFunc(uint value, bool verbose) {\n+  if (!UseG1GC) return JVMFlag::SUCCESS;\n+\n+  if (!FLAG_IS_CMDLINE(G1RemSetHowlMaxNumBuckets)) {\n@@ -61,0 +69,7 @@\n+  if (!is_power_of_2(G1RemSetHowlMaxNumBuckets)) {\n+    JVMFlag::printError(verbose,\n+                        \"G1RemSetMaxHowlNumBuckets (%u) must be a power of two.\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+  return JVMFlag::SUCCESS;\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -33,3 +33,6 @@\n-  \/* G1 Flag Constraints *\/                           \\\n-  f(intx,   G1RSetRegionEntriesConstraintFunc)        \\\n-  f(intx,   G1RSetSparseRegionEntriesConstraintFunc)  \\\n+  \/* G1 Remembered Sets Constraints *\/                \\\n+  f(uint,   G1RemSetArrayOfCardsEntriesConstraintFunc)\\\n+  f(uint,   G1RemSetHowlMaxNumBucketsConstraintFunc)  \\\n+  f(uint,   G1RemSetHowlNumBucketsConstraintFunc)     \\\n+                                                      \\\n+  \/* G1 Heap Size Constraints *\/                      \\\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"gc\/g1\/heapRegionBounds.inline.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n-#include \"gc\/g1\/sparsePRT.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"gc\/shared\/space.inline.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-\n-\/\/ Check that the size of the SparsePRTEntry is evenly divisible by the maximum\n-\/\/ member type to avoid SIGBUS when accessing them.\n-STATIC_ASSERT(sizeof(SparsePRTEntry) % sizeof(int) == 0);\n-\n-void SparsePRTEntry::init(RegionIdx_t region_ind) {\n-  \/\/ Check that the card array element type can represent all cards in the region.\n-  \/\/ Choose a large SparsePRTEntry::card_elem_t (e.g. CardIdx_t) if required.\n-  assert(((size_t)1 << (sizeof(SparsePRTEntry::card_elem_t) * BitsPerByte)) *\n-         G1CardTable::card_size >= HeapRegionBounds::max_size(), \"precondition\");\n-  assert(G1RSetSparseRegionEntries > 0, \"precondition\");\n-  _region_ind = region_ind;\n-  _next_index = RSHashTable::NullEntry;\n-  _next_null = 0;\n-}\n-\n-bool SparsePRTEntry::contains_card(CardIdx_t card_index) const {\n-  for (int i = 0; i < num_valid_cards(); i++) {\n-    if (card(i) == card_index) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-SparsePRT::AddCardResult SparsePRTEntry::add_card(CardIdx_t card_index) {\n-  for (int i = 0; i < num_valid_cards(); i++) {\n-    if (card(i) == card_index) {\n-      return SparsePRT::found;\n-    }\n-  }\n-  if (num_valid_cards() < cards_num() - 1) {\n-    _cards[_next_null] = (card_elem_t)card_index;\n-    _next_null++;\n-    return SparsePRT::added;\n-   }\n-  \/\/ Otherwise, we're full.\n-  return SparsePRT::overflow;\n-}\n-\n-void SparsePRTEntry::copy_cards(card_elem_t* cards) const {\n-  memcpy(cards, _cards, cards_num() * sizeof(card_elem_t));\n-}\n-\n-void SparsePRTEntry::copy_cards(SparsePRTEntry* e) const {\n-  copy_cards(e->_cards);\n-  assert(_next_null >= 0, \"invariant\");\n-  assert(_next_null <= cards_num(), \"invariant\");\n-  e->_next_null = _next_null;\n-}\n-\n-\/\/ ----------------------------------------------------------------------\n-\n-float RSHashTable::TableOccupancyFactor = 0.5f;\n-\n-\/\/ The empty table can't hold any entries and is effectively immutable\n-\/\/ This means it can be used as an initial sentinel value\n-static int empty_buckets[] = { RSHashTable::NullEntry };\n-RSHashTable RSHashTable::empty_table;\n-\n-RSHashTable::RSHashTable() :\n-  _num_entries(0),\n-  _capacity(0),\n-  _capacity_mask(0),\n-  _occupied_entries(0),\n-  _entries(NULL),\n-  _buckets(empty_buckets),\n-  _free_region(0),\n-  _free_list(NullEntry) { }\n-\n-RSHashTable::RSHashTable(size_t capacity) :\n-  _num_entries((capacity * TableOccupancyFactor) + 1),\n-  _capacity(capacity),\n-  _capacity_mask(capacity - 1),\n-  _occupied_entries(0),\n-  _entries((SparsePRTEntry*)NEW_C_HEAP_ARRAY(char, _num_entries * SparsePRTEntry::size(), mtGC)),\n-  _buckets(NEW_C_HEAP_ARRAY(int, capacity, mtGC)),\n-  _free_region(0),\n-  _free_list(NullEntry)\n-{\n-  clear();\n-}\n-\n-RSHashTable::~RSHashTable() {\n-  \/\/ Nothing to free for empty RSHashTable\n-  if (_buckets != empty_buckets) {\n-    assert(_entries != NULL, \"invariant\");\n-    FREE_C_HEAP_ARRAY(SparsePRTEntry, _entries);\n-    FREE_C_HEAP_ARRAY(int, _buckets);\n-  }\n-}\n-\n-void RSHashTable::clear() {\n-  assert(_buckets != empty_buckets, \"Shouldn't call this for the empty_table\");\n-  _occupied_entries = 0;\n-  guarantee(_entries != NULL, \"invariant\");\n-  guarantee(_buckets != NULL, \"invariant\");\n-\n-  guarantee(_capacity <= ((size_t)1 << (sizeof(int)*BitsPerByte-1)) - 1,\n-                \"_capacity too large\");\n-\n-  \/\/ This will put -1 == NullEntry in the key field of all entries.\n-  memset((void*)_entries, NullEntry, _num_entries * SparsePRTEntry::size());\n-  memset((void*)_buckets, NullEntry, _capacity * sizeof(int));\n-  _free_list = NullEntry;\n-  _free_region = 0;\n-}\n-\n-SparsePRT::AddCardResult RSHashTable::add_card(RegionIdx_t region_ind, CardIdx_t card_index) {\n-  assert(this != &empty_table, \"can't add a card to the empty table\");\n-  SparsePRTEntry* e = entry_for_region_ind_create(region_ind);\n-  assert(e != NULL && e->r_ind() == region_ind,\n-         \"Postcondition of call above.\");\n-  SparsePRT::AddCardResult res = e->add_card(card_index);\n-  assert(e->num_valid_cards() > 0, \"Postcondition\");\n-  return res;\n-}\n-\n-SparsePRTEntry* RSHashTable::get_entry(RegionIdx_t region_ind) const {\n-  int ind = (int) (region_ind & capacity_mask());\n-  int cur_ind = _buckets[ind];\n-  SparsePRTEntry* cur;\n-  while (cur_ind != NullEntry &&\n-         (cur = entry(cur_ind))->r_ind() != region_ind) {\n-    cur_ind = cur->next_index();\n-  }\n-\n-  if (cur_ind == NullEntry) return NULL;\n-  \/\/ Otherwise...\n-  assert(cur->r_ind() == region_ind, \"Postcondition of loop + test above.\");\n-  assert(cur->num_valid_cards() > 0, \"Inv\");\n-  return cur;\n-}\n-\n-bool RSHashTable::delete_entry(RegionIdx_t region_ind) {\n-  int ind = (int) (region_ind & capacity_mask());\n-  int* prev_loc = &_buckets[ind];\n-  int cur_ind = *prev_loc;\n-  SparsePRTEntry* cur;\n-  while (cur_ind != NullEntry &&\n-         (cur = entry(cur_ind))->r_ind() != region_ind) {\n-    prev_loc = cur->next_index_addr();\n-    cur_ind = *prev_loc;\n-  }\n-\n-  if (cur_ind == NullEntry) return false;\n-  \/\/ Otherwise, splice out \"cur\".\n-  *prev_loc = cur->next_index();\n-  free_entry(cur_ind);\n-  _occupied_entries--;\n-  return true;\n-}\n-\n-SparsePRTEntry*\n-RSHashTable::entry_for_region_ind_create(RegionIdx_t region_ind) {\n-  SparsePRTEntry* res = get_entry(region_ind);\n-  if (res == NULL) {\n-    int new_ind = alloc_entry();\n-    res = entry(new_ind);\n-    res->init(region_ind);\n-    \/\/ Insert at front.\n-    int ind = (int) (region_ind & capacity_mask());\n-    res->set_next_index(_buckets[ind]);\n-    _buckets[ind] = new_ind;\n-    _occupied_entries++;\n-  }\n-  return res;\n-}\n-\n-int RSHashTable::alloc_entry() {\n-  int res;\n-  if (_free_list != NullEntry) {\n-    res = _free_list;\n-    _free_list = entry(res)->next_index();\n-    return res;\n-  } else if ((size_t)_free_region < _num_entries) {\n-    res = _free_region;\n-    _free_region++;\n-    return res;\n-  } else {\n-    return NullEntry;\n-  }\n-}\n-\n-void RSHashTable::free_entry(int fi) {\n-  entry(fi)->set_next_index(_free_list);\n-  _free_list = fi;\n-}\n-\n-void RSHashTable::add_entry(SparsePRTEntry* e) {\n-  assert(e->num_valid_cards() > 0, \"Precondition.\");\n-  SparsePRTEntry* e2 = entry_for_region_ind_create(e->r_ind());\n-  e->copy_cards(e2);\n-  assert(e2->num_valid_cards() > 0, \"Postcondition.\");\n-}\n-\n-bool RSHashTableBucketIter::has_next(SparsePRTEntry*& entry) {\n-  while (_bl_ind == RSHashTable::NullEntry)  {\n-    if (_tbl_ind + 1 >= _rsht->capacity()) {\n-      return false;\n-    }\n-    _tbl_ind++;\n-    _bl_ind = _rsht->_buckets[_tbl_ind];\n-  }\n-  entry = _rsht->entry(_bl_ind);\n-  _bl_ind = entry->next_index();\n-  return true;\n-}\n-\n-bool RSHashTable::contains_card(RegionIdx_t region_index, CardIdx_t card_index) const {\n-  SparsePRTEntry* e = get_entry(region_index);\n-  return (e != NULL && e->contains_card(card_index));\n-}\n-\n-size_t RSHashTable::mem_size() const {\n-  return sizeof(RSHashTable) +\n-    _num_entries * (SparsePRTEntry::size() + sizeof(int));\n-}\n-\n-\/\/ ----------------------------------------------------------------------\n-\n-SparsePRT::SparsePRT() :\n-  _table(&RSHashTable::empty_table) {\n-}\n-\n-\n-SparsePRT::~SparsePRT() {\n-  if (_table != &RSHashTable::empty_table) {\n-    delete _table;\n-  }\n-}\n-\n-\n-size_t SparsePRT::mem_size() const {\n-  \/\/ We ignore \"_cur\" here, because it either = _next, or else it is\n-  \/\/ on the deleted list.\n-  return sizeof(SparsePRT) + _table->mem_size();\n-}\n-\n-SparsePRT::AddCardResult SparsePRT::add_card(RegionIdx_t region_id, CardIdx_t card_index) {\n-  if (_table->should_expand()) {\n-    expand();\n-  }\n-  return _table->add_card(region_id, card_index);\n-}\n-\n-SparsePRTEntry* SparsePRT::get_entry(RegionIdx_t region_id) {\n-  return _table->get_entry(region_id);\n-}\n-\n-bool SparsePRT::delete_entry(RegionIdx_t region_id) {\n-  return _table->delete_entry(region_id);\n-}\n-\n-void SparsePRT::clear() {\n-  \/\/ If the entry table not at initial capacity, just reset to the empty table.\n-  if (_table->capacity() == InitialCapacity) {\n-    _table->clear();\n-  } else if (_table != &RSHashTable::empty_table) {\n-    delete _table;\n-    _table = &RSHashTable::empty_table;\n-  }\n-}\n-\n-void SparsePRT::expand() {\n-  RSHashTable* last = _table;\n-  if (last != &RSHashTable::empty_table) {\n-    _table = new RSHashTable(last->capacity() * 2);\n-    for (size_t i = 0; i < last->num_entries(); i++) {\n-      SparsePRTEntry* e = last->entry((int)i);\n-      if (e->valid_entry()) {\n-        _table->add_entry(e);\n-      }\n-    }\n-    delete last;\n-  } else {\n-    _table = new RSHashTable(InitialCapacity);\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/sparsePRT.cpp","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"},{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_SPARSEPRT_HPP\n-#define SHARE_GC_G1_SPARSEPRT_HPP\n-\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class RSHashTable;\n-class SparsePRTEntry;\n-\n-\/\/ Sparse remembered set for a heap region (the \"owning\" region).  Maps\n-\/\/ indices of other regions to short sequences of cards in the other region\n-\/\/ that might contain pointers into the owner region.\n-\/\/ Concurrent access to a SparsePRT must be serialized by some external mutex.\n-class SparsePRT {\n-  friend class SparsePRTBucketIter;\n-\n-  RSHashTable* _table;\n-\n-  static const size_t InitialCapacity = 8;\n-\n-  void expand();\n-\n-public:\n-  SparsePRT();\n-  ~SparsePRT();\n-\n-  size_t mem_size() const;\n-\n-  enum AddCardResult {\n-    overflow, \/\/ The table is full, could not add the card to the table.\n-    found,    \/\/ The card is already in the PRT.\n-    added     \/\/ The card has been added.\n-  };\n-\n-  \/\/ Attempts to ensure that the given card_index in the given region is in\n-  \/\/ the sparse table.  If successful (because the card was already\n-  \/\/ present, or because it was successfully added) returns \"true\".\n-  \/\/ Otherwise, returns \"false\" to indicate that the addition would\n-  \/\/ overflow the entry for the region.  The caller must transfer these\n-  \/\/ entries to a larger-capacity representation.\n-  AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);\n-\n-  \/\/ Return the pointer to the entry associated with the given region.\n-  SparsePRTEntry* get_entry(RegionIdx_t region_ind);\n-\n-  \/\/ If there is an entry for \"region_ind\", removes it and return \"true\";\n-  \/\/ otherwise returns \"false.\"\n-  bool delete_entry(RegionIdx_t region_ind);\n-\n-  \/\/ Clear the table, and reinitialize to initial capacity.\n-  void clear();\n-\n-  bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;\n-};\n-\n-class SparsePRTEntry: public CHeapObj<mtGC> {\n-public:\n-  \/\/ The type of a card entry.\n-  typedef uint16_t card_elem_t;\n-\n-private:\n-  \/\/ We need to make sizeof(SparsePRTEntry) an even multiple of maximum member size,\n-  \/\/ in order to force correct alignment that could otherwise cause SIGBUS errors\n-  \/\/ when reading the member variables. This calculates the minimum number of card\n-  \/\/ array elements required to get that alignment.\n-  static const size_t card_array_alignment = sizeof(int) \/ sizeof(card_elem_t);\n-\n-  RegionIdx_t _region_ind;\n-  int         _next_index;\n-  int         _next_null;\n-  \/\/ The actual cards stored in this array.\n-  \/\/ WARNING: Don't put any data members beyond this line. Card array has, in fact, variable length.\n-  \/\/ It should always be the last data member.\n-  card_elem_t _cards[card_array_alignment];\n-\n-  \/\/ Copy the current entry's cards into \"cards\".\n-  inline void copy_cards(card_elem_t* cards) const;\n-public:\n-  \/\/ Returns the size of the entry, used for entry allocation.\n-  static size_t size() { return sizeof(SparsePRTEntry) + sizeof(card_elem_t) * (cards_num() - card_array_alignment); }\n-  \/\/ Returns the size of the card array.\n-  static int cards_num() {\n-    return align_up((int)G1RSetSparseRegionEntries, (int)card_array_alignment);\n-  }\n-\n-  \/\/ Set the region_ind to the given value, and delete all cards.\n-  inline void init(RegionIdx_t region_ind);\n-\n-  RegionIdx_t r_ind() const { return _region_ind; }\n-  bool valid_entry() const { return r_ind() >= 0; }\n-\n-  int next_index() const { return _next_index; }\n-  int* next_index_addr() { return &_next_index; }\n-  void set_next_index(int ni) { _next_index = ni; }\n-\n-  \/\/ Returns \"true\" iff the entry contains the given card index.\n-  inline bool contains_card(CardIdx_t card_index) const;\n-\n-  \/\/ Returns the number of non-NULL card entries.\n-  inline int num_valid_cards() const { return _next_null; }\n-\n-  inline SparsePRT::AddCardResult add_card(CardIdx_t card_index);\n-\n-  \/\/ Copy the current entry's cards into the \"_card\" array of \"e.\"\n-  inline void copy_cards(SparsePRTEntry* e) const;\n-\n-  card_elem_t* cards() { return _cards; }\n-\n-  inline CardIdx_t card(int i) const {\n-    assert(i >= 0, \"must be nonnegative\");\n-    assert(i < cards_num(), \"range checking\");\n-    return (CardIdx_t)_cards[i];\n-  }\n-};\n-\n-class RSHashTable : public CHeapObj<mtGC> {\n-\n-  friend class RSHashTableBucketIter;\n-\n-  \/\/ Inverse maximum hash table occupancy used.\n-  static float TableOccupancyFactor;\n-\n-  size_t _num_entries;\n-\n-  size_t _capacity;\n-  size_t _capacity_mask;\n-  size_t _occupied_entries;\n-\n-  SparsePRTEntry* _entries;\n-  int* _buckets;\n-  int  _free_region;\n-  int  _free_list;\n-\n-  \/\/ Requires that the caller hold a lock preventing parallel modifying\n-  \/\/ operations, and that the the table be less than completely full.  If\n-  \/\/ an entry for \"region_ind\" is already in the table, finds it and\n-  \/\/ returns its address; otherwise allocates, initializes, inserts and\n-  \/\/ returns a new entry for \"region_ind\".\n-  SparsePRTEntry* entry_for_region_ind_create(RegionIdx_t region_ind);\n-\n-  \/\/ Returns the index of the next free entry in \"_entries\".\n-  int alloc_entry();\n-  \/\/ Declares the entry \"fi\" to be free.  (It must have already been\n-  \/\/ deleted from any bucket lists.\n-  void free_entry(int fi);\n-\n-  \/\/ For the empty sentinel created at static initialization time\n-  RSHashTable();\n-\n-public:\n-  RSHashTable(size_t capacity);\n-  ~RSHashTable();\n-\n-  static const int NullEntry = -1;\n-  static RSHashTable empty_table;\n-\n-  bool should_expand() const { return _occupied_entries == _num_entries; }\n-\n-  \/\/ Attempts to ensure that the given card_index in the given region is in\n-  \/\/ the sparse table.  If successful (because the card was already\n-  \/\/ present, or because it was successfully added) returns \"true\".\n-  \/\/ Otherwise, returns \"false\" to indicate that the addition would\n-  \/\/ overflow the entry for the region.  The caller must transfer these\n-  \/\/ entries to a larger-capacity representation.\n-  SparsePRT::AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);\n-\n-  bool delete_entry(RegionIdx_t region_id);\n-\n-  bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;\n-\n-  void add_entry(SparsePRTEntry* e);\n-\n-  SparsePRTEntry* get_entry(RegionIdx_t region_id) const;\n-\n-  void clear();\n-\n-  size_t capacity() const      { return _capacity; }\n-  size_t capacity_mask() const { return _capacity_mask;  }\n-  size_t mem_size() const;\n-  \/\/ The number of SparsePRTEntry instances available.\n-  size_t num_entries() const { return _num_entries; }\n-\n-  SparsePRTEntry* entry(int i) const {\n-    assert(i >= 0 && (size_t)i < _num_entries, \"precondition\");\n-    return (SparsePRTEntry*)((char*)_entries + SparsePRTEntry::size() * i);\n-  }\n-\n-  void print();\n-};\n-\n-\/\/ This is embedded in HRRS iterator.\n-class RSHashTableBucketIter {\n-  uint _tbl_ind;        \/\/ [0.._rsht->_capacity)\n-  int  _bl_ind;         \/\/ [-1, 0.._rsht->_capacity)\n-\n-  RSHashTable* _rsht;\n-\n-public:\n-  RSHashTableBucketIter(RSHashTable* rsht) :\n-    _tbl_ind(0),\n-    _bl_ind(rsht->_buckets[_tbl_ind]),\n-    _rsht(rsht) { }\n-\n-  bool has_next(SparsePRTEntry*& entry);\n-};\n-\n-class SparsePRTBucketIter: public RSHashTableBucketIter {\n-public:\n-  SparsePRTBucketIter(const SparsePRT* sprt) :\n-    RSHashTableBucketIter(sprt->_table) {}\n-\n-  bool has_next(SparsePRTEntry*& entry) {\n-    return RSHashTableBucketIter::has_next(entry);\n-  }\n-};\n-\n-#endif \/\/ SHARE_GC_G1_SPARSEPRT_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/sparsePRT.hpp","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_SPARSEPRT_INLINE_HPP\n-#define SHARE_GC_G1_SPARSEPRT_INLINE_HPP\n-\n-#include \"gc\/g1\/sparsePRT.hpp\"\n-\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-\n-inline bool SparsePRT::contains_card(RegionIdx_t region_id, CardIdx_t card_index) const {\n-  return _table->contains_card(region_id, card_index);\n-}\n-\n-\n-#endif \/\/ SHARE_GC_G1_SPARSEPRT_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/sparsePRT.inline.hpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -65,1 +65,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -86,3 +86,1 @@\n-           obj->mark() == markWord::prototype() || \/\/ not gc marked?\n-           (UseBiasedLocking && obj->mark().has_bias_pattern()),\n-           \/\/ not gc marked?\n+           obj->mark() == markWord::prototype(), \/\/ not gc marked?\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -238,2 +238,2 @@\n-  static CardValue clean_card_val()          { return clean_card; }\n-  static CardValue dirty_card_val()          { return dirty_card; }\n+  static constexpr CardValue clean_card_val()          { return clean_card; }\n+  static constexpr CardValue dirty_card_val()          { return dirty_card; }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-    flush_deferred_card_mark_barrier(thread->as_Java_thread());\n+    flush_deferred_card_mark_barrier(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+\n+  \/\/ Printing\n+  const char* type_name() const { return \"ConcurrentGCThread\"; }\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -442,2 +441,1 @@\n-                                          bool is_tlab, bool run_verification, bool clear_soft_refs,\n-                                          bool restore_marks_for_biased_locking) {\n+                                          bool is_tlab, bool run_verification, bool clear_soft_refs) {\n@@ -464,8 +462,0 @@\n-  if (restore_marks_for_biased_locking) {\n-    \/\/ We perform this mark word preservation work lazily\n-    \/\/ because it's only at this point that we know whether we\n-    \/\/ absolutely have to do it; we want to avoid doing it for\n-    \/\/ scavenge-only collections where it's unnecessary\n-    BiasedLocking::preserve_marks();\n-  }\n-\n@@ -575,2 +565,1 @@\n-                       do_clear_all_soft_refs,\n-                       false);\n+                       do_clear_all_soft_refs);\n@@ -635,2 +624,1 @@\n-                       do_clear_all_soft_refs,\n-                       true);\n+                       do_clear_all_soft_refs);\n@@ -658,2 +646,0 @@\n-    BiasedLocking::restore_marks();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,2 +93,1 @@\n-                          bool run_verification, bool clear_soft_refs,\n-                          bool restore_marks_for_biased_locking);\n+                          bool run_verification, bool clear_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  _thread->as_Java_thread()->check_for_valid_safepoint_state();\n+  JavaThread::cast(_thread)->check_for_valid_safepoint_state();\n@@ -385,6 +385,2 @@\n-  if (UseBiasedLocking) {\n-    oopDesc::set_mark(mem, _klass->prototype_header());\n-  } else {\n-    \/\/ May be bootstrapping\n-    oopDesc::set_mark(mem, markWord::prototype());\n-  }\n+  \/\/ May be bootstrapping\n+  oopDesc::set_mark(mem, markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -400,1 +400,0 @@\n-  void set_atomic_discovery(bool atomic) { _discovery_is_atomic = atomic; }\n@@ -564,21 +563,0 @@\n-\/\/ A utility class to temporarily change the disposition\n-\/\/ of the \"discovery_is_atomic\" field of the\n-\/\/ given ReferenceProcessor in the scope that contains it.\n-class ReferenceProcessorAtomicMutator: StackObj {\n- private:\n-  ReferenceProcessor* _rp;\n-  bool                _saved_atomic_discovery;\n-\n- public:\n-  ReferenceProcessorAtomicMutator(ReferenceProcessor* rp,\n-                                  bool atomic):\n-    _rp(rp) {\n-    _saved_atomic_discovery = _rp->discovery_is_atomic();\n-    _rp->set_atomic_discovery(atomic);\n-  }\n-\n-  ~ReferenceProcessorAtomicMutator() {\n-    _rp->set_atomic_discovery(_saved_atomic_discovery);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  static const uint MaxThreadWorkItems = 6;\n+  static const uint MaxThreadWorkItems = 9;\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -222,0 +222,3 @@\n+\n+  \/\/ Printing\n+  const char* type_name() const override { return \"GCTaskThread\"; }\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-      JavaThread* const jt = thread->as_Java_thread();\n+      JavaThread* const jt = JavaThread::cast(thread);\n@@ -125,1 +125,1 @@\n-        StackWatermarkSet::finish_processing(thread->as_Java_thread(), &oops, StackWatermarkKind::gc);\n+        StackWatermarkSet::finish_processing(JavaThread::cast(thread), &oops, StackWatermarkKind::gc);\n@@ -128,1 +128,1 @@\n-        StackWatermarkSet::finish_processing(thread->as_Java_thread(), &oops, StackWatermarkKind::gc);\n+        StackWatermarkSet::finish_processing(JavaThread::cast(thread), &oops, StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-  JavaThread* const jt = thread->as_Java_thread();\n+  JavaThread* const jt = JavaThread::cast(thread);\n@@ -937,1 +937,1 @@\n-    JavaThread* jt = thread->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  char* name() const { return (char*)\"ShenandoahControlThread\";}\n+  const char* name() const { return \"ShenandoahControlThread\";}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -185,1 +184,0 @@\n-    BiasedLocking::preserve_marks();\n@@ -233,1 +231,0 @@\n-    BiasedLocking::restore_marks();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1753,1 +1753,1 @@\n-      ThreadBlockInVM sp(thread->as_Java_thread());\n+      ThreadBlockInVM sp(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  JavaThread* const jt = thread->as_Java_thread();\n+  JavaThread* const jt = JavaThread::cast(thread);\n@@ -205,1 +205,1 @@\n-        ShenandoahStackWatermark* wm = StackWatermarkSet::get<ShenandoahStackWatermark>(thr->as_Java_thread(), StackWatermarkKind::gc);\n+        ShenandoahStackWatermark* wm = StackWatermarkSet::get<ShenandoahStackWatermark>(JavaThread::cast(thr), StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-    JavaThread* const jt = thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    _sema.wait_with_safepoint_check(thread->as_Java_thread());\n+    _sema.wait_with_safepoint_check(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/gc\/z\/zFuture.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-    JavaThread* const jt = thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-      ThreadBlockInVM tbivm(_thread->as_Java_thread());\n+      ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-    JavaThread* const jt = thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -730,3 +729,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());\n-  }\n@@ -1037,21 +1033,0 @@\n-\n-  if (osr_nm != NULL) {\n-    \/\/ We may need to do on-stack replacement which requires that no\n-    \/\/ monitors in the activation are biased because their\n-    \/\/ BasicObjectLocks will need to migrate during OSR. Force\n-    \/\/ unbiasing of all monitors in the activation now (even though\n-    \/\/ the OSR nmethod might be invalidated) because we don't have a\n-    \/\/ safepoint opportunity later once the migration begins.\n-    if (UseBiasedLocking) {\n-      ResourceMark rm;\n-      GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-      for( BasicObjectLock *kptr = last_frame.monitor_end();\n-           kptr < last_frame.monitor_begin();\n-           kptr = last_frame.next_monitor(kptr) ) {\n-        if( kptr->obj() != NULL ) {\n-          objects_to_revoke->append(Handle(current, kptr->obj()));\n-        }\n-      }\n-      BiasedLocking::revoke(objects_to_revoke, current);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -579,1 +579,0 @@\n-        \/\/ Monitor not filled in frame manager any longer as this caused race condition with biased locking.\n@@ -583,2 +582,0 @@\n-        assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -679,2 +676,0 @@\n-      assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1522,2 +1517,0 @@\n-          assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1556,2 +1549,0 @@\n-            assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1880,1 +1871,0 @@\n-              assert(!UseBiasedLocking, \"Not implemented\");\n@@ -2686,2 +2676,0 @@\n-          assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -2754,2 +2742,0 @@\n-            assert(!UseBiasedLocking, \"Not implemented\");\n-\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -36,0 +36,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -222,1 +223,0 @@\n-  ResourceMark rm(THREAD);\n@@ -244,2 +244,0 @@\n-  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;C)[Ljava\/lang\/String;\";\n-\n@@ -249,1 +247,1 @@\n-\n+  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;C)[Ljava\/lang\/String;\";\n@@ -274,2 +272,2 @@\n-  JfrJavaArguments print_help(&result, javaClass(), \"printHelp\", signature, thread);\n-  invoke(print_help, thread);\n+  JfrJavaArguments printHelp(&result, javaClass(), \"printHelp\", signature, thread);\n+  invoke(printHelp, thread);\n@@ -279,0 +277,63 @@\n+\/\/ Since the DcmdFramework does not support dynamically allocated strings,\n+\/\/ we keep them in a thread local arena. The arena is reset between invocations.\n+static THREAD_LOCAL Arena* dcmd_arena = NULL;\n+\n+static void prepare_dcmd_string_arena() {\n+  if (dcmd_arena == NULL) {\n+    dcmd_arena = new (mtTracing) Arena(mtTracing);\n+  } else {\n+    dcmd_arena->destruct_contents(); \/\/ will grow on next allocation\n+  }\n+}\n+\n+static char* dcmd_arena_allocate(size_t size) {\n+  assert(dcmd_arena != NULL, \"invariant\");\n+  return (char*)dcmd_arena->Amalloc(size);\n+}\n+\n+static const char* get_as_dcmd_arena_string(oop string, JavaThread* t) {\n+  char* str = NULL;\n+  const typeArrayOop value = java_lang_String::value(string);\n+  if (value != NULL) {\n+    const size_t length = static_cast<size_t>(java_lang_String::utf8_length(string, value)) + 1;\n+    str = dcmd_arena_allocate(length);\n+    assert(str != NULL, \"invariant\");\n+    java_lang_String::as_utf8_string(string, value, str, static_cast<int>(length));\n+  }\n+  return str;\n+}\n+\n+static const char* read_string_field(oop argument, const char* field_name, TRAPS) {\n+  JavaValue result(T_OBJECT);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(argument->klass());\n+  args.set_name(field_name);\n+  args.set_signature(\"Ljava\/lang\/String;\");\n+  args.set_receiver(argument);\n+  JfrJavaSupport::get_field(&args, THREAD);\n+  const oop string_oop = result.get_oop();\n+  return string_oop != NULL ? get_as_dcmd_arena_string(string_oop, (JavaThread*)THREAD) : NULL;\n+}\n+\n+static bool read_boolean_field(oop argument, const char* field_name, TRAPS) {\n+  JavaValue result(T_BOOLEAN);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(argument->klass());\n+  args.set_name(field_name);\n+  args.set_signature(\"Z\");\n+  args.set_receiver(argument);\n+  JfrJavaSupport::get_field(&args, THREAD);\n+  return (result.get_jint() & 1) == 1;\n+}\n+\n+static DCmdArgumentInfo* create_info(oop argument, TRAPS) {\n+  return new DCmdArgumentInfo(\n+    read_string_field(argument, \"name\", THREAD),\n+    read_string_field(argument, \"description\", THREAD),\n+    read_string_field(argument, \"type\", THREAD),\n+    read_string_field(argument, \"defaultValue\", THREAD),\n+    read_boolean_field(argument, \"mandatory\", THREAD),\n+    true, \/\/ a DcmdFramework \"option\"\n+    read_boolean_field(argument, \"allowMultiple\", THREAD));\n+}\n+\n@@ -280,1 +341,17 @@\n-  return new GrowableArray<DCmdArgumentInfo*>();\n+  static const char signature[] = \"()[Ljdk\/jfr\/internal\/dcmd\/Argument;\";\n+  JavaThread* thread = JavaThread::current();\n+  JavaValue result(T_OBJECT);\n+  JfrJavaArguments getArgumentInfos(&result, javaClass(), \"getArgumentInfos\", signature, thread);\n+  invoke(getArgumentInfos, thread);\n+  objArrayOop arguments = objArrayOop(result.get_oop());\n+  assert(arguments != NULL, \"invariant\");\n+  assert(arguments->is_array(), \"must be array\");\n+  GrowableArray<DCmdArgumentInfo*>* const array = new GrowableArray<DCmdArgumentInfo*>();\n+  const int length = arguments->length();\n+  prepare_dcmd_string_arena();\n+  for (int i = 0; i < length; ++i) {\n+    DCmdArgumentInfo* const dai = create_info(arguments->obj_at(i), thread);\n+    assert(dai != NULL, \"invariant\");\n+    array->append(dai);\n+  }\n+  return array;\n@@ -390,1 +467,0 @@\n-  ResourceMark rm(THREAD);\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":85,"deletions":9,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+  static int num_arguments() {\n+    return 11;\n+  }\n@@ -90,0 +93,3 @@\n+  static int num_arguments() {\n+    return 7;\n+  }\n@@ -112,0 +118,3 @@\n+  static int num_arguments() {\n+    return 2;\n+  }\n@@ -134,0 +143,3 @@\n+  static int num_arguments() {\n+    return 2;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -824,1 +824,1 @@\n-  DEBUG_ONLY(check_new_unstarted_java_thread(t->as_Java_thread());)\n+  DEBUG_ONLY(check_new_unstarted_java_thread(JavaThread::cast(t));)\n@@ -826,1 +826,1 @@\n-  if (check_exclusion_state_on_thread_start(t->as_Java_thread())) {\n+  if (check_exclusion_state_on_thread_start(JavaThread::cast(t))) {\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n@@ -162,0 +163,1 @@\n+  e.set_objectSize(sample->allocated());\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,19 +73,0 @@\n-  <Event name=\"BiasedLockRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Revocation\" description=\"Revoked bias of object\" thread=\"true\"\n-    stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"lockClass\" label=\"Lock Class\" description=\"Class of object whose biased lock was revoked\" \/>\n-    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n-    <Field type=\"Thread\" name=\"previousOwner\" label=\"Previous Owner\" description=\"Thread owning the bias before revocation\" \/>\n-  <\/Event>\n-\n-  <Event name=\"BiasedLockSelfRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Self Revocation\" description=\"Revoked bias of object biased towards own thread\"\n-    thread=\"true\" stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"lockClass\" label=\"Lock Class\" description=\"Class of object whose biased lock was revoked\" \/>\n-  <\/Event>\n-\n-  <Event name=\"BiasedLockClassRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Class Revocation\" description=\"Revoked biases for all instances of a class\"\n-    thread=\"true\" stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"revokedClass\" label=\"Revoked Class\" description=\"Class whose biased locks were revoked\" \/>\n-    <Field type=\"boolean\" name=\"disableBiasing\" label=\"Disable Further Biasing\" description=\"Whether further biasing for instances of this class will be allowed\" \/>\n-    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n-  <\/Event>\n-\n@@ -630,0 +611,1 @@\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"objectSize\" label=\"Object Size\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,1 +178,1 @@\n-  JavaThread* jth = context.thread()->as_Java_thread();\n+  JavaThread* jth = JavaThread::cast(context.thread());\n@@ -346,1 +346,2 @@\n-  virtual char* name() const { return (char*)\"JFR Thread Sampler\"; }\n+  virtual const char* name() const { return \"JFR Thread Sampler\"; }\n+  virtual const char* type_name() const { return \"JfrThreadSampler\"; }\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -452,1 +452,1 @@\n-      ThreadInVMfromNative transition(thread->as_Java_thread());\n+      ThreadInVMfromNative transition(JavaThread::cast(thread));\n@@ -481,1 +481,1 @@\n-    JfrJavaEventWriter::notify(thread->as_Java_thread());\n+    JfrJavaEventWriter::notify(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  const oop thread_obj = t->as_Java_thread()->threadObj();\n+  const oop thread_obj = JavaThread::cast(t)->threadObj();\n@@ -126,1 +126,1 @@\n-  return t->is_Java_thread() ? get_java_thread_name(t->as_Java_thread()) : t->name();\n+  return t->is_Java_thread() ? get_java_thread_name(JavaThread::cast(t)) : t->name();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    _writer.write(JfrThreadGroup::thread_group_id(t->as_Java_thread(), _curthread));\n+    _writer.write(JfrThreadGroup::thread_group_id(JavaThread::cast(t), _curthread));\n@@ -279,1 +279,1 @@\n-    JavaThread* const jt = _thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(_thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -431,2 +431,0 @@\n-    assert(IS_NOT_SERIALIZED(value), \"invariant\");\n-    return;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -504,1 +504,1 @@\n-  JavaThreadInVMAndNative(Thread* t) : _jt(t->is_Java_thread() ? t->as_Java_thread() : NULL),\n+  JavaThreadInVMAndNative(Thread* t) : _jt(t->is_Java_thread() ? JavaThread::cast(t) : NULL),\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-  return (thread->is_Java_thread() && thread->as_Java_thread()->thread_state() != _thread_in_vm) || thread->is_VM_thread();\n+  return (thread->is_Java_thread() && JavaThread::cast(thread)->thread_state() != _thread_in_vm) || thread->is_VM_thread();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrPostBox.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  return instance().record_for(thread->as_Java_thread(), skip, frames, tl->stackdepth());\n+  return instance().record_for(JavaThread::cast(thread), skip, frames, tl->stackdepth());\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        send_java_thread_start_event(t->as_Java_thread());\n+        send_java_thread_start_event(JavaThread::cast(t));\n@@ -163,1 +163,1 @@\n-      JavaThread* const jt = t->as_Java_thread();\n+      JavaThread* const jt = JavaThread::cast(t);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-       JfrJavaEventWriter::notify(t->as_Java_thread());\n+       JfrJavaEventWriter::notify(JavaThread::cast(t));\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  return thread->as_Java_thread();\n+  return JavaThread::cast(thread);\n@@ -2282,1 +2282,1 @@\n-    attach_args.name = thread->name();\n+    attach_args.name = const_cast<char*>(thread->name());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,1 +232,0 @@\n-  do_bool_flag(UseBiasedLocking)                                           \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-      attach_args.name = thread->name();\n+      attach_args.name = const_cast<char*>(thread->name());\n@@ -317,1 +317,1 @@\n-        JavaThread* THREAD = thread->as_Java_thread(); \/\/ For exception macros.\n+        JavaThread* THREAD = JavaThread::cast(thread); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -206,1 +206,0 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -651,1 +650,0 @@\n-  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n@@ -653,1 +651,0 @@\n-  declare_constant(markWord::epoch_mask_in_place)                         \\\n@@ -658,1 +655,0 @@\n-  declare_constant(markWord::biased_lock_pattern)                         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -163,1 +163,2 @@\n-  char* name() const override { return (char*)\"AsyncLog Thread\"; }\n+  const char* name() const override { return \"AsyncLog Thread\"; }\n+  const char* type_name() const override { return \"AsyncLogWriter\"; }\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  LOG_TAG(biasedlocking) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+  f(mtGCCardSet,      \"GCCardSet\")   \/* G1 card set remembered set                *\/ \\\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -589,1 +589,1 @@\n-      JavaThread* THREAD = current->as_Java_thread(); \/\/ For exception macros.\n+      JavaThread* THREAD = JavaThread::cast(current); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-class PSPromotionManager;\n-\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2155,1 +2155,1 @@\n-    _exception = Exceptions::new_exception(current->as_Java_thread(),\n+    _exception = Exceptions::new_exception(JavaThread::cast(current),\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -511,6 +510,0 @@\n-\n-  \/\/ Set biased locking bit for all instances of this class; it will be\n-  \/\/ cleared if revocation occurs too often for this type\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    set_prototype_header(markWord::biased_locking_prototype());\n-  }\n@@ -2533,5 +2526,0 @@\n-  \/\/ Initialize current biased locking state.\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    set_prototype_header(markWord::biased_locking_prototype());\n-  }\n-\n@@ -2541,1 +2529,0 @@\n-    set_prototype_header(markWord::prototype());\n@@ -3627,1 +3614,1 @@\n-        current->as_Java_thread()->security_get_caller_class(1):\n+        JavaThread::cast(current)->security_get_caller_class(1):\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-                           _prototype_header(markWord::prototype()),\n@@ -715,4 +714,0 @@\n-int Klass::atomic_incr_biased_lock_revocation_count() {\n-  return (int) Atomic::add(&_biased_lock_revocation_count, 1);\n-}\n-\n@@ -747,2 +742,0 @@\n-     st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n-     st->cr();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -162,6 +162,0 @@\n-  \/\/ Biased locking implementation and statistics\n-  \/\/ (the 64-bit chunk goes first, to avoid some fragmentation)\n-  jlong    _last_biased_lock_bulk_revocation_time;\n-  markWord _prototype_header;   \/\/ Used when biased locking is both enabled and disabled for this type\n-  jint     _biased_lock_revocation_count;\n-\n@@ -648,24 +642,0 @@\n-  \/\/ Biased locking support\n-  \/\/ Note: the prototype header is always set up to be at least the\n-  \/\/ prototype markWord. If biased locking is enabled it may further be\n-  \/\/ biasable and have an epoch.\n-  markWord prototype_header() const      { return _prototype_header; }\n-\n-  \/\/ NOTE: once instances of this klass are floating around in the\n-  \/\/ system, this header must only be updated at a safepoint.\n-  \/\/ NOTE 2: currently we only ever set the prototype header to the\n-  \/\/ biasable prototype for instanceKlasses. There is no technical\n-  \/\/ reason why it could not be done for arrayKlasses aside from\n-  \/\/ wanting to reduce the initial scope of this optimization. There\n-  \/\/ are potential problems in setting the bias pattern for\n-  \/\/ JVM-internal oops.\n-  inline void set_prototype_header(markWord header);\n-  static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }\n-\n-  int  biased_lock_revocation_count() const { return (int) _biased_lock_revocation_count; }\n-  \/\/ Atomically increments biased_lock_revocation_count and returns updated value\n-  int atomic_incr_biased_lock_revocation_count();\n-  void set_biased_lock_revocation_count(int val) { _biased_lock_revocation_count = (jint) val; }\n-  jlong last_biased_lock_bulk_revocation_time() { return _last_biased_lock_bulk_revocation_time; }\n-  void  set_last_biased_lock_bulk_revocation_time(jlong cur_time) { _last_biased_lock_bulk_revocation_time = cur_time; }\n-\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -54,5 +54,0 @@\n-inline void Klass::set_prototype_header(markWord header) {\n-  assert(!header.has_bias_pattern() || is_instance_klass(), \"biased locking currently only supported for Java instances\");\n-  _prototype_header = header;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,1 @@\n-    \/\/ Biased bit is 3rd rightmost bit\n-    if (is_neutral()) {   \/\/ last bits = 001\n+    if (is_neutral()) {   \/\/ last bits = 01\n@@ -91,4 +90,0 @@\n-    } else if (has_bias_pattern()) {  \/\/ last bits = 101\n-      st->print(\"is_biased\");\n-      JavaThread* jt = biased_locker();\n-      st->print(\" biased_locker=\" INTPTR_FORMAT \" epoch=%d\", p2i(jt), bias_epoch());\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,1 @@\n-\/\/             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)\n-\/\/             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)\n+\/\/             hash:25 ------------>| age:4  unused_gap:1  lock:2 (normal object)\n@@ -44,2 +43,1 @@\n-\/\/  unused:25 hash:31 -->| unused_gap:1   age:4    biased_lock:1 lock:2 (normal object)\n-\/\/  JavaThread*:54 epoch:2 unused_gap:1   age:4    biased_lock:1 lock:2 (biased object)\n+\/\/  unused:25 hash:31 -->| unused_gap:1  age:4  unused_gap:1  lock:2 (normal object)\n@@ -52,28 +50,0 @@\n-\/\/  - the biased lock pattern is used to bias a lock toward a given\n-\/\/    thread. When this pattern is set in the low three bits, the lock\n-\/\/    is either biased toward a given thread or \"anonymously\" biased,\n-\/\/    indicating that it is possible for it to be biased. When the\n-\/\/    lock is biased toward a given thread, locking and unlocking can\n-\/\/    be performed by that thread without using atomic operations.\n-\/\/    When a lock's bias is revoked, it reverts back to the normal\n-\/\/    locking scheme described below.\n-\/\/\n-\/\/    Note that we are overloading the meaning of the \"unlocked\" state\n-\/\/    of the header. Because we steal a bit from the age we can\n-\/\/    guarantee that the bias pattern will never be seen for a truly\n-\/\/    unlocked object.\n-\/\/\n-\/\/    Note also that the biased state contains the age bits normally\n-\/\/    contained in the object header. Large increases in scavenge\n-\/\/    times were seen when these bits were absent and an arbitrary age\n-\/\/    assigned to all biased objects, because they tended to consume a\n-\/\/    significant fraction of the eden semispaces and were not\n-\/\/    promoted promptly, causing an increase in the amount of copying\n-\/\/    performed. The runtime system aligns all JavaThread* pointers to\n-\/\/    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))\n-\/\/    to make room for the age bits & the epoch bits (used in support of\n-\/\/    biased locking).\n-\/\/\n-\/\/    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread\n-\/\/    [0           | epoch | age | 1 | 01]       lock is anonymously biased\n-\/\/\n@@ -83,1 +53,1 @@\n-\/\/    [header      | 0 | 01]  unlocked           regular object header\n+\/\/    [header          | 01]  unlocked           regular object header\n@@ -131,2 +101,2 @@\n-  static const int biased_lock_bits               = 1;\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - biased_lock_bits;\n+  static const int first_unused_gap_bits          = 1;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - first_unused_gap_bits;\n@@ -134,2 +104,1 @@\n-  static const int unused_gap_bits                = LP64_ONLY(1) NOT_LP64(0);\n-  static const int epoch_bits                     = 2;\n+  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0);\n@@ -137,2 +106,0 @@\n-  \/\/ The biased locking code currently requires that the age bits be\n-  \/\/ contiguous to the lock bits.\n@@ -140,5 +107,2 @@\n-  static const int biased_lock_shift              = lock_bits;\n-  static const int age_shift                      = lock_bits + biased_lock_bits;\n-  static const int unused_gap_shift               = age_shift + age_bits;\n-  static const int hash_shift                     = unused_gap_shift + unused_gap_bits;\n-  static const int epoch_shift                    = hash_shift;\n+  static const int age_shift                      = lock_bits + first_unused_gap_bits;\n+  static const int hash_shift                     = age_shift + age_bits + second_unused_gap_bits;\n@@ -148,3 +112,0 @@\n-  static const uintptr_t biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits);\n-  static const uintptr_t biased_lock_mask_in_place= biased_lock_mask << lock_shift;\n-  static const uintptr_t biased_lock_bit_in_place = 1 << biased_lock_shift;\n@@ -153,3 +114,0 @@\n-  static const uintptr_t epoch_mask               = right_n_bits(epoch_bits);\n-  static const uintptr_t epoch_mask_in_place      = epoch_mask << epoch_shift;\n-\n@@ -159,3 +117,0 @@\n-  \/\/ Alignment of JavaThread pointers encoded in object header required by biased locking\n-  static const size_t biased_lock_alignment       = 2 << (epoch_shift + epoch_bits);\n-\n@@ -166,1 +121,0 @@\n-  static const uintptr_t biased_lock_pattern      = 5;\n@@ -174,2 +128,0 @@\n-  static const int max_bias_epoch                 = epoch_mask;\n-\n@@ -179,38 +131,0 @@\n-  \/\/ Biased Locking accessors.\n-  \/\/ These must be checked by all code which calls into the\n-  \/\/ ObjectSynchronizer and other code. The biasing is not understood\n-  \/\/ by the lower-level CAS-based locking code, although the runtime\n-  \/\/ fixes up biased locks to be compatible with it when a bias is\n-  \/\/ revoked.\n-  bool has_bias_pattern() const {\n-    return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);\n-  }\n-  JavaThread* biased_locker() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (JavaThread*) mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place));\n-  }\n-  \/\/ Indicates that the mark has the bias bit set but that it has not\n-  \/\/ yet been biased toward a particular thread\n-  bool is_biased_anonymously() const {\n-    return (has_bias_pattern() && (biased_locker() == NULL));\n-  }\n-  \/\/ Indicates epoch in which this bias was acquired. If the epoch\n-  \/\/ changes due to too many bias revocations occurring, the biases\n-  \/\/ from the previous epochs are all considered invalid.\n-  int bias_epoch() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (mask_bits(value(), epoch_mask_in_place) >> epoch_shift);\n-  }\n-  markWord set_bias_epoch(int epoch) {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    assert((epoch & (~epoch_mask)) == 0, \"epoch overflow\");\n-    return markWord(mask_bits(value(), ~epoch_mask_in_place) | (epoch << epoch_shift));\n-  }\n-  markWord incr_bias_epoch() {\n-    return set_bias_epoch((1 + bias_epoch()) & epoch_mask);\n-  }\n-  \/\/ Prototype mark for initialization\n-  static markWord biased_locking_prototype() {\n-    return markWord( biased_lock_pattern );\n-  }\n-\n@@ -222,1 +136,1 @@\n-    return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);\n+    return (mask_bits(value(), lock_mask_in_place) == unlocked_value);\n@@ -227,1 +141,3 @@\n-  bool is_neutral()  const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }\n+  bool is_neutral()  const {\n+    return (mask_bits(value(), lock_mask_in_place) == unlocked_value);\n+  }\n@@ -242,1 +158,3 @@\n-  inline bool must_be_preserved(const oopDesc* obj) const;\n+  bool must_be_preserved(const oopDesc* obj) const {\n+    return (!is_unlocked() || !has_no_hash());\n+  }\n@@ -246,16 +164,3 @@\n-  \/\/ Note that we special case this situation. We want to avoid\n-  \/\/ calling BiasedLocking::preserve_marks()\/restore_marks() (which\n-  \/\/ decrease the number of mark words that need to be preserved\n-  \/\/ during GC) during each scavenge. During scavenges in which there\n-  \/\/ is no promotion failure, we actually don't need to call the above\n-  \/\/ routines at all, since we don't mutate and re-initialize the\n-  \/\/ marks of promoted objects using init_mark(). However, during\n-  \/\/ scavenges which result in promotion failure, we do re-initialize\n-  \/\/ the mark words of objects, meaning that we should have called\n-  \/\/ these mark word preservation routines. Currently there's no good\n-  \/\/ place in which to call them in any of the scavengers (although\n-  \/\/ guarded by appropriate locks we could make one), but the\n-  \/\/ observation is that promotion failures are quite rare and\n-  \/\/ reducing the number of mark words preserved during them isn't a\n-  \/\/ high priority.\n-  inline bool must_be_preserved_for_promotion_failure(const oopDesc* obj) const;\n+  bool must_be_preserved_for_promotion_failure(const oopDesc* obj) const {\n+    return (!is_unlocked() || !has_no_hash());\n+  }\n@@ -308,7 +213,0 @@\n-  static markWord encode(JavaThread* thread, uint age, int bias_epoch) {\n-    uintptr_t tmp = (uintptr_t) thread;\n-    assert(UseBiasedLocking && ((tmp & (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == 0), \"misaligned JavaThread pointer\");\n-    assert(age <= max_age, \"age too large\");\n-    assert(bias_epoch <= max_bias_epoch, \"bias epoch too large\");\n-    return markWord(tmp | (bias_epoch << epoch_shift) | (age << age_shift) | biased_lock_pattern);\n-  }\n@@ -344,3 +242,0 @@\n-  \/\/ Helper function for restoration of unmarked mark oops during GC\n-  static inline markWord prototype_for_klass(const Klass* klass);\n-\n@@ -354,1 +249,1 @@\n-  inline void* decode_pointer() { if (UseBiasedLocking && has_bias_pattern()) return NULL; return (void*)clear_lock_bits().value(); }\n+  inline void* decode_pointer() { return (void*)clear_lock_bits().value(); }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":20,"deletions":125,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_OOPS_MARKWORD_INLINE_HPP\n-#define SHARE_OOPS_MARKWORD_INLINE_HPP\n-\n-#include \"oops\/markWord.hpp\"\n-\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/globals.hpp\"\n-\n-\/\/ Should this header be preserved during GC?\n-inline bool markWord::must_be_preserved(const oopDesc* obj) const {\n-  if (UseBiasedLocking) {\n-    if (has_bias_pattern()) {\n-      \/\/ Will reset bias at end of collection\n-      \/\/ Mark words of biased and currently locked objects are preserved separately\n-      return false;\n-    }\n-    markWord prototype_header = prototype_for_klass(obj->klass());\n-    if (prototype_header.has_bias_pattern()) {\n-      \/\/ Individual instance which has its bias revoked; must return\n-      \/\/ true for correctness\n-      return true;\n-    }\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-\/\/ Should this header be preserved in the case of a promotion failure during scavenge?\n-inline bool markWord::must_be_preserved_for_promotion_failure(const oopDesc* obj) const {\n-  if (UseBiasedLocking) {\n-    \/\/ We don't explicitly save off the mark words of biased and\n-    \/\/ currently-locked objects during scavenges, so if during a\n-    \/\/ promotion failure we encounter either a biased mark word or a\n-    \/\/ klass which still has a biasable prototype header, we have to\n-    \/\/ preserve the mark word. This results in oversaving, but promotion\n-    \/\/ failures are rare, and this avoids adding more complex logic to\n-    \/\/ the scavengers to call new variants of\n-    \/\/ BiasedLocking::preserve_marks() \/ restore_marks() in the middle\n-    \/\/ of a scavenge when a promotion failure has first been detected.\n-    if (has_bias_pattern() || prototype_for_klass(obj->klass()).has_bias_pattern()) {\n-      return true;\n-    }\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-inline markWord markWord::prototype_for_klass(const Klass* klass) {\n-  markWord prototype_header = klass->prototype_header();\n-  assert(prototype_header == prototype() || prototype_header.has_bias_pattern(), \"corrupt prototype header\");\n-\n-  return prototype_header;\n-}\n-\n-#endif \/\/ SHARE_OOPS_MARKWORD_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -616,1 +616,1 @@\n-    JavaThread* THREAD = current->as_Java_thread(); \/\/ For exception macros.\n+    JavaThread* THREAD = JavaThread::cast(current); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,1 +236,0 @@\n-  inline bool has_bias_pattern() const;\n@@ -286,2 +285,0 @@\n-  \/\/ NOTE with the introduction of UseBiasedLocking that identity_hash() might reach a\n-  \/\/ safepoint if called on a biased object. Calling code must be aware of that.\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -78,1 +78,1 @@\n-  set_mark(markWord::prototype_for_klass(klass()));\n+  set_mark(markWord::prototype());\n@@ -257,4 +257,0 @@\n-bool oopDesc::has_bias_pattern() const {\n-  return mark().has_bias_pattern();\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -290,7 +290,11 @@\n-  develop_pd(intx, FLOATPRESSURE,                                           \\\n-          \"Number of float LRG's that constitute high register pressure\")   \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  develop_pd(intx, INTPRESSURE,                                             \\\n-          \"Number of integer LRG's that constitute high register pressure\") \\\n-          range(0, max_jint)                                                \\\n+  develop(intx, FLOATPRESSURE, -1,                                          \\\n+          \"Number of float LRG's that constitute high register pressure.\"   \\\n+          \"-1: means the threshold is determined by number of available \"   \\\n+          \"float register for allocation\")                                  \\\n+          range(-1, max_jint)                                               \\\n+                                                                            \\\n+  develop(intx, INTPRESSURE, -1,                                            \\\n+          \"Number of integer LRG's that constitute high register pressure.\" \\\n+          \"-1: means the threshold is determined by number of available \"   \\\n+          \"integer register for allocation\")                                \\\n+          range(-1, max_jint)                                               \\\n@@ -451,4 +455,0 @@\n-  product(bool, PrintPreciseBiasedLockingStatistics, false, DIAGNOSTIC,     \\\n-          \"(Deprecated) Print per-lock-site statistics of biased locking \"  \\\n-          \"in JVM\")                                                         \\\n-                                                                            \\\n@@ -510,3 +510,0 @@\n-  product(bool, UseOptoBiasInlining, true,                                  \\\n-          \"(Deprecated) Generate biased locking code in C2 ideal graph\")    \\\n-                                                                            \\\n@@ -770,0 +767,3 @@\n+                                                                            \\\n+  product(bool, VerifyReceiverTypes, trueInDebug, DIAGNOSTIC,               \\\n+          \"Verify receiver types at runtime\")                               \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -518,0 +518,4 @@\n+  if (!allow_inline && _callee->holder()->is_interface()) {\n+    \/\/ Don't convert the interface call to a direct call guarded by an interface subtype check.\n+    return false;\n+  }\n@@ -956,1 +960,1 @@\n-    \/\/ Instance exactly does not matches the desired type.\n+    \/\/ Instance does not match the predicted type.\n@@ -961,1 +965,1 @@\n-  \/\/ fall through if the instance exactly matches the desired type\n+  \/\/ Fall through if the instance matches the desired type.\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1673,7 +1673,1 @@\n-  if (UseBiasedLocking && Opcode() == Op_Allocate) {\n-    Node* klass_node = in(AllocateNode::KlassNode);\n-    Node* proto_adr = phase->transform(new AddPNode(klass_node, klass_node, phase->MakeConX(in_bytes(Klass::prototype_header_offset()))));\n-    mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n-  } else {\n-    mark_node = phase->MakeConX(markWord::prototype().value());\n-  }\n+  mark_node = phase->MakeConX(markWord::prototype().value());\n@@ -1761,1 +1755,1 @@\n-      length->set_req(0, init->proj_out_or_null(0));\n+      length->set_req(TypeFunc::Control, init->proj_out_or_null(TypeFunc::Control));\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -213,4 +213,4 @@\n-  , _sched_int_pressure(0, INTPRESSURE)\n-  , _sched_float_pressure(0, FLOATPRESSURE)\n-  , _scratch_int_pressure(0, INTPRESSURE)\n-  , _scratch_float_pressure(0, FLOATPRESSURE)\n+  , _sched_int_pressure(0, Matcher::int_pressure_limit())\n+  , _sched_float_pressure(0, Matcher::float_pressure_limit())\n+  , _scratch_int_pressure(0, Matcher::int_pressure_limit())\n+  , _scratch_float_pressure(0, Matcher::float_pressure_limit())\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,0 +75,3 @@\n+  const bool is_virtual_or_interface = (bytecode == Bytecodes::_invokevirtual) ||\n+                                       (bytecode == Bytecodes::_invokeinterface);\n+\n@@ -167,0 +170,12 @@\n+        \/\/ For optimized virtual calls assert at runtime that receiver object\n+        \/\/ is a subtype of the inlined method holder. CHA can report a method\n+        \/\/ as a unique target under an abstract method, but receiver type\n+        \/\/ sometimes has a broader type. Similar scenario is possible with\n+        \/\/ default methods when type system loses information about implemented\n+        \/\/ interfaces.\n+        if (cg != NULL && is_virtual_or_interface && !callee->is_static()) {\n+          CallGenerator* trap_cg = CallGenerator::for_uncommon_trap(callee,\n+              Deoptimization::Reason_receiver_constraint, Deoptimization::Action_none);\n+\n+          cg = CallGenerator::for_guarded_call(callee->holder(), trap_cg, cg);\n+        }\n@@ -347,3 +362,10 @@\n-    \/\/ Class Hierarchy Analysis or Type Profile reveals a unique target,\n-    \/\/ or it is a static or special call.\n-    return CallGenerator::for_direct_call(callee, should_delay_inlining(callee, jvms));\n+    \/\/ Class Hierarchy Analysis or Type Profile reveals a unique target, or it is a static or special call.\n+    CallGenerator* cg = CallGenerator::for_direct_call(callee, should_delay_inlining(callee, jvms));\n+    \/\/ For optimized virtual calls assert at runtime that receiver object\n+    \/\/ is a subtype of the method holder.\n+    if (cg != NULL && is_virtual_or_interface && !callee->is_static()) {\n+      CallGenerator* trap_cg = CallGenerator::for_uncommon_trap(callee,\n+          Deoptimization::Reason_receiver_constraint, Deoptimization::Action_none);\n+      cg = CallGenerator::for_guarded_call(callee->holder(), trap_cg, cg);\n+    }\n+    return cg;\n@@ -1108,3 +1130,3 @@\n-  ciInstanceKlass *ikl = receiver_type->klass()->as_instance_klass();\n-  if (ikl->is_loaded() && ikl->is_initialized() && !ikl->is_interface() &&\n-      (ikl == actual_receiver || ikl->is_subtype_of(actual_receiver))) {\n+  ciInstanceKlass* receiver_klass = receiver_type->klass()->as_instance_klass();\n+  if (receiver_klass->is_loaded() && receiver_klass->is_initialized() && !receiver_klass->is_interface() &&\n+      (receiver_klass == actual_receiver || receiver_klass->is_subtype_of(actual_receiver))) {\n@@ -1113,1 +1135,1 @@\n-    actual_receiver = ikl;\n+    actual_receiver = receiver_klass;\n@@ -1121,11 +1143,0 @@\n-  \/\/ Validate receiver info against target method.\n-  if (cha_monomorphic_target != NULL) {\n-    bool has_receiver = !cha_monomorphic_target->is_static();\n-    bool is_interface_holder = cha_monomorphic_target->holder()->is_interface();\n-    if (has_receiver && !is_interface_holder) {\n-      if (!cha_monomorphic_target->holder()->is_subtype_of(receiver_type->klass())) {\n-        cha_monomorphic_target = NULL; \/\/ not a subtype\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1187,5 +1187,1 @@\n-    alen = alloc->Ideal_length();\n-    Node* ccast = alloc->make_ideal_length(_gvn.type(array)->is_oopptr(), &_gvn);\n-    if (ccast != alen) {\n-      alen = _gvn.transform(ccast);\n-    }\n+    alen = array_ideal_length(alloc, _gvn.type(array)->is_oopptr(), false);\n@@ -1196,0 +1192,20 @@\n+Node* GraphKit::array_ideal_length(AllocateArrayNode* alloc,\n+                                   const TypeOopPtr* oop_type,\n+                                   bool replace_length_in_map) {\n+  Node* length = alloc->Ideal_length();\n+  if (replace_length_in_map == false || map()->find_edge(length) >= 0) {\n+    Node* ccast = alloc->make_ideal_length(oop_type, &_gvn);\n+    if (ccast != length) {\n+      \/\/ do not transfrom ccast here, it might convert to top node for\n+      \/\/ negative array length and break assumptions in parsing stage.\n+      _gvn.set_type_bottom(ccast);\n+      record_for_igvn(ccast);\n+      if (replace_length_in_map) {\n+        replace_in_map(length, ccast);\n+      }\n+      return ccast;\n+    }\n+  }\n+  return length;\n+}\n+\n@@ -2936,1 +2952,3 @@\n-  if (ExpandSubTypeCheckAtParseTime) {\n+  bool expand_subtype_check = C->post_loop_opts_phase() ||   \/\/ macro node expansion is over\n+                              ExpandSubTypeCheckAtParseTime; \/\/ forced expansion\n+  if (expand_subtype_check) {\n@@ -3509,4 +3527,0 @@\n-  if (UseBiasedLocking && PrintPreciseBiasedLockingStatistics) {\n-    \/\/ Create the counters for this fast lock.\n-    flock->create_lock_counter(sync_jvms()); \/\/ sync_jvms used to get current bci\n-  }\n@@ -3981,10 +3995,1 @@\n-  \/\/ Cast length on remaining path to be as narrow as possible\n-  if (map()->find_edge(length) >= 0) {\n-    Node* ccast = alloc->make_ideal_length(ary_type, &_gvn);\n-    if (ccast != length) {\n-      _gvn.set_type_bottom(ccast);\n-      record_for_igvn(ccast);\n-      replace_in_map(length, ccast);\n-    }\n-  }\n-\n+  array_ideal_length(alloc, ary_type, true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":25,"deletions":20,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -346,0 +346,6 @@\n+  \/\/ Cast array allocation's length as narrow as possible.\n+  \/\/ If replace_length_in_map is true, replace length with CastIINode in map.\n+  \/\/ This method is invoked after creating\/moving ArrayAllocationNode or in load_array_length\n+  Node* array_ideal_length(AllocateArrayNode* alloc,\n+                           const TypeOopPtr* oop_type,\n+                           bool replace_length_in_map);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -859,2 +859,2 @@\n-    Pressure int_pressure(last_inst + 1, INTPRESSURE);\n-    Pressure float_pressure(last_inst + 1, FLOATPRESSURE);\n+    Pressure int_pressure(last_inst + 1, Matcher::int_pressure_limit());\n+    Pressure float_pressure(last_inst + 1, Matcher::float_pressure_limit());\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1079,5 +1079,4 @@\n-    uint float_pressure = Matcher::float_pressure(FLOATPRESSURE);\n-    _regalloc->_sched_int_pressure.init(INTPRESSURE);\n-    _regalloc->_sched_float_pressure.init(float_pressure);\n-    _regalloc->_scratch_int_pressure.init(INTPRESSURE);\n-    _regalloc->_scratch_float_pressure.init(float_pressure);\n+    _regalloc->_sched_int_pressure.init(Matcher::int_pressure_limit());\n+    _regalloc->_sched_float_pressure.init(Matcher::float_pressure_limit());\n+    _regalloc->_scratch_int_pressure.init(Matcher::int_pressure_limit());\n+    _regalloc->_scratch_float_pressure.init(Matcher::float_pressure_limit());\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3813,1 +3813,1 @@\n-  Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);\n+  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n@@ -4448,0 +4448,30 @@\n+\n+    \/\/ The CastIINode created in GraphKit::new_array (in AllocateArrayNode::make_ideal_length) must stay below\n+    \/\/ the allocation (i.e. is only valid if the allocation succeeds):\n+    \/\/ 1) replace CastIINode with AllocateArrayNode's length here\n+    \/\/ 2) Create CastIINode again once allocation has moved (see below) at the end of this method\n+    \/\/\n+    \/\/ Multiple identical CastIINodes might exist here. Each GraphKit::load_array_length() call will generate\n+    \/\/ new separate CastIINode (arraycopy guard checks or any array length use between array allocation and ararycopy)\n+    Node* init_control = init->proj_out(TypeFunc::Control);\n+    Node* alloc_length = alloc->Ideal_length();\n+#ifdef ASSERT\n+    Node* prev_cast = NULL;\n+#endif\n+    for (uint i = 0; i < init_control->outcnt(); i++) {\n+      Node* init_out = init_control->raw_out(i);\n+      if (init_out->is_CastII() && init_out->in(TypeFunc::Control) == init_control && init_out->in(1) == alloc_length) {\n+#ifdef ASSERT\n+        if (prev_cast == NULL) {\n+          prev_cast = init_out;\n+        } else {\n+          if (prev_cast->cmp(*init_out) == false) {\n+            prev_cast->dump();\n+            init_out->dump();\n+            assert(false, \"not equal CastIINode\");\n+          }\n+        }\n+#endif\n+        C->gvn_replace_by(init_out, alloc_length);\n+      }\n+    }\n@@ -4479,0 +4509,2 @@\n+\n+    array_ideal_length(alloc, ary_type, true);\n@@ -6385,1 +6417,1 @@\n-  assert(callee()->signature()->size() == 6, \"base64_decodeBlock has 6 parameters\");\n+  assert(callee()->signature()->size() == 7, \"base64_decodeBlock has 7 parameters\");\n@@ -6397,0 +6429,1 @@\n+  Node* isMIME = argument(7);\n@@ -6409,1 +6442,1 @@\n-                                 src_start, src_offset, len, dest_start, dest_offset, isURL);\n+                                 src_start, src_offset, len, dest_start, dest_offset, isURL, isMIME);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -161,9 +161,0 @@\n-\/\/\n-\/\/ Create a counter which counts the number of times this lock is acquired\n-\/\/\n-void FastLockNode::create_lock_counter(JVMState* state) {\n-  BiasedLockingNamedCounter* blnc = (BiasedLockingNamedCounter*)\n-           OptoRuntime::new_named_counter(state, NamedCounter::BiasedLockingCounter);\n-  _counters = blnc->counters();\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-class BiasedLockingCounters;\n@@ -77,1 +76,0 @@\n-  BiasedLockingCounters*        _counters;\n@@ -85,1 +83,0 @@\n-    _counters = NULL;\n@@ -102,1 +99,0 @@\n-  void create_lock_counter(JVMState* s);\n@@ -104,1 +100,0 @@\n-  BiasedLockingCounters*        counters() const { return _counters; }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2854,0 +2854,10 @@\n+  assert(main_limit == cl->limit() || get_ctrl(main_limit) == pre_ctrl, \"wrong control for added limit\");\n+  const TypeInt* orig_limit_t = _igvn.type(orig_limit)->is_int();\n+  bool upward = cl->stride_con() > 0;\n+  \/\/ The new loop limit is <= (for an upward loop) >= (for a downward loop) than the orig limit.\n+  \/\/ The expression that computes the new limit may be too complicated and the computed type of the new limit\n+  \/\/ may be too pessimistic. A CastII here guarantees it's not lost.\n+  main_limit = new CastIINode(main_limit, TypeInt::make(upward ? min_jint : orig_limit_t->_lo,\n+                                                        upward ? orig_limit_t->_hi : max_jint, Type::WidenMax));\n+  main_limit->init_req(0, pre_ctrl);\n+  register_new_node(main_limit, pre_ctrl);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1999,1 +1999,1 @@\n-      Node* c = u->in(0) != NULL ? u->in(0) : phase->get_ctrl(u);\n+      Node* c = phase->get_ctrl(u);\n@@ -2002,1 +2002,4 @@\n-      if (outer_loop->is_member(u_loop)) {\n+      if (outer_loop->is_member(u_loop) ||\n+          \/\/ nodes pinned with control in the outer loop but not referenced from the safepoint must be moved out of\n+          \/\/ the outer loop too\n+          (u->in(0) != NULL && outer_loop->is_member(phase->get_loop(u->in(0))))) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class BiasedLockingCounters;\n@@ -798,1 +797,0 @@\n-  BiasedLockingCounters*        _counters;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2167,80 +2167,3 @@\n-  if (UseOptoBiasInlining) {\n-    \/*\n-     *  See the full description in MacroAssembler::biased_locking_enter().\n-     *\n-     *  if( (mark_word & biased_lock_mask) == biased_lock_pattern ) {\n-     *    \/\/ The object is biased.\n-     *    proto_node = klass->prototype_header;\n-     *    o_node = thread | proto_node;\n-     *    x_node = o_node ^ mark_word;\n-     *    if( (x_node & ~age_mask) == 0 ) { \/\/ Biased to the current thread ?\n-     *      \/\/ Done.\n-     *    } else {\n-     *      if( (x_node & biased_lock_mask) != 0 ) {\n-     *        \/\/ The klass's prototype header is no longer biased.\n-     *        cas(&mark_word, mark_word, proto_node)\n-     *        goto cas_lock;\n-     *      } else {\n-     *        \/\/ The klass's prototype header is still biased.\n-     *        if( (x_node & epoch_mask) != 0 ) { \/\/ Expired epoch?\n-     *          old = mark_word;\n-     *          new = o_node;\n-     *        } else {\n-     *          \/\/ Different thread or anonymous biased.\n-     *          old = mark_word & (epoch_mask | age_mask | biased_lock_mask);\n-     *          new = thread | old;\n-     *        }\n-     *        \/\/ Try to rebias.\n-     *        if( cas(&mark_word, old, new) == 0 ) {\n-     *          \/\/ Done.\n-     *        } else {\n-     *          goto slow_path; \/\/ Failed.\n-     *        }\n-     *      }\n-     *    }\n-     *  } else {\n-     *    \/\/ The object is not biased.\n-     *    cas_lock:\n-     *    if( FastLock(obj) == 0 ) {\n-     *      \/\/ Done.\n-     *    } else {\n-     *      slow_path:\n-     *      OptoRuntime::complete_monitor_locking_Java(obj);\n-     *    }\n-     *  }\n-     *\/\n-\n-    region  = new RegionNode(5);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    Node* fast_lock_region  = new RegionNode(3);\n-    Node* fast_lock_mem_phi = new PhiNode( fast_lock_region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ First, check mark word for the biased lock pattern.\n-    Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-\n-    \/\/ Get fast path - mark word has the biased lock pattern.\n-    ctrl = opt_bits_test(ctrl, fast_lock_region, 1, mark_node,\n-                         markWord::biased_lock_mask_in_place,\n-                         markWord::biased_lock_pattern, true);\n-    \/\/ fast_lock_region->in(1) is set to slow path.\n-    fast_lock_mem_phi->init_req(1, mem);\n-\n-    \/\/ Now check that the lock is biased to the current thread and has\n-    \/\/ the same epoch and bias as Klass::_prototype_header.\n-\n-    \/\/ Special-case a fresh allocation to avoid building nodes:\n-    Node* klass_node = AllocateNode::Ideal_klass(obj, &_igvn);\n-    if (klass_node == NULL) {\n-      Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());\n-      klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, mem, k_adr, _igvn.type(k_adr)->is_ptr()));\n-#ifdef _LP64\n-      if (UseCompressedClassPointers && klass_node->is_DecodeNKlass()) {\n-        assert(klass_node->in(1)->Opcode() == Op_LoadNKlass, \"sanity\");\n-        klass_node->in(1)->init_req(0, ctrl);\n-      } else\n-#endif\n-      klass_node->init_req(0, ctrl);\n-    }\n-    Node *proto_node = make_load(ctrl, mem, klass_node, in_bytes(Klass::prototype_header_offset()), TypeX_X, TypeX_X->basic_type());\n+  region  = new RegionNode(3);\n+  \/\/ create a Phi for the memory state\n+  mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n@@ -2248,109 +2171,3 @@\n-    Node* thread = transform_later(new ThreadLocalNode());\n-    Node* cast_thread = transform_later(new CastP2XNode(ctrl, thread));\n-    Node* o_node = transform_later(new OrXNode(cast_thread, proto_node));\n-    Node* x_node = transform_later(new XorXNode(o_node, mark_node));\n-\n-    \/\/ Get slow path - mark word does NOT match the value.\n-    STATIC_ASSERT(markWord::age_mask_in_place <= INT_MAX);\n-    Node* not_biased_ctrl =  opt_bits_test(ctrl, region, 3, x_node,\n-                                      (~(int)markWord::age_mask_in_place), 0);\n-    \/\/ region->in(3) is set to fast path - the object is biased to the current thread.\n-    mem_phi->init_req(3, mem);\n-\n-\n-    \/\/ Mark word does NOT match the value (thread | Klass::_prototype_header).\n-\n-\n-    \/\/ First, check biased pattern.\n-    \/\/ Get fast path - _prototype_header has the same biased lock pattern.\n-    ctrl =  opt_bits_test(not_biased_ctrl, fast_lock_region, 2, x_node,\n-                          markWord::biased_lock_mask_in_place, 0, true);\n-\n-    not_biased_ctrl = fast_lock_region->in(2); \/\/ Slow path\n-    \/\/ fast_lock_region->in(2) - the prototype header is no longer biased\n-    \/\/ and we have to revoke the bias on this object.\n-    \/\/ We are going to try to reset the mark of this object to the prototype\n-    \/\/ value and fall through to the CAS-based locking scheme.\n-    Node* adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n-    Node* cas = new StoreXConditionalNode(not_biased_ctrl, mem, adr,\n-                                          proto_node, mark_node);\n-    transform_later(cas);\n-    Node* proj = transform_later(new SCMemProjNode(cas));\n-    fast_lock_mem_phi->init_req(2, proj);\n-\n-\n-    \/\/ Second, check epoch bits.\n-    Node* rebiased_region  = new RegionNode(3);\n-    Node* old_phi = new PhiNode( rebiased_region, TypeX_X);\n-    Node* new_phi = new PhiNode( rebiased_region, TypeX_X);\n-\n-    \/\/ Get slow path - mark word does NOT match epoch bits.\n-    Node* epoch_ctrl =  opt_bits_test(ctrl, rebiased_region, 1, x_node,\n-                                      markWord::epoch_mask_in_place, 0);\n-    \/\/ The epoch of the current bias is not valid, attempt to rebias the object\n-    \/\/ toward the current thread.\n-    rebiased_region->init_req(2, epoch_ctrl);\n-    old_phi->init_req(2, mark_node);\n-    new_phi->init_req(2, o_node);\n-\n-    \/\/ rebiased_region->in(1) is set to fast path.\n-    \/\/ The epoch of the current bias is still valid but we know\n-    \/\/ nothing about the owner; it might be set or it might be clear.\n-    Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |\n-                             markWord::age_mask_in_place |\n-                             markWord::epoch_mask_in_place);\n-    Node* old = transform_later(new AndXNode(mark_node, cmask));\n-    cast_thread = transform_later(new CastP2XNode(ctrl, thread));\n-    Node* new_mark = transform_later(new OrXNode(cast_thread, old));\n-    old_phi->init_req(1, old);\n-    new_phi->init_req(1, new_mark);\n-\n-    transform_later(rebiased_region);\n-    transform_later(old_phi);\n-    transform_later(new_phi);\n-\n-    \/\/ Try to acquire the bias of the object using an atomic operation.\n-    \/\/ If this fails we will go in to the runtime to revoke the object's bias.\n-    cas = new StoreXConditionalNode(rebiased_region, mem, adr, new_phi, old_phi);\n-    transform_later(cas);\n-    proj = transform_later(new SCMemProjNode(cas));\n-\n-    \/\/ Get slow path - Failed to CAS.\n-    not_biased_ctrl = opt_bits_test(rebiased_region, region, 4, cas, 0, 0);\n-    mem_phi->init_req(4, proj);\n-    \/\/ region->in(4) is set to fast path - the object is rebiased to the current thread.\n-\n-    \/\/ Failed to CAS.\n-    slow_path  = new RegionNode(3);\n-    Node *slow_mem = new PhiNode( slow_path, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    slow_path->init_req(1, not_biased_ctrl); \/\/ Capture slow-control\n-    slow_mem->init_req(1, proj);\n-\n-    \/\/ Call CAS-based locking scheme (FastLock node).\n-\n-    transform_later(fast_lock_region);\n-    transform_later(fast_lock_mem_phi);\n-\n-    \/\/ Get slow path - FastLock failed to lock the object.\n-    ctrl = opt_bits_test(fast_lock_region, region, 2, flock, 0, 0);\n-    mem_phi->init_req(2, fast_lock_mem_phi);\n-    \/\/ region->in(2) is set to fast path - the object is locked to the current thread.\n-\n-    slow_path->init_req(2, ctrl); \/\/ Capture slow-control\n-    slow_mem->init_req(2, fast_lock_mem_phi);\n-\n-    transform_later(slow_path);\n-    transform_later(slow_mem);\n-    \/\/ Reset lock's memory edge.\n-    lock->set_req(TypeFunc::Memory, slow_mem);\n-\n-  } else {\n-    region  = new RegionNode(3);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ Optimize test; set region slot 2\n-    slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);\n-    mem_phi->init_req(2, mem);\n-  }\n+  \/\/ Optimize test; set region slot 2\n+  slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);\n+  mem_phi->init_req(2, mem);\n@@ -2406,17 +2223,3 @@\n-  if (UseOptoBiasInlining) {\n-    \/\/ Check for biased locking unlock case, which is a no-op.\n-    \/\/ See the full description in MacroAssembler::biased_locking_exit().\n-    region  = new RegionNode(4);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-    mem_phi->init_req(3, mem);\n-\n-    Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-    ctrl = opt_bits_test(ctrl, region, 3, mark_node,\n-                         markWord::biased_lock_mask_in_place,\n-                         markWord::biased_lock_pattern);\n-  } else {\n-    region  = new RegionNode(3);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-  }\n+  region  = new RegionNode(3);\n+  \/\/ create a Phi for the memory state\n+  mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":9,"deletions":206,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -2770,3 +2770,1 @@\n-    \/\/ With biased locking we're no longer guaranteed that a monitor\n-    \/\/ enter operation contains a serializing instruction.\n-    if ((xop == Op_FastLock) && !UseBiasedLocking) {\n+    if (xop == Op_FastLock) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -236,0 +236,4 @@\n+  \/\/ Number of integer live ranges that constitute high register pressure\n+  static uint int_pressure_limit();\n+  \/\/ Number of float live ranges that constitute high register pressure\n+  static uint float_pressure_limit();\n@@ -331,3 +335,0 @@\n-  \/\/ Some uarchs have different sized float register resources\n-  static const int float_pressure(int default_pressure_threshold);\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1837,7 +1837,0 @@\n-  AllocateNode* alloc = is_new_object_mark_load(phase);\n-  if (alloc != NULL && alloc->Opcode() == Op_Allocate && UseBiasedLocking) {\n-    InitializeNode* init = alloc->initialization();\n-    Node* control = init->proj_out(0);\n-    return alloc->make_ideal_mark(phase, address, control, mem);\n-  }\n-\n@@ -2106,1 +2099,1 @@\n-  if (alloc != NULL && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking)) {\n+  if (alloc != NULL) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1196,0 +1196,1 @@\n+#ifdef ASSERT\n@@ -1197,1 +1198,0 @@\n-  ciInstanceKlass* callee_holder = method()->holder();\n@@ -1199,0 +1199,1 @@\n+    ciInstanceKlass* callee_holder = method()->holder();\n@@ -1205,0 +1206,5 @@\n+      \/\/ Receiver should always be a subtype of callee holder.\n+      \/\/ But, since C2 type system doesn't properly track interfaces,\n+      \/\/ the invariant can't be expressed in the type system for default methods.\n+      \/\/ Example: for unrelated C <: I and D <: I, (C `meet` D) = Object <\/: I.\n+      assert(callee_holder->is_interface(), \"missing subtype check\");\n@@ -1206,1 +1212,0 @@\n-#ifdef ASSERT\n@@ -1214,15 +1219,0 @@\n-#endif \/\/ ASSERT\n-\n-      \/\/ Receiver should always be a subtype of callee holder.\n-      \/\/ But, since C2 type system doesn't properly track interfaces,\n-      \/\/ the invariant on default methods can't be expressed in the type system.\n-      \/\/ Example: for unrelated C <: I and D <: I, (C `meet` D) = Object <\/: I.\n-      \/\/ (Downcasting interface receiver type to concrete class is fine, though it doesn't happen in practice.)\n-      if (!callee_holder->is_interface()) {\n-        assert(callee_holder->is_subtype_of(receiver_type->klass()), \"sanity\");\n-        assert(!receiver_type->klass()->is_interface(), \"interface receiver type\");\n-        receiver_type = receiver_type->join_speculative(holder_type)->is_instptr(); \/\/ keep speculative part\n-        Node* casted_receiver_obj = _gvn.transform(new CheckCastPPNode(control(), receiver_obj, receiver_type));\n-        set_local(0, casted_receiver_obj);\n-      }\n-\n@@ -1231,0 +1221,1 @@\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-  int bound_pres = is_float_or_vector ? FLOATPRESSURE : INTPRESSURE;\n+  int bound_pres = is_float_or_vector ? Matcher::float_pressure_limit() : Matcher::int_pressure_limit();\n@@ -803,1 +803,1 @@\n-              (b->_reg_pressure < (uint)INTPRESSURE) ||\n+              (b->_reg_pressure < Matcher::int_pressure_limit()) ||\n@@ -808,1 +808,1 @@\n-              (b->_freg_pressure < (uint)FLOATPRESSURE) ||\n+              (b->_freg_pressure < Matcher::float_pressure_limit()) ||\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1196,1 +1196,1 @@\n-  int argcnt = 6;\n+  int argcnt = 7;\n@@ -1206,0 +1206,1 @@\n+  fields[argp++] = TypeInt::BOOL;       \/\/ isMIME\n@@ -1601,6 +1602,0 @@\n-    } else if (c->tag() == NamedCounter::BiasedLockingCounter) {\n-      BiasedLockingCounters* blc = ((BiasedLockingNamedCounter*)c)->counters();\n-      if (blc->nonzero()) {\n-        tty->print_cr(\"%s\", c->name());\n-        blc->print_on(tty);\n-      }\n@@ -1657,3 +1652,1 @@\n-  if (tag == NamedCounter::BiasedLockingCounter) {\n-    c = new BiasedLockingNamedCounter(st.as_string());\n-  } else if (tag == NamedCounter::RTMLockingCounter) {\n+  if (tag == NamedCounter::RTMLockingCounter) {\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -66,1 +65,0 @@\n-    BiasedLockingCounter,\n@@ -103,12 +101,0 @@\n-class BiasedLockingNamedCounter : public NamedCounter {\n- private:\n-  BiasedLockingCounters _counters;\n-\n- public:\n-  BiasedLockingNamedCounter(const char *n) :\n-    NamedCounter(n, BiasedLockingCounter), _counters() {}\n-\n-  BiasedLockingCounters* counters() { return &_counters; }\n-};\n-\n-\n@@ -173,4 +159,0 @@\n-  \/\/ Slow-path Locking and Unlocking\n-  static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n-  static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2697,1 +2697,1 @@\n-          if (FLOATPRESSURE > 8) {\n+          if (Matcher::float_pressure_limit() > 8) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-#endif\n+#endif \/\/ !PRODUCT\n@@ -1877,3 +1877,1 @@\n-\/\/ UseOptoBiasInlining\n-#define XorXNode     XorLNode\n-#define StoreXConditionalNode StoreLConditionalNode\n+\/\/ For shenandoahSupport\n@@ -1925,3 +1923,1 @@\n-\/\/ UseOptoBiasInlining\n-#define XorXNode     XorINode\n-#define StoreXConditionalNode StoreIConditionalNode\n+\/\/ For shenandoahSupport\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -579,1 +579,1 @@\n-        \"in thread \\\"%s\\\" \", thread->get_thread_name());\n+        \"in thread \\\"%s\\\" \", thread->name());\n@@ -3770,1 +3770,1 @@\n-      *(JNIEnv**)penv = t->as_Java_thread()->jni_environment();\n+      *(JNIEnv**)penv = JavaThread::cast(t)->jni_environment();\n@@ -3907,1 +3907,1 @@\n-  JavaThread* thread = current->as_Java_thread();\n+  JavaThread* thread = JavaThread::cast(current);\n@@ -3969,1 +3969,1 @@\n-      *(JNIEnv**)penv = thread->as_Java_thread()->jni_environment();\n+      *(JNIEnv**)penv = JavaThread::cast(thread)->jni_environment();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    JavaThread* thr = cur->as_Java_thread();                             \\\n+    JavaThread* thr = JavaThread::cast(cur);                             \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,2 +230,4 @@\n-      \/\/ Walk the CodeCache notifying for live nmethods, don't release the CodeCache_lock\n-      \/\/ because the sweeper may be running concurrently.\n+      \/\/ Walk the CodeCache notifying for live nmethods. We hold the CodeCache_lock\n+      \/\/ to ensure the iteration is safe and nmethods are not concurrently freed.\n+      \/\/ However, they may still change states and become !is_alive(). Filtering\n+      \/\/ those out is done inside of nmethod::post_compiled_method_load_event().\n","filename":"src\/hotspot\/share\/prims\/jvmtiCodeBlobEvents.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -436,1 +436,1 @@\n-    <xsl:text>JavaThread* current_thread = this_thread->as_Java_thread();<\/xsl:text>\n+    <xsl:text>JavaThread* current_thread = JavaThread::cast(this_thread);<\/xsl:text>\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnter.xsl","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -973,3 +972,0 @@\n-    \/\/ Revoke any biases before querying the mark word\n-    BiasedLocking::revoke_at_safepoint(hobj);\n-\n@@ -1272,1 +1268,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1396,1 +1392,1 @@\n-  JavaThread* java_thread = target->as_Java_thread();\n+  JavaThread* java_thread = JavaThread::cast(target);\n@@ -1531,1 +1527,1 @@\n-  JavaThread* java_thread = target->as_Java_thread();\n+  JavaThread* java_thread = JavaThread::cast(target);\n@@ -1621,1 +1617,1 @@\n-  JavaThread* java_thread = target->as_Java_thread();\n+  JavaThread* java_thread = JavaThread::cast(target);\n@@ -1652,1 +1648,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1662,1 +1658,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1672,1 +1668,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1691,1 +1687,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-    JavaThread *jt = target->as_Java_thread();\n+    JavaThread *jt = JavaThread::cast(target);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-    JavaThread* jt = th->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(th);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-       _jthread = thread->as_Java_thread();\n+       _jthread = JavaThread::cast(thread);\n@@ -2311,1 +2311,1 @@\n-    JvmtiThreadState *state = thread->as_Java_thread()->jvmti_thread_state();\n+    JvmtiThreadState *state = JavaThread::cast(thread)->jvmti_thread_state();\n@@ -2335,1 +2335,1 @@\n-    JvmtiThreadState *state = thread->as_Java_thread()->jvmti_thread_state();\n+    JvmtiThreadState *state = JavaThread::cast(thread)->jvmti_thread_state();\n@@ -2871,1 +2871,1 @@\n-    JavaThread* current_thread = thread->as_Java_thread();\n+    JavaThread* current_thread = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n@@ -329,1 +329,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n@@ -382,1 +382,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4071,1 +4071,1 @@\n-\/\/ Deoptimize all compiled code that depends on this class.\n+\/\/ Deoptimize all compiled code that depends on the classes redefined.\n@@ -4087,12 +4087,0 @@\n-\/\/ First step is to walk the code cache for each class redefined and mark\n-\/\/ dependent methods.  Wait until all classes are processed to deoptimize everything.\n-void VM_RedefineClasses::mark_dependent_code(InstanceKlass* ik) {\n-  assert_locked_or_safepoint(Compile_lock);\n-\n-  \/\/ All dependencies have been recorded from startup or this is a second or\n-  \/\/ subsequent use of RedefineClasses\n-  if (JvmtiExport::all_dependencies_are_recorded()) {\n-    CodeCache::mark_for_evol_deoptimization(ik);\n-  }\n-}\n-\n@@ -4223,3 +4211,0 @@\n-\n-  \/\/ Mark all compiled code that depends on this class\n-  mark_dependent_code(the_class);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -496,1 +496,0 @@\n-  void mark_dependent_code(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1401,4 +1400,0 @@\n-\n-  if (UseBiasedLocking) {\n-    BiasedLocking::preserve_marks();\n-  }\n@@ -1427,4 +1422,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::restore_marks();\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -280,1 +280,1 @@\n-  oop threadObj = thread->as_Java_thread()->threadObj();\n+  oop threadObj = JavaThread::cast(thread)->threadObj();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-    upcall_helper(thread->as_Java_thread(), rec, buff);\n+    upcall_helper(JavaThread::cast(thread), rec, buff);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/typeArrayOop.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"oops\/typeArrayOop.hpp\"\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -2020,0 +2020,46 @@\n+WB_ENTRY(jboolean, WB_HandshakeReadMonitors(JNIEnv* env, jobject wb, jobject thread_handle))\n+  class ReadMonitorsClosure : public HandshakeClosure {\n+    jboolean _executed;\n+\n+    void do_thread(Thread* th) {\n+      JavaThread* jt = JavaThread::cast(th);\n+      ResourceMark rm;\n+\n+      GrowableArray<MonitorInfo*>* info = new GrowableArray<MonitorInfo*>();\n+\n+      if (!jt->has_last_Java_frame()) {\n+        return;\n+      }\n+      RegisterMap rmap(jt);\n+      for (javaVFrame* vf = jt->last_java_vframe(&rmap); vf != NULL; vf = vf->java_sender()) {\n+        GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n+        if (monitors != NULL) {\n+          int len = monitors->length();\n+          \/\/ Walk monitors youngest to oldest\n+          for (int i = len - 1; i >= 0; i--) {\n+            MonitorInfo* mon_info = monitors->at(i);\n+            if (mon_info->eliminated()) continue;\n+            oop owner = mon_info->owner();\n+            if (owner != NULL) {\n+              info->append(mon_info);\n+            }\n+          }\n+        }\n+      }\n+      _executed = true;\n+    }\n+\n+   public:\n+    ReadMonitorsClosure() : HandshakeClosure(\"WB_HandshakeReadMonitors\"), _executed(false) {}\n+    jboolean executed() const { return _executed; }\n+  };\n+\n+  ReadMonitorsClosure rmc;\n+  oop thread_oop = JNIHandles::resolve(thread_handle);\n+  if (thread_oop != NULL) {\n+    JavaThread* target = java_lang_Thread::thread(thread_oop);\n+    Handshake::execute(&rmc, target);\n+  }\n+  return rmc.executed();\n+WB_END\n+\n@@ -2025,1 +2071,1 @@\n-      JavaThread* jt = th->as_Java_thread();\n+      JavaThread* jt = JavaThread::cast(th);\n@@ -2061,1 +2107,1 @@\n-      JavaThread* jt = th->as_Java_thread();\n+      JavaThread* jt = JavaThread::cast(th);\n@@ -2567,0 +2613,1 @@\n+  {CC\"handshakeReadMonitors\", CC\"(Ljava\/lang\/Thread;)Z\", (void*)&WB_HandshakeReadMonitors },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,3 +169,0 @@\n-  \/\/ ARCH specific policy for the BiasedLocking\n-  static bool use_biased_locking()  { return true; }\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -536,0 +536,2 @@\n+  { \"G1RSetRegionEntries\",          JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"G1RSetSparseRegionEntries\",    JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n@@ -3106,4 +3108,0 @@\n-    \/\/ Disable biased locking now as it interferes with the clean up of\n-    \/\/ the archived Klasses and Java string objects (at dump time only).\n-    UseBiasedLocking = false;\n-\n@@ -4023,20 +4021,0 @@\n-  \/\/ Turn off biased locking for locking debug mode flags,\n-  \/\/ which are subtly different from each other but neither works with\n-  \/\/ biased locking\n-  if (UseHeavyMonitors\n-#ifdef COMPILER1\n-      || !UseFastLocking\n-#endif \/\/ COMPILER1\n-#if INCLUDE_JVMCI\n-      || !JVMCIUseFastLocking\n-#endif\n-    ) {\n-    if (!FLAG_IS_DEFAULT(UseBiasedLocking) && UseBiasedLocking) {\n-      \/\/ flag set to true on command line; warn the user that they\n-      \/\/ can't enable biased locking here\n-      warning(\"Biased Locking is not supported with locking debug flags\"\n-              \"; ignoring UseBiasedLocking flag.\" );\n-    }\n-    UseBiasedLocking = false;\n-  }\n-\n@@ -4046,1 +4024,0 @@\n-  FLAG_SET_DEFAULT(UseBiasedLocking, false);\n@@ -4077,7 +4054,0 @@\n-  \/\/ Apply CPU specific policy for the BiasedLocking\n-  if (UseBiasedLocking) {\n-    if (!VM_Version::use_biased_locking() &&\n-        !(FLAG_IS_CMDLINE(UseBiasedLocking))) {\n-      UseBiasedLocking = false;\n-    }\n-  }\n@@ -4085,4 +4055,0 @@\n-  if (!UseBiasedLocking) {\n-    UseOptoBiasInlining = false;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":36,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1,995 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n-#include \"jfr\/jfrEvents.hpp\"\n-#include \"jfr\/support\/jfrThreadId.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/basicLock.hpp\"\n-#include \"runtime\/biasedLocking.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/handshake.hpp\"\n-#include \"runtime\/safepointMechanism.hpp\"\n-#include \"runtime\/task.hpp\"\n-#include \"runtime\/threadSMR.hpp\"\n-#include \"runtime\/vframe.hpp\"\n-#include \"runtime\/vmThread.hpp\"\n-#include \"runtime\/vmOperations.hpp\"\n-\n-\n-static bool _biased_locking_enabled = false;\n-BiasedLockingCounters BiasedLocking::_counters;\n-\n-static GrowableArray<Handle>*   _preserved_oop_stack  = NULL;\n-static GrowableArray<markWord>* _preserved_mark_stack = NULL;\n-\n-static void enable_biased_locking(InstanceKlass* k) {\n-  k->set_prototype_header(markWord::biased_locking_prototype());\n-}\n-\n-static void enable_biased_locking() {\n-  _biased_locking_enabled = true;\n-  log_info(biasedlocking)(\"Biased locking enabled\");\n-}\n-\n-class VM_EnableBiasedLocking: public VM_Operation {\n- public:\n-  VM_EnableBiasedLocking() {}\n-  VMOp_Type type() const          { return VMOp_EnableBiasedLocking; }\n-\n-  void doit() {\n-    \/\/ Iterate the class loader data dictionaries enabling biased locking for all\n-    \/\/ currently loaded classes.\n-    ClassLoaderDataGraph::dictionary_classes_do(enable_biased_locking);\n-    \/\/ Indicate that future instances should enable it as well\n-    enable_biased_locking();\n-  }\n-\n-  bool allow_nested_vm_operations() const        { return false; }\n-};\n-\n-\n-\/\/ One-shot PeriodicTask subclass for enabling biased locking\n-class EnableBiasedLockingTask : public PeriodicTask {\n- public:\n-  EnableBiasedLockingTask(size_t interval_time) : PeriodicTask(interval_time) {}\n-\n-  virtual void task() {\n-    VM_EnableBiasedLocking op;\n-    VMThread::execute(&op);\n-\n-    \/\/ Reclaim our storage and disenroll ourself\n-    delete this;\n-  }\n-};\n-\n-\n-void BiasedLocking::init() {\n-  \/\/ If biased locking is enabled and BiasedLockingStartupDelay is set,\n-  \/\/ schedule a task to fire after the specified delay which turns on\n-  \/\/ biased locking for all currently loaded classes as well as future\n-  \/\/ ones. This could be a workaround for startup time regressions\n-  \/\/ due to large number of safepoints being taken during VM startup for\n-  \/\/ bias revocation.\n-  if (UseBiasedLocking) {\n-    if (BiasedLockingStartupDelay > 0) {\n-      EnableBiasedLockingTask* task = new EnableBiasedLockingTask(BiasedLockingStartupDelay);\n-      task->enroll();\n-    } else {\n-      enable_biased_locking();\n-    }\n-  }\n-}\n-\n-\n-bool BiasedLocking::enabled() {\n-  assert(UseBiasedLocking, \"precondition\");\n-  \/\/ We check \"BiasedLockingStartupDelay == 0\" here to cover the\n-  \/\/ possibility of calls to BiasedLocking::enabled() before\n-  \/\/ BiasedLocking::init().\n-  return _biased_locking_enabled || BiasedLockingStartupDelay == 0;\n-}\n-\n-\n-\/\/ Returns MonitorInfos for all objects locked on this thread in youngest to oldest order\n-static GrowableArray<MonitorInfo*>* get_or_compute_monitor_info(JavaThread* thread) {\n-  GrowableArray<MonitorInfo*>* info = thread->cached_monitor_info();\n-  if (info != NULL) {\n-    return info;\n-  }\n-\n-  info = new GrowableArray<MonitorInfo*>();\n-\n-  \/\/ It's possible for the thread to not have any Java frames on it,\n-  \/\/ i.e., if it's the main thread and it's already returned from main()\n-  if (thread->has_last_Java_frame()) {\n-    RegisterMap rm(thread);\n-    for (javaVFrame* vf = thread->last_java_vframe(&rm); vf != NULL; vf = vf->java_sender()) {\n-      GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n-      if (monitors != NULL) {\n-        int len = monitors->length();\n-        \/\/ Walk monitors youngest to oldest\n-        for (int i = len - 1; i >= 0; i--) {\n-          MonitorInfo* mon_info = monitors->at(i);\n-          if (mon_info->eliminated()) continue;\n-          oop owner = mon_info->owner();\n-          if (owner != NULL) {\n-            info->append(mon_info);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  thread->set_cached_monitor_info(info);\n-  return info;\n-}\n-\n-\n-\/\/ After the call, *biased_locker will be set to obj->mark()->biased_locker() if biased_locker != NULL,\n-\/\/ AND it is a living thread. Otherwise it will not be updated, (i.e. the caller is responsible for initialization).\n-void BiasedLocking::single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requesting_thread, JavaThread** biased_locker) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be done at safepoint\");\n-  assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-\n-  markWord mark = obj->mark();\n-  if (!mark.has_bias_pattern()) {\n-    if (log_is_enabled(Info, biasedlocking)) {\n-      ResourceMark rm;\n-      log_info(biasedlocking)(\"  (Skipping revocation of object \" INTPTR_FORMAT\n-                              \", mark \" INTPTR_FORMAT \", type %s\"\n-                              \", requesting thread \" INTPTR_FORMAT\n-                              \" because it's no longer biased)\",\n-                              p2i((void *)obj), mark.value(),\n-                              obj->klass()->external_name(),\n-                              (intptr_t) requesting_thread);\n-    }\n-    return;\n-  }\n-\n-  uint age = mark.age();\n-  markWord unbiased_prototype = markWord::prototype().set_age(age);\n-\n-  \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-  if (!is_bulk) {\n-    ResourceMark rm;\n-    log_info(biasedlocking)(\"Revoking bias of object \" INTPTR_FORMAT \", mark \"\n-                            INTPTR_FORMAT \", type %s, prototype header \" INTPTR_FORMAT\n-                            \", requesting thread \" INTPTR_FORMAT,\n-                            p2i((void *)obj),\n-                            mark.value(),\n-                            obj->klass()->external_name(),\n-                            obj->klass()->prototype_header().value(),\n-                            (intptr_t) requesting_thread);\n-  } else {\n-    ResourceMark rm;\n-    log_trace(biasedlocking)(\"Revoking bias of object \" INTPTR_FORMAT \" , mark \"\n-                             INTPTR_FORMAT \" , type %s , prototype header \" INTPTR_FORMAT\n-                             \" , requesting thread \" INTPTR_FORMAT,\n-                             p2i((void *)obj),\n-                             mark.value(),\n-                             obj->klass()->external_name(),\n-                             obj->klass()->prototype_header().value(),\n-                             (intptr_t) requesting_thread);\n-  }\n-\n-  JavaThread* biased_thread = mark.biased_locker();\n-  if (biased_thread == NULL) {\n-    \/\/ Object is anonymously biased. We can get here if, for\n-    \/\/ example, we revoke the bias due to an identity hash code\n-    \/\/ being computed for an object.\n-    obj->set_mark(unbiased_prototype);\n-\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of anonymously-biased object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of anonymously-biased object\");\n-    }\n-    return;\n-  }\n-\n-  \/\/ Handle case where the thread toward which the object was biased has exited\n-  bool thread_is_alive = false;\n-  if (requesting_thread == biased_thread) {\n-    thread_is_alive = true;\n-  } else {\n-    ThreadsListHandle tlh;\n-    thread_is_alive = tlh.includes(biased_thread);\n-  }\n-  if (!thread_is_alive) {\n-    obj->set_mark(unbiased_prototype);\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of object biased toward dead thread (\"\n-                              PTR_FORMAT \")\", p2i(biased_thread));\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of object biased toward dead thread (\"\n-                               PTR_FORMAT \")\", p2i(biased_thread));\n-    }\n-    return;\n-  }\n-\n-  \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-  if (!is_bulk) {\n-    log_info(biasedlocking)(\"  Revoked bias of object biased toward live thread (\"\n-                            PTR_FORMAT \")\", p2i(biased_thread));\n-  } else {\n-    log_trace(biasedlocking)(\"  Revoked bias of object biased toward live thread (\"\n-                               PTR_FORMAT \")\", p2i(biased_thread));\n-  }\n-\n-  \/\/ Thread owning bias is alive.\n-  \/\/ Check to see whether it currently owns the lock and, if so,\n-  \/\/ write down the needed displaced headers to the thread's stack.\n-  \/\/ Otherwise, restore the object's header either to the unlocked\n-  \/\/ or unbiased state.\n-  GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(biased_thread);\n-  BasicLock* highest_lock = NULL;\n-  for (int i = 0; i < cached_monitor_info->length(); i++) {\n-    MonitorInfo* mon_info = cached_monitor_info->at(i);\n-    if (mon_info->owner() == obj) {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") == obj (\" PTR_FORMAT \")\",\n-                               p2i((void *) mon_info->owner()),\n-                               p2i((void *) obj));\n-      \/\/ Assume recursive case and fix up highest lock below\n-      markWord mark = markWord::encode((BasicLock*) NULL);\n-      highest_lock = mon_info->lock();\n-      highest_lock->set_displaced_header(mark);\n-    } else {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") != obj (\" PTR_FORMAT \")\",\n-                               p2i((void *) mon_info->owner()),\n-                               p2i((void *) obj));\n-    }\n-  }\n-  if (highest_lock != NULL) {\n-    \/\/ Fix up highest lock to contain displaced header and point\n-    \/\/ object at it\n-    highest_lock->set_displaced_header(unbiased_prototype);\n-    \/\/ Reset object header to point to displaced mark.\n-    \/\/ Must release store the lock address for platforms without TSO\n-    \/\/ ordering (e.g. ppc).\n-    obj->release_set_mark(markWord::encode(highest_lock));\n-    assert(!obj->mark().has_bias_pattern(), \"illegal mark state: stack lock used bias bit\");\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-    }\n-  } else {\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    }\n-    \/\/ Store the unlocked value into the object's header.\n-    obj->set_mark(unbiased_prototype);\n-  }\n-\n-  \/\/ If requested, return information on which thread held the bias\n-  if (biased_locker != NULL) {\n-    *biased_locker = biased_thread;\n-  }\n-}\n-\n-\n-enum HeuristicsResult {\n-  HR_NOT_BIASED    = 1,\n-  HR_SINGLE_REVOKE = 2,\n-  HR_BULK_REBIAS   = 3,\n-  HR_BULK_REVOKE   = 4\n-};\n-\n-\n-static HeuristicsResult update_heuristics(oop o) {\n-  markWord mark = o->mark();\n-  if (!mark.has_bias_pattern()) {\n-    return HR_NOT_BIASED;\n-  }\n-\n-  \/\/ Heuristics to attempt to throttle the number of revocations.\n-  \/\/ Stages:\n-  \/\/ 1. Revoke the biases of all objects in the heap of this type,\n-  \/\/    but allow rebiasing of those objects if unlocked.\n-  \/\/ 2. Revoke the biases of all objects in the heap of this type\n-  \/\/    and don't allow rebiasing of these objects. Disable\n-  \/\/    allocation of objects of that type with the bias bit set.\n-  Klass* k = o->klass();\n-  jlong cur_time = nanos_to_millis(os::javaTimeNanos());\n-  jlong last_bulk_revocation_time = k->last_biased_lock_bulk_revocation_time();\n-  int revocation_count = k->biased_lock_revocation_count();\n-  if ((revocation_count >= BiasedLockingBulkRebiasThreshold) &&\n-      (revocation_count <  BiasedLockingBulkRevokeThreshold) &&\n-      (last_bulk_revocation_time != 0) &&\n-      (cur_time - last_bulk_revocation_time >= BiasedLockingDecayTime)) {\n-    \/\/ This is the first revocation we've seen in a while of an\n-    \/\/ object of this type since the last time we performed a bulk\n-    \/\/ rebiasing operation. The application is allocating objects in\n-    \/\/ bulk which are biased toward a thread and then handing them\n-    \/\/ off to another thread. We can cope with this allocation\n-    \/\/ pattern via the bulk rebiasing mechanism so we reset the\n-    \/\/ klass's revocation count rather than allow it to increase\n-    \/\/ monotonically. If we see the need to perform another bulk\n-    \/\/ rebias operation later, we will, and if subsequently we see\n-    \/\/ many more revocation operations in a short period of time we\n-    \/\/ will completely disable biasing for this type.\n-    k->set_biased_lock_revocation_count(0);\n-    revocation_count = 0;\n-  }\n-\n-  \/\/ Make revocation count saturate just beyond BiasedLockingBulkRevokeThreshold\n-  if (revocation_count <= BiasedLockingBulkRevokeThreshold) {\n-    revocation_count = k->atomic_incr_biased_lock_revocation_count();\n-  }\n-\n-  if (revocation_count == BiasedLockingBulkRevokeThreshold) {\n-    return HR_BULK_REVOKE;\n-  }\n-\n-  if (revocation_count == BiasedLockingBulkRebiasThreshold) {\n-    return HR_BULK_REBIAS;\n-  }\n-\n-  return HR_SINGLE_REVOKE;\n-}\n-\n-\n-void BiasedLocking::bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requesting_thread) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be done at safepoint\");\n-  assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-\n-  log_info(biasedlocking)(\"* Beginning bulk revocation (kind == %s) because of object \"\n-                          INTPTR_FORMAT \" , mark \" INTPTR_FORMAT \" , type %s\",\n-                          (bulk_rebias ? \"rebias\" : \"revoke\"),\n-                          p2i((void *) o),\n-                          o->mark().value(),\n-                          o->klass()->external_name());\n-\n-  jlong cur_time = nanos_to_millis(os::javaTimeNanos());\n-  o->klass()->set_last_biased_lock_bulk_revocation_time(cur_time);\n-\n-  Klass* k_o = o->klass();\n-  Klass* klass = k_o;\n-\n-  {\n-    JavaThreadIteratorWithHandle jtiwh;\n-\n-    if (bulk_rebias) {\n-      \/\/ Use the epoch in the klass of the object to implicitly revoke\n-      \/\/ all biases of objects of this data type and force them to be\n-      \/\/ reacquired. However, we also need to walk the stacks of all\n-      \/\/ threads and update the headers of lightweight locked objects\n-      \/\/ with biases to have the current epoch.\n-\n-      \/\/ If the prototype header doesn't have the bias pattern, don't\n-      \/\/ try to update the epoch -- assume another VM operation came in\n-      \/\/ and reset the header to the unbiased state, which will\n-      \/\/ implicitly cause all existing biases to be revoked\n-      if (klass->prototype_header().has_bias_pattern()) {\n-        int prev_epoch = klass->prototype_header().bias_epoch();\n-        klass->set_prototype_header(klass->prototype_header().incr_bias_epoch());\n-        int cur_epoch = klass->prototype_header().bias_epoch();\n-\n-        \/\/ Now walk all threads' stacks and adjust epochs of any biased\n-        \/\/ and locked objects of this data type we encounter\n-        for (; JavaThread *thr = jtiwh.next(); ) {\n-          GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(thr);\n-          for (int i = 0; i < cached_monitor_info->length(); i++) {\n-            MonitorInfo* mon_info = cached_monitor_info->at(i);\n-            oop owner = mon_info->owner();\n-            markWord mark = owner->mark();\n-            if ((owner->klass() == k_o) && mark.has_bias_pattern()) {\n-              \/\/ We might have encountered this object already in the case of recursive locking\n-              assert(mark.bias_epoch() == prev_epoch || mark.bias_epoch() == cur_epoch, \"error in bias epoch adjustment\");\n-              owner->set_mark(mark.set_bias_epoch(cur_epoch));\n-            }\n-          }\n-        }\n-      }\n-\n-      \/\/ At this point we're done. All we have to do is potentially\n-      \/\/ adjust the header of the given object to revoke its bias.\n-      single_revoke_at_safepoint(o, true, requesting_thread, NULL);\n-    } else {\n-      if (log_is_enabled(Info, biasedlocking)) {\n-        ResourceMark rm;\n-        log_info(biasedlocking)(\"* Disabling biased locking for type %s\", klass->external_name());\n-      }\n-\n-      \/\/ Disable biased locking for this data type. Not only will this\n-      \/\/ cause future instances to not be biased, but existing biased\n-      \/\/ instances will notice that this implicitly caused their biases\n-      \/\/ to be revoked.\n-      klass->set_prototype_header(markWord::prototype());\n-\n-      \/\/ Now walk all threads' stacks and forcibly revoke the biases of\n-      \/\/ any locked and biased objects of this data type we encounter.\n-      for (; JavaThread *thr = jtiwh.next(); ) {\n-        GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(thr);\n-        for (int i = 0; i < cached_monitor_info->length(); i++) {\n-          MonitorInfo* mon_info = cached_monitor_info->at(i);\n-          oop owner = mon_info->owner();\n-          markWord mark = owner->mark();\n-          if ((owner->klass() == k_o) && mark.has_bias_pattern()) {\n-            single_revoke_at_safepoint(owner, true, requesting_thread, NULL);\n-          }\n-        }\n-      }\n-\n-      \/\/ Must force the bias of the passed object to be forcibly revoked\n-      \/\/ as well to ensure guarantees to callers\n-      single_revoke_at_safepoint(o, true, requesting_thread, NULL);\n-    }\n-  } \/\/ ThreadsListHandle is destroyed here.\n-\n-  log_info(biasedlocking)(\"* Ending bulk revocation\");\n-\n-  assert(!o->mark().has_bias_pattern(), \"bug in bulk bias revocation\");\n-}\n-\n-\n-static void clean_up_cached_monitor_info(JavaThread* thread = NULL) {\n-  if (thread != NULL) {\n-    thread->set_cached_monitor_info(NULL);\n-  } else {\n-    \/\/ Walk the thread list clearing out the cached monitors\n-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {\n-      thr->set_cached_monitor_info(NULL);\n-    }\n-  }\n-}\n-\n-\n-class VM_BulkRevokeBias : public VM_Operation {\n-private:\n-  Handle* _obj;\n-  JavaThread* _requesting_thread;\n-  bool _bulk_rebias;\n-  uint64_t _safepoint_id;\n-\n-public:\n-  VM_BulkRevokeBias(Handle* obj, JavaThread* requesting_thread,\n-                    bool bulk_rebias)\n-    : _obj(obj)\n-    , _requesting_thread(requesting_thread)\n-    , _bulk_rebias(bulk_rebias)\n-    , _safepoint_id(0) {}\n-\n-  virtual VMOp_Type type() const { return VMOp_BulkRevokeBias; }\n-\n-  virtual void doit() {\n-    BiasedLocking::bulk_revoke_at_safepoint((*_obj)(), _bulk_rebias, _requesting_thread);\n-    _safepoint_id = SafepointSynchronize::safepoint_id();\n-    clean_up_cached_monitor_info();\n-  }\n-\n-  bool is_bulk_rebias() const {\n-    return _bulk_rebias;\n-  }\n-\n-  uint64_t safepoint_id() const {\n-    return _safepoint_id;\n-  }\n-};\n-\n-\n-class RevokeOneBias : public HandshakeClosure {\n-protected:\n-  Handle _obj;\n-  JavaThread* _requesting_thread;\n-  JavaThread* _biased_locker;\n-  BiasedLocking::Condition _status_code;\n-  traceid _biased_locker_id;\n-  bool _executed;\n-\n-public:\n-  RevokeOneBias(Handle obj, JavaThread* requesting_thread, JavaThread* biased_locker)\n-    : HandshakeClosure(\"RevokeOneBias\")\n-    , _obj(obj)\n-    , _requesting_thread(requesting_thread)\n-    , _biased_locker(biased_locker)\n-    , _status_code(BiasedLocking::NOT_BIASED)\n-    , _biased_locker_id(0)\n-    , _executed(false) {}\n-\n-  bool executed() { return _executed; }\n-\n-  void do_thread(Thread* target) {\n-    assert(target == _biased_locker, \"Wrong thread\");\n-    _executed = true;\n-\n-    oop o = _obj();\n-    markWord mark = o->mark();\n-\n-    if (!mark.has_bias_pattern()) {\n-      return;\n-    }\n-\n-    markWord prototype = o->klass()->prototype_header();\n-    if (!prototype.has_bias_pattern()) {\n-      \/\/ This object has a stale bias from before the handshake\n-      \/\/ was requested. If we fail this race, the object's bias\n-      \/\/ has been revoked by another thread so we simply return.\n-      markWord biased_value = mark;\n-      mark = o->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-      assert(!o->mark().has_bias_pattern(), \"even if we raced, should still be revoked\");\n-      if (biased_value == mark) {\n-        _status_code = BiasedLocking::BIAS_REVOKED;\n-      }\n-      return;\n-    }\n-\n-    if (_biased_locker == mark.biased_locker()) {\n-      if (mark.bias_epoch() == prototype.bias_epoch()) {\n-        \/\/ Epoch is still valid. This means biaser could be currently\n-        \/\/ synchronized on this object. We must walk its stack looking\n-        \/\/ for monitor records associated with this object and change\n-        \/\/ them to be stack locks if any are found.\n-        ResourceMark rm;\n-        BiasedLocking::walk_stack_and_revoke(o, _biased_locker);\n-        _biased_locker->set_cached_monitor_info(NULL);\n-        assert(!o->mark().has_bias_pattern(), \"invariant\");\n-        _biased_locker_id = JFR_THREAD_ID(_biased_locker);\n-        _status_code = BiasedLocking::BIAS_REVOKED;\n-        return;\n-      } else {\n-        markWord biased_value = mark;\n-        mark = o->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-        if (mark == biased_value || !mark.has_bias_pattern()) {\n-          assert(!o->mark().has_bias_pattern(), \"should be revoked\");\n-          _status_code = (biased_value == mark) ? BiasedLocking::BIAS_REVOKED : BiasedLocking::NOT_BIASED;\n-          return;\n-        }\n-      }\n-    }\n-\n-    _status_code = BiasedLocking::NOT_REVOKED;\n-  }\n-\n-  BiasedLocking::Condition status_code() const {\n-    return _status_code;\n-  }\n-\n-  traceid biased_locker() const {\n-    return _biased_locker_id;\n-  }\n-};\n-\n-\n-static void post_self_revocation_event(EventBiasedLockSelfRevocation* event, Klass* k) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_lockClass(k);\n-  event->commit();\n-}\n-\n-static void post_revocation_event(EventBiasedLockRevocation* event, Klass* k, RevokeOneBias* op) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(op != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_lockClass(k);\n-  event->set_safepointId(0);\n-  event->set_previousOwner(op->biased_locker());\n-  event->commit();\n-}\n-\n-static void post_class_revocation_event(EventBiasedLockClassRevocation* event, Klass* k, VM_BulkRevokeBias* op) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(op != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_revokedClass(k);\n-  event->set_disableBiasing(!op->is_bulk_rebias());\n-  event->set_safepointId(op->safepoint_id());\n-  event->commit();\n-}\n-\n-\n-BiasedLocking::Condition BiasedLocking::single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser) {\n-\n-  EventBiasedLockRevocation event;\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(handshakes_count_addr());\n-  }\n-  log_info(biasedlocking, handshake)(\"JavaThread \" INTPTR_FORMAT \" handshaking JavaThread \"\n-                                     INTPTR_FORMAT \" to revoke object \" INTPTR_FORMAT, p2i(requester),\n-                                     p2i(biaser), p2i(obj()));\n-\n-  RevokeOneBias revoke(obj, requester, biaser);\n-  Handshake::execute(&revoke, biaser);\n-  if (revoke.status_code() == NOT_REVOKED) {\n-    return NOT_REVOKED;\n-  }\n-  if (revoke.executed()) {\n-    log_info(biasedlocking, handshake)(\"Handshake revocation for object \" INTPTR_FORMAT \" succeeded. Bias was %srevoked\",\n-                                       p2i(obj()), (revoke.status_code() == BIAS_REVOKED ? \"\" : \"already \"));\n-    if (event.should_commit() && revoke.status_code() == BIAS_REVOKED) {\n-      post_revocation_event(&event, obj->klass(), &revoke);\n-    }\n-    assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-    return revoke.status_code();\n-  } else {\n-    \/\/ Thread was not alive.\n-    \/\/ Grab Threads_lock before manually trying to revoke bias. This avoids race with a newly\n-    \/\/ created JavaThread (that happens to get the same memory address as biaser) synchronizing\n-    \/\/ on this object.\n-    {\n-      MutexLocker ml(Threads_lock);\n-      markWord mark = obj->mark();\n-      \/\/ Check if somebody else was able to revoke it before biased thread exited.\n-      if (!mark.has_bias_pattern()) {\n-        return NOT_BIASED;\n-      }\n-      ThreadsListHandle tlh;\n-      markWord prototype = obj->klass()->prototype_header();\n-      if (!prototype.has_bias_pattern() || (!tlh.includes(biaser) && biaser == mark.biased_locker() &&\n-                                            prototype.bias_epoch() == mark.bias_epoch())) {\n-        obj->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-        if (event.should_commit()) {\n-          post_revocation_event(&event, obj->klass(), &revoke);\n-        }\n-        assert(!obj->mark().has_bias_pattern(), \"bias should be revoked by now\");\n-        return BIAS_REVOKED;\n-      }\n-    }\n-  }\n-\n-  return NOT_REVOKED;\n-}\n-\n-\n-\/\/ Caller should have instantiated a ResourceMark object before calling this method\n-void BiasedLocking::walk_stack_and_revoke(oop obj, JavaThread* biased_locker) {\n-  Thread* cur = Thread::current();\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"this should always be executed outside safepoints\");\n-  assert(biased_locker->is_handshake_safe_for(cur), \"wrong thread\");\n-\n-  markWord mark = obj->mark();\n-  assert(mark.biased_locker() == biased_locker &&\n-         obj->klass()->prototype_header().bias_epoch() == mark.bias_epoch(), \"invariant\");\n-\n-  log_trace(biasedlocking)(\"JavaThread(\" INTPTR_FORMAT \") revoking object \" INTPTR_FORMAT \", mark \"\n-                           INTPTR_FORMAT \", type %s, prototype header \" INTPTR_FORMAT\n-                           \", biaser \" INTPTR_FORMAT \" %s\",\n-                           p2i(cur),\n-                           p2i(obj),\n-                           mark.value(),\n-                           obj->klass()->external_name(),\n-                           obj->klass()->prototype_header().value(),\n-                           p2i(biased_locker),\n-                           cur != biased_locker ? \"\" : \"(walking own stack)\");\n-\n-  markWord unbiased_prototype = markWord::prototype().set_age(obj->mark().age());\n-\n-  GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(biased_locker);\n-  BasicLock* highest_lock = NULL;\n-  for (int i = 0; i < cached_monitor_info->length(); i++) {\n-    MonitorInfo* mon_info = cached_monitor_info->at(i);\n-    if (mon_info->owner() == obj) {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") == obj (\" PTR_FORMAT \")\",\n-                               p2i(mon_info->owner()),\n-                               p2i(obj));\n-      \/\/ Assume recursive case and fix up highest lock below\n-      markWord mark = markWord::encode((BasicLock*) NULL);\n-      highest_lock = mon_info->lock();\n-      highest_lock->set_displaced_header(mark);\n-    } else {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") != obj (\" PTR_FORMAT \")\",\n-                               p2i(mon_info->owner()),\n-                               p2i(obj));\n-    }\n-  }\n-  if (highest_lock != NULL) {\n-    \/\/ Fix up highest lock to contain displaced header and point\n-    \/\/ object at it\n-    highest_lock->set_displaced_header(unbiased_prototype);\n-    \/\/ Reset object header to point to displaced mark.\n-    \/\/ Must release store the lock address for platforms without TSO\n-    \/\/ ordering (e.g. ppc).\n-    obj->release_set_mark(markWord::encode(highest_lock));\n-    assert(!obj->mark().has_bias_pattern(), \"illegal mark state: stack lock used bias bit\");\n-    log_info(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-  } else {\n-    log_info(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    \/\/ Store the unlocked value into the object's header.\n-    obj->set_mark(unbiased_prototype);\n-  }\n-\n-  assert(!obj->mark().has_bias_pattern(), \"must not be biased\");\n-}\n-\n-void BiasedLocking::revoke_own_lock(JavaThread* current, Handle obj) {\n-  markWord mark = obj->mark();\n-\n-  if (!mark.has_bias_pattern()) {\n-    return;\n-  }\n-\n-  Klass *k = obj->klass();\n-  assert(mark.biased_locker() == current &&\n-         k->prototype_header().bias_epoch() == mark.bias_epoch(), \"Revoke failed, unhandled biased lock state\");\n-  ResourceMark rm(current);\n-  log_info(biasedlocking)(\"Revoking bias by walking my own stack:\");\n-  EventBiasedLockSelfRevocation event;\n-  BiasedLocking::walk_stack_and_revoke(obj(), current);\n-  current->set_cached_monitor_info(NULL);\n-  assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-  if (event.should_commit()) {\n-    post_self_revocation_event(&event, k);\n-  }\n-}\n-\n-void BiasedLocking::revoke(JavaThread* current, Handle obj) {\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"must not be called while at safepoint\");\n-\n-  while (true) {\n-    \/\/ We can revoke the biases of anonymously-biased objects\n-    \/\/ efficiently enough that we should not cause these revocations to\n-    \/\/ update the heuristics because doing so may cause unwanted bulk\n-    \/\/ revocations (which are expensive) to occur.\n-    markWord mark = obj->mark();\n-\n-    if (!mark.has_bias_pattern()) {\n-      return;\n-    }\n-\n-    if (mark.is_biased_anonymously()) {\n-      \/\/ We are probably trying to revoke the bias of this object due to\n-      \/\/ an identity hash code computation. Try to revoke the bias\n-      \/\/ without a safepoint. This is possible if we can successfully\n-      \/\/ compare-and-exchange an unbiased header into the mark word of\n-      \/\/ the object, meaning that no other thread has raced to acquire\n-      \/\/ the bias of the object.\n-      markWord biased_value       = mark;\n-      markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-      markWord res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n-      if (res_mark == biased_value) {\n-        return;\n-      }\n-      mark = res_mark;  \/\/ Refresh mark with the latest value.\n-    } else {\n-      Klass* k = obj->klass();\n-      markWord prototype_header = k->prototype_header();\n-      if (!prototype_header.has_bias_pattern()) {\n-        \/\/ This object has a stale bias from before the bulk revocation\n-        \/\/ for this data type occurred. It's pointless to update the\n-        \/\/ heuristics at this point so simply update the header with a\n-        \/\/ CAS. If we fail this race, the object's bias has been revoked\n-        \/\/ by another thread so we simply return and let the caller deal\n-        \/\/ with it.\n-        obj->cas_set_mark(prototype_header.set_age(mark.age()), mark);\n-        assert(!obj->mark().has_bias_pattern(), \"even if we raced, should still be revoked\");\n-        return;\n-      } else if (prototype_header.bias_epoch() != mark.bias_epoch()) {\n-        \/\/ The epoch of this biasing has expired indicating that the\n-        \/\/ object is effectively unbiased. We can revoke the bias of this\n-        \/\/ object efficiently enough with a CAS that we shouldn't update the\n-        \/\/ heuristics. This is normally done in the assembly code but we\n-        \/\/ can reach this point due to various points in the runtime\n-        \/\/ needing to revoke biases.\n-        markWord res_mark;\n-        markWord biased_value       = mark;\n-        markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-        res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n-        if (res_mark == biased_value) {\n-          return;\n-        }\n-        mark = res_mark;  \/\/ Refresh mark with the latest value.\n-      }\n-    }\n-\n-    HeuristicsResult heuristics = update_heuristics(obj());\n-    if (heuristics == HR_NOT_BIASED) {\n-      return;\n-    } else if (heuristics == HR_SINGLE_REVOKE) {\n-      JavaThread *blt = mark.biased_locker();\n-      assert(blt != NULL, \"invariant\");\n-      if (blt == current) {\n-        \/\/ A thread is trying to revoke the bias of an object biased\n-        \/\/ toward it, again likely due to an identity hash code\n-        \/\/ computation. We can again avoid a safepoint\/handshake in this case\n-        \/\/ since we are only going to walk our own stack. There are no\n-        \/\/ races with revocations occurring in other threads because we\n-        \/\/ reach no safepoints in the revocation path.\n-        EventBiasedLockSelfRevocation event;\n-        ResourceMark rm(current);\n-        walk_stack_and_revoke(obj(), blt);\n-        blt->set_cached_monitor_info(NULL);\n-        assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-        if (event.should_commit()) {\n-          post_self_revocation_event(&event, obj->klass());\n-        }\n-        return;\n-      } else {\n-        BiasedLocking::Condition cond = single_revoke_with_handshake(obj, current, blt);\n-        if (cond != NOT_REVOKED) {\n-          return;\n-        }\n-      }\n-    } else {\n-      assert((heuristics == HR_BULK_REVOKE) ||\n-         (heuristics == HR_BULK_REBIAS), \"?\");\n-      EventBiasedLockClassRevocation event;\n-      VM_BulkRevokeBias bulk_revoke(&obj, current, (heuristics == HR_BULK_REBIAS));\n-      VMThread::execute(&bulk_revoke);\n-      if (event.should_commit()) {\n-        post_class_revocation_event(&event, obj->klass(), &bulk_revoke);\n-      }\n-      return;\n-    }\n-  }\n-}\n-\n-\/\/ All objects in objs should be locked by biaser\n-void BiasedLocking::revoke(GrowableArray<Handle>* objs, JavaThread *biaser) {\n-  bool clean_my_cache = false;\n-  for (int i = 0; i < objs->length(); i++) {\n-    oop obj = (objs->at(i))();\n-    markWord mark = obj->mark();\n-    if (mark.has_bias_pattern()) {\n-      walk_stack_and_revoke(obj, biaser);\n-      clean_my_cache = true;\n-    }\n-  }\n-  if (clean_my_cache) {\n-    clean_up_cached_monitor_info(biaser);\n-  }\n-}\n-\n-\n-void BiasedLocking::revoke_at_safepoint(Handle h_obj) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must only be called while at safepoint\");\n-  oop obj = h_obj();\n-  HeuristicsResult heuristics = update_heuristics(obj);\n-  if (heuristics == HR_SINGLE_REVOKE) {\n-    JavaThread* biased_locker = NULL;\n-    single_revoke_at_safepoint(obj, false, NULL, &biased_locker);\n-    if (biased_locker) {\n-      clean_up_cached_monitor_info(biased_locker);\n-    }\n-  } else if ((heuristics == HR_BULK_REBIAS) ||\n-             (heuristics == HR_BULK_REVOKE)) {\n-    bulk_revoke_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), NULL);\n-    clean_up_cached_monitor_info();\n-  }\n-}\n-\n-\n-void BiasedLocking::preserve_marks() {\n-  if (!UseBiasedLocking)\n-    return;\n-\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must only be called while at safepoint\");\n-\n-  assert(_preserved_oop_stack  == NULL, \"double initialization\");\n-  assert(_preserved_mark_stack == NULL, \"double initialization\");\n-\n-  \/\/ In order to reduce the number of mark words preserved during GC\n-  \/\/ due to the presence of biased locking, we reinitialize most mark\n-  \/\/ words to the class's prototype during GC -- even those which have\n-  \/\/ a currently valid bias owner. One important situation where we\n-  \/\/ must not clobber a bias is when a biased object is currently\n-  \/\/ locked. To handle this case we iterate over the currently-locked\n-  \/\/ monitors in a prepass and, if they are biased, preserve their\n-  \/\/ mark words here. This should be a relatively small set of objects\n-  \/\/ especially compared to the number of objects in the heap.\n-  _preserved_mark_stack = new (ResourceObj::C_HEAP, mtGC) GrowableArray<markWord>(10, mtGC);\n-  _preserved_oop_stack = new (ResourceObj::C_HEAP, mtGC) GrowableArray<Handle>(10, mtGC);\n-\n-  Thread* cur = Thread::current();\n-  ResourceMark rm(cur);\n-\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n-    if (thread->has_last_Java_frame()) {\n-      RegisterMap rm(thread);\n-      for (javaVFrame* vf = thread->last_java_vframe(&rm); vf != NULL; vf = vf->java_sender()) {\n-        GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n-        if (monitors != NULL) {\n-          int len = monitors->length();\n-          \/\/ Walk monitors youngest to oldest\n-          for (int i = len - 1; i >= 0; i--) {\n-            MonitorInfo* mon_info = monitors->at(i);\n-            if (mon_info->owner_is_scalar_replaced()) continue;\n-            oop owner = mon_info->owner();\n-            if (owner != NULL) {\n-              markWord mark = owner->mark();\n-              if (mark.has_bias_pattern()) {\n-                _preserved_oop_stack->push(Handle(cur, owner));\n-                _preserved_mark_stack->push(mark);\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-\n-void BiasedLocking::restore_marks() {\n-  if (!UseBiasedLocking)\n-    return;\n-\n-  assert(_preserved_oop_stack  != NULL, \"double free\");\n-  assert(_preserved_mark_stack != NULL, \"double free\");\n-\n-  int len = _preserved_oop_stack->length();\n-  for (int i = 0; i < len; i++) {\n-    Handle owner = _preserved_oop_stack->at(i);\n-    markWord mark = _preserved_mark_stack->at(i);\n-    owner->set_mark(mark);\n-  }\n-\n-  delete _preserved_oop_stack;\n-  _preserved_oop_stack = NULL;\n-  delete _preserved_mark_stack;\n-  _preserved_mark_stack = NULL;\n-}\n-\n-\n-int* BiasedLocking::total_entry_count_addr()                   { return _counters.total_entry_count_addr(); }\n-int* BiasedLocking::biased_lock_entry_count_addr()             { return _counters.biased_lock_entry_count_addr(); }\n-int* BiasedLocking::anonymously_biased_lock_entry_count_addr() { return _counters.anonymously_biased_lock_entry_count_addr(); }\n-int* BiasedLocking::rebiased_lock_entry_count_addr()           { return _counters.rebiased_lock_entry_count_addr(); }\n-int* BiasedLocking::revoked_lock_entry_count_addr()            { return _counters.revoked_lock_entry_count_addr(); }\n-int* BiasedLocking::handshakes_count_addr()                    { return _counters.handshakes_count_addr(); }\n-int* BiasedLocking::fast_path_entry_count_addr()               { return _counters.fast_path_entry_count_addr(); }\n-int* BiasedLocking::slow_path_entry_count_addr()               { return _counters.slow_path_entry_count_addr(); }\n-\n-\n-\/\/ BiasedLockingCounters\n-\n-int BiasedLockingCounters::slow_path_entry_count() const {\n-  if (_slow_path_entry_count != 0) {\n-    return _slow_path_entry_count;\n-  }\n-  int sum = _biased_lock_entry_count   + _anonymously_biased_lock_entry_count +\n-            _rebiased_lock_entry_count + _revoked_lock_entry_count +\n-            _fast_path_entry_count;\n-\n-  return _total_entry_count - sum;\n-}\n-\n-void BiasedLockingCounters::print_on(outputStream* st) const {\n-  tty->print_cr(\"# total entries: %d\", _total_entry_count);\n-  tty->print_cr(\"# biased lock entries: %d\", _biased_lock_entry_count);\n-  tty->print_cr(\"# anonymously biased lock entries: %d\", _anonymously_biased_lock_entry_count);\n-  tty->print_cr(\"# rebiased lock entries: %d\", _rebiased_lock_entry_count);\n-  tty->print_cr(\"# revoked lock entries: %d\", _revoked_lock_entry_count);\n-  tty->print_cr(\"# handshakes entries: %d\", _handshakes_count);\n-  tty->print_cr(\"# fast path lock entries: %d\", _fast_path_entry_count);\n-  tty->print_cr(\"# slow path lock entries: %d\", slow_path_entry_count());\n-}\n-\n-void BiasedLockingCounters::print() const { print_on(tty); }\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":0,"deletions":995,"binary":false,"changes":995,"status":"deleted"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_BIASEDLOCKING_HPP\n-#define SHARE_RUNTIME_BIASEDLOCKING_HPP\n-\n-#include \"runtime\/handles.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-\/\/ This class describes operations to implement Store-Free Biased\n-\/\/ Locking. The high-level properties of the scheme are similar to\n-\/\/ IBM's lock reservation, Dice-Moir-Scherer QR locks, and other biased\n-\/\/ locking mechanisms. The principal difference is in the handling of\n-\/\/ recursive locking which is how this technique achieves a more\n-\/\/ efficient fast path than these other schemes.\n-\/\/\n-\/\/ The basic observation is that in HotSpot's current fast locking\n-\/\/ scheme, recursive locking (in the fast path) causes no update to\n-\/\/ the object header. The recursion is described simply by stack\n-\/\/ records containing a specific value (NULL). Only the last unlock by\n-\/\/ a given thread causes an update to the object header.\n-\/\/\n-\/\/ This observation, coupled with the fact that HotSpot only compiles\n-\/\/ methods for which monitor matching is obeyed (and which therefore\n-\/\/ can not throw IllegalMonitorStateException), implies that we can\n-\/\/ completely eliminate modifications to the object header for\n-\/\/ recursive locking in compiled code, and perform similar recursion\n-\/\/ checks and throwing of IllegalMonitorStateException in the\n-\/\/ interpreter with little or no impact on the performance of the fast\n-\/\/ path.\n-\/\/\n-\/\/ The basic algorithm is as follows (note, see below for more details\n-\/\/ and information). A pattern in the low three bits is reserved in\n-\/\/ the object header to indicate whether biasing of a given object's\n-\/\/ lock is currently being done or is allowed at all.  If the bias\n-\/\/ pattern is present, the contents of the rest of the header are\n-\/\/ either the JavaThread* of the thread to which the lock is biased,\n-\/\/ or NULL, indicating that the lock is \"anonymously biased\". The\n-\/\/ first thread which locks an anonymously biased object biases the\n-\/\/ lock toward that thread. If another thread subsequently attempts to\n-\/\/ lock the same object, the bias is revoked.\n-\/\/\n-\/\/ Because there are no updates to the object header at all during\n-\/\/ recursive locking while the lock is biased, the biased lock entry\n-\/\/ code is simply a test of the object header's value. If this test\n-\/\/ succeeds, the lock has been acquired by the thread. If this test\n-\/\/ fails, a bit test is done to see whether the bias bit is still\n-\/\/ set. If not, we fall back to HotSpot's original CAS-based locking\n-\/\/ scheme. If it is set, we attempt to CAS in a bias toward this\n-\/\/ thread. The latter operation is expected to be the rarest operation\n-\/\/ performed on these locks. We optimistically expect the biased lock\n-\/\/ entry to hit most of the time, and want the CAS-based fallthrough\n-\/\/ to occur quickly in the situations where the bias has been revoked.\n-\/\/\n-\/\/ Revocation of the lock's bias is fairly straightforward. We want to\n-\/\/ restore the object's header and stack-based BasicObjectLocks and\n-\/\/ BasicLocks to the state they would have been in had the object been\n-\/\/ locked by HotSpot's usual fast locking scheme. To do this, we execute\n-\/\/ a handshake with the JavaThread that biased the lock. Inside the\n-\/\/ handshake we walk the biaser stack searching for all of the lock\n-\/\/ records corresponding to this object, in particular the first \/ \"highest\"\n-\/\/ record. We fill in the highest lock record with the object's displaced\n-\/\/ header (which is a well-known value given that we don't maintain an\n-\/\/ identity hash nor age bits for the object while it's in the biased\n-\/\/ state) and all other lock records with 0, the value for recursive locks.\n-\/\/ Alternatively, we can revoke the bias of an object inside a safepoint\n-\/\/ if we are already in one and we detect that we need to perform a\n-\/\/ revocation.\n-\/\/\n-\/\/ This scheme can not handle transfers of biases of single objects\n-\/\/ from thread to thread efficiently, but it can handle bulk transfers\n-\/\/ of such biases, which is a usage pattern showing up in some\n-\/\/ applications and benchmarks. We implement \"bulk rebias\" and \"bulk\n-\/\/ revoke\" operations using a \"bias epoch\" on a per-data-type basis.\n-\/\/ If too many bias revocations are occurring for a particular data\n-\/\/ type, the bias epoch for the data type is incremented at a\n-\/\/ safepoint, effectively meaning that all previous biases are\n-\/\/ invalid. The fast path locking case checks for an invalid epoch in\n-\/\/ the object header and attempts to rebias the object with a CAS if\n-\/\/ found, avoiding safepoints or bulk heap sweeps (the latter which\n-\/\/ was used in a prior version of this algorithm and did not scale\n-\/\/ well). If too many bias revocations persist, biasing is completely\n-\/\/ disabled for the data type by resetting the prototype header to the\n-\/\/ unbiased markWord. The fast-path locking code checks to see whether\n-\/\/ the instance's bias pattern differs from the prototype header's and\n-\/\/ causes the bias to be revoked without reaching a safepoint or,\n-\/\/ again, a bulk heap sweep.\n-\n-\/\/ Biased locking counters\n-class BiasedLockingCounters {\n- private:\n-  int _total_entry_count;\n-  int _biased_lock_entry_count;\n-  int _anonymously_biased_lock_entry_count;\n-  int _rebiased_lock_entry_count;\n-  int _revoked_lock_entry_count;\n-  int _handshakes_count;\n-  int _fast_path_entry_count;\n-  int _slow_path_entry_count;\n-\n- public:\n-  BiasedLockingCounters() :\n-    _total_entry_count(0),\n-    _biased_lock_entry_count(0),\n-    _anonymously_biased_lock_entry_count(0),\n-    _rebiased_lock_entry_count(0),\n-    _revoked_lock_entry_count(0),\n-    _handshakes_count(0),\n-    _fast_path_entry_count(0),\n-    _slow_path_entry_count(0) {}\n-\n-  int slow_path_entry_count() const; \/\/ Compute this field if necessary\n-\n-  int* total_entry_count_addr()                   { return &_total_entry_count; }\n-  int* biased_lock_entry_count_addr()             { return &_biased_lock_entry_count; }\n-  int* anonymously_biased_lock_entry_count_addr() { return &_anonymously_biased_lock_entry_count; }\n-  int* rebiased_lock_entry_count_addr()           { return &_rebiased_lock_entry_count; }\n-  int* revoked_lock_entry_count_addr()            { return &_revoked_lock_entry_count; }\n-  int* handshakes_count_addr()                    { return &_handshakes_count; }\n-  int* fast_path_entry_count_addr()               { return &_fast_path_entry_count; }\n-  int* slow_path_entry_count_addr()               { return &_slow_path_entry_count; }\n-\n-  bool nonzero() { return _total_entry_count > 0; }\n-\n-  void print_on(outputStream* st) const;\n-  void print() const;\n-};\n-\n-\n-class BiasedLocking : AllStatic {\n-friend class VM_BulkRevokeBias;\n-friend class RevokeOneBias;\n-\n-private:\n-  static BiasedLockingCounters _counters;\n-\n-public:\n-  static int* total_entry_count_addr();\n-  static int* biased_lock_entry_count_addr();\n-  static int* anonymously_biased_lock_entry_count_addr();\n-  static int* rebiased_lock_entry_count_addr();\n-  static int* revoked_lock_entry_count_addr();\n-  static int* handshakes_count_addr();\n-  static int* fast_path_entry_count_addr();\n-  static int* slow_path_entry_count_addr();\n-\n-  enum Condition {\n-    NOT_BIASED = 1,\n-    BIAS_REVOKED = 2,\n-    NOT_REVOKED = 3\n-  };\n-\n-private:\n-  static void single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requester, JavaThread** biaser);\n-  static void bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requester);\n-  static Condition single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser);\n-  static void walk_stack_and_revoke(oop obj, JavaThread* biased_locker);\n-\n-public:\n-  \/\/ This initialization routine should only be called once and\n-  \/\/ schedules a PeriodicTask to turn on biased locking a few seconds\n-  \/\/ into the VM run to avoid startup time regressions\n-  static void init();\n-\n-  \/\/ This provides a global switch for leaving biased locking disabled\n-  \/\/ for the first part of a run and enabling it later\n-  static bool enabled();\n-\n-  \/\/ This should be called by JavaThreads to revoke the bias of an object\n-  static void revoke(JavaThread* current, Handle obj);\n-\n-  \/\/ This must only be called by a JavaThread to revoke the bias of an owned object.\n-  static void revoke_own_lock(JavaThread* current, Handle obj);\n-\n-  static void revoke_at_safepoint(Handle obj);\n-\n-  \/\/ These are used by deoptimization to ensure that monitors on the stack\n-  \/\/ can be migrated\n-  static void revoke(GrowableArray<Handle>* objs, JavaThread *biaser);\n-\n-  static void print_counters() { _counters.print(); }\n-  static BiasedLockingCounters* counters() { return &_counters; }\n-\n-  \/\/ These routines are GC-related and should not be called by end\n-  \/\/ users. GCs which do not do preservation of mark words do not need\n-  \/\/ to call these routines.\n-  static void preserve_marks();\n-  static void restore_marks();\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_BIASEDLOCKING_HPP\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.hpp","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -59,1 +59,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -314,3 +313,0 @@\n-  \/\/ Revoke biases of objects with eliminated locks in the given frame.\n-  Deoptimization::revoke_for_object_deoptimization(deoptee_thread, deoptee, &map, thread);\n-\n@@ -386,4 +382,0 @@\n-  \/\/ Revoke biases, done with in java state.\n-  \/\/ No safepoints allowed after this\n-  revoke_from_deopt_handler(current, deoptee, &map);\n-\n@@ -872,1 +864,1 @@\n-    JavaThread* jt = thread->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(thread);\n@@ -1445,10 +1437,1 @@\n-        if (UseBiasedLocking && mark.has_bias_pattern()) {\n-          \/\/ New allocated objects may have the mark set to anonymously biased.\n-          \/\/ Also the deoptimized method may called methods with synchronization\n-          \/\/ where the thread-local object is bias locked to the current thread.\n-          assert(mark.is_biased_anonymously() ||\n-                 mark.biased_locker() == deoptee_thread, \"should be locked to current thread\");\n-          \/\/ Reset mark word to unbiased prototype.\n-          markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-          obj->set_mark(unbiased_prototype);\n-        } else if (exec_mode == Unpack_none) {\n+        if (exec_mode == Unpack_none) {\n@@ -1457,2 +1440,1 @@\n-            \/\/ a callee frame. In this case the bias was revoked before in revoke_for_object_deoptimization().\n-            \/\/ Make the lock in the callee a recursive lock and restore the displaced header.\n+            \/\/ a callee frame. Make the lock in the callee a recursive lock and restore the displaced header.\n@@ -1598,92 +1580,0 @@\n-static void collect_monitors(compiledVFrame* cvf, GrowableArray<Handle>* objects_to_revoke,\n-                             bool only_eliminated) {\n-  GrowableArray<MonitorInfo*>* monitors = cvf->monitors();\n-  Thread* thread = Thread::current();\n-  for (int i = 0; i < monitors->length(); i++) {\n-    MonitorInfo* mon_info = monitors->at(i);\n-    if (mon_info->eliminated() == only_eliminated &&\n-        !mon_info->owner_is_scalar_replaced() &&\n-        mon_info->owner() != NULL) {\n-      objects_to_revoke->append(Handle(thread, mon_info->owner()));\n-    }\n-  }\n-}\n-\n-static void get_monitors_from_stack(GrowableArray<Handle>* objects_to_revoke, JavaThread* thread,\n-                                    frame fr, RegisterMap* map, bool only_eliminated) {\n-  \/\/ Unfortunately we don't have a RegisterMap available in most of\n-  \/\/ the places we want to call this routine so we need to walk the\n-  \/\/ stack again to update the register map.\n-  if (map == NULL || !map->update_map()) {\n-    StackFrameStream sfs(thread, true \/* update *\/, true \/* process_frames *\/);\n-    bool found = false;\n-    while (!found && !sfs.is_done()) {\n-      frame* cur = sfs.current();\n-      sfs.next();\n-      found = cur->id() == fr.id();\n-    }\n-    assert(found, \"frame to be deoptimized not found on target thread's stack\");\n-    map = sfs.register_map();\n-  }\n-\n-  vframe* vf = vframe::new_vframe(&fr, map, thread);\n-  compiledVFrame* cvf = compiledVFrame::cast(vf);\n-  \/\/ Revoke monitors' biases in all scopes\n-  while (!cvf->is_top()) {\n-    collect_monitors(cvf, objects_to_revoke, only_eliminated);\n-    cvf = compiledVFrame::cast(cvf->sender());\n-  }\n-  collect_monitors(cvf, objects_to_revoke, only_eliminated);\n-}\n-\n-void Deoptimization::revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map) {\n-  if (!UseBiasedLocking) {\n-    return;\n-  }\n-  assert(thread == Thread::current(), \"should be\");\n-  ResourceMark rm(thread);\n-  HandleMark hm(thread);\n-  GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-  get_monitors_from_stack(objects_to_revoke, thread, fr, map, false);\n-\n-  int len = objects_to_revoke->length();\n-  for (int i = 0; i < len; i++) {\n-    oop obj = (objects_to_revoke->at(i))();\n-    BiasedLocking::revoke_own_lock(thread, objects_to_revoke->at(i));\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-}\n-\n-\/\/ Revoke the bias of objects with eliminated locking to prepare subsequent relocking.\n-void Deoptimization::revoke_for_object_deoptimization(JavaThread* deoptee_thread, frame fr,\n-                                                      RegisterMap* map, JavaThread* thread) {\n-  if (!UseBiasedLocking) {\n-    return;\n-  }\n-  GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-  assert(KeepStackGCProcessedMark::stack_is_kept_gc_processed(deoptee_thread), \"must be\");\n-  \/\/ Collect monitors but only those with eliminated locking.\n-  get_monitors_from_stack(objects_to_revoke, deoptee_thread, fr, map, true);\n-\n-  int len = objects_to_revoke->length();\n-  for (int i = 0; i < len; i++) {\n-    oop obj = (objects_to_revoke->at(i))();\n-    markWord mark = obj->mark();\n-    if (!mark.has_bias_pattern() ||\n-        mark.is_biased_anonymously() || \/\/ eliminated locking does not bias an object if it wasn't before\n-        !obj->klass()->prototype_header().has_bias_pattern() || \/\/ bulk revoke ignores eliminated monitors\n-        (obj->klass()->prototype_header().bias_epoch() != mark.bias_epoch())) { \/\/ bulk rebias ignores eliminated monitors\n-      \/\/ We reach here regularly if there's just eliminated locking on obj.\n-      \/\/ We must not call BiasedLocking::revoke_own_lock() in this case, as we\n-      \/\/ would hit assertions because it is a prerequisite that there has to be\n-      \/\/ non-eliminated locking on obj by deoptee_thread.\n-      \/\/ Luckily we don't have to revoke here because obj has to be a\n-      \/\/ non-escaping obj and can be relocked without revoking the bias. See\n-      \/\/ Deoptimization::relock_objects().\n-      continue;\n-    }\n-    BiasedLocking::revoke(thread, objects_to_revoke->at(i));\n-    assert(!objects_to_revoke->at(i)->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-}\n-\n@@ -1926,1 +1816,0 @@\n-  \/\/ We need to update the map if we have biased locking.\n@@ -1931,1 +1820,1 @@\n-  RegisterMap reg_map(current, UseBiasedLocking);\n+  RegisterMap reg_map(current, false);\n@@ -1960,1 +1849,3 @@\n-    if (TraceDeoptimization) {\n+    bool is_receiver_constraint_failure = COMPILER2_PRESENT(VerifyReceiverTypes &&) (reason == Deoptimization::Reason_receiver_constraint);\n+\n+    if (TraceDeoptimization || is_receiver_constraint_failure) {\n@@ -2019,1 +1910,1 @@\n-    if (TraceDeoptimization || LogCompilation) {\n+    if (TraceDeoptimization || LogCompilation || is_receiver_constraint_failure) {\n@@ -2112,0 +2003,4 @@\n+    if (is_receiver_constraint_failure) {\n+      fatal(\"missing receiver type check\");\n+    }\n+\n@@ -2601,0 +2496,1 @@\n+  \"receiver_constraint\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":13,"deletions":117,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+    Reason_receiver_constraint,   \/\/ receiver subtype check failed\n@@ -154,7 +155,0 @@\n- private:\n-  \/\/ Revoke biased locks at deopt.\n-  static void revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map);\n-\n-  static void revoke_for_object_deoptimization(JavaThread* deoptee_thread, frame fr,\n-                                               RegisterMap* map, JavaThread* thread);\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -68,56 +68,0 @@\n-JVMFlag::Error BiasedLockingBulkRebiasThresholdFunc(intx value, bool verbose) {\n-  if (value > BiasedLockingBulkRevokeThreshold) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \")\\n\",\n-                        value, BiasedLockingBulkRevokeThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingStartupDelayFunc(intx value, bool verbose) {\n-  if ((value % PeriodicTask::interval_gran) != 0) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingStartupDelay (\" INTX_FORMAT \") must be \"\n-                        \"evenly divisible by PeriodicTask::interval_gran (%d)\\n\",\n-                        value, PeriodicTask::interval_gran);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingBulkRevokeThresholdFunc(intx value, bool verbose) {\n-  if (value < BiasedLockingBulkRebiasThreshold) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \")\\n\",\n-                        value, BiasedLockingBulkRebiasThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else if ((double)value\/(double)BiasedLockingDecayTime > 0.1) {\n-    JVMFlag::printError(verbose,\n-                        \"The ratio of BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \")\"\n-                        \" to BiasedLockingDecayTime (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to 0.1\\n\",\n-                        value, BiasedLockingBulkRebiasThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingDecayTimeFunc(intx value, bool verbose) {\n-  if (BiasedLockingBulkRebiasThreshold\/(double)value > 0.1) {\n-    JVMFlag::printError(verbose,\n-                        \"The ratio of BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \")\"\n-                        \" to BiasedLockingDecayTime (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to 0.1\\n\",\n-                        BiasedLockingBulkRebiasThreshold, value);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":0,"deletions":56,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,4 +39,0 @@\n-  f(intx,   BiasedLockingBulkRebiasThresholdFunc)     \\\n-  f(intx,   BiasedLockingStartupDelayFunc)            \\\n-  f(intx,   BiasedLockingBulkRevokeThresholdFunc)     \\\n-  f(intx,   BiasedLockingDecayTimeFunc)               \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -264,2 +264,1 @@\n-  \/\/ native methods so that biased locking can revoke the receiver's\n-  \/\/ bias if necessary.  This is also used by JVMTI's GetLocalInstance method\n+  \/\/ native methods. Used by JVMTI's GetLocalInstance method\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+      \/\/ Optimized entry frames are only present on certain platforms\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -797,31 +797,0 @@\n-  product(bool, UseBiasedLocking, false,                                    \\\n-          \"(Deprecated) Enable biased locking in JVM\")                      \\\n-                                                                            \\\n-  product(intx, BiasedLockingStartupDelay, 0,                               \\\n-          \"(Deprecated) Number of milliseconds to wait before enabling \"    \\\n-          \"biased locking\")                                                 \\\n-          range(0, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) \\\n-          constraint(BiasedLockingStartupDelayFunc,AfterErgo)               \\\n-                                                                            \\\n-  product(bool, PrintBiasedLockingStatistics, false, DIAGNOSTIC,            \\\n-          \"(Deprecated) Print statistics of biased locking in JVM\")         \\\n-                                                                            \\\n-  product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \\\n-          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n-          \"try to rebias all objects in the heap of that type\")             \\\n-          range(0, max_intx)                                                \\\n-          constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \\\n-                                                                            \\\n-  product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \\\n-          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n-          \"permanently revoke biases of all objects in the heap of that \"   \\\n-          \"type\")                                                           \\\n-          range(0, max_intx)                                                \\\n-          constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)        \\\n-                                                                            \\\n-  product(intx, BiasedLockingDecayTime, 25000,                              \\\n-          \"(Deprecated) Decay time (in milliseconds) to re-enable bulk \"    \\\n-          \"rebiasing of a type after previous bulk rebias\")                 \\\n-          range(500, max_intx)                                              \\\n-          constraint(BiasedLockingDecayTimeFunc,AfterErgo)                  \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-        wait_blocked(self->as_Java_thread(), now);\n+        wait_blocked(JavaThread::cast(self), now);\n@@ -303,1 +303,1 @@\n-    StackWatermarkSet::start_processing(_requester->as_Java_thread(), StackWatermarkKind::gc);\n+    StackWatermarkSet::start_processing(JavaThread::cast(_requester), StackWatermarkKind::gc);\n@@ -620,1 +620,1 @@\n-    JavaThread* current = thr->as_Java_thread();\n+    JavaThread* current = JavaThread::cast(thr);\n@@ -663,1 +663,1 @@\n-    JavaThread* target = thr->as_Java_thread();\n+    JavaThread* target = JavaThread::cast(thr);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  JavaThread *current_thread = thread->as_Java_thread();\n+  JavaThread *current_thread = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-      JavaThread* t2 = t->as_Java_thread();\n+      JavaThread* t2 = JavaThread::cast(t);\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -250,1 +249,1 @@\n-  if (PrintLockStatistics || PrintPreciseBiasedLockingStatistics || PrintPreciseRTMLockingStatistics) {\n+  if (PrintLockStatistics || PrintPreciseRTMLockingStatistics) {\n@@ -336,4 +335,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    BiasedLocking::print_counters();\n-  }\n-\n@@ -378,1 +373,1 @@\n-  if (PrintPreciseBiasedLockingStatistics || PrintPreciseRTMLockingStatistics) {\n+  if (PrintPreciseRTMLockingStatistics) {\n@@ -382,3 +377,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    BiasedLocking::print_counters();\n-  }\n@@ -564,1 +556,1 @@\n-      thread->as_Java_thread()->set_thread_state(_thread_in_vm);\n+      JavaThread::cast(thread)->set_thread_state(_thread_in_vm);\n@@ -612,1 +604,1 @@\n-      JavaThread* jt = thread->as_Java_thread();\n+      JavaThread* jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-           is_frame_handle(thread->as_Java_thread(), handle))) {\n+           is_frame_handle(JavaThread::cast(thread), handle))) {\n@@ -305,1 +305,1 @@\n-          thread->as_Java_thread()->thread_state() == _thread_in_native);\n+          JavaThread::cast(thread)->thread_state() == _thread_in_native);\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    thread->as_Java_thread()->check_for_valid_safepoint_state();\n+    JavaThread::cast(thread)->check_for_valid_safepoint_state();\n@@ -88,1 +88,1 @@\n-      { ThreadBlockInVM tbivmdc(self->as_Java_thread(), &in_flight_mutex);\n+      { ThreadBlockInVM tbivmdc(JavaThread::cast(self), &in_flight_mutex);\n@@ -443,1 +443,1 @@\n-      new_owner->as_Java_thread()->inc_no_safepoint_count();\n+      JavaThread::cast(new_owner)->inc_no_safepoint_count();\n@@ -480,1 +480,1 @@\n-      old_owner->as_Java_thread()->dec_no_safepoint_count();\n+      JavaThread::cast(old_owner)->dec_no_safepoint_count();\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,2 +73,4 @@\n-\/\/ Name support for threads.  non-JavaThread subclasses with multiple\n-\/\/ uniquely named instances should derive from this.\n+\/\/ A base class for non-JavaThread subclasses with multiple\n+\/\/ uniquely named instances. NamedThreads also provide a common\n+\/\/ location to store GC information needed by GC threads\n+\/\/ and the VMThread.\n@@ -92,1 +94,2 @@\n-  virtual char* name() const { return _name == NULL ? (char*)\"Unknown Thread\" : _name; }\n+  virtual const char* name() const { return _name == NULL ? \"Unknown Thread\" : _name; }\n+  virtual const char* type_name() const { return \"NamedThread\"; }\n@@ -120,0 +123,4 @@\n+\n+  \/\/ Printing\n+  virtual const char* type_name() const { return \"WorkerThread\"; }\n+\n@@ -135,0 +142,1 @@\n+\n@@ -151,1 +159,2 @@\n-  char* name() const { return (char*)\"VM Periodic Task Thread\"; }\n+  const char* name() const { return \"VM Periodic Task Thread\"; }\n+  const char* type_name() const { return \"WatcherThread\"; }\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n@@ -488,1 +488,1 @@\n-    event.set_previousOwner((uintptr_t)_previous_owner_tid);\n+    event.set_previousOwner(_previous_owner_tid);\n@@ -548,1 +548,1 @@\n-    _contentions = -max_jint;\n+    _contentions = INT_MIN; \/\/ minimum negative int\n@@ -575,1 +575,1 @@\n-    if (Atomic::cmpxchg(&_contentions, (jint)0, -max_jint) != 0) {\n+    if (Atomic::cmpxchg(&_contentions, 0, INT_MIN) != 0) {\n@@ -1434,1 +1434,1 @@\n-                                    jlong notifier_tid,\n+                                    uint64_t notifier_tid,\n@@ -2246,1 +2246,1 @@\n-  st->print_cr(\"  _previous_owner_tid = \" JLONG_FORMAT, _previous_owner_tid);\n+  st->print_cr(\"  _previous_owner_tid = \" UINT64_FORMAT, _previous_owner_tid);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  jlong         _notifier_tid;\n+  uint64_t      _notifier_tid;\n@@ -151,1 +151,1 @@\n-  volatile jlong _previous_owner_tid;  \/\/ thread id of the previous owner of the monitor\n+  volatile uint64_t _previous_owner_tid;  \/\/ thread id of the previous owner of the monitor\n@@ -157,1 +157,1 @@\n-                        sizeof(volatile jlong));\n+                        sizeof(volatile uint64_t));\n@@ -171,1 +171,1 @@\n-  jint  _contentions;               \/\/ Number of active contentions in enter(). It is used by is_busy()\n+  int _contentions;                 \/\/ Number of active contentions in enter(). It is used by is_busy()\n@@ -177,1 +177,1 @@\n-  volatile jint  _waiters;          \/\/ number of waiting threads\n+  volatile int  _waiters;           \/\/ number of waiting threads\n@@ -241,3 +241,4 @@\n-    intptr_t ret_code = _waiters | intptr_t(_cxq) | intptr_t(_EntryList);\n-    if (contentions() > 0) {\n-      ret_code |= contentions();\n+    intptr_t ret_code = intptr_t(_waiters) | intptr_t(_cxq) | intptr_t(_EntryList);\n+    int cnts = contentions(); \/\/ read once\n+    if (cnts > 0) {\n+      ret_code |= intptr_t(cnts);\n@@ -284,1 +285,1 @@\n-  jint      waiters() const;\n+  int       waiters() const;\n@@ -286,2 +287,2 @@\n-  jint      contentions() const;\n-  void      add_to_contentions(jint value);\n+  int       contentions() const;\n+  void      add_to_contentions(int value);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-inline jint ObjectMonitor::waiters() const {\n+inline int ObjectMonitor::waiters() const {\n@@ -82,1 +82,1 @@\n-inline jint ObjectMonitor::contentions() const {\n+inline int ObjectMonitor::contentions() const {\n@@ -87,1 +87,1 @@\n-inline void ObjectMonitor::add_to_contentions(jint value) {\n+inline void ObjectMonitor::add_to_contentions(int value) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-        VM_PrintThreads op;\n+        VM_PrintThreads op(tty, PrintConcurrentLocks, false \/* no extended info *\/, true \/* print JNI handle info *\/);\n@@ -404,2 +404,0 @@\n-        VM_PrintJNI jni_op;\n-        VMThread::execute(&jni_op);\n@@ -1472,1 +1470,1 @@\n-  address limit = thread->as_Java_thread()->stack_end() +\n+  address limit = JavaThread::cast(thread)->stack_end() +\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -513,1 +513,1 @@\n-      StackWatermarkSet::start_processing(thread->as_Java_thread(), StackWatermarkKind::gc);\n+      StackWatermarkSet::start_processing(JavaThread::cast(thread), StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    _thread->as_Java_thread()->inc_no_safepoint_count();\n+    JavaThread::cast(_thread)->inc_no_safepoint_count();\n@@ -42,1 +42,1 @@\n-    _thread->as_Java_thread()->dec_no_safepoint_count();\n+    JavaThread::cast(_thread)->dec_no_safepoint_count();\n@@ -50,1 +50,1 @@\n-    _nsv->_thread->as_Java_thread()->dec_no_safepoint_count();\n+    JavaThread::cast(_nsv->_thread)->dec_no_safepoint_count();\n@@ -56,1 +56,1 @@\n-    _nsv->_thread->as_Java_thread()->inc_no_safepoint_count();\n+    JavaThread::cast(_nsv->_thread)->inc_no_safepoint_count();\n","filename":"src\/hotspot\/share\/runtime\/safepointVerifiers.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -144,1 +143,0 @@\n-int SharedRuntime::_throw_null_ctr = 0;\n@@ -159,1 +157,0 @@\n-int SharedRuntime::_multi1_ctr=0;\n@@ -995,1 +992,1 @@\n-      oop obj = thread->as_Java_thread()->threadObj();\n+      oop obj = JavaThread::cast(thread)->threadObj();\n@@ -2121,3 +2118,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());\n-  }\n@@ -2161,2 +2155,0 @@\n-  if (_throw_null_ctr) tty->print_cr(\"%5d implicit null throw\", _throw_null_ctr);\n-\n@@ -2168,1 +2160,0 @@\n-  if (_multi1_ctr) tty->print_cr(\"%5d multianewarray 1 dim\", _multi1_ctr);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -537,1 +537,0 @@\n-  static int _throw_null_ctr;                    \/\/ throwing a null-pointer exception\n@@ -558,1 +557,1 @@\n-  static int _multi1_ctr, _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n+  static int _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    JavaThread* jt = thread->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,1 @@\n-      thread->as_Java_thread()->nmethods_do(_cl);\n+      JavaThread::cast(thread)->nmethods_do(_cl);\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -130,1 +129,1 @@\n-      ObjectSynchronizer::chk_for_block_req(current->as_Java_thread(), \"unlinking\",\n+      ObjectSynchronizer::chk_for_block_req(JavaThread::cast(current), \"unlinking\",\n@@ -303,1 +302,1 @@\n-  \/\/ biased locking and any other IMS exception states take the slow-path\n+  \/\/ other IMS exception states take the slow-path\n@@ -352,2 +351,1 @@\n-    \/\/ Biased Locking in the object's header, the second check is for\n-    \/\/ stack-locking in the object's header, the third check is for\n+    \/\/ stack-locking in the object's header, the second check is for\n@@ -367,1 +365,0 @@\n-  \/\/ -- perform bias revocation, or\n@@ -434,4 +431,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-  }\n-\n@@ -439,2 +432,0 @@\n-  assert(!mark.has_bias_pattern(), \"should not see bias pattern here\");\n-\n@@ -475,3 +466,0 @@\n-  \/\/ We cannot check for Biased Locking if we are racing an inflation.\n-  assert(mark == markWord::INFLATING() ||\n-         !mark.has_bias_pattern(), \"should not see bias pattern here\");\n@@ -538,5 +526,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -552,5 +535,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -578,4 +556,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -598,6 +572,0 @@\n-  if (UseBiasedLocking) {\n-    Handle h_obj(current, obj);\n-    BiasedLocking::revoke(current, h_obj);\n-    obj = h_obj();\n-  }\n-  assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -641,4 +609,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -667,4 +631,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -680,4 +640,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -699,4 +655,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -849,19 +801,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ NOTE: many places throughout the JVM do not expect a safepoint\n-    \/\/ to be taken here. However, we only ever bias Java instances and all\n-    \/\/ of the call sites of identity_hash that might revoke biases have\n-    \/\/ been checked to make sure they can handle a safepoint. The\n-    \/\/ added check of the bias pattern is to avoid useless calls to\n-    \/\/ thread-local storage.\n-    if (obj->mark().has_bias_pattern()) {\n-      \/\/ Handle for oop obj in case of STW safepoint\n-      Handle hobj(current, obj);\n-      if (SafepointSynchronize::is_at_safepoint()) {\n-        BiasedLocking::revoke_at_safepoint(hobj);\n-      } else {\n-        BiasedLocking::revoke(current->as_Java_thread(), hobj);\n-      }\n-      obj = hobj();\n-      assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-    }\n-  }\n@@ -875,3 +808,0 @@\n-    \/\/ object should remain ineligible for biased locking\n-    assert(!mark.has_bias_pattern(), \"invariant\");\n-\n@@ -988,5 +918,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, h_obj);\n-    assert(!h_obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -1016,9 +941,0 @@\n-  if (UseBiasedLocking) {\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      BiasedLocking::revoke_at_safepoint(h_obj);\n-    } else {\n-      BiasedLocking::revoke(JavaThread::current(), h_obj);\n-    }\n-    assert(!h_obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -1205,1 +1121,0 @@\n-    assert(!mark.has_bias_pattern(), \"invariant\");\n@@ -1212,1 +1127,0 @@\n-    \/\/ *  BIASED       - Illegal.  We should never see this\n@@ -1420,1 +1334,1 @@\n-      chk_for_block_req(current->as_Java_thread(), \"deflation\", \"deflated_count\",\n+      chk_for_block_req(JavaThread::cast(current), \"deflation\", \"deflated_count\",\n@@ -1510,1 +1424,1 @@\n-        chk_for_block_req(current->as_Java_thread(), \"deletion\", \"deleted_count\",\n+        chk_for_block_req(JavaThread::cast(current), \"deletion\", \"deleted_count\",\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":5,"deletions":91,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -166,1 +165,1 @@\n-      const char* name = (javathread)->get_thread_name();                  \\\n+      const char* name = (javathread)->name();                             \\\n@@ -187,1 +186,0 @@\n-\/\/ Support for forcing alignment of thread objects for biased locking\n@@ -189,19 +187,1 @@\n-  if (UseBiasedLocking) {\n-    const size_t alignment = markWord::biased_lock_alignment;\n-    size_t aligned_size = size + (alignment - sizeof(intptr_t));\n-    void* real_malloc_addr = throw_excpt? AllocateHeap(aligned_size, flags, CURRENT_PC)\n-                                          : AllocateHeap(aligned_size, flags, CURRENT_PC,\n-                                                         AllocFailStrategy::RETURN_NULL);\n-    void* aligned_addr     = align_up(real_malloc_addr, alignment);\n-    assert(((uintptr_t) aligned_addr + (uintptr_t) size) <=\n-           ((uintptr_t) real_malloc_addr + (uintptr_t) aligned_size),\n-           \"JavaThread alignment code overflowed allocated storage\");\n-    if (aligned_addr != real_malloc_addr) {\n-      log_info(biasedlocking)(\"Aligned thread \" INTPTR_FORMAT \" to \" INTPTR_FORMAT,\n-                              p2i(real_malloc_addr),\n-                              p2i(aligned_addr));\n-    }\n-    ((Thread*) aligned_addr)->_real_malloc_address = real_malloc_addr;\n-    return aligned_addr;\n-  } else {\n-    return throw_excpt? AllocateHeap(size, flags, CURRENT_PC)\n+  return throw_excpt ? AllocateHeap(size, flags, CURRENT_PC)\n@@ -209,1 +189,0 @@\n-  }\n@@ -213,5 +192,1 @@\n-  if (UseBiasedLocking) {\n-    FreeHeap(((Thread*) p)->_real_malloc_address);\n-  } else {\n-    FreeHeap(p);\n-  }\n+  FreeHeap(p);\n@@ -291,8 +266,0 @@\n-#ifdef ASSERT\n-  if (UseBiasedLocking) {\n-    assert(is_aligned(this, markWord::biased_lock_alignment), \"forced alignment of thread object failed\");\n-    assert(this == _real_malloc_address ||\n-           this == align_up(_real_malloc_address, markWord::biased_lock_alignment),\n-           \"bug in forced alignment of thread objects\");\n-  }\n-#endif \/\/ ASSERT\n@@ -352,1 +319,1 @@\n-    as_Java_thread()->stack_overflow_state()->initialize(stack_base(), stack_end());\n+    JavaThread::cast(this)->stack_overflow_state()->initialize(stack_base(), stack_end());\n@@ -464,2 +431,2 @@\n-         thread->as_Java_thread()->is_handshake_safe_for(Thread::current()) ||\n-         !thread->as_Java_thread()->on_thread_list() ||\n+         JavaThread::cast(thread)->is_handshake_safe_for(Thread::current()) ||\n+         !JavaThread::cast(thread)->on_thread_list() ||\n@@ -467,1 +434,1 @@\n-         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock(thread->as_Java_thread()),\n+         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock(JavaThread::cast(thread)),\n@@ -539,1 +506,1 @@\n-    java_lang_Thread::set_thread_status(thread->as_Java_thread()->threadObj(),\n+    java_lang_Thread::set_thread_status(JavaThread::cast(thread)->threadObj(),\n@@ -645,11 +612,1 @@\n-  if (is_VM_thread())                 { st->print(\"VMThread\"); }\n-  else if (is_GC_task_thread())       { st->print(\"GCTaskThread\"); }\n-  else if (is_Watcher_thread())       { st->print(\"WatcherThread\"); }\n-  else if (is_ConcurrentGC_thread())  { st->print(\"ConcurrentGCThread\"); }\n-  else if (this == AsyncLogWriter::instance()) {\n-    st->print(\"%s\", this->name());\n-  } else                                { st->print(\"Thread\"); }\n-\n-  if (is_Named_thread()) {\n-    st->print(\" \\\"%s\\\"\", name());\n-  }\n+  st->print(\"%s \\\"%s\\\"\", type_name(), name());\n@@ -708,1 +665,1 @@\n-  return os::create_main_thread(this->as_Java_thread());\n+  return os::create_main_thread(JavaThread::cast(this));\n@@ -1084,1 +1041,0 @@\n-  _cached_monitor_info(nullptr),\n@@ -1309,1 +1265,1 @@\n-      this->set_native_thread_name(this->get_thread_name());\n+      this->set_native_thread_name(this->name());\n@@ -1388,1 +1344,1 @@\n-                    get_thread_name());\n+                    name());\n@@ -1493,1 +1449,1 @@\n-    thread_name = os::strdup(get_thread_name());\n+    thread_name = os::strdup(name());\n@@ -1550,1 +1506,1 @@\n-    return thread->as_Java_thread();\n+    return JavaThread::cast(thread);\n@@ -1554,1 +1510,1 @@\n-    JavaThread *ret = op == NULL ? NULL : op->calling_thread()->as_Java_thread();\n+    JavaThread *ret = op == NULL ? NULL : JavaThread::cast(op->calling_thread());\n@@ -1712,1 +1668,1 @@\n-    JavaThread* target = thr->as_Java_thread();\n+    JavaThread* target = JavaThread::cast(thr);\n@@ -2090,1 +2046,1 @@\n-  st->print_raw(get_thread_name());\n+  st->print_raw(name());\n@@ -2128,1 +2084,1 @@\n-  st->print(\"JavaThread \\\"%s\\\"\", get_thread_name_string(buf, buflen));\n+  st->print(\"%s \\\"%s\\\"\", type_name(), get_thread_name_string(buf, buflen));\n@@ -2176,1 +2132,1 @@\n-const char* JavaThread::get_thread_name() const {\n+const char* JavaThread::name() const  {\n@@ -2202,1 +2158,1 @@\n-      name_str = Thread::name();\n+      name_str = \"<un-named>\";\n@@ -3053,2 +3009,0 @@\n-  BiasedLocking::init();\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":20,"deletions":66,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -167,3 +167,0 @@\n-  \/\/ Support for forcing alignment of thread objects for biased locking\n-  void*       _real_malloc_address;\n-\n@@ -358,3 +355,5 @@\n-  \/\/ Casts\n-  inline JavaThread* as_Java_thread();\n-  inline const JavaThread* as_Java_thread() const;\n+  \/\/ All threads are given names. For singleton subclasses we can\n+  \/\/ just hard-wire the known name of the instance. JavaThreads and\n+  \/\/ NamedThreads support multiple named instances, and dynamic\n+  \/\/ changing of the name of an instance.\n+  virtual const char* name() const { return \"Unknown thread\"; }\n@@ -362,1 +361,3 @@\n-  virtual char* name() const { return (char*)\"Unknown thread\"; }\n+  \/\/ A thread's type name is also made available for debugging\n+  \/\/ and logging.\n+  virtual const char* type_name() const { return \"Thread\"; }\n@@ -578,0 +579,1 @@\n+  \/\/ Basic, non-virtual, printing support that is simple and always safe.\n@@ -1357,0 +1359,3 @@\n+  \/\/ factor out low-level mechanics for use in both normal and error cases\n+  const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n+\n@@ -1376,1 +1381,3 @@\n-  char* name() const { return (char*)get_thread_name(); }\n+  const char* name() const;\n+  const char* type_name() const { return \"JavaThread\"; }\n+\n@@ -1384,5 +1391,1 @@\n-  const char* get_thread_name() const;\n- protected:\n-  \/\/ factor out low-level mechanics for use in both normal and error cases\n-  virtual const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n- public:\n+\n@@ -1423,1 +1426,14 @@\n-  static inline JavaThread* current();\n+  static JavaThread* current() {\n+    return JavaThread::cast(Thread::current());\n+  }\n+\n+  \/\/ Casts\n+  static JavaThread* cast(Thread* t) {\n+    assert(t->is_Java_thread(), \"incorrect cast to JavaThread\");\n+    return static_cast<JavaThread*>(t);\n+  }\n+\n+  static const JavaThread* cast(const Thread* t) {\n+    assert(t->is_Java_thread(), \"incorrect cast to const JavaThread\");\n+    return static_cast<const JavaThread*>(t);\n+  }\n@@ -1554,3 +1570,0 @@\n-  \/\/ Biased locking support\n- private:\n-  GrowableArray<MonitorInfo*>* _cached_monitor_info;\n@@ -1558,3 +1571,0 @@\n-  GrowableArray<MonitorInfo*>* cached_monitor_info() { return _cached_monitor_info; }\n-  void set_cached_monitor_info(GrowableArray<MonitorInfo*>* info) { _cached_monitor_info = info; }\n-\n@@ -1589,15 +1599,0 @@\n-\/\/ Inline implementation of JavaThread::current\n-inline JavaThread* JavaThread::current() {\n-  return Thread::current()->as_Java_thread();\n-}\n-\n-inline JavaThread* Thread::as_Java_thread() {\n-  assert(is_Java_thread(), \"incorrect cast to JavaThread\");\n-  return static_cast<JavaThread*>(this);\n-}\n-\n-inline const JavaThread* Thread::as_Java_thread() const {\n-  assert(is_Java_thread(), \"incorrect cast to const JavaThread\");\n-  return static_cast<const JavaThread*>(this);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":30,"deletions":35,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-          assert(monitor->owner() == NULL || (!monitor->owner()->is_unlocked() && !monitor->owner()->has_bias_pattern()), \"object must be null or locked, and unbiased\");\n+          assert(monitor->owner() == NULL || !monitor->owner()->is_unlocked(), \"object must be null or locked\");\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -235,3 +235,2 @@\n-    \/\/ This monitor is really only needed for UseBiasedLocking, but\n-    \/\/ return it in all cases for now as it might be useful for stack\n-    \/\/ traces and tools as well\n+    \/\/ This monitor is not really needed but return it for now as it might be\n+    \/\/ useful for stack traces and tools\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-  template(PrintJNI)                              \\\n@@ -71,2 +70,0 @@\n-  template(EnableBiasedLocking)                   \\\n-  template(BulkRevokeBias)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-  calling_thread()->as_Java_thread()->make_zombies();\n+  JavaThread::cast(calling_thread())->make_zombies();\n@@ -171,0 +171,3 @@\n+  if (_print_jni_handle_info) {\n+    JNIHandles::print_on(_out);\n+  }\n@@ -180,4 +183,0 @@\n-void VM_PrintJNI::doit() {\n-  JNIHandles::print_on(_out);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+  bool _print_jni_handle_info;\n@@ -148,1 +149,1 @@\n-    : _out(tty), _print_concurrent_locks(PrintConcurrentLocks), _print_extended_info(false)\n+    : _out(tty), _print_concurrent_locks(PrintConcurrentLocks), _print_extended_info(false), _print_jni_handle_info(false)\n@@ -150,2 +151,3 @@\n-  VM_PrintThreads(outputStream* out, bool print_concurrent_locks, bool print_extended_info)\n-    : _out(out), _print_concurrent_locks(print_concurrent_locks), _print_extended_info(print_extended_info)\n+  VM_PrintThreads(outputStream* out, bool print_concurrent_locks, bool print_extended_info, bool print_jni_handle_info)\n+    : _out(out), _print_concurrent_locks(print_concurrent_locks), _print_extended_info(print_extended_info),\n+      _print_jni_handle_info(print_jni_handle_info)\n@@ -161,10 +163,0 @@\n-class VM_PrintJNI: public VM_Operation {\n- private:\n-  outputStream* _out;\n- public:\n-  VM_PrintJNI()                         { _out = tty; }\n-  VM_PrintJNI(outputStream* out)        { _out = out; }\n-  VMOp_Type type() const                { return VMOp_PrintJNI; }\n-  void doit();\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -269,1 +269,0 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -884,2 +883,2 @@\n-  nonstatic_field(ObjectMonitor,               _contentions,                                  jint)                                  \\\n-  volatile_nonstatic_field(ObjectMonitor,      _waiters,                                      jint)                                  \\\n+  nonstatic_field(ObjectMonitor,               _contentions,                                  int)                                   \\\n+  volatile_nonstatic_field(ObjectMonitor,      _waiters,                                      int)                                   \\\n@@ -2405,0 +2404,1 @@\n+  declare_constant(Deoptimization::Reason_receiver_constraint)            \\\n@@ -2632,1 +2632,0 @@\n-  declare_constant(markWord::biased_lock_bits)                            \\\n@@ -2637,1 +2636,0 @@\n-  declare_constant(markWord::biased_lock_shift)                           \\\n@@ -2643,3 +2641,0 @@\n-  declare_constant(markWord::biased_lock_mask)                            \\\n-  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n-  declare_constant(markWord::biased_lock_bit_in_place)                    \\\n@@ -2648,2 +2643,0 @@\n-  declare_constant(markWord::epoch_mask)                                  \\\n-  declare_constant(markWord::epoch_mask_in_place)                         \\\n@@ -2652,1 +2645,0 @@\n-  declare_constant(markWord::biased_lock_alignment)                       \\\n@@ -2658,1 +2650,0 @@\n-  declare_constant(markWord::biased_lock_pattern)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-    thread->as_Java_thread()->verify_states_for_handshake();\n+    JavaThread::cast(thread)->verify_states_for_handshake();\n@@ -525,1 +525,1 @@\n-    t->as_Java_thread()->check_for_valid_safepoint_state();\n+    JavaThread::cast(t)->check_for_valid_safepoint_state();\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,0 +133,3 @@\n+  \/\/ Printing\n+  const char* type_name() const { return \"VMThread\"; }\n+\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-  \/\/ thread stacks\n-  VM_PrintThreads op1(out, print_concurrent_locks, print_extended_info);\n+  \/\/ thread stacks and JNI global handles\n+  VM_PrintThreads op1(out, print_concurrent_locks, print_extended_info, true \/* print JNI handle info *\/);\n@@ -190,4 +190,0 @@\n-  \/\/ JNI global handles\n-  VM_PrintJNI op2(out);\n-  VMThread::execute(&op2);\n-\n@@ -195,2 +191,2 @@\n-  VM_FindDeadlocks op3(out);\n-  VMThread::execute(&op3);\n+  VM_FindDeadlocks op2(out);\n+  VMThread::execute(&op2);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -537,2 +537,2 @@\n-  \/\/ thread stacks\n-  VM_PrintThreads op1(output(), _locks.value(), _extended.value());\n+  \/\/ thread stacks and JNI global handles\n+  VM_PrintThreads op1(output(), _locks.value(), _extended.value(), true \/* print JNI handle info *\/);\n@@ -541,4 +541,0 @@\n-  \/\/ JNI global handles\n-  VM_PrintJNI op2(output());\n-  VMThread::execute(&op2);\n-\n@@ -546,2 +542,2 @@\n-  VM_FindDeadlocks op3(output());\n-  VMThread::execute(&op3);\n+  VM_FindDeadlocks op2(output());\n+  VMThread::execute(&op2);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-          currentThread = owner->as_Java_thread();\n+          currentThread = JavaThread::cast(owner);\n@@ -444,2 +444,0 @@\n-            cycle->set_deadlock(true);\n-\n@@ -487,2 +485,0 @@\n-        cycle->set_deadlock(true);\n-\n@@ -958,1 +954,0 @@\n-  _is_deadlock = false;\n@@ -983,1 +978,1 @@\n-    st->print_cr(\"\\\"%s\\\":\", currentThread->get_thread_name());\n+    st->print_cr(\"\\\"%s\\\":\", currentThread->name());\n@@ -994,2 +989,2 @@\n-          currentThread = owner->as_Java_thread();\n-          st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->get_thread_name());\n+          currentThread = JavaThread::cast(owner);\n+          st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->name());\n@@ -1034,1 +1029,1 @@\n-    st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->get_thread_name());\n+    st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->name());\n@@ -1046,1 +1041,1 @@\n-    st->print_cr(\"\\\"%s\\\":\", currentThread->get_thread_name());\n+    st->print_cr(\"\\\"%s\\\":\", currentThread->name());\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -387,1 +387,0 @@\n-  bool _is_deadlock;\n@@ -397,3 +396,1 @@\n-  void           reset()                    { _is_deadlock = false; _threads->clear(); }\n-  void           set_deadlock(bool value)   { _is_deadlock = value; }\n-  bool           is_deadlock()              { return _is_deadlock; }\n+  void           reset()                    { _threads->clear(); }\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -192,0 +192,4 @@\n+\n+    size_t get_mem_size() {\n+      return sizeof(*this) + _size * sizeof(Bucket);\n+    }\n@@ -387,0 +391,2 @@\n+  size_t get_mem_size(Thread* thread);\n+\n@@ -388,1 +394,1 @@\n-  size_t get_node_size() const { return sizeof(Node); }\n+  static size_t get_node_size() { return sizeof(Node); }\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-\/\/ 2^5  = 32 buckets\n-#define SIZE_SMALL_LOG2 5\n+\/\/ 2^2  = 4 buckets\n+#define SIZE_SMALL_LOG2 2\n@@ -820,4 +820,1 @@\n-\n-  if (_new_table->_log2_size == _log2_size_limit) {\n-    _size_limit_reached = true;\n-  }\n+  _size_limit_reached = _new_table->_log2_size == _log2_size_limit;\n@@ -957,0 +954,1 @@\n+    Prefetch::read(current_node->next(), 0);\n@@ -1035,0 +1033,8 @@\n+template <typename CONFIG, MEMFLAGS F>\n+inline size_t ConcurrentHashTable<CONFIG, F>::\n+  get_mem_size(Thread* thread)\n+{\n+  ScopedCS cs(thread, this);\n+  return sizeof(*this) + _table->get_mem_size();\n+}\n+\n@@ -1138,2 +1144,0 @@\n-  assert(Thread::current()->is_VM_thread(),\n-         \"should be in vm thread\");\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n-#define SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n-\n-#include \"memory\/padded.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/pair.hpp\"\n-\n-\/\/ Return status of a LockFreeQueue::try_pop() call.\n-\/\/ See description for try_pop() below.\n-enum class LockFreeQueuePopStatus {\n-  success,\n-  lost_race,\n-  operation_in_progress\n-};\n-\n-\/\/ The LockFreeQueue template provides a lock-free FIFO. Its structure\n-\/\/ and usage is similar to LockFreeStack. It provides a try_pop() function\n-\/\/ for the client to implement pop() according to its need (e.g., whether\n-\/\/ or not to retry or prevent ABA problem). It has inner padding of one\n-\/\/ cache line between its two internal pointer fields.\n-\/\/\n-\/\/ \\tparam T is the class of the elements in the queue.\n-\/\/\n-\/\/ \\tparam next_ptr is a function pointer.  Applying this function to\n-\/\/ an object of type T must return a pointer to the list entry member\n-\/\/ of the object associated with the LockFreeQueue type.\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-class LockFreeQueue {\n-  T* volatile _head;\n-  \/\/ Padding of one cache line to avoid false sharing.\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(T*));\n-  T* volatile _tail;\n-\n-  NONCOPYABLE(LockFreeQueue);\n-\n-  \/\/ Return the entry following node in the list used by the\n-  \/\/ specialized LockFreeQueue class.\n-  static inline T* next(const T& node);\n-\n-  \/\/ Set the entry following node to new_next in the list used by the\n-  \/\/ specialized LockFreeQueue class. Not thread-safe, as it cannot\n-  \/\/ concurrently run with push or try_pop operations that modify this\n-  \/\/ node.\n-  static inline void set_next(T& node, T* new_next);\n-\n-public:\n-  inline LockFreeQueue();\n-  DEBUG_ONLY(~LockFreeQueue();)\n-\n-  \/\/ Return the first object in the queue.\n-  \/\/ Thread-safe, but the result may change immediately.\n-  inline T* top() const;\n-\n-  \/\/ Return true if the queue is empty.\n-  inline bool empty() const { return top() == NULL; }\n-\n-  \/\/ Return the number of objects in the queue.\n-  \/\/ Not thread-safe. There must be no concurrent modification\n-  \/\/ while the length is being determined.\n-  inline size_t length() const;\n-\n-  \/\/ Thread-safe add the object to the end of the queue.\n-  inline void push(T& node) { append(node, node); }\n-\n-  \/\/ Thread-safe add the objects from first to last to the end of the queue.\n-  inline void append(T& first, T& last);\n-\n-  \/\/ Thread-safe attempt to remove and return the first object in the queue.\n-  \/\/ Returns a <LockFreeQueuePopStatus, T*> pair for the caller to determine\n-  \/\/ further operation. 3 possible cases depending on pair.first:\n-  \/\/ - success:\n-  \/\/   The operation succeeded. If pair.second is NULL, the queue is empty;\n-  \/\/   otherwise caller can assume ownership of the object pointed by\n-  \/\/   pair.second. Note that this case is still subject to ABA behavior;\n-  \/\/   callers must ensure usage is safe.\n-  \/\/ - lost_race:\n-  \/\/   An atomic operation failed. pair.second is NULL.\n-  \/\/   The caller can typically retry in this case.\n-  \/\/ - operation_in_progress:\n-  \/\/   An in-progress concurrent operation interfered with taking what had been\n-  \/\/   the only remaining element in the queue. pair.second is NULL.\n-  \/\/   A concurrent try_pop may have already claimed it, but not completely\n-  \/\/   updated the queue. Alternatively, a concurrent push\/append may have not\n-  \/\/   yet linked the new entry(s) to the former sole entry. Retrying the try_pop\n-  \/\/   will continue to fail in this way until that other thread has updated the\n-  \/\/   queue's internal structure.\n-  inline Pair<LockFreeQueuePopStatus, T*> try_pop();\n-\n-  \/\/ Take all the objects from the queue, leaving the queue empty.\n-  \/\/ Not thread-safe. It should only be used when there is no concurrent\n-  \/\/ push\/append\/try_pop operation.\n-  \/\/ Returns a pair of <head, tail> pointers to the current queue.\n-  inline Pair<T*, T*> take_all();\n-};\n-\n-#endif \/\/ SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n","filename":"src\/hotspot\/share\/utilities\/lockFreeQueue.hpp","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n-#define SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n-\n-#include \"utilities\/lockFreeQueue.hpp\"\n-\n-#include \"runtime\/atomic.hpp\"\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-T* LockFreeQueue<T, next_ptr>::next(const T& node) {\n-  return Atomic::load(next_ptr(const_cast<T&>(node)));\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-void LockFreeQueue<T, next_ptr>::set_next(T& node, T* new_next) {\n-    Atomic::store(next_ptr(node), new_next);\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-LockFreeQueue<T, next_ptr>::LockFreeQueue() : _head(NULL), _tail(NULL) {}\n-\n-#ifdef ASSERT\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-LockFreeQueue<T, next_ptr>::~LockFreeQueue() {\n-  assert(_head == NULL, \"precondition\");\n-  assert(_tail == NULL, \"precondition\");\n-}\n-#endif\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-T* LockFreeQueue<T, next_ptr>::top() const {\n-  return Atomic::load(&_head);\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-size_t LockFreeQueue<T, next_ptr>::length() const {\n-  size_t result = 0;\n-  for (const T* current = top(); current != NULL; current = next(*current)) {\n-    ++result;\n-  }\n-  return result;\n-}\n-\n-\/\/ An append operation atomically exchanges the new tail with the queue tail.\n-\/\/ It then sets the \"next\" value of the old tail to the head of the list being\n-\/\/ appended; it is an invariant that the old tail's \"next\" value is NULL.\n-\/\/ But if the old tail is NULL then the queue was empty.  In this case the\n-\/\/ head of the list being appended is instead stored in the queue head; it is\n-\/\/ an invariant that the queue head is NULL in this case.\n-\/\/\n-\/\/ This means there is a period between the exchange and the old tail update\n-\/\/ where the queue sequence is split into two parts, the list from the queue\n-\/\/ head to the old tail, and the list being appended.  If there are concurrent\n-\/\/ push\/append operations, each may introduce another such segment.  But they\n-\/\/ all eventually get resolved by their respective updates of their old tail's\n-\/\/ \"next\" value.  This also means that try_pop operation must handle an object\n-\/\/ with a NULL \"next\" value specially.\n-\/\/\n-\/\/ A push operation is just a degenerate append, where the object being pushed\n-\/\/ is both the head and the tail of the list being appended.\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-void LockFreeQueue<T, next_ptr>::append(T& first, T& last) {\n-  assert(next(last) == NULL, \"precondition\");\n-  T* old_tail = Atomic::xchg(&_tail, &last);\n-  if (old_tail == NULL) {       \/\/ Was empty.\n-    Atomic::store(&_head, &first);\n-  } else {\n-    assert(next(*old_tail) == NULL, \"invariant\");\n-    set_next(*old_tail, &first);\n-  }\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-Pair<LockFreeQueuePopStatus, T*> LockFreeQueue<T, next_ptr>::try_pop() {\n-  typedef Pair<LockFreeQueuePopStatus, T*> StatusPair;\n-  \/\/ We only need memory_order_consume. Upgrade it to \"load_acquire\"\n-  \/\/ as the memory_order_consume API is not ready for use yet.\n-  T* result = Atomic::load_acquire(&_head);\n-  if (result == NULL) {\n-    \/\/ Queue is empty.\n-    return StatusPair(LockFreeQueuePopStatus::success, NULL);\n-  }\n-\n-  \/\/ This relaxed load is always followed by a cmpxchg(), thus it\n-  \/\/ is OK as the reader-side of the release-acquire ordering.\n-  T* next_node = Atomic::load(next_ptr(*result));\n-  if (next_node != NULL) {\n-    \/\/ The \"usual\" lock-free pop from the head of a singly linked list.\n-    if (result == Atomic::cmpxchg(&_head, result, next_node)) {\n-      \/\/ Former head successfully taken; it is not the last.\n-      assert(Atomic::load(&_tail) != result, \"invariant\");\n-      assert(next(*result) != NULL, \"invariant\");\n-      set_next(*result, NULL);\n-      return StatusPair(LockFreeQueuePopStatus::success, result);\n-    }\n-    \/\/ Lost the race; the caller should try again.\n-    return StatusPair(LockFreeQueuePopStatus::lost_race, NULL);\n-  }\n-\n-  \/\/ next is NULL.  This case is handled differently from the \"usual\"\n-  \/\/ lock-free pop from the head of a singly linked list.\n-\n-  \/\/ If _tail == result then result is the only element in the list. We can\n-  \/\/ remove it from the list by first setting _tail to NULL and then setting\n-  \/\/ _head to NULL, the order being important.  We set _tail with cmpxchg in\n-  \/\/ case of a concurrent push\/append\/try_pop also changing _tail.  If we win\n-  \/\/ then we've claimed result.\n-  if (Atomic::cmpxchg(&_tail, result, (T*)NULL) == result) {\n-    assert(next(*result) == NULL, \"invariant\");\n-    \/\/ Now that we've claimed result, also set _head to NULL.  But we must\n-    \/\/ be careful of a concurrent push\/append after we NULLed _tail, since\n-    \/\/ it may have already performed its list-was-empty update of _head,\n-    \/\/ which we must not overwrite.\n-    Atomic::cmpxchg(&_head, result, (T*)NULL);\n-    return StatusPair(LockFreeQueuePopStatus::success, result);\n-  }\n-\n-  \/\/ If _head != result then we lost the race to take result;\n-  \/\/ the caller should try again.\n-  if (result != Atomic::load_acquire(&_head)) {\n-    return StatusPair(LockFreeQueuePopStatus::lost_race, NULL);\n-  }\n-\n-  \/\/ An in-progress concurrent operation interfered with taking the head\n-  \/\/ element when it was the only element.  A concurrent try_pop may have won\n-  \/\/ the race to clear the tail but not yet cleared the head. Alternatively,\n-  \/\/ a concurrent push\/append may have changed the tail but not yet linked\n-  \/\/ result->next(). This case slightly differs from the \"lost_race\" case,\n-  \/\/ because the caller could wait for a long time for the other concurrent\n-  \/\/ operation to finish.\n-  return StatusPair(LockFreeQueuePopStatus::operation_in_progress, NULL);\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-Pair<T*, T*> LockFreeQueue<T, next_ptr>::take_all() {\n-  Pair<T*, T*> result(Atomic::load(&_head), Atomic::load(&_tail));\n-  Atomic::store(&_head, (T*)NULL);\n-  Atomic::store(&_tail, (T*)NULL);\n-  return result;\n-}\n-\n-#endif \/\/ SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/lockFreeQueue.inline.hpp","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_NONBLOCKINGQUEUE_HPP\n+#define SHARE_UTILITIES_NONBLOCKINGQUEUE_HPP\n+\n+#include \"memory\/padded.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/pair.hpp\"\n+\n+\/\/ The NonblockingQueue template provides a non-blocking FIFO. It provides a\n+\/\/ try_pop() function for the client to implement pop() according to its\n+\/\/ need (e.g., whether or not to retry or prevent ABA problem). It has inner\n+\/\/ padding of one cache line between its two internal pointer fields.\n+\/\/\n+\/\/ The queue is internally represented by a linked list of elements, with\n+\/\/ the link to the next element provided by a member of each element.\n+\/\/ Access to this member is provided by the next_ptr function.\n+\/\/\n+\/\/ The queue has a special pseudo-element that marks the end of the list.\n+\/\/ Each queue has its own unique special element.  A pointer to this element\n+\/\/ can be recognized using the is_end() function.  Such a pointer must never\n+\/\/ be dereferenced.  This end marker is the value of the next member of the\n+\/\/ last element in the queue, and possibly other elements while modifying\n+\/\/ the queue.\n+\/\/\n+\/\/ A queue may temporarily appear to be empty even though elements have been\n+\/\/ added and not removed.  For example, after running the following program,\n+\/\/ the value of r may be NULL.\n+\/\/\n+\/\/ thread1: q.push(a); r = q.pop();\n+\/\/ thread2: q.push(b);\n+\/\/\n+\/\/ This can occur if the push of b started before the push of a, but didn't\n+\/\/ complete until after the pop.\n+\/\/\n+\/\/ \\tparam T is the class of the elements in the queue.\n+\/\/\n+\/\/ \\tparam next_ptr is a function pointer.  Applying this function to\n+\/\/ an object of type T must return a pointer to the list entry member\n+\/\/ of the object associated with the NonblockingQueue type.\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+class NonblockingQueue {\n+  T* volatile _head;\n+  \/\/ Padding of one cache line to avoid false sharing.\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(T*));\n+  T* volatile _tail;\n+\n+  NONCOPYABLE(NonblockingQueue);\n+\n+  \/\/ Return the entry following node in the list used by the\n+  \/\/ specialized NonblockingQueue class.\n+  static inline T* next(const T& node);\n+\n+  \/\/ Set the entry following node to new_next in the list used by the\n+  \/\/ specialized NonblockingQueue class. Not thread-safe, as it cannot\n+  \/\/ concurrently run with push or try_pop operations that modify this\n+  \/\/ node.\n+  static inline void set_next(T& node, T* new_next);\n+\n+  \/\/ A unique pseudo-object pointer associated with this specific queue.\n+  \/\/ The resulting pointer must not be dereferenced.\n+  inline T* end_marker() const;\n+\n+public:\n+  inline NonblockingQueue();\n+  inline ~NonblockingQueue() NOT_DEBUG(= default);\n+\n+  \/\/ Return true if the queue is empty.\n+  \/\/ Not thread-safe.  There must be no concurrent modification while the\n+  \/\/ queue is being tested.\n+  inline bool empty() const;\n+\n+  \/\/ Return the number of objects in the queue.\n+  \/\/ Not thread-safe. There must be no concurrent modification while the\n+  \/\/ length is being determined.\n+  inline size_t length() const;\n+\n+  \/\/ Thread-safe add the object to the end of the queue.\n+  inline void push(T& node) { append(node, node); }\n+\n+  \/\/ Thread-safe add the objects from first to last to the end of the queue.\n+  inline void append(T& first, T& last);\n+\n+  \/\/ Thread-safe attempt to remove and return the first object in the queue.\n+  \/\/ Returns true if successful.  If successful then *node_ptr is the former\n+  \/\/ first object, or NULL if the queue was empty.  If unsuccessful, because\n+  \/\/ of contention with a concurrent modification, then returns false with\n+  \/\/ the value of *node_ptr unspecified.  Subject to ABA behavior; callers\n+  \/\/ must ensure usage is safe.\n+  inline bool try_pop(T** node_ptr);\n+\n+  \/\/ Thread-safe remove and return the first object in the queue, or NULL if\n+  \/\/ the queue was empty.  This just iterates on try_pop() until it\n+  \/\/ succeeds, returning the (possibly NULL) element obtained from that.\n+  \/\/ Subject to ABA behavior; callers must ensure usage is safe.\n+  inline T* pop();\n+\n+  \/\/ Take all the objects from the queue, leaving the queue empty.\n+  \/\/ Not thread-safe.  There must be no concurrent operations.\n+  \/\/ Returns a pair of <head, tail> pointers to the current queue.\n+  inline Pair<T*, T*> take_all();\n+\n+  \/\/ Iteration support is provided by first() and is_end().  The queue must\n+  \/\/ not be modified while iterating over its elements.\n+\n+  \/\/ Return the first object in the queue, or an end marker (a pointer p for\n+  \/\/ which is_end(p) is true) if the queue is empty.\n+  inline T* first() const;\n+\n+  \/\/ Test whether entry is an end marker for this queue.\n+  inline bool is_end(const T* entry) const;\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_NONBLOCKINGQUEUE_HPP\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.hpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_NONBLOCKINGQUEUE_INLINE_HPP\n+#define SHARE_UTILITIES_NONBLOCKINGQUEUE_INLINE_HPP\n+\n+#include \"utilities\/nonblockingQueue.hpp\"\n+\n+#include \"runtime\/atomic.hpp\"\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::next(const T& node) {\n+  return Atomic::load(next_ptr(const_cast<T&>(node)));\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+void NonblockingQueue<T, next_ptr>::set_next(T& node, T* new_next) {\n+  Atomic::store(next_ptr(node), new_next);\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+NonblockingQueue<T, next_ptr>::NonblockingQueue() : _head(NULL), _tail(NULL) {}\n+\n+#ifdef ASSERT\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+NonblockingQueue<T, next_ptr>::~NonblockingQueue() {\n+  assert(_head == NULL, \"precondition\");\n+  assert(_tail == NULL, \"precondition\");\n+}\n+#endif\n+\n+\/\/ The end_marker must be uniquely associated with the specific queue, in\n+\/\/ case queue elements can make their way through multiple queues.  A\n+\/\/ pointer to the queue itself (after casting) satisfies that requirement.\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::end_marker() const {\n+  return const_cast<T*>(reinterpret_cast<const T*>(this));\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::first() const {\n+  T* head = Atomic::load(&_head);\n+  return head == NULL ? end_marker() : head;\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+bool NonblockingQueue<T, next_ptr>::is_end(const T* entry) const {\n+  return entry == end_marker();\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+bool NonblockingQueue<T, next_ptr>::empty() const {\n+  return Atomic::load(&_head) == NULL;\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+size_t NonblockingQueue<T, next_ptr>::length() const {\n+  size_t result = 0;\n+  for (T* cur = first(); !is_end(cur); cur = next(*cur)) {\n+    ++result;\n+  }\n+  return result;\n+}\n+\n+\/\/ An append operation atomically exchanges the new tail with the queue tail.\n+\/\/ It then sets the \"next\" value of the old tail to the head of the list being\n+\/\/ appended; it is an invariant that the old tail's \"next\" value is NULL.\n+\/\/ But if the old tail is NULL then the queue was empty.  In this case the\n+\/\/ head of the list being appended is instead stored in the queue head; it is\n+\/\/ an invariant that the queue head is NULL in this case.\n+\/\/\n+\/\/ This means there is a period between the exchange and the old tail update\n+\/\/ where the queue sequence is split into two parts, the list from the queue\n+\/\/ head to the old tail, and the list being appended.  If there are concurrent\n+\/\/ push\/append operations, each may introduce another such segment.  But they\n+\/\/ all eventually get resolved by their respective updates of their old tail's\n+\/\/ \"next\" value.  This also means that try_pop operation must handle an object\n+\/\/ with a NULL \"next\" value specially.\n+\/\/\n+\/\/ A push operation is just a degenerate append, where the object being pushed\n+\/\/ is both the head and the tail of the list being appended.\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+void NonblockingQueue<T, next_ptr>::append(T& first, T& last) {\n+  assert(next(last) == NULL, \"precondition\");\n+  set_next(last, end_marker());\n+  T* old_tail = Atomic::xchg(&_tail, &last);\n+  if ((old_tail == NULL) ||\n+      \/\/ Try to install first as old_tail's next.\n+      !is_end(Atomic::cmpxchg(next_ptr(*old_tail), end_marker(), &first))) {\n+    \/\/ Install first as the new head if either\n+    \/\/ (1) the list was empty, or\n+    \/\/ (2) a concurrent try_pop claimed old_tail, so it is no longer in the list.\n+    Atomic::store(&_head, &first);\n+  }\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+bool NonblockingQueue<T, next_ptr>::try_pop(T** node_ptr) {\n+  \/\/ We only need memory_order_consume. Upgrade it to \"load_acquire\"\n+  \/\/ as the memory_order_consume API is not ready for use yet.\n+  T* result = Atomic::load_acquire(&_head);\n+  if (result == NULL) {\n+    *node_ptr = NULL;\n+    return true;                \/\/ Queue is empty.\n+  }\n+\n+  T* next_node = Atomic::load_acquire(next_ptr(*result));\n+  if (next_node == NULL) {\n+    \/\/ A concurrent try_pop already claimed what was the last entry.  That\n+    \/\/ operation may not have cleared queue head yet, but we should still\n+    \/\/ treat the queue as empty until a push\/append operation changes head\n+    \/\/ to an entry with a non-NULL next value.\n+    *node_ptr = NULL;\n+    return true;\n+\n+  } else if (!is_end(next_node)) {\n+    \/\/ The next_node is not at the end of the queue's list.  Use the \"usual\"\n+    \/\/ lock-free pop from the head of a singly linked list to try to take it.\n+    if (result == Atomic::cmpxchg(&_head, result, next_node)) {\n+      \/\/ Former head successfully taken.\n+      set_next(*result, NULL);\n+      *node_ptr = result;\n+      return true;\n+    } else {\n+      \/\/ Lost race to take result from the head of the list.\n+      return false;\n+    }\n+\n+  } else if (is_end(Atomic::cmpxchg(next_ptr(*result), end_marker(), (T*)NULL))) {\n+    \/\/ Result was the last entry and we've claimed it by setting its next\n+    \/\/ value to NULL.  However, this leaves the queue in disarray.  Fix up\n+    \/\/ the queue, possibly in conjunction with other concurrent operations.\n+    \/\/ Any further try_pops will consider the queue empty until a\n+    \/\/ push\/append completes by installing a new head.\n+\n+    \/\/ Attempt to change the queue tail from result to NULL.  Failure of the\n+    \/\/ cmpxchg indicates that a concurrent push\/append updated the tail first.\n+    \/\/ That operation will eventually recognize the old tail (our result) is\n+    \/\/ no longer in the list and update head from the list being appended.\n+    Atomic::cmpxchg(&_tail, result, (T*)NULL);\n+\n+    \/\/ Attempt to change the queue head from result to NULL.  Failure of the\n+    \/\/ cmpxchg indicates a concurrent push\/append updated the head first.\n+    Atomic::cmpxchg(&_head, result, (T*)NULL);\n+\n+    \/\/ The queue has been restored to order, and we can return the result.\n+    *node_ptr = result;\n+    return true;\n+\n+  } else {\n+    \/\/ Result was the last entry in the list, but either a concurrent pop\n+    \/\/ claimed it first or a concurrent push\/append extended the list from\n+    \/\/ it.  Either way, we lost the race.\n+    return false;\n+  }\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::pop() {\n+  T* result = NULL;\n+  while (!try_pop(&result)) {}\n+  return result;\n+}\n+\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+Pair<T*, T*> NonblockingQueue<T, next_ptr>::take_all() {\n+  T* tail = Atomic::load(&_tail);\n+  if (tail != NULL) set_next(*tail, NULL); \/\/ Clear end marker.\n+  Pair<T*, T*> result(Atomic::load(&_head), tail);\n+  Atomic::store(&_head, (T*)NULL);\n+  Atomic::store(&_tail, (T*)NULL);\n+  return result;\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_NONBLOCKINGQUEUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -156,1 +156,1 @@\n-    if (thread->as_Java_thread()->thread_state() == _thread_in_native) {\n+    if (JavaThread::cast(thread)->thread_state() == _thread_in_native) {\n@@ -267,1 +267,1 @@\n-          RegisterMap map(t->as_Java_thread(), false); \/\/ No update\n+          RegisterMap map(JavaThread::cast(t), false); \/\/ No update\n@@ -753,1 +753,1 @@\n-       print_stack_trace(st, _thread->as_Java_thread(), buf, sizeof(buf));\n+       print_stack_trace(st, JavaThread::cast(_thread), buf, sizeof(buf));\n@@ -762,1 +762,1 @@\n-         JavaThread* jt = thread->as_Java_thread();\n+         JavaThread* jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-    \/\/ init method. Check opmode and key, then call init(byte[]).\n+    \/\/ init method. Check key, then call init(byte[]).\n@@ -184,0 +184,4 @@\n+\n+        \/\/ Cipher.init() already checks opmode to be:\n+        \/\/ ENCRYPT_MODE\/DECRYPT_MODE\/WRAP_MODE\/UNWRAP_MODE\n+\n@@ -187,3 +191,1 @@\n-        if ((opmode < Cipher.ENCRYPT_MODE) || (opmode > Cipher.UNWRAP_MODE)) {\n-            throw new InvalidKeyException(\"Unknown opmode: \" + opmode);\n-        }\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ARCFOURCipher.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -538,0 +538,2 @@\n+        \/\/ Cipher.init() already checks opmode to be:\n+        \/\/ ENCRYPT_MODE\/DECRYPT_MODE\/WRAP_MODE\/UNWRAP_MODE\n@@ -541,3 +543,0 @@\n-        } else if ((opmode != Cipher.ENCRYPT_MODE) &&\n-                (opmode != Cipher.DECRYPT_MODE)) {\n-            throw new InvalidKeyException(\"Unknown opmode: \" + opmode);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -177,1 +177,0 @@\n-            this.keysize = keysize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,1 +264,2 @@\n-            throw new InvalidKeyException(\"Unknown mode: \" + opmode);\n+            \/\/ should never happen; checked by Cipher.init()\n+            throw new AssertionError(\"Unknown mode: \" + opmode);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RSACipher.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.net.URL;\n@@ -48,4 +49,0 @@\n-import java.security.AccessControlContext;\n-import java.security.ProtectionDomain;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -55,0 +52,5 @@\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.CodeSource;\n+import java.security.PrivilegedAction;\n+import java.security.ProtectionDomain;\n@@ -327,0 +329,10 @@\n+    \/\/ Remember initial System.err. setSecurityManager() warning goes here\n+    private static volatile @Stable PrintStream initialErrStream;\n+\n+    private static URL codeSource(Class<?> clazz) {\n+        PrivilegedAction<ProtectionDomain> pa = clazz::getProtectionDomain;\n+        @SuppressWarnings(\"removal\")\n+        CodeSource cs = AccessController.doPrivileged(pa).getCodeSource();\n+        return (cs != null) ? cs.getLocation() : null;\n+    }\n+\n@@ -365,0 +377,1 @@\n+    @CallerSensitive\n@@ -367,2 +380,14 @@\n-            System.err.println(\"WARNING: java.lang.System::setSecurityManager\" +\n-                    \" is deprecated and will be removed in a future release.\");\n+            var callerClass = Reflection.getCallerClass();\n+            URL url = codeSource(callerClass);\n+            final String source;\n+            if (url == null) {\n+                source = callerClass.getName();\n+            } else {\n+                source = callerClass.getName() + \" (\" + url + \")\";\n+            }\n+            initialErrStream.printf(\"\"\"\n+                    WARNING: A terminally deprecated method in java.lang.System has been called\n+                    WARNING: System::setSecurityManager has been called by %s\n+                    WARNING: Please consider reporting this to the maintainers of %s\n+                    WARNING: System::setSecurityManager will be removed in a future release\n+                    \"\"\", source, callerClass.getName());\n@@ -374,1 +399,1 @@\n-                    \"Runtime configured to disallow security manager\");\n+                    \"The Security Manager is deprecated and will be removed in a future release\");\n@@ -2194,2 +2219,3 @@\n-            System.err.println(\"WARNING: The Security Manager is deprecated\" +\n-                    \" and will be removed in a future release.\");\n+            System.err.println(\"\"\"\n+                    WARNING: A command line option has enabled the Security Manager\n+                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n@@ -2198,0 +2224,2 @@\n+        initialErrStream = System.err;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-            return valueOf(refKind, false);\n+            return valueOf(refKind, refKind == REF_invokeInterface);\n@@ -137,8 +137,2 @@\n-            if (i >= 0 && i < TABLE.length) {\n-                Kind kind = TABLE[i];\n-                if (kind == null) {\n-                    throw new IllegalArgumentException(String.format(\"refKind=%d\", refKind));\n-                }\n-                if (kind.refKind == refKind && kind.isInterface == isInterface) {\n-                    return kind;\n-                }\n+            if (i >= 2 && i < TABLE.length) {\n+                return TABLE[i];\n@@ -146,1 +140,1 @@\n-            throw new IllegalArgumentException(String.format(\"refKind=%d\", refKind));\n+            throw new IllegalArgumentException(String.format(\"refKind=%d isInterface=%s\", refKind, isInterface));\n@@ -183,3 +177,1 @@\n-                        \/\/ There is not a specific Kind for interfaces\n-                        if (kind == VIRTUAL)  kind = INTERFACE_VIRTUAL;\n-                        if (TABLE[i] == null)  TABLE[i] = kind;\n+                        TABLE[i] = kind;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDesc.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1669,10 +1669,5 @@\n-        StringBuffer sb = new StringBuffer();\n-        sb.append(getClass().getName());\n-        sb.append(\"[pos=\");\n-        sb.append(position());\n-        sb.append(\" lim=\");\n-        sb.append(limit());\n-        sb.append(\" cap=\");\n-        sb.append(capacity());\n-        sb.append(\"]\");\n-        return sb.toString();\n+        return getClass().getName()\n+                 + \"[pos=\" + position()\n+                 + \" lim=\" + limit()\n+                 + \" cap=\" + capacity()\n+                 + \"]\";\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -756,4 +756,0 @@\n-         * If the intrinsic function does not process all of the bytes in\n-         * src, it must process a multiple of four of them, making the\n-         * returned destination length a multiple of three.\n-         *\n@@ -765,1 +761,4 @@\n-         * containing pad characters.\n+         * containing pad characters.  However, MIME decoding ignores\n+         * illegal characters, so any intrinsic overriding decodeBlock\n+         * can choose how to handle illegal characters based on the isMIME\n+         * parameter.\n@@ -782,0 +781,2 @@\n+         * @param  isMIME\n+         *         boolean, when true decode according to RFC2045 (ignore illegal chars)\n@@ -785,1 +786,1 @@\n-        private int decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL) {\n+        private int decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, boolean isMIME) {\n@@ -813,1 +814,1 @@\n-                    int dl = decodeBlock(src, sp, sl, dst, dp, isURL);\n+                    int dl = decodeBlock(src, sp, sl, dst, dp, isURL, isMIME);\n@@ -818,1 +819,1 @@\n-                    int chars_decoded = (dl \/ 3) * 4;\n+                    int chars_decoded = ((dl + 2) \/ 3) * 4;\n","filename":"src\/java.base\/share\/classes\/java\/util\/Base64.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+        String cwd = new File(\"\").getAbsolutePath(); \/\/ current dir used for printing message.\n@@ -302,2 +303,2 @@\n-            String stdOutFile = drainOutput(proc.getInputStream(), proc.pid(), \"stdout\", cmds);\n-            String stdErrFile = drainOutput(proc.getErrorStream(), proc.pid(), \"stderr\", cmds);\n+            String stdOutFileName = drainOutput(proc.getInputStream(), proc.pid(), \"stdout\", cmds);\n+            String stdErrFileName = drainOutput(proc.getErrorStream(), proc.pid(), \"stderr\", cmds);\n@@ -314,2 +315,2 @@\n-                                            stdOutFile + \" or stderr file \" +\n-                                            stdErrFile + \" for more detail\");\n+                                            cwd + File.separator + stdOutFileName + \" or stderr file \" +\n+                                            cwd + File.separator + stdErrFileName + \" for more detail\");\n@@ -321,1 +322,2 @@\n-                                           \" is not created, please check process \" +\n+                                           \" is not created, please check current working directory \" +\n+                                           cwd  + \" for process \" +\n@@ -334,1 +336,1 @@\n-        System.out.println((isStatic ? \"Static\" : \" Dynamic\") + \" dump to file \" + archiveFileName);\n+        System.out.println((isStatic ? \"Static\" : \" Dynamic\") + \" dump to file \" + cwd + File.separator + archiveFileName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -637,2 +637,1 @@\n-    RSA keySize < 1024, DSA keySize < 1024, EC keySize < 224, \\\n-    SHA1 jdkCA & usage SignedJAR & denyAfter 2019-01-01\n+    RSA keySize < 1024, DSA keySize < 1024, EC keySize < 224\n@@ -702,1 +701,1 @@\n-      DSA keySize < 1024, SHA1 jdkCA & denyAfter 2019-01-01\n+      DSA keySize < 1024\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JAVA\" \"1\" \"2021\" \"JDK 17\\-ea\" \"JDK Commands\"\n+.TH \"JAVA\" \"1\" \"2021\" \"JDK 18\\-ea\" \"JDK Commands\"\n@@ -184,1 +184,1 @@\n-(\\f[CB]17\\f[R]) and a limited number of previous releases, detailed in the\n+(\\f[CB]18\\f[R]) and a limited number of previous releases, detailed in the\n@@ -3999,10 +3999,0 @@\n-.TP\n-.B \\f[CB]\\-XX:+UseBiasedLocking\\f[R]\n-Enables the use of biased locking.\n-Some applications with significant amounts of uncontended\n-synchronization may attain significant speedups with this flag enabled,\n-but applications with certain patterns of locking may see slowdowns.\n-.RS\n-.PP\n-By default, this option is disabled.\n-.RE\n@@ -4023,0 +4013,10 @@\n+.TP\n+.B \\f[CB]\\-XX:+UseBiasedLocking\\f[R]\n+Enables the use of biased locking.\n+Some applications with significant amounts of uncontended\n+synchronization may attain significant speedups with this flag enabled,\n+but applications with certain patterns of locking may see slowdowns.\n+.RS\n+.PP\n+By default, this option is disabled.\n+.RE\n@@ -4937,8 +4937,0 @@\n-\\f[CB]TraceBiasedLocking\\f[R]\n-T}@T{\n-\\f[CB]\\-Xlog:biasedlocking=\\f[R]\\f[I]level\\f[R]\n-T}@T{\n-Use \\f[I]level\\f[R]=\\f[CB]info\\f[R] for regular information, or\n-\\f[I]level\\f[R]=\\f[CB]trace\\f[R] for additional information.\n-T}\n-T{\n","filename":"src\/java.base\/share\/man\/java.1","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1840,0 +1840,1 @@\n+    int res;\n@@ -1996,2 +1997,2 @@\n-        if (setsockopt(fd, IPPROTO_IP, (join ? IP_ADD_MEMBERSHIP:IP_DROP_MEMBERSHIP),\n-                       (char *) &mname, mname_len) < 0) {\n+        res = setsockopt(fd, IPPROTO_IP, (join ? IP_ADD_MEMBERSHIP:IP_DROP_MEMBERSHIP),\n+                       (char *) &mname, mname_len);\n@@ -1999,0 +2000,8 @@\n+#ifdef __APPLE__\n+        if (res < 0 && errno == ENOMEM) {\n+            res = setsockopt(fd, IPPROTO_IP, (join ? IP_ADD_MEMBERSHIP:IP_DROP_MEMBERSHIP),\n+                       (char *) &mname, mname_len);\n+        }\n+#endif\n+\n+        if (res < 0) {\n@@ -2099,2 +2108,2 @@\n-        if (setsockopt(fd, IPPROTO_IPV6, (join ? ADD_MEMBERSHIP : DRP_MEMBERSHIP),\n-                       (char *) &mname6, sizeof (mname6)) < 0) {\n+        res = setsockopt(fd, IPPROTO_IPV6, (join ? ADD_MEMBERSHIP : DRP_MEMBERSHIP),\n+                       (char *) &mname6, sizeof(mname6));\n@@ -2102,0 +2111,7 @@\n+#ifdef __APPLE__\n+        if (res < 0 && errno == ENOMEM) {\n+            res = setsockopt(fd, IPPROTO_IPV6, (join ? ADD_MEMBERSHIP : DRP_MEMBERSHIP),\n+                       (char *) &mname6, sizeof(mname6));\n+        }\n+#endif\n+        if (res < 0) {\n","filename":"src\/java.base\/unix\/native\/libnet\/PlainDatagramSocketImpl.c","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -193,4 +193,4 @@\n-     * The default implementation converts each path to a file and calls\n-     * {@link #getJavaFileObjectsFromFiles getJavaObjectsFromFiles}.\n-     * IllegalArgumentException will be thrown if any of the paths\n-     * cannot be converted to a file.\n+     * The default implementation lazily converts each path to a file and calls\n+     * {@link #getJavaFileObjectsFromFiles(Iterable) getJavaFileObjectsFromFiles}.\n+     * {@code IllegalArgumentException} will be thrown\n+     * if any of the paths cannot be converted to a file at the point the conversion happens.\n@@ -202,1 +202,1 @@\n-     * given paths.\n+     * given paths\n@@ -215,4 +215,4 @@\n-     * The default implementation converts each path to a file and calls\n-     * {@link #getJavaFileObjectsFromFiles getJavaObjectsFromFiles}.\n-     * IllegalArgumentException will be thrown if any of the paths\n-     * cannot be converted to a file.\n+     * The default implementation lazily converts each path to a file and calls\n+     * {@link #getJavaFileObjectsFromPaths(Collection) getJavaFileObjectsFromPaths}.\n+     * {@code IllegalArgumentException} will be thrown\n+     * if any of the paths cannot be converted to a file at the point the conversion happens.\n@@ -251,1 +251,2 @@\n-     * a directory\n+     * a directory or if this file manager does not support any of the\n+     * given paths\n@@ -265,0 +266,4 @@\n+     * @implSpec\n+     * The default implementation will only throw {@code NullPointerException}\n+     * if {@linkplain #getJavaFileObjectsFromPaths(Collection)} throws it.\n+     *\n@@ -268,1 +273,2 @@\n-     * a directory\n+     * a directory or if this file manager does not support any of the\n+     * given paths\n@@ -335,4 +341,4 @@\n-     * The default implementation converts each path to a file and calls\n-     * {@link #getJavaFileObjectsFromFiles getJavaObjectsFromFiles}.\n-     * {@linkplain IllegalArgumentException IllegalArgumentException}\n-     * will be thrown if any of the paths cannot be converted to a file.\n+     * The default implementation lazily converts each path to a file and calls\n+     * {@link #setLocation setLocation}.\n+     * {@code IllegalArgumentException} will be thrown if any of the paths cannot\n+     * be converted to a file at the point the conversion happens.\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/StandardJavaFileManager.java","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: June 2021\n@@ -1896,4 +1896,0 @@\n-        \/\/ process the attributes now, because after this SAX call they might be gone\n-        if (atts != null)\n-            addAttributes(atts);\n-\n@@ -1908,0 +1904,4 @@\n+        \/\/ process the attributes now, because after this SAX call they might be gone\n+        if (atts != null)\n+            addAttributes(atts);\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/serializer\/ToStream.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.TreeScanner;\n@@ -196,0 +199,3 @@\n+        if (new TypeAnnotationFinder().scan(paramTypes, null) != null)\n+            throw new ParseException(\"dc.ref.annotations.not.allowed\");\n+\n@@ -198,1 +204,13 @@\n-}\n+\n+    static class TypeAnnotationFinder extends TreeScanner<Tree, Void> {\n+        @Override\n+        public Tree visitAnnotatedType(AnnotatedTypeTree t, Void ignore) {\n+            return t;\n+        }\n+\n+        @Override\n+        public Tree reduce(Tree t1, Tree t2) {\n+            return t1 != null ? t1 : t2;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ReferenceParser.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3269,0 +3269,3 @@\n+compiler.err.dc.ref.annotations.not.allowed=\\\n+    annotations not allowed\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -359,2 +359,3 @@\n-            default:\n-                throw new InvalidAlgorithmParameterException\n+            case Cipher.WRAP_MODE:\n+            case Cipher.UNWRAP_MODE:\n+                throw new UnsupportedOperationException\n@@ -362,0 +363,3 @@\n+            default:\n+                \/\/ should never happen; checked by Cipher.init()\n+                throw new AssertionError(\"Unknown mode: \" + opmode);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -373,2 +373,3 @@\n-            default:\n-                throw new InvalidAlgorithmParameterException\n+            case Cipher.WRAP_MODE:\n+            case Cipher.UNWRAP_MODE:\n+                throw new UnsupportedOperationException\n@@ -376,0 +377,3 @@\n+            default:\n+                \/\/ should never happen; checked by Cipher.init()\n+                throw new AssertionError(\"Unknown mode: \" + opmode);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,1 +207,2 @@\n-            throw new InvalidKeyException(\"Unknown mode: \" + opmode);\n+            \/\/ should never happen; checked by Cipher.init()\n+            throw new AssertionError(\"Unknown mode: \" + opmode);\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CRSACipher.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    biasedLockBits      = db.lookupLongConstant(\"markWord::biased_lock_bits\").longValue();\n@@ -56,1 +55,0 @@\n-    biasedLockShift     = db.lookupLongConstant(\"markWord::biased_lock_shift\").longValue();\n@@ -61,3 +59,0 @@\n-    biasedLockMask      = db.lookupLongConstant(\"markWord::biased_lock_mask\").longValue();\n-    biasedLockMaskInPlace  = db.lookupLongConstant(\"markWord::biased_lock_mask_in_place\").longValue();\n-    biasedLockBitInPlace  = db.lookupLongConstant(\"markWord::biased_lock_bit_in_place\").longValue();\n@@ -68,1 +63,0 @@\n-    biasedLockAlignment  = db.lookupLongConstant(\"markWord::biased_lock_alignment\").longValue();\n@@ -73,1 +67,0 @@\n-    biasedLockPattern = db.lookupLongConstant(\"markWord::biased_lock_pattern\").longValue();\n@@ -86,1 +79,0 @@\n-  private static long biasedLockBits;\n@@ -91,1 +83,0 @@\n-  private static long biasedLockShift;\n@@ -97,3 +88,0 @@\n-  private static long biasedLockMask;\n-  private static long biasedLockMaskInPlace;\n-  private static long biasedLockBitInPlace;\n@@ -104,1 +92,0 @@\n-  private static long biasedLockAlignment;\n@@ -110,1 +97,0 @@\n-  private static long biasedLockPattern;\n@@ -136,22 +122,0 @@\n-  \/\/ Biased locking accessors\n-  \/\/ These must be checked by all code which calls into the\n-  \/\/ ObjectSynchoronizer and other code. The biasing is not understood\n-  \/\/ by the lower-level CAS-based locking code, although the runtime\n-  \/\/ fixes up biased locks to be compatible with it when a bias is\n-  \/\/ revoked.\n-  public boolean hasBiasPattern() {\n-    return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == biasedLockPattern);\n-  }\n-\n-  public JavaThread biasedLocker() {\n-    Threads threads = VM.getVM().getThreads();\n-    Address addr = valueAsAddress().andWithMask(~(biasedLockMaskInPlace & ageMaskInPlace));\n-    return threads.createJavaThreadWrapper(addr);\n-  }\n-\n-  \/\/ Indicates that the mark gas the bias bit set but that it has not\n-  \/\/ yet been biased toward a particular thread\n-  public boolean isBiasedAnonymously() {\n-    return hasBiasPattern() && (biasedLocker() == null);\n-  }\n-\n@@ -163,1 +127,1 @@\n-    return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == unlockedValue);\n+    return (Bits.maskBitsLong(value(), lockMaskInPlace) == unlockedValue);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,3 +55,3 @@\n-    contentionsField  = type.getJIntField(\"_contentions\");\n-    waitersField = type.getJIntField(\"_waiters\");\n-    recursionsField = type.getCIntegerField(\"_recursions\");\n+    contentionsField  = new CIntField(type.getCIntegerField(\"_contentions\"), 0);\n+    waitersField      = new CIntField(type.getCIntegerField(\"_waiters\"), 0);\n+    recursionsField   = type.getCIntegerField(\"_recursions\");\n@@ -86,1 +86,1 @@\n-  public int    waiters() { return waitersField.getValue(addr); }\n+  public int    waiters() { return (int)waitersField.getValue(this); }\n@@ -103,1 +103,1 @@\n-      return contentionsField.getValue(addr);\n+      return (int)contentionsField.getValue(this);\n@@ -114,2 +114,2 @@\n-  private static JIntField     contentionsField;\n-  private static JIntField     waitersField;\n+  private static CIntField     contentionsField;\n+  private static CIntField     waitersField;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -603,1 +603,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -605,10 +606,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -635,1 +635,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -637,10 +638,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -817,18 +809,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -699,1 +699,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -701,10 +702,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -881,18 +873,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -587,1 +587,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -589,10 +590,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -769,18 +761,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -573,1 +573,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -575,10 +576,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -755,18 +747,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -571,1 +571,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -573,10 +574,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -753,18 +745,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -575,1 +575,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -577,10 +578,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -583,1 +583,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -585,10 +586,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -765,18 +757,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -569,1 +569,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -571,10 +572,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -751,18 +743,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -568,1 +568,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -570,10 +571,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -750,18 +742,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -575,1 +575,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -577,10 +578,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -583,1 +583,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -585,10 +586,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -765,18 +757,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -599,1 +599,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -601,10 +602,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -781,18 +773,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -571,1 +571,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -573,10 +574,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -753,18 +745,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -568,1 +568,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -570,10 +571,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -750,18 +742,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -579,1 +579,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -581,10 +582,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -761,18 +753,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -587,1 +587,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -589,10 +590,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -769,18 +761,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -603,1 +603,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -605,10 +606,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -575,1 +575,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -577,10 +578,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -573,1 +573,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -575,10 +576,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -766,18 +758,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -565,1 +565,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -567,10 +568,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -747,18 +739,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -569,1 +569,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -571,10 +572,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -751,18 +743,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -577,1 +577,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -579,10 +580,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -759,18 +751,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -563,1 +563,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -565,10 +566,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -745,18 +737,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -563,1 +563,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -565,10 +566,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -745,18 +737,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -587,1 +587,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -589,10 +590,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -769,18 +761,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -603,1 +603,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -605,10 +606,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -635,1 +635,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -637,10 +638,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -817,18 +809,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -579,1 +579,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -581,10 +582,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -761,18 +753,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -573,1 +573,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -575,10 +576,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -755,18 +747,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -846,1 +846,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -848,10 +849,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short$bits$Vector.Short$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int$bits$Vector.Int$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long$bits$Vector.Long$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float$bits$Vector.Float$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double$bits$Vector.Double$bits$Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -1043,18 +1035,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte$bits$Vector.Byte$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short$bits$Vector.Short$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int$bits$Vector.Int$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long$bits$Vector.Long$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float$bits$Vector.Float$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double$bits$Vector.Double$bits$Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -926,5 +926,1 @@\n-        if (isArray()) {\n-            return config.arrayPrototypeMarkWord();\n-        } else {\n-            return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);\n-        }\n+        return config.prototypeMarkWord();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-    final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markWord\");\n@@ -155,1 +154,1 @@\n-    long arrayPrototypeMarkWord() {\n+    long prototypeMarkWord() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -427,0 +427,2 @@\n+     *\n+     * @since 17\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-@Description(\"Results of deserialiation and ObjectInputFilter checks\")\n+@Description(\"Results of deserialization and ObjectInputFilter checks\")\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/DeserializationEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,4 @@\n-    \/\/ Called by native\n+    \/\/ Called by native. The number of arguments for each command is\n+    \/\/ reported to the DCmdFramework as a hardcoded number in native.\n+    \/\/ This is to avoid an upcall as part of DcmdFramework enumerating existing commands.\n+    \/\/ Remember to keep the two sides in synch.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/AbstractDCmd.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jfr.internal.PrivateAccess;\n@@ -33,0 +34,1 @@\n+import jdk.jfr.internal.WriteableUserPath;\n@@ -47,1 +49,0 @@\n-            SafePath safePath = null;\n@@ -49,0 +50,2 @@\n+            WriteableUserPath path = PrivateAccess.getInstance().getPlatformRecording(recording).getDestination();\n+            SafePath safePath = path == null ? null : new SafePath(path.getRealPathText());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStop.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,18 +99,0 @@\n-    <event name=\"jdk.BiasedLockRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockSelfRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockClassRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -99,18 +99,0 @@\n-    <event name=\"jdk.BiasedLockRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockSelfRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockClassRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -586,0 +586,2 @@\n+     *\n+     * @since 17\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,5 +63,8 @@\n-  HeapRegion hr0(0, &bot, mr0);\n-  HeapRegion hr1(1, &bot, mr1);\n-  HeapRegion hr2(2, &bot, mr2);\n-  HeapRegion hr3(3, &bot, mr3);\n-  HeapRegion hr4(4, &bot, mr4);\n+  G1CardSetConfiguration config;\n+\n+  HeapRegion hr0(0, &bot, mr0, &config);\n+  HeapRegion hr1(1, &bot, mr1, &config);\n+  HeapRegion hr2(2, &bot, mr2, &config);\n+  HeapRegion hr3(3, &bot, mr3, &config);\n+  HeapRegion hr4(4, &bot, mr4, &config);\n+\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/workgroup.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+class G1CardSetTest : public ::testing::Test {\n+\n+  class G1CountCardsClosure : public G1CardSet::G1CardSetCardIterator {\n+  public:\n+    size_t _num_cards;\n+\n+    G1CountCardsClosure() : _num_cards(0) { }\n+    void do_card(uint region_idx, uint card_idx) override {\n+      _num_cards++;\n+    }\n+  };\n+\n+  static WorkGang* _workers;\n+  static uint _max_workers;\n+\n+  static WorkGang* workers() {\n+    if (_workers == NULL) {\n+      _max_workers = os::processor_count();\n+      _workers = new WorkGang(\"G1CardSetTest Work Gang\", _max_workers, false, false);\n+      _workers->initialize_workers();\n+      _workers->update_active_workers(_max_workers);\n+    }\n+    return _workers;\n+  }\n+\n+  \/\/ Check whether iteration agrees with the expected number of entries. If the\n+  \/\/ add has been single-threaded, we can also check whether the occupied()\n+  \/\/ (which is an estimate in that case) agrees.\n+  static void check_iteration(G1CardSet* card_set,\n+                              const size_t expected,\n+                              const bool add_was_single_threaded = true);\n+\n+public:\n+  G1CardSetTest() { }\n+  ~G1CardSetTest() { }\n+\n+  static uint next_random(uint& seed, uint i) {\n+    \/\/ ParkMiller random number generator\n+    seed = (seed * 279470273u) % 0xfffffffb;\n+    return (seed % i);\n+  }\n+\n+  static void cardset_basic_test();\n+  static void cardset_mt_test();\n+\n+  static void add_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards, G1AddCardResult* results);\n+  static void contains_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards);\n+\n+  static void translate_cards(uint cards_per_region, uint region_idx, uint* cards, uint num_cards);\n+\n+  static void iterate_cards(G1CardSet* card_set, G1CardSet::G1CardSetCardIterator* cl);\n+};\n+\n+WorkGang* G1CardSetTest::_workers = NULL;\n+uint G1CardSetTest::_max_workers = 0;\n+\n+void G1CardSetTest::add_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards, G1AddCardResult* results) {\n+  for (uint i = 0; i < num_cards; i++) {\n+\n+    uint region_idx = cards[i] \/ cards_per_region;\n+    uint card_idx = cards[i] % cards_per_region;\n+\n+    G1AddCardResult res = card_set->add_card(region_idx, card_idx);\n+    if (results != NULL) {\n+      ASSERT_TRUE(res == results[i]);\n+    }\n+  }\n+}\n+\n+class G1CheckCardClosure : public G1CardSet::G1CardSetCardIterator {\n+  G1CardSet* _card_set;\n+\n+  uint _cards_per_region;\n+  uint* _cards_to_expect;\n+  uint _num_cards;\n+\n+  bool _wrong_region_idx;\n+\n+public:\n+  G1CheckCardClosure(G1CardSet* card_set, uint cards_per_region, uint* cards_to_expect, uint num_cards) :\n+    _card_set(card_set),\n+    _cards_per_region(cards_per_region),\n+    _cards_to_expect(cards_to_expect),\n+    _num_cards(num_cards),\n+    _wrong_region_idx(false) {\n+  }\n+\n+  void do_card(uint region_idx, uint card_idx) override {\n+    uint card = _cards_per_region * region_idx + card_idx;\n+    for (uint i = 0; i < _num_cards; i++) {\n+      if (_cards_to_expect[i] == card) {\n+        _cards_to_expect[i] = (uint)-1;\n+      }\n+    }\n+  }\n+\n+  bool all_found() const {\n+    bool all_good = true;\n+    for (uint i = 0; i < _num_cards; i++) {\n+      if (_cards_to_expect[i] != (uint)-1) {\n+        log_error(gc)(\"Could not find card %u in region %u\",\n+                      _cards_to_expect[i] % _cards_per_region,\n+                      _cards_to_expect[i] \/ _cards_per_region);\n+        all_good = false;\n+      }\n+    }\n+    return all_good;\n+  }\n+};\n+\n+void G1CardSetTest::contains_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards) {\n+  for (uint i = 0; i < num_cards; i++) {\n+    uint region_idx = cards[i] \/ cards_per_region;\n+    uint card_idx = cards[i] % cards_per_region;\n+\n+    ASSERT_TRUE(card_set->contains_card(region_idx, card_idx));\n+  }\n+\n+  G1CheckCardClosure cl(card_set, cards_per_region, cards, num_cards);\n+  card_set->iterate_cards(cl);\n+\n+  ASSERT_TRUE(cl.all_found());\n+}\n+\n+\/\/ Offsets the card indexes in the cards array by the region_idx.\n+void G1CardSetTest::translate_cards(uint cards_per_region, uint region_idx, uint* cards, uint num_cards) {\n+  for (uint i = 0; i < num_cards; i++) {\n+    cards[i] = cards_per_region * region_idx + cards[i];\n+  }\n+}\n+\n+class G1CountCardsOccupied : public G1CardSet::G1CardSetPtrIterator {\n+  size_t _num_occupied;\n+\n+public:\n+  G1CountCardsOccupied() : _num_occupied(0) { }\n+\n+  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+    _num_occupied += num_occupied;\n+  }\n+\n+  size_t num_occupied() const { return _num_occupied; }\n+};\n+\n+void G1CardSetTest::check_iteration(G1CardSet* card_set, const size_t expected, const bool single_threaded) {\n+\n+  class CheckIterator : public G1CardSet::G1CardSetCardIterator {\n+  public:\n+    G1CardSet* _card_set;\n+    size_t _num_found;\n+\n+    CheckIterator(G1CardSet* card_set) : _card_set(card_set), _num_found(0) { }\n+\n+    void do_card(uint region_idx, uint card_idx) override {\n+      ASSERT_TRUE(_card_set->contains_card(region_idx, card_idx));\n+      _num_found++;\n+    }\n+  } cl(card_set);\n+\n+  card_set->iterate_cards(cl);\n+\n+  ASSERT_TRUE(expected == cl._num_found);\n+  \/\/ We can assert this only if we are single-threaded.\n+  if (single_threaded) {\n+    ASSERT_EQ(card_set->occupied(), cl._num_found);\n+  }\n+}\n+\n+void G1CardSetTest::cardset_basic_test() {\n+\n+  const uint CardsPerRegion = 2048;\n+  const double FullCardSetThreshold = 0.8;\n+  const double BitmapCoarsenThreshold = 0.9;\n+\n+  G1CardSetConfiguration config(log2i_exact(CardsPerRegion), 28, BitmapCoarsenThreshold, 8, FullCardSetThreshold, CardsPerRegion);\n+  G1CardSetFreePool free_pool(config.num_mem_object_types());\n+  G1CardSetMemoryManager mm(&config, &free_pool);\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 1, 2, 3 };\n+    G1AddCardResult results1[] = { Added, Added, Added };\n+    translate_cards(CardsPerRegion, 99, cards1, ARRAY_SIZE(cards1));\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), results1);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+\n+    check_iteration(&card_set, 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 0, 2047, 17, 17 };\n+    G1AddCardResult results1[] = { Added, Added, Added, Found };\n+    translate_cards(CardsPerRegion, 100, cards1, ARRAY_SIZE(cards1));\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), results1);\n+    \/\/ -1 because of the duplicate at the end.\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1) - 1);\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1) - 1);\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1) - 1);\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 0, 2047, 17, 18 \/* for region 100 *\/,\n+                      1,  128, 35, 17 \/* for region 990 *\/\n+                    };\n+    translate_cards(CardsPerRegion, 100, &cards1[0], 4);\n+    translate_cards(CardsPerRegion, 990, &cards1[4], 4);\n+\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[100];\n+    for (uint i = 0; i < ARRAY_SIZE(cards1); i++) {\n+      cards1[i] = i + 3;\n+      translate_cards(CardsPerRegion, i, &cards1[i], 1);\n+    }\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+\n+    ASSERT_TRUE(card_set.num_containers() == ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    \/\/ Generate non-prime numbers from 1 to 1000\n+    uint count = 0;\n+    for (uint i = 2; i < 33; i++) {\n+      if (!card_set.contains_card(100, i)) {\n+        for (uint j = i * i; j < 1000; j += i) {\n+          G1AddCardResult res = card_set.add_card(100, j);\n+          count += (res == Added);\n+        }\n+      }\n+    }\n+\n+    G1CountCardsOccupied cl;\n+    card_set.iterate_containers(&cl);\n+\n+    ASSERT_TRUE(count == card_set.occupied());\n+    ASSERT_TRUE(card_set.occupied() == cl.num_occupied());\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+  { \/\/ Test coarsening to full\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint count = 0;\n+    uint i = 10;\n+    uint bitmap_threshold = config.cards_in_howl_bitmap_threshold();\n+    for (; i <  bitmap_threshold + 10; i++) {\n+      G1AddCardResult res = card_set.add_card(99, i);\n+      ASSERT_TRUE(res == Added);\n+      count++;\n+      ASSERT_TRUE(count == card_set.occupied());\n+    }\n+\n+    G1AddCardResult res = card_set.add_card(99, config.num_cards_in_howl_bitmap() - 1);\n+    \/\/ Adding above card should have coarsened Bitmap -> Full.\n+    ASSERT_TRUE(res == Added);\n+    ASSERT_TRUE(config.num_cards_in_howl_bitmap() == card_set.occupied());\n+\n+    res = card_set.add_card(99, config.num_cards_in_howl_bitmap() - 2);\n+    ASSERT_TRUE(res == Found);\n+\n+    uint threshold = config.cards_in_howl_threshold();\n+    uint adjusted_threshold = config.cards_in_howl_bitmap_threshold() * config.num_buckets_in_howl();\n+    i = config.num_cards_in_howl_bitmap();\n+    count = i;\n+    for (; i <  threshold; i++) {\n+      G1AddCardResult res = card_set.add_card(99, i);\n+      ASSERT_TRUE(res == Added);\n+      count++;\n+      ASSERT_TRUE(count == card_set.occupied());\n+    }\n+\n+    res = card_set.add_card(99, CardsPerRegion - 1);\n+    \/\/ Adding above card should have coarsened Howl -> Full.\n+    ASSERT_TRUE(res == Added);\n+    ASSERT_TRUE(CardsPerRegion == card_set.occupied());\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    res = card_set.add_card(99, CardsPerRegion - 2);\n+    ASSERT_TRUE(res == Found);\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == config.max_cards_in_region());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+}\n+\n+class G1CardSetMtTestTask : public AbstractGangTask {\n+  G1CardSet* _card_set;\n+\n+  size_t _added;\n+  size_t _found;\n+\n+public:\n+  G1CardSetMtTestTask(G1CardSet* card_set) :\n+    AbstractGangTask(\"\"),\n+    _card_set(card_set),\n+    _added(0),\n+    _found(0) { }\n+\n+  void work(uint worker_id) {\n+    uint seed = worker_id;\n+    size_t added = 0;\n+    size_t found = 0;\n+\n+    for (uint i = 0; i < 100000; i++) {\n+      uint region = G1CardSetTest::next_random(seed, 1000);\n+      uint card = G1CardSetTest::next_random(seed, 10000);\n+\n+      G1AddCardResult res = _card_set->add_card(region, card);\n+\n+      ASSERT_TRUE(res == Added || res == Found);\n+      if (res == Added) {\n+        added++;\n+      } else if (res == Found) {\n+        found++;\n+      }\n+    }\n+    Atomic::add(&_added, added);\n+    Atomic::add(&_found, found);\n+  }\n+\n+  size_t added() const { return _added; }\n+  size_t found() const { return _found; }\n+};\n+\n+void G1CardSetTest::cardset_mt_test() {\n+  const uint CardsPerRegion = 16384;\n+  const double FullCardSetThreshold = 1.0;\n+  const uint BitmapCoarsenThreshold = 1.0;\n+\n+  G1CardSetConfiguration config(log2i_exact(CardsPerRegion), 120, BitmapCoarsenThreshold, 8, FullCardSetThreshold, CardsPerRegion);\n+  G1CardSetFreePool free_pool(config.num_mem_object_types());\n+  G1CardSetMemoryManager mm(&config, &free_pool);\n+\n+  G1CardSet card_set(&config, &mm);\n+\n+  const uint num_workers = workers()->active_workers();\n+\n+  G1CardSetMtTestTask cl(&card_set);\n+\n+  {\n+    GCTraceTime(Error, gc) x(\"Cardset test\");\n+    _workers->run_task(&cl, num_workers);\n+  }\n+\n+  size_t num_found = 0;\n+  \/\/ Now check the contents of the card set.\n+  for (uint i = 0; i < num_workers; i++) {\n+    uint seed = i;\n+\n+    for (uint j = 0; j < 100000; j++) {\n+      uint region = G1CardSetTest::next_random(seed, 1000);\n+      uint card = G1CardSetTest::next_random(seed, 10000);\n+\n+      bool contains = card_set.contains_card(region, card);\n+      ASSERT_TRUE(contains);\n+\n+      num_found += contains;\n+    }\n+  }\n+\n+  ASSERT_TRUE(num_found == cl.added() + cl.found());\n+\n+  G1CountCardsClosure count_cards;\n+  card_set.iterate_cards(count_cards);\n+\n+  check_iteration(&card_set, count_cards._num_cards, false \/* add_was_single_threaded *\/);\n+\n+  \/\/ During coarsening we try to unblock concurrent threads as soon as possible,\n+  \/\/ so we do not add the cards from the smaller CardSetContainer to the larger\n+  \/\/ one immediately, allowing addition by concurrent threads after allocating\n+  \/\/ the space immediately. So the amount of \"successfully added\" results may be\n+  \/\/ (and in case of many threads typically is) higher than the number of unique\n+  \/\/ cards.\n+  ASSERT_TRUE(count_cards._num_cards <= cl.added());\n+}\n+\n+TEST_VM(G1CardSetTest, basic_cardset_test) {\n+  G1CardSetTest::cardset_basic_test();\n+}\n+\n+TEST_VM(G1CardSetTest, mt_cardset_test) {\n+  G1CardSetTest::cardset_mt_test();\n+}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/heapRegionBounds.inline.hpp\"\n+#include \"gc\/shared\/cardTable.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"unittest.hpp\"\n+\n+class G1CardSetContainersTest : public ::testing::Test {\n+public:\n+  G1CardSetContainersTest() { }\n+  ~G1CardSetContainersTest() { }\n+\n+  static uint cards_per_inlineptr_set(uint bits_per_card) {\n+    return G1CardSetInlinePtr::max_cards_in_inline_ptr(bits_per_card);\n+  }\n+\n+  static void cardset_inlineptr_test(uint bits_per_card);\n+  static void cardset_array_test(uint cards_per_array);\n+  static void cardset_bitmap_test(uint threshold, uint size_in_bits);\n+};\n+\n+class G1FindCardsInRange : public StackObj {\n+  uint _num_cards;\n+  uint _range_min;\n+  bool* _cards_found;\n+public:\n+  G1FindCardsInRange(uint range_min, uint range_max) :\n+    _num_cards(range_max - range_min + 1),\n+    _range_min(range_min),\n+    _cards_found(NEW_C_HEAP_ARRAY(bool, _num_cards, mtGC)) {\n+    for (uint i = 0; i < _num_cards; i++) {\n+      _cards_found[i] = false;\n+    }\n+  }\n+\n+  void verify_all_found() {\n+    verify_part_found(_num_cards);\n+  }\n+\n+  void verify_part_found(uint num) {\n+    for (uint i = 0; i < num; i++) {\n+      ASSERT_TRUE(_cards_found[i]);\n+    }\n+  }\n+\n+  ~G1FindCardsInRange() {\n+    FREE_C_HEAP_ARRAY(mtGC, _cards_found);\n+  }\n+  void operator()(uint card) {\n+    ASSERT_TRUE((card - _range_min) < _num_cards);\n+    ASSERT_FALSE(_cards_found[card - _range_min]); \/\/ Must not have been found yet.\n+    _cards_found[card - _range_min] = true;\n+  }\n+};\n+\n+void G1CardSetContainersTest::cardset_inlineptr_test(uint bits_per_card) {\n+  const uint CardsPerSet = cards_per_inlineptr_set(bits_per_card);\n+\n+  G1AddCardResult res;\n+\n+  G1CardSet::CardSetPtr value = G1CardSetInlinePtr();\n+\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    {\n+      G1CardSetInlinePtr cards(&value, value);\n+      res = cards.add(i + 1, bits_per_card, CardsPerSet);\n+      ASSERT_TRUE(res == Added);\n+    }\n+    {\n+      G1CardSetInlinePtr cards(&value, value);\n+      ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+    }\n+  }\n+\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(&value, value);\n+    res = cards.add(i + 1, bits_per_card, CardsPerSet);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    G1CardSetInlinePtr cards(&value, value);\n+    res = cards.add(CardsPerSet + 1, bits_per_card, CardsPerSet);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+  }\n+\n+  \/\/ Boundary cards should not be in the set.\n+  {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(!cards.contains(0, bits_per_card));\n+    ASSERT_TRUE(!cards.contains(CardsPerSet + 1, bits_per_card));\n+  }\n+\n+  \/\/ Verify iteration finds all cards too and only those.\n+  {\n+    G1FindCardsInRange found(1, CardsPerSet);\n+    G1CardSetInlinePtr cards(value);\n+    cards.iterate(found, bits_per_card);\n+    found.verify_all_found();\n+  }\n+}\n+\n+void G1CardSetContainersTest::cardset_array_test(uint cards_per_array) {\n+  uint8_t* cardset_data = NEW_C_HEAP_ARRAY(uint8_t, G1CardSetArray::size_in_bytes(cards_per_array), mtGC);\n+  G1CardSetArray* cards = new (cardset_data) G1CardSetArray(1, cards_per_array);\n+\n+  ASSERT_TRUE(cards->contains(1)); \/\/ Added during initialization\n+  ASSERT_TRUE(cards->num_entries() == 1); \/\/ Check it's the only one.\n+\n+  G1AddCardResult res;\n+\n+  \/\/ Add some elements\n+  for (uint i = 1; i < cards_per_array; i++) {\n+    res = cards->add(i + 1);\n+    ASSERT_TRUE(res == Added);\n+  }\n+\n+  \/\/ Check they are in the container.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    res = cards->add(i + 1);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    res = cards->add(cards_per_array + 1);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1));\n+  }\n+\n+  ASSERT_TRUE(!cards->contains(0));\n+  ASSERT_TRUE(!cards->contains(cards_per_array + 1));\n+\n+  \/\/ Verify iteration finds all cards too.\n+  {\n+    G1FindCardsInRange found(1, cards_per_array);\n+    cards->iterate(found);\n+    found.verify_all_found();\n+  }\n+\n+  FREE_C_HEAP_ARRAY(mtGC, cardset_data);\n+}\n+\n+void G1CardSetContainersTest::cardset_bitmap_test(uint threshold, uint size_in_bits) {\n+  uint8_t* cardset_data = NEW_C_HEAP_ARRAY(uint8_t, G1CardSetBitMap::size_in_bytes(size_in_bits), mtGC);\n+  G1CardSetBitMap* cards = new (cardset_data) G1CardSetBitMap(1, size_in_bits);\n+\n+  ASSERT_TRUE(cards->contains(1, size_in_bits)); \/\/ Added during initialization\n+  ASSERT_TRUE(cards->num_bits_set() == 1); \/\/ Should be the only one.\n+\n+  G1AddCardResult res;\n+\n+  for (uint i = 1; i < threshold; i++) {\n+    res = cards->add(i + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Added);\n+  }\n+\n+  for (uint i = 0; i < threshold; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1, size_in_bits));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < threshold; i++) {\n+    res = cards->add(i + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    res = cards->add(threshold + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < threshold; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1, size_in_bits));\n+  }\n+\n+  ASSERT_TRUE(!cards->contains(0, size_in_bits));\n+\n+  \/\/ Verify iteration finds all cards too.\n+  {\n+    G1FindCardsInRange found(1, threshold + 1);\n+    cards->iterate(found, size_in_bits, 0);\n+    found.verify_part_found(threshold);\n+  }\n+\n+  FREE_C_HEAP_ARRAY(mtGC, cardset_data);\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_inptr_test) {\n+  uint const min = (uint)log2i(HeapRegionBounds::min_size());\n+  uint const max = (uint)log2i(HeapRegionBounds::max_size());\n+\n+  for (uint i = min; i <= max; i++) {\n+    G1CardSetContainersTest::cardset_inlineptr_test(i - CardTable::card_shift);\n+  }\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_array_test) {\n+  uint array_sizes[] = { 5, 9, 63, 77, 127 };\n+\n+  for (uint i = 0; i < ARRAY_SIZE(array_sizes); i++) {\n+    size_t const max_cards_in_set = ARRAY_SIZE(array_sizes);\n+    G1CardSetContainersTest::cardset_array_test(max_cards_in_set);\n+  }\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_bitmap_test) {\n+  uint bit_sizes[] = { 64, 2048 };\n+  uint threshold_sizes[] = { 17, 330 };\n+\n+  for (uint i = 0; i < ARRAY_SIZE(bit_sizes); i++) {\n+    G1CardSetContainersTest::cardset_bitmap_test(threshold_sizes[i], bit_sizes[i]);\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSetContainers.cpp","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -44,1 +44,0 @@\n-  ASSERT_TRUE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n@@ -48,0 +47,1 @@\n+  ASSERT_TRUE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyYoungEvacFail));\n@@ -54,1 +54,0 @@\n-  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n@@ -58,0 +57,1 @@\n+  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyYoungEvacFail));\n@@ -82,3 +82,0 @@\n-\n-  \/\/ Enabling all is not the same as G1VerifyAll\n-  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1HeapVerifier.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,7 +29,0 @@\n-class ScopedDisabledBiasedLocking {\n-  bool _orig;\n-public:\n-  ScopedDisabledBiasedLocking() : _orig(UseBiasedLocking) { UseBiasedLocking = false; }\n-  ~ScopedDisabledBiasedLocking() { UseBiasedLocking = _orig; }\n-};\n-\n@@ -59,4 +52,0 @@\n-  \/\/ Need to disable biased locking to easily\n-  \/\/ create oops that \"must_be_preseved\"\n-  ScopedDisabledBiasedLocking dbl;\n-\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -54,6 +53,0 @@\n-static void assert_not_test_pattern(Handle object, const char* pattern) {\n-  stringStream st;\n-  object->print_on(&st);\n-  ASSERT_FALSE(test_pattern(&st, pattern)) << pattern << \" found in \" << st.as_string();\n-}\n-\n@@ -96,21 +89,1 @@\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    \/\/ Can't test this with biased locking disabled.\n-    \/\/ Biased locking is initially enabled for this java.lang.Byte object.\n-    assert_test_pattern(h_obj, \"is_biased\");\n-\n-    \/\/ Lock using biased locking.\n-    BasicObjectLock lock;\n-    lock.set_obj(obj);\n-    markWord prototype_header = obj->klass()->prototype_header();\n-    markWord mark = obj->mark();\n-    markWord biased_mark = markWord::encode((JavaThread*) THREAD, mark.age(), prototype_header.bias_epoch());\n-    obj->set_mark(biased_mark);\n-    \/\/ Look for the biased_locker in markWord, not prototype_header.\n-#ifdef _LP64\n-    assert_not_test_pattern(h_obj, \"mark(is_biased biased_locker=0x0000000000000000\");\n-#else\n-    assert_not_test_pattern(h_obj, \"mark(is_biased biased_locker=0x00000000\");\n-#endif\n-  }\n-\n-  \/\/ Same thread tries to lock it again.\n+  \/\/ Thread tries to lock it.\n@@ -121,2 +94,0 @@\n-\n-  \/\/ This is no longer biased, because ObjectLocker revokes the bias.\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,302 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/lockFreeQueue.inline.hpp\"\n-#include \"utilities\/pair.hpp\"\n-#include \"threadHelper.inline.hpp\"\n-#include \"unittest.hpp\"\n-#include <new>\n-\n-class LockFreeQueueTestElement {\n-  typedef LockFreeQueueTestElement Element;\n-\n-  Element* volatile _entry;\n-  Element* volatile _entry1;\n-  size_t _id;\n-\n-  static Element* volatile* entry_ptr(Element& e) { return &e._entry; }\n-  static Element* volatile* entry1_ptr(Element& e) { return &e._entry1; }\n-\n-public:\n-  class TestQueue: public LockFreeQueue<Element, &entry_ptr> {\n-  public:\n-    Element* pop() {\n-      using Status = LockFreeQueuePopStatus;\n-      while (true) {\n-        Pair<Status, Element*> pop_result = try_pop();\n-        if (pop_result.first == Status::success) {\n-          return pop_result.second;\n-        }\n-        \/\/ Retry until success.\n-      }\n-    }\n-  };\n-  class TestQueue1: public LockFreeQueue<Element, &entry1_ptr> {\n-  public:\n-    Element* pop() {\n-      using Status = LockFreeQueuePopStatus;\n-      while (true) {\n-        Pair<Status, Element*> pop_result = try_pop();\n-        if (pop_result.first == Status::success) {\n-          return pop_result.second;\n-        }\n-        \/\/ Retry until success.\n-      }\n-    }\n-  };\n-\n-  LockFreeQueueTestElement(size_t id = 0) : _entry(), _entry1(), _id(id) {}\n-  size_t id() const { return _id; }\n-  void set_id(size_t value) { _id = value; }\n-  Element* next() { return _entry; }\n-  Element* next1() { return _entry1; }\n-};\n-\n-typedef LockFreeQueueTestElement Element;\n-typedef Element::TestQueue TestQueue;\n-typedef Element::TestQueue1 TestQueue1;\n-\n-static void initialize(Element* elements, size_t size, TestQueue* queue) {\n-  for (size_t i = 0; i < size; ++i) {\n-    elements[i].set_id(i);\n-  }\n-  ASSERT_TRUE(queue->empty());\n-  ASSERT_EQ(0u, queue->length());\n-  ASSERT_TRUE(queue->pop() == NULL);\n-  ASSERT_TRUE(queue->top() == NULL);\n-\n-  for (size_t id = 0; id < size; ++id) {\n-    ASSERT_EQ(id, queue->length());\n-    Element* e = &elements[id];\n-    ASSERT_EQ(id, e->id());\n-    queue->push(*e);\n-    ASSERT_FALSE(queue->empty());\n-    \/\/ top() is always the oldest element.\n-    ASSERT_EQ(&elements[0], queue->top());\n-  }\n-}\n-\n-class LockFreeQueueTestBasics : public ::testing::Test {\n-public:\n-  LockFreeQueueTestBasics();\n-\n-  static const size_t nelements = 10;\n-  Element elements[nelements];\n-  TestQueue queue;\n-};\n-\n-const size_t LockFreeQueueTestBasics::nelements;\n-\n-LockFreeQueueTestBasics::LockFreeQueueTestBasics() : queue() {\n-  initialize(elements, nelements, &queue);\n-}\n-\n-TEST_F(LockFreeQueueTestBasics, pop) {\n-  for (size_t i = 0; i < nelements; ++i) {\n-    ASSERT_FALSE(queue.empty());\n-    ASSERT_EQ(nelements - i, queue.length());\n-    Element* e = queue.pop();\n-    ASSERT_TRUE(e != NULL);\n-    ASSERT_EQ(&elements[i], e);\n-    ASSERT_EQ(i, e->id());\n-  }\n-  ASSERT_TRUE(queue.empty());\n-  ASSERT_EQ(0u, queue.length());\n-  ASSERT_TRUE(queue.pop() == NULL);\n-}\n-\n-TEST_F(LockFreeQueueTestBasics, append) {\n-  TestQueue other_queue;\n-  ASSERT_TRUE(other_queue.empty());\n-  ASSERT_EQ(0u, other_queue.length());\n-  ASSERT_TRUE(other_queue.top() == NULL);\n-  ASSERT_TRUE(other_queue.pop() == NULL);\n-\n-  Pair<Element*, Element*> pair = queue.take_all();\n-  other_queue.append(*pair.first, *pair.second);\n-  ASSERT_EQ(nelements, other_queue.length());\n-  ASSERT_TRUE(queue.empty());\n-  ASSERT_EQ(0u, queue.length());\n-  ASSERT_TRUE(queue.pop() == NULL);\n-  ASSERT_TRUE(queue.top() == NULL);\n-\n-  for (size_t i = 0; i < nelements; ++i) {\n-    ASSERT_EQ(nelements - i, other_queue.length());\n-    Element* e = other_queue.pop();\n-    ASSERT_TRUE(e != NULL);\n-    ASSERT_EQ(&elements[i], e);\n-    ASSERT_EQ(i, e->id());\n-  }\n-  ASSERT_EQ(0u, other_queue.length());\n-  ASSERT_TRUE(other_queue.pop() == NULL);\n-}\n-\n-TEST_F(LockFreeQueueTestBasics, two_queues) {\n-  TestQueue1 queue1;\n-  ASSERT_TRUE(queue1.pop() == NULL);\n-\n-  for (size_t id = 0; id < nelements; ++id) {\n-    queue1.push(elements[id]);\n-  }\n-  ASSERT_EQ(nelements, queue1.length());\n-  Element* e0 = queue.top();\n-  Element* e1 = queue1.top();\n-  while (true) {\n-    ASSERT_EQ(e0, e1);\n-    if (e0 == NULL) break;\n-    e0 = e0->next();\n-    e1 = e1->next1();\n-  }\n-\n-  for (size_t i = 0; i < nelements; ++i) {\n-    ASSERT_EQ(nelements - i, queue.length());\n-    ASSERT_EQ(nelements - i, queue1.length());\n-\n-    Element* e = queue.pop();\n-    ASSERT_TRUE(e != NULL);\n-    ASSERT_EQ(&elements[i], e);\n-    ASSERT_EQ(i, e->id());\n-\n-    Element* e1 = queue1.pop();\n-    ASSERT_TRUE(e1 != NULL);\n-    ASSERT_EQ(&elements[i], e1);\n-    ASSERT_EQ(i, e1->id());\n-\n-    ASSERT_EQ(e, e1);\n-  }\n-  ASSERT_EQ(0u, queue.length());\n-  ASSERT_EQ(0u, queue1.length());\n-  ASSERT_TRUE(queue.pop() == NULL);\n-  ASSERT_TRUE(queue1.pop() == NULL);\n-}\n-\n-class LockFreeQueueTestThread : public JavaTestThread {\n-  uint _id;\n-  TestQueue* _from;\n-  TestQueue* _to;\n-  volatile size_t* _processed;\n-  size_t _process_limit;\n-  size_t _local_processed;\n-  volatile bool _ready;\n-\n-public:\n-  LockFreeQueueTestThread(Semaphore* post,\n-                          uint id,\n-                          TestQueue* from,\n-                          TestQueue* to,\n-                          volatile size_t* processed,\n-                          size_t process_limit) :\n-    JavaTestThread(post),\n-    _id(id),\n-    _from(from),\n-    _to(to),\n-    _processed(processed),\n-    _process_limit(process_limit),\n-    _local_processed(0),\n-    _ready(false)\n-  {}\n-\n-  virtual void main_run() {\n-    Atomic::release_store_fence(&_ready, true);\n-    while (true) {\n-      Element* e = _from->pop();\n-      if (e != NULL) {\n-        _to->push(*e);\n-        Atomic::inc(_processed);\n-        ++_local_processed;\n-      } else if (Atomic::load_acquire(_processed) == _process_limit) {\n-        tty->print_cr(\"thread %u processed \" SIZE_FORMAT, _id, _local_processed);\n-        return;\n-      }\n-    }\n-  }\n-\n-  bool ready() const { return Atomic::load_acquire(&_ready); }\n-};\n-\n-TEST_VM(LockFreeQueueTest, stress) {\n-  Semaphore post;\n-  TestQueue initial_queue;\n-  TestQueue start_queue;\n-  TestQueue middle_queue;\n-  TestQueue final_queue;\n-  volatile size_t stage1_processed = 0;\n-  volatile size_t stage2_processed = 0;\n-\n-  const size_t nelements = 10000;\n-  Element* elements = NEW_C_HEAP_ARRAY(Element, nelements, mtOther);\n-  for (size_t id = 0; id < nelements; ++id) {\n-    ::new (&elements[id]) Element(id);\n-    initial_queue.push(elements[id]);\n-  }\n-  ASSERT_EQ(nelements, initial_queue.length());\n-\n-  \/\/ - stage1 threads pop from start_queue and push to middle_queue.\n-  \/\/ - stage2 threads pop from middle_queue and push to final_queue.\n-  \/\/ - all threads in a stage count the number of elements processed in\n-  \/\/   their corresponding stageN_processed counter.\n-\n-  const uint stage1_threads = 2;\n-  const uint stage2_threads = 2;\n-  const uint nthreads = stage1_threads + stage2_threads;\n-  LockFreeQueueTestThread* threads[nthreads] = {};\n-\n-  for (uint i = 0; i < ARRAY_SIZE(threads); ++i) {\n-    TestQueue* from = &start_queue;\n-    TestQueue* to = &middle_queue;\n-    volatile size_t* processed = &stage1_processed;\n-    if (i >= stage1_threads) {\n-      from = &middle_queue;\n-      to = &final_queue;\n-      processed = &stage2_processed;\n-    }\n-    threads[i] =\n-      new LockFreeQueueTestThread(&post, i, from, to, processed, nelements);\n-    threads[i]->doit();\n-    while (!threads[i]->ready()) {} \/\/ Wait until ready to start test.\n-  }\n-\n-  \/\/ Transfer elements to start_queue to start test.\n-  Pair<Element*, Element*> pair = initial_queue.take_all();\n-  start_queue.append(*pair.first, *pair.second);\n-\n-  \/\/ Wait for all threads to complete.\n-  for (uint i = 0; i < nthreads; ++i) {\n-    post.wait();\n-  }\n-\n-  \/\/ Verify expected state.\n-  ASSERT_EQ(nelements, stage1_processed);\n-  ASSERT_EQ(nelements, stage2_processed);\n-  ASSERT_EQ(0u, initial_queue.length());\n-  ASSERT_EQ(0u, start_queue.length());\n-  ASSERT_EQ(0u, middle_queue.length());\n-  ASSERT_EQ(nelements, final_queue.length());\n-  while (final_queue.pop() != NULL) {}\n-\n-  FREE_C_HEAP_ARRAY(Element, elements);\n-}\n","filename":"test\/hotspot\/gtest\/utilities\/test_lockFreeQueue.cpp","additions":0,"deletions":302,"binary":false,"changes":302,"status":"deleted"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/nonblockingQueue.inline.hpp\"\n+#include \"utilities\/pair.hpp\"\n+#include \"threadHelper.inline.hpp\"\n+#include \"unittest.hpp\"\n+#include <new>\n+\n+class NonblockingQueueTestElement {\n+  typedef NonblockingQueueTestElement Element;\n+\n+  Element* volatile _entry;\n+  Element* volatile _entry1;\n+  size_t _id;\n+\n+  static Element* volatile* entry_ptr(Element& e) { return &e._entry; }\n+  static Element* volatile* entry1_ptr(Element& e) { return &e._entry1; }\n+\n+public:\n+  using TestQueue = NonblockingQueue<Element, &entry_ptr>;\n+  using TestQueue1 = NonblockingQueue<Element, &entry1_ptr>;\n+\n+  NonblockingQueueTestElement(size_t id = 0) : _entry(), _entry1(), _id(id) {}\n+  size_t id() const { return _id; }\n+  void set_id(size_t value) { _id = value; }\n+  Element* next() { return _entry; }\n+  Element* next1() { return _entry1; }\n+};\n+\n+typedef NonblockingQueueTestElement Element;\n+typedef Element::TestQueue TestQueue;\n+typedef Element::TestQueue1 TestQueue1;\n+\n+static void initialize(Element* elements, size_t size, TestQueue* queue) {\n+  for (size_t i = 0; i < size; ++i) {\n+    elements[i].set_id(i);\n+  }\n+  ASSERT_TRUE(queue->empty());\n+  ASSERT_EQ(0u, queue->length());\n+  ASSERT_TRUE(queue->is_end(queue->first()));\n+  ASSERT_TRUE(queue->pop() == NULL);\n+\n+  for (size_t id = 0; id < size; ++id) {\n+    ASSERT_EQ(id, queue->length());\n+    Element* e = &elements[id];\n+    ASSERT_EQ(id, e->id());\n+    queue->push(*e);\n+    ASSERT_FALSE(queue->empty());\n+    \/\/ first() is always the oldest element.\n+    ASSERT_EQ(&elements[0], queue->first());\n+  }\n+}\n+\n+class NonblockingQueueTestBasics : public ::testing::Test {\n+public:\n+  NonblockingQueueTestBasics();\n+\n+  static const size_t nelements = 10;\n+  Element elements[nelements];\n+  TestQueue queue;\n+};\n+\n+const size_t NonblockingQueueTestBasics::nelements;\n+\n+NonblockingQueueTestBasics::NonblockingQueueTestBasics() : queue() {\n+  initialize(elements, nelements, &queue);\n+}\n+\n+TEST_F(NonblockingQueueTestBasics, pop) {\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_FALSE(queue.empty());\n+    ASSERT_EQ(nelements - i, queue.length());\n+    Element* e = queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+  }\n+  ASSERT_TRUE(queue.empty());\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_TRUE(queue.pop() == NULL);\n+}\n+\n+TEST_F(NonblockingQueueTestBasics, append) {\n+  TestQueue other_queue;\n+  ASSERT_TRUE(other_queue.empty());\n+  ASSERT_EQ(0u, other_queue.length());\n+  ASSERT_TRUE(other_queue.is_end(other_queue.first()));\n+  ASSERT_TRUE(other_queue.pop() == NULL);\n+\n+  Pair<Element*, Element*> pair = queue.take_all();\n+  other_queue.append(*pair.first, *pair.second);\n+  ASSERT_EQ(nelements, other_queue.length());\n+  ASSERT_TRUE(queue.empty());\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_TRUE(queue.is_end(queue.first()));\n+  ASSERT_TRUE(queue.pop() == NULL);\n+\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_EQ(nelements - i, other_queue.length());\n+    Element* e = other_queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+  }\n+  ASSERT_EQ(0u, other_queue.length());\n+  ASSERT_TRUE(other_queue.pop() == NULL);\n+}\n+\n+TEST_F(NonblockingQueueTestBasics, two_queues) {\n+  TestQueue1 queue1;\n+  ASSERT_TRUE(queue1.pop() == NULL);\n+\n+  for (size_t id = 0; id < nelements; ++id) {\n+    queue1.push(elements[id]);\n+  }\n+  ASSERT_EQ(nelements, queue1.length());\n+  Element* e0 = queue.first();\n+  Element* e1 = queue1.first();\n+  ASSERT_TRUE(e0 != NULL);\n+  ASSERT_TRUE(e1 != NULL);\n+  ASSERT_FALSE(queue.is_end(e0));\n+  ASSERT_FALSE(queue1.is_end(e1));\n+  while (!queue.is_end(e0) && !queue1.is_end(e1)) {\n+    ASSERT_EQ(e0, e1);\n+    e0 = e0->next();\n+    e1 = e1->next1();\n+  }\n+  ASSERT_TRUE(queue.is_end(e0));\n+  ASSERT_TRUE(queue1.is_end(e1));\n+\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_EQ(nelements - i, queue.length());\n+    ASSERT_EQ(nelements - i, queue1.length());\n+\n+    Element* e = queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+\n+    Element* e1 = queue1.pop();\n+    ASSERT_TRUE(e1 != NULL);\n+    ASSERT_EQ(&elements[i], e1);\n+    ASSERT_EQ(i, e1->id());\n+\n+    ASSERT_EQ(e, e1);\n+  }\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_EQ(0u, queue1.length());\n+  ASSERT_TRUE(queue.pop() == NULL);\n+  ASSERT_TRUE(queue1.pop() == NULL);\n+}\n+\n+class NonblockingQueueTestThread : public JavaTestThread {\n+  uint _id;\n+  TestQueue* _from;\n+  TestQueue* _to;\n+  volatile size_t* _processed;\n+  size_t _process_limit;\n+  size_t _local_processed;\n+  volatile bool _ready;\n+\n+public:\n+  NonblockingQueueTestThread(Semaphore* post,\n+                             uint id,\n+                             TestQueue* from,\n+                             TestQueue* to,\n+                             volatile size_t* processed,\n+                             size_t process_limit) :\n+    JavaTestThread(post),\n+    _id(id),\n+    _from(from),\n+    _to(to),\n+    _processed(processed),\n+    _process_limit(process_limit),\n+    _local_processed(0),\n+    _ready(false)\n+  {}\n+\n+  virtual void main_run() {\n+    Atomic::release_store_fence(&_ready, true);\n+    while (true) {\n+      Element* e = _from->pop();\n+      if (e != NULL) {\n+        _to->push(*e);\n+        Atomic::inc(_processed);\n+        ++_local_processed;\n+      } else if (Atomic::load_acquire(_processed) == _process_limit) {\n+        tty->print_cr(\"thread %u processed \" SIZE_FORMAT, _id, _local_processed);\n+        return;\n+      }\n+    }\n+  }\n+\n+  bool ready() const { return Atomic::load_acquire(&_ready); }\n+};\n+\n+TEST_VM(NonblockingQueueTest, stress) {\n+  Semaphore post;\n+  TestQueue initial_queue;\n+  TestQueue start_queue;\n+  TestQueue middle_queue;\n+  TestQueue final_queue;\n+  volatile size_t stage1_processed = 0;\n+  volatile size_t stage2_processed = 0;\n+\n+  const size_t nelements = 10000;\n+  Element* elements = NEW_C_HEAP_ARRAY(Element, nelements, mtOther);\n+  for (size_t id = 0; id < nelements; ++id) {\n+    ::new (&elements[id]) Element(id);\n+    initial_queue.push(elements[id]);\n+  }\n+  ASSERT_EQ(nelements, initial_queue.length());\n+\n+  \/\/ - stage1 threads pop from start_queue and push to middle_queue.\n+  \/\/ - stage2 threads pop from middle_queue and push to final_queue.\n+  \/\/ - all threads in a stage count the number of elements processed in\n+  \/\/   their corresponding stageN_processed counter.\n+\n+  const uint stage1_threads = 2;\n+  const uint stage2_threads = 2;\n+  const uint nthreads = stage1_threads + stage2_threads;\n+  NonblockingQueueTestThread* threads[nthreads] = {};\n+\n+  for (uint i = 0; i < ARRAY_SIZE(threads); ++i) {\n+    TestQueue* from = &start_queue;\n+    TestQueue* to = &middle_queue;\n+    volatile size_t* processed = &stage1_processed;\n+    if (i >= stage1_threads) {\n+      from = &middle_queue;\n+      to = &final_queue;\n+      processed = &stage2_processed;\n+    }\n+    threads[i] =\n+      new NonblockingQueueTestThread(&post, i, from, to, processed, nelements);\n+    threads[i]->doit();\n+    while (!threads[i]->ready()) {} \/\/ Wait until ready to start test.\n+  }\n+\n+  \/\/ Transfer elements to start_queue to start test.\n+  Pair<Element*, Element*> pair = initial_queue.take_all();\n+  start_queue.append(*pair.first, *pair.second);\n+\n+  \/\/ Wait for all threads to complete.\n+  for (uint i = 0; i < nthreads; ++i) {\n+    post.wait();\n+  }\n+\n+  \/\/ Verify expected state.\n+  ASSERT_EQ(nelements, stage1_processed);\n+  ASSERT_EQ(nelements, stage2_processed);\n+  ASSERT_EQ(0u, initial_queue.length());\n+  ASSERT_EQ(0u, start_queue.length());\n+  ASSERT_EQ(0u, middle_queue.length());\n+  ASSERT_EQ(nelements, final_queue.length());\n+  while (final_queue.pop() != NULL) {}\n+\n+  FREE_C_HEAP_ARRAY(Element, elements);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_nonblockingQueue.cpp","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -35,2 +35,0 @@\n-\n-serviceability\/sa\/ClhsdbJstackXcompStress.java 8268570 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,4 +43,0 @@\n-\n-serviceability\/dcmd\/framework\/HelpTest.java                   8268433 windows-x64\n-serviceability\/dcmd\/framework\/InvalidCommandTest.java         8268433 windows-x64\n-serviceability\/dcmd\/framework\/VMVersionTest.java              8268433 windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,5 +107,1 @@\n-serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8268570 generic-all\n-serviceability\/attach\/RemovingUnixDomainSocketTest.java 8268570 generic-all\n-serviceability\/sa\/TestJhsdbJstackLock.java 8268570 generic-all\n-serviceability\/sa\/JhsdbThreadInfoTest.java 8268570 generic-all\n-\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062 macosx-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8268362\n+ * @requires vm.compiler2.enabled & vm.debug\n+ * @summary C2 using negative array length as index, using a.length.\n+ *          AllocateArrayNode::make_ideal_length create CastIINode to not negative range.\n+ *          Apply transform in GraphKit::load_array_length will covert array load index type to top.\n+ *          This cause assert in Parse::array_addressing, it expect index type is int.\n+ * @run main\/othervm -XX:-PrintCompilation compiler.arraycopy.TestNegArrayLengthAsIndex1\n+ *\/\n+\n+package compiler.arraycopy;\n+public class TestNegArrayLengthAsIndex1 {\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < 10000; i++) {\n+            foo();\n+        }\n+    }\n+\n+    static int foo() {\n+        int minusOne = -1;\n+        int[] a = null;\n+        try {\n+            a = new int[minusOne];\n+        } catch (NegativeArraySizeException e) {\n+           return 0;\n+        }\n+        return a[a.length - 1];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestNegArrayLengthAsIndex1.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8268362\n+ * @requires vm.compiler2.enabled & vm.debug\n+ * @summary C2 using negative array length as index, using array allocation length.\n+ *          This assertion is triggered by 8267904.\n+ * @run main\/othervm compiler.arraycopy.TestNegArrayLengthAsIndex2\n+ *\/\n+\n+package compiler.arraycopy;\n+public class TestNegArrayLengthAsIndex2 {\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < 10000; i++) {\n+            foo();\n+        }\n+    }\n+\n+    static int foo() {\n+        int minusOne = -1;\n+        int[] a = null;\n+        try {\n+            a = new int[minusOne];\n+        } catch (NegativeArraySizeException e) {\n+           return 0;\n+        }\n+        return a[minusOne - 1];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestNegArrayLengthAsIndex2.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8267904\n+ * @requires vm.compiler2.enabled\n+ * @summary C2 inline array_copy move CastIINode(Array Length) before allocation cause crash.\n+ * @run main\/othervm compiler.arraycopy.TestNegativeArrayCopyAfterLoop\n+ *\/\n+\n+package compiler.arraycopy;\n+import java.util.Arrays;\n+\n+class test {\n+    public static int exp_count = 0;\n+    public int in1 = -4096;\n+    test (){\n+        try {\n+            short sha4[] = new short[1012];\n+            for (int i = 0; i < sha4.length; i++) {\n+              sha4[i] = 9;\n+            }\n+            Arrays.copyOf(sha4, in1);\n+        } catch (Exception ex) {\n+            exp_count++;\n+        }\n+    }\n+}\n+\n+public class TestNegativeArrayCopyAfterLoop {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20000; i++) {\n+            new test();\n+        }\n+        if (test.exp_count == 20000) {\n+            System.out.println(\"TEST PASSED\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestNegativeArrayCopyAfterLoop.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c1;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+\n+\/*\n+ * @test\n+ * @author Chris Cole\n+ * @bug 8267042\n+ * @summary missing displaced_header initialization causes hangup\n+ * @run main\/othervm -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ *                   -XX:-BackgroundCompilation -XX:CompileThreshold=1\n+ *                   -XX:CompileOnly=compiler.c1.Test8267042::write\n+ *                   compiler.c1.Test8267042\n+ *\/\n+public class Test8267042 {\n+\n+    private static int DATA_SIZE = 4;\n+\n+    private char buffer;\n+    private boolean empty = true;\n+\n+    public static void main(String[] args) {\n+        Test8267042 test = new Test8267042();\n+        test.run();\n+    }\n+\n+    private void run() {\n+        System.out.println(\"Starting test\");\n+\n+        Thread writeThread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                char data[] = new char[DATA_SIZE];\n+                try {\n+                    write(data, 0, data.length);\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+        writeThread.setDaemon(true);\n+        writeThread.start();\n+\n+        Thread readThread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    for (int i = 0; i < DATA_SIZE; i++) {\n+                        read();\n+                    }\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+        readThread.setDaemon(true);\n+        readThread.start();\n+\n+        try {\n+            writeThread.join(5000);\n+            if (writeThread.isAlive()) {\n+                throw new InternalError(\"write thread deadlocked\");\n+            }\n+            readThread.join(5000);\n+            if (readThread.isAlive()) {\n+                throw new InternalError(\"read thread deadlocked\");\n+            }\n+        } catch (InterruptedException e) {\n+            throw new InternalError(\"unexpected InterrruptedException while waiting to join threads\", e);\n+        }\n+        System.out.println(\"Test passed\");\n+    }\n+\n+    synchronized void write(char data[], int offset, int length) throws IOException {\n+        while (--length >= 0) {\n+            getZeroOnStack(offset);\n+            write(data[offset++]);\n+        }\n+    }\n+\n+    synchronized void write(int c) throws IOException {\n+        while (!empty) {\n+            try {\n+                wait(1000);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedIOException();\n+            }\n+        }\n+        buffer = (char) c;\n+        empty = false;\n+        notifyAll();\n+    }\n+\n+    public synchronized int read() throws IOException {\n+        while (empty) {\n+            try {\n+                System.out.println(\"read() before wait\");\n+                wait(1000);\n+                System.out.println(\"read() after wait\");\n+            } catch (InterruptedException e) {\n+                throw new InterruptedIOException();\n+            }\n+        }\n+        int value = buffer;\n+        empty = true;\n+        notifyAll();\n+        return value;\n+    }\n+\n+    private void getZeroOnStack(int offset) {\n+        int l1;\n+        int l2;\n+        int l3;\n+        int l4;\n+        int l5;\n+        int l6;\n+        int l7;\n+        int l8;\n+        int l9;\n+        int l10;\n+        int l11;\n+        int l12;\n+        int l13;\n+        int l14;\n+        int l15;\n+        int l16;\n+\n+        l1 = 0;\n+        l2 = 0;\n+        l3 = 0;\n+        l4 = 0;\n+        l5 = 0;\n+        l6 = 0;\n+        l7 = 0;\n+        l8 = 0;\n+        l9 = 0;\n+        l10 = 0;\n+        l11 = 0;\n+        l12 = 0;\n+        l13 = 0;\n+        l14 = 0;\n+        l15 = 0;\n+        l16 = 0;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/Test8267042.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8062950\n- * @requires vm.flavor == \"server\"\n- * @library \/test\/lib\n- * @run driver compiler.c2.Test8062950\n- *\/\n-\n-package compiler.c2;\n-\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class Test8062950 {\n-    private static final String CLASSNAME = \"DoesNotExist\";\n-    public static void main(String[] args) throws Exception {\n-        ProcessTools.executeTestJvm(\"-Xcomp\",\n-                                    \"-XX:-TieredCompilation\",\n-                                    \"-XX:-UseOptoBiasInlining\",\n-                                    CLASSNAME)\n-                    .shouldHaveExitValue(1)\n-                    .shouldContain(\"Error: Could not find or load main class \" + CLASSNAME)\n-                    .shouldNotContain(\"A fatal error has been detected\")\n-                    .shouldNotContain(\"Internal Error\")\n-                    .shouldNotContain(\"HotSpot Virtual Machine Error\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/Test8062950.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8217990\n- * @summary With -XX:+UseOptoBiasInlining loading the markword is replaced by 0L if EliminateLocks is disabled. assert(dmw->is_neutral()) failed: invariant fails.\n- * @author Richard Reingruber richard DOT reingruber AT sap DOT com\n- *\n- * @library \/test\/lib \/test\/hotspot\/jtreg\n- *\n- * @build sun.hotspot.WhiteBox\n- *\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n- *                   -XX:CompileCommand=compileonly,*.TestUseOptoBiasInliningWithoutEliminateLocks::dontinline_testMethod\n- *                   -XX:CompileCommand=dontinline,*::dontinline_*\n- *                   -XX:-EliminateLocks\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                   -Xbatch\n- *                   -XX:-TieredCompilation\n- *                   compiler.c2.TestUseOptoBiasInliningWithoutEliminateLocks\n- *\/\n-\n-package compiler.c2;\n-\n-import sun.hotspot.WhiteBox;\n-\n-public class TestUseOptoBiasInliningWithoutEliminateLocks {\n-\n-    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n-\n-    public static void main(String[] args) {\n-        new TestUseOptoBiasInliningWithoutEliminateLocks().run();\n-    }\n-\n-    public boolean warmupDone;\n-\n-    public void run() {\n-        for(int i = 0; i < 30000; i++) {\n-            dontinline_testMethod();\n-        }\n-        warmupDone = true;\n-        dontinline_testMethod();\n-    }\n-\n-    public void dontinline_testMethod() {\n-        PointXY l1 = new PointXY(4.0f, 2.0f);\n-        synchronized (l1) {\n-            dontinline_deopt();\n-        }\n-    }\n-\n-    public void dontinline_deopt() {\n-        if (warmupDone) {\n-            WB.deoptimizeFrames(false);\n-        }\n-    }\n-\n-    static class PointXY {\n-\n-        public float fritz;\n-        public float felix;\n-\n-        public PointXY(float fritz_param, float felix_param) {\n-            this.fritz = fritz_param;\n-\/\/            this.felix = felix_param;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUseOptoBiasInliningWithoutEliminateLocks.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -61,1 +61,1 @@\n-                if (!out.getOutput().contains(\"-XX:+TieredCompilation not supported in this VM\")) {\n+                if (Platform.isTieredSupported()) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckSegmentedCodeCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,8 @@\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8001183\n+ * @summary incorrect results of char vectors right shift operation\n+ * @requires vm.compiler2.enabled | vm.graal.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestCharVect2.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8267399\n+ * @summary C2: java\/text\/Normalizer\/ConformanceTest.java test failed with assertion\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation TestDeadCountedLoop\n+ *\n+ *\/\n+\n+public class TestDeadCountedLoop {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(true, new int[10], false, 0, 1);\n+            test(false, new int[10], false, 0, 1);\n+        }\n+    }\n+\n+    private static int test(boolean flag, int[] array2, boolean flag2, int start, int stop) {\n+        if (array2 == null) {\n+        }\n+        int[] array;\n+        if (flag) {\n+            array = new int[1];\n+        } else {\n+            array = new int[2];\n+        }\n+        int len = array.length;\n+        int v = 1;\n+        for (int j = start; j < stop; j++) {\n+            for (int i = 0; i < len; i++) {\n+                if (i > 0) {\n+                    if (flag2) {\n+                        break;\n+                    }\n+                    v *= array2[i + j];\n+                }\n+            }\n+        }\n+\n+        return v;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeadCountedLoop.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -42,2 +42,0 @@\n-                                    \/\/ to prevent biased locking handshakes from changing the timing of this test\n-                                    \"-XX:-UseBiasedLocking\",\n@@ -60,2 +58,0 @@\n-                                    \/\/ to prevent biased locking handshakes from changing the timing of this test\n-                                    \"-XX:-UseBiasedLocking\",\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/CheckLoopStripMining.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8268672\n+ * @summary C2: assert(!loop->is_member(u_loop)) failed: can be in outer loop or out of both loops only\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestPinnedNodeInInnerLoop TestPinnedNodeInInnerLoop\n+ *\n+ *\/\n+\n+public class TestPinnedNodeInInnerLoop {\n+    boolean b;\n+    double d;\n+    int iArr[];\n+\n+    public static void main(String[] args) {\n+        TestPinnedNodeInInnerLoop t = new TestPinnedNodeInInnerLoop();\n+        for (int i = 0; i < 10; i++) {\n+            t.test();\n+        }\n+    }\n+\n+    void test() {\n+        int e = 4, f = -51874, g = 7, h = 0;\n+\n+        for (; f < 3; ++f) {\n+        }\n+        while (++g < 2) {\n+            if (b) {\n+                d = h;\n+            } else {\n+                iArr[g] = e;\n+            }\n+        }\n+        System.out.println(g);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/TestPinnedNodeInInnerLoop.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8183543\n+ * @summary C2 compilation often fails on aarch64 with \"failed spill-split-recycle sanity check\"\n+ *\n+ * @library \/test\/lib\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:-Inline\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:+PreserveFramePointer\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   compiler.regalloc.TestC2IntPressure\n+ *\/\n+\n+package compiler.regalloc;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class TestC2IntPressure {\n+\n+  static volatile int vol_f;\n+\n+  static void not_inlined() {\n+    \/\/ Do nothing\n+  }\n+\n+  static int test(TestC2IntPressure arg) {\n+    TestC2IntPressure a = arg;\n+    int res = 0;\n+    not_inlined();\n+    res = a.vol_f;\n+    return res;\n+  }\n+\n+  public static void main(String args[]) {\n+    TestC2IntPressure arg = new TestC2IntPressure();\n+    for (int i = 0; i < 10000; i++) {\n+      test(arg);\n+    }\n+    try {\n+      var method = TestC2IntPressure.class.getDeclaredMethod(\"test\", TestC2IntPressure.class);\n+      if (!WhiteBox.getWhiteBox().isMethodCompiled(method)) {\n+        throw new Error(\"test method didn't get compiled\");\n+      }\n+    } catch (NoSuchMethodException e) {\n+      throw new Error(\"TESTBUG : \" + e, e);\n+    }\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/regalloc\/TestC2IntPressure.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,0 @@\n-    protected static final String RTM_BIASED_LOCKING_WARNING\n-            = \"Biased locking is not supported with RTM locking; \"\n-            + \"ignoring UseBiasedLocking flag\";\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/RTMGenericCommandLineOptionTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify processing of UseRTMLocking and UseBiasedLocking\n- *          options combination on CPU, OS, and VM with rtm support.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMLockingOptionWithBiasedLocking\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMLockingOptionWithBiasedLocking {\n-\n-    public void runTestCases() throws Throwable {\n-        String warningMessage\n-                = RTMGenericCommandLineOptionTest.RTM_BIASED_LOCKING_WARNING;\n-        String shouldPassMessage = \"JVM startup should pass with both \"\n-                + \"-XX:+UseRTMLocking and \"\n-                + \"-XX:-UseBiasedLocking flags set without any warnings\";\n-        \/\/ verify that we will not get a warning\n-        CommandLineOptionTest.verifySameJVMStartup(null,\n-                new String[] { warningMessage }, shouldPassMessage,\n-                shouldPassMessage, ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", \"-XX:-UseBiasedLocking\");\n-\n-        \/\/ verify that we will get a warning\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[] { warningMessage }, null,\n-                \"JVM startup should pass when both -XX:+UseRTMLocking and \"\n-                        + \"-XX:+UseBiasedLocking flags set\",\n-                \"Flags -XX:+UseRTMLocking\"\n-                        + \" and -XX:+UseBiasedLocking conflicts. \"\n-                        + \"Warning should be shown.\", ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", \"-XX:+UseBiasedLocking\");\n-        \/\/ verify that UseBiasedLocking is false when we use rtm locking\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseBiasedLocking\",\n-                \"false\",\n-                \"Value of option 'UseBiasedLocking' should be false if\"\n-                        + \"-XX:+UseRTMLocking flag set.\",\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\");\n-        \/\/ verify that we can't turn on biased locking when\n-        \/\/ using rtm locking\n-        CommandLineOptionTest\n-                .verifyOptionValueForSameVM(\n-                        \"UseBiasedLocking\",\n-                        \"false\",\n-                        \"Value of option 'UseBiasedLocking' should be false if\"\n-                                + \"both -XX:+UseRTMLocking and \"\n-                                + \"-XX:+UseBiasedLocking flags set.\",\n-                        CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                        \"-XX:+UseRTMLocking\", \"-XX:+UseBiasedLocking\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMLockingOptionWithBiasedLocking().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMLockingOptionWithBiasedLocking.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8032011\n- * @summary biased locking's revoke_bias locks monitor in compiled frame with eliminated lock\n- *\n- * @run main\/othervm -XX:-UseOnStackReplacement\n- *      -XX:CompileCommand=dontinline,compiler.uncommontrap.TestLockEliminatedAtDeopt$A::m2\n- *      -XX:-BackgroundCompilation -XX:BiasedLockingStartupDelay=0\n- *      compiler.uncommontrap.TestLockEliminatedAtDeopt\n- *\/\n-\n-package compiler.uncommontrap;\n-\n-public class TestLockEliminatedAtDeopt {\n-\n-    static class A {\n-        void m() {\n-        }\n-\n-        \/\/ This lock is not eliminated but biased to main thread on\n-        \/\/ first call\n-        synchronized void m2(boolean trap) {\n-            if (trap) {\n-                new B();\n-            }\n-        }\n-    }\n-\n-    static class B extends A {\n-        void m() {\n-        }\n-    }\n-\n-    static void m1(boolean trap) {\n-        A a = new A();\n-        \/\/ This lock is eliminated by c2\n-        synchronized(a) {\n-            a.m2(trap);\n-            a.m();\n-        }\n-    }\n-\n-     public static void main(String[] args) {\n-        for (int i = 0; i < 20000; i++) {\n-            m1(false);\n-        }\n-        \/\/ Trigger uncommon trap in A.m2() (class unloaded) and\n-        \/\/ deoptimization of m1() (CHA invalidated). Uncommon trap\n-        \/\/ code locks monitor in m1's frame where's it's eliminated.\n-        m1(true);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestLockEliminatedAtDeopt.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n- * @run main\/othervm -XX:NewSize=10m -XX:+FullGCALot -XX:FullGCALotInterval=120 -XX:+UseBiasedLocking gc.TestFullGCALot\n","filename":"test\/hotspot\/jtreg\/gc\/TestFullGCALot.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n- * @run main\/othervm -XX:+UseLargePages gc.TestSystemGC\n-  *\/\n+ *\/\n@@ -56,0 +55,7 @@\n+\n+\/*\n+ * @test TestSystemGCLargePages\n+ * @summary Runs System.gc() with different flags.\n+ * @run main\/othervm -XX:+UseLargePages gc.TestSystemGC\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/TestSystemGC.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.arguments;\n+\n+\/*\n+ * @test TestG1RemSetFlags\n+ * @requires vm.gc.G1\n+ * @summary Verify that the remembered set flags are updated as expected\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.management\/sun.management\n+ * @library \/test\/lib\n+ * @library \/\n+ * @run driver gc.arguments.TestG1RemSetFlags\n+ *\/\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestG1RemSetFlags {\n+\n+  private static void checkG1RemSetFlags(String[] flags, int exitValue) throws Exception {\n+    ArrayList<String> flagList = new ArrayList<String>();\n+    flagList.addAll(Arrays.asList(flags));\n+    flagList.add(\"-XX:+UseG1GC\");\n+    flagList.add(\"-XX:+PrintFlagsFinal\");\n+    flagList.add(\"-version\");\n+\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flagList);\n+    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    output.shouldHaveExitValue(exitValue);\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=8\", \"-XX:G1RemSetHowlMaxNumBuckets=8\"  },  0);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=8\", \"-XX:G1RemSetHowlMaxNumBuckets=16\"  },  0);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=16\", \"-XX:G1RemSetHowlMaxNumBuckets=8\"  },  1);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=7\"  },  1);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlMaxNumBuckets=7\"  },  1);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1RemSetFlags.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -104,3 +104,8 @@\n-        new LogMessageWithLevel(\"Merged Sparse\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Fine\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Coarse\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Inline\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged ArrayOfCards\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Full\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl Inline\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl ArrayOfCards\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl BitMap\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl Full\", Level.DEBUG),\n@@ -138,0 +143,1 @@\n+        new LogMessageWithLevel(\"Sample Collection Set Candidates\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -Xlog:gc,gc+humongous=debug -XX:+UseG1GC -XX:MaxTenuringThreshold=0 -XX:G1RSetSparseRegionEntries=32 -XX:G1HeapRegionSize=1m -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.g1.TestNoEagerReclaimOfHumongousRegions\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xlog:gc,gc+humongous=debug -XX:+UseG1GC -XX:MaxTenuringThreshold=0 -XX:+UnlockExperimentalVMOptions -XX:G1RemSetArrayOfCardsEntries=32 -XX:G1HeapRegionSize=1m -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.g1.TestNoEagerReclaimOfHumongousRegions\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestNoEagerReclaimOfHumongousRegions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.Platform;\n@@ -55,0 +56,3 @@\n+        if (Platform.isDebugBuild()) {\n+            testYoungEvacFail();\n+        }\n@@ -118,0 +122,20 @@\n+    private static void testYoungEvacFail() throws Exception {\n+        OutputAnalyzer output;\n+        output = testWithVerificationType(new String[] {\"young-evac-fail\"},\n+                                          new String[] {\"-XX:+G1EvacuationFailureALot\",\n+                                                        \"-XX:G1EvacuationFailureALotCount=100\",\n+                                                        \"-XX:G1EvacuationFailureALotInterval=1\",\n+                                                        \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                        \"-XX:-G1AllowPreventiveGC\"});\n+        output.shouldHaveExitValue(0);\n+\n+        verifyCollection(\"Pause Young (Normal)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Concurrent Start)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Mixed)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Prepare Mixed)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Remark\", false, false, false, output.getStdout());\n+        verifyCollection(\"Pause Cleanup\", false, false, false, output.getStdout());\n+        verifyCollection(\"Pause Full\", false, false, false, output.getStdout());\n+    }\n+\n+\n@@ -124,1 +148,1 @@\n-        output.shouldMatch(\"VerifyGCType: '.*' is unknown. Available types are: young-normal, concurrent-start, mixed, remark, cleanup and full\");\n+        output.shouldMatch(\"VerifyGCType: '.*' is unknown. Available types are: young-normal, young-evac-fail, concurrent-start, mixed, remark, cleanup and full\");\n@@ -134,1 +158,1 @@\n-    private static OutputAnalyzer testWithVerificationType(String[] types) throws Exception {\n+    private static OutputAnalyzer testWithVerificationType(String[] types, String... extraOpts) throws Exception {\n@@ -154,0 +178,2 @@\n+        Collections.addAll(basicOpts, extraOpts);\n+\n@@ -158,0 +184,1 @@\n+\n@@ -231,0 +258,3 @@\n+\n+        \/\/ This class triggers GCs; we need to make sure that in all of the young gcs\n+        \/\/ at least some objects survive so that evacuation failure can happen.\n@@ -244,0 +274,2 @@\n+\n+            used = alloc1M();\n@@ -245,0 +277,1 @@\n+            partialFree(used);\n@@ -252,0 +285,1 @@\n+            used = alloc1M();\n@@ -253,0 +287,3 @@\n+            partialFree(used);\n+\n+            used = alloc1M();\n@@ -254,0 +291,1 @@\n+            partialFree(used);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerifyGCType.java","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+    private static final int CARDSIZE = 512; \/\/ Card size in bytes.\n+\n@@ -232,2 +234,2 @@\n-        \/\/ threshold for sparce -> fine\n-        final int FINE = WB.getIntxVMFlag(\"G1RSetSparseRegionEntries\").intValue();\n+        \/\/ Threshold for Array of Cards -> Howl\n+        final int ARRAY_TO_HOWL_THRESHOLD = WB.getUintVMFlag(\"G1RemSetArrayOfCardsEntries\").intValue();\n@@ -235,2 +237,4 @@\n-        \/\/ threshold for fine -> coarse\n-        final int COARSE = WB.getIntxVMFlag(\"G1RSetRegionEntries\").intValue();\n+        \/\/ Threshold for Howl -> Full\n+        int coarsenHowlToFullPercent = WB.getUintVMFlag(\"G1RemSetCoarsenHowlToFullPercent\").intValue();\n+        int cardsPerRegion = WB.getSizeTVMFlag(\"G1HeapRegionSize\").intValue() \/ CARDSIZE;\n+        final int HOWL_TO_FULL_THRESHOLD = (cardsPerRegion * coarsenHowlToFullPercent) \/ 100;\n@@ -244,2 +248,7 @@\n-        int[] regToRegRefCounts = {0, FINE \/ 2, 0, FINE, (FINE + COARSE) \/ 2, 0,\n-            COARSE, COARSE + 10, FINE + 1, FINE \/ 2, 0};\n+        int[] regToRegRefCounts = {\n+            0, ARRAY_TO_HOWL_THRESHOLD \/ 2,\n+            0, ARRAY_TO_HOWL_THRESHOLD,\n+            (ARRAY_TO_HOWL_THRESHOLD + HOWL_TO_FULL_THRESHOLD) \/ 2, 0,\n+            HOWL_TO_FULL_THRESHOLD, HOWL_TO_FULL_THRESHOLD + 10,\n+            ARRAY_TO_HOWL_THRESHOLD + 1, ARRAY_TO_HOWL_THRESHOLD \/ 2,\n+            0};\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressRSetCoarsening.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:+PrintCommandLineFlags -XX:-ShowMessageBoxOnError -XX:BiasedLockingStartupDelay=4000 -XX:ParallelGCThreads=4 -XX:MaxRAM=1G -XX:ErrorFile=\"file\" PrintAsFlag\n+ * @run main\/othervm -XX:+PrintCommandLineFlags -XX:-ShowMessageBoxOnError -XX:ParallelGCThreads=4 -XX:MaxRAM=1G -XX:ErrorFile=\"file\" PrintAsFlag\n","filename":"test\/hotspot\/jtreg\/runtime\/7167069\/PrintAsFlag.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -233,2 +233,0 @@\n-        excludeTestMaxRange(\"G1RSetRegionEntries\");\n-        excludeTestMaxRange(\"G1RSetSparseRegionEntries\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,7 +45,3 @@\n-        {\"-Xint\", \"-XX:+UseBiasedLocking\"},\n-        {\"-Xint\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\", \"-XX:+UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseBiasedLocking\", \"-XX:+UseOptoBiasInlining\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseBiasedLocking\", \"-XX:-UseOptoBiasInlining\"}\n+        {\"-Xint\"},\n+        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\"},\n+        {\"-Xcomp\", \"-XX:-TieredCompilation\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/SyncOnValueBasedClassTest.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\"});\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"detail\"});\n@@ -62,1 +62,1 @@\n-        addr = wb.NMTMallocWithPseudoStackAndType(2 * 1024, pc, 8 \/* mtInternal *\/ );\n+        addr = wb.NMTMallocWithPseudoStackAndType(2 * 1024, pc, 9 \/* mtInternal *\/ );\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocSiteTypeChange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-            \/\/ i = 1 -- dump with agent = disable BiasedLocking\n-            \/\/ i = 2 -- dump with agent = enable BiasedLocking\n+            \/\/ i = 1 -- dump with agent\n@@ -67,1 +66,0 @@\n-            String biasedLock = (i != 2) ? \"-showversion\" : \"-XX:+UseBiasedLocking\";\n@@ -72,1 +70,1 @@\n-                                    agentArg, agentArg2, biasedLock);\n+                                    agentArg, agentArg2);\n@@ -79,1 +77,1 @@\n-                \"-XX:+UnlockDiagnosticVMOptions\", agentArg2, biasedLock,\n+                \"-XX:+UnlockDiagnosticVMOptions\", agentArg2,\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/LockDuringDump.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    protected static void test(String fileName, long pid,\n+    protected static OutputAnalyzer test(String fileName, long pid,\n@@ -203,0 +203,1 @@\n+        return output;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestDumpBase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8265465\n+ * @bug 8265465 8267075\n@@ -44,0 +44,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -46,0 +47,16 @@\n+    static final String promptStdout = \"please check stdout file\";\n+    static final String promptStderr = \"or stderr file\";\n+\n+    static void checkContainAbsoluteLogPath(OutputAnalyzer output) throws Exception {\n+       String stdText = output.getOutput();\n+       if (stdText.contains(promptStdout) &&\n+           stdText.contains(promptStderr)) {\n+           int a = stdText.indexOf(promptStdout);\n+           int b = stdText.indexOf(promptStderr);\n+           String stdOutFileName = stdText.substring(a + promptStdout.length() + 1, b - 1).trim();\n+           File   stdOutFile = new File(stdOutFileName);\n+           if (!stdOutFile.isAbsolute()) {\n+               throw new RuntimeException(\"Failed to set file name in absolute for prompting message\");\n+           }\n+        }\n+    }\n@@ -70,1 +87,0 @@\n-        app.stopApp();\n@@ -74,0 +90,7 @@\n+        \/\/ Illegal character in file name\n+        localFileName = \"mystatic:.jsa\";\n+        OutputAnalyzer output = test(localFileName, pid, noBoot,  EXPECT_FAIL);\n+        checkFileExistence(localFileName, false\/*exist*\/);\n+        checkContainAbsoluteLogPath(output);\n+        app.stopApp();\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestFileSafety.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268720\n+ * @summary Constant pool NameAndType entries with valid but incompatible method\n+ *          name and signature shouldn't cause an exception until referenced by\n+ *          a method_ref.\n+ * @compile nonVoidInitSig.jcod\n+ * @run main\/othervm -Xverify:remote NameAndTypeSig\n+ *\/\n+\n+\/\/ Test constant pool NameAndType descriptors with valid but incompatible method\n+\/\/ names and signatures.\n+public class NameAndTypeSig {\n+    public static void main(String args[]) throws Throwable {\n+\n+        \/\/ Test that an unreferenced NameAndType with a valid name and signature\n+        \/\/ is allowed even for name and signature pairs such as <init>()D.\n+        Class newClass = Class.forName(\"nonVoidInitSig\");\n+\n+        \/\/ Test that a NameAndType with a valid name and signature is allowed for\n+        \/\/ name and signature pairs such as <init>()D, but not allowed by a cp\n+        \/\/ Method_ref.\n+        try {\n+            Class newClass2 = Class.forName(\"nonVoidInitSigCFE\");\n+            throw new RuntimeException(\"Expected ClassFormatError exception not thrown\");\n+        } catch (java.lang.ClassFormatError e) {\n+            if (!e.getMessage().contains(\"Method \\\"<init>\\\" in class nonVoidInitSigCFE has illegal signature\")) {\n+                throw new RuntimeException(\"Wrong ClassFormatError exception: \" + e.getMessage());\n+            }\n+        }\n+\n+        \/\/ Test that a NameAndType with a valid name and invalid signature throws a\n+        \/\/ ClassFormatError exception with a message containing the name <init> and\n+        \/\/ the bad signature.\n+        try {\n+            Class newClass2 = Class.forName(\"voidInitBadSig\");\n+            throw new RuntimeException(\"Expected ClassFormatError exception not thrown\");\n+        } catch (java.lang.ClassFormatError e) {\n+            if (!e.getMessage().contains(\"Method \\\"<init>\\\" in class voidInitBadSig has illegal signature \\\"()))V\\\"\")) {\n+                throw new RuntimeException(\"Wrong ClassFormatError exception: \" + e.getMessage());\n+            }\n+        }\n+        System.out.println(\"Test NameAndTypeSig passed.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/NameAndTypeSig.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,346 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ The constant pool in this class contains an unused NameAndType entry (#20)\n+\/\/ that points to method <init> and signature ()D.  This is a valid NameAndType\n+\/\/ because <init> is a valid method name and ()D is a valid method signature.\n+class nonVoidInitSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [21] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"nonVoidInitSig\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"nonVoidInitSig.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()D\"; \/\/ #19\n+    NameAndType #5 #19; \/\/ #20 \/\/ Unused, points to <init>()D.\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class nonVoidInitSig\n+\n+\n+\n+\/\/ The constant pool in this class contains a cp NameAndType entry (#3) that\n+\/\/ points to method <init> and signature ()D.  This is a valid NameAndType\n+\/\/ because <init> is a valid method name and ()D is a valid method signature.\n+\/\/ But, a cp Methodref (#1) that points to NameAndType with a method named\n+\/\/ <init> and a non-void return type, is invalid.\n+class nonVoidInitSigCFE {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #19; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"nonVoidInitSigCFE\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"nonVoidInitSigCFE.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()D\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class nonVoidInitSigCFE\n+\n+\n+\/\/ The constant pool in this class contains a cp NameAndType entry (#20) that\n+\/\/ points to method <init> and signature ()))V.  This is an invalid NameAndType\n+\/\/ entry and should throw a ClassFormatError exception, with a message containing\n+\/\/ the name <init> and the bad signature, even thought the NameAndType is not\n+\/\/ referenced by a cp Methodref.\n+class voidInitBadSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [21] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"voidInitBadSig\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"voidInitBadSig.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()))V\"; \/\/ #19\n+    NameAndType #5 #19; \/\/ #20 \/\/ Unused, points to <init>()))V.\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class voidInitBadSig\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/nonVoidInitSig.jcod","additions":346,"deletions":0,"binary":false,"changes":346,"status":"added"},{"patch":"@@ -31,2 +31,3 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseBiasedLocking -XX:+SafepointALot -XX:BiasedLockingDecayTime=100000000 -XX:BiasedLockingBulkRebiasThreshold=1000000 -XX:BiasedLockingBulkRevokeThreshold=1000000 HandshakeDirectTest\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseBiasedLocking -XX:GuaranteedSafepointInterval=10 -XX:+HandshakeALot -XX:+SafepointALot -XX:BiasedLockingDecayTime=100000000 -XX:BiasedLockingBulkRebiasThreshold=1000000 -XX:BiasedLockingBulkRevokeThreshold=1000000 HandshakeDirectTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI HandshakeDirectTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:GuaranteedSafepointInterval=10 -XX:+HandshakeALot -XX:+SafepointALot HandshakeDirectTest\n@@ -38,0 +39,1 @@\n+import sun.hotspot.WhiteBox;\n@@ -42,1 +44,1 @@\n-    static final int DIRECT_HANDSHAKES_MARK = 500000;\n+    static final int DIRECT_HANDSHAKES_MARK = 300000;\n@@ -44,1 +46,0 @@\n-    static Semaphore[] handshakeSem = new Semaphore[WORKING_THREADS];\n@@ -46,1 +47,0 @@\n-    static boolean[] isBiased = new boolean[WORKING_THREADS];\n@@ -52,0 +52,1 @@\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n@@ -53,10 +54,3 @@\n-        while (true) {\n-            try {\n-                if (!isBiased[me]) {\n-                    handshakeSem[me].acquire();\n-                    synchronized(locks[me]) {\n-                        isBiased[me] = true;\n-                    }\n-                    handshakeSem[me].release();\n-                }\n-\n+        while (handshakeCount.get() < DIRECT_HANDSHAKES_MARK) {\n+            boolean walked = false;\n+            synchronized(locks[me]) {\n@@ -69,13 +63,5 @@\n-                handshakeSem[handshakee].acquire();\n-                if (isBiased[handshakee]) {\n-                    \/\/ Revoke biased lock\n-                    synchronized(locks[handshakee]) {\n-                        handshakeCount.incrementAndGet();\n-                    }\n-                    \/\/ Create new lock to be biased\n-                    locks[handshakee] = new Object();\n-                    isBiased[handshakee] = false;\n-                }\n-                handshakeSem[handshakee].release();\n-                if (handshakeCount.get() >= DIRECT_HANDSHAKES_MARK) {\n-                    break;\n+                \/\/ Inflate locks[handshakee] if possible\n+                System.identityHashCode(locks[handshakee]);\n+                walked = wb.handshakeReadMonitors(workingThreads[handshakee]);\n+                if (walked) {\n+                    handshakeCount.incrementAndGet();\n@@ -83,2 +69,0 @@\n-            } catch(InterruptedException ie) {\n-                throw new Error(\"Unexpected interrupt\");\n@@ -86,0 +70,1 @@\n+            locks[me] = new Object();\n@@ -92,5 +77,0 @@\n-        \/\/ Initialize semaphores\n-        for (int i = 0; i < WORKING_THREADS; i++) {\n-            handshakeSem[i] = new Semaphore(1);\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeDirectTest.java","additions":15,"deletions":35,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI HandshakeTimeoutTest\n+ * @run main HandshakeTimeoutTest\n@@ -44,9 +44,0 @@\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-        Boolean useJVMCICompiler = wb.getBooleanVMFlag(\"UseJVMCICompiler\");\n-        String useJVMCICompilerStr;\n-        if (useJVMCICompiler != null) {\n-            useJVMCICompilerStr = useJVMCICompiler ?  \"-XX:+UseJVMCICompiler\" : \"-XX:-UseJVMCICompiler\";\n-        } else {\n-            \/\/ pass something innocuous\n-            useJVMCICompilerStr = \"-XX:+UnlockExperimentalVMOptions\";\n-        }\n@@ -66,1 +57,0 @@\n-                    useJVMCICompilerStr,\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeTimeoutTest.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import sun.hotspot.WhiteBox;\n-\n@@ -37,2 +35,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI HandshakeTransitionTest\n+ * @run main\/native HandshakeTransitionTest\n@@ -45,9 +42,0 @@\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-        Boolean useJVMCICompiler = wb.getBooleanVMFlag(\"UseJVMCICompiler\");\n-        String useJVMCICompilerStr;\n-        if (useJVMCICompiler != null) {\n-            useJVMCICompilerStr = useJVMCICompiler ?  \"-XX:+UseJVMCICompiler\" : \"-XX:-UseJVMCICompiler\";\n-        } else {\n-            \/\/ pass something innocuous\n-            useJVMCICompilerStr = \"-XX:+UnlockExperimentalVMOptions\";\n-        }\n@@ -64,2 +52,0 @@\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    useJVMCICompilerStr,\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeTransitionTest.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/native TestAtExit\n+ * @run main\/native TestAtExit\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/atExit\/TestAtExit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm\/native TestCheckedEnsureLocalCapacity launch\n+ * @run main\/native TestCheckedEnsureLocalCapacity launch\n@@ -30,0 +30,1 @@\n+import jdk.test.lib.Utils;\n@@ -68,0 +69,1 @@\n+                                    \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n@@ -80,0 +82,1 @@\n+                                    \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestCheckedEnsureLocalCapacity.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,2 @@\n+\n+import jdk.test.lib.Utils;\n@@ -33,1 +35,1 @@\n- * @run main\/othervm\/native TestRegisterNativesWarning\n+ * @run main\/native TestRegisterNativesWarning\n@@ -64,1 +66,4 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(Tester.class.getName());\n+        String cp = Utils.TEST_CLASS_PATH;\n+        String libp = Utils.TEST_NATIVE_PATH;\n+        OutputAnalyzer output = ProcessTools.executeTestJvm(\"-Djava.library.path=\" + libp,\n+                                                            Tester.class.getName());\n@@ -70,3 +75,2 @@\n-        String cp = System.getProperty(\"test.class.path\");\n-        String libp = System.getProperty(\"java.library.path\");\n-        output = ProcessTools.executeTestJvm(\"-Xbootclasspath\/a:\" + cp,\n+        output = ProcessTools.executeTestJvm(\"-Djava.library.path=\" + libp,\n+                                             \"-Xbootclasspath\/a:\" + cp,\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/registerNativesWarning\/TestRegisterNativesWarning.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+        output.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/jsig\/Testjsig.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8149383\n- * @summary -Xlog:biasedlocking should have logging from statements in the source code\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver BiasedLockingTest\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class BiasedLockingTest {\n-    static void analyzeOutputOn(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Biased locking enabled\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    static void analyzeOutputOff(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"[biasedlocking]\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                                  \"-Xlog:biasedlocking\",\n-                                                                  \"-XX:BiasedLockingStartupDelay=0\",\n-                                                                  InnerClass.class.getName());\n-        analyzeOutputOn(pb);\n-\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                   \"-Xlog:biasedlocking=off\",\n-                                                   \"-XX:BiasedLockingStartupDelay=0\",\n-                                                   InnerClass.class.getName());\n-        analyzeOutputOff(pb);\n-    }\n-\n-    public static class InnerClass {\n-        public static void main(String[] args) {\n-            System.out.println(\"Biased Locking test\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/BiasedLockingTest.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/RedefineRecord.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/RedefinePermittedSubclass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/RedefineSealedClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/stringtable\/StringTableVerifyTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/symboltable\/ShortLivedSymbolCleanup.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/TraceClassRes.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/7170638\/SDTProbesGNULinuxTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/AttachSetGetFlag.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @requires os.family != \"windows\"\n+ * @requires vm.flagless\n@@ -32,1 +34,0 @@\n- * @requires os.family != \"windows\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/AttachWithStalePidFile.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,1 +80,5 @@\n-            pipe.println(\"quit\");\n+            if (pipe.isConnected()) {\n+                pipe.println(\"quit\");\n+            } else {\n+                System.out.println(\"WARNING: IOPipe is not connected\");\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/TestProcessLauncher.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/CanGenerateAllClassHook\/CanGenerateAllClassHook.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetObjectSizeClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -55,1 +55,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -67,1 +67,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -79,37 +79,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/GetOwnedMonitorInfoWithEATest.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -55,1 +55,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -67,1 +67,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -79,37 +79,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorStackDepthInfo\/GetOwnedMonitorStackDepthInfoWithEATest.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -124,1 +124,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -135,1 +135,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Heap\/IterateHeapWithEscapeAnalysisEnabled.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineLeak.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefinePreviousVersions.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RetransformClassesZeroLength.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/TransformerDeadlockTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -212,1 +212,2 @@\n-                expStrMap.put(cmdStr, List.of(\"In java stack\"));\n+                \/\/ Note, sometimes a stack address points to a hotspot type, thus allow for \"Is of type\".\n+                expStrMap.put(cmdStr, List.of(\"(In java stack)|(Is of type)\"));\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,1 @@\n-                    \"InvocationCounter::count_increment\",\n-                    \"markWord::epoch_mask_in_place\"));\n+                    \"InvocationCounter::count_increment\"));\n@@ -96,1 +95,0 @@\n-        \/\/ longConstant markWord::biased_lock_bits 1\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbLongConstant.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackLineNumbers.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-    if (phase != JVMTI_PHASE_LIVE) {\n+    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE) {\n@@ -81,1 +81,1 @@\n-        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodLoad event received during non-live phase %s\\n\",\n+        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodLoad event received during wrong phase %s\\n\",\n@@ -85,1 +85,1 @@\n-        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodLoad event received during the live phase as expected\\n\\n\");\n+        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodLoad event received during the start or live phase as expected\\n\\n\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CompiledMethodLoad\/compmethload001\/compmethload001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-    if (phase != JVMTI_PHASE_LIVE) {\n+    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE) {\n@@ -113,1 +113,1 @@\n-        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodUnload event received during non-live phase %s\\n\",\n+        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodUnload event received during wrong phase %s\\n\",\n@@ -117,1 +117,1 @@\n-        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodUnload event received during the live phase as expected\\n\\n\");\n+        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodUnload event received during the start or live phase as expected\\n\\n\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CompiledMethodUnload\/compmethunload001\/compmethunload001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n@@ -69,1 +67,1 @@\n- * @bug 6439439 8087303 8174025 8223291 8249867 8261209 8260858\n+ * @bug 6439439 8087303 8174025 8223291 8249867 8261209 8260858 8265073\n@@ -183,0 +181,48 @@\n+    private final String xml1 = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n+            + \"<a><b>element b<\/b><c>element c<\/c><d xml:space=\\\"preserve\\\">TRUE<\/d><e>test<\/e><\/a>\";\n+    private final String expected1 = \"<a>\\n\"\n+            + \"    <b>element b<\/b>\\n\"\n+            + \"    <c>element c<\/c>\\n\"\n+            + \"    <d xml:space=\\\"preserve\\\">TRUE<\/d>\\n\"\n+            + \"    <e>test<\/e>\\n\"\n+            + \"<\/a>\\n\";\n+\n+    private final String xml2 = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n+            + \"<l0><l1><l2 xml:space=\\\"preserve\\\">level 2<\/l2> level 1 <l2>level 2<\/l2><\/l1>\"\n+            + \"<l1 xml:space=\\\"preserve\\\"><l2>level 2<\/l2> level 1 <l2>level 2<\/l2><\/l1><\/l0>\";\n+    private final String expected2 = \"<l0>\\n\"\n+            + \"    <l1>\\n\"\n+            + \"        <l2 xml:space=\\\"preserve\\\">level 2<\/l2>\\n\"\n+            + \"         level 1 \\n\"\n+            + \"        <l2>level 2<\/l2>\\n\"\n+            + \"    <\/l1>\\n\"\n+            + \"    <l1 xml:space=\\\"preserve\\\"><l2>level 2<\/l2> level 1 <l2>level 2<\/l2><\/l1>\\n\"\n+            + \"<\/l0>\\n\";\n+\n+    \/*\n+     * Bug: 8265073\n+     * source and expected output\n+     *\/\n+    @DataProvider\n+    public Object[][] preserveSpace() {\n+        return new Object[][]{\n+            {xml1, expected1},\n+            {xml2, expected2},\n+        };\n+    }\n+\n+    \/**\n+     * Bug: 8265073\n+     * Verifies that the scope of the preserve attribute is applied properly\n+     * within the relevant elements.\n+     * @param xml the source\n+     * @param expected the expected result\n+     * @throws Exception if the assertion fails or an error occurs in the\n+     * transform process\n+     *\/\n+    @Test(dataProvider = \"preserveSpace\")\n+    public void test(String xml, String expected) throws Exception {\n+        String result = transform(null, xml, true, true, false, false, false);\n+        Assert.assertEquals(result.replaceAll(\"\\r\\n\", \"\\n\"), expected);\n+    }\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/prettyprint\/PrettyPrintTest.java","additions":49,"deletions":3,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -609,1 +609,0 @@\n-java\/net\/MulticastSocket\/Promiscuous.java                       8265369 macosx-aarch64\n@@ -836,2 +835,0 @@\n-tools\/jpackage\/windows\/WinInstallerIconTest.java 8268404 windows-x64\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -52,1 +52,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -60,1 +60,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -68,25 +68,1 @@\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -103,1 +79,1 @@\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -235,1 +211,0 @@\n-        new EARelockingSimple_2Target()                                                     .run();\n@@ -241,2 +216,0 @@\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_3Target()                             .run();\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_4Target()                             .run();\n@@ -352,1 +325,0 @@\n-        new EARelockingSimple_2()                                                     .run(this);\n@@ -358,2 +330,0 @@\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_3()                             .run(this);\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_4()                             .run(this);\n@@ -796,2 +766,0 @@\n-    public static final long BiasedLockingBulkRebiasThreshold = WB.getIntxVMFlag(\"BiasedLockingBulkRebiasThreshold\");\n-    public static final long BiasedLockingBulkRevokeThreshold = WB.getIntxVMFlag(\"BiasedLockingBulkRevokeThreshold\");\n@@ -812,2 +780,0 @@\n-    public volatile Object biasToBeRevoked;\n-\n@@ -1057,40 +1023,0 @@\n-    \/**\n-     * Trigger bulk rebiasing for the given class by creating new instances and calling <code> hashCode() <\/code> on them.\n-     * @param cls The class to bulk rebias\n-     *\/\n-    public void dontinline_bulkRebiasAfterWarmup(Class<?> cls) {\n-        if (warmupDone) {\n-            try {\n-                for (int i=0; i < BiasedLockingBulkRebiasThreshold+2; i++) {\n-                    biasToBeRevoked = cls.getDeclaredConstructor(int.class, int.class).newInstance(1, 1);\n-                    synchronized (biasToBeRevoked) { \/\/ bias towards current thread\n-                        checkSum++;\n-                    }\n-                    biasToBeRevoked.hashCode(); \/\/ calling hashCode triggers revocation\n-                }\n-            } catch (Throwable e) {\n-                Asserts.fail(\"failed to create new instance of \" + cls.getName(), e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Trigger bulk revoke of biases for the given class by creating new instances and calling <code> hashCode() <\/code> on them.\n-     * @param cls The class to bulk rebias\n-     *\/\n-    public void dontinline_bulkRevokeAfterWarmup(Class<?> cls) {\n-        if (warmupDone) {\n-            try {\n-                for (int i=0; i < BiasedLockingBulkRevokeThreshold+2; i++) {\n-                    biasToBeRevoked = cls.getDeclaredConstructor(int.class, int.class).newInstance(1, 1);\n-                    synchronized (biasToBeRevoked) { \/\/ bias towards current thread\n-                        checkSum++;\n-                    }\n-                    biasToBeRevoked.hashCode(); \/\/ calling hashCode triggers revocation\n-                }\n-            } catch (Throwable e) {\n-                Asserts.fail(\"failed to create new instance of \" + cls.getName(), e);\n-            }\n-        }\n-    }\n-\n@@ -1767,32 +1693,0 @@\n-\/**\n- * Test if the bias of an object O that escapes globally is revoked correctly if local objects\n- * escape through JVMTI. O is referenced by field l0.\n- * This tests a regression of a previous version of the implementation.\n- *\/\n-class EARelockingSimple_2 extends EATestCaseBaseDebugger {\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingSimple_2Target extends EATestCaseBaseTarget {\n-\n-    public XYVal l0;\n-\n-    public void dontinline_testMethod() {\n-        l0 = new XYVal(4, 2);         \/\/ GobalEscape\n-        XYVal l1 = new XYVal(4, 2);\n-        synchronized (l0) {\n-            synchronized (l1) {\n-                dontinline_brkpt();\n-            }\n-        }\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -1997,99 +1891,0 @@\n-\/**\n- * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame}.\n- * A bulk rebias operation is triggered at a position where all locks on the local object referenced\n- * by l1 are eliminated. This leaves the object with an outdated biased locking epoch which has to be\n- * considered when relocking.\n- * This tests a regression in a previous version.\n- *\/\n-class EARelockingArgEscapeLWLockedInCalleeFrame_3 extends EATestCaseBaseDebugger {\n-\n-    public static final String XYVAL_LOCAL_NAME = EARelockingArgEscapeLWLockedInCalleeFrame_3Target.XYValLocal.class.getName();\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_LOCAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingArgEscapeLWLockedInCalleeFrame_3Target extends EATestCaseBaseTarget {\n-\n-    \/\/ Using local type to avoid side effects on biased locking heuristics\n-    public static class XYValLocal extends XYVal {\n-        public XYValLocal(int x, int y) {\n-            super(x,y);\n-        }\n-    }\n-\n-    public void dontinline_testMethod() {\n-        XYVal l1 = new XYValLocal(1, 1);       \/\/ ArgEscape\n-        synchronized (l1) {                    \/\/ eliminated\n-            l1.dontinline_sync_method_no_brkpt(this);  \/\/ l1 escapes\n-            \/\/ trigger bulk rebias\n-            dontinline_bulkRebiasAfterWarmup(l1.getClass());\n-            \/\/ Now the epoch of l1 does not match the epoch of its class.\n-            \/\/ This has to be considered when relocking because of JVMTI access\n-            dontinline_brkpt();\n-        }\n-    }\n-\n-    @Override\n-    public boolean testFrameShouldBeDeoptimized() {\n-        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n-        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\/**\n- * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame_3}.\n- * But instead of a bulk rebias a bulk revoke operation is triggered.\n- * This leaves the object with a stale bias as the prototype header of its calls lost its bias\n- * pattern in the bulk revoke which has to be considered during relocking.\n- * This tests a regression in a previous version.\n- *\/\n-class EARelockingArgEscapeLWLockedInCalleeFrame_4 extends EATestCaseBaseDebugger {\n-\n-    public static final String XYVAL_LOCAL_NAME = EARelockingArgEscapeLWLockedInCalleeFrame_4Target.XYValLocal.class.getName();\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_LOCAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingArgEscapeLWLockedInCalleeFrame_4Target extends EATestCaseBaseTarget {\n-\n-    \/\/ Using local type to avoid side effects on biased locking heuristics\n-    public static class XYValLocal extends XYVal {\n-        public XYValLocal(int x, int y) {\n-            super(x,y);\n-        }\n-    }\n-\n-    public void dontinline_testMethod() {\n-        XYVal l1 = new XYValLocal(1, 1);       \/\/ ArgEscape\n-        synchronized (l1) {                    \/\/ eliminated\n-            l1.dontinline_sync_method_no_brkpt(this);  \/\/ l1 escapes\n-            \/\/ trigger bulk rebias\n-            dontinline_bulkRevokeAfterWarmup(l1.getClass());\n-            \/\/ Now the epoch of l1 does not match the epoch of its class.\n-            \/\/ This has to be considered when relocking because of JVMTI access\n-            dontinline_brkpt();\n-        }\n-    }\n-\n-\n-    @Override\n-    public boolean testFrameShouldBeDeoptimized() {\n-        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n-        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":5,"deletions":210,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.stream.Collectors;\n@@ -47,2 +48,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -52,1 +51,0 @@\n-import java.util.ServiceConfigurationError;\n@@ -55,1 +53,0 @@\n-import jdk.internal.logger.SimpleConsoleLogger;\n@@ -205,0 +202,4 @@\n+    private static String withoutWarning(String in) {\n+        return in.lines().filter(s -> !s.startsWith(\"WARNING:\")).collect(Collectors.joining());\n+    }\n+\n@@ -238,6 +239,1 @@\n-                    String smDeprecationWarning\n-                            = \"WARNING: java.lang.System::setSecurityManager is deprecated and will be removed in a future release.\"\n-                            + System.getProperty(\"line.separator\");\n-                    if (warning.startsWith(smDeprecationWarning)) {\n-                        warning = warning.substring(smDeprecationWarning.length());\n-                    }\n+                    warning = withoutWarning(warning);\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/internal\/LoggerFinderLoaderTest\/LoggerFinderLoaderTest.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8266459\n+ * @bug 8266459 8268349\n@@ -31,0 +31,1 @@\n+import jdk.test.lib.JDKToolFinder;\n@@ -33,0 +34,1 @@\n+import jdk.test.lib.util.JarUtils;\n@@ -34,1 +36,5 @@\n-import java.security.Permission;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -37,0 +43,1 @@\n+\n@@ -39,30 +46,22 @@\n-            run(null)\n-                    .shouldHaveExitValue(0)\n-                    .shouldContain(\"SM is enabled: false\")\n-                    .shouldNotContain(\"Security Manager is deprecated\")\n-                    .shouldContain(\"setSecurityManager is deprecated\");\n-            run(\"allow\")\n-                    .shouldHaveExitValue(0)\n-                    .shouldContain(\"SM is enabled: false\")\n-                    .shouldNotContain(\"Security Manager is deprecated\")\n-                    .shouldContain(\"setSecurityManager is deprecated\");\n-            run(\"disallow\")\n-                    .shouldNotHaveExitValue(0)\n-                    .shouldContain(\"SM is enabled: false\")\n-                    .shouldNotContain(\"Security Manager is deprecated\")\n-                    .shouldContain(\"UnsupportedOperationException\");\n-            run(\"SecurityManagerWarnings$MySM\")\n-                    .shouldHaveExitValue(0)\n-                    .shouldContain(\"SM is enabled: true\")\n-                    .shouldContain(\"Security Manager is deprecated\")\n-                    .shouldContain(\"setSecurityManager is deprecated\");\n-            run(\"\")\n-                    .shouldNotHaveExitValue(0)\n-                    .shouldContain(\"SM is enabled: true\")\n-                    .shouldContain(\"Security Manager is deprecated\")\n-                    .shouldContain(\"AccessControlException\");\n-            run(\"default\")\n-                    .shouldNotHaveExitValue(0)\n-                    .shouldContain(\"SM is enabled: true\")\n-                    .shouldContain(\"Security Manager is deprecated\")\n-                    .shouldContain(\"AccessControlException\");\n+            Files.writeString(Path.of(\"policy\"), \"\"\"\n+                    grant {\n+                        permission java.lang.RuntimePermission \"setIO\";\n+                        permission java.lang.RuntimePermission \"createSecurityManager\";\n+                        permission java.lang.RuntimePermission \"setSecurityManager\";\n+                    };\n+                    \"\"\");\n+\n+            String testClasses = System.getProperty(\"test.classes\");\n+\n+            allowTest(null, testClasses);\n+            allowTest(\"allow\", testClasses);\n+            disallowTest(\"disallow\", testClasses);\n+            enableTest(\"\", testClasses);\n+            enableTest(\"default\", testClasses);\n+            enableTest(\"java.lang.SecurityManager\", testClasses);\n+\n+            JarUtils.createJarFile(Path.of(\"a.jar\"),\n+                    Path.of(testClasses),\n+                    Path.of(\"SecurityManagerWarnings.class\"));\n+\n+            allowTest(null, \"a.jar\");\n@@ -71,1 +70,11 @@\n-            System.setSecurityManager(new SecurityManager());\n+            PrintStream oldErr = System.err;\n+            \/\/ Modify System.err, thus make sure warnings are always printed\n+            \/\/ to the original System.err and will not be swallowed.\n+            System.setErr(new PrintStream(new ByteArrayOutputStream()));\n+            try {\n+                System.setSecurityManager(new SecurityManager());\n+            } catch (Exception e) {\n+                \/\/ Exception messages must show in original stderr\n+                e.printStackTrace(oldErr);\n+                throw e;\n+            }\n@@ -75,1 +84,39 @@\n-    static OutputAnalyzer run(String prop) throws Exception {\n+    \/\/ When SM is allowed, no startup warning, has setSM warning\n+    static void allowTest(String prop, String cp) throws Exception {\n+        checkInstallMessage(run(prop, cp), cp)\n+                .shouldHaveExitValue(0)\n+                .stdoutShouldContain(\"SM is enabled: false\")\n+                .shouldNotContain(\"A command line option\");\n+    }\n+\n+    \/\/ When SM is disallowed, no startup warning, setSM fails\n+    static void disallowTest(String prop, String cp) throws Exception {\n+        run(prop, cp)\n+                .shouldNotHaveExitValue(0)\n+                .stdoutShouldContain(\"SM is enabled: false\")\n+                .shouldNotContain(\"A command line option\")\n+                .shouldNotContain(\"A terminally deprecated method\")\n+                .stderrShouldContain(\"UnsupportedOperationException: The Security Manager is deprecated and will be removed in a future release\");\n+    }\n+\n+    \/\/ When SM is allowed, has startup warning, has setSM warning\n+    static void enableTest(String prop, String cp) throws Exception {\n+        checkInstallMessage(run(prop, cp), cp)\n+                .shouldHaveExitValue(0)\n+                .stdoutShouldContain(\"SM is enabled: true\")\n+                .stderrShouldContain(\"WARNING: A command line option has enabled the Security Manager\")\n+                .stderrShouldContain(\"WARNING: The Security Manager is deprecated and will be removed in a future release\");\n+    }\n+\n+    \/\/ Check the setSM warning\n+    static OutputAnalyzer checkInstallMessage(OutputAnalyzer oa, String cp) {\n+        String uri = new File(cp).toURI().toString();\n+        return oa\n+                .stderrShouldContain(\"WARNING: A terminally deprecated method in java.lang.System has been called\")\n+                .stderrShouldContain(\"WARNING: System::setSecurityManager has been called by SecurityManagerWarnings (\" + uri + \")\")\n+                .stderrShouldContain(\"WARNING: Please consider reporting this to the maintainers of SecurityManagerWarnings\")\n+                .stderrShouldContain(\"WARNING: System::setSecurityManager will be removed in a future release\");\n+    }\n+\n+    static OutputAnalyzer run(String prop, String cp) throws Exception {\n+        ProcessBuilder pb;\n@@ -77,1 +124,3 @@\n-            return ProcessTools.executeTestJvm(\n+            pb = new ProcessBuilder(\n+                    JDKToolFinder.getJDKTool(\"java\"),\n+                    \"-cp\", cp,\n@@ -80,1 +129,3 @@\n-            return ProcessTools.executeTestJvm(\n+            pb = new ProcessBuilder(\n+                    JDKToolFinder.getJDKTool(\"java\"),\n+                    \"-cp\", cp,\n@@ -82,0 +133,1 @@\n+                    \"-Djava.security.policy=policy\",\n@@ -84,7 +136,1 @@\n-    }\n-\n-    \/\/ This SecurityManager allows everything!\n-    public static class MySM extends SecurityManager {\n-        @Override\n-        public void checkPermission(Permission perm) {\n-        }\n+        return ProcessTools.executeProcess(pb);\n","filename":"test\/jdk\/java\/lang\/System\/SecurityManagerWarnings.java","additions":89,"deletions":43,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import static java.lang.invoke.MethodHandleInfo.*;\n@@ -57,0 +58,1 @@\n+import static org.testng.Assert.assertNotEquals;\n@@ -362,0 +364,1 @@\n+            assertEquals(Kind.valueOf(k.refKind), Kind.valueOf(k.refKind, k.refKind == MethodHandleInfo.REF_invokeInterface));\n@@ -364,0 +367,20 @@\n+        \/\/ let's now verify those cases for which the value of the isInterface parameter is ignored\n+        int[] isInterfaceIgnored = new int[] {\n+                REF_getField,\n+                REF_getStatic,\n+                REF_putField,\n+                REF_putStatic,\n+                REF_newInvokeSpecial,\n+                REF_invokeInterface\n+        };\n+        for (int refKind : isInterfaceIgnored) {\n+            assertEquals(Kind.valueOf(refKind, false), Kind.valueOf(refKind, true));\n+        }\n+\n+        \/\/ some explicit tests for REF_invokeStatic and REF_invokeSpecial\n+        assertNotEquals(Kind.valueOf(REF_invokeStatic, false), Kind.valueOf(REF_invokeStatic, true));\n+        assertNotEquals(Kind.valueOf(REF_invokeSpecial, false), Kind.valueOf(REF_invokeSpecial, true));\n+        assertEquals(Kind.valueOf(REF_invokeStatic, false), Kind.STATIC);\n+        assertEquals(Kind.valueOf(REF_invokeStatic, true), Kind.INTERFACE_STATIC);\n+        assertEquals(Kind.valueOf(REF_invokeSpecial, false), Kind.SPECIAL);\n+        assertEquals(Kind.valueOf(REF_invokeSpecial, true), Kind.INTERFACE_SPECIAL);\n","filename":"test\/jdk\/java\/lang\/constant\/MethodHandleDescTest.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-                                  .filter(s -> !s.contains(\"setSecurityManager is deprecated\"))\n@@ -152,1 +151,1 @@\n-                                  .peek(s -> assertTrue(s.contains(\"does not exist\")))\n+                                  .filter(s -> s.contains(\"does not exist\"))\n@@ -167,1 +166,0 @@\n-                                  .filter(s -> !s.contains(\"setSecurityManager is deprecated\"))\n@@ -169,1 +167,1 @@\n-                                  .peek(s -> assertTrue(s.contains(\"not a directory\")))\n+                                  .filter(s -> s.contains(\"not a directory\"))\n@@ -227,1 +225,0 @@\n-                                      .filter(s -> !s.contains(\"setSecurityManager is deprecated\"))\n@@ -229,1 +226,1 @@\n-                                      .peek(s -> assertTrue(s.contains(\"not writable\")))\n+                                      .filter(s -> s.contains(\"not writable\"))\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -89,0 +89,5 @@\n+\n+    private static String withoutWarning(String in) {\n+        return in.lines().filter(s -> !s.startsWith(\"WARNING:\")).collect(Collectors.joining());\n+    }\n+\n@@ -90,3 +95,2 @@\n-        if (r.exitValue != 0 ||\n-                (!r.output.isEmpty() && !r.output.equals(SECURITY_MANAGER_DEPRECATED)))\n-            throw new RuntimeException(r.output);\n+        if (r.exitValue != 0 || !withoutWarning(r.output).isEmpty())\n+            throw new RuntimeException(\"[\" + r.output + \"]\");\n","filename":"test\/jdk\/java\/net\/spi\/URLStreamHandlerProvider\/Basic.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1137,0 +1137,20 @@\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+#if[byte]\n+        $Type$Buffer direct1 = $Type$Buffer.allocateDirect(cap);\n+        if (!direct1.toString().equals(Basic.toString(direct1))) {\n+           fail(\"Direct buffer toString is incorrect: \"\n+                  + direct1.toString() + \" vs \" + Basic.toString(direct1));\n+        }\n+#end[byte]\n+\n+#if[!char]\n+        $Type$Buffer nondirect1 = $Type$Buffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+#end[!char]\n+    }\n+\n@@ -1158,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/Basic-X.java.template","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1137,0 +1137,20 @@\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+        ByteBuffer direct1 = ByteBuffer.allocateDirect(cap);\n+        if (!direct1.toString().equals(Basic.toString(direct1))) {\n+           fail(\"Direct buffer toString is incorrect: \"\n+                  + direct1.toString() + \" vs \" + Basic.toString(direct1));\n+        }\n+\n+\n+\n+        ByteBuffer nondirect1 = ByteBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n+    }\n+\n@@ -1158,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicByte.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicChar.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        DoubleBuffer nondirect1 = DoubleBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicDouble.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        FloatBuffer nondirect1 = FloatBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicFloat.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        IntBuffer nondirect1 = IntBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicInt.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        LongBuffer nondirect1 = LongBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicLong.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        ShortBuffer nondirect1 = ShortBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicShort.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4947618\n+ * @bug 4947618 8268349\n@@ -90,2 +90,0 @@\n-\n-        System.setSecurityManager(null);\n","filename":"test\/jdk\/java\/security\/ProtectionDomain\/RecursionDebug.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Arrays;\n@@ -43,4 +44,8 @@\n-        \"DES\/ECB\/PKCS5Padding\",\n-        \"AES\/KW\/NoPadding\",\n-        \"AES\/KW\/PKCS5Padding\",\n-        \"AES\/KWP\/NoPadding\",\n+        \"DES\/ECB\/PKCS5Padding\", \/\/ CipherCore\n+        \"AES\/GCM\/NoPadding\", \/\/ GaloisCounterMode\n+        \"AES\/KW\/NoPadding\", \/\/ KeyWrapCipher\n+        \"AES\/KW\/PKCS5Padding\", \/\/ KeyWrapCipher\n+        \"AES\/KWP\/NoPadding\", \/\/ KeyWrapCipher\n+        \"RSA\/ECB\/NoPadding\", \/\/ RSACipher\n+        \"DESedeWrap\/CBC\/NoPadding\", \/\/ DESedeWrapCipher\n+        \"ChaCha20-Poly1305\", \/\/ ChaCha20Cipher\n@@ -49,0 +54,2 @@\n+    private static final byte[] BYTES32 =\n+            Arrays.copyOf(TRANSFORMATIONS[0].getBytes(), 32);\n@@ -50,1 +57,1 @@\n-            new SecretKeySpec(new byte[8], \"DES\");\n+            new SecretKeySpec(BYTES32, 0, 8, \"DES\");\n@@ -52,1 +59,1 @@\n-            new SecretKeySpec(new byte[16], \"AES\");\n+            new SecretKeySpec(BYTES32, 0, 16, \"AES\");\n@@ -54,13 +61,39 @@\n-    public static void main(String[] argv) throws Exception {\n-        for (String t : TRANSFORMATIONS) {\n-            System.out.println(\"Testing SunJCE provider, Cipher \" + t );\n-\n-            TestCipherMode test = new TestCipherMode(t);\n-            System.out.println(\"Testing ENCRYPT_MODE...\");\n-            test.checkMode(Cipher.ENCRYPT_MODE, \"encryption\");\n-            System.out.println(\"Testing DECRYPT_MODE...\");\n-            test.checkMode(Cipher.DECRYPT_MODE, \"decryption\");\n-            System.out.println(\"Testing WRAP_MODE...\");\n-            test.checkMode(Cipher.WRAP_MODE, \"key wrapping\");\n-            System.out.println(\"Testing UNWRAP_MODE...\");\n-            test.checkMode(Cipher.UNWRAP_MODE, \"key unwrapping\");\n+    private  static enum CipherMode {\n+        ENCRYPT(Cipher.ENCRYPT_MODE),\n+        DECRYPT(Cipher.DECRYPT_MODE),\n+        WRAP(Cipher.WRAP_MODE),\n+        UNWRAP(Cipher.UNWRAP_MODE),\n+        NONEXISTENT(100);\n+\n+        int value;\n+\n+        CipherMode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static Key getKey(String t, CipherMode m)\n+            throws NoSuchAlgorithmException, NoSuchProviderException {\n+        Key key;\n+        String algo = t.split(\"\/\")[0];\n+        switch (algo) {\n+        case \"AES\":\n+            key = AES_KEY;\n+        break;\n+        case \"RSA\":\n+            KeyPairGenerator kpg = KeyPairGenerator.getInstance(algo);\n+            KeyPair kp = kpg.generateKeyPair();\n+            key = ((m == CipherMode.ENCRYPT || m == CipherMode.UNWRAP)?\n+                    kp.getPrivate() : kp.getPublic());\n+        break;\n+        case \"ChaCha20-Poly1305\":\n+            key = new SecretKeySpec(BYTES32, 0, 32, \"ChaCha20\");\n+        break;\n+        case \"DES\":\n+            key = new SecretKeySpec(BYTES32, 0, 8, algo);\n+        break;\n+        case \"DESedeWrap\":\n+            key = new SecretKeySpec(BYTES32, 0, 24, \"DESede\");\n+        break;\n+        default:\n+            throw new RuntimeException(\"Unknown transformation: \" + t);\n@@ -68,0 +101,6 @@\n+        return key;\n+    }\n+\n+    public static void main(String[] argv) throws Exception {\n+\n+        TestCipherMode test = new TestCipherMode(\"SunJCE\", TRANSFORMATIONS);\n@@ -74,10 +113,10 @@\n-    private TestCipherMode(String transformation)\n-            throws NoSuchAlgorithmException, NoSuchProviderException,\n-            NoSuchPaddingException {\n-        c = Cipher.getInstance(transformation, \"SunJCE\");\n-        this.key = switch (transformation.split(\"\/\")[0]) {\n-            case \"DES\" -> DES_KEY;\n-            case \"AES\" -> AES_KEY;\n-            default -> throw new RuntimeException\n-                    (\"Error: Unsupported key algorithm\");\n-        };\n+    private TestCipherMode(String provName, String... transformations)\n+            throws Exception {\n+\n+        System.out.println(\"Testing \" + provName);\n+\n+        for (String t : transformations) {\n+            for (CipherMode m : CipherMode.values()) {\n+                checkMode(t, m, provName);\n+            }\n+        }\n@@ -86,2 +125,25 @@\n-    private void checkMode(int mode, String opString) throws Exception {\n-        c.init(mode, key);\n+    private void checkMode(String t, CipherMode mode, String provName)\n+            throws Exception {\n+        Cipher c = Cipher.getInstance(t, provName);\n+        Key key = getKey(t, mode);\n+\n+        System.out.println(c.getAlgorithm() + \" with \" + mode.name());\n+        try {\n+            c.init(mode.value, key, c.getParameters());\n+            if (mode == CipherMode.NONEXISTENT) {\n+                throw new Exception(\"ERROR: should throw IPE for init()\");\n+            }\n+        } catch (UnsupportedOperationException uoe)  {\n+            \/\/ some may not support wrap\/unwrap or enc\/dec\n+            if (mode != CipherMode.NONEXISTENT) {\n+                System.out.println(\"Expected UOE thrown with init()\");\n+                return;\n+            }\n+            throw uoe;\n+        } catch (InvalidParameterException ipe) {\n+            if (mode == CipherMode.NONEXISTENT) {\n+                System.out.println(\"=> expected IPE thrown for init()\");\n+                return;\n+            }\n+            throw ipe;\n+        }\n@@ -90,2 +152,2 @@\n-        case Cipher.ENCRYPT_MODE:\n-        case Cipher.DECRYPT_MODE:\n+        case ENCRYPT:\n+        case DECRYPT:\n@@ -97,1 +159,1 @@\n-                System.out.println(\"expected ISE is thrown for wrap()\");\n+                System.out.println(\"=> expected ISE thrown for wrap()\");\n@@ -103,1 +165,1 @@\n-                System.out.println(\"expected ISE is thrown for unwrap()\");\n+                System.out.println(\"=> expected ISE thrown for unwrap()\");\n@@ -106,2 +168,2 @@\n-        case Cipher.WRAP_MODE:\n-        case Cipher.UNWRAP_MODE:\n+        case WRAP:\n+        case UNWRAP:\n@@ -112,1 +174,1 @@\n-                System.out.println(\"expected ISE is thrown for update()\");\n+                System.out.println(\"=> expected ISE thrown for update()\");\n@@ -118,1 +180,1 @@\n-                System.out.println(\"expected ISE is thrown for doFinal()\");\n+                System.out.println(\"=> expected ISE thrown for doFinal()\");\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestCipherMode.java","additions":101,"deletions":39,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.vector.VectorMask;\n@@ -28,0 +29,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -244,0 +246,15 @@\n+    static Object[][] fixedShapeXSegmentedCastSpeciesArgs(VectorShape srcShape, boolean legal) {\n+        List<Object[]> args = new ArrayList<>();\n+        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+            VectorSpecies<?> src = VectorSpecies.of(srcE, srcShape);\n+            for (VectorShape dstShape : VectorShape.values()) {\n+                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+                    VectorSpecies<?> dst = VectorSpecies.of(dstE, dstShape);\n+                    if (legal == (dst.length() == src.length())) {\n+                        args.add(new Object[]{src, dst});\n+                    }\n+                }\n+            }\n+        }\n+        return args.toArray(Object[][]::new);\n+    }\n@@ -491,0 +508,42 @@\n+\n+    static <E,F> void legal_mask_cast_kernel(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        for(int i = 0; i < INVOC_COUNT; i++) {\n+            VectorMask<E> mask = VectorMask.fromLong(src, i);\n+            VectorMask<F> res = mask.cast(dst);\n+            Assert.assertEquals(res.toLong(), mask.toLong());\n+        }\n+    }\n+\n+    static <E,F> void illegal_mask_cast_kernel(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        VectorMask<E> mask = VectorMask.fromLong(src, -1);\n+        try {\n+            mask.cast(dst);\n+            Assert.fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    static <E,F> void legal_shuffle_cast_kernel(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        int [] arr = new int[src.length()*INVOC_COUNT];\n+        for(int i = 0; i < arr.length; i++) {\n+            arr[i] = i;\n+        }\n+        for(int i = 0; i < INVOC_COUNT; i++) {\n+            VectorShuffle<E> shuffle = VectorShuffle.fromArray(src, arr, i);\n+            VectorShuffle<F> res = shuffle.cast(dst);\n+            Assert.assertEquals(res.toArray(), shuffle.toArray());\n+        }\n+    }\n+\n+    static <E,F> void illegal_shuffle_cast_kernel(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        int [] arr = new int[src.length()];\n+        for(int i = 0; i < arr.length; i++) {\n+            arr[i] = i;\n+        }\n+        VectorShuffle<E> shuffle = VectorShuffle.fromArray(src, arr, 0);\n+        try {\n+            shuffle.cast(dst);\n+            Assert.fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorConversionTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -111,14 +111,0 @@\n-    static final List<IntFunction<int[]>> INDEX_GENERATORS = List.of(\n-            withToString(\"index[i -> i]\", (int s) -> {\n-                return fillInts(s,\n-                                i -> i);\n-            }),\n-            withToString(\"index[i -> size - i - 1]\", (int s) -> {\n-                return fillInts(s,\n-                                i -> s - i - 1);\n-            }),\n-            withToString(\"index[i -> (i % 2) == 0 ? i : s - i - 1]\", (int s) -> {\n-                return fillInts(s,\n-                                i -> (i % 2) == 0 ? i : s - i - 1);\n-            })\n-    );\n@@ -164,3 +150,2 @@\n-            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n-                return RAND.ints(l, 0, m).toArray();\n-            })\n+            withToStringBi(\"shuffle[random]\",\n+                    (Integer l, Integer m) -> RAND.ints(l, 0, m).toArray())\n@@ -205,3 +190,2 @@\n-            withToStringBi(\"index[random]\", (Integer l, Integer m) -> {\n-                return RAND.ints(l, 0, m).toArray();\n-            })\n+            withToStringBi(\"index[random]\",\n+                    (Integer l, Integer m) -> RAND.ints(l, 0, m).toArray())\n@@ -210,6 +194,0 @@\n-    static int countTrailingFalse(boolean[] m) {\n-        int i;\n-        for (i = m.length - 1; i >= 0 && !m[i]; i--);\n-        return m.length - 1 - i;\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Arrays;\n@@ -53,1 +54,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -58,2 +59,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -181,19 +180,0 @@\n-    @DataProvider\n-    public Object[][] byteIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1041,0 +1021,277 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":279,"deletions":22,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -1011,30 +1009,0 @@\n-    @DataProvider\n-    public Object[][] byteUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().flatMap(fn ->\n-              BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4925,116 +4893,0 @@\n-    static byte[] gather(byte a[], int ix, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void gatherByte128VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte128VectorTests::gather);\n-    }\n-    static byte[] gatherMasked(byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedByte128VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte128VectorTests::gatherMasked);\n-    }\n-\n-    static byte[] scatter(byte a[], int ix, int[] b, int iy) {\n-      byte[] res = new byte[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void scatterByte128VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte128VectorTests::scatter);\n-    }\n-\n-    static byte[] scatterMasked(byte r[], byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      byte[] oldVal = gather(r, ix, b, iy);\n-      byte[] newVal = new byte[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      byte[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Arrays;\n@@ -53,1 +54,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -58,2 +59,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -181,19 +180,0 @@\n-    @DataProvider\n-    public Object[][] byteIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1041,0 +1021,277 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":279,"deletions":22,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -1011,30 +1009,0 @@\n-    @DataProvider\n-    public Object[][] byteUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().flatMap(fn ->\n-              BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4925,116 +4893,0 @@\n-    static byte[] gather(byte a[], int ix, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void gatherByte256VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte256VectorTests::gather);\n-    }\n-    static byte[] gatherMasked(byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedByte256VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte256VectorTests::gatherMasked);\n-    }\n-\n-    static byte[] scatter(byte a[], int ix, int[] b, int iy) {\n-      byte[] res = new byte[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void scatterByte256VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte256VectorTests::scatter);\n-    }\n-\n-    static byte[] scatterMasked(byte r[], byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      byte[] oldVal = gather(r, ix, b, iy);\n-      byte[] newVal = new byte[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      byte[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Arrays;\n@@ -53,1 +54,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -58,2 +59,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -181,19 +180,0 @@\n-    @DataProvider\n-    public Object[][] byteIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1041,0 +1021,277 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":279,"deletions":22,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -1011,30 +1009,0 @@\n-    @DataProvider\n-    public Object[][] byteUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().flatMap(fn ->\n-              BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4925,116 +4893,0 @@\n-    static byte[] gather(byte a[], int ix, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void gatherByte512VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte512VectorTests::gather);\n-    }\n-    static byte[] gatherMasked(byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedByte512VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte512VectorTests::gatherMasked);\n-    }\n-\n-    static byte[] scatter(byte a[], int ix, int[] b, int iy) {\n-      byte[] res = new byte[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void scatterByte512VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte512VectorTests::scatter);\n-    }\n-\n-    static byte[] scatterMasked(byte r[], byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      byte[] oldVal = gather(r, ix, b, iy);\n-      byte[] newVal = new byte[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      byte[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Arrays;\n@@ -53,1 +54,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -58,2 +59,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -181,19 +180,0 @@\n-    @DataProvider\n-    public Object[][] byteIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1041,0 +1021,277 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":279,"deletions":22,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -1011,30 +1009,0 @@\n-    @DataProvider\n-    public Object[][] byteUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().flatMap(fn ->\n-              BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4925,116 +4893,0 @@\n-    static byte[] gather(byte a[], int ix, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void gatherByte64VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte64VectorTests::gather);\n-    }\n-    static byte[] gatherMasked(byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedByte64VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte64VectorTests::gatherMasked);\n-    }\n-\n-    static byte[] scatter(byte a[], int ix, int[] b, int iy) {\n-      byte[] res = new byte[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void scatterByte64VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte64VectorTests::scatter);\n-    }\n-\n-    static byte[] scatterMasked(byte r[], byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      byte[] oldVal = gather(r, ix, b, iy);\n-      byte[] newVal = new byte[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      byte[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.Arrays;\n@@ -57,1 +58,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -67,2 +68,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -190,19 +189,0 @@\n-    @DataProvider\n-    public Object[][] byteIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1050,0 +1030,277 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":279,"deletions":22,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -1016,30 +1014,0 @@\n-    @DataProvider\n-    public Object[][] byteUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().flatMap(fn ->\n-              BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4930,116 +4898,0 @@\n-    static byte[] gather(byte a[], int ix, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void gatherByteMaxVectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::gather);\n-    }\n-    static byte[] gatherMasked(byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedByteMaxVectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::gatherMasked);\n-    }\n-\n-    static byte[] scatter(byte a[], int ix, int[] b, int iy) {\n-      byte[] res = new byte[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void scatterByteMaxVectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::scatter);\n-    }\n-\n-    static byte[] scatterMasked(byte r[], byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      byte[] oldVal = gather(r, ix, b, iy);\n-      byte[] newVal = new byte[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      byte[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] doubleIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -1143,30 +1141,0 @@\n-    @DataProvider\n-    public Object[][] doubleUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().flatMap(fn ->\n-              DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4497,116 +4465,0 @@\n-    static double[] gather(double a[], int ix, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void gatherDouble128VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double128VectorTests::gather);\n-    }\n-    static double[] gatherMasked(double a[], int ix, boolean[] mask, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedDouble128VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double128VectorTests::gatherMasked);\n-    }\n-\n-    static double[] scatter(double a[], int ix, int[] b, int iy) {\n-      double[] res = new double[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void scatterDouble128VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double128VectorTests::scatter);\n-    }\n-\n-    static double[] scatterMasked(double r[], double a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      double[] oldVal = gather(r, ix, b, iy);\n-      double[] newVal = new double[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      double[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedDouble128VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] doubleIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -1143,30 +1141,0 @@\n-    @DataProvider\n-    public Object[][] doubleUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().flatMap(fn ->\n-              DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4497,116 +4465,0 @@\n-    static double[] gather(double a[], int ix, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void gatherDouble256VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double256VectorTests::gather);\n-    }\n-    static double[] gatherMasked(double a[], int ix, boolean[] mask, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedDouble256VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double256VectorTests::gatherMasked);\n-    }\n-\n-    static double[] scatter(double a[], int ix, int[] b, int iy) {\n-      double[] res = new double[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void scatterDouble256VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double256VectorTests::scatter);\n-    }\n-\n-    static double[] scatterMasked(double r[], double a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      double[] oldVal = gather(r, ix, b, iy);\n-      double[] newVal = new double[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      double[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedDouble256VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] doubleIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -1143,30 +1141,0 @@\n-    @DataProvider\n-    public Object[][] doubleUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().flatMap(fn ->\n-              DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4497,116 +4465,0 @@\n-    static double[] gather(double a[], int ix, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void gatherDouble512VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double512VectorTests::gather);\n-    }\n-    static double[] gatherMasked(double a[], int ix, boolean[] mask, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedDouble512VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double512VectorTests::gatherMasked);\n-    }\n-\n-    static double[] scatter(double a[], int ix, int[] b, int iy) {\n-      double[] res = new double[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void scatterDouble512VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double512VectorTests::scatter);\n-    }\n-\n-    static double[] scatterMasked(double r[], double a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      double[] oldVal = gather(r, ix, b, iy);\n-      double[] newVal = new double[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      double[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedDouble512VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] doubleIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -1143,30 +1141,0 @@\n-    @DataProvider\n-    public Object[][] doubleUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().flatMap(fn ->\n-              DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4497,116 +4465,0 @@\n-    static double[] gather(double a[], int ix, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void gatherDouble64VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double64VectorTests::gather);\n-    }\n-    static double[] gatherMasked(double a[], int ix, boolean[] mask, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedDouble64VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double64VectorTests::gatherMasked);\n-    }\n-\n-    static double[] scatter(double a[], int ix, int[] b, int iy) {\n-      double[] res = new double[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void scatterDouble64VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double64VectorTests::scatter);\n-    }\n-\n-    static double[] scatterMasked(double r[], double a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      double[] oldVal = gather(r, ix, b, iy);\n-      double[] newVal = new double[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      double[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedDouble64VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Arrays;\n@@ -58,1 +59,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -68,2 +69,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -201,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] doubleIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -974,0 +954,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -1148,30 +1146,0 @@\n-    @DataProvider\n-    public Object[][] doubleUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().flatMap(fn ->\n-              DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4502,116 +4470,0 @@\n-    static double[] gather(double a[], int ix, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void gatherDoubleMaxVectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::gather);\n-    }\n-    static double[] gatherMasked(double a[], int ix, boolean[] mask, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedDoubleMaxVectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, DoubleMaxVectorTests::gatherMasked);\n-    }\n-\n-    static double[] scatter(double a[], int ix, int[] b, int iy) {\n-      double[] res = new double[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void scatterDoubleMaxVectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::scatter);\n-    }\n-\n-    static double[] scatterMasked(double r[], double a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      double[] oldVal = gather(r, ix, b, iy);\n-      double[] newVal = new double[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      double[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedDoubleMaxVectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, DoubleMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] floatIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -1153,30 +1151,0 @@\n-    @DataProvider\n-    public Object[][] floatUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().flatMap(fn ->\n-              FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4465,116 +4433,0 @@\n-    static float[] gather(float a[], int ix, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void gatherFloat128VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float128VectorTests::gather);\n-    }\n-    static float[] gatherMasked(float a[], int ix, boolean[] mask, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedFloat128VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float128VectorTests::gatherMasked);\n-    }\n-\n-    static float[] scatter(float a[], int ix, int[] b, int iy) {\n-      float[] res = new float[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void scatterFloat128VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float128VectorTests::scatter);\n-    }\n-\n-    static float[] scatterMasked(float r[], float a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      float[] oldVal = gather(r, ix, b, iy);\n-      float[] newVal = new float[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      float[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedFloat128VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] floatIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -1153,30 +1151,0 @@\n-    @DataProvider\n-    public Object[][] floatUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().flatMap(fn ->\n-              FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4465,116 +4433,0 @@\n-    static float[] gather(float a[], int ix, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void gatherFloat256VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float256VectorTests::gather);\n-    }\n-    static float[] gatherMasked(float a[], int ix, boolean[] mask, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedFloat256VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float256VectorTests::gatherMasked);\n-    }\n-\n-    static float[] scatter(float a[], int ix, int[] b, int iy) {\n-      float[] res = new float[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void scatterFloat256VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float256VectorTests::scatter);\n-    }\n-\n-    static float[] scatterMasked(float r[], float a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      float[] oldVal = gather(r, ix, b, iy);\n-      float[] newVal = new float[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      float[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedFloat256VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] floatIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -1153,30 +1151,0 @@\n-    @DataProvider\n-    public Object[][] floatUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().flatMap(fn ->\n-              FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4465,116 +4433,0 @@\n-    static float[] gather(float a[], int ix, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void gatherFloat512VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float512VectorTests::gather);\n-    }\n-    static float[] gatherMasked(float a[], int ix, boolean[] mask, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedFloat512VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float512VectorTests::gatherMasked);\n-    }\n-\n-    static float[] scatter(float a[], int ix, int[] b, int iy) {\n-      float[] res = new float[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void scatterFloat512VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float512VectorTests::scatter);\n-    }\n-\n-    static float[] scatterMasked(float r[], float a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      float[] oldVal = gather(r, ix, b, iy);\n-      float[] newVal = new float[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      float[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedFloat512VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] floatIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -1153,30 +1151,0 @@\n-    @DataProvider\n-    public Object[][] floatUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().flatMap(fn ->\n-              FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4465,116 +4433,0 @@\n-    static float[] gather(float a[], int ix, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void gatherFloat64VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float64VectorTests::gather);\n-    }\n-    static float[] gatherMasked(float a[], int ix, boolean[] mask, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedFloat64VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float64VectorTests::gatherMasked);\n-    }\n-\n-    static float[] scatter(float a[], int ix, int[] b, int iy) {\n-      float[] res = new float[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void scatterFloat64VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float64VectorTests::scatter);\n-    }\n-\n-    static float[] scatterMasked(float r[], float a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      float[] oldVal = gather(r, ix, b, iy);\n-      float[] newVal = new float[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      float[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedFloat64VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Arrays;\n@@ -58,1 +59,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -68,2 +69,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -201,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] floatIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -974,0 +954,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -1158,30 +1156,0 @@\n-    @DataProvider\n-    public Object[][] floatUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().flatMap(fn ->\n-              FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4470,116 +4438,0 @@\n-    static float[] gather(float a[], int ix, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void gatherFloatMaxVectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::gather);\n-    }\n-    static float[] gatherMasked(float a[], int ix, boolean[] mask, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedFloatMaxVectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, FloatMaxVectorTests::gatherMasked);\n-    }\n-\n-    static float[] scatter(float a[], int ix, int[] b, int iy) {\n-      float[] res = new float[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void scatterFloatMaxVectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::scatter);\n-    }\n-\n-    static float[] scatterMasked(float r[], float a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      float[] oldVal = gather(r, ix, b, iy);\n-      float[] newVal = new float[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      float[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedFloatMaxVectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, FloatMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] intIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -971,30 +969,0 @@\n-    @DataProvider\n-    public Object[][] intUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().flatMap(fn ->\n-              INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4890,116 +4858,0 @@\n-    static int[] gather(int a[], int ix, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void gatherInt128VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int128VectorTests::gather);\n-    }\n-    static int[] gatherMasked(int a[], int ix, boolean[] mask, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedInt128VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int128VectorTests::gatherMasked);\n-    }\n-\n-    static int[] scatter(int a[], int ix, int[] b, int iy) {\n-      int[] res = new int[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void scatterInt128VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int128VectorTests::scatter);\n-    }\n-\n-    static int[] scatterMasked(int r[], int a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      int[] oldVal = gather(r, ix, b, iy);\n-      int[] newVal = new int[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      int[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] intIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -971,30 +969,0 @@\n-    @DataProvider\n-    public Object[][] intUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().flatMap(fn ->\n-              INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4890,116 +4858,0 @@\n-    static int[] gather(int a[], int ix, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void gatherInt256VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int256VectorTests::gather);\n-    }\n-    static int[] gatherMasked(int a[], int ix, boolean[] mask, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedInt256VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int256VectorTests::gatherMasked);\n-    }\n-\n-    static int[] scatter(int a[], int ix, int[] b, int iy) {\n-      int[] res = new int[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void scatterInt256VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int256VectorTests::scatter);\n-    }\n-\n-    static int[] scatterMasked(int r[], int a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      int[] oldVal = gather(r, ix, b, iy);\n-      int[] newVal = new int[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      int[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] intIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -971,30 +969,0 @@\n-    @DataProvider\n-    public Object[][] intUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().flatMap(fn ->\n-              INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4890,116 +4858,0 @@\n-    static int[] gather(int a[], int ix, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void gatherInt512VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int512VectorTests::gather);\n-    }\n-    static int[] gatherMasked(int a[], int ix, boolean[] mask, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedInt512VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int512VectorTests::gatherMasked);\n-    }\n-\n-    static int[] scatter(int a[], int ix, int[] b, int iy) {\n-      int[] res = new int[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void scatterInt512VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int512VectorTests::scatter);\n-    }\n-\n-    static int[] scatterMasked(int r[], int a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      int[] oldVal = gather(r, ix, b, iy);\n-      int[] newVal = new int[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      int[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] intIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -971,30 +969,0 @@\n-    @DataProvider\n-    public Object[][] intUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().flatMap(fn ->\n-              INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4890,116 +4858,0 @@\n-    static int[] gather(int a[], int ix, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void gatherInt64VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int64VectorTests::gather);\n-    }\n-    static int[] gatherMasked(int a[], int ix, boolean[] mask, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedInt64VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int64VectorTests::gatherMasked);\n-    }\n-\n-    static int[] scatter(int a[], int ix, int[] b, int iy) {\n-      int[] res = new int[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void scatterInt64VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int64VectorTests::scatter);\n-    }\n-\n-    static int[] scatterMasked(int r[], int a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      int[] oldVal = gather(r, ix, b, iy);\n-      int[] newVal = new int[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      int[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Arrays;\n@@ -58,1 +59,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -68,2 +69,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -201,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] intIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -974,0 +954,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -976,30 +974,0 @@\n-    @DataProvider\n-    public Object[][] intUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().flatMap(fn ->\n-              INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4895,116 +4863,0 @@\n-    static int[] gather(int a[], int ix, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void gatherIntMaxVectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::gather);\n-    }\n-    static int[] gatherMasked(int a[], int ix, boolean[] mask, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedIntMaxVectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::gatherMasked);\n-    }\n-\n-    static int[] scatter(int a[], int ix, int[] b, int iy) {\n-      int[] res = new int[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void scatterIntMaxVectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::scatter);\n-    }\n-\n-    static int[] scatterMasked(int r[], int a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      int[] oldVal = gather(r, ix, b, iy);\n-      int[] newVal = new int[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      int[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] longIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -997,30 +995,0 @@\n-    @DataProvider\n-    public Object[][] longUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().flatMap(fn ->\n-              LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4840,116 +4808,0 @@\n-    static long[] gather(long a[], int ix, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void gatherLong128VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long128VectorTests::gather);\n-    }\n-    static long[] gatherMasked(long a[], int ix, boolean[] mask, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedLong128VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long128VectorTests::gatherMasked);\n-    }\n-\n-    static long[] scatter(long a[], int ix, int[] b, int iy) {\n-      long[] res = new long[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void scatterLong128VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long128VectorTests::scatter);\n-    }\n-\n-    static long[] scatterMasked(long r[], long a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      long[] oldVal = gather(r, ix, b, iy);\n-      long[] newVal = new long[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      long[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] longIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -997,30 +995,0 @@\n-    @DataProvider\n-    public Object[][] longUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().flatMap(fn ->\n-              LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4840,116 +4808,0 @@\n-    static long[] gather(long a[], int ix, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void gatherLong256VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long256VectorTests::gather);\n-    }\n-    static long[] gatherMasked(long a[], int ix, boolean[] mask, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedLong256VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long256VectorTests::gatherMasked);\n-    }\n-\n-    static long[] scatter(long a[], int ix, int[] b, int iy) {\n-      long[] res = new long[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void scatterLong256VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long256VectorTests::scatter);\n-    }\n-\n-    static long[] scatterMasked(long r[], long a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      long[] oldVal = gather(r, ix, b, iy);\n-      long[] newVal = new long[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      long[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] longIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -997,30 +995,0 @@\n-    @DataProvider\n-    public Object[][] longUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().flatMap(fn ->\n-              LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4840,116 +4808,0 @@\n-    static long[] gather(long a[], int ix, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void gatherLong512VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long512VectorTests::gather);\n-    }\n-    static long[] gatherMasked(long a[], int ix, boolean[] mask, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedLong512VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long512VectorTests::gatherMasked);\n-    }\n-\n-    static long[] scatter(long a[], int ix, int[] b, int iy) {\n-      long[] res = new long[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void scatterLong512VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long512VectorTests::scatter);\n-    }\n-\n-    static long[] scatterMasked(long r[], long a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      long[] oldVal = gather(r, ix, b, iy);\n-      long[] newVal = new long[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      long[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] longIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -997,30 +995,0 @@\n-    @DataProvider\n-    public Object[][] longUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().flatMap(fn ->\n-              LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4840,116 +4808,0 @@\n-    static long[] gather(long a[], int ix, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void gatherLong64VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long64VectorTests::gather);\n-    }\n-    static long[] gatherMasked(long a[], int ix, boolean[] mask, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedLong64VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long64VectorTests::gatherMasked);\n-    }\n-\n-    static long[] scatter(long a[], int ix, int[] b, int iy) {\n-      long[] res = new long[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void scatterLong64VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long64VectorTests::scatter);\n-    }\n-\n-    static long[] scatterMasked(long r[], long a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      long[] oldVal = gather(r, ix, b, iy);\n-      long[] newVal = new long[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      long[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Arrays;\n@@ -58,1 +59,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -68,2 +69,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -201,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] longIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -974,0 +954,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -1002,30 +1000,0 @@\n-    @DataProvider\n-    public Object[][] longUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().flatMap(fn ->\n-              LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4845,116 +4813,0 @@\n-    static long[] gather(long a[], int ix, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void gatherLongMaxVectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::gather);\n-    }\n-    static long[] gatherMasked(long a[], int ix, boolean[] mask, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedLongMaxVectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::gatherMasked);\n-    }\n-\n-    static long[] scatter(long a[], int ix, int[] b, int iy) {\n-      long[] res = new long[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void scatterLongMaxVectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::scatter);\n-    }\n-\n-    static long[] scatterMasked(long r[], long a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      long[] oldVal = gather(r, ix, b, iy);\n-      long[] newVal = new long[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      long[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] shortIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1209,0 +1189,297 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":299,"deletions":22,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -1001,30 +999,0 @@\n-    @DataProvider\n-    public Object[][] shortUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().flatMap(fn ->\n-              SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4915,116 +4883,0 @@\n-    static short[] gather(short a[], int ix, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void gatherShort128VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short128VectorTests::gather);\n-    }\n-    static short[] gatherMasked(short a[], int ix, boolean[] mask, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedShort128VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short128VectorTests::gatherMasked);\n-    }\n-\n-    static short[] scatter(short a[], int ix, int[] b, int iy) {\n-      short[] res = new short[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void scatterShort128VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short128VectorTests::scatter);\n-    }\n-\n-    static short[] scatterMasked(short r[], short a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      short[] oldVal = gather(r, ix, b, iy);\n-      short[] newVal = new short[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      short[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] shortIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1209,0 +1189,297 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":299,"deletions":22,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -1001,30 +999,0 @@\n-    @DataProvider\n-    public Object[][] shortUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().flatMap(fn ->\n-              SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4915,116 +4883,0 @@\n-    static short[] gather(short a[], int ix, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void gatherShort256VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short256VectorTests::gather);\n-    }\n-    static short[] gatherMasked(short a[], int ix, boolean[] mask, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedShort256VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short256VectorTests::gatherMasked);\n-    }\n-\n-    static short[] scatter(short a[], int ix, int[] b, int iy) {\n-      short[] res = new short[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void scatterShort256VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short256VectorTests::scatter);\n-    }\n-\n-    static short[] scatterMasked(short r[], short a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      short[] oldVal = gather(r, ix, b, iy);\n-      short[] newVal = new short[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      short[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] shortIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1209,0 +1189,297 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":299,"deletions":22,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -1001,30 +999,0 @@\n-    @DataProvider\n-    public Object[][] shortUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().flatMap(fn ->\n-              SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4915,116 +4883,0 @@\n-    static short[] gather(short a[], int ix, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void gatherShort512VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short512VectorTests::gather);\n-    }\n-    static short[] gatherMasked(short a[], int ix, boolean[] mask, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedShort512VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short512VectorTests::gatherMasked);\n-    }\n-\n-    static short[] scatter(short a[], int ix, int[] b, int iy) {\n-      short[] res = new short[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void scatterShort512VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short512VectorTests::scatter);\n-    }\n-\n-    static short[] scatterMasked(short r[], short a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      short[] oldVal = gather(r, ix, b, iy);\n-      short[] newVal = new short[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      short[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] shortIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1209,0 +1189,297 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":299,"deletions":22,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -1001,30 +999,0 @@\n-    @DataProvider\n-    public Object[][] shortUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().flatMap(fn ->\n-              SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4915,116 +4883,0 @@\n-    static short[] gather(short a[], int ix, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void gatherShort64VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short64VectorTests::gather);\n-    }\n-    static short[] gatherMasked(short a[], int ix, boolean[] mask, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedShort64VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short64VectorTests::gatherMasked);\n-    }\n-\n-    static short[] scatter(short a[], int ix, int[] b, int iy) {\n-      short[] res = new short[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void scatterShort64VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short64VectorTests::scatter);\n-    }\n-\n-    static short[] scatterMasked(short r[], short a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      short[] oldVal = gather(r, ix, b, iy);\n-      short[] newVal = new short[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      short[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Arrays;\n@@ -58,1 +59,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -68,2 +69,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -201,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] shortIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1218,0 +1198,297 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":299,"deletions":22,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -1006,30 +1004,0 @@\n-    @DataProvider\n-    public Object[][] shortUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().flatMap(fn ->\n-              SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4920,116 +4888,0 @@\n-    static short[] gather(short a[], int ix, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void gatherShortMaxVectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::gather);\n-    }\n-    static short[] gatherMasked(short a[], int ix, boolean[] mask, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedShortMaxVectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::gatherMasked);\n-    }\n-\n-    static short[] scatter(short a[], int ix, int[] b, int iy) {\n-      short[] res = new short[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void scatterShortMaxVectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::scatter);\n-    }\n-\n-    static short[] scatterMasked(short r[], short a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      short[] oldVal = gather(r, ix, b, iy);\n-      short[] newVal = new short[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      short[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShuffle;\n@@ -28,0 +30,1 @@\n+import org.testng.Assert;\n@@ -30,0 +33,1 @@\n+import java.util.List;\n@@ -55,0 +59,10 @@\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedLegalCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE, true);\n+    }\n+\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedIllegalCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE, false);\n+    }\n+\n@@ -78,0 +92,20 @@\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedLegalCastSpecies\")\n+    static <E,F> void shuffleCast(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        legal_shuffle_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedIllegalCastSpecies\")\n+    static <E,F> void shuffleCastNeg(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        illegal_shuffle_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedLegalCastSpecies\")\n+    static <E,F> void maskCast(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        legal_mask_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedIllegalCastSpecies\")\n+    static <E,F> void maskCastNeg(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        illegal_mask_cast_kernel(src, dst);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector128ConversionTests.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShuffle;\n@@ -28,0 +30,1 @@\n+import org.testng.Assert;\n@@ -30,0 +33,1 @@\n+import java.util.List;\n@@ -55,0 +59,10 @@\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedLegalCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE, true);\n+    }\n+\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedIllegalCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE, false);\n+    }\n+\n@@ -78,0 +92,20 @@\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedLegalCastSpecies\")\n+    static <E,F> void shuffleCast(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        legal_shuffle_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedIllegalCastSpecies\")\n+    static <E,F> void shuffleCastNeg(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        illegal_shuffle_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedLegalCastSpecies\")\n+    static <E,F> void maskCast(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        legal_mask_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedIllegalCastSpecies\")\n+    static <E,F> void maskCastNeg(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        illegal_mask_cast_kernel(src, dst);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector256ConversionTests.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShuffle;\n@@ -28,0 +30,1 @@\n+import org.testng.Assert;\n@@ -30,0 +33,1 @@\n+import java.util.List;\n@@ -55,0 +59,10 @@\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedLegalCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE, true);\n+    }\n+\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedIllegalCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE, false);\n+    }\n+\n@@ -78,0 +92,20 @@\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedLegalCastSpecies\")\n+    static <E,F> void shuffleCast(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        legal_shuffle_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedIllegalCastSpecies\")\n+    static <E,F> void shuffleCastNeg(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        illegal_shuffle_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedLegalCastSpecies\")\n+    static <E,F> void maskCast(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        legal_mask_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedIllegalCastSpecies\")\n+    static <E,F> void maskCastNeg(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        illegal_mask_cast_kernel(src, dst);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector512ConversionTests.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShuffle;\n@@ -28,0 +30,1 @@\n+import org.testng.Assert;\n@@ -30,1 +33,1 @@\n-\n+import java.util.List;\n@@ -77,0 +80,10 @@\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedLegalCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE, true);\n+    }\n+\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedIllegalCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE, false);\n+    }\n+\n@@ -100,0 +113,20 @@\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedLegalCastSpecies\")\n+    static <E,F> void shuffleCast(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        legal_shuffle_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedIllegalCastSpecies\")\n+    static <E,F> void shuffleCastNeg(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        illegal_shuffle_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedLegalCastSpecies\")\n+    static <E,F> void maskCast(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        legal_mask_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedIllegalCastSpecies\")\n+    static <E,F> void maskCastNeg(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        illegal_mask_cast_kernel(src, dst);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector64ConversionTests.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShuffle;\n@@ -28,0 +30,1 @@\n+import org.testng.Assert;\n@@ -30,0 +33,1 @@\n+import java.util.List;\n@@ -54,0 +58,10 @@\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedLegalCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE, true);\n+    }\n+\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedIllegalCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE, false);\n+    }\n+\n@@ -77,0 +91,20 @@\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedLegalCastSpecies\")\n+    static <E,F> void shuffleCast(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        legal_shuffle_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedIllegalCastSpecies\")\n+    static <E,F> void shuffleCastNeg(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        illegal_shuffle_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedLegalCastSpecies\")\n+    static <E,F> void maskCast(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        legal_mask_cast_kernel(src, dst);\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedIllegalCastSpecies\")\n+    static <E,F> void maskCastNeg(VectorSpecies<E> src, VectorSpecies<F> dst) {\n+        illegal_mask_cast_kernel(src, dst);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorMaxConversionTests.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -77,4 +77,0 @@\n-gather_template=\"Gather-op\"\n-gather_masked_template=\"Gather-Masked-op\"\n-scatter_template=\"Scatter-op\"\n-scatter_masked_template=\"Scatter-Masked-op\"\n@@ -561,6 +557,0 @@\n-# Gather Scatter operations.\n-gen_op_tmpl $gather_template \"gather\" \"\"\n-gen_op_tmpl $gather_masked_template \"gather\" \"\"\n-gen_op_tmpl $scatter_template \"scatter\" \"\"\n-gen_op_tmpl $scatter_masked_template \"scatter\" \"\"\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,12 +0,0 @@\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = new $type$[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Gather-Masked-op.template","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,10 +0,0 @@\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = new $type$[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Gather-op.template","additions":0,"deletions":10,"binary":false,"changes":10,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Scatter-Masked-op.template","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,10 +0,0 @@\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = new $type$[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Scatter-op.template","additions":0,"deletions":10,"binary":false,"changes":10,"status":"deleted"},{"patch":"@@ -1,17 +0,0 @@\n-    static $type$[] [[TEST]][[TEST_TYPE]]($type$ a[], int ix, boolean[] mask, int[] b, int iy) {\n-        $type$[] res = new $type$[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"$type$UnaryMaskedOpIndexProvider\")\n-    static void [[TEST]][[TEST_TYPE]]$vectorteststype$(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-[[KERNEL]]\n-        assertArraysEquals(r, a, b, mask, $vectorteststype$::[[TEST]][[TEST_TYPE]]);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Gather-Masked-op.template","additions":0,"deletions":17,"binary":false,"changes":17,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-    static $type$[] [[TEST]]($type$ a[], int ix, int[] b, int iy) {\n-        $type$[] res = new $type$[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"$type$UnaryOpIndexProvider\")\n-    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-[[KERNEL]]\n-        assertArraysEquals(r, a, b, $vectorteststype$::[[TEST]]);\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Gather-op.template","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-    static $type$[] [[TEST]][[TEST_TYPE]]($type$ r[], $type$ a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      $type$[] oldVal = gather(r, ix, b, iy);\n-      $type$[] newVal = new $type$[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      $type$[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void [[TEST]][[TEST_TYPE]]$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-[[KERNEL]]\n-        assertArraysEquals(r, a, b, mask, $vectorteststype$::[[TEST]][[TEST_TYPE]]);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Scatter-Masked-op.template","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-    static $type$[] [[TEST]]($type$ a[], int ix, int[] b, int iy) {\n-      $type$[] res = new $type$[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"$type$UnaryOpIndexProvider\")\n-    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-[[KERNEL]]\n-        assertArraysEquals(r, a, b, $vectorteststype$::[[TEST]]);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Scatter-op.template","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -94,2 +94,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * ($bits$ \/ 8));\n-\n@@ -1220,30 +1218,0 @@\n-    @DataProvider\n-    public Object[][] $type$UnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> $TYPE$_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] $type$UnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            $TYPE$_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            $TYPE$_GENERATORS.stream().flatMap(fn ->\n-              $TYPE$_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import java.util.Arrays;\n@@ -73,1 +74,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -85,2 +86,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * ($bits$ \/ 8));\n-\n@@ -220,19 +219,0 @@\n-    @DataProvider\n-    public Object[][] $type$IndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> $TYPE$_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] $type$IndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> $TYPE$_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1332,0 +1312,426 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals($type$[] r, $type$[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals($type$[] r, $type$[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: ($type$) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: ($type$) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals($type$[] r, $type$[] a, int[] indexMap, boolean[] mask) {\n+        $type$[] expected = new $type$[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals($type$[] r, $type$[] a, int[] indexMap) {\n+        $type$[] expected = new $type$[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> $TYPE$_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            $TYPE$_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+#if[short]\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+#end[short]\n+\n+#if[byte]\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+#end[byte]\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":428,"deletions":22,"binary":false,"changes":450,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-            \"RebuildFreeList\"\n+            \"RebuildFreeList\",\n+            \"SampleCandidates\"\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.oldobject;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedObject;\n+import jdk.jfr.internal.test.WhiteBox;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @run main\/othervm  -XX:TLABSize=2k jdk.jfr.event.oldobject.TestObjectSize\n+ *\/\n+public class TestObjectSize {\n+\n+    private interface Leak {\n+    }\n+    private static class Leak1 implements Leak {\n+        private long field1;\n+    }\n+    private static class Leak2 implements Leak {\n+        private long field1;\n+        private long field2;\n+    }\n+    private static class Leak3 implements Leak {\n+        private long field1;\n+        private long field2;\n+        private long field3;\n+    }\n+\n+    public static List<Object> leak = new ArrayList<>(OldObjects.MIN_SIZE);\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox.setWriteAllObjectSamples(true);\n+\n+        final Random rand = new Random(1L);\n+\n+        long sizeLeak1, sizeLeak2, sizeLeak3;\n+\n+        do {\n+            sizeLeak1 = -1;\n+            sizeLeak2 = -1;\n+            sizeLeak3 = -1;\n+\n+            try (Recording recording = new Recording()) {\n+                leak.clear();\n+                recording.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n+                recording.start();\n+\n+                for (int i = 0; i < 1000; i++) {\n+                    switch (rand.nextInt(3)) {\n+                    case 0: leak.add(new Leak1()); break;\n+                    case 1: leak.add(new Leak2()); break;\n+                    case 2: leak.add(new Leak3()); break;\n+                    }\n+                }\n+\n+                recording.stop();\n+\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                Events.hasEvents(events);\n+                for (RecordedEvent e : events) {\n+                    RecordedObject object = e.getValue(\"object\");\n+                    RecordedClass type = object.getValue(\"type\");\n+                    long objectSize = e.getLong(\"objectSize\");\n+                    System.err.println(\"type = \" + type.getName() + \", objectSize = \" + e.getLong(\"objectSize\"));\n+                    if (objectSize <= 0) {\n+                        throw new Exception(\"Object size for \" + type.getName() + \" is lower or equal to 0\");\n+                    }\n+                    if (type.getName().equals(Leak1.class.getName())) {\n+                        sizeLeak1 = objectSize;\n+                    }\n+                    if (type.getName().equals(Leak2.class.getName())) {\n+                        sizeLeak2 = objectSize;\n+                    }\n+                    if (type.getName().equals(Leak3.class.getName())) {\n+                        sizeLeak3 = objectSize;\n+                    }\n+                }\n+            }\n+        } while (sizeLeak1 == -1 || sizeLeak2 == -1 || sizeLeak3 == -1);\n+\n+        if (sizeLeak3 <= sizeLeak2) {\n+            throw new Exception(\"Object size for \" + Leak3.class.getName() + \" is lower or equal to size for\" + Leak2.class.getName());\n+        }\n+        if (sizeLeak2 <= sizeLeak1) {\n+            throw new Exception(\"Object size for \" + Leak2.class.getName() + \" is lower or equal to size for\" + Leak1.class.getName());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestObjectSize.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -1,305 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.runtime;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.*;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.dcmd.PidJcmdExecutor;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.util.*;\n-import java.util.concurrent.FutureTask;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * @test\n- * @key jfr\n- * @requires vm.hasJFR\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UseBiasedLocking jdk.jfr.event.runtime.TestBiasedLockRevocationEvents\n- *\/\n-public class TestBiasedLockRevocationEvents {\n-\n-    public static void main(String[] args) throws Throwable {\n-        testSingleRevocation();\n-        testBulkRevocation();\n-        testSelfRevocation();\n-        testExitedThreadRevocation();\n-        testBulkRevocationNoRebias();\n-        testRevocationSafepointIdCorrelation();\n-    }\n-\n-    \/\/ Default value of BiasedLockingBulkRebiasThreshold is 20, and BiasedLockingBulkRevokeTreshold is 40.\n-    \/\/ Using a value that will hit the first threshold once, and the second one the next time.\n-    private static final int BULK_REVOKE_THRESHOLD = 25;\n-\n-    static void touch(Object lock) {\n-        synchronized(lock) {\n-        }\n-    }\n-\n-    static Thread triggerRevocation(int numRevokes, Class<?> lockClass) throws Throwable {\n-        Object[] locks = new Object[numRevokes];\n-        for (int i = 0; i < locks.length; ++i) {\n-            locks[i] = lockClass.getDeclaredConstructor().newInstance();\n-            touch(locks[i]);\n-        }\n-\n-        Thread biasBreaker = new Thread(\"BiasBreaker\") {\n-            @Override\n-            public void run() {\n-                for (Object lock : locks) {\n-                    touch(lock);\n-                }\n-            }\n-        };\n-\n-        biasBreaker.start();\n-        biasBreaker.join();\n-\n-        return biasBreaker;\n-    }\n-\n-    \/\/ Basic stack trace validation, checking the name of the leaf method\n-    static void validateStackTrace(RecordedStackTrace stackTrace, String leafMethodName) {\n-        List<RecordedFrame> frames = stackTrace.getFrames();\n-        Asserts.assertFalse(frames.isEmpty());\n-        String name = frames.get(0).getMethod().getName();\n-        Asserts.assertEquals(name, leafMethodName);\n-    }\n-\n-    \/\/ Validates that the given stack trace refers to lock.touch(); in triggerRevocation\n-    static void validateStackTrace(RecordedStackTrace stackTrace) {\n-        validateStackTrace(stackTrace, \"touch\");\n-    }\n-\n-    \/\/ Retrieve all biased lock revocation events related to the provided lock class, sorted by start time\n-    static List<RecordedEvent> getRevocationEvents(Recording recording, String eventTypeName, String fieldName, Class<?> lockClass) throws Throwable {\n-        return Events.fromRecording(recording).stream()\n-                .filter(e -> e.getEventType().getName().equals(eventTypeName))\n-                .filter(e -> ((RecordedClass)e.getValue(fieldName)).getName().equals(lockClass.getName()))\n-                .sorted(Comparator.comparing(RecordedEvent::getStartTime))\n-                .collect(Collectors.toList());\n-    }\n-\n-    static void testSingleRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker = triggerRevocation(1, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, biasBreaker);\n-        Events.assertEventThread(event, \"previousOwner\", Thread.currentThread());\n-\n-        RecordedClass lockClass = event.getValue(\"lockClass\");\n-        Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testBulkRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, \"revokedClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, biasBreaker);\n-        Events.assertField(event, \"disableBiasing\").equal(false);\n-\n-        RecordedClass lockClass = event.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testSelfRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockSelfRevocation);\n-        recording.start();\n-\n-        MyLock l = new MyLock();\n-        touch(l);\n-        Thread.holdsLock(l);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockSelfRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, Thread.currentThread());\n-\n-        validateStackTrace(event.getStackTrace(), \"holdsLock\");\n-    }\n-\n-    static void testExitedThreadRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockRevocation);\n-        recording.start();\n-\n-        FutureTask<MyLock> lockerTask = new FutureTask<>(() -> {\n-           MyLock l = new MyLock();\n-           touch(l);\n-           return l;\n-        });\n-\n-        Thread locker = new Thread(lockerTask, \"BiasLocker\");\n-        locker.start();\n-        locker.join();\n-\n-        \/\/ Even after joining, the VM has a bit more work to do before the thread is actually removed\n-        \/\/ from the threads list. Ensure that this has happened before proceeding.\n-        while (true) {\n-            PidJcmdExecutor jcmd = new PidJcmdExecutor();\n-            OutputAnalyzer oa = jcmd.execute(\"Thread.print\", true);\n-            String lockerThreadFound = oa.firstMatch(\"BiasLocker\");\n-            if (lockerThreadFound == null) {\n-                break;\n-            }\n-        };\n-\n-        MyLock l = lockerTask.get();\n-        touch(l);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, Thread.currentThread());\n-        \/\/ Previous owner will usually be null, but can also be a thread that\n-        \/\/ was created after the BiasLocker thread exited due to address reuse.\n-        RecordedThread prevOwner = event.getValue(\"previousOwner\");\n-        if (prevOwner != null) {\n-            Asserts.assertNE(prevOwner.getJavaName(), \"BiasLocker\");\n-        }\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testBulkRevocationNoRebias() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker0 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-        Thread biasBreaker1 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, \"revokedClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 2);\n-\n-        \/\/ The rebias event should occur before the noRebias one\n-        RecordedEvent eventRebias = events.get(0);\n-        RecordedEvent eventNoRebias = events.get(1);\n-\n-        Events.assertEventThread(eventRebias, biasBreaker0);\n-        Events.assertField(eventRebias, \"disableBiasing\").equal(false);\n-\n-        Events.assertEventThread(eventNoRebias, biasBreaker1);\n-        Events.assertField(eventNoRebias, \"disableBiasing\").equal(true);\n-\n-        RecordedClass lockClassRebias = eventRebias.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClassRebias.getName(), MyLock.class.getName());\n-        RecordedClass lockClassNoRebias = eventNoRebias.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClassNoRebias.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(eventRebias.getStackTrace());\n-        validateStackTrace(eventNoRebias.getStackTrace());\n-    }\n-\n-    static void testRevocationSafepointIdCorrelation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.enable(EventNames.ExecuteVMOperation);\n-        recording.start();\n-\n-        triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = Events.fromRecording(recording);\n-\n-        \/\/ Determine which safepoints included bulk revocation VM operations\n-        Set<Long> vmOperationsBulk = new HashSet<>();\n-\n-        for (RecordedEvent event : events) {\n-            if (event.getEventType().getName().equals(EventNames.ExecuteVMOperation)) {\n-                String operation = event.getValue(\"operation\");\n-                Long safepointId = event.getValue(\"safepointId\");\n-\n-                if (operation.equals(\"BulkRevokeBias\")) {\n-                    vmOperationsBulk.add(safepointId);\n-                }\n-            }\n-        }\n-\n-        int bulkRevokeCount = 0;\n-\n-        \/\/ Match all revoke events to a corresponding VMOperation event\n-        for (RecordedEvent event : events) {\n-            if (event.getEventType().getName().equals(EventNames.BiasedLockClassRevocation)) {\n-                Long safepointId = event.getValue(\"safepointId\");\n-                String lockClass = ((RecordedClass)event.getValue(\"revokedClass\")).getName();\n-                if (lockClass.toString().equals(MyLock.class.getName())) {\n-                    Asserts.assertTrue(vmOperationsBulk.contains(safepointId));\n-                    bulkRevokeCount++;\n-                }\n-            }\n-        }\n-\n-        Asserts.assertGT(bulkRevokeCount, 0);\n-    }\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestBiasedLockRevocationEvents.java","additions":0,"deletions":305,"binary":false,"changes":305,"status":"deleted"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @summary The test verifies JFR.stop\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jcmd.TestJcmdStopWithoutFilename\n+ *\/\n+public class TestJcmdStopWithoutFilename {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        JcmdHelper.jcmd(\"JFR.start name=test\");\n+        OutputAnalyzer output = JcmdHelper.jcmd(\"JFR.stop name=test\");\n+        output.shouldNotContain(\"written to\");\n+\n+        String filename = \"output.jfr\";\n+        JcmdHelper.jcmd(\"JFR.start name=test filename=\" + filename);\n+        output = JcmdHelper.jcmd(\"JFR.stop name=test\");\n+        output.shouldContain(\"written to\").shouldContain(filename);\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdStopWithoutFilename.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.util.*;\n-import java.io.IOException;\n-\n-\/**\n- * This class provides a partial implementation of the HttpCallback\n- * interface. Use this class if you want to use the requestURI as a means\n- * of tracking multiple invocations of a request (on the server).\n- * In this case, you implement the modified request() method, which includes\n- * an integer count parameter. This parameter indicates the number of times\n- * (starting at zero) the request URI has been received.\n- *\/\n-\n-public abstract class AbstractCallback implements HttpCallback {\n-\n-    Map requests;\n-\n-    static class Request {\n-        URI uri;\n-        int count;\n-\n-        Request (URI u) {\n-            uri = u;\n-            count = 0;\n-        }\n-    }\n-\n-    AbstractCallback () {\n-        requests = Collections.synchronizedMap (new HashMap());\n-    }\n-\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    public void request (HttpTransaction msg) {\n-        URI uri = msg.getRequestURI();\n-        Request req = (Request) requests.get (uri);\n-        if (req == null) {\n-            req = new Request (uri);\n-            requests.put (uri, req);\n-        }\n-        request (msg, req.count++);\n-    }\n-\n-    \/**\n-     * Same as HttpCallback interface except that the integer n\n-     * is provided to indicate sequencing of repeated requests using\n-     * the same request URI. n starts at zero and is incremented\n-     * for each successive call.\n-     *\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     * @param n value is 0 at first call, and is incremented by 1 for\n-     *        each subsequent call using the same request URI.\n-     *\/\n-    abstract public void request (HttpTransaction msg, int n);\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/AbstractCallback.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * @modules java.base\/sun.net.www\n- * @build TestHttpsServer HttpCallback\n+ * @library \/test\/lib\n@@ -37,3 +36,14 @@\n-import java.io.*;\n-import java.net.*;\n-import javax.net.ssl.*;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpRetryException;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.security.KeyStore;\n+import java.util.concurrent.Executors;\n@@ -42,1 +52,13 @@\n-public class ChunkedOutputStream implements HttpCallback {\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+\n+public class ChunkedOutputStream implements HttpHandler {\n@@ -60,20 +82,7 @@\n-    public void request(HttpTransaction req) {\n-        try {\n-            \/\/ this is needed (count++ doesn't work), 'cause we\n-            \/\/ are doing concurrent tests\n-            String path = req.getRequestURI().getPath();\n-            if (path.equals(\"\/d0\")) {\n-                count = 0;\n-            } else if (path.equals(\"\/d01\")) {\n-                count = 1;\n-            } else if (path.equals(\"\/d3\")) {\n-                count = 2;\n-            } else if (path.equals(\"\/d4\") || path.equals(\"\/d5\")) {\n-                count = 3;\n-            } else if (path.equals(\"\/d6\")) {\n-                count = 3;\n-            }  else if (path.equals(\"\/d7\")) {\n-                count = 4;\n-            }  else if (path.equals(\"\/d8\")) {\n-                count = 5;\n-            }\n+    private static String getAuthority() {\n+        InetAddress address = server.getAddress().getAddress();\n+        String hostaddr = address.getHostAddress();\n+        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n+        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n+        return hostaddr + \":\" + server.getAddress().getPort();\n+    }\n@@ -81,1 +90,22 @@\n-            switch (count) {\n+    public void handle(HttpExchange req) throws IOException {\n+        \/\/ this is needed (count++ doesn't work), 'cause we\n+        \/\/ are doing concurrent tests\n+        System.out.println(\"Request Received\");\n+        String path = req.getRequestURI().getPath();\n+        if (path.equals(\"\/d0\")) {\n+            count = 0;\n+        } else if (path.equals(\"\/d01\")) {\n+            count = 1;\n+        } else if (path.equals(\"\/d3\")) {\n+            count = 2;\n+        } else if (path.equals(\"\/d4\") || path.equals(\"\/d5\")) {\n+            count = 3;\n+        } else if (path.equals(\"\/d6\")) {\n+            count = 3;\n+        }  else if (path.equals(\"\/d7\")) {\n+            count = 4;\n+        }  else if (path.equals(\"\/d8\")) {\n+            count = 5;\n+        }\n+\n+        switch (count) {\n@@ -84,1 +114,5 @@\n-                String reqbody = req.getRequestEntityBody();\n+\n+                String reqbody = \"\";\n+                try(InputStream inputStream = req.getRequestBody()) {\n+                    reqbody = new String(inputStream.readAllBytes(), Charset.forName(\"ISO8859_1\"));\n+                }\n@@ -86,2 +120,2 @@\n-                    req.sendResponse(500, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(500, -1);\n+                    break;\n@@ -89,1 +123,1 @@\n-                String chunk = req.getRequestHeader(\"Transfer-encoding\");\n+                String chunk = req.getRequestHeaders().getFirst(\"Transfer-encoding\");\n@@ -91,2 +125,2 @@\n-                    req.sendResponse(501, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n@@ -94,1 +128,0 @@\n-                req.setResponseEntityBody(reqbody);\n@@ -96,1 +129,1 @@\n-                    req.setResponseHeader(\"Connection\", \"close\");\n+                    req.getResponseHeaders().set(\"Connection\", \"close\");\n@@ -98,3 +131,3 @@\n-                req.sendResponse(200, \"OK\");\n-                if (count == 1) {\n-                    req.orderlyClose();\n+                req.sendResponseHeaders(200, 0);\n+                try (OutputStream os = req.getResponseBody()) {\n+                    os.write(reqbody.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -104,1 +137,1 @@\n-                reqbody = req.getRequestEntityBody();\n+                reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n@@ -106,2 +139,2 @@\n-                    req.sendResponse(500, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(500, -1);\n+                    break;\n@@ -109,2 +142,1 @@\n-                int clen = Integer.parseInt (\n-                        req.getRequestHeader(\"Content-length\"));\n+                int clen = Integer.parseInt (req.getRequestHeaders().getFirst(\"Content-length\"));\n@@ -112,2 +144,7 @@\n-                    req.sendResponse(501, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n+                }\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(200, 0);\n+                try (OutputStream os = req.getResponseBody()) {\n+                    os.write(reqbody.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -115,4 +152,0 @@\n-                req.setResponseEntityBody (reqbody);\n-                req.setResponseHeader(\"Connection\", \"close\");\n-                req.sendResponse(200, \"OK\");\n-                req.orderlyClose();\n@@ -121,4 +154,6 @@\n-                req.setResponseHeader(\"Location\", \"https:\/\/foo.bar\/\");\n-                req.setResponseHeader(\"Connection\", \"close\");\n-                req.sendResponse(307, \"Temporary Redirect\");\n-                req.orderlyClose();\n+                if (path.equals(\"\/d6\")) {\n+                    reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n+                }\n+                req.getResponseHeaders().set(\"Location\", \"https:\/\/foo.bar\/\");\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(307, -1);\n@@ -128,1 +163,1 @@\n-                reqbody = req.getRequestEntityBody();\n+                reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n@@ -130,2 +165,2 @@\n-                    req.sendResponse(501, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n@@ -133,3 +168,2 @@\n-                req.setResponseHeader(\"Connection\", \"close\");\n-                req.sendResponse(200, \"OK\");\n-                req.orderlyClose();\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(200, -1);\n@@ -138,2 +172,1 @@\n-                req.sendResponse(404, \"Not Found\");\n-                req.orderlyClose();\n+                req.sendResponseHeaders(404, -1);\n@@ -141,3 +174,0 @@\n-            }\n-        } catch (IOException e) {\n-            e.printStackTrace();\n@@ -145,7 +175,1 @@\n-    }\n-\n-    public boolean dropPlainTextConnections() {\n-        System.out.println(\"Unrecognized SSL message, plaintext connection?\");\n-        System.out.println(\"TestHttpsServer receveived rogue connection: ignoring it.\");\n-        rogueCount.incrementAndGet();\n-        return true;\n+        req.close();\n@@ -182,3 +206,0 @@\n-            \/\/ on the client side, and confirm that this::dropPlainTextConnections\n-            \/\/ has ben called.\n-            if (rogueCount.get() == rogue) throw x;\n@@ -199,1 +220,1 @@\n-        os.write(str1.getBytes());\n+        os.write(str1.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -216,1 +237,1 @@\n-        os.write (str2.getBytes());\n+        os.write (str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -233,1 +254,1 @@\n-        os.write(str2.getBytes());\n+        os.write(str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -251,1 +272,1 @@\n-            os.write(str2.getBytes());\n+            os.write(str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -266,1 +287,1 @@\n-        os.write(str1.getBytes());\n+        os.write(str1.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -313,1 +334,1 @@\n-    static TestHttpsServer server;\n+    static HttpsServer server;\n@@ -316,0 +337,1 @@\n+        ChunkedOutputStream chunkedOutputStream = new ChunkedOutputStream();\n@@ -336,4 +358,26 @@\n-                server = new TestHttpsServer(\n-                        new ChunkedOutputStream(), 1, 10, loopback, 0);\n-                System.out.println(\"Server started: listening on: \" + server.getAuthority());\n-                testPlainText(server.getAuthority());\n+                \/\/ create and initialize a SSLContext\n+                KeyStore ks = KeyStore.getInstance(\"JKS\");\n+                KeyStore ts = KeyStore.getInstance(\"JKS\");\n+                char[] passphrase = \"passphrase\".toCharArray();\n+\n+                ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n+                ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n+\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+                kmf.init(ks, passphrase);\n+\n+                TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+                tmf.init(ts);\n+\n+                SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n+\n+                sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+                server = HttpsServer.create(new InetSocketAddress(loopback, 0), 10);\n+                server.setHttpsConfigurator(new HttpsConfigurator(sslCtx));\n+                server.createContext(\"\/\", chunkedOutputStream);\n+                server.setExecutor(Executors.newSingleThreadExecutor());\n+                server.start();\n+\n+                System.out.println(\"Server started: listening on: \" + getAuthority());\n+                testPlainText(getAuthority());\n@@ -342,7 +386,7 @@\n-                test1(\"https:\/\/\" + server.getAuthority() + \"\/d01\");\n-                test3(\"https:\/\/\" + server.getAuthority() + \"\/d3\");\n-                test4(\"https:\/\/\" + server.getAuthority() + \"\/d4\");\n-                test5(\"https:\/\/\" + server.getAuthority() + \"\/d5\");\n-                test6(\"https:\/\/\" + server.getAuthority() + \"\/d6\");\n-                test7(\"https:\/\/\" + server.getAuthority() + \"\/d7\");\n-                test8(\"https:\/\/\" + server.getAuthority() + \"\/d8\");\n+                test1(\"https:\/\/\" + getAuthority() + \"\/d01\");\n+                test3(\"https:\/\/\" + getAuthority() + \"\/d3\");\n+                test4(\"https:\/\/\" + getAuthority() + \"\/d4\");\n+                test5(\"https:\/\/\" + getAuthority() + \"\/d5\");\n+                test6(\"https:\/\/\" + getAuthority() + \"\/d6\");\n+                test7(\"https:\/\/\" + getAuthority() + \"\/d7\");\n+                test8(\"https:\/\/\" + getAuthority() + \"\/d8\");\n@@ -351,1 +395,1 @@\n-                    server.terminate();\n+                    server.stop(1);\n@@ -355,1 +399,1 @@\n-            server.terminate();\n+            server.stop(1);\n@@ -368,1 +412,1 @@\n-        server.terminate();\n+        server.stop(1);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/ChunkedOutputStream.java","additions":139,"deletions":95,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This interface is implemented by classes that wish to handle incoming HTTP\n- * requests and generate responses. This could be a general purpose HTTP server\n- * or a test case that expects specific requests from a client.\n- * <p>\n- * The incoming request fields can be examined via the {@link HttpTransaction}\n- * object, and a response can also be generated and sent via the request object.\n- *\/\n-public interface HttpCallback {\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    void request (HttpTransaction msg);\n-\n-    \/**\n-     * Tells whether the server should simply close the\n-     * connection and ignore the request when the first\n-     * byte received by the server looks like a plain\n-     * text connection.\n-     * @return true if the request should be ignored.\n-     **\/\n-    default boolean dropPlainTextConnections() {\n-        return false;\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpCallback.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,330 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import java.net.*;\n-import sun.net.www.MessageHeader;\n-\n-\/**\n- * This class encapsulates a HTTP request received and a response to be\n- * generated in one transaction. It provides methods for examaining the\n- * request from the client, and for building and sending a reply.\n- *\/\n-\n-public class HttpTransaction {\n-\n-    String command;\n-    URI requesturi;\n-    TestHttpsServer.ServerWorker server;\n-    MessageHeader reqheaders, reqtrailers;\n-    String reqbody;\n-    byte[] rspbody;\n-    MessageHeader rspheaders, rsptrailers;\n-    SocketChannel ch;\n-    int rspbodylen;\n-    boolean rspchunked;\n-\n-    HttpTransaction (TestHttpsServer.ServerWorker server, String command,\n-                        URI requesturi, MessageHeader headers,\n-                        String body, MessageHeader trailers, SocketChannel ch) {\n-        this.command = command;\n-        this.requesturi = requesturi;\n-        this.reqheaders = headers;\n-        this.reqbody = body;\n-        this.reqtrailers = trailers;\n-        this.ch = ch;\n-        this.server = server;\n-    }\n-\n-    \/**\n-     * Get the value of a request header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the request header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getRequestHeader (String key) {\n-        return reqheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the value of a response header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the response header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getResponseHeader (String key) {\n-        return rspheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the request URI\n-     *\n-     * @return the request URI\n-     *\/\n-    public URI getRequestURI () {\n-        return requesturi;\n-    }\n-\n-    public String toString () {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append (\"Request from: \").append (ch.toString()).append(\"\\r\\n\");\n-        buf.append (\"Command: \").append (command).append(\"\\r\\n\");\n-        buf.append (\"Request URI: \").append (requesturi).append(\"\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        buf.append (reqheaders.toString()).append(\"\\r\\n\");\n-        buf.append (\"Body: \").append (reqbody).append(\"\\r\\n\");\n-        buf.append (\"---------Response-------\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        if (rspheaders != null) {\n-            buf.append (rspheaders.toString()).append(\"\\r\\n\");\n-        }\n-        String rbody = rspbody == null? \"\": new String (rspbody);\n-        buf.append (\"Body: \").append (rbody).append(\"\\r\\n\");\n-        return new String (buf);\n-    }\n-\n-    \/**\n-     * Get the value of a request trailer whose name is specified by\n-     * the String argument.\n-     *\n-     * @param key the name of the request trailer\n-     * @return the value of the trailer or null if it does not exist\n-     *\/\n-    public String getRequestTrailer (String key) {\n-        return reqtrailers.findValue (key);\n-    }\n-\n-    \/**\n-     * Add a response header to the response. Multiple calls with the same\n-     * key value result in multiple header lines with the same key identifier\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void addResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.add (key, val);\n-    }\n-\n-    \/**\n-     * Set a response header. Searches for first header with named key\n-     * and replaces its value with val\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void setResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.set (key, val);\n-    }\n-\n-    \/**\n-     * Add a response trailer to the response. Multiple calls with the same\n-     * key value result in multiple trailer lines with the same key identifier\n-     * @param key the name of the request trailer to add\n-     * @param val the value of the trailer\n-     *\/\n-    public void addResponseTrailer (String key, String val) {\n-        if (rsptrailers == null)\n-            rsptrailers = new MessageHeader ();\n-        rsptrailers.add (key, val);\n-    }\n-\n-    \/**\n-     * Get the request method\n-     *\n-     * @return the request method\n-     *\/\n-    public String getRequestMethod (){\n-        return command;\n-    }\n-\n-    \/**\n-     * Perform an orderly close of the TCP connection associated with this\n-     * request. This method guarantees that any response already sent will\n-     * not be reset (by this end). The implementation does a shutdownOutput()\n-     * of the TCP connection and for a period of time consumes and discards\n-     * data received on the reading side of the connection. This happens\n-     * in the background. After the period has expired the\n-     * connection is completely closed.\n-     *\/\n-\n-    public void orderlyClose () {\n-        try {\n-            server.orderlyCloseChannel (ch);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Do an immediate abortive close of the TCP connection associated\n-     * with this request.\n-     *\/\n-    public void abortiveClose () {\n-        try {\n-            server.abortiveCloseChannel(ch);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Get the SocketChannel associated with this request\n-     *\n-     * @return the socket channel\n-     *\/\n-    public SocketChannel channel() {\n-        return ch;\n-    }\n-\n-    \/**\n-     * Get the request entity body associated with this request\n-     * as a single String.\n-     *\n-     * @return the entity body in one String\n-     *\/\n-    public String getRequestEntityBody (){\n-        return reqbody;\n-    }\n-\n-    \/**\n-     * Set the entity response body with the given string\n-     * The content length is set to the length of the string\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (String body){\n-        rspbody = body.getBytes();\n-        rspbodylen = body.length();\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-    \/**\n-     * Set the entity response body with the given byte[]\n-     * The content length is set to the gven length\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (byte[] body, int len){\n-        rspbody = body;\n-        rspbodylen = len;\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-\n-\n-    \/**\n-     * Set the entity response body by reading the given inputstream\n-     *\n-     * @param is the inputstream from which to read the body\n-     *\/\n-    public void setResponseEntityBody (InputStream is) throws IOException {\n-        byte[] buf = new byte [2048];\n-        byte[] total = new byte [2048];\n-        int total_len = 2048;\n-        int c, len=0;\n-        while ((c=is.read (buf)) != -1) {\n-            if (len+c > total_len) {\n-                byte[] total1 = new byte [total_len * 2];\n-                System.arraycopy (total, 0, total1, 0, len);\n-                total = total1;\n-                total_len = total_len * 2;\n-            }\n-            System.arraycopy (buf, 0, total, len, c);\n-            len += c;\n-        }\n-        setResponseEntityBody (total, len);\n-    }\n-\n-    \/* chunked *\/\n-\n-    \/**\n-     * Set the entity response body with the given array of strings\n-     * The content encoding is set to \"chunked\" and each array element\n-     * is sent as one chunk.\n-     * @param body the array of string chunks to send in the response\n-     *\/\n-    public void setResponseEntityBody (String[] body) {\n-        StringBuffer buf = new StringBuffer ();\n-        int len = 0;\n-        for (int i=0; i<body.length; i++) {\n-            String chunklen = Integer.toHexString (body[i].length());\n-            len += body[i].length();\n-            buf.append (chunklen).append (\"\\r\\n\");\n-            buf.append (body[i]).append (\"\\r\\n\");\n-        }\n-        buf.append (\"0\\r\\n\");\n-        rspbody = new String (buf).getBytes();\n-        rspbodylen = rspbody.length;\n-        rspchunked = true;\n-        addResponseHeader (\"Transfer-encoding\", \"chunked\");\n-    }\n-\n-    \/**\n-     * Send the response with the current set of response parameters\n-     * but using the response code and string tag line as specified\n-     * @param rCode the response code to send\n-     * @param rTag the response string to send with the response code\n-     *\/\n-    public void sendResponse (int rCode, String rTag) throws IOException {\n-        OutputStream os = new TestHttpsServer.NioOutputStream(channel(), server.getSSLEngine(), server.outNetBB(), server.outAppBB());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        if (rspheaders != null) {\n-            rspheaders.print (ps);\n-        } else {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush ();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        } else if (rspchunked) {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush();\n-    }\n-\n-    \/* sends one byte less than intended *\/\n-\n-    public void sendPartialResponse (int rCode, String rTag)throws IOException {\n-        OutputStream os = new TestHttpsServer.NioOutputStream(channel(), server.getSSLEngine(), server.outNetBB(), server.outAppBB());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        ps.flush();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen-1);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        }\n-        ps.flush();\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpTransaction.java","additions":0,"deletions":330,"binary":false,"changes":330,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- *        HttpCallback TestHttpsServer ClosedChannelList\n- *        HttpTransaction TunnelProxy\n+ *        ClosedChannelList\n+ *        TunnelProxy\n@@ -43,5 +43,22 @@\n-import java.io.*;\n-import java.net.*;\n-import javax.net.ssl.*;\n-import java.util.*;\n-\n+import java.io.FileInputStream;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.ProxySelector;\n+import java.net.URL;\n+import java.security.KeyStore;\n+import java.util.Optional;\n+import java.util.concurrent.Executors;\n+\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n@@ -52,1 +69,1 @@\n-    static TestHttpsServer server;\n+    static HttpsServer server;\n@@ -69,1 +86,0 @@\n-\n@@ -71,1 +87,0 @@\n-\n@@ -74,3 +89,1 @@\n-            System.setProperty(\"https.proxyPort\",\n-                        (new Integer(proxy.getLocalPort())).toString() );\n-\n+            ProxySelector.setDefault(ProxySelector.of(new InetSocketAddress(firstNonLoAddress, proxy.getLocalPort())));\n@@ -78,4 +91,0 @@\n-\n-            if (httpTrans.hasBadRequest) {\n-                throw new RuntimeException(\"Test failed : bad http request\");\n-            }\n@@ -87,1 +96,1 @@\n-               server.terminate();\n+               server.stop(1);\n@@ -138,1 +147,1 @@\n-    public static void startHttpServer() throws IOException {\n+    public static void startHttpServer() throws  Exception {\n@@ -142,1 +151,23 @@\n-        server = new TestHttpsServer(httpTrans, 1, 10, firstNonLoAddress, 0);\n+        \/\/ create and initialize a SSLContext\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        KeyStore ts = KeyStore.getInstance(\"JKS\");\n+        char[] passphrase = \"passphrase\".toCharArray();\n+\n+        ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n+        ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n+\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        server = HttpsServer.create(new InetSocketAddress(firstNonLoAddress, 0), 10);\n+        server.setHttpsConfigurator(new HttpsConfigurator(sslCtx));\n+        server.createContext(\"\/\", httpTrans);\n+        server.setExecutor(Executors.newSingleThreadExecutor());\n+        server.start();\n@@ -147,1 +178,1 @@\n-        System.out.println(\"https server listen on: \" + server.getLocalPort());\n+        System.out.println(\"https server listen on: \" + server.getAddress().getPort());\n@@ -150,1 +181,1 @@\n-                            server.getLocalPort(), \"\/\");\n+                            server.getAddress().getPort(), \"\/\");\n@@ -153,0 +184,4 @@\n+        if(uc.getResponseCode() != 200) {\n+            uc.disconnect();\n+            throw new RuntimeException(\"Test failed : bad http request with response code : \"+ uc.getResponseCode());\n+        }\n@@ -163,2 +198,1 @@\n-class SimpleHttpTransaction implements HttpCallback {\n-    public boolean hasBadRequest = false;\n+class SimpleHttpTransaction implements HttpHandler {\n@@ -169,1 +203,1 @@\n-    public void request(HttpTransaction trans) {\n+    public void handle(HttpExchange trans) {\n@@ -175,2 +209,2 @@\n-                trans.addResponseHeader(\"Location\", location);\n-                trans.sendResponse(302, \"Moved Temporarily\");\n+                trans.getResponseHeaders().set(\"Location\", location);\n+                trans.sendResponseHeaders(302, -1);\n@@ -178,10 +212,1 @@\n-                \/\/ if the bug exsits, it'll send 2 GET commands\n-                \/\/ check 2nd GET here\n-                String duplicatedGet = trans.getRequestHeader(null);\n-                if (duplicatedGet != null &&\n-                    duplicatedGet.toUpperCase().indexOf(\"GET\") >= 0) {\n-                    trans.sendResponse(400, \"Bad Request\");\n-                    hasBadRequest = true;\n-                } else {\n-                    trans.sendResponse(200, \"OK\");\n-                }\n+                trans.sendResponseHeaders(200, -1);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/B6216082.java","additions":63,"deletions":38,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,20 @@\n-import java.net.*;\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n@@ -33,1 +49,0 @@\n-import java.util.*;\n@@ -46,1 +61,0 @@\n-     * @param cb the callback object which is invoked to handle each\n@@ -58,2 +72,0 @@\n-     * @param cb the callback object which is invoked to handle each\n-     *     incoming request\n@@ -77,2 +89,0 @@\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n@@ -98,2 +108,0 @@\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n@@ -252,1 +260,0 @@\n-            HttpTransaction msg;\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/TunnelProxy.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,983 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import sun.net.www.MessageHeader;\n-import java.util.*;\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.security.*;\n-\n-\/**\n- * This class implements a simple HTTPS server. It uses multiple threads to\n- * handle connections in parallel, and will spin off a new thread to handle\n- * each request. (this is easier to implement with SSLEngine)\n- * <p>\n- * It must be instantiated with a {@link HttpCallback} object to which\n- * requests are given and must be handled.\n- * <p>\n- * Simple synchronization between the client(s) and server can be done\n- * using the {@link #waitForCondition(String)}, {@link #setCondition(String)} and\n- * {@link #rendezvous(String,int)} methods.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\n- * If you make a change in here, please don't forget to make the\n- * corresponding change in the J2SE equivalent.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\/\n-\n-public class TestHttpsServer {\n-\n-    ServerSocketChannel schan;\n-    int threads;\n-    int cperthread;\n-    HttpCallback cb;\n-    Server[] servers;\n-\n-    \/\/ ssl related fields\n-    static SSLContext sslCtx;\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified callback object\n-     * for handling requests. One thread is created to handle requests,\n-     * and up to ten TCP connections will be handled simultaneously.\n-     * @param cb the callback object which is invoked to handle each\n-     *  incoming request\n-     *\/\n-\n-    public TestHttpsServer(HttpCallback cb) throws IOException {\n-        this(cb, 1, 10, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified number of\n-     * threads and maximum number of connections per thread. This functions\n-     * the same as the 4 arg constructor, where the port argument is set to zero.\n-     * @param cb the callback object which is invoked to handle each\n-     *     incoming request\n-     * @param threads the number of threads to create to handle requests\n-     *     in parallel\n-     * @param cperthread the number of simultaneous TCP connections to\n-     *     handle per thread\n-     *\/\n-\n-    public TestHttpsServer(HttpCallback cb, int threads, int cperthread)\n-        throws IOException {\n-        this(cb, threads, cperthread, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified number\n-     * of threads and maximum number of connections per thread and running on\n-     * the specified port. The specified number of threads are created to\n-     * handle incoming requests, and each thread is allowed\n-     * to handle a number of simultaneous TCP connections.\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n-     * @param threads the number of threads to create to handle\n-     *  requests in parallel\n-     * @param cperthread the number of simultaneous TCP connections\n-     *  to handle per thread\n-     * @param port the port number to bind the server to. <code>Zero<\/code>\n-     *  means choose any free port.\n-     *\/\n-    public TestHttpsServer(HttpCallback cb, int threads, int cperthread, int port)\n-        throws IOException {\n-        this(cb, threads, cperthread, null, port);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified number\n-     * of threads and maximum number of connections per thread and running on\n-     * the specified port. The specified number of threads are created to\n-     * handle incoming requests, and each thread is allowed\n-     * to handle a number of simultaneous TCP connections.\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n-     * @param threads the number of threads to create to handle\n-     *  requests in parallel\n-     * @param cperthread the number of simultaneous TCP connections\n-     *  to handle per thread\n-     * @param address the InetAddress to bind to. {@code Null} means the\n-     *  wildcard address.\n-     * @param port the port number to bind the server to. {@code Zero}\n-     *  means choose any free port.\n-     *\/\n-\n-    public TestHttpsServer(HttpCallback cb, int threads, int cperthread, InetAddress address, int port)\n-        throws IOException {\n-        schan = ServerSocketChannel.open();\n-        InetSocketAddress addr = new InetSocketAddress(address, port);\n-        schan.socket().bind(addr);\n-        this.threads = threads;\n-        this.cb = cb;\n-        this.cperthread = cperthread;\n-\n-        try {\n-            \/\/ create and initialize a SSLContext\n-            KeyStore ks = KeyStore.getInstance(\"JKS\");\n-            KeyStore ts = KeyStore.getInstance(\"JKS\");\n-            char[] passphrase = \"passphrase\".toCharArray();\n-\n-            ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n-            ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n-\n-            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-            kmf.init(ks, passphrase);\n-\n-            TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-            tmf.init(ts);\n-\n-            sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-            sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-            servers = new Server[threads];\n-            for (int i=0; i<threads; i++) {\n-                servers[i] = new Server(cb, schan, cperthread);\n-                servers[i].start();\n-            }\n-        } catch (Exception ex) {\n-            throw new RuntimeException(\"test failed. cause: \"+ex.getMessage());\n-        }\n-    }\n-\n-    \/** Tell all threads in the server to exit within 5 seconds.\n-     *  This is an abortive termination. Just prior to the thread exiting\n-     *  all channels in that thread waiting to be closed are forceably closed.\n-     *\/\n-\n-    public void terminate() {\n-        for (int i=0; i<threads; i++) {\n-            servers[i].terminate ();\n-        }\n-    }\n-\n-    \/**\n-     * return the local port number to which the server is bound.\n-     * @return the local port number\n-     *\/\n-\n-    public int getLocalPort () {\n-        return schan.socket().getLocalPort ();\n-    }\n-\n-    public String getAuthority() {\n-        InetAddress address = schan.socket().getInetAddress();\n-        String hostaddr = address.getHostAddress();\n-        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n-        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n-        return hostaddr + \":\" + getLocalPort();\n-    }\n-\n-    static class Server extends Thread {\n-\n-        ServerSocketChannel schan;\n-        Selector selector;\n-        SelectionKey listenerKey;\n-        SelectionKey key; \/* the current key being processed *\/\n-        HttpCallback cb;\n-        ByteBuffer consumeBuffer;\n-        int maxconn;\n-        int nconn;\n-        ClosedChannelList clist;\n-        boolean shutdown;\n-\n-        Server(HttpCallback cb, ServerSocketChannel schan, int maxconn) {\n-            this.schan = schan;\n-            this.maxconn = maxconn;\n-            this.cb = cb;\n-            nconn = 0;\n-            consumeBuffer = ByteBuffer.allocate(512);\n-            clist = new ClosedChannelList();\n-            try {\n-                selector = Selector.open();\n-                schan.configureBlocking(false);\n-                listenerKey = schan.register(selector, SelectionKey.OP_ACCEPT);\n-            } catch (IOException e) {\n-                System.err.println(\"Server could not start: \" + e);\n-            }\n-        }\n-\n-        \/* Stop the thread as soon as possible *\/\n-        public synchronized void terminate() {\n-            shutdown = true;\n-        }\n-\n-        public void run()  {\n-            try {\n-                while (true) {\n-                    selector.select(1000);\n-                    Set selected = selector.selectedKeys();\n-                    Iterator iter = selected.iterator();\n-                    while (iter.hasNext()) {\n-                        key = (SelectionKey)iter.next();\n-                        if (key.equals (listenerKey)) {\n-                            SocketChannel sock = schan.accept();\n-                            if (sock == null) {\n-                                \/* false notification *\/\n-                                iter.remove();\n-                                continue;\n-                            }\n-                            sock.configureBlocking(true);\n-                            SSLEngine sslEng = sslCtx.createSSLEngine();\n-                            sslEng.setUseClientMode(false);\n-                            new ServerWorker(cb, sock, sslEng).start();\n-                            nconn ++;\n-                            if (nconn == maxconn) {\n-                                \/* deregister *\/\n-                                listenerKey.cancel();\n-                                listenerKey = null;\n-                            }\n-                        } else {\n-                            if (key.isReadable()) {\n-                                boolean closed = false;\n-                                SocketChannel chan = (SocketChannel)key.channel();\n-                                if (key.attachment() != null) {\n-                                    closed = consume(chan);\n-                                }\n-\n-                                if (closed) {\n-                                    chan.close();\n-                                    key.cancel();\n-                                    if (nconn == maxconn) {\n-                                        listenerKey = schan.register(selector, SelectionKey.OP_ACCEPT);\n-                                    }\n-                                    nconn --;\n-                                }\n-                            }\n-                        }\n-                        iter.remove();\n-                    }\n-                    clist.check();\n-\n-                    synchronized (this) {\n-                        if (shutdown) {\n-                            clist.terminate();\n-                            return;\n-                        }\n-                    }\n-                }\n-            } catch (IOException e) {\n-                System.out.println(\"Server exception: \" + e);\n-                \/\/ TODO finish\n-            }\n-        }\n-\n-        \/* read all the data off the channel without looking at it\n-         * return true if connection closed\n-         *\/\n-        boolean consume(SocketChannel chan) {\n-            try {\n-                consumeBuffer.clear();\n-                int c = chan.read(consumeBuffer);\n-                if (c == -1)\n-                    return true;\n-            } catch (IOException e) {\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    static class ServerWorker extends Thread {\n-        private ByteBuffer inNetBB;\n-        private ByteBuffer outNetBB;\n-        private ByteBuffer inAppBB;\n-        private ByteBuffer outAppBB;\n-\n-        SSLEngine sslEng;\n-        SocketChannel schan;\n-        HttpCallback cb;\n-        HandshakeStatus currentHSStatus;\n-        boolean initialHSComplete;\n-        boolean handshakeStarted;\n-        \/*\n-         * All inbound data goes through this buffer.\n-         *\n-         * It might be nice to use a cache of ByteBuffers so we're\n-         * not alloc\/dealloc'ing all over the place.\n-         *\/\n-\n-        \/*\n-         * Application buffers, also used for handshaking\n-         *\/\n-        private int appBBSize;\n-\n-        ServerWorker(HttpCallback cb, SocketChannel schan, SSLEngine sslEng) {\n-            this.sslEng = sslEng;\n-            this.schan = schan;\n-            this.cb = cb;\n-            currentHSStatus = HandshakeStatus.NEED_UNWRAP;\n-            initialHSComplete = false;\n-            int netBBSize = sslEng.getSession().getPacketBufferSize();\n-            inNetBB =  ByteBuffer.allocate(netBBSize);\n-            outNetBB = ByteBuffer.allocate(netBBSize);\n-            appBBSize = sslEng.getSession().getApplicationBufferSize();\n-            inAppBB = ByteBuffer.allocate(appBBSize);\n-            outAppBB = ByteBuffer.allocate(appBBSize);\n-        }\n-\n-        public SSLEngine getSSLEngine() {\n-            return sslEng;\n-        }\n-\n-        public ByteBuffer outNetBB() {\n-            return outNetBB;\n-        }\n-\n-        public ByteBuffer outAppBB() {\n-            return outAppBB;\n-        }\n-\n-        public void run () {\n-            try {\n-                SSLEngineResult result;\n-\n-                while (!initialHSComplete) {\n-\n-                    switch (currentHSStatus) {\n-\n-                    case NEED_UNWRAP:\n-                        int bytes = schan.read(inNetBB);\n-                        if (!handshakeStarted && bytes > 0) {\n-                            handshakeStarted = true;\n-                            int byte0 = inNetBB.get(0);\n-                            if (byte0 != 0x16) {\n-                                \/\/ first byte of a TLS connection is supposed to be\n-                                \/\/ 0x16. If not it may be a plain text connection.\n-                                \/\/\n-                                \/\/ Sometime a rogue client may try to open a plain\n-                                \/\/ connection with our server. Calling this method\n-                                \/\/ gives a chance to the test logic to ignore such\n-                                \/\/ rogue connections.\n-                                \/\/\n-                                if (cb.dropPlainTextConnections()) {\n-                                    try { schan.close(); } catch (IOException x) { };\n-                                    return;\n-                                }\n-                                \/\/ else sslEng.unwrap will throw later on...\n-                            }\n-                        }\n-\n-needIO:\n-                        while (currentHSStatus == HandshakeStatus.NEED_UNWRAP) {\n-                            \/*\n-                             * Don't need to resize requestBB, since no app data should\n-                             * be generated here.\n-                             *\/\n-                            inNetBB.flip();\n-                            result = sslEng.unwrap(inNetBB, inAppBB);\n-                            inNetBB.compact();\n-                            currentHSStatus = result.getHandshakeStatus();\n-\n-                            switch (result.getStatus()) {\n-\n-                            case OK:\n-                                switch (currentHSStatus) {\n-                                case NOT_HANDSHAKING:\n-                                    throw new IOException(\n-                                                          \"Not handshaking during initial handshake\");\n-\n-                                case NEED_TASK:\n-                                    Runnable task;\n-                                    while ((task = sslEng.getDelegatedTask()) != null) {\n-                                        task.run();\n-                                        currentHSStatus = sslEng.getHandshakeStatus();\n-                                    }\n-                                    break;\n-                                }\n-\n-                                break;\n-\n-                            case BUFFER_UNDERFLOW:\n-                                break needIO;\n-\n-                            default: \/\/ BUFFER_OVERFLOW\/CLOSED:\n-                                throw new IOException(\"Received\" + result.getStatus() +\n-                                                      \"during initial handshaking\");\n-                            }\n-                        }\n-\n-                        \/*\n-                         * Just transitioned from read to write.\n-                         *\/\n-                        if (currentHSStatus != HandshakeStatus.NEED_WRAP) {\n-                            break;\n-                        }\n-\n-                        \/\/ Fall through and fill the write buffer.\n-\n-                    case NEED_WRAP:\n-                        \/*\n-                         * The flush above guarantees the out buffer to be empty\n-                         *\/\n-                        outNetBB.clear();\n-                        result = sslEng.wrap(inAppBB, outNetBB);\n-                        outNetBB.flip();\n-                        schan.write (outNetBB);\n-                        outNetBB.compact();\n-                        currentHSStatus = result.getHandshakeStatus();\n-\n-                        switch (result.getStatus()) {\n-                        case OK:\n-\n-                            if (currentHSStatus == HandshakeStatus.NEED_TASK) {\n-                                Runnable task;\n-                                while ((task = sslEng.getDelegatedTask()) != null) {\n-                                    task.run();\n-                                    currentHSStatus = sslEng.getHandshakeStatus();\n-                                }\n-                            }\n-\n-                            break;\n-\n-                        default: \/\/ BUFFER_OVERFLOW\/BUFFER_UNDERFLOW\/CLOSED:\n-                            throw new IOException(\"Received\" + result.getStatus() +\n-                                                  \"during initial handshaking\");\n-                        }\n-                        break;\n-\n-                    case FINISHED:\n-                        initialHSComplete = true;\n-                        break;\n-                    default: \/\/ NOT_HANDSHAKING\/NEED_TASK\n-                        throw new RuntimeException(\"Invalid Handshaking State\" +\n-                                                   currentHSStatus);\n-                    } \/\/ switch\n-                }\n-                \/\/ read the application data; using non-blocking mode\n-                schan.configureBlocking(false);\n-                read(schan, sslEng);\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n-            }\n-        }\n-\n-        \/* return true if the connection is closed, false otherwise *\/\n-\n-        private boolean read(SocketChannel chan, SSLEngine sslEng) {\n-            HttpTransaction msg;\n-            boolean res;\n-            try {\n-                InputStream is = new BufferedInputStream(new NioInputStream(chan, sslEng, inNetBB, inAppBB));\n-                String requestline = readLine(is);\n-                MessageHeader mhead = new MessageHeader(is);\n-                String clen = mhead.findValue(\"Content-Length\");\n-                String trferenc = mhead.findValue(\"Transfer-Encoding\");\n-                String data = null;\n-                if (trferenc != null && trferenc.equals(\"chunked\"))\n-                    data = new String(readChunkedData(is));\n-                else if (clen != null)\n-                    data = new String(readNormalData(is, Integer.parseInt(clen)));\n-                String[] req = requestline.split(\" \");\n-                if (req.length < 2) {\n-                    \/* invalid request line *\/\n-                    return false;\n-                }\n-                String cmd = req[0];\n-                URI uri = null;\n-                try {\n-                    uri = new URI(req[1]);\n-                    msg = new HttpTransaction(this, cmd, uri, mhead, data, null, chan);\n-                    cb.request(msg);\n-                } catch (URISyntaxException e) {\n-                    System.err.println (\"Invalid URI: \" + e);\n-                    msg = new HttpTransaction(this, cmd, null, null, null, null, chan);\n-                    msg.sendResponse(501, \"Whatever\");\n-                }\n-                res = false;\n-            } catch (IOException e) {\n-                res = true;\n-            }\n-            return res;\n-        }\n-\n-        byte[] readNormalData(InputStream is, int len) throws IOException {\n-            byte[] buf  = new byte[len];\n-            int c, off=0, remain=len;\n-            while (remain > 0 && ((c=is.read (buf, off, remain))>0)) {\n-                remain -= c;\n-                off += c;\n-            }\n-            return buf;\n-        }\n-\n-        private void readCRLF(InputStream is) throws IOException {\n-            int cr = is.read();\n-            int lf = is.read();\n-\n-            if (((cr & 0xff) != 0x0d) ||\n-                ((lf & 0xff) != 0x0a)) {\n-                throw new IOException(\n-                    \"Expected <CR><LF>:  got '\" + cr + \"\/\" + lf + \"'\");\n-            }\n-        }\n-\n-        byte[] readChunkedData(InputStream is) throws IOException {\n-            LinkedList l = new LinkedList();\n-            int total = 0;\n-            for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {\n-                l.add(readNormalData(is, len));\n-                total += len;\n-                readCRLF(is); \/\/ CRLF at end of chunk\n-            }\n-            readCRLF(is); \/\/ CRLF at end of Chunked Stream.\n-            byte[] buf = new byte[total];\n-            Iterator i = l.iterator();\n-            int x = 0;\n-            while (i.hasNext()) {\n-                byte[] b = (byte[])i.next();\n-                System.arraycopy(b, 0, buf, x, b.length);\n-                x += b.length;\n-            }\n-            return buf;\n-        }\n-\n-        private int readChunkLen(InputStream is) throws IOException {\n-            int c, len=0;\n-            boolean done=false, readCR=false;\n-            while (!done) {\n-                c = is.read();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        int x=0;\n-                        if (c >= 'a' && c <= 'f') {\n-                            x = c - 'a' + 10;\n-                        } else if (c >= 'A' && c <= 'F') {\n-                            x = c - 'A' + 10;\n-                        } else if (c >= '0' && c <= '9') {\n-                            x = c - '0';\n-                        }\n-                        len = len * 16 + x;\n-                    }\n-                }\n-            }\n-            return len;\n-        }\n-\n-        private String readLine(InputStream is) throws IOException {\n-            boolean done=false, readCR=false;\n-            byte[] b = new byte[512];\n-            int c, l = 0;\n-\n-            while (!done) {\n-                c = is.read();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        b[l++] = (byte)c;\n-                    }\n-                }\n-            }\n-            return new String(b);\n-        }\n-\n-        \/** close the channel associated with the current key by:\n-         * 1. shutdownOutput (send a FIN)\n-         * 2. mark the key so that incoming data is to be consumed and discarded\n-         * 3. After a period, close the socket\n-         *\/\n-\n-        synchronized void orderlyCloseChannel(SocketChannel ch) throws IOException {\n-            ch.socket().shutdownOutput();\n-        }\n-\n-        synchronized void abortiveCloseChannel(SocketChannel ch) throws IOException {\n-            Socket s = ch.socket();\n-            s.setSoLinger(true, 0);\n-            ch.close();\n-        }\n-    }\n-\n-\n-    \/**\n-     * Implements blocking reading semantics on top of a non-blocking channel\n-     *\/\n-\n-    static class NioInputStream extends InputStream {\n-        SSLEngine sslEng;\n-        SocketChannel channel;\n-        Selector selector;\n-        ByteBuffer inNetBB;\n-        ByteBuffer inAppBB;\n-        SelectionKey key;\n-        int available;\n-        byte[] one;\n-        boolean closed;\n-        ByteBuffer markBuf; \/* reads may be satisifed from this buffer *\/\n-        boolean marked;\n-        boolean reset;\n-        int readlimit;\n-\n-        public NioInputStream(SocketChannel chan, SSLEngine sslEng, ByteBuffer inNetBB, ByteBuffer inAppBB) throws IOException {\n-            this.sslEng = sslEng;\n-            this.channel = chan;\n-            selector = Selector.open();\n-            this.inNetBB = inNetBB;\n-            this.inAppBB = inAppBB;\n-            key = chan.register(selector, SelectionKey.OP_READ);\n-            available = 0;\n-            one = new byte[1];\n-            closed = marked = reset = false;\n-        }\n-\n-        public synchronized int read(byte[] b) throws IOException {\n-            return read(b, 0, b.length);\n-        }\n-\n-        public synchronized int read() throws IOException {\n-            return read(one, 0, 1);\n-        }\n-\n-        public synchronized int read(byte[] b, int off, int srclen) throws IOException {\n-\n-            int canreturn, willreturn;\n-\n-            if (closed)\n-                return -1;\n-\n-            if (reset) { \/* satisfy from markBuf *\/\n-                canreturn = markBuf.remaining();\n-                willreturn = canreturn > srclen ? srclen : canreturn;\n-                markBuf.get(b, off, willreturn);\n-                if (canreturn == willreturn) {\n-                    reset = false;\n-                }\n-            } else { \/* satisfy from channel *\/\n-                canreturn = available();\n-                if (canreturn == 0) {\n-                    block();\n-                    canreturn = available();\n-                }\n-                willreturn = canreturn > srclen ? srclen : canreturn;\n-                inAppBB.get(b, off, willreturn);\n-                available -= willreturn;\n-\n-                if (marked) { \/* copy into markBuf *\/\n-                    try {\n-                        markBuf.put(b, off, willreturn);\n-                    } catch (BufferOverflowException e) {\n-                        marked = false;\n-                    }\n-                }\n-            }\n-            return willreturn;\n-        }\n-\n-        public synchronized int available() throws IOException {\n-            if (closed)\n-                throw new IOException(\"Stream is closed\");\n-\n-            if (reset)\n-                return markBuf.remaining();\n-\n-            if (available > 0)\n-                return available;\n-\n-            inAppBB.clear();\n-            int bytes = channel.read(inNetBB);\n-\n-            int needed = sslEng.getSession().getApplicationBufferSize();\n-            if (needed > inAppBB.remaining()) {\n-                inAppBB = ByteBuffer.allocate(needed);\n-            }\n-            inNetBB.flip();\n-            SSLEngineResult result = sslEng.unwrap(inNetBB, inAppBB);\n-            inNetBB.compact();\n-            available = result.bytesProduced();\n-\n-            if (available > 0)\n-                inAppBB.flip();\n-            else if (available == -1)\n-                throw new IOException(\"Stream is closed\");\n-            return available;\n-        }\n-\n-        \/**\n-         * block() only called when available==0 and buf is empty\n-         *\/\n-        private synchronized void block() throws IOException {\n-            \/\/assert available == 0;\n-            int n = selector.select();\n-            \/\/assert n == 1;\n-            selector.selectedKeys().clear();\n-            available();\n-        }\n-\n-        public void close() throws IOException {\n-            if (closed)\n-                return;\n-            channel.close();\n-            closed = true;\n-        }\n-\n-        public synchronized void mark(int readlimit) {\n-            if (closed)\n-                return;\n-            this.readlimit = readlimit;\n-            markBuf = ByteBuffer.allocate(readlimit);\n-            marked = true;\n-            reset = false;\n-        }\n-\n-        public synchronized void reset() throws IOException {\n-            if (closed )\n-                return;\n-            if (!marked)\n-                throw new IOException(\"Stream not marked\");\n-            marked = false;\n-            reset = true;\n-            markBuf.flip();\n-        }\n-    }\n-\n-    static class NioOutputStream extends OutputStream {\n-        SSLEngine sslEng;\n-        SocketChannel channel;\n-        ByteBuffer outNetBB;\n-        ByteBuffer outAppBB;\n-        SelectionKey key;\n-        Selector selector;\n-        boolean closed;\n-        byte[] one;\n-\n-        public NioOutputStream(SocketChannel channel, SSLEngine sslEng, ByteBuffer outNetBB, ByteBuffer outAppBB) throws IOException {\n-            this.sslEng = sslEng;\n-            this.channel = channel;\n-            this.outNetBB = outNetBB;\n-            this.outAppBB = outAppBB;\n-            selector = Selector.open();\n-            key = channel.register(selector, SelectionKey.OP_WRITE);\n-            closed = false;\n-            one = new byte[1];\n-        }\n-\n-        public synchronized void write(int b) throws IOException {\n-            one[0] = (byte)b;\n-            write(one, 0, 1);\n-        }\n-\n-        public synchronized void write(byte[] b) throws IOException {\n-            write(b, 0, b.length);\n-        }\n-\n-        public synchronized void write(byte[] b, int off, int len) throws IOException {\n-            if (closed)\n-                throw new IOException(\"stream is closed\");\n-\n-            outAppBB = ByteBuffer.allocate(len);\n-            outAppBB.put(b, off, len);\n-            outAppBB.flip();\n-            int n;\n-            outNetBB.clear();\n-            int needed = sslEng.getSession().getPacketBufferSize();\n-            if (outNetBB.capacity() < needed) {\n-                outNetBB = ByteBuffer.allocate(needed);\n-            }\n-            SSLEngineResult ret = sslEng.wrap(outAppBB, outNetBB);\n-            outNetBB.flip();\n-            int newLen = ret.bytesProduced();\n-            while ((n = channel.write (outNetBB)) < newLen) {\n-                newLen -= n;\n-                if (newLen == 0)\n-                    return;\n-                selector.select();\n-                selector.selectedKeys().clear();\n-            }\n-        }\n-\n-        public void close() throws IOException {\n-            if (closed)\n-                return;\n-            channel.close();\n-            closed = true;\n-        }\n-    }\n-\n-    \/**\n-     * Utilities for synchronization. A condition is\n-     * identified by a string name, and is initialized\n-     * upon first use (ie. setCondition() or waitForCondition()). Threads\n-     * are blocked until some thread calls (or has called) setCondition() for the same\n-     * condition.\n-     * <P>\n-     * A rendezvous built on a condition is also provided for synchronizing\n-     * N threads.\n-     *\/\n-\n-    private static HashMap conditions = new HashMap();\n-\n-    \/*\n-     * Modifiable boolean object\n-     *\/\n-    private static class BValue {\n-        boolean v;\n-    }\n-\n-    \/*\n-     * Modifiable int object\n-     *\/\n-    private static class IValue {\n-        int v;\n-        IValue(int i) {\n-            v =i;\n-        }\n-    }\n-\n-\n-    private static BValue getCond(String condition) {\n-        synchronized (conditions) {\n-            BValue cond = (BValue) conditions.get(condition);\n-            if (cond == null) {\n-                cond = new BValue();\n-                conditions.put(condition, cond);\n-            }\n-            return cond;\n-        }\n-    }\n-\n-    \/**\n-     * Set the condition to true. Any threads that are currently blocked\n-     * waiting on the condition, will be unblocked and allowed to continue.\n-     * Threads that subsequently call waitForCondition() will not block.\n-     * If the named condition did not exist prior to the call, then it is created\n-     * first.\n-     *\/\n-\n-    public static void setCondition(String condition) {\n-        BValue cond = getCond(condition);\n-        synchronized (cond) {\n-            if (cond.v) {\n-                return;\n-            }\n-            cond.v = true;\n-            cond.notifyAll();\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition does not exist, then it is created and initialized\n-     * to false. If the condition exists or has just been created and its value\n-     * is false, then the thread blocks until another thread sets the condition.\n-     * If the condition exists and is already set to true, then this call returns\n-     * immediately without blocking.\n-     *\/\n-\n-    public static void waitForCondition(String condition) {\n-        BValue cond = getCond(condition);\n-        synchronized (cond) {\n-            if (!cond.v) {\n-                try {\n-                    cond.wait();\n-                } catch (InterruptedException e) {}\n-            }\n-        }\n-    }\n-\n-    \/* conditions must be locked when accessing this *\/\n-    static HashMap rv = new HashMap();\n-\n-    \/**\n-     * Force N threads to rendezvous (ie. wait for each other) before proceeding.\n-     * The first thread(s) to call are blocked until the last\n-     * thread makes the call. Then all threads continue.\n-     * <p>\n-     * All threads that call with the same condition name, must use the same value\n-     * for N (or the results may be not be as expected).\n-     * <P>\n-     * Obviously, if fewer than N threads make the rendezvous then the result\n-     * will be a hang.\n-     *\/\n-\n-    public static void rendezvous(String condition, int N) {\n-        BValue cond;\n-        IValue iv;\n-        String name = \"RV_\"+condition;\n-\n-        \/* get the condition *\/\n-\n-        synchronized (conditions) {\n-            cond = (BValue)conditions.get(name);\n-            if (cond == null) {\n-                \/* we are first caller *\/\n-                if (N < 2) {\n-                    throw new RuntimeException(\"rendezvous must be called with N >= 2\");\n-                }\n-                cond = new BValue();\n-                conditions.put(name, cond);\n-                iv = new IValue(N-1);\n-                rv.put(name, iv);\n-            } else {\n-                \/* already initialised, just decrement the counter *\/\n-                iv = (IValue) rv.get(name);\n-                iv.v--;\n-            }\n-        }\n-\n-        if (iv.v > 0) {\n-            waitForCondition(name);\n-        } else {\n-            setCondition(name);\n-            synchronized (conditions) {\n-                clearCondition(name);\n-                rv.remove(name);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition exists and is set then remove it, so it can\n-     * be re-initialized and used again. If the condition does not exist, or\n-     * exists but is not set, then the call returns without doing anything.\n-     * Note, some higher level synchronization\n-     * may be needed between clear and the other operations.\n-     *\/\n-\n-    public static void clearCondition(String condition) {\n-        BValue cond;\n-        synchronized (conditions) {\n-            cond = (BValue) conditions.get(condition);\n-            if (cond == null) {\n-                return;\n-            }\n-            synchronized (cond) {\n-                if (cond.v) {\n-                    conditions.remove(condition);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/TestHttpsServer.java","additions":0,"deletions":983,"binary":false,"changes":983,"status":"deleted"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8265500\n+ * @summary\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm TestCipherMode\n+ *\/\n+\n+import java.security.Provider;\n+import java.security.Key;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.InvalidParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class TestCipherMode extends PKCS11Test {\n+\n+    private static String[] TRANSFORMATIONS = {\n+        \"AES\/ECB\/PKCS5Padding\", \"AES\/GCM\/NoPadding\",\n+        \"RSA\/ECB\/PKCS1Padding\"\n+    };\n+\n+    private static byte[] BYTES16 =\n+            Arrays.copyOf(TRANSFORMATIONS[0].getBytes(), 16);\n+    private static SecretKey AES_KEY = new SecretKeySpec(BYTES16, \"AES\");\n+    private static PublicKey RSA_PUBKEY = null;\n+    private static PrivateKey RSA_PRIVKEY = null;\n+\n+    enum CipherMode {\n+        ENCRYPT(Cipher.ENCRYPT_MODE),\n+        DECRYPT(Cipher.DECRYPT_MODE),\n+        WRAP(Cipher.WRAP_MODE),\n+        UNWRAP(Cipher.UNWRAP_MODE),\n+        NONEXISTENT(100);\n+\n+        int value;\n+\n+        CipherMode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static Key getKey(String t, CipherMode m, Provider p)\n+            throws NoSuchAlgorithmException {\n+        if (t.startsWith(\"AES\")) {\n+            return AES_KEY;\n+        } else if (t.startsWith(\"RSA\")) {\n+            if (RSA_PUBKEY == null) {\n+                KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\", p);\n+                KeyPair kp = kpg.generateKeyPair();\n+                RSA_PUBKEY = kp.getPublic();\n+                RSA_PRIVKEY = kp.getPrivate();\n+            }\n+            return ((m == CipherMode.ENCRYPT || m == CipherMode.UNWRAP)?\n+                    RSA_PRIVKEY : RSA_PUBKEY);\n+        } else {\n+            throw new RuntimeException(\"Unknown transformation: \" + t);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestCipherMode(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+\n+        \/\/ test all cipher impls, e.g. P11Cipher, P11AEADCipher, and\n+        \/\/ P11RSACipher\n+        for (String t : TRANSFORMATIONS) {\n+            checkModes(t, p);\n+        }\n+        System.out.println(\"All tests passed\");\n+    }\n+\n+    private static void checkModes(String t, Provider p) throws Exception {\n+        try {\n+            Cipher.getInstance(t, p);\n+        } catch (Exception e) {\n+            System.out.println(\"Skip \" + t + \" due to \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (CipherMode m : CipherMode.values()) {\n+            System.out.println(\"Testing \" + t + \" with \" + m.name());\n+            Cipher c;\n+            try {\n+                c = Cipher.getInstance(t, p);\n+                \/\/ try init and see if the expected Exception is thrown\n+                c.init(m.value, getKey(t, m, p), c.getParameters());\n+                if (m == CipherMode.NONEXISTENT) {\n+                    throw new Exception(\"ERROR: should throw IPE with init()\");\n+                }\n+            } catch (UnsupportedOperationException uoe)  {\n+                \/\/ some may not support wrap\/unwrap\n+                if (m == CipherMode.WRAP || m == CipherMode.UNWRAP) {\n+                    System.out.println(\"Expected UOE thrown with init()\");\n+                    continue;\n+                }\n+                throw uoe;\n+            } catch (InvalidParameterException ipe) {\n+                if (m == CipherMode.NONEXISTENT) {\n+                    System.out.println(\"Expected IPE thrown for init()\");\n+                    continue;\n+                }\n+                throw ipe;\n+            }\n+            switch (m) {\n+            case ENCRYPT:\n+            case DECRYPT:\n+                \/\/ call wrap()\/unwrap() and see if ISE is thrown.\n+                try {\n+                    c.wrap(AES_KEY);\n+                    throw new Exception(\"ERROR: should throw ISE for wrap()\");\n+                } catch (IllegalStateException ise) {\n+                    System.out.println(\"Expected ISE thrown for wrap()\");\n+                }\n+                try {\n+                    c.unwrap(BYTES16, \"AES\", Cipher.SECRET_KEY);\n+                    throw new Exception(\"ERROR: should throw ISE for unwrap()\");\n+                } catch (IllegalStateException ise) {\n+                    System.out.println(\"Expected ISE thrown for unwrap()\");\n+                }\n+                break;\n+            case WRAP:\n+            case UNWRAP:\n+                try {\n+                    c.update(BYTES16);\n+                    throw new Exception(\"ERROR: should throw ISE for update()\");\n+                } catch (IllegalStateException ise) {\n+                    System.out.println(\"Expected ISE thrown for update()\");\n+                }\n+                try {\n+                    c.doFinal();\n+                    throw new Exception(\"ERROR: should throw ISE for\" +\n+                            \" doFinal()\");\n+                } catch (IllegalStateException ise) {\n+                    System.out.println(\"Expected ISE thrown for doFinal()\");\n+                }\n+                break;\n+            default:\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherMode.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.function.Consumer;\n@@ -70,5 +69,1 @@\n-        createInstaller(null, \"WithDefaultIcon\", installerIconImg -> {\n-            defaultInstallerIconImg[0] = installerIconImg;\n-        }, null, null);\n-\n-        BufferedImage[] customInstallerIconImg = new BufferedImage[1];\n+        long size1 = createInstaller(null, \"WithDefaultIcon\");\n@@ -77,12 +72,11 @@\n-        \/\/ This installer icon should differ from the icon\n-        \/\/ of the installer created with the default icon.\n-        createInstaller(customIcon, \"2\", installerIconImg -> {\n-            customInstallerIconImg[0] = installerIconImg;\n-        }, null, defaultInstallerIconImg[0]);\n-\n-        \/\/ Create installer with custom icon again.\n-        \/\/ This installer icon should differ from the icon\n-        \/\/ of the installer created with the default icon and should have\n-        \/\/ the same icon as the icon of installer created with custom icon.\n-        createInstaller(customIcon, null, null,\n-                customInstallerIconImg[0], defaultInstallerIconImg[0]);\n+        long size2 = createInstaller(customIcon, \"WithCustomIcon\");\n+\n+        \/\/ Create another installer with custom icon.\n+        long size3 = createInstaller(customIcon, null);\n+\n+        TKit.assertTrue(size2 < size1, \"Installer 2 built with custom icon \" +\n+                \"should  be smaller than Installer 1 built with default icon\");\n+\n+        TKit.assertTrue(size3 < size1, \"Installer 3 built with custom icon \" +\n+                \"should be smaller than Installer 1 built with default icon\");\n+\n@@ -91,4 +85,1 @@\n-    private void createInstaller(Path icon, String nameSuffix,\n-            Consumer<BufferedImage> installerIconImgConsumer,\n-            BufferedImage expectedInstallerIconImg,\n-            BufferedImage unexpectedInstallerIconImg) throws IOException {\n+    private long createInstaller(Path icon, String nameSuffix) throws IOException {\n@@ -115,23 +106,0 @@\n-\n-            Icon actualIcon = FileSystemView.getFileSystemView().getSystemIcon(\n-                    installerExePath[0].toFile());\n-\n-            BufferedImage actualInstallerIconImg = loadIcon(actualIcon);\n-\n-            if (installerIconImgConsumer != null) {\n-                installerIconImgConsumer.accept(actualInstallerIconImg);\n-            }\n-\n-            if (expectedInstallerIconImg != null) {\n-                TKit.assertTrue(imageEquals(expectedInstallerIconImg,\n-                        actualInstallerIconImg), String.format(\n-                                \"Check icon of %s installer is matching expected value\",\n-                                installerExePath[0]));\n-            }\n-\n-            if (unexpectedInstallerIconImg != null) {\n-                TKit.assertFalse(imageEquals(unexpectedInstallerIconImg,\n-                        actualInstallerIconImg), String.format(\n-                                \"Check icon of %s installer is NOT matching unexpected value\",\n-                                installerExePath[0]));\n-            }\n@@ -142,29 +110,6 @@\n-        if (installerExePath[0] != null && nameSuffix != null) {\n-            TKit.deleteIfExists(installerExePath[0]);\n-        }\n-    }\n-\n-    private BufferedImage loadIcon(Icon icon) {\n-        TKit.assertNotEquals(0, icon.getIconWidth(),\n-                \"Check icon has not empty width\");\n-        TKit.assertNotEquals(0, icon.getIconHeight(),\n-                \"Check icon has not empty height\");\n-        BufferedImage img = new BufferedImage(\n-                icon.getIconWidth(),\n-                icon.getIconHeight(),\n-                BufferedImage.TYPE_INT_RGB);\n-        Graphics g = img.createGraphics();\n-        icon.paintIcon(null, g, 0, 0);\n-        g.dispose();\n-        return img;\n-    }\n-\n-    private static boolean imageEquals(BufferedImage imgA, BufferedImage imgB) {\n-        if (imgA.getWidth() == imgB.getWidth() && imgA.getHeight()\n-                == imgB.getHeight()) {\n-            for (int x = 0; x < imgA.getWidth(); x++) {\n-                for (int y = 0; y < imgA.getHeight(); y++) {\n-                    if (imgA.getRGB(x, y) != imgB.getRGB(x, y)) {\n-                        return false;\n-                    }\n-                }\n+        long size = 0L;\n+        if (installerExePath[0] != null) {\n+            size = installerExePath[0].toFile().length();\n+            TKit.trace(\" installer: \" + installerExePath[0] + \" - size: \" + size);\n+            if (nameSuffix != null) {\n+                TKit.deleteIfExists(installerExePath[0]);\n@@ -172,2 +117,0 @@\n-        } else {\n-            return false;\n@@ -175,1 +118,1 @@\n-        return true;\n+        return size;\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinInstallerIconTest.java","additions":20,"deletions":77,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8266082\n+ * @summary javac should not crash when seeing type annotations in links\n+ * @compile\/fail\/ref=CrashInAnnotateTest.out -Xdoclint -XDrawDiagnostics CrashInAnnotateTest.java\n+ *\/\n+\n+import java.util.List;\n+\n+\/** {@link #equals(@Deprecated Object)}\n+ *  {@link java.util.Map.@Deprecated Entry#getKey()}\n+ *\/\n+class CrashInAnnotateTest {\n+}\n+\n+\/** {@link #compare(Object, List<List<@Deprecated Object>>)} *\/\n+class CrashInAnnotateTest2 {\n+    void compare(Object o, List<List<Object>> l) {}\n+}\n+\n+\/** {@link @Deprecated java.lang.Object#hashCode()} *\/\n+class CrashInAnnotateTest3 { }\n+\n+\/** {@link CrashInAnnotateTest4.@java.lang.Deprecated Inner#aField}\n+ *  {@link java.util.Map.@Deprecated#getKey()}\n+ *\/\n+class CrashInAnnotateTest4 {\n+    class Inner {\n+        Object aField;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/doclint\/CrashInAnnotateTest.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+CrashInAnnotateTest.java:10:5: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:11:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:16:5: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:18:10: compiler.warn.proc.messager: no comment\n+CrashInAnnotateTest.java:21:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:24:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:25:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:28:5: compiler.warn.proc.messager: no comment\n+CrashInAnnotateTest.java:29:16: compiler.warn.proc.messager: no comment\n+6 errors\n+3 warnings\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/doclint\/CrashInAnnotateTest.out","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.dc.ref.annotations.not.allowed\n+\/\/ key: compiler.note.note\n+\/\/ key: compiler.note.proc.messager\n+\/\/ run: backdoor\n+\/\/ options: -processor DocCommentProcessor -proc:only\n+\n+\/** {@link #equals(@Deprecated Object)} *\/\n+class NoAnnotationsInLink {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NoAnnotationsInLink.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -83,3 +83,0 @@\n-    public final static String BiasedLockRevocation = PREFIX + \"BiasedLockRevocation\";\n-    public final static String BiasedLockSelfRevocation = PREFIX + \"BiasedLockSelfRevocation\";\n-    public final static String BiasedLockClassRevocation = PREFIX + \"BiasedLockClassRevocation\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-    return getMethodCompilationLevel(method, false \/*not ost*\/);\n+    return getMethodCompilationLevel(method, false \/*not osr*\/);\n@@ -608,0 +608,1 @@\n+  public native boolean handshakeReadMonitors(Thread t);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,12 +113,0 @@\n-    \/**\n-     * Same as {@link #testRecursiveSynchronization()} but the first call\n-     * to this method will generate the identity hashcode for this object\n-     * which effectively disables biased locking as they occupy the same\n-     * bits in the object header.\n-     *\/\n-    @Benchmark\n-    public void testRecursiveSynchronizationNoBias() {\n-        System.identityHashCode(this);\n-        factorial = fact(10);\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/LockUnlock.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"}]}