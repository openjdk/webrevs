{"files":[{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.layout.ValueLayouts;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.reflect.CallerSensitive;\n+\n+import java.lang.foreign.Linker.Option;\n+import java.lang.invoke.MethodHandle;\n+import java.nio.ByteOrder;\n+import java.util.Optional;\n+\n+\/**\n+ * A value layout used to model the address of some region of memory. The carrier associated with an address layout is\n+ * {@code MemorySegment.class}. The size and alignment of an address layout are platform dependent\n+ * (e.g. on a 64-bit platform, the size and alignment of an address layout are set to 64 bits).\n+ * <p>\n+ * An address layout may optionally feature a {@linkplain #targetLayout() target layout}. An address layout with\n+ * target layout {@code T} can be used to model the address of a region of memory whose layout is {@code T}.\n+ * For instance, an address layout with target layout {@link ValueLayout#JAVA_INT} can be used to model the address\n+ * of a region of memory that is 4 bytes long. Specifying a target layout can be useful in the following situations:\n+ * <ul>\n+ *     <li>When accessing a memory segment that has been obtained by reading an address from another\n+ *     memory segment, e.g. using {@link MemorySegment#getAtIndex(AddressLayout, long)};<\/li>\n+ *     <li>When creating a downcall method handle, using {@link Linker#downcallHandle(FunctionDescriptor, Option...)};\n+ *     <li>When creating an upcall stub, using {@link Linker#upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...)}.\n+ * <\/ul>\n+ *\n+ * @see #ADDRESS\n+ * @see #ADDRESS_UNALIGNED\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+sealed public interface AddressLayout extends ValueLayout permits ValueLayouts.OfAddressImpl {\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    AddressLayout withName(String name);\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    AddressLayout withBitAlignment(long bitAlignment);\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    AddressLayout withOrder(ByteOrder order);\n+\n+    \/**\n+     * Returns an address layout with the same carrier, alignment constraint, name and order as this address layout,\n+     * but associated with the specified target layout. The returned address layout allows raw addresses to be accessed\n+     * as {@linkplain MemorySegment memory segments} whose size is set to the size of the specified layout. Moreover,\n+     * if the accessed raw address is not compatible with the alignment constraint in the provided layout,\n+     * {@linkplain IllegalArgumentException} will be thrown.\n+     * @apiNote\n+     * This method can also be used to create an address layout which, when used, creates native memory\n+     * segments with maximal size (e.g. {@linkplain Long#MAX_VALUE}. This can be done by using a target sequence\n+     * layout with unspecified size, as follows:\n+     * {@snippet lang = java:\n+     * AddressLayout addressLayout   = ...\n+     * AddressLayout unboundedLayout = addressLayout.withTargetLayout(\n+     *         MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+     *}\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the target layout.\n+     * @return an address layout with same characteristics as this layout, but with the provided target layout.\n+     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n+     * @see #targetLayout()\n+     *\/\n+    @CallerSensitive\n+    AddressLayout withTargetLayout(MemoryLayout layout);\n+\n+    \/**\n+     * {@return the target layout associated with this address layout (if any)}.\n+     *\/\n+    Optional<MemoryLayout> targetLayout();\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -36,1 +36,0 @@\n-import java.lang.foreign.ValueLayout.OfAddress;\n@@ -118,1 +117,1 @@\n- * {@linkplain ValueLayout.OfAddress address layout} returns a native segment associated with\n+ * {@linkplain AddressLayout address layout} returns a native segment associated with\n@@ -120,1 +119,1 @@\n- * However, if the return address layout has a {@linkplain OfAddress#targetLayout()} {@code T}, then the size of the returned segment\n+ * However, if the return address layout has a {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the returned segment\n@@ -131,1 +130,1 @@\n- * An upcall stub argument whose corresponding layout is an {@linkplain ValueLayout.OfAddress address layout}\n+ * An upcall stub argument whose corresponding layout is an {@linkplain AddressLayout address layout}\n@@ -134,1 +133,1 @@\n- * However, if the address layout has a {@linkplain OfAddress#targetLayout()} {@code T}, then the size of the\n+ * However, if the address layout has a {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.ValueLayout.OfAddress;\n@@ -421,1 +420,1 @@\n-     * dereference path element} for an address layout that has no {@linkplain OfAddress#targetLayout() target layout}.\n+     * dereference path element} for an address layout that has no {@linkplain AddressLayout#targetLayout() target layout}.\n@@ -637,1 +636,1 @@\n-         * {@linkplain OfAddress#targetLayout() target layout} (where set).\n+         * {@linkplain AddressLayout#targetLayout() target layout} (where set).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.ValueLayout.OfAddress;\n@@ -357,1 +356,1 @@\n- *     <li>pointers {@linkplain MemorySegment#get(OfAddress, long) read} from a memory segment.<\/li>\n+ *     <li>pointers {@linkplain MemorySegment#get(AddressLayout, long) read} from a memory segment.<\/li>\n@@ -398,1 +397,1 @@\n- * {@linkplain OfAddress#withTargetLayout(MemoryLayout) target layout} with the address layout used to obtain the\n+ * {@linkplain AddressLayout#withTargetLayout(MemoryLayout) target layout} with the address layout used to obtain the\n@@ -417,1 +416,1 @@\n- * {@link ValueLayout.OfAddress#withTargetLayout(MemoryLayout)}) are\n+ * {@link AddressLayout#withTargetLayout(MemoryLayout)}) are\n@@ -1643,1 +1642,1 @@\n-     * {@linkplain OfAddress#targetLayout()} {@code T}, then the size of the returned segment\n+     * {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the returned segment\n@@ -1654,1 +1653,1 @@\n-     * @throws IllegalArgumentException if provided address layout has a {@linkplain OfAddress#targetLayout() target layout}\n+     * @throws IllegalArgumentException if provided address layout has a {@linkplain AddressLayout#targetLayout() target layout}\n@@ -1661,1 +1660,1 @@\n-    default MemorySegment get(ValueLayout.OfAddress layout, long offset) {\n+    default MemorySegment get(AddressLayout layout, long offset) {\n@@ -1683,1 +1682,1 @@\n-    default void set(ValueLayout.OfAddress layout, long offset, MemorySegment value) {\n+    default void set(AddressLayout layout, long offset, MemorySegment value) {\n@@ -1985,1 +1984,1 @@\n-     * {@linkplain OfAddress#targetLayout()} {@code T}, then the size of the returned segment\n+     * {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the returned segment\n@@ -1998,1 +1997,1 @@\n-     * @throws IllegalArgumentException if provided address layout has a {@linkplain OfAddress#targetLayout() target layout}\n+     * @throws IllegalArgumentException if provided address layout has a {@linkplain AddressLayout#targetLayout() target layout}\n@@ -2005,1 +2004,1 @@\n-    default MemorySegment getAtIndex(ValueLayout.OfAddress layout, long index) {\n+    default MemorySegment getAtIndex(AddressLayout layout, long index) {\n@@ -2031,1 +2030,1 @@\n-    default void setAtIndex(ValueLayout.OfAddress layout, long index, MemorySegment value) {\n+    default void setAtIndex(AddressLayout layout, long index, MemorySegment value) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.foreign.MemorySessionImpl;\n@@ -202,1 +201,1 @@\n-    default MemorySegment allocate(ValueLayout.OfAddress layout, MemorySegment value) {\n+    default MemorySegment allocate(AddressLayout layout, MemorySegment value) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- *     <li>It can be {@linkplain MemorySegment#set(ValueLayout.OfAddress, long, MemorySegment) stored} inside another memory segment.<\/li>\n+ *     <li>It can be {@linkplain MemorySegment#set(AddressLayout, long, MemorySegment) stored} inside another memory segment.<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.Optional;\n@@ -35,1 +34,0 @@\n-import jdk.internal.reflect.CallerSensitive;\n@@ -57,1 +55,3 @@\n-public sealed interface ValueLayout extends MemoryLayout {\n+public sealed interface ValueLayout extends MemoryLayout permits\n+        ValueLayout.OfBoolean, ValueLayout.OfByte, ValueLayout.OfChar, ValueLayout.OfShort, ValueLayout.OfInt,\n+        ValueLayout.OfFloat, ValueLayout.OfLong, ValueLayout.OfDouble, AddressLayout {\n@@ -389,66 +389,0 @@\n-    \/**\n-     * A value layout whose carrier is {@code MemorySegment.class}. An address layout may optionally feature\n-     * a {@linkplain #targetLayout() target layout}. The target layout indicates the layout of the region\n-     * of memory pointed to by the address described by this layout.\n-     *\n-     * @see #ADDRESS\n-     * @see #ADDRESS_UNALIGNED\n-     * @since 19\n-     *\/\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfAddress extends ValueLayout permits ValueLayouts.OfAddressImpl {\n-\n-        \/**\n-         * {@inheritDoc}\n-         *\/\n-        @Override\n-        OfAddress withName(String name);\n-\n-        \/**\n-         * {@inheritDoc}\n-         *\/\n-        @Override\n-        OfAddress withBitAlignment(long bitAlignment);\n-\n-        \/**\n-         * {@inheritDoc}\n-         *\/\n-        @Override\n-        OfAddress withOrder(ByteOrder order);\n-\n-        \/**\n-         * Returns an address layout with the same carrier, alignment constraint, name and order as this address layout,\n-         * but associated with the specified target layout. The returned address layout allows raw addresses to be accessed\n-         * as {@linkplain MemorySegment memory segments} whose size is set to the size of the specified layout. Moreover,\n-         * if the accessed raw address is not compatible with the alignment constraint in the provided layout,\n-         * {@linkplain IllegalArgumentException} will be thrown.\n-         * @apiNote\n-         * This method can also be used to create an address layout which, when used, creates native memory\n-         * segments with maximal size (e.g. {@linkplain Long#MAX_VALUE}. This can be done by using a target sequence\n-         * layout with unspecified size, as follows:\n-         * {@snippet lang=java :\n-         * ValueLayout.OfAddress addressLayout = ...\n-         * ValueLayout.OfAddress unboundedLayout = addressLayout.withTargetLayout(\n-         *         MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n-         * }\n-         * <p>\n-         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-         * restricted methods, and use safe and supported functionalities, where possible.\n-         *\n-         * @param layout the target layout.\n-         * @return an address layout with same characteristics as this layout, but with the provided target layout.\n-         * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n-         * @see #targetLayout()\n-         *\/\n-        @CallerSensitive\n-        OfAddress withTargetLayout(MemoryLayout layout);\n-\n-        \/**\n-         * {@return the target layout associated with this address layout (if any)}.\n-         *\/\n-        Optional<MemoryLayout> targetLayout();\n-\n-    }\n-\n@@ -459,1 +393,1 @@\n-    OfAddress ADDRESS = ValueLayouts.OfAddressImpl.of(ByteOrder.nativeOrder());\n+    AddressLayout ADDRESS = ValueLayouts.OfAddressImpl.of(ByteOrder.nativeOrder());\n@@ -519,1 +453,1 @@\n-    OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n+    AddressLayout ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":5,"deletions":71,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -165,1 +166,1 @@\n-        if (!(layout instanceof ValueLayout.OfAddress addressLayout) ||\n+        if (!(layout instanceof AddressLayout addressLayout) ||\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -106,1 +107,1 @@\n-        if (layout instanceof ValueLayout.OfAddress ofAddress) {\n+        if (layout instanceof AddressLayout ofAddress) {\n@@ -255,1 +256,1 @@\n-            if (layout instanceof ValueLayout.OfAddress ofAddress && o instanceof MemorySegment m) {\n+            if (layout instanceof AddressLayout ofAddress && o instanceof MemorySegment m) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspectionUtil.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -124,1 +125,1 @@\n-        } else if (layout instanceof ValueLayout.OfAddress addressLayout) {\n+        } else if (layout instanceof AddressLayout addressLayout) {\n@@ -181,1 +182,1 @@\n-    public static long pointeeByteSize(ValueLayout.OfAddress addressLayout) {\n+    public static long pointeeByteSize(AddressLayout addressLayout) {\n@@ -187,1 +188,1 @@\n-    public static long pointeeByteAlign(ValueLayout.OfAddress addressLayout) {\n+    public static long pointeeByteAlign(AddressLayout addressLayout) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-        return paramLayout instanceof ValueLayout.OfAddress;\n+        return paramLayout instanceof AddressLayout;\n@@ -932,1 +932,1 @@\n-            return ValueLayout.OfAddress.class;\n+            return AddressLayout.class;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -80,1 +81,1 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ADDRESS\n+    public static final AddressLayout C_POINTER = ADDRESS\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -495,1 +496,1 @@\n-                    ValueLayout.OfAddress addressLayout = (ValueLayout.OfAddress)layout;\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -235,1 +236,1 @@\n-        } else if (layout instanceof ValueLayout.OfAddress al) {\n+        } else if (layout instanceof AddressLayout al) {\n@@ -263,1 +264,1 @@\n-        } else if (layout instanceof ValueLayout.OfAddress al) {\n+        } else if (layout instanceof AddressLayout al) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -393,1 +394,1 @@\n-                    ValueLayout.OfAddress addressLayout = (ValueLayout.OfAddress)layout;\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -321,1 +322,1 @@\n-                    ValueLayout.OfAddress addressLayout = (ValueLayout.OfAddress)layout;\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -276,1 +277,1 @@\n-                    ValueLayout.OfAddress addressLayout = (ValueLayout.OfAddress)layout;\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -318,1 +319,1 @@\n-    public static final class OfAddressImpl extends AbstractValueLayout<OfAddressImpl> implements ValueLayout.OfAddress {\n+    public static final class OfAddressImpl extends AbstractValueLayout<OfAddressImpl> implements AddressLayout {\n@@ -345,2 +346,2 @@\n-        public OfAddress withTargetLayout(MemoryLayout layout) {\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass(), OfAddress.class, \"withTargetLayout\");\n+        public AddressLayout withTargetLayout(MemoryLayout layout) {\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass(), AddressLayout.class, \"withTargetLayout\");\n@@ -356,1 +357,1 @@\n-        public static OfAddress of(ByteOrder order) {\n+        public static AddressLayout of(ByteOrder order) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-            case OfAddress oa -> 0; \/\/ leaf\n+            case AddressLayout oa -> 0; \/\/ leaf\n@@ -103,1 +103,1 @@\n-            case OfAddress oa -> 0; \/\/ leaf\n+            case AddressLayout oa -> 0; \/\/ leaf\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutPrincipalTotalityTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-        OfAddress v = ADDRESS\n+        AddressLayout v = ADDRESS\n@@ -127,1 +127,1 @@\n-        OfAddress v2 = v.withTargetLayout(JAVA_INT);\n+        AddressLayout v2 = v.withTargetLayout(JAVA_INT);\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -123,1 +124,1 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64)\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64)\n@@ -212,1 +213,1 @@\n-        } else if (layout instanceof ValueLayout.OfAddress) {\n+        } else if (layout instanceof AddressLayout) {\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -93,1 +94,1 @@\n-    static final ValueLayout.OfAddress ADDRESS_ALIGNED = ValueLayout.ADDRESS.withBitAlignment(ValueLayout.ADDRESS.bitSize());\n+    static final AddressLayout ADDRESS_ALIGNED = ValueLayout.ADDRESS.withBitAlignment(ValueLayout.ADDRESS.bitSize());\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-            ValueLayout.OfAddress.class,\n+            AddressLayout.class,\n@@ -155,1 +155,1 @@\n-        addDefaultMapping(ValueLayout.OfAddress.class, ValueLayout.ADDRESS);\n+        addDefaultMapping(AddressLayout.class, ValueLayout.ADDRESS);\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-        interface OfAddress extends AllocationFunction<MemorySegment, ValueLayout.OfAddress> { }\n+        interface OfAddress extends AllocationFunction<MemorySegment, AddressLayout> { }\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -53,2 +54,2 @@\n-        if (layout instanceof ValueLayout.OfAddress addressLayout && addressLayout.targetLayout().isPresent()) {\n-            newLayout = ((ValueLayout.OfAddress)newLayout).withTargetLayout(addressLayout.targetLayout().get());\n+        if (layout instanceof AddressLayout addressLayout && addressLayout.targetLayout().isPresent()) {\n+            newLayout = ((AddressLayout)newLayout).withTargetLayout(addressLayout.targetLayout().get());\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLayoutEquality.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -88,1 +89,1 @@\n-        public static final ValueLayout.OfAddress C_POINTER = SharedUtils.C_POINTER;;\n+        public static final AddressLayout C_POINTER = SharedUtils.C_POINTER;;\n@@ -142,1 +143,1 @@\n-        public static final ValueLayout.OfAddress C_POINTER = SharedUtils.C_POINTER;\n+        public static final AddressLayout C_POINTER = SharedUtils.C_POINTER;\n@@ -197,1 +198,1 @@\n-        public static final ValueLayout.OfAddress C_POINTER = SharedUtils.C_POINTER;\n+        public static final AddressLayout C_POINTER = SharedUtils.C_POINTER;\n@@ -249,1 +250,1 @@\n-        public static final ValueLayout.OfAddress C_POINTER = SharedUtils.C_POINTER;\n+        public static final AddressLayout C_POINTER = SharedUtils.C_POINTER;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/platform\/PlatformLayouts.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -87,1 +88,1 @@\n-        addDefaultMapping(ValueLayout.OfAddress.class, ValueLayout.ADDRESS);\n+        addDefaultMapping(AddressLayout.class, ValueLayout.ADDRESS);\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    private static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+    private static final AddressLayout C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/ImplicitAttach.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -70,1 +71,1 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -41,1 +42,1 @@\n-    private static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS\n+    private static final AddressLayout UNSAFE_ADDRESS = ValueLayout.ADDRESS\n@@ -45,1 +46,1 @@\n-        public ValueLayout.OfAddress layout() {\n+        public AddressLayout layout() {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/NativeType.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -61,1 +62,1 @@\n-    public static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS\n+    public static final AddressLayout UNSAFE_ADDRESS = ValueLayout.ADDRESS\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}