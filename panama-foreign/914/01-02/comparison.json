{"files":[{"patch":"@@ -98,1 +98,1 @@\n-For a more exhaustive examples of mapping between C types and layouts, please refer to the [appendix](#c-types-mapping-in-linuxx64). In the following sections, we will assume Linux\/x64 as our target platform.\n+For a more exhaustive examples of mappings between C types and layouts, please refer to the [appendix](#c-types-mapping-in-linuxx64). In the following sections, we will assume Linux\/x64 as our target platform.\n@@ -114,1 +114,0 @@\n-\n@@ -254,1 +253,1 @@\n-While this works, and provides optimal performance, it has some limitations<a href=\"#2\"><sup>3<\/sup><\/a>:\n+While this works, and provides optimal performance, it has some limitations<a href=\"#3\"><sup>3<\/sup><\/a>:\n@@ -377,1 +376,1 @@\n-* <a id=\"3\"\/>(<sup>2<\/sup>):<small> Previous iterations of the FFM API provided a `VaList` class that could be used to model a C `va_list`. This class was later dropped from the FFM API as too implementation specific. It is possible that a future version of the `jextract` tool might provide higher-level bindings for variadic calls. <\/small>\n+* <a id=\"3\"\/>(<sup>3<\/sup>):<small> Previous iterations of the FFM API provided a `VaList` class that could be used to model a C `va_list`. This class was later dropped from the FFM API as too implementation specific. It is possible that a future version of the `jextract` tool might provide higher-level bindings for variadic calls. <\/small>\n","filename":"doc\/panama_ffi.md","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-The attentive reader might have noted how rich the var handles obtained from the sequence layout in the previous section can be in fact derived from  the simple memory access var handle we have constructed here. That is, var handles can be adapted and turned into more complex var handles, using var handle *combinators*. Developers familiar with the method handle API know how simpler method handles can be combined into more complex ones using the various combinator methods in the `MethodHandles` class. These methods allow, for instance, to insert (or bind) arguments into a target method handle, filter return values, permute arguments and much more.\n+The attentive reader might have noted how the var handles obtained from the sequence layout in the previous section can be in fact derived from  the simple memory access var handle we have constructed here. That is, var handles can be adapted and turned into more complex var handles, using var handle *combinators*. Developers familiar with the method handle API know how simpler method handles can be combined into more complex ones using the various combinator methods in the `MethodHandles` class. These methods allow, for instance, to insert (or bind) arguments into a target method handle, filter return values, permute arguments and much more.\n","filename":"doc\/panama_memaccess.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}