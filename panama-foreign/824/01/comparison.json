{"files":[{"patch":"@@ -70,0 +70,3 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @throws IllegalArgumentException if {@code bitAlignment} is less than {@code M}, where {@code M} is the maximum alignment\n+     * constraint in any of the member layouts associated with this group layout.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -707,0 +707,1 @@\n+     * @throws IllegalArgumentException if {@code elementLayout.bitAlignment() > elementLayout.bitSize()}.\n@@ -711,0 +712,1 @@\n+        Utils.checkElementAlignment(elementLayout, \"Element layout alignment greater than its size\");\n@@ -726,0 +728,1 @@\n+     * @throws IllegalArgumentException if {@code elementLayout.bitAlignment() > elementLayout.bitSize()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,0 +145,2 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @throws IllegalArgumentException if {@code bitAlignment < elementLayout().bitAlignment()}.\n@@ -146,1 +148,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+     * @throws IllegalArgumentException {@inheritDoc}\n@@ -154,1 +155,0 @@\n-\n@@ -180,0 +180,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -215,0 +216,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -251,0 +253,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -287,0 +290,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -323,0 +327,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -395,0 +400,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n@@ -431,0 +437,1 @@\n+         * @throws IllegalArgumentException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -195,1 +195,0 @@\n-        checkAlignment(this);\n@@ -284,20 +283,0 @@\n-    private static void checkAlignment(LayoutPath path) {\n-        MemoryLayout layout = path.layout;\n-        long alignment = layout.bitAlignment();\n-        if (!Utils.isAligned(path.offset, alignment)) {\n-            throw new UnsupportedOperationException(\"Invalid alignment requirements for layout \" + layout);\n-        }\n-        for (long stride : path.strides) {\n-            if (!Utils.isAligned(stride, alignment)) {\n-                throw new UnsupportedOperationException(\"Alignment requirements for layout \" + layout + \" do not match stride \" + stride);\n-            }\n-        }\n-        LayoutPath encl = path.enclosing;\n-        if (encl != null) {\n-            if (encl.layout.bitAlignment() < alignment) {\n-                throw new UnsupportedOperationException(\"Alignment requirements for layout \" + layout + \" do not match those for enclosing layout \" + encl.layout);\n-            }\n-            checkAlignment(encl);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -86,0 +86,8 @@\n+    @Override\n+    public L withBitAlignment(long bitAlignment) {\n+        if (bitAlignment < kind.alignof(elements)) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint\");\n+        }\n+        return super.withBitAlignment(bitAlignment);\n+    }\n+\n@@ -135,0 +143,3 @@\n+                if (this == STRUCT && (size % elem.bitAlignment() != 0)) {\n+                    throw new IllegalArgumentException(\"Invalid alignment constraint for member layout: \" + elem);\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    public final L withBitAlignment(long bitAlignment) {\n+    public L withBitAlignment(long bitAlignment) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,0 +203,8 @@\n+    @Override\n+    public SequenceLayoutImpl withBitAlignment(long bitAlignment) {\n+        if (bitAlignment < elementLayout.bitAlignment()) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint\");\n+        }\n+        return super.withBitAlignment(bitAlignment);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/SequenceLayoutImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    private static final long BIT_ALIGNMENT = Long.SIZE * 2;\n+    private static final long BIT_ALIGNMENT = Byte.SIZE;\n@@ -168,1 +168,3 @@\n-        GroupLayout v = MemoryLayout.structLayout(JAVA_INT, JAVA_LONG)\n+        GroupLayout v = MemoryLayout.structLayout(\n+                        JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n+                        JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n@@ -177,1 +179,3 @@\n-        StructLayout v = MemoryLayout.structLayout(JAVA_INT, JAVA_LONG)\n+        StructLayout v = MemoryLayout.structLayout(\n+                        JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n+                        JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n@@ -186,1 +190,3 @@\n-        UnionLayout v = MemoryLayout.unionLayout(JAVA_INT, JAVA_LONG)\n+        UnionLayout v = MemoryLayout.unionLayout(\n+                    JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n+                    JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -179,38 +179,0 @@\n-    @Test\n-    public void testBadContainerAlign() {\n-        GroupLayout g = MemoryLayout.structLayout(JAVA_INT.withBitAlignment(16).withName(\"foo\")).withBitAlignment(8);\n-        try {\n-            g.bitOffset(groupElement(\"foo\"));\n-            g.byteOffset(groupElement(\"foo\"));\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex); \/\/ should be ok!\n-        }\n-        try {\n-            g.varHandle(groupElement(\"foo\")); \/\/ok\n-            assertTrue(false); \/\/should fail!\n-        } catch (UnsupportedOperationException ex) {\n-            \/\/ok\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex); \/\/should fail!\n-        }\n-    }\n-\n-    @Test\n-    public void testBadAlignOffset() {\n-        GroupLayout g = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n-        try {\n-            g.bitOffset(groupElement(\"foo\"));\n-            g.byteOffset(groupElement(\"foo\"));\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex); \/\/ should be ok!\n-        }\n-        try {\n-            g.varHandle(groupElement(\"foo\")); \/\/ok\n-            assertTrue(false); \/\/should fail!\n-        } catch (UnsupportedOperationException ex) {\n-            \/\/ok\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex); \/\/should fail!\n-        }\n-    }\n-\n@@ -255,3 +217,3 @@\n-                ValueLayout.JAVA_CHAR.withName(\"1\"),\n-                ValueLayout.JAVA_FLOAT.withName(\"2\"),\n-                ValueLayout.JAVA_LONG.withName(\"3\")\n+                ValueLayout.JAVA_CHAR.withBitAlignment(8).withName(\"1\"),\n+                ValueLayout.JAVA_FLOAT.withBitAlignment(8).withName(\"2\"),\n+                ValueLayout.JAVA_LONG.withBitAlignment(8).withName(\"3\")\n@@ -364,1 +326,1 @@\n-            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), JAVA_INT.withName(\"y\"))),\n+            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(32), JAVA_INT.withName(\"y\"))),\n@@ -367,1 +329,1 @@\n-            (JAVA_INT.bitSize() + 8) * 4 + 8\n+            (JAVA_INT.bitSize() + 32) * 4 + 32\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":5,"deletions":43,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-            if (layout.bitAlignment() == layout.bitSize()) {\n+            if (layout.bitAlignment() == bitAlign) {\n@@ -282,1 +282,3 @@\n-                assertEquals(layout.withBitAlignment(a).toString().contains(\"%\"), a != bitAlign);\n+                if (a >= layout.bitAlignment()) {\n+                    assertEquals(layout.withBitAlignment(a).toString().contains(\"%\"), a != bitAlign);\n+                }\n@@ -287,0 +289,22 @@\n+    @Test(dataProvider=\"layoutsAndAlignments\")\n+    public void testBadBitAlignment(MemoryLayout layout, long bitAlign) {\n+        long[] alignments = { 8, 16, 32, 64, 128 };\n+        for (long a : alignments) {\n+            if (a < bitAlign && !(layout instanceof ValueLayout)) {\n+                assertThrows(IllegalArgumentException.class, () -> layout.withBitAlignment(a));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider=\"layoutsAndAlignments\", expectedExceptions = IllegalArgumentException.class)\n+    public void testBadSequence(MemoryLayout layout, long bitAlign) {\n+        layout = layout.withBitAlignment(layout.bitSize() * 2); \/\/ hyper-align\n+        MemoryLayout.sequenceLayout(layout);\n+    }\n+\n+    @Test(dataProvider=\"layoutsAndAlignments\", expectedExceptions = IllegalArgumentException.class)\n+    public void testBadStruct(MemoryLayout layout, long bitAlign) {\n+        layout = layout.withBitAlignment(layout.bitSize() * 2); \/\/ hyper-align\n+        MemoryLayout.structLayout(layout, layout);\n+    }\n+\n@@ -425,1 +449,1 @@\n-                MemoryLayout.structLayout(JAVA_INT, JAVA_LONG),\n+                MemoryLayout.structLayout(JAVA_INT, MemoryLayout.paddingLayout(32), JAVA_LONG),\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -65,3 +65,0 @@\n-        MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n-        assertEquals(alignedGroup.bitAlignment(), align);\n-        VarHandle vh = aligned.varHandle();\n@@ -69,0 +66,3 @@\n+            MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n+            assertEquals(alignedGroup.bitAlignment(), align);\n+            VarHandle vh = aligned.varHandle();\n@@ -81,1 +81,0 @@\n-        GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n@@ -83,0 +82,1 @@\n+            GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n@@ -85,1 +85,1 @@\n-        } catch (UnsupportedOperationException ex) {\n+        } catch (IllegalArgumentException ex) {\n@@ -92,1 +92,0 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(align));\n@@ -94,0 +93,1 @@\n+            SequenceLayout layout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(align));\n@@ -101,1 +101,1 @@\n-        } catch (UnsupportedOperationException ex) {\n+        } catch (IllegalArgumentException ex) {\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -216,21 +216,0 @@\n-            },\n-            \/\/ struct __attribute__((__packed__)) s { float a; double b; };\n-            { MemoryLayout.structLayout(C_FLOAT, C_DOUBLE),\n-                new Binding[]{\n-                    dup(),\n-                    \/\/ s.a\n-                    bufferLoad(0, float.class), vmStore(f10, float.class),\n-                    \/\/ s.b\n-                    bufferLoad(4, double.class), vmStore(f11, double.class),\n-                }\n-            },\n-            \/\/ struct s { float a; float b __attribute__ ((aligned (8))); }\n-            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32),\n-                C_FLOAT, MemoryLayout.paddingLayout(32)),\n-                new Binding[]{\n-                    dup(),\n-                    \/\/ s.a\n-                    bufferLoad(0, float.class), vmStore(f10, float.class),\n-                    \/\/ s.b\n-                    bufferLoad(8, float.class), vmStore(f11, float.class),\n-                }\n@@ -281,1 +260,1 @@\n-        MemoryLayout fa = MemoryLayout.structLayout(C_FLOAT, C_DOUBLE);\n+        MemoryLayout fa = MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE);\n@@ -301,1 +280,1 @@\n-                bufferLoad(4, double.class),\n+                bufferLoad(8, double.class),\n@@ -313,1 +292,1 @@\n-            bufferStore(4, double.class)\n+            bufferStore(8, double.class)\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestRISCV64CallArranger.java","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -148,60 +148,0 @@\n-    @Test\n-    public void testNestedStructsUnaligned() {\n-        MemoryLayout POINT = MemoryLayout.structLayout(\n-                C_INT,\n-                MemoryLayout.structLayout(\n-                        C_LONG,\n-                        C_INT\n-                )\n-        );\n-        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(POINT);\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n-                    bufferLoad(8, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class)},\n-            { vmStore(rax, long.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-\n-        assertEquals(bindings.nVectorArgs(), 0);\n-    }\n-\n-    @Test\n-    public void testNestedUnionUnaligned() {\n-        MemoryLayout POINT = MemoryLayout.structLayout(\n-                C_INT,\n-                MemoryLayout.unionLayout(\n-                        MemoryLayout.structLayout(C_INT, C_INT),\n-                        C_LONG\n-                )\n-        );\n-        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(POINT);\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n-                    bufferLoad(8, int.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), int.class)},\n-            { vmStore(rax, long.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-\n-        assertEquals(bindings.nVectorArgs(), 0);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"modified"}]}