{"files":[{"patch":"@@ -30,54 +30,0 @@\n-Text::Text(size_t len, char *text, bool isCopy)\n-        : len(len), text(text), isCopy(isCopy) {\n-    std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n-}\n-Text::Text(char *text, bool isCopy)\n-        : len(std::strlen(text)), text(text), isCopy(isCopy) {\n-    std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n-}\n-Text::Text(size_t len)\n-        : len(len), text(len > 0 ? new char[len] : nullptr), isCopy(true) {\n-    std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n-}\n-void Text::write(std::string &filename) const{\n-    std::ofstream out;\n-    out.open(filename, std::ofstream::trunc);\n-    out.write(text, len);\n-    out.close();\n-}\n-void Text::read(std::string &filename){\n-    if (isCopy && text){\n-        delete[] text;\n-    }\n-    text = nullptr;\n-    isCopy=false;\n-    \/\/ std::cout << \"reading from \" << filename << std::endl;\n-\n-    std::ifstream ptxStream;\n-    ptxStream.open(filename);\n-\n-\n-    ptxStream.seekg(0, std::ios::end);\n-    len = ptxStream.tellg();\n-    ptxStream.seekg(0, std::ios::beg);\n-\n-    if (len > 0) {\n-        text = new char[len];\n-        isCopy = true;\n-        \/\/std::cerr << \"about to read  \" << len << std::endl;\n-        ptxStream.read(text, len);\n-        ptxStream.close();\n-        \/\/std::cerr << \"read  \" << len << std::endl;\n-        text[len - 1] = '\\0';\n-        \/\/std::cerr << \"read text \" << text << std::endl;\n-    }\n-}\n-\n-Text::~Text(){\n-    if (isCopy && text){\n-        delete[] text;\n-    }\n-    text = nullptr;\n-    isCopy = false;\n-    len = 0;\n-}\n@@ -101,1 +47,1 @@\n-   :Text(len, text, isCopy){\n+        :Text(len, text, isCopy){\n@@ -107,6 +53,0 @@\n-Log::Log(size_t len)\n-        : Text(len) {\n-}\n-Log::Log(char *text)\n-        : Text(text, false) {\n-}\n@@ -364,1 +304,1 @@\n-extern \"C\" long getCudaBackend(int mode) {\n+extern \"C\" long getBackend(int mode) {\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend.cpp","additions":2,"deletions":62,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -37,12 +37,0 @@\n-template<typename T>\n-T *bufferOf(const char*name){\n-    T *buffer = (T*)new unsigned char[sizeof(T) + sizeof(BufferState_s)+32];\n-    auto bs = BufferState_s::of(buffer, sizeof(T));\n-    bs->magic1 =  bs->magic2 = BufferState_s::MAGIC;\n-    bs->ptr = buffer;\n-    bs->length=sizeof(T);\n-    bs->state=BufferState_s::NEW_STATE;\n-    bs->vendorPtr = nullptr;\n-    bs->dump(name);\n-    return buffer;\n-}\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/squares.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,13 +66,1 @@\n-class Text {\n-public:\n-    size_t len;\n-    char *text;\n-    bool isCopy;\n-\n-    Text(size_t len, char *text, bool isCopy);\n-    Text(char *text, bool isCopy);\n-    Text(size_t len);\n-    void write(std::string &filename) const;\n-    void read(std::string &filename);\n-    virtual ~Text();\n-};\n+\n@@ -96,7 +84,0 @@\n-class Log:public Text  {\n-public:\n-    Log(size_t len);\n-    Log(char* text);\n-    ~Log()  = default;\n-};\n-\n@@ -164,1 +145,0 @@\n-\n","filename":"hat\/backends\/ffi\/cuda\/include\/cuda_backend.h","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,2 +37,5 @@\n-    final Config config;\n-    final FFILib.LongIntMethodPtr getBackend_MPtr;\n+   \/\/ final Config config;\n+   \/\/ final FFILib.LongIntMethodPtr getBackend_MPtr;\n+    \/\/public long getBackend(int configBits) {\n+      \/\/  return backendBridge.handle = getBackend_MPtr.invoke(configBits);\n+   \/\/ }\n@@ -40,0 +43,7 @@\n+    public CudaBackend(String configSpec) {\n+        this(Config.of(configSpec));\n+    }\n+\n+    public CudaBackend() {\n+        this(Config.of());\n+    }\n@@ -41,8 +51,1 @@\n-        super(\"cuda_backend\");\n-        this.config = config;\n-        getBackend_MPtr  =  ffiLib.longIntFunc(\"getCudaBackend\");\n-        getBackend(this.config.bits());\n-        if (this.config.isINFO()) {\n-            System.out.println(\"CONFIG = \" + this.config);\n-            backendBridge.info();\n-        }\n+        super(\"cuda_backend\", config);\n@@ -58,11 +61,0 @@\n-    public long getBackend(int configBits) {\n-        return backendBridge.handle = getBackend_MPtr.invoke(configBits);\n-    }\n-\n-    public CudaBackend(String configSpec) {\n-        this(Config.of(configSpec));\n-    }\n-\n-    public CudaBackend() {\n-        this(Config.of());\n-    }\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-        long getKernel(int nameLen, char *name) {\n-            return (long) new MockKernel(this, name);\n+        Kernel* getKernel(int nameLen, char *name) {\n+            return new MockKernel(this, name);\n@@ -61,1 +61,1 @@\n-    MockBackend(int mode): Backend(mode) {\n+    MockBackend(int configBits): Backend(configBits) {\n@@ -67,1 +67,1 @@\n-    bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) {\n+    bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) override {\n@@ -72,4 +72,0 @@\n-    int getMaxComputeUnits() {\n-        std::cout << \"mock getMaxComputeUnits()\" << std::endl;\n-        return 0;\n-    }\n@@ -77,1 +73,1 @@\n-    void info() {\n+    void info() override {\n@@ -80,6 +76,0 @@\n-     void computeStart(){\n-           std::cout << \"mock compute start()\" << std::endl;\n-         }\n-            void computeEnd(){\n-              std::cout << \"mock compute start()\" << std::endl;\n-            }\n@@ -87,1 +77,9 @@\n-    long compile(int len, char *source) {\n+    void computeStart() override{\n+        std::cout << \"mock compute start()\" << std::endl;\n+    }\n+\n+    void computeEnd() override{\n+        std::cout << \"mock compute start()\" << std::endl;\n+    }\n+\n+    CompilationUnit *compile(int len, char *source) override{\n@@ -95,1 +93,1 @@\n-        return (long)mockProgram;\n+        return dynamic_cast<CompilationUnit*>(mockProgram);\n@@ -99,2 +97,2 @@\n-long getMockBackend(int mode) {\n-    return (long) new MockBackend(mode);\n+long getBackend(int configBits) {\n+    return reinterpret_cast<long>(new MockBackend(configBits));\n","filename":"hat\/backends\/ffi\/mock\/cpp\/mock_backend.cpp","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -37,4 +37,4 @@\n-    final FFILib.LongIntMethodPtr getBackend_MPtr;\n-    public long getBackend(int mode) {\n-       return getBackend_MPtr.invoke(mode);\n-    }\n+    \/\/final FFILib.LongIntMethodPtr getBackend_MPtr;\n+    \/\/public long getBackend(int mode) {\n+      \/\/ return getBackend_MPtr.invoke(mode);\n+   \/\/ }\n@@ -44,3 +44,3 @@\n-        super(\"mock_backend\");\n-        getBackend_MPtr  =  ffiLib.longIntFunc(\"getMockBackend\");\n-        getBackend(0);\n+        super(\"mock_backend\", Config.of(0));\n+       \/\/ getBackend_MPtr  =  ffiLib.longIntFunc(\"getMockBackend\");\n+       \/\/ getBackend(0);\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+\n@@ -67,1 +68,2 @@\n-        ${OPENCL_BACKEND}\/cpp\/info.cpp\n+            ${OPENCL_BACKEND}\/include\/opencl_backend.h\n+            ${OPENCL_BACKEND}\/cpp\/info.cpp\n@@ -69,0 +71,4 @@\n+    add_executable(opencl_squares\n+            ${OPENCL_BACKEND}\/include\/opencl_backend.h\n+            ${OPENCL_BACKEND}\/cpp\/squares.cpp\n+        )\n@@ -70,0 +76,4 @@\n+    target_link_libraries(opencl_squares\n+        opencl_backend\n+        ${OPENCL_LIB}\n+    )\n","filename":"hat\/backends\/ffi\/opencl\/CMakeLists.txt","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -154,0 +154,6 @@\n+  OpenCLBackend::OpenCLProgram *OpenCLBackend::compileProgram(OpenCLSource &openclSource){\n+    return compileProgram(&openclSource);\n+  }\n+  OpenCLBackend::OpenCLProgram *OpenCLBackend::compileProgram(OpenCLSource *openclSource){\n+      return compileProgram(openclSource->len, openclSource->text);\n+  }\n@@ -155,15 +161,2 @@\n-long OpenCLBackend::compile(int len, char *source) {\n-    size_t srcLen = ::strlen(source);\n-    char *src = new char[srcLen + 1];\n-    ::strncpy(src, source, srcLen);\n-    src[srcLen] = '\\0';\n-    if(openclConfig.trace){\n-        std::cout << \"native compiling \" << src << std::endl;\n-    }\n-    cl_int status;\n-    cl_program program;\n-    if ((program = clCreateProgramWithSource(context, 1, (const char **) &src, nullptr, &status)) == nullptr ||\n-        status != CL_SUCCESS) {\n-        std::cerr << \"clCreateProgramWithSource failed\" << std::endl;\n-        delete[] src;\n-        return 0;\n+    OpenCLBackend::OpenCLProgram *OpenCLBackend::compileProgram(int len, char *text){\n+        return dynamic_cast<OpenCLProgram *>(compile(len, text));\n@@ -172,27 +165,16 @@\n-    cl_int buildStatus = clBuildProgram(program, 0, nullptr, nullptr, nullptr, nullptr);\n-    if (buildStatus != CL_SUCCESS) {\n-       std::cerr << \"buildStatus =failed\" << std::endl;\n-    }\n-    size_t logLen = 0;\n-    OpenCLProgram *openclProgram = nullptr;\n-    if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, 0, nullptr, &logLen)) != CL_SUCCESS) {\n-        std::cerr << \"clGetBuildInfo (getting log size) failed\" << std::endl;\n-        \/\/openclProgram->buildInfo = new Backend::CompilationUnit::BuildInfo(openclProgram, src, nullptr, false);\n-       openclProgram= new OpenCLProgram(this,  src,nullptr,buildStatus==CL_SUCCESS,program);\n-    } else {\n-        cl_build_status buildStatus;\n-        clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_STATUS, sizeof(buildStatus), &buildStatus, nullptr);\n-        if (logLen > 0) {\n-            char *log = new char[logLen + 1];\n-            if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, logLen + 1, (void *) log,\n-                                                nullptr)) != CL_SUCCESS) {\n-                std::cerr << \"clGetBuildInfo (getting log) failed\" << std::endl;\n-                delete[] log;\n-                log = nullptr;\n-            } else {\n-                log[logLen] = '\\0';\n-                if (logLen > 1) {\n-                    std::cerr << \"logLen = \" << logLen << \" log  = \" << log << std::endl;\n-                }\n-            }\n-              openclProgram= new OpenCLProgram(this,  src,log,buildStatus==CL_SUCCESS,program);\n+    Backend::CompilationUnit *OpenCLBackend::compile(int len, char *source){\n+     size_t srcLen = ::strlen(source);\n+        char *src = new char[srcLen + 1];\n+        ::strncpy(src, source, srcLen);\n+        src[srcLen] = '\\0';\n+        if(openclConfig.trace){\n+            std::cout << \"native compiling \" << src << std::endl;\n+        }\n+        cl_int status;\n+        cl_program program;\n+        if ((program = clCreateProgramWithSource(context, 1, (const char **) &src, nullptr, &status)) == nullptr ||\n+            status != CL_SUCCESS) {\n+            std::cerr << \"clCreateProgramWithSource failed\" << std::endl;\n+            delete[] src;\n+            return 0;\n+        }\n@@ -200,0 +182,10 @@\n+        cl_int buildStatus = clBuildProgram(program, 0, nullptr, nullptr, nullptr, nullptr);\n+        if (buildStatus != CL_SUCCESS) {\n+           std::cerr << \"buildStatus =failed\" << std::endl;\n+        }\n+        size_t logLen = 0;\n+        OpenCLProgram *openclProgram = nullptr;\n+        if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, 0, nullptr, &logLen)) != CL_SUCCESS) {\n+            std::cerr << \"clGetBuildInfo (getting log size) failed\" << std::endl;\n+            \/\/openclProgram->buildInfo = new Backend::CompilationUnit::BuildInfo(openclProgram, src, nullptr, false);\n+           openclProgram= new OpenCLProgram(this,  src,nullptr,buildStatus==CL_SUCCESS,program);\n@@ -201,1 +193,20 @@\n-          openclProgram= new OpenCLProgram(this, src, nullptr, buildStatus==CL_SUCCESS, program);\n+            cl_build_status buildStatus;\n+            clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_STATUS, sizeof(buildStatus), &buildStatus, nullptr);\n+            if (logLen > 0) {\n+                char *log = new char[logLen + 1];\n+                if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, logLen + 1, (void *) log,\n+                                                    nullptr)) != CL_SUCCESS) {\n+                    std::cerr << \"clGetBuildInfo (getting log) failed\" << std::endl;\n+                    delete[] log;\n+                    log = nullptr;\n+                } else {\n+                    log[logLen] = '\\0';\n+                    if (logLen > 1) {\n+                        std::cerr << \"logLen = \" << logLen << \" log  = \" << log << std::endl;\n+                    }\n+                }\n+                  openclProgram= new OpenCLProgram(this,  src,log,buildStatus==CL_SUCCESS,program);\n+\n+            } else {\n+              openclProgram= new OpenCLProgram(this, src, nullptr, buildStatus==CL_SUCCESS, program);\n+            }\n@@ -203,0 +214,1 @@\n+        return openclProgram;\n@@ -205,2 +217,0 @@\n-    return reinterpret_cast<long>(openclProgram);\n-}\n@@ -280,2 +290,2 @@\n-long getOpenCLBackend(int configBits) {\n- \/\/ std::cerr << \"Opencl Driver mode=\" << mode << \" platform=\" << platform << \" device=\" << device << std::endl;\n+extern \"C\" long getBackend(int configBits) {\n+  std::cerr << \"Opencl Driver =\" << std::hex<< configBits <<std::dec<< std::endl;\n@@ -294,0 +304,9 @@\n+OpenCLSource::OpenCLSource()\n+        : Text(0L) {\n+}\n+OpenCLSource::OpenCLSource(size_t len)\n+        : Text(len) {\n+}\n+OpenCLSource::OpenCLSource(char *text)\n+        : Text(text, false) {\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":66,"deletions":47,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -139,4 +139,4 @@\n-int OpenCLBackend::getMaxComputeUnits() {\n-    PlatformInfo platformInfo(this);\n-    return platformInfo.deviceInfo.maxComputeUnits;\n-}\n+\/\/int OpenCLBackend::getMaxComputeUnits() {\n+ \/\/   PlatformInfo platformInfo(this);\n+ \/\/   return platformInfo.deviceInfo.maxComputeUnits;\n+\/\/}\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_info.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-long OpenCLBackend::OpenCLProgram::getKernel(int nameLen, char *name) {\n+ Backend::CompilationUnit::Kernel *OpenCLBackend::OpenCLProgram::getKernel(int nameLen, char *name) {\n@@ -42,1 +42,8 @@\n-    return (long) new OpenCLKernel(this,name, kernel);\n+    return dynamic_cast<Backend::CompilationUnit::Kernel *>(new OpenCLKernel(this,name, kernel));\n+}\n+OpenCLBackend::OpenCLProgram::OpenCLKernel *OpenCLBackend::OpenCLProgram::getOpenCLKernel(int len, char *name) {\n+   return dynamic_cast<OpenCLProgram::OpenCLKernel *>(getKernel(len, name));\n+}\n+\n+OpenCLBackend::OpenCLProgram::OpenCLKernel *OpenCLBackend::OpenCLProgram::getOpenCLKernel(char *name) {\n+   return getOpenCLKernel(::strlen(name), name);\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_program.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"opencl_backend.h\"\n+class KernelContext {\n+public:\n+    int x;\n+    int maxX;\n+    BufferState_s bufferState;\n+};\n+struct ArgArray_2 {\n+    int argc;\n+    u8_t pad12[12];\n+    Arg_s argv[2];\n+};\n+\n+\n+struct S32Array1024_s {\n+    int length;\n+    int array[1024];\n+    BufferState_s bufferState;\n+};\n+int main(int argc, char **argv) {\n+    OpenCLBackend openclBackend(0\n+            | OpenCLBackend::OpenCLConfig::Config::INFO_BIT\n+            | OpenCLBackend::OpenCLConfig::Config::TRACE_CALLS_BIT\n+            | OpenCLBackend::OpenCLConfig::Config::TRACE_COPIES_BIT\n+    );\n+\n+    \/\/std::string cudaPath =  \"\/home\/gfrost\/github\/grfrost\/babylon-grfrost-fork\/hat\/squares.cuda\";\n+    OpenCLSource openclSource((char *) R\"(\n+ #define NDRANGE_OPENCL\n+ #pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n+ #pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n+ #ifndef NULL\n+ #define NULL 0\n+ #endif\n+ #pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n+ #pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n+ typedef char s8_t;\n+ typedef char byte;\n+ typedef char boolean;\n+ typedef unsigned char u8_t;\n+ typedef short s16_t;\n+ typedef unsigned short u16_t;\n+ typedef unsigned int u32_t;\n+ typedef int s32_t;\n+ typedef float f32_t;\n+ typedef long s64_t;\n+ typedef unsigned long u64_t;\n+ typedef struct KernelContext_s{\n+     int x;\n+     int maxX;\n+ }KernelContext_t;\n+ typedef struct S32Array_s{\n+     int length;\n+     int array[1];\n+ }S32Array_t;\n+\n+\n+\n+ inline int squareit(\n+     int v\n+ ){\n+     return v*v;\n+ }\n+\n+\n+ __kernel void squareKernel(\n+     __global KernelContext_t *global_kc, __global S32Array_t* s32Array\n+ ){\n+     KernelContext_t mine;\n+     KernelContext_t* kc=&mine;\n+     kc->x=get_global_id(0);\n+     kc->maxX=global_kc->maxX;\n+     if(kc->x<kc->maxX){\n+         int value = s32Array->array[(long)kc->x];\n+         s32Array->array[(long)kc->x]=squareit(value);\n+     }\n+     return;\n+ }\n+    )\");\n+\n+    auto *program =openclBackend.compileProgram(openclSource);\n+    int maxX = 32;\n+    auto *kernelContext = bufferOf<KernelContext>(\"kernelContext\");\n+    kernelContext->x=0;\n+    kernelContext->maxX=maxX;\n+\n+    auto *s32Array1024 = bufferOf<S32Array1024_s>(\"s32Arrayx1024\");\n+\n+    s32Array1024->length=maxX;\n+\n+    for (int i=0; i<s32Array1024->length; i++){\n+        s32Array1024->array[i]=i;\n+    }\n+\n+    ArgArray_2 args2Array{.argc = 2, .argv={\n+            {.idx = 0, .variant = '&',.value = {.buffer ={.memorySegment = (void *) kernelContext, .sizeInBytes = sizeof(KernelContext), .access = RO_BYTE}}},\n+            {.idx = 1, .variant = '&',.value = {.buffer ={.memorySegment = (void *) s32Array1024, .sizeInBytes = sizeof(S32Array1024_s), .access = RW_BYTE}}}\n+    }};\n+    auto kernel = program->getOpenCLKernel((char*)\"squareKernel\");\n+    kernel->ndrange( reinterpret_cast<ArgArray_s *>(&args2Array));\n+    for (int i=0; i<s32Array1024->length; i++){\n+        std::cout << i << \" array[\"<<i<<\"]=\"<<s32Array1024->array[i] <<std::endl;\n+    }\n+}\n+\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/squares.cpp","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -40,0 +40,11 @@\n+\n+\n+class OpenCLSource:public Text  {\n+public:\n+    OpenCLSource(size_t len, char *text, bool isCopy);\n+    OpenCLSource(size_t len);\n+    OpenCLSource(char* text);\n+    OpenCLSource();\n+    ~OpenCLSource() = default;\n+};\n+\n@@ -93,5 +104,0 @@\n-            public:\n-\n-        private:\n-            const char *name;\n-            cl_kernel kernel;\n@@ -99,0 +105,2 @@\n+           \/\/ const char *name;\n+            cl_kernel kernel;\n@@ -108,1 +116,3 @@\n-        long getKernel(int nameLen, char *name);\n+        OpenCLKernel *getOpenCLKernel(char *name);\n+        OpenCLKernel *getOpenCLKernel(int nameLen, char *name);\n+        CompilationUnit::Kernel *getKernel(int nameLen, char *name) override;\n@@ -120,8 +130,14 @@\n-    int getMaxComputeUnits();\n-    bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength);\n-    void info();\n-    void computeStart();\n-    void computeEnd();\n-    void dumpSled(std::ostream &out,void *argArray);\n-    char *dumpSchema(std::ostream &out,int depth, char *ptr, void *data);\n-    long compile(int len, char *source);\n+    \/\/int getMaxComputeUnits() override;\n+\n+\n+   \/\/ void dumpSled(std::ostream &out,void *argArray) override;\n+   \/\/ char *dumpSchema(std::ostream &out,int depth, char *ptr, void *data) override;\n+    OpenCLProgram *compileProgram(OpenCLSource &openclSource) ;\n+    OpenCLProgram *compileProgram(OpenCLSource *openclSource);\n+    OpenCLProgram *compileProgram(int len, char *source);\n+\n+    CompilationUnit *compile(int len, char *source) override;\n+    void computeStart() override;\n+    void computeEnd() override;\n+    bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) override;\n+    void info() override;\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":30,"deletions":14,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    final Config config;\n+   \/\/ final Config config;\n@@ -39,5 +39,0 @@\n-    final FFILib.LongIntMethodPtr getBackend_MPtr;\n-\n-    public long getBackend(int configBits) {\n-            return backendBridge.handle = getBackend_MPtr.invoke(configBits);\n-    }\n@@ -50,8 +45,2 @@\n-        super(\"opencl_backend\");\n-        this.config = config;\n-        getBackend_MPtr = ffiLib.longIntFunc(\"getOpenCLBackend\");\n-        getBackend(this.config.bits());\n-        if (this.config.isINFO()) {\n-            System.out.println(\"CONFIG = \" + this.config);\n-            backendBridge.info();\n-        }\n+        super(\"opencl_backend\", config);\n+\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,237 +0,0 @@\n-package hat.backend.ffi;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-public record OpenCLConfig(int bits) {\n-    record Bit(int index, String name) {\n-    }\n-\n-    \/\/ These must sync with hat\/backends\/ffi\/opencl\/include\/opencl_backend.h\n-    \/\/ Bits 0-3 select platform id 0..5\n-    \/\/ Bits 4-7 select device id 0..15\n-    private static final int START_BIT_IDX = 16;\n-    private static final int MINIMIZE_COPIES_BIT = 1 << START_BIT_IDX;\n-    private static final int TRACE_BIT = 1 << 17;\n-    private static final int PROFILE_BIT = 1 << 18;\n-    private static final int SHOW_CODE_BIT = 1 << 19;\n-    private static final int SHOW_KERNEL_MODEL_BIT = 1 << 20;\n-    private static final int SHOW_COMPUTE_MODEL_BIT = 1 << 21;\n-    private static final int INFO_BIT = 1 << 22;\n-    private static final int TRACE_COPIES_BIT = 1 << 23;\n-    private static final int TRACE_SKIPPED_COPIES_BIT = 1 << 24;\n-    private static final int TRACE_ENQUEUES_BIT = 1 << 25;\n-    private static final int TRACE_CALLS_BIT = 1 << 26;\n-    private static final int SHOW_WHY_BIT = 1 << 27;\n-    private static final int SHOW_STATE_BIT = 1 << 28;\n-    private static final int END_BIT_IDX = 29;\n-\n-    private static String[] bitNames = {\n-            \"MINIMIZE_COPIES\",\n-            \"TRACE\",\n-            \"PROFILE\",\n-            \"SHOW_CODE\",\n-            \"SHOW_KERNEL_MODEL\",\n-            \"SHOW_COMPUTE_MODEL\",\n-            \"INFO\",\n-            \"TRACE_COPIES\",\n-            \"TRACE_SKIPPED_COPIES\",\n-            \"TRACE_ENQUEUES\",\n-            \"TRACE_CALLS\",\n-            \"SHOW_WHY\",\n-            \"SHOW_STATE\",\n-    };\n-\n-    public static OpenCLConfig of() {\n-        if (System.getenv(\"HAT\") instanceof String opts){\n-            System.out.println(\"From env \"+opts);\n-            return of(opts);\n-        }\n-        if (System.getProperty(\"HAT\") instanceof String opts) {\n-            System.out.println(\"From prop \"+opts);\n-            return of(opts);\n-        }\n-        return of(\"\");\n-    }\n-\n-    public static OpenCLConfig of(int bits) {\n-        return new OpenCLConfig(bits);\n-    }\n-\n-    public static OpenCLConfig of(List<OpenCLConfig> configs) {\n-        int allBits = 0;\n-        for (OpenCLConfig config : configs) {\n-            allBits |= config.bits;\n-        }\n-        return new OpenCLConfig(allBits);\n-    }\n-\n-    public static OpenCLConfig of(OpenCLConfig... configs) {\n-        return of(List.of(configs));\n-    }\n-\n-    public OpenCLConfig and(OpenCLConfig... configs) {\n-        return OpenCLConfig.of(OpenCLConfig.of(List.of(configs)).bits & bits);\n-    }\n-\n-    public OpenCLConfig or(OpenCLConfig... configs) {\n-        return OpenCLConfig.of(OpenCLConfig.of(List.of(configs)).bits | bits);\n-    }\n-\n-    public static OpenCLConfig of(String name) {\n-        if (name == null || name.equals(\"\")){\n-            return OpenCLConfig.of(0);\n-        }\n-        for (int i = 0; i < bitNames.length; i++) {\n-            if (bitNames[i].equals(name)) {\n-                return new OpenCLConfig(1 << (i + START_BIT_IDX));\n-            }\n-        }\n-        if (name.contains(\",\")) {\n-            List<OpenCLConfig> configs = new ArrayList<>();\n-            Arrays.stream(name.split(\",\")).forEach(opt ->\n-                    configs.add(of(opt))\n-            );\n-            return of(configs);\n-        }else if (name.contains(\":\")){\n-            var tokens=name.split(\":\");\n-            if (tokens.length == 2) {\n-                var token = tokens[0];\n-                if (token.equals(\"PLATFORM\") || token.equals(\"DEVICE\")) {\n-                    int value = Integer.parseInt(tokens[1]);\n-                    return new OpenCLConfig(value<<(token.equals(\"DEVICE\")?4:0));\n-                }else{\n-                    System.out.println(\"Unexpected opt '\" + name + \"'\");\n-                    return OpenCLConfig.of(0);\n-                }\n-            }else{\n-                System.out.println(\"Unexpected opt '\" + name + \"'\");\n-                return OpenCLConfig.of(0);\n-            }\n-        } else {\n-            System.out.println(\"Unexpected opt '\" + name + \"'\");\n-            System.exit(1);\n-            return OpenCLConfig.of(0);\n-        }\n-    }\n-    public static OpenCLConfig SHOW_STATE() {\n-        return new OpenCLConfig(SHOW_STATE_BIT);\n-    }\n-\n-    public boolean isSHOW_STATE() {\n-        return (bits & SHOW_STATE_BIT) == SHOW_STATE_BIT;\n-    }\n-    public static OpenCLConfig SHOW_WHY() {\n-        return new OpenCLConfig(SHOW_WHY_BIT);\n-    }\n-\n-    public boolean isSHOW_WHY() {\n-        return (bits & SHOW_WHY_BIT) == SHOW_WHY_BIT;\n-    }\n-\n-    public static OpenCLConfig TRACE_COPIES() {\n-        return new OpenCLConfig(TRACE_COPIES_BIT);\n-    }\n-\n-    public boolean isTRACE_COPIES() {\n-        return (bits & TRACE_COPIES_BIT) == TRACE_COPIES_BIT;\n-    }\n-\n-    public static OpenCLConfig TRACE_CALLS() {\n-        return new OpenCLConfig(TRACE_CALLS_BIT);\n-    }\n-\n-    public boolean isTRACE_CALLS() {\n-        return (bits & TRACE_CALLS_BIT) == TRACE_CALLS_BIT;\n-    }\n-\n-    public static OpenCLConfig TRACE_ENQUEUES() {\n-        return new OpenCLConfig(TRACE_ENQUEUES_BIT);\n-    }\n-\n-    public boolean isTRACE_ENQUEUES() {\n-        return (bits & TRACE_ENQUEUES_BIT) == TRACE_ENQUEUES_BIT;\n-    }\n-\n-\n-    public static OpenCLConfig TRACE_SKIPPED_COPIES() {\n-        return new OpenCLConfig(TRACE_SKIPPED_COPIES_BIT);\n-    }\n-\n-    public boolean isTRACE_SKIPPED_COPIES() {\n-        return (bits & TRACE_SKIPPED_COPIES_BIT) == TRACE_SKIPPED_COPIES_BIT;\n-    }\n-\n-    public static OpenCLConfig INFO() {\n-        return new OpenCLConfig(INFO_BIT);\n-    }\n-\n-    public boolean isINFO() {\n-        return (bits & INFO_BIT) == INFO_BIT;\n-    }\n-\n-\n-    public static OpenCLConfig PROFILE() {\n-        return new OpenCLConfig(PROFILE_BIT);\n-    }\n-\n-    public boolean isPROFILE() {\n-        return (bits & PROFILE_BIT) == PROFILE_BIT;\n-    }\n-\n-    public static OpenCLConfig TRACE() {\n-        return new OpenCLConfig(TRACE_BIT);\n-    }\n-\n-    public boolean isTRACE() {\n-        return (bits & TRACE_BIT) == TRACE_BIT;\n-    }\n-\n-    public static OpenCLConfig MINIMIZE_COPIES() {\n-        return new OpenCLConfig(MINIMIZE_COPIES_BIT);\n-    }\n-\n-    public boolean isMINIMIZE_COPIES() {\n-        return (bits & MINIMIZE_COPIES_BIT) == MINIMIZE_COPIES_BIT;\n-    }\n-\n-    public static OpenCLConfig SHOW_CODE() {\n-        return new OpenCLConfig(SHOW_CODE_BIT);\n-    }\n-\n-    public boolean isSHOW_CODE() {\n-        return (bits & SHOW_CODE_BIT) == SHOW_CODE_BIT;\n-    }\n-\n-    public static OpenCLConfig SHOW_KERNEL_MODEL() {\n-        return new OpenCLConfig(SHOW_KERNEL_MODEL_BIT);\n-    }\n-\n-    public boolean isSHOW_KERNEL_MODEL() {\n-        return (bits & SHOW_KERNEL_MODEL_BIT) == SHOW_KERNEL_MODEL_BIT;\n-    }\n-\n-    public static OpenCLConfig SHOW_COMPUTE_MODEL() {\n-        return new OpenCLConfig(SHOW_COMPUTE_MODEL_BIT);\n-    }\n-\n-    public boolean isSHOW_COMPUTE_MODEL() {\n-        return (bits & SHOW_COMPUTE_MODEL_BIT) == SHOW_COMPUTE_MODEL_BIT;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder();\n-        for (int bitIdx = START_BIT_IDX; bitIdx < END_BIT_IDX; bitIdx++) {\n-            if ((bits & (1 << bitIdx)) == (1 << bitIdx)) {\n-                if (!builder.isEmpty()) {\n-                    builder.append(\"|\");\n-                }\n-                builder.append(bitNames[bitIdx - START_BIT_IDX]);\n-\n-            }\n-        }\n-        return builder.toString();\n-    }\n-}\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLConfig.java","additions":0,"deletions":237,"binary":false,"changes":237,"status":"deleted"},{"patch":"@@ -44,4 +44,4 @@\n-    final FFILib.LongIntMethodPtr getBackend_MPtr;\n-    public long getBackend(int mode) {\n-          return  backendBridge.handle = getBackend_MPtr.invoke(mode);\n-    }\n+    \/\/final FFILib.LongIntMethodPtr getBackend_MPtr;\n+    \/\/public long getBackend(int mode) {\n+      \/\/    return  backendBridge.handle = getBackend_MPtr.invoke(mode);\n+   \/\/ }\n@@ -57,1 +57,1 @@\n-        super(\"ptx_backend\");\n+        super(\"ptx_backend\", Config.of(0));\n@@ -65,2 +65,2 @@\n-        getBackend_MPtr  =  ffiLib.longIntFunc(\"getPtxBackend\");\n-        getBackend(0);\n+     \/\/   getBackend_MPtr  =  ffiLib.longIntFunc(\"getPtxBackend\");\n+      \/\/  getBackend(0);\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXBackend.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    auto compilationUnitHandle = backend->compile(len, source);\n+    long compilationUnitHandle = reinterpret_cast<long>(backend->compile(len, source));\n@@ -146,1 +146,1 @@\n-    return compilationUnit->getKernel(nameLen, name);\n+    return reinterpret_cast<long>(compilationUnit->getKernel(nameLen, name));\n@@ -239,0 +239,61 @@\n+Text::Text(size_t len, char *text, bool isCopy)\n+        : len(len), text(text), isCopy(isCopy) {\n+    std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n+}\n+Text::Text(char *text, bool isCopy)\n+        : len(std::strlen(text)), text(text), isCopy(isCopy) {\n+    std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n+}\n+Text::Text(size_t len)\n+        : len(len), text(len > 0 ? new char[len] : nullptr), isCopy(true) {\n+    std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n+}\n+void Text::write(std::string &filename) const{\n+    std::ofstream out;\n+    out.open(filename, std::ofstream::trunc);\n+    out.write(text, len);\n+    out.close();\n+}\n+void Text::read(std::string &filename){\n+    if (isCopy && text){\n+        delete[] text;\n+    }\n+    text = nullptr;\n+    isCopy=false;\n+    \/\/ std::cout << \"reading from \" << filename << std::endl;\n+\n+    std::ifstream ptxStream;\n+    ptxStream.open(filename);\n+\n+\n+    ptxStream.seekg(0, std::ios::end);\n+    len = ptxStream.tellg();\n+    ptxStream.seekg(0, std::ios::beg);\n+\n+    if (len > 0) {\n+        text = new char[len];\n+        isCopy = true;\n+        \/\/std::cerr << \"about to read  \" << len << std::endl;\n+        ptxStream.read(text, len);\n+        ptxStream.close();\n+        \/\/std::cerr << \"read  \" << len << std::endl;\n+        text[len - 1] = '\\0';\n+        \/\/std::cerr << \"read text \" << text << std::endl;\n+    }\n+}\n+\n+Text::~Text(){\n+    if (isCopy && text){\n+        delete[] text;\n+    }\n+    text = nullptr;\n+    isCopy = false;\n+    len = 0;\n+}\n+\n+Log::Log(size_t len)\n+        : Text(len) {\n+}\n+Log::Log(char *text)\n+        : Text(text, false) {\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/shared\/cpp\/shared.cpp","additions":63,"deletions":2,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -69,0 +69,20 @@\n+class Text {\n+public:\n+    size_t len;\n+    char *text;\n+    bool isCopy;\n+\n+    Text(size_t len, char *text, bool isCopy);\n+    Text(char *text, bool isCopy);\n+    Text(size_t len);\n+    void write(std::string &filename) const;\n+    void read(std::string &filename);\n+    virtual ~Text();\n+};\n+\n+class Log:public Text  {\n+public:\n+    Log(size_t len);\n+    Log(char* text);\n+    ~Log()  = default;\n+};\n@@ -422,1 +442,1 @@\n-        virtual long getKernel(int nameLen, char *name) = 0;\n+        virtual Kernel *getKernel(int nameLen, char *name) = 0;\n@@ -451,1 +471,1 @@\n-    virtual long compile(int len, char *source) = 0;\n+    virtual CompilationUnit * compile(int len, char *source) = 0;\n@@ -476,0 +496,15 @@\n+\n+template<typename T>\n+T *bufferOf(const char*name){\n+    size_t lenIncludingBufferState = sizeof(T);\n+    size_t lenExcludingBufferState = lenIncludingBufferState - sizeof(BufferState_s);\n+    T *buffer = (T*)new unsigned char[lenIncludingBufferState];\n+    BufferState_s *bufferState = (BufferState_s*)((char*)buffer+lenExcludingBufferState);\n+    bufferState->magic1 = bufferState->magic2 = BufferState_s::MAGIC;\n+    bufferState->ptr = buffer;\n+    bufferState->length= sizeof(T) - sizeof(BufferState_s);\n+    bufferState->state=BufferState_s::NEW_STATE;\n+    bufferState->vendorPtr = nullptr;\n+    bufferState->dump(name);\n+    return buffer;\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    public C99FFIBackend(String libName) {\n-        super(libName);\n+    public C99FFIBackend(String libName, Config config) {\n+        super(libName, config);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,26 @@\n-package hat.backend.ffi;\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ package hat.backend.ffi;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/Config.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -65,2 +65,2 @@\n-    public FFIBackend(String libName) {\n-        super(libName);\n+    public FFIBackend(String libName, Config config) {\n+        super(libName, config);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-\n+protected final Config config;\n@@ -56,1 +56,1 @@\n-                final FFILib.LongLongAddressMethodPtr ndrange_MPtr;\n+                final FFILib.LongHandleLongAddressMethodPtr ndrange_MPtr;\n@@ -61,1 +61,1 @@\n-                    this.ndrange_MPtr = compilationUnitBridge.backendBridge.ffiLib.longLongAddressFunc(\"ndrange\");\n+                    this.ndrange_MPtr = compilationUnitBridge.backendBridge.ffiLib.longHandleLongAddressFunc(\"ndrange\");\n@@ -92,3 +92,0 @@\n-\n-\n-\n@@ -111,2 +108,0 @@\n-\n-\n@@ -118,2 +113,2 @@\n-        FFILib ffiLib;\n-        long handle;\n+        final FFILib ffiLib;\n+        final long handle;\n@@ -121,1 +116,2 @@\n-        Map<Long, CompilationUnitBridge> compilationUnits = new HashMap<>();\n+        final Map<Long, CompilationUnitBridge> compilationUnits = new HashMap<>();\n+        final FFILib.LongHandleIntMethodPtr getBackend_MPtr;\n@@ -126,0 +122,6 @@\n+\/*\n+  final FFILib.LongIntMethodPtr getBackend_MPtr;\n+    getBackend_MPtr = ffiLib.longIntFunc(\"getBackend\");\n+    public long getBackend(int configBits) {\n+        return backendBridge.handle = getBackend_MPtr.invoke(configBits);\n+    }\n@@ -127,0 +129,1 @@\n+ *\/\n@@ -129,1 +132,1 @@\n-        BackendBridge(FFILib ffiLib) {\n+        BackendBridge(FFILib ffiLib, Config config) {\n@@ -131,0 +134,5 @@\n+            this.getBackend_MPtr = ffiLib.longHandleIntFunc(\"getBackend\");\n+            if (this.getBackend_MPtr.mh == null) {\n+                throw new RuntimeException(\"No getBackend()\");\n+            }\n+            this.handle = getBackend(config.bits());\n@@ -144,0 +152,4 @@\n+        public long getBackend(int configBits) {\n+            return getBackend_MPtr.invoke(configBits);\n+        }\n+\n@@ -189,1 +201,1 @@\n-    public FFIBackendDriver(String libName) {\n+    public FFIBackendDriver(String libName, Config config) {\n@@ -191,1 +203,2 @@\n-        this.backendBridge = new BackendBridge(ffiLib);\n+        this.config = config;\n+        this.backendBridge = new BackendBridge(ffiLib, config);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackendDriver.java","additions":27,"deletions":14,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -158,2 +158,2 @@\n-    public static class LongIntMethodPtr extends MethodPtr{\n-        LongIntMethodPtr(FFILib ffiLib, String name) {\n+    public static class LongHandleIntMethodPtr extends MethodPtr{\n+        LongHandleIntMethodPtr(FFILib ffiLib, String name) {\n@@ -164,1 +164,1 @@\n-                throw new RuntimeException(\"Null methodhandle \"+name);\n+                throw new RuntimeException(\"Null method handle trying to invoke \"+ffiLib.name+\"::\"+name+\"()\");\n@@ -174,2 +174,2 @@\n-    public static class LongLongAddressMethodPtr extends MethodPtr{\n-        LongLongAddressMethodPtr(FFILib ffiLib, String name) {\n+    public static class LongHandleLongAddressMethodPtr extends MethodPtr{\n+        LongHandleLongAddressMethodPtr(FFILib ffiLib, String name) {\n@@ -221,2 +221,2 @@\n-    public LongIntMethodPtr longIntFunc(String name) {\n-        return new LongIntMethodPtr(this, name);\n+    public LongHandleIntMethodPtr longHandleIntFunc(String name) {\n+        return new LongHandleIntMethodPtr(this, name);\n@@ -224,2 +224,2 @@\n-    public LongLongAddressMethodPtr longLongAddressFunc(String name) {\n-        return new LongLongAddressMethodPtr(this, name);\n+    public LongHandleLongAddressMethodPtr longHandleLongAddressFunc(String name) {\n+        return new LongHandleLongAddressMethodPtr(this, name);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFILib.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-            long ndrange(void *argArray) {\n+            long ndrange(void *argArray) override {\n@@ -53,2 +53,2 @@\n-        long getKernel(int nameLen, char *name) {\n-            return (long) new SpirvKernel(this, name);\n+        Kernel *getKernel(int nameLen, char *name) {\n+            return new SpirvKernel(this, name);\n@@ -68,7 +68,3 @@\n-bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) {\n-    std::cout << \"attempting  to get buffer from SpirvBackend \"<<std::endl;\n-    return false;\n-}\n-    int getMaxComputeUnits() {\n-        std::cout << \"spirv getMaxComputeUnits()\" << std::endl;\n-        return 0;\n+    bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) override {\n+        std::cout << \"attempting  to get buffer from SpirvBackend \"<<std::endl;\n+        return false;\n@@ -76,2 +72,1 @@\n-\n-    void info() {\n+    void info() override{\n@@ -80,1 +75,1 @@\n-     void computeStart(){\n+     void computeStart() override{\n@@ -83,1 +78,1 @@\n-        void computeEnd(){\n+        void computeEnd() override {\n@@ -87,1 +82,1 @@\n-    long compile(int len, char *source) {\n+    CompilationUnit* compile(int len, char *source) override{\n@@ -96,1 +91,1 @@\n-        return (long)spirvProgram;\n+        return dynamic_cast<CompilationUnit*>(spirvProgram);\n@@ -100,2 +95,2 @@\n-long getSpirvBackend(int mode) {\n-    return (long) new SpirvBackend(mode);\n+long getBackend(int mode) {\n+    return reinterpret_cast<long>(new SpirvBackend(mode));\n","filename":"hat\/backends\/ffi\/spirv\/cpp\/spirv_backend.cpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_shared\" \/>\n@@ -17,1 +18,1 @@\n-<\/module>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/experiments.iml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}