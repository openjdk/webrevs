{"files":[{"patch":"@@ -41,1 +41,0 @@\n-       useState((configBits&USE_STATE_BIT)==USE_STATE_BIT),\n@@ -58,2 +57,1 @@\n-           std::cout << \"native useState \" << useState<<std::endl;\n-            std::cout << \"native showState \" << showState<<std::endl;\n+          std::cout << \"native showState \" << showState<<std::endl;\n@@ -97,3 +95,1 @@\n-\n-   if (openclBackend->openclConfig.useState){\n-     bool isAlwaysCopyingOrNewStateOrHostOwned =\n+   bool isAlwaysCopyingOrNewStateOrHostOwned =\n@@ -102,2 +98,2 @@\n-         || ((bufferState->state == BufferState_s::HOST_OWNED));\n-     if (openclBackend->openclConfig.showWhy){\n+        || ((bufferState->state == BufferState_s::HOST_OWNED));\n+   if (openclBackend->openclConfig.showWhy){\n@@ -114,22 +110,0 @@\n-   }else{\n-     bool isHostDirtyOrNew = bufferState->isHostDirty() | bufferState->isHostNew();\n-\n-      if (openclBackend->openclConfig.showWhy){\n-        std::cout<<\n-          \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n-          << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n-          << \" | arg.RO=\"<<(arg->value.buffer.access==RO_BYTE)\n-          << \" | kernel.needsToRead=\"<<  kernelReadsFromThisArg\n-          << \" | buffer.hostDirty=\"<< bufferState->isHostDirty()\n-          << \" | buffer.hostNew=\"<< bufferState->isHostNew()\n-          << \" | buffer.deviceDirty=\"<< bufferState->isDeviceDirty()\n-          <<\" so \"\n-            ;\n-      }\n-\n-     bool result=  (kernelReadsFromThisArg & isHostDirtyOrNew);\n-     if (result && bufferState->isDeviceDirty()){\n-       result= false;\n-     }\n-     return openclBackend->openclConfig.alwaysCopy |result;\n-   }\n@@ -140,1 +114,0 @@\n-    if (openclBackend->openclConfig.useState){\n@@ -151,14 +124,0 @@\n-    }else{\n-\n-       if (openclBackend->openclConfig.showWhy){\n-         std::cout<<\n-            \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n-            << \" | arg.WO=\"<<(arg->value.buffer.access==WO_BYTE)\n-            << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n-            << \" | kernel.wroteToThisArg=\"<<  kernelWroteToThisArg\n-            <<\" so \" ;\n-       }\n-       return openclBackend->openclConfig.alwaysCopy;\n-    }\n-\n-\n@@ -219,3 +178,0 @@\n-\n-\n-\n@@ -273,3 +229,1 @@\n-       if (   (openclConfig.useState && (bufferState->state == BufferState_s::DEVICE_OWNED))\n-           || (!openclConfig.useState && bufferState->isDeviceDirty())){\n-\n+       if (bufferState->state == BufferState_s::DEVICE_OWNED){\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":5,"deletions":51,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -88,0 +88,5 @@\n+               if (bufferState->ptr != arg->value.buffer.memorySegment){\n+                   std::cerr <<\"bufferState->ptr !=  arg->value.buffer.memorySegment\"<<std::endl;\n+                   std::exit(1);\n+               }\n+\n@@ -89,2 +94,1 @@\n-               if ((openclBackend->openclConfig.useState && (bufferState->state == BufferState_s::NEW_STATE))\n-                || (!openclBackend->openclConfig.useState && bufferState->isHostNew())){\n+               if (bufferState->state == BufferState_s::NEW_STATE){\n@@ -103,6 +107,0 @@\n-                   if (openclBackend->openclConfig.useState){\n-                   }else{\n-                       bufferState->clearHostNew();\n-                       bufferState->clearHostDirty();\n-                   }\n-\n@@ -110,1 +108,1 @@\n-                       std::cout << \"NOT copying arg \" << arg->idx <<\" to device \"<< std::endl;\n+                    std::cout << \"NOT copying arg \" << arg->idx <<\" to device \"<< std::endl;\n@@ -184,9 +182,1 @@\n-\n-\n-    if (openclBackend->openclConfig.useState){\n-     \/\/ std::cout << \"setting device dirty\"<<std::endl;\n-       bufferState->state = BufferState_s::HOST_OWNED;\n-    }else{\n-       bufferState->clearDeviceDirty();\n-\n-    }\n+                bufferState->state = BufferState_s::HOST_OWNED;\n@@ -197,8 +187,1 @@\n-                    if (openclBackend->openclConfig.useState){\n-                      \/\/ std::cout << \"setting device dirty\"<<std::endl;\n-                        bufferState->state = BufferState_s::DEVICE_OWNED;\n-                     }else{\n-                        bufferState->setDeviceDirty();\n-                        bufferState->clearDeviceDirty();\n-\n-                     }\n+                 bufferState->state = BufferState_s::DEVICE_OWNED;\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_kernel_dispatch.cpp","additions":9,"deletions":26,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -64,3 +64,2 @@\n-        const static  int USE_STATE_BIT = 1 <<28;\n-        const static  int SHOW_STATE_BIT = 1 <<29;\n-        const static  int END_BIT_IDX = 30;\n+        const static  int SHOW_STATE_BIT = 1 <<28;\n+        const static  int END_BIT_IDX = 29;\n@@ -81,1 +80,0 @@\n-        bool useState;\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+\n@@ -52,0 +53,1 @@\n+\n@@ -55,0 +57,1 @@\n+\n@@ -58,4 +61,4 @@\n-        getBackend_MH  =  nativeLibrary.longFunc(\"getOpenCLBackend\",JAVA_INT);\n-        getBackend(config.bits());\n-        if (config.isINFO()) {\n-            System.out.println(\"CONFIG = \"+config);\n+        getBackend_MH = nativeLibrary.longFunc(\"getOpenCLBackend\", JAVA_INT);\n+        getBackend(this.config.bits());\n+        if (this.config.isINFO()) {\n+            System.out.println(\"CONFIG = \" + this.config);\n@@ -74,1 +77,1 @@\n-       \/\/ System.out.println(\"OpenCL backend received computeContext minimizing = \"+ config.isMINIMIZE_COPIES());\n+        \/\/ System.out.println(\"OpenCL backend received computeContext minimizing = \"+ config.isMINIMIZE_COPIES());\n@@ -94,1 +97,1 @@\n-        compiledKernel.dispatch(ndRange,args);\n+        compiledKernel.dispatch(ndRange, args);\n@@ -100,28 +103,7 @@\n-\n-        if (!config.isMINIMIZE_COPIES()) {\n-            throw new IllegalStateException(\"why is premutate being called if we are not minimizing buffer copies\");\n-            \/\/System.exit(1);\n-        }\n-        if (config.isUSE_STATE() ) {\n-\n-            switch (b.getState()){\n-                case BufferState.NO_STATE:\n-                case BufferState.NEW_STATE :\n-                case BufferState.HOST_OWNED :\n-                case BufferState.DEVICE_VALID_HOST_HAS_COPY:{\n-                    if (config.isSHOW_STATE()) {\n-                        System.out.println(\"in preMutate state = \" + b.getStateString() + \" no action to take\");\n-                    }\n-                break;\n-                }\n-                case BufferState.DEVICE_OWNED:{\n-                    getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n-\n-                    if (config.isSHOW_STATE()) {\n-                        System.out.print(\"in preMutate state = \" + b.getStateString() + \" we pulled from device \");\n-                    }\n-                    b.setState(BufferState.DEVICE_VALID_HOST_HAS_COPY);\n-                    if (config.isSHOW_STATE()) {\n-                        System.out.println(\"and switched to \" + b.getStateString());\n-                    }\n-                    break;\n+        switch (b.getState()) {\n+            case BufferState.NO_STATE:\n+            case BufferState.NEW_STATE:\n+            case BufferState.HOST_OWNED:\n+            case BufferState.DEVICE_VALID_HOST_HAS_COPY: {\n+                if (config.isSHOW_STATE()) {\n+                    System.out.println(\"in preMutate state = \" + b.getStateString() + \" no action to take\");\n@@ -129,2 +111,1 @@\n-                default:\n-                    throw new IllegalStateException(\"Not expecting this state \");\n+                break;\n@@ -132,5 +113,8 @@\n-        }else {\n-            if (b.isDeviceDirty()) {\n-                if (!b.isHostChecked()) {\n-                    getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n-                    b.setHostChecked();\n+            case BufferState.DEVICE_OWNED: {\n+                getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n+                if (config.isSHOW_STATE()) {\n+                    System.out.print(\"in preMutate state = \" + b.getStateString() + \" we pulled from device \");\n+                }\n+                b.setState(BufferState.DEVICE_VALID_HOST_HAS_COPY);\n+                if (config.isSHOW_STATE()) {\n+                    System.out.println(\"and switched to \" + b.getStateString());\n@@ -138,1 +122,1 @@\n-                b.clearDeviceDirty();\n+                break;\n@@ -140,0 +124,2 @@\n+            default:\n+                throw new IllegalStateException(\"Not expecting this state \");\n@@ -141,1 +127,0 @@\n-\n@@ -146,2 +131,2 @@\n-        if (!config.isMINIMIZE_COPIES()) {\n-            throw new IllegalStateException(\"why is postmutate being called if we are not minimizing buffer copies\");\n+        if (config.isSHOW_STATE()) {\n+            System.out.print(\"in postMutate state = \" + b.getStateString() + \" no action to take \");\n@@ -149,10 +134,3 @@\n-        if (config.isUSE_STATE()) {\n-            if (config.isSHOW_STATE()) {\n-                System.out.print(\"in postMutate state = \" + b.getStateString() + \" no action to take \");\n-            }\n-            b.setState(BufferState.HOST_OWNED);\n-            if (config.isSHOW_STATE()) {\n-                System.out.println(\"and switched to (or stayed on) \" + b.getStateString());\n-            }\n-        }else {\n-            b.setHostDirty();\n+        b.setState(BufferState.HOST_OWNED);\n+        if (config.isSHOW_STATE()) {\n+            System.out.println(\"and switched to (or stayed on) \" + b.getStateString());\n@@ -160,1 +138,0 @@\n-\n@@ -165,14 +142,7 @@\n-        if (!config.isMINIMIZE_COPIES()) {\n-            throw new IllegalStateException(\"why is pre access being called if we are not minimizing buffer copies\");\n-        }\n-        if (config.isUSE_STATE() ) {\n-\n-            switch (b.getState()){\n-                case BufferState.NO_STATE:\n-                case BufferState.NEW_STATE :\n-                case BufferState.HOST_OWNED :\n-                case BufferState.DEVICE_VALID_HOST_HAS_COPY:{\n-                    if (config.isSHOW_STATE()) {\n-                        System.out.println(\"in preAccess state = \" + b.getStateString() + \" no action to take\");\n-                    }\n-                    break;\n+        switch (b.getState()) {\n+            case BufferState.NO_STATE:\n+            case BufferState.NEW_STATE:\n+            case BufferState.HOST_OWNED:\n+            case BufferState.DEVICE_VALID_HOST_HAS_COPY: {\n+                if (config.isSHOW_STATE()) {\n+                    System.out.println(\"in preAccess state = \" + b.getStateString() + \" no action to take\");\n@@ -180,2 +150,4 @@\n-                case BufferState.DEVICE_OWNED:{\n-                    getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n+                break;\n+            }\n+            case BufferState.DEVICE_OWNED: {\n+                getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n@@ -183,8 +155,2 @@\n-                    if (config.isSHOW_STATE()) {\n-                        System.out.print(\"in preAccess state = \" + b.getStateString() + \" we pulled from device \");\n-                    }\n-                    b.setState(BufferState.DEVICE_VALID_HOST_HAS_COPY);\n-                    if (config.isSHOW_STATE()) {\n-                        System.out.println(\"and switched to \" + b.getStateString());\n-                    }\n-                    break;\n+                if (config.isSHOW_STATE()) {\n+                    System.out.print(\"in preAccess state = \" + b.getStateString() + \" we pulled from device \");\n@@ -192,9 +158,5 @@\n-                default:\n-                    throw new IllegalStateException(\"Not expecting this state \");\n-            }\n-        }else {\n-            if (b.isDeviceDirty() && !b.isHostChecked()) {\n-                getBufferFromDeviceIfDirty(b); \/\/ calls through FFI and might block when fetching from device\n-                \/\/ We don't call clearDeviceDirty() if we did then 'just reading on the host' would force copy in next dispatch\n-                \/\/so buffer is still considered deviceDirty\n-                b.setHostChecked();\n+                b.setState(BufferState.DEVICE_VALID_HOST_HAS_COPY);\n+                if (config.isSHOW_STATE()) {\n+                    System.out.println(\"and switched to \" + b.getStateString());\n+                }\n+                break;\n@@ -202,0 +164,2 @@\n+            default:\n+                throw new IllegalStateException(\"Not expecting this state \");\n@@ -208,4 +172,1 @@\n-        if (!config.isMINIMIZE_COPIES()) {\n-            throw new IllegalStateException(\"why is postaccess being called if we are not minimizing buffer copies\");\n-        }\n-        if (config.isUSE_STATE() && config.isSHOW_STATE()) {\n+        if (config.isSHOW_STATE()) {\n@@ -214,1 +175,0 @@\n-       \/\/ a no op buffer may well still be deviceDirty\n@@ -219,26 +179,7 @@\n-        if (!config.isMINIMIZE_COPIES()) {\n-            throw new IllegalStateException(\"why is preEscape being called if we are not minimizing buffer copies\");\n-        }\n-        if (config.isUSE_STATE() ) {\n-\n-            switch (b.getState()){\n-                case BufferState.NO_STATE:\n-                case BufferState.NEW_STATE :\n-                case BufferState.HOST_OWNED :\n-                case BufferState.DEVICE_VALID_HOST_HAS_COPY:{\n-                    if (config.isSHOW_STATE()) {\n-                        System.out.println(\"in preEscape state = \" + b.getStateString() + \" no action to take\");\n-                    }\n-                    break;\n-                }\n-                case BufferState.DEVICE_OWNED:{\n-                    getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n-\n-                    if (config.isSHOW_STATE()) {\n-                        System.out.print(\"in preEscape state = \" + b.getStateString() + \" we pulled from device \");\n-                    }\n-                    b.setState(BufferState.DEVICE_VALID_HOST_HAS_COPY);\n-                    if (config.isSHOW_STATE()) {\n-                        System.out.println(\"and switched to \" + b.getStateString());\n-                    }\n-                    break;\n+        switch (b.getState()) {\n+            case BufferState.NO_STATE:\n+            case BufferState.NEW_STATE:\n+            case BufferState.HOST_OWNED:\n+            case BufferState.DEVICE_VALID_HOST_HAS_COPY: {\n+                if (config.isSHOW_STATE()) {\n+                    System.out.println(\"in preEscape state = \" + b.getStateString() + \" no action to take\");\n@@ -246,2 +187,1 @@\n-                default:\n-                    throw new IllegalStateException(\"Not expecting this state \");\n+                break;\n@@ -249,5 +189,8 @@\n-        }else {\n-            if (b.isDeviceDirty()) {\n-                if (!b.isHostChecked()) {\n-                    getBufferFromDeviceIfDirty(b);\n-                    b.setHostChecked();\n+            case BufferState.DEVICE_OWNED: {\n+                getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n+                if (config.isSHOW_STATE()) {\n+                    System.out.print(\"in preEscape state = \" + b.getStateString() + \" we pulled from device \");\n+                }\n+                b.setState(BufferState.DEVICE_VALID_HOST_HAS_COPY);\n+                if (config.isSHOW_STATE()) {\n+                    System.out.println(\"and switched to \" + b.getStateString());\n@@ -255,1 +198,1 @@\n-                \/\/ b.clearDeviceDirty();\n+                break;\n@@ -257,0 +200,2 @@\n+            default:\n+                throw new IllegalStateException(\"Not expecting this state \");\n@@ -263,2 +208,6 @@\n-        if (!config.isMINIMIZE_COPIES()) {\n-            throw new IllegalStateException(\"why is postEscape being called if we are not minimizing buffer copies\");\n+        if (config.isSHOW_STATE()) {\n+            System.out.print(\"in postEscape state = \" + b.getStateString() + \" we pulled from device \");\n+        }\n+        b.setState(BufferState.HOST_OWNED);\n+        if (config.isSHOW_STATE()) {\n+            System.out.println(\"and switched to \" + b.getStateString());\n@@ -266,15 +215,0 @@\n-        if (config.isUSE_STATE() ) {\n-\n-                    if (config.isSHOW_STATE()) {\n-                        System.out.print(\"in postEscape state = \" + b.getStateString() + \" we pulled from device \");\n-                    }\n-                    b.setState(BufferState.HOST_OWNED);\n-                    if (config.isSHOW_STATE()) {\n-                        System.out.println(\"and switched to \" + b.getStateString());\n-                    }\n-\n-        }else {\n-\n-            b.setHostDirty();\n-        }\/\/ We have no choice but to assume escapee was modified by the call\n-\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":79,"deletions":145,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n-    private static final int USE_STATE_BIT = 1 << 28;\n-    private static final int SHOW_STATE_BIT = 1 << 29;\n-    private static final int END_BIT_IDX = 28;\n+    private static final int SHOW_STATE_BIT = 1 << 28;\n+    private static final int END_BIT_IDX = 29;\n@@ -44,1 +43,0 @@\n-            \"USE_STATE\",\n@@ -95,1 +93,2 @@\n-                if (tokens[0].equals(\"PLATFORM\")) {\n+                var token = tokens[0];\n+                if (token.equals(\"PLATFORM\") || token.equals(\"DEVICE\")) {\n@@ -97,4 +96,1 @@\n-                    return new OpenCLConfig(value);\n-                }else  if (tokens[0].equals(\"DEVICE\")) {\n-                    int value = Integer.parseInt(tokens[1]);\n-                    return new OpenCLConfig(value<<4);\n+                    return new OpenCLConfig(value<<(token.equals(\"DEVICE\")?4:0));\n@@ -111,0 +107,1 @@\n+            System.exit(1);\n@@ -114,7 +111,0 @@\n-    public static OpenCLConfig USE_STATE() {\n-        return new OpenCLConfig(USE_STATE_BIT);\n-    }\n-\n-    public boolean isUSE_STATE() {\n-        return (bits & USE_STATE_BIT) == USE_STATE_BIT;\n-    }\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLConfig.java","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -120,8 +120,0 @@\n-   static const int   NONE = 0;\n-   static const int   BIT_HOST_NEW =1<<0;\n-   static const int   BIT_DEVICE_NEW =1<<1;\n-   static const int   BIT_HOST_DIRTY =1<<2;\n-   static const int   BIT_DEVICE_DIRTY =1<<3;\n-   static const int   BIT_HOST_CHECKED =1<<4;\n-\n-\n@@ -136,0 +128,1 @@\n+   void *ptr;\n@@ -150,58 +143,0 @@\n-   void assignBits(int bitBits) {\n-      bits=bitBits;\n-   }\n-   void setBits(int bitBits) {\n-      bits|=bitBits;\n-   }\n-   void  xorBits(int bitsToReset) {\n-      \/\/ say bits = 0b0111 (7) and bitz = 0b0100 (4)\n-      int xored = bits^bitsToReset;  \/\/ xored = 0b0011 (3)\n-      bits =  xored;\n-   }\n-    void  resetBits(int bitsToReset) {\n-         \/\/ say bits = 0b0111 (7) and bitz = 0b0100 (4)\n-         bits = bits&~bitsToReset;  \/\/ xored = 0b0011 (3)\n-         \/\/bits =  xored;\n-      }\n-   int getBits() {\n-      return bits;\n-   }\n-   bool areBitsSet(int bitBits) {\n-      return (bits&bitBits)==bitBits;\n-   }\n-   void setHostDirty(){\n-      setBits(BIT_HOST_DIRTY);\n-   }\n-   bool isHostDirty(){\n-      return  areBitsSet(BIT_HOST_DIRTY);\n-   }\n-   void clearHostDirty(){\n-      resetBits(BIT_HOST_DIRTY);\n-   }\n-   void clearHostChecked(){\n-      resetBits(BIT_HOST_CHECKED);\n-   }\n-   void clear(){\n-       bits=0;\n-   }\n-   bool isHostNew(){\n-      return  areBitsSet(BIT_HOST_NEW);\n-   }\n-   void clearHostNew(){\n-      resetBits(BIT_HOST_NEW);\n-   }\n-   bool isHostNewOrDirty() {\n-      return areBitsSet(BIT_HOST_NEW|BIT_HOST_DIRTY);\n-   }\n-\n-   void setDeviceDirty(){\n-      setBits(BIT_DEVICE_DIRTY);\n-   }\n-\n-   bool isDeviceDirty(){\n-      return areBitsSet(BIT_DEVICE_DIRTY);\n-   }\n-   void clearDeviceDirty(){\n-      resetBits(BIT_DEVICE_DIRTY);\n-   }\n-\n@@ -211,1 +146,1 @@\n-        printf(\"{%s,length: %016lx, bits:%08x, state:%08x, vendorPtr:%016lx}\\n\", msg, length, bits, state, (long)vendorPtr);\n+        printf(\"{%s,ptr:%016lx,length: %016lx,  state:%08x, vendorPtr:%016lx}\\n\", msg, (long)ptr, length,  state, (long)vendorPtr);\n@@ -215,1 +150,1 @@\n-        printf(\"{%s, length: %016lx, bits:%08x, state:%08x, vendorPtr:%016lx}\", msg, length, bits, state, (long)vendorPtr);\n+        printf(\"{%s, ptr:%016lx, length: %016lx,  state:%08x, vendorPtr:%016lx}\", msg, (long)ptr, length,  state, (long)vendorPtr);\n@@ -366,4 +301,0 @@\n-\n-\/\/extern \"C\" void dumpArgArray(void *ptr);\n-\n-\n@@ -451,2 +382,1 @@\n-    Backend(int mode)\n-            : mode(mode){}\n+    Backend(int mode): mode(mode){}\n@@ -456,2 +386,3 @@\n-     virtual void computeStart() = 0;\n-      virtual void computeEnd() = 0;\n+    virtual void computeStart() = 0;\n+\n+    virtual void computeEnd() = 0;\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":7,"deletions":76,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.backend.ffi.OpenCLBackend;\n@@ -241,2 +242,4 @@\n-                    bufferState.setHostDirty(!viewer.state.minimizingCopies || (viewer.state.generations == 0)); \/\/ only first\n-                    bufferState.setDeviceDirty(!viewer.state.minimizingCopies || shouldUpdateUI);\n+                    if (!viewer.state.minimizingCopies || (viewer.state.generations == 0)){\n+                        bufferState.setState(BufferState.HOST_OWNED);\n+                    }\n+                    BufferState.of(control).setState(BufferState.HOST_OWNED);\n@@ -244,0 +247,2 @@\n+\n+\n@@ -260,1 +265,1 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup());\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup());\/\/,new OpenCLBackend(\"INFO,MINIMIZE_COPIES,SHOW_COMPUTE_MODEL\"));\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -298,4 +298,0 @@\n-                \/\/ System.out.print(\" gw \"+glutGet(GLUT_SCREEN_WIDTH())+\" gh \"+glutGet(GLUT_SCREEN_HEIGHT()));\n-                \/\/ System.out.print(\" a \"+aspect+\",s \"+size);\n-                \/\/ System.out.println(\" w \"+width+\" h\"+height);\n-\n@@ -318,3 +314,1 @@\n-            BufferState.of(universe).setHostDirty(true).setDeviceDirty(true);\n-            \/\/ vel.copyToDevice = true;\n-            \/\/ pos.copyToDevice = true;\n+            BufferState.of(universe).setState(BufferState.HOST_OWNED);\n@@ -322,3 +316,1 @@\n-            BufferState.of(universe).setHostDirty(false).setDeviceDirty(true);\n-            \/\/ vel.copyToDevice = false;\n-            \/\/pos.copyToDevice = false;\n+            BufferState.of(universe).setState(BufferState.DEVICE_OWNED);\n@@ -333,11 +325,0 @@\n-        \/\/    if (frameCount == 0) {\n-              \/\/  SegmentMapper.BufferState.of(universe).setHostDirty(true).setDeviceDirty(true);\n-               \/\/ vel.copyToDevice = true;\n-               \/\/ pos.copyToDevice = true;\n-          \/\/  } else {\n-            \/\/    SegmentMapper.BufferState.of(universe).setHostDirty(false).setDeviceDirty(true);\n-               \/\/ vel.copyToDevice = false;\n-                \/\/pos.copyToDevice = false;\n-           \/\/ }\n-           \/\/ vel.copyFromDevice = false;\n-          \/\/  pos.copyFromDevice = true;\n@@ -352,9 +333,0 @@\n-   \/* public static void main(String[] args) throws IOException {\n-        int particleCount = args.length > 2 ? Integer.parseInt(args[2]) : 32768;\n-        Mode mode = Mode.of(args.length > 3 ? args[3] : Mode.OpenCL4.toString());\n-        System.out.println(\"mode\" + mode);\n-        try (var arena = mode.equals(Mode.JavaMT4) || mode.equals(Mode.JavaMT) ? Arena.ofShared() : Arena.ofConfined()) {\n-            var particleTexture = new GLTexture(arena, NBody.class.getResourceAsStream(\"\/particle.png\"));\n-            new CLNBodyGLWindow( arena, 1000, 1000, particleTexture, particleCount, mode).bindEvents().mainLoop();\n-        }\n-    } *\/\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/opencl\/OpenCLNBodyGLWindow.java","additions":2,"deletions":30,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -36,0 +37,1 @@\n+import java.lang.annotation.Annotation;\n@@ -37,0 +39,4 @@\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n@@ -44,0 +50,1 @@\n+import jdk.incubator.code.type.MethodRef;\n@@ -95,0 +102,60 @@\n+    record TypeAndAccess(Annotation[] annotations, Value value, JavaType javaType) {\n+        static TypeAndAccess of(Annotation[] annotations, Value value) {\n+            return new TypeAndAccess(annotations, value, (JavaType) value.type());\n+        }\n+        boolean isIface(MethodHandles.Lookup lookup) {\n+            return InvokeOpWrapper.isIfaceUsingLookup(lookup, javaType);\n+        }\n+        boolean ro(){\n+            for (Annotation annotation : annotations) {\n+                if (  annotation instanceof MappableIface.RO){\n+                    System.out.println(\"MappableIface.RO\");\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+        boolean rw(){\n+            for (Annotation annotation : annotations) {\n+                if (  annotation instanceof MappableIface.RW){\n+                    System.out.println(\"MappableIface.RW\");\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+        boolean wo(){\n+            for (Annotation annotation : annotations) {\n+                if (  annotation instanceof MappableIface.WO){\n+                    System.out.println(\"MappableIface.WO\");\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+\n+        record PrePost(MethodRef pre,MethodRef post) {\n+            static PrePost access() {\n+                return new PrePost(ACCESS.pre, ACCESS.post);\n+            }\n+\n+            static PrePost mutate() {\n+                return new PrePost(MUTATE.pre, MUTATE.post);\n+            }\n+\n+            static PrePost escape() {\n+                return new PrePost(ESCAPE.pre, ESCAPE.post);\n+            }\n+\n+            void apply(Block.Builder bldr, CopyContext bldrCntxt, Value computeContext, InvokeOpWrapper invokeOW) {\n+                if (invokeOW.isIfaceMutator()) {                    \/\/ iface.v(newV)\n+                    Value iface = bldrCntxt.getValue(invokeOW.operandNAsValue(0));\n+                    bldr.op(CoreOp.invoke(MUTATE.pre, computeContext, iface));  \/\/ cc->preMutate(iface);\n+                    bldr.op(invokeOW.op());                         \/\/ iface.v(newV);\n+                    bldr.op(CoreOp.invoke(MUTATE.post, computeContext, iface));\n+                }\n+            }\n+        }\n+\n@@ -120,11 +187,46 @@\n-                    invokeOW.op().operands().stream()\n-                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, javaType))\n-                            .forEach(value ->\n-                                    bldr.op(CoreOp.invoke(ESCAPE.pre, cc, bldrCntxt.getValue(value)))\n-                            );\n-                    bldr.op(invokeOW.op());\n-                    invokeOW.op().operands().stream()\n-                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup,javaType))\n-                            .forEach(value -> bldr.op(\n-                                    CoreOp.invoke(ESCAPE.post, cc, bldrCntxt.getValue(value)))\n-                            );\n+                    List<Value> list = invokeOW.op().operands();\n+                    System.out.println(\"args \"+list.size());\n+                    if (!list.isEmpty()) {\n+                        System.out.println(\"method \"+invokeOW.method());\n+                        Annotation[][] parameterAnnotations = invokeOW.method().getParameterAnnotations();\n+                        boolean isVirtual = list.size()>parameterAnnotations.length;\n+                        System.out.println(\"params length\"+parameterAnnotations.length);\n+                        List<TypeAndAccess> typeAndAccesses = new ArrayList<>();\n+\n+                            for (int i = isVirtual?1:0; i < list.size(); i++) {\n+                                typeAndAccesses.add(TypeAndAccess.of(\n+                                        parameterAnnotations[i-(isVirtual?1:0)],\n+                                        list.get(i)));\n+                            }\n+                        List<PrePost> prePosts = new ArrayList<>();\n+                        typeAndAccesses.stream()\n+                                .filter(typeAndAccess -> typeAndAccess.isIface(prevFOW.lookup))\/\/InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, typeAndAccess.javaType))\n+                                .forEach(typeAndAccess -> {\n+                                     if (typeAndAccess.ro()) {\n+                                         bldr.op(CoreOp.invoke(ACCESS.pre, cc,  bldrCntxt.getValue(typeAndAccess.value)));\n+                                     }else if (typeAndAccess.wo()||typeAndAccess.rw()) {\n+                                         bldr.op(CoreOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                     }else {\n+                                         bldr.op(CoreOp.invoke(ESCAPE.pre, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                     }\n+                                });\n+                        \/\/  invokeOW.op().operands().stream()\n+                        \/\/ .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, javaType))\n+                        \/\/  .forEach(value ->\n+                        \/\/          bldr.op(CoreOp.invoke(ESCAPE.pre, cc, bldrCntxt.getValue(value)))\n+                        \/\/  );\n+                        bldr.op(invokeOW.op());\n+                        typeAndAccesses.stream()\n+                                .filter(typeAndAccess -> InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, typeAndAccess.javaType))\n+                                .forEach(typeAndAccess -> {\n+                                    if (typeAndAccess.ro()) {\n+                                        bldr.op(CoreOp.invoke(ACCESS.post, cc,  bldrCntxt.getValue(typeAndAccess.value)));\n+                                    }else if (typeAndAccess.rw() || typeAndAccess.wo()) {\n+                                        bldr.op(CoreOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                    }else {\n+                                        bldr.op(CoreOp.invoke(ESCAPE.post, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                    }\n+                                });\n+                    }else{\n+                        bldr.op(invokeOW.op());\n+                    }\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":113,"deletions":11,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -53,6 +53,6 @@\n-    default boolean isDeviceDirty(){\n-        return BufferState.of(this).isDeviceDirty();\n-    }\n-    default boolean isHostChecked(){\n-        return BufferState.of(this).isHostChecked();\n-    }\n+  \/\/  default boolean isDeviceDirty(){\n+    \/\/    return BufferState.of(this).isDeviceDirty();\n+   \/\/ }\n+   \/\/ default boolean isHostChecked(){\n+     \/\/   return BufferState.of(this).isHostChecked();\n+   \/\/ }\n@@ -60,6 +60,6 @@\n-    default void clearDeviceDirty(){\n-         BufferState.of(this).clearDeviceDirty();\n-    }\n-    default void setHostDirty(){\n-        BufferState.of(this).setHostDirty(true);\n-    }\n+   \/\/ default void clearDeviceDirty(){\n+   \/\/      BufferState.of(this).clearDeviceDirty();\n+   \/\/ }\n+    \/\/default void setHostDirty(){\n+      \/\/  BufferState.of(this).setHostDirty(true);\n+   \/\/ }\n@@ -67,3 +67,3 @@\n-    default void setHostChecked(){\n-        BufferState.of(this).setHostChecked(true);\n-    }\n+   \/\/ default void setHostChecked(){\n+     \/\/   BufferState.of(this).setHostChecked(true);\n+   \/\/ }\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n-import java.lang.foreign.Arena;\n@@ -42,6 +41,0 @@\n-    public static final int NONE = 0;\n-    public static final int BIT_HOST_NEW = 1<< 0;\n-    public static final int BIT_DEVICE_NEW = 1 << 1;\n-    public static final int BIT_HOST_DIRTY = 1 << 2;\n-    public static final int BIT_DEVICE_DIRTY = 1 << 3;\n-    public static final int BIT_HOST_CHECKED = 1 << 4;\n@@ -63,0 +56,1 @@\n+            ValueLayout.ADDRESS.withName(\"ptr\"),\n@@ -77,0 +71,3 @@\n+    static final VarHandle ptr = stateMemoryLayout.varHandle(\n+            MemoryLayout.PathElement.groupElement(\"ptr\")\n+    );\n@@ -80,3 +77,1 @@\n-    static final VarHandle bits = stateMemoryLayout.varHandle(\n-            MemoryLayout.PathElement.groupElement(\"bits\")\n-    );\n+\n@@ -109,2 +104,4 @@\n-\n-\n+    public BufferState setPtr(MemorySegment  ptr) {\n+        BufferState.ptr.set(segment, paddedSize, ptr);\n+        return this;\n+    }\n@@ -122,28 +119,0 @@\n-    public BufferState assignBits(int bits) {\n-        BufferState.bits.set(segment, paddedSize, bits);\n-        return this;\n-    }\n-\n-    public BufferState and(int bitz) {\n-        BufferState.bits.set(segment, paddedSize, getBits() & bitz);\n-        return this;\n-    }\n-\n-    public BufferState or(int bitz) {\n-        BufferState.bits.set(segment, paddedSize, getBits() | bitz);\n-        return this;\n-    }\n-\n-    public BufferState xor(int bitz) {\n-        \/\/ if getBits() = 0b0111 (7) and bitz = 0b0100 (4) xored = 0x0011 3\n-        \/\/ if getBits() = 0b0011 (3) and bitz = 0b0100 (4) xored = 0x0111 7\n-        BufferState.bits.set(segment, paddedSize, getBits() ^ bitz);\n-        return this;\n-    }\n-\n-    public BufferState andNot(int bitz) {\n-        \/\/ if getBits() = 0b0111 (7) and bitz = 0b0100 (4) andNot = 0b0111 & 0b1011 = 0x0011 3\n-        \/\/ if getBits() = 0b0011 (3) and bitz = 0b0100 (4) andNot = 0b0011 & 0b1011 = 0x0011 3\n-        BufferState.bits.set(segment, paddedSize, getBits() & ~bitz);\n-        return this;\n-    }\n@@ -157,4 +126,0 @@\n-    public int getBits() {\n-        return (Integer) BufferState.bits.get(segment, paddedSize);\n-    }\n-\n@@ -164,1 +129,0 @@\n-\n@@ -169,71 +133,0 @@\n-    public boolean all(int bitz) {\n-        return (getBits() & bitz) == bitz;\n-    }\n-\n-    public boolean any(int bitz) {\n-        return (getBits() & bitz) != 0;\n-    }\n-\n-    public BufferState setHostDirty(boolean dirty) {\n-        if (dirty) {\n-            or(BIT_HOST_DIRTY);\n-        } else {\n-            andNot(BIT_HOST_DIRTY);\n-        }\n-        return this;\n-    }\n-\n-    public BufferState setHostChecked(boolean checked) {\n-        if (checked) {\n-            or(BIT_HOST_CHECKED);\n-        } else {\n-            andNot(BIT_HOST_CHECKED); \/\/ this is wrong we want bits&=!BIT_DEVICE_DIRTY\n-        }\n-        return this;\n-    }\n-\n-    public BufferState setDeviceDirty(boolean dirty) {\n-        if (dirty) {\n-            or(BIT_DEVICE_DIRTY);\n-        } else {\n-            andNot(BIT_DEVICE_DIRTY); \/\/ this is wrong we want bits&=!BIT_DEVICE_DIRTY\n-        }\n-        return this;\n-    }\n-\n-    public boolean isHostNew() {\n-        return all(BIT_HOST_NEW);\n-    }\n-\n-    public boolean isHostDirty() {\n-        return all(BIT_HOST_DIRTY);\n-    }\n-\n-    public boolean isHostChecked() {\n-        return all(BIT_HOST_CHECKED);\n-    }\n-\n-    public boolean isHostNewOrDirty() {\n-        return all(BIT_HOST_NEW | BIT_HOST_DIRTY);\n-    }\n-\n-    public boolean isDeviceDirty() {\n-        return all(BIT_DEVICE_DIRTY);\n-    }\n-\n-    public BufferState clearHostChecked() {\n-        return xor(BIT_HOST_CHECKED);\n-    }\n-\n-    public BufferState clearDeviceDirty() {\n-        return xor(BIT_DEVICE_DIRTY);\n-    }\n-\n-    public BufferState resetHostDirty() {\n-        return xor(BIT_HOST_DIRTY);\n-    }\n-\n-    public BufferState resetHostNew() {\n-        return xor(BIT_HOST_NEW);\n-    }\n-\n@@ -252,5 +145,0 @@\n-    static String paddedString(int bits) {\n-        String s = Integer.toBinaryString(bits);\n-        String s32 = \"                                  \";\n-        return s32.substring(0, s32.length() - s.length()) + s;\n-    }\n@@ -263,10 +151,0 @@\n-            builder.append(\"State:Bits:\").append(paddedString(getBits()));\n-            if (all(BIT_HOST_DIRTY)) {\n-                builder.append(\",\").append(\"HOST_DIRTY\");\n-            }\n-            if (all(BIT_DEVICE_DIRTY)) {\n-                builder.append(\",\").append(\"DEVICE_DIRTY\");\n-            }\n-            if (all(BIT_HOST_NEW)) {\n-                builder.append(\",\").append(\"HOST_NEW\");\n-            }\n@@ -276,2 +154,0 @@\n-\n-\n@@ -284,1 +160,0 @@\n-\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/BufferState.java","additions":9,"deletions":134,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public interface MappableIface {\n+public interface MappableIface  {\n@@ -35,1 +35,1 @@\n-    @interface RW {}\n+    @interface RW  {}\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/MappableIface.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -352,1 +352,6 @@\n-        new BufferState(segment, BufferState.getLayoutSizeAfterPadding(layout())).setMagic().setLength(layout().byteSize()).setState(BufferState.NEW_STATE).assignBits(BufferState.BIT_HOST_NEW| BufferState.BIT_HOST_DIRTY);\n+        new BufferState(segment, BufferState.getLayoutSizeAfterPadding(layout()))\n+                .setMagic()\n+                .setPtr(segment)\n+                .setLength(layout().byteSize())\n+                .setState(BufferState.NEW_STATE);\n+               \/\/ .assignBits(BufferState.BIT_HOST_NEW| BufferState.BIT_HOST_DIRTY);\n@@ -354,9 +359,0 @@\n-        \/\/ Uncomment if you want to check the State\n-        \/*\n-        State state = State.of(returnValue);\n-        if (state.ok() &&!state.isDeviceDirty() &&!state.isJavaDirty()){\n-            System.out.println(\"OK\");\n-        }else{\n-            throw new IllegalArgumentException(\"BAD TAIL\");\n-        }\n-         *\/\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+-agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=y --enable-preview --source 24 hat\/run.java\n","filename":"hat\/hat\/debug","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -258,1 +258,1 @@\n-                                if (bufferState.isHostDirty()) {\n+                                if (bufferState.getState()==BufferState.HOST_OWNED) {\n@@ -350,1 +350,1 @@\n-                                if (bufferState.isDeviceDirty()) {\n+                                if (bufferState.getState() == BufferState.HOST_OWNED) {\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/CLPlatform.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}