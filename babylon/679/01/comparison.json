{"files":[{"patch":"@@ -53,0 +53,1 @@\n+import java.util.stream.Stream;\n@@ -559,1 +560,3 @@\n-            opMethod = method.getDeclaringClass().getDeclaredMethod(opMethodName);\n+            var cls = Stream.of(method.getDeclaringClass().getDeclaredClasses()).filter(c -> c.getName().endsWith(\"$$CM\")).findFirst();\n+            if (cls.isEmpty()) return Optional.empty();\n+            opMethod = cls.get().getDeclaredMethod(opMethodName);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -72,0 +71,2 @@\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n@@ -152,4 +153,0 @@\n-        if (!iop.capturedValues().isEmpty()) {\n-            throw new UnsupportedOperationException(\"Operation captures values\");\n-        }\n-\n@@ -160,0 +157,26 @@\n+        return generateClassData(lookup, className, _ -> name, _ -> {}, iop);\n+    }\n+\n+    \/**\n+     * Transforms the invokable operation to bytecode encapsulated in a method of a class file.\n+     *\n+     * @param lookup the lookup\n+     * @param className the name to use for the class file\n+     * @param methodNamer function compiting method names from ops\n+     * @param extraBuilder additional builder actions\n+     * @param iops the invokable operation(s) to transform to bytecode\n+     * @return the class file bytes\n+     * @param <O> the type of the invokable operation\n+     *\/\n+    @SafeVarargs\n+    public static <O extends Op & Op.Invokable> byte[] generateClassData(MethodHandles.Lookup lookup,\n+                                                                         ClassDesc className,\n+                                                                         Function<O, String> methodNamer,\n+                                                                         Consumer<ClassBuilder> extraBuilder,\n+                                                                         O... iops) {\n+        for (O iop : iops) {\n+            if (!iop.capturedValues().isEmpty()) {\n+                throw new UnsupportedOperationException(\"Operation captures values\");\n+            }\n+        }\n+\n@@ -163,1 +186,3 @@\n-            generateMethod(lookup, className, name, iop, clb, lambdaSink, quotable);\n+            for (O iop : iops) {\n+                generateMethod(lookup, className, methodNamer.apply(iop), iop, clb, lambdaSink, quotable);\n+            }\n@@ -178,0 +203,1 @@\n+            extraBuilder.accept(clb);\n@@ -799,0 +825,2 @@\n+                        \/\/ Determine invoke opcode\n+                        boolean isInterface = false;\n@@ -800,5 +828,6 @@\n-                        Class<?> refClass;\n-                        try {\n-                             refClass = (Class<?>)refType.erasure().resolve(lookup);\n-                        } catch (ReflectiveOperationException e) {\n-                            throw new IllegalArgumentException(e);\n+                        if (!refType.equals(JavaType.type(className))) {\n+                            try {\n+                                 isInterface = ((Class<?>)refType.erasure().resolve(lookup)).isInterface();\n+                            } catch (ReflectiveOperationException e) {\n+                                throw new IllegalArgumentException(e);\n+                            }\n@@ -806,2 +835,0 @@\n-                        \/\/ Determine invoke opcode\n-                        final boolean isInterface = refClass.isInterface();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -114,3 +114,0 @@\n-    static final MethodRef LOCATION_FROM_STRING = MethodRef.method(J_C_LOCATION, \"fromString\",\n-            J_C_LOCATION, J_L_STRING);\n-\n@@ -129,0 +126,55 @@\n+    static final MethodRef LIST_EMPTY = MethodRef.method(List.class, \"of\", List.class);\n+    static final MethodRef LIST_OF_OBJECT = MethodRef.method(List.class, \"of\", List.class, Object.class);\n+    static final MethodRef MAP_EMPTY = MethodRef.method(Map.class, \"of\", Map.class);\n+    static final MethodRef MAP_OF_OBJECT_OBJECT = MethodRef.method(Map.class, \"of\", Map.class, Object.class, Object.class);\n+\n+    static final String LIST_BUILDER_F_NAME = \"::list\";\n+    static final String MAP_BUILDER_F_NAME = \"::map\";\n+    static final String OP_BUILDER_F_NAME = \"::op\";\n+\n+    static final JavaType J_U_LIST_VALUE = JavaType.parameterized(J_U_LIST, type(Value.class));\n+    static final JavaType J_U_LIST_BLOCK_REFERENCE = JavaType.parameterized(J_U_LIST, type(Block.Reference.class));\n+    static final JavaType J_U_LIST_BODY_BUILDER = JavaType.parameterized(J_U_LIST, type(Body.Builder.class));\n+\n+    static final FunctionType LIST_BUILDER_F_TYPE = functionType(\n+            J_U_LIST,\n+            J_L_OBJECT);\n+\n+    static final FunctionType MAP_BUILDER_F_TYPE = functionType(\n+            J_U_MAP,\n+            J_L_OBJECT);\n+\n+    static final FunctionType OP_BUILDER_F_OVERRIDE_1 = functionType(\n+            type(Op.class),\n+            J_L_STRING, \/\/ op name\n+            J_C_LOCATION, \/\/ location: Location or null\n+            J_L_OBJECT, \/\/ operand(s): Value, List<Value> or null\n+            J_L_OBJECT, \/\/ successor(s): Block.Reference, List<Block.Reference> or null\n+            J_L_OBJECT, \/\/ result type: TypeElement or null for void\n+            J_L_OBJECT, \/\/ attribute(s): Map<String, Object>, Object or null\n+            J_L_OBJECT); \/\/ body definition(s): Body.Builder, List<Body.Builder> or null\n+\n+    static final FunctionType OP_BUILDER_F_OVERRIDE_2 = functionType(\n+            type(Op.Result.class),\n+            type(Block.Builder.class),\n+            J_L_STRING, \/\/ op name\n+            J_C_LOCATION, \/\/ location: Location or null\n+            J_L_OBJECT, \/\/ operand(s): Value, List<Value> or null\n+            J_L_OBJECT, \/\/ successor(s): Block.Reference, List<Block.Reference> or null\n+            J_L_OBJECT, \/\/ result type: TypeElement or null for void\n+            J_L_OBJECT, \/\/ attribute(s): Map<String, Object>, Object or null\n+            J_L_OBJECT); \/\/ body definition(s): Body.Builder, List<Body.Builder> or null\n+\n+    static final FunctionType OP_BUILDER_F_OVERRIDE_3 = functionType(\n+            type(Op.Result.class),\n+            type(Block.Builder.class),\n+            J_L_STRING, \/\/ op name\n+            INT, \/\/ location.line\n+            INT, \/\/ location.columnt\n+            J_L_OBJECT, \/\/ operand(s): Value, List<Value> or null\n+            J_L_OBJECT, \/\/ successor(s): Block.Reference, List<Block.Reference> or null\n+            J_L_OBJECT, \/\/ result type: TypeElement or null for void\n+            J_L_OBJECT, \/\/ attribute(s): Map<String, Object>, Object or null\n+            J_L_OBJECT); \/\/ body definition(s): Body.Builder, List<Body.Builder> or null\n+\n+    final JavaType currentClass;\n@@ -154,0 +206,2 @@\n+     * @param currentClass type of the current class\n+     * @param name method name\n@@ -158,2 +212,2 @@\n-    public static FuncOp createBuilderFunction(Op op, Function<Block.Builder, Value> dialectFactoryF) {\n-        return new OpBuilder(dialectFactoryF).build(op);\n+    public static FuncOp createBuilderFunction(JavaType currentClass, String name, Op op, Function<Block.Builder, Value> dialectFactoryF) {\n+        return new OpBuilder(currentClass, dialectFactoryF).build(name, op);\n@@ -162,1 +216,67 @@\n-    OpBuilder(Function<Block.Builder, Value> dialectFactoryF) {\n+    public static List<FuncOp> createSupportFunctions(JavaType currentClass) {\n+        MethodRef listMethodRef = MethodRef.method(currentClass, LIST_BUILDER_F_NAME, LIST_BUILDER_F_TYPE);\n+        return List.of(\n+                func(LIST_BUILDER_F_NAME, LIST_BUILDER_F_TYPE).body(bb -> {\n+                    Block.Builder b0 = bb.entryBlock(), b1 = b0.block(), b2 = b0.block(), b3 = b0.block(), b4 = b0.block();\n+                    Value arg = b0.parameters().get(0);\n+                    b0.op(conditionalBranch(b0.op(eq(arg, b0.op(constant(J_L_OBJECT, null)))), b1.successor(), b2.successor()));\n+                    b1.op(return_(b1.op(invoke(LIST_EMPTY))));\n+                    b2.op(conditionalBranch(b2.op(instanceOf(J_U_LIST, arg)), b3.successor(), b4.successor()));\n+                    b3.op(return_(b3.op(cast(J_U_LIST, arg))));\n+                    b4.op(return_(b4.op(invoke(LIST_OF_OBJECT, arg))));\n+                }),\n+                func(MAP_BUILDER_F_NAME, MAP_BUILDER_F_TYPE).body(bb -> {\n+                    Block.Builder b0 = bb.entryBlock(), b1 = b0.block(), b2 = b0.block(), b3 = b0.block(), b4 = b0.block();\n+                    Value arg = b0.parameters().get(0);\n+                    b0.op(conditionalBranch(b0.op(eq(arg, b0.op(constant(J_L_OBJECT, null)))), b1.successor(), b2.successor()));\n+                    b1.op(return_(b1.op(invoke(MAP_EMPTY))));\n+                    b2.op(conditionalBranch(b2.op(instanceOf(J_U_MAP, arg)), b3.successor(), b4.successor()));\n+                    b3.op(return_(b3.op(cast(J_U_MAP, arg))));\n+                    b4.op(return_(b4.op(invoke(MAP_OF_OBJECT_OBJECT, b4.op(constant(J_L_STRING, \"\")), arg))));\n+                }),\n+                func(OP_BUILDER_F_NAME, OP_BUILDER_F_OVERRIDE_1).body(bb -> {\n+                    Block.Builder b = bb.entryBlock();\n+                    List<Block.Parameter> args = b.parameters();\n+                    b.op(return_(b.op(invoke(OP_FACTORY_CONSTRUCT,\n+                            b.op(fieldLoad(FieldRef.field(JavaOp.class, \"JAVA_OP_FACTORY\", OpFactory.class))),\n+                            b.op(new_(ConstructorRef.constructor(EXTERNALIZED_OP_F_TYPE),\n+                                    args.get(0),\n+                                    args.get(1),\n+                                    b.op(invoke(J_U_LIST_VALUE, listMethodRef, args.get(2))),\n+                                    b.op(invoke(J_U_LIST_BLOCK_REFERENCE, listMethodRef, args.get(3))),\n+                                    args.get(4),\n+                                    b.op(invoke(J_U_MAP, MethodRef.method(currentClass, MAP_BUILDER_F_NAME, MAP_BUILDER_F_TYPE), args.get(5))),\n+                                    b.op(invoke(J_U_LIST_BODY_BUILDER, listMethodRef, args.get(6)))))))));\n+                }),\n+                func(OP_BUILDER_F_NAME, OP_BUILDER_F_OVERRIDE_2).body(bb -> {\n+                    Block.Builder b = bb.entryBlock();\n+                    List<Block.Parameter> args = b.parameters();\n+                    b.op(return_(b.op(invoke(BLOCK_BUILDER_OP,\n+                            args.get(0),\n+                            b.op(invoke(MethodRef.method(currentClass, OP_BUILDER_F_NAME, OP_BUILDER_F_OVERRIDE_1),\n+                                    args.get(1),\n+                                    args.get(2),\n+                                    args.get(3),\n+                                    args.get(4),\n+                                    args.get(5),\n+                                    args.get(6),\n+                                    args.get(7)))))));\n+                }),\n+                func(OP_BUILDER_F_NAME, OP_BUILDER_F_OVERRIDE_3).body(bb -> {\n+                    Block.Builder b = bb.entryBlock();\n+                    List<Block.Parameter> args = b.parameters();\n+                    b.op(return_(b.op(invoke(MethodRef.method(currentClass, OP_BUILDER_F_NAME, OP_BUILDER_F_OVERRIDE_2),\n+                            args.get(0),\n+                            args.get(1),\n+                            b.op(new_(ConstructorRef.constructor(Location.class, int.class, int.class), args.get(2), args.get(3))),\n+                            args.get(4),\n+                            args.get(5),\n+                            args.get(6),\n+                            args.get(7),\n+                            args.get(8)))));\n+                })\n+        );\n+    }\n+\n+    OpBuilder(JavaType currentClass, Function<Block.Builder, Value> dialectFactoryF) {\n+        this.currentClass = currentClass;\n@@ -175,1 +295,1 @@\n-    FuncOp build(Op op) {\n+    FuncOp build(String name, Op op) {\n@@ -177,1 +297,1 @@\n-        Value result = buildOp(ancestorBody, op);\n+        Value result = buildOp(null, ancestorBody, op);\n@@ -182,2 +302,1 @@\n-        \/\/ @@@ avoid use of opName\n-        return func(\"builder.\" + op.getClass().getName(), builder.parentBody());\n+        return func(name, builder.parentBody());\n@@ -187,1 +306,1 @@\n-    Value buildOp(Value ancestorBody, Op inputOp) {\n+    Value buildOp(Value blockBuilder, Value ancestorBody, Op inputOp) {\n@@ -219,1 +338,2 @@\n-        Value opDef = buildOpDefinition(\n+        return buildOp(\n+                blockBuilder,\n@@ -228,1 +348,0 @@\n-        return builder.op(invoke(OP_FACTORY_CONSTRUCT, opFactory, opDef));\n@@ -231,0 +350,31 @@\n+    Value buildOp(Value blockBuilder,\n+                  Op inputOp,\n+                  String name,\n+                  Location location,\n+                  List<Value> operands,\n+                  List<Value> successors,\n+                  TypeElement resultType,\n+                  Map<String, Object> attributes,\n+                  List<Value> bodies) {\n+        FunctionType override =\n+                blockBuilder == null ? OP_BUILDER_F_OVERRIDE_1\n+                : location == Location.NO_LOCATION || location.sourceRef() != null\n+                ? OP_BUILDER_F_OVERRIDE_2 : OP_BUILDER_F_OVERRIDE_3;\n+        List<Value> args = new ArrayList<>();\n+        if (override != OP_BUILDER_F_OVERRIDE_1) {\n+            args.add(blockBuilder);\n+        }\n+        args.add(builder.op(constant(J_L_STRING, name)));\n+        if (override == OP_BUILDER_F_OVERRIDE_3) {\n+            args.add(builder.op(constant(INT, location.line())));\n+            args.add(builder.op(constant(INT, location.column())));\n+        } else {\n+            args.add(buildLocation(location));\n+        }\n+        args.add(buildFlexibleList(type(Value.class), operands));\n+        args.add(buildFlexibleList(type(Block.Reference.class), successors));\n+        args.add(buildType(resultType));\n+        args.add(buildAttributeMap(inputOp, attributes));\n+        args.add(buildFlexibleList(type(Body.Builder.class), bodies));\n+        return builder.op(invoke(MethodRef.method(currentClass, \"::op\", override), args));\n+    }\n@@ -232,17 +382,6 @@\n-    Value buildOpDefinition(Op inputOp,\n-                            String name,\n-                            Location location,\n-                            List<Value> operands,\n-                            List<Value> successors,\n-                            TypeElement resultType,\n-                            Map<String, Object> attributes,\n-                            List<Value> bodies) {\n-        List<Value> args = List.of(\n-                builder.op(constant(J_L_STRING, name)),\n-                buildLocation(location),\n-                buildList(type(Value.class), operands),\n-                buildList(type(Block.Reference.class), successors),\n-                buildType(resultType),\n-                buildAttributeMap(inputOp, attributes),\n-                buildList(type(Body.Builder.class), bodies));\n-        return builder.op(new_(ConstructorRef.constructor(EXTERNALIZED_OP_F_TYPE), args));\n+    Value buildFlexibleList(JavaType elementType, List<Value> elements) {\n+        return switch (elements.size()) {\n+            case 0 -> builder.op(constant(elementType, null));\n+            case 1 -> elements.getFirst();\n+            default -> buildList(elementType, elements);\n+        };\n@@ -255,2 +394,4 @@\n-            return builder.op(invoke(LOCATION_FROM_STRING,\n-                    builder.op(constant(J_L_STRING, l.toString()))));\n+            return builder.op(new_(ConstructorRef.constructor(Location.class, String.class, int.class, int.class),\n+                    builder.op(constant(J_L_STRING, l.sourceRef())),\n+                    builder.op(constant(INT, l.line())),\n+                    builder.op(constant(INT, l.column()))));\n@@ -291,3 +432,1 @@\n-                Value op = buildOp(body, inputOp);\n-                Value result = builder.op(invoke(BLOCK_BUILDER_OP, block, op));\n-                valueMap.put(inputOp.result(), result);\n+                valueMap.put(inputOp.result(), buildOp(block, body, inputOp));\n@@ -336,0 +475,6 @@\n+        if (attributes.isEmpty()) {\n+            return builder.op(constant(type(Map.class), null));\n+        }\n+        if (attributes.size() == 1 && attributes.get(\"\") instanceof Object o) {\n+            return buildAttributeValue(o);\n+        }\n@@ -346,0 +491,4 @@\n+    private Value box(TypeElement to, Value v) {\n+        return builder.op(invoke(MethodRef.method(to, \"valueOf\", to, v.type()), v));\n+    }\n+\n@@ -348,33 +497,22 @@\n-            case Boolean v -> {\n-                yield builder.op(constant(BOOLEAN, value));\n-            }\n-            case Byte v -> {\n-                yield builder.op(constant(BYTE, value));\n-            }\n-            case Short v -> {\n-                yield builder.op(constant(SHORT, value));\n-            }\n-            case Character v -> {\n-                yield builder.op(constant(CHAR, value));\n-            }\n-            case Integer v -> {\n-                yield builder.op(constant(INT, value));\n-            }\n-            case Long v -> {\n-                yield builder.op(constant(LONG, value));\n-            }\n-            case Float v -> {\n-                yield builder.op(constant(FLOAT, value));\n-            }\n-            case Double v -> {\n-                yield builder.op(constant(DOUBLE, value));\n-            }\n-            case Class<?> v -> {\n-                yield buildType(JavaType.type(v));\n-            }\n-            case String s -> {\n-                yield builder.op(constant(J_L_STRING, value));\n-            }\n-            case TypeElement f -> {\n-                yield buildType(f);\n-            }\n+            case Boolean _ ->\n+                box(J_L_BOOLEAN, builder.op(constant(BOOLEAN, value)));\n+            case Byte _ ->\n+                box(J_L_BYTE, builder.op(constant(BYTE, value)));\n+            case Short _ ->\n+                box(J_L_SHORT, builder.op(constant(SHORT, value)));\n+            case Character _ ->\n+                box(J_L_CHARACTER, builder.op(constant(CHAR, value)));\n+            case Integer _ ->\n+                box(J_L_INTEGER, builder.op(constant(INT, value)));\n+            case Long _ ->\n+                box(J_L_LONG, builder.op(constant(LONG, value)));\n+            case Float _ ->\n+                box(J_L_FLOAT, builder.op(constant(FLOAT, value)));\n+            case Double _ ->\n+                box(J_L_DOUBLE, builder.op(constant(DOUBLE, value)));\n+            case Class<?> v ->\n+                buildType(JavaType.type(v));\n+            case String s ->\n+                builder.op(constant(J_L_STRING, value));\n+            case TypeElement f ->\n+                buildType(f);\n@@ -385,2 +523,2 @@\n-            case Object o when value == ExternalizedOp.NULL_ATTRIBUTE_VALUE -> {\n-                yield builder.op(fieldLoad(FieldRef.field(ExternalizedOp.class,\n+            case Object o when value == ExternalizedOp.NULL_ATTRIBUTE_VALUE ->\n+                builder.op(fieldLoad(FieldRef.field(ExternalizedOp.class,\n@@ -388,1 +526,0 @@\n-            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":208,"deletions":71,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -113,0 +113,9 @@\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.NestHostAttribute;\n+import java.lang.invoke.MethodHandles;\n+import javax.tools.JavaFileManager;\n+import javax.tools.StandardLocation;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -138,0 +147,1 @@\n+    private final JavaFileManager fileManager;\n@@ -144,2 +154,2 @@\n-    private ListBuffer<JCTree> classOps;\n-    private Symbol.ClassSymbol currentClassSym;\n+    private List<CoreOp.FuncOp> classOps;\n+    private Symbol.ClassSymbol currentClassSym, synthClassSym;\n@@ -166,0 +176,1 @@\n+        fileManager = context.get(JavaFileManager.class);\n@@ -184,1 +195,1 @@\n-                classOps.add(opMethodDecl(methodName(symbolToMethodRef(tree.sym)), funcOp, codeModelStorageOption));\n+                classOps.add(opBuilder(methodName(symbolToMethodRef(tree.sym)).toString(), funcOp));\n@@ -197,1 +208,1 @@\n-        ListBuffer<JCTree> prevClassOps = classOps;\n+        List<CoreOp.FuncOp> prevClassOps = classOps;\n@@ -199,0 +210,1 @@\n+        Symbol.ClassSymbol prevSynthClassSym = synthClassSym;\n@@ -204,1 +216,2 @@\n-            classOps = new ListBuffer<>();\n+            synthClassSym = new ClassSymbol(0, names.fromString(\"$CM\"), currentClassSym);\n+            classOps = new ArrayList<>();\n@@ -206,1 +219,6 @@\n-            tree.defs = tree.defs.prependList(classOps.toList());\n+            if (!classOps.isEmpty()) {\n+                String synthClassName = synthClassSym.flatName().toString();\n+                classOps.addAll(OpBuilder.createSupportFunctions(JavaType.type(ClassDesc.of(synthClassName))));\n+                synthClassDecl(synthClassName, classOps);\n+                currentClassSym.members().enter(synthClassSym);\n+            }\n@@ -211,0 +229,1 @@\n+            synthClassSym = prevSynthClassSym;\n@@ -234,1 +253,3 @@\n-            JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n+            Name lambdaName = lambdaName();\n+            MethodSymbol opMethodSymbol = opMethodSymbol(lambdaName);\n+            CoreOp.FuncOp opMethod = opBuilder(lambdaName.toString(), funcOp);\n@@ -238,1 +259,1 @@\n-            tree.codeModel = opMethod.sym;\n+            tree.codeModel = opMethodSymbol;\n@@ -265,1 +286,2 @@\n-            JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n+            Name lambdaName = lambdaName();\n+            CoreOp.FuncOp opMethod = opBuilder(lambdaName.toString(), funcOp);\n@@ -267,1 +289,1 @@\n-            tree.codeModel = opMethod.sym;\n+            tree.codeModel = opMethodSymbol(lambdaName);\n@@ -346,7 +368,1 @@\n-    private JCMethodDecl opMethodDecl(Name methodName, CoreOp.FuncOp op, CodeModelStorageOption codeModelStorageOption) {\n-        \/\/ Create the method that constructs the code model stored in the class file\n-        var mt = new MethodType(com.sun.tools.javac.util.List.nil(), crSyms.opType,\n-                com.sun.tools.javac.util.List.nil(), syms.methodClass);\n-        var ms = new MethodSymbol(PRIVATE | STATIC | SYNTHETIC, methodName, mt, currentClassSym);\n-        currentClassSym.members().enter(ms);\n-\n+    private CoreOp.FuncOp opBuilder(String methodName, CoreOp.FuncOp op) {\n@@ -356,1 +372,4 @@\n-        var opBuilder = OpBuilder.createBuilderFunction(op,\n+        return OpBuilder.createBuilderFunction(\n+                symbolToErasedDesc(synthClassSym),\n+                methodName,\n+                op,\n@@ -359,2 +378,0 @@\n-        var codeModelTranslator = new CodeModelTranslator();\n-        var body = codeModelTranslator.translateFuncOp(opBuilder, ms);\n@@ -362,2 +379,36 @@\n-        var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(body)));\n-        return md;\n+    }\n+\n+    private MethodSymbol opMethodSymbol(Name methodName) {\n+        \/\/ Create the method that constructs the code model stored in the class file\n+        var mt = new MethodType(com.sun.tools.javac.util.List.nil(), crSyms.opType,\n+                com.sun.tools.javac.util.List.nil(), syms.methodClass);\n+        return new MethodSymbol(PRIVATE | STATIC | SYNTHETIC, methodName, mt, synthClassSym);\n+    }\n+\n+    private Type synthClassDecl(String className, List<CoreOp.FuncOp> funcs) {\n+        try {\n+            JavaFileManager.Location outLocn;\n+            if (fileManager.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {\n+                outLocn = fileManager.getLocationForModule(StandardLocation.CLASS_OUTPUT, currentClassSym.packge().modle.name.toString());\n+            } else {\n+                outLocn = StandardLocation.CLASS_OUTPUT;\n+            }\n+            JavaFileObject outFile = fileManager.getJavaFileForOutput(outLocn, className, JavaFileObject.Kind.CLASS, currentClassSym.sourcefile);\n+            ClassDesc synthCD = ClassDesc.of(className);\n+            ClassDesc parentClass = ClassDesc.of(currentClassSym.className());\n+            byte[] data = BytecodeGenerator.generateClassData(\n+                        MethodHandles.lookup(),\n+                        synthCD,\n+                        CoreOp.FuncOp::funcName,\n+                        clb -> {\n+                            clb.with(InnerClassesAttribute.of(InnerClassInfo.of(synthCD, Optional.of(parentClass), Optional.of(\"$CM\"))));\n+                            clb.with(NestHostAttribute.of(parentClass));\n+                        },\n+                        funcs.toArray(CoreOp.FuncOp[]::new));\n+            try (OutputStream out = outFile.openOutputStream()) {\n+                out.write(data);\n+            }\n+            return syms.enterClass(currentClassSym.packge().modle, className);\n+        } catch (IOException e) {\n+            throw new IllegalStateException(e);\n+        }\n@@ -2681,150 +2732,0 @@\n-    \/**\n-     * Translate a code model (a function op) into the corresponding AST.\n-     * The input function op is assumed to be generated by {@code OpBuilder}.\n-     *\/\n-    class CodeModelTranslator {\n-        private static final MethodRef M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n-                Op.Result.class, Op.class);\n-        private static final MethodRef M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\",\n-                Block.Parameter.class, TypeElement.class);\n-        private static final MethodRef M_OP_SEAL = MethodRef.method(Op.class, \"seal\", void.class);\n-\n-        private final Map<Value, JCTree> valueToTree = new HashMap<>();\n-        private int localVarCount = 0; \/\/ used to name variables we introduce in the AST\n-\n-        private JCExpression toExpr(JCTree t) {\n-            return switch (t) {\n-                case JCExpression e -> e;\n-                case JCTree.JCVariableDecl vd -> make.Ident(vd);\n-                case null, default -> throw new IllegalArgumentException();\n-            };\n-        }\n-\n-        private JCTree translateInvokeOp(JavaOp.InvokeOp invokeOp) {\n-            Value receiver = (invokeOp.invokeKind() == JavaOp.InvokeOp.InvokeKind.INSTANCE) ?\n-                    invokeOp.operands().get(0) : null;\n-            com.sun.tools.javac.util.List<Value> arguments = invokeOp.operands().stream()\n-                    .skip(receiver == null ? 0 : 1)\n-                    .collect(com.sun.tools.javac.util.List.collector());\n-            var methodSym = methodDescriptorToSymbol(invokeOp.invokeDescriptor());\n-            var meth = (receiver == null) ?\n-                    make.Ident(methodSym) :\n-                    make.Select(toExpr(translateOp(receiver)), methodSym);\n-            var args = new ListBuffer<JCTree.JCExpression>();\n-            for (Value operand : arguments) {\n-                args.add(toExpr(translateOp(operand)));\n-            }\n-            var methodInvocation = make.App(meth, args.toList());\n-            if (invokeOp.isVarArgs()) {\n-                setVarargs(methodInvocation, invokeOp.invokeDescriptor().type());\n-            }\n-            return methodInvocation;\n-        }\n-\n-        private void setVarargs(JCExpression tree, FunctionType type) {\n-            var lastParam = type.parameterTypes().getLast();\n-            if (lastParam instanceof jdk.incubator.code.dialect.java.ArrayType varargType) {\n-                TreeInfo.setVarargsElement(tree, typeElementToType(varargType.componentType()));\n-            } else {\n-                Assert.error(\"Expected trailing array type: \" + type);\n-            }\n-        }\n-\n-        private static final Set<MethodRef> mRefs = Set.of(M_BLOCK_BUILDER_OP, M_BLOCK_BUILDER_PARAM, M_OP_SEAL);\n-        public JCTree.JCStatement translateFuncOp(CoreOp.FuncOp funcOp, MethodSymbol ms) {\n-            Assert.check(funcOp.parameters().isEmpty());\n-            Assert.check(funcOp.body().blocks().size() == 1);\n-\n-            java.util.List<Value> rootValues = funcOp.traverse(new ArrayList<>(), (l, ce) -> {\n-                boolean isRoot = switch (ce) {\n-                    case JavaOp.InvokeOp invokeOp when mRefs.contains(invokeOp.invokeDescriptor()) -> true;\n-                    case CoreOp.ReturnOp _, JavaOp.ArrayAccessOp.ArrayStoreOp _ -> true;\n-                    case Op op when op.result() != null && op.result().uses().size() > 1 -> true;\n-                    default -> false;\n-                };\n-                if (isRoot) {\n-                    l.add(((Op) ce).result());\n-                }\n-                return l;\n-            });\n-\n-            var stats = new ListBuffer<JCTree.JCStatement>();\n-            for (Value root : rootValues) {\n-                JCTree tree = translateOp(root);\n-                if (tree instanceof JCExpression e) {\n-                    if (!root.uses().isEmpty()) {\n-                        var vs = new Symbol.VarSymbol(LocalVarFlags | SYNTHETIC, names.fromString(\"_$\" + localVarCount++), tree.type, ms);\n-                        tree = make.VarDef(vs, e);\n-                        valueToTree.put(root, tree);\n-                    } else {\n-                        tree = make.Exec(e);\n-                    }\n-                }\n-                stats.add((JCTree.JCStatement) tree);\n-            }\n-            var mb = make.Block(0, stats.toList());\n-\n-            return mb;\n-        }\n-\n-        private JCTree translateOp(Value v) {\n-            if (valueToTree.containsKey(v)) {\n-                return valueToTree.get(v);\n-            }\n-            Op op = ((Op.Result) v).op();\n-            JCTree tree = switch (op) {\n-                case CoreOp.ConstantOp constantOp when constantOp.value() == null ->\n-                        make.Literal(TypeTag.BOT, null).setType(syms.botType);\n-                case CoreOp.ConstantOp constantOp -> make.Literal(constantOp.value());\n-                case JavaOp.InvokeOp invokeOp -> translateInvokeOp(invokeOp);\n-                case JavaOp.NewOp newOp when newOp.resultType() instanceof jdk.incubator.code.dialect.java.ArrayType at -> {\n-                    var elemType = make.Ident(typeElementToType(at.componentType()).tsym);\n-                    var dims = new ListBuffer<JCTree.JCExpression>();\n-                    for (int d = 0; d < at.dimensions(); d++) {\n-                        dims.add(toExpr(translateOp(newOp.operands().get(d))));\n-                    }\n-                    var na = make.NewArray(elemType, dims.toList(), null);\n-                    na.type = typeElementToType(at);\n-                    yield na;\n-                }\n-                case JavaOp.NewOp newOp -> {\n-                    var ownerType = typeElementToType(newOp.constructorDescriptor().refType());\n-                    var clazz = make.Ident(ownerType.tsym);\n-                    var args = new ListBuffer<JCTree.JCExpression>();\n-                    for (Value operand : newOp.operands()) {\n-                        args.add(toExpr(translateOp(operand)));\n-                    }\n-                    var nc = make.NewClass(null, null, clazz, args.toList(), null);\n-                    if (newOp.isVarargs()) {\n-                        setVarargs(nc, newOp.constructorDescriptor().type());\n-                    }\n-                    nc.type = ownerType;\n-                    nc.constructor = constructorDescriptorToSymbol(newOp.constructorDescriptor());\n-                    nc.constructorType = nc.constructor.type;\n-                    yield nc;\n-                }\n-                case CoreOp.ReturnOp returnOp -> make.Return(toExpr(translateOp(returnOp.returnValue())));\n-                case JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp -> {\n-                    var sym = fieldDescriptorToSymbol(fieldLoadOp.fieldDescriptor());\n-                    Assert.check(sym.isStatic());\n-                    yield make.Select(make.Ident(sym.owner), sym);\n-                }\n-                case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n-                    var array = arrayStoreOp.operands().get(0);\n-                    var index = arrayStoreOp.operands().get(1);\n-                    var val = arrayStoreOp.operands().get(2);\n-                    var as = make.Assign(\n-                            make.Indexed(\n-                                    toExpr(translateOp(array)), toExpr(translateOp(index))), toExpr(translateOp(val))\n-                    );\n-                    as.type = typeElementToType(((jdk.incubator.code.dialect.java.ArrayType) array.type()).componentType());\n-                    yield as;\n-                }\n-                default ->\n-                        throw new IllegalStateException(\"Op -> JCTree not supported for :\" + op.getClass().getName());\n-            };\n-            valueToTree.put(v, tree);\n-            return tree;\n-        }\n-    }\n-\n@@ -2968,21 +2869,0 @@\n-\n-    VarSymbol fieldDescriptorToSymbol(FieldRef fieldRef) {\n-        Name name = names.fromString(fieldRef.name());\n-        Type site = typeElementToType(fieldRef.refType());\n-        return resolve.resolveInternalField(attrEnv().enclClass, attrEnv(), site, name);\n-    }\n-\n-    MethodSymbol methodDescriptorToSymbol(MethodRef methodRef) {\n-        Name name = names.fromString(methodRef.name());\n-        Type site = typeElementToType(methodRef.refType());\n-        com.sun.tools.javac.util.List<Type> argtypes = methodRef.type().parameterTypes().stream()\n-                .map(this::typeElementToType).collect(com.sun.tools.javac.util.List.collector());\n-        return resolve.resolveInternalMethod(attrEnv().enclClass, attrEnv(), site, name, argtypes, com.sun.tools.javac.util.List.nil());\n-    }\n-\n-    MethodSymbol constructorDescriptorToSymbol(ConstructorRef constructorRef) {\n-        Type site = typeElementToType(constructorRef.refType());\n-        com.sun.tools.javac.util.List<Type> argtypes = constructorRef.type().parameterTypes().stream()\n-                .map(this::typeElementToType).collect(com.sun.tools.javac.util.List.collector());\n-        return resolve.resolveInternalConstructor(attrEnv().enclClass, attrEnv(), site, argtypes, com.sun.tools.javac.util.List.nil());\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":73,"deletions":193,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+ * @ignore\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestCodeBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}