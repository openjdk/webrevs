{"files":[{"patch":"@@ -68,0 +68,1 @@\n+import java.util.function.Function;\n@@ -71,2 +72,2 @@\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n+import java.util.LinkedHashMap;\n+import java.util.SequencedMap;\n@@ -141,0 +142,16 @@\n+    \/**\n+     * Transforms the invokable operation to bytecode encapsulated in a method of a class file.\n+     *\n+     * @param lookup the lookup\n+     * @param clName the name to use for the method of the class file\n+     * @param mop the module operation to transform to bytecode\n+     * @return the class file bytes\n+     *\/\n+    public static byte[] generateClassData(MethodHandles.Lookup lookup,\n+                                           ClassDesc clName,\n+                                           ModuleOp mop) {\n+        ClassModel generatedModel = ClassFile.of().parse(generateClassData(lookup, clName, mop.functionTable()));\n+        \/\/ Compact locals of the generated bytecode\n+        return ClassFile.of().transformClass(generatedModel, LocalsCompactor.INSTANCE);\n+    }\n+\n@@ -154,1 +171,1 @@\n-        ClassDesc className = ClassDesc.of(packageName.isEmpty()\n+        ClassDesc clsName = ClassDesc.of(packageName.isEmpty()\n@@ -157,1 +174,1 @@\n-        return generateClassData(lookup, className, _ -> name, _ -> {}, iop);\n+        return generateClassData(lookup, clsName, new LinkedHashMap<>(Map.of(name, iop)));\n@@ -160,22 +177,3 @@\n-    \/**\n-     * Transforms the invokable operation to bytecode encapsulated in a method of a class file.\n-     *\n-     * @param lookup the lookup\n-     * @param className the name to use for the class file\n-     * @param methodNamer function compiting method names from ops\n-     * @param extraBuilder additional builder actions\n-     * @param iops the invokable operation(s) to transform to bytecode\n-     * @return the class file bytes\n-     * @param <O> the type of the invokable operation\n-     *\/\n-    @SafeVarargs\n-    public static <O extends Op & Op.Invokable> byte[] generateClassData(MethodHandles.Lookup lookup,\n-                                                                         ClassDesc className,\n-                                                                         Function<O, String> methodNamer,\n-                                                                         Consumer<ClassBuilder> extraBuilder,\n-                                                                         O... iops) {\n-        for (O iop : iops) {\n-            if (!iop.capturedValues().isEmpty()) {\n-                throw new UnsupportedOperationException(\"Operation captures values\");\n-            }\n-        }\n+    private static <O extends Op & Op.Invokable> byte[] generateClassData(MethodHandles.Lookup lookup,\n+                                                                          ClassDesc clName,\n+                                                                          SequencedMap<String, ? extends O> ops) {\n@@ -183,1 +181,1 @@\n-        byte[] classBytes = ClassFile.of().build(className, clb -> {\n+        byte[] classBytes = ClassFile.of().build(clName, clb -> {\n@@ -186,2 +184,2 @@\n-            for (O iop : iops) {\n-                generateMethod(lookup, className, methodNamer.apply(iop), iop, clb, lambdaSink, quotable);\n+            for (var e : ops.sequencedEntrySet()) {\n+                generateMethod(lookup, clName, e.getKey(), e.getValue(), clb, ops, lambdaSink, quotable);\n@@ -201,1 +199,1 @@\n-                generateMethod(lookup, className, \"lambda$\" + i, lop, clb, lambdaSink, quotable);\n+                generateMethod(lookup, clName, \"lambda$\" + i, lop, clb, ops, lambdaSink, quotable);\n@@ -203,1 +201,0 @@\n-            extraBuilder.accept(clb);\n@@ -213,0 +210,1 @@\n+                                                                     SequencedMap<String, ? extends O> functionTable,\n@@ -223,1 +221,1 @@\n-                                          iop.body().blocks(), cob, lambdaSink, quotable).generate()));\n+                                          iop.body().blocks(), cob, functionTable, lambdaSink, quotable).generate()));\n@@ -240,0 +238,1 @@\n+    private final Map<String, ? extends Invokable> functionMap;\n@@ -252,0 +251,1 @@\n+                              Map<String, ? extends Invokable> functionMap,\n@@ -266,0 +266,1 @@\n+        this.functionMap = functionMap;\n@@ -825,2 +826,0 @@\n-                        \/\/ Determine invoke opcode\n-                        boolean isInterface = false;\n@@ -828,6 +827,5 @@\n-                        if (!refType.equals(JavaType.type(className))) {\n-                            try {\n-                                 isInterface = ((Class<?>)refType.erasure().resolve(lookup)).isInterface();\n-                            } catch (ReflectiveOperationException e) {\n-                                throw new IllegalArgumentException(e);\n-                            }\n+                        Class<?> refClass;\n+                        try {\n+                             refClass = (Class<?>)refType.erasure().resolve(lookup);\n+                        } catch (ReflectiveOperationException e) {\n+                            throw new IllegalArgumentException(e);\n@@ -835,0 +833,2 @@\n+                        \/\/ Determine invoke opcode\n+                        boolean isInterface =  refClass.isInterface();\n@@ -864,0 +864,20 @@\n+                    case FuncCallOp op -> {\n+                        Invokable fop = functionMap.get(op.funcName());\n+                        if (fop == null) {\n+                            throw new IllegalArgumentException(\"Could not resolve function: \" + op.funcName());\n+                        }\n+                        processOperands(op);\n+                        MethodTypeDesc mDesc = MethodRef.toNominalDescriptor(fop.invokableType());\n+                        cob.invoke(\n+                                Opcode.INVOKESTATIC,\n+                                className,\n+                                op.funcName(),\n+                                mDesc,\n+                                false);\n+                        ClassDesc ret = toClassDesc(op.resultType());\n+                        if (ret.isClassOrInterface() && !ret.equals(mDesc.returnType())) {\n+                            \/\/ Explicit cast if method return type differs\n+                            cob.checkcast(ret);\n+                        }\n+                        push(op.result());\n+                    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":60,"deletions":40,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -131,7 +131,5 @@\n-    static final String LIST_BUILDER_F_NAME = \"::list\";\n-    static final String MAP_BUILDER_F_NAME = \"::map\";\n-    static final String OP_BUILDER_F_NAME = \"::op\";\n-\n-    static final JavaType J_U_LIST_VALUE = JavaType.parameterized(J_U_LIST, type(Value.class));\n-    static final JavaType J_U_LIST_BLOCK_REFERENCE = JavaType.parameterized(J_U_LIST, type(Block.Reference.class));\n-    static final JavaType J_U_LIST_BODY_BUILDER = JavaType.parameterized(J_U_LIST, type(Body.Builder.class));\n+    static final String LIST_BUILDER_F_NAME = \"$list\";\n+    static final String MAP_BUILDER_F_NAME = \"$map\";\n+    static final String OP_BUILDER_F_NAME_1 = \"$op1\";\n+    static final String OP_BUILDER_F_NAME_2 = \"$op2\";\n+    static final String OP_BUILDER_F_NAME_3 = \"$op3\";\n@@ -180,2 +178,0 @@\n-    final JavaType currentClass;\n-\n@@ -192,4 +188,0 @@\n-    final Value dialectFactory;\n-\n-    final Value opFactory;\n-\n@@ -206,3 +198,2 @@\n-     * @param currentClass type of the current class\n-     * @param name method name\n-     * @param op the code model.\n+     * @param ops the named code models.\n+     * @param functionNameF a function that defines method names of the code models\n@@ -210,1 +201,1 @@\n-     * @return the building code model.\n+     * @return the module with building code models and support functions.\n@@ -212,2 +203,9 @@\n-    public static FuncOp createBuilderFunction(JavaType currentClass, String name, Op op, Function<Block.Builder, Value> dialectFactoryF) {\n-        return new OpBuilder(currentClass, dialectFactoryF).build(name, op);\n+    public static ModuleOp createBuilderFunction(SequencedMap<String, Op> ops, Function<Block.Builder, Value> dialectFactoryF) {\n+        List<FuncOp> funcs = new ArrayList<>();\n+        for (var e : ops.sequencedEntrySet()) {\n+            funcs.add(new OpBuilder(dialectFactoryF).build(e.getKey(), e.getValue()));\n+        }\n+        funcs.addAll(createSupportFunctions(dialectFactoryF));\n+        ModuleOp module = module(funcs);\n+        module.seal();\n+        return module;\n@@ -216,2 +214,1 @@\n-    public static List<FuncOp> createSupportFunctions(JavaType currentClass) {\n-        MethodRef listMethodRef = MethodRef.method(currentClass, LIST_BUILDER_F_NAME, LIST_BUILDER_F_TYPE);\n+    static List<FuncOp> createSupportFunctions(Function<Block.Builder, Value> dialectFactoryF) {\n@@ -237,1 +234,1 @@\n-                func(OP_BUILDER_F_NAME, OP_BUILDER_F_OVERRIDE_1).body(bb -> {\n+                func(OP_BUILDER_F_NAME_1, OP_BUILDER_F_OVERRIDE_1).body(bb -> {\n@@ -241,1 +238,1 @@\n-                            b.op(fieldLoad(FieldRef.field(JavaOp.class, \"JAVA_OP_FACTORY\", OpFactory.class))),\n+                            b.op(invoke(DIALECT_FACTORY_OP_FACTORY, dialectFactoryF.apply(b))),\n@@ -245,2 +242,2 @@\n-                                    b.op(invoke(J_U_LIST_VALUE, listMethodRef, args.get(2))),\n-                                    b.op(invoke(J_U_LIST_BLOCK_REFERENCE, listMethodRef, args.get(3))),\n+                                    b.op(funcCall(LIST_BUILDER_F_NAME, LIST_BUILDER_F_TYPE, args.get(2))),\n+                                    b.op(funcCall(LIST_BUILDER_F_NAME, LIST_BUILDER_F_TYPE, args.get(3))),\n@@ -248,2 +245,2 @@\n-                                    b.op(invoke(J_U_MAP, MethodRef.method(currentClass, MAP_BUILDER_F_NAME, MAP_BUILDER_F_TYPE), args.get(5))),\n-                                    b.op(invoke(J_U_LIST_BODY_BUILDER, listMethodRef, args.get(6)))))))));\n+                                    b.op(funcCall(MAP_BUILDER_F_NAME, MAP_BUILDER_F_TYPE, args.get(5))),\n+                                    b.op(funcCall(LIST_BUILDER_F_NAME, LIST_BUILDER_F_TYPE, args.get(6)))))))));\n@@ -251,1 +248,1 @@\n-                func(OP_BUILDER_F_NAME, OP_BUILDER_F_OVERRIDE_2).body(bb -> {\n+                func(OP_BUILDER_F_NAME_2, OP_BUILDER_F_OVERRIDE_2).body(bb -> {\n@@ -256,1 +253,1 @@\n-                            b.op(invoke(MethodRef.method(currentClass, OP_BUILDER_F_NAME, OP_BUILDER_F_OVERRIDE_1),\n+                            b.op(funcCall(OP_BUILDER_F_NAME_1, OP_BUILDER_F_OVERRIDE_1,\n@@ -265,1 +262,1 @@\n-                func(OP_BUILDER_F_NAME, OP_BUILDER_F_OVERRIDE_3).body(bb -> {\n+                func(OP_BUILDER_F_NAME_3, OP_BUILDER_F_OVERRIDE_3).body(bb -> {\n@@ -268,1 +265,1 @@\n-                    b.op(return_(b.op(invoke(MethodRef.method(currentClass, OP_BUILDER_F_NAME, OP_BUILDER_F_OVERRIDE_2),\n+                    b.op(return_(b.op(funcCall(OP_BUILDER_F_NAME_2, OP_BUILDER_F_OVERRIDE_2,\n@@ -281,2 +278,1 @@\n-    OpBuilder(JavaType currentClass, Function<Block.Builder, Value> dialectFactoryF) {\n-        this.currentClass = currentClass;\n+    OpBuilder(Function<Block.Builder, Value> dialectFactoryF) {\n@@ -290,2 +286,1 @@\n-        this.dialectFactory = dialectFactoryF.apply(builder);\n-        this.opFactory = builder.op(invoke(DIALECT_FACTORY_OP_FACTORY, dialectFactory));\n+        var dialectFactory = dialectFactoryF.apply(builder);\n@@ -359,4 +354,4 @@\n-        FunctionType override =\n-                blockBuilder == null ? OP_BUILDER_F_OVERRIDE_1\n-                : location == Location.NO_LOCATION || location.sourceRef() != null\n-                ? OP_BUILDER_F_OVERRIDE_2 : OP_BUILDER_F_OVERRIDE_3;\n+\n+        boolean bb = blockBuilder != null;\n+        boolean simpleLoc = bb && location != null && location.sourceRef() == null;\n+\n@@ -364,1 +359,1 @@\n-        if (override != OP_BUILDER_F_OVERRIDE_1) {\n+        if (bb) {\n@@ -368,1 +363,1 @@\n-        if (override == OP_BUILDER_F_OVERRIDE_3) {\n+        if (simpleLoc) {\n@@ -379,1 +374,3 @@\n-        return builder.op(invoke(MethodRef.method(currentClass, \"::op\", override), args));\n+        return builder.op(bb ? simpleLoc ? funcCall(OP_BUILDER_F_NAME_3, OP_BUILDER_F_OVERRIDE_3, args)\n+                                         : funcCall(OP_BUILDER_F_NAME_2, OP_BUILDER_F_OVERRIDE_2, args)\n+                             : funcCall(OP_BUILDER_F_NAME_1, OP_BUILDER_F_OVERRIDE_1, args));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":39,"deletions":42,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -115,0 +115,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n@@ -154,1 +156,1 @@\n-    private List<CoreOp.FuncOp> classOps;\n+    private SequencedMap<String, Op> ops;\n@@ -195,1 +197,2 @@\n-                classOps.add(opBuilder(methodName(symbolToMethodRef(tree.sym)).toString(), funcOp));\n+                Name methodName = methodName(symbolToMethodRef(tree.sym));\n+                ops.put(methodName.toString(), funcOp);\n@@ -208,1 +211,1 @@\n-        List<CoreOp.FuncOp> prevClassOps = classOps;\n+        SequencedMap<String, Op> prevOps = ops;\n@@ -217,1 +220,1 @@\n-            classOps = new ArrayList<>();\n+            ops = new LinkedHashMap<>();\n@@ -219,4 +222,2 @@\n-            if (!classOps.isEmpty()) {\n-                String synthClassName = synthClassSym.flatName().toString();\n-                classOps.addAll(OpBuilder.createSupportFunctions(JavaType.type(ClassDesc.of(synthClassName))));\n-                synthClassDecl(synthClassName, classOps);\n+            if (!ops.isEmpty()) {\n+                synthClassDecl();\n@@ -227,1 +228,1 @@\n-            classOps = prevClassOps;\n+            ops = prevOps;\n@@ -255,2 +256,1 @@\n-            CoreOp.FuncOp opMethod = opBuilder(lambdaName.toString(), funcOp);\n-            classOps.add(opMethod);\n+            ops.put(lambdaName.toString(), funcOp);\n@@ -287,2 +287,1 @@\n-            CoreOp.FuncOp opMethod = opBuilder(lambdaName.toString(), funcOp);\n-            classOps.add(opMethod);\n+            ops.put(lambdaName.toString(), funcOp);\n@@ -368,1 +367,1 @@\n-    private CoreOp.FuncOp opBuilder(String methodName, CoreOp.FuncOp op) {\n+    private CoreOp.ModuleOp opBuilder() {\n@@ -373,3 +372,1 @@\n-                symbolToErasedDesc(synthClassSym),\n-                methodName,\n-                op,\n+                ops,\n@@ -388,1 +385,1 @@\n-    private Type synthClassDecl(String className, List<CoreOp.FuncOp> funcs) {\n+    private void synthClassDecl() {\n@@ -396,0 +393,2 @@\n+            String className = synthClassSym.flatName().toString();\n+            ClassDesc classDesc = ClassDesc.of(className);\n@@ -397,1 +396,0 @@\n-            ClassDesc synthCD = ClassDesc.of(className);\n@@ -399,9 +397,6 @@\n-            byte[] data = BytecodeGenerator.generateClassData(\n-                        MethodHandles.lookup(),\n-                        synthCD,\n-                        CoreOp.FuncOp::funcName,\n-                        clb -> {\n-                            clb.with(InnerClassesAttribute.of(InnerClassInfo.of(synthCD, Optional.of(parentClass), Optional.of(\"$CM\"))));\n-                            clb.with(NestHostAttribute.of(parentClass));\n-                        },\n-                        funcs.toArray(CoreOp.FuncOp[]::new));\n+            CoreOp.ModuleOp module = opBuilder();\n+            byte[] data = BytecodeGenerator.generateClassData(MethodHandles.lookup(), classDesc, module);\n+            \/\/ inject InnerClassesAttribute and NestHostAttribute\n+            data = ClassFile.of().transformClass(ClassFile.of().parse(data), ClassTransform.endHandler(clb ->\n+                    clb.with(InnerClassesAttribute.of(InnerClassInfo.of(classDesc, Optional.of(parentClass), Optional.of(\"$CM\"), ClassFile.ACC_STATIC)))\n+                       .with(NestHostAttribute.of(parentClass))));\n@@ -411,1 +406,1 @@\n-            return syms.enterClass(currentClassSym.packge().modle, className);\n+            syms.enterClass(currentClassSym.packge().modle, className);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":24,"deletions":29,"binary":false,"changes":53,"status":"modified"}]}