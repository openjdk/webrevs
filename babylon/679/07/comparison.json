{"files":[{"patch":"@@ -51,1 +51,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -69,0 +68,1 @@\n+import java.util.function.Function;\n@@ -72,0 +72,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.SequencedMap;\n@@ -140,0 +142,16 @@\n+    \/**\n+     * Transforms the invokable operation to bytecode encapsulated in a method of a class file.\n+     *\n+     * @param lookup the lookup\n+     * @param clName the name to use for the method of the class file\n+     * @param mop the module operation to transform to bytecode\n+     * @return the class file bytes\n+     *\/\n+    public static byte[] generateClassData(MethodHandles.Lookup lookup,\n+                                           ClassDesc clName,\n+                                           ModuleOp mop) {\n+        ClassModel generatedModel = ClassFile.of().parse(generateClassData(lookup, clName, mop.functionTable()));\n+        \/\/ Compact locals of the generated bytecode\n+        return ClassFile.of().transformClass(generatedModel, LocalsCompactor.INSTANCE);\n+    }\n+\n@@ -152,4 +170,0 @@\n-        if (!iop.capturedValues().isEmpty()) {\n-            throw new UnsupportedOperationException(\"Operation captures values\");\n-        }\n-\n@@ -157,1 +171,1 @@\n-        ClassDesc className = ClassDesc.of(packageName.isEmpty()\n+        ClassDesc clsName = ClassDesc.of(packageName.isEmpty()\n@@ -160,1 +174,8 @@\n-        byte[] classBytes = ClassFile.of().build(className, clb -> {\n+        return generateClassData(lookup, clsName, new LinkedHashMap<>(Map.of(name, iop)));\n+    }\n+\n+    private static <O extends Op & Op.Invokable> byte[] generateClassData(MethodHandles.Lookup lookup,\n+                                                                          ClassDesc clName,\n+                                                                          SequencedMap<String, ? extends O> ops) {\n+\n+        byte[] classBytes = ClassFile.of().build(clName, clb -> {\n@@ -163,1 +184,3 @@\n-            generateMethod(lookup, className, name, iop, clb, lambdaSink, quotable);\n+            for (var e : ops.sequencedEntrySet()) {\n+                generateMethod(lookup, clName, e.getKey(), e.getValue(), clb, ops, lambdaSink, quotable);\n+            }\n@@ -176,1 +199,1 @@\n-                generateMethod(lookup, className, \"lambda$\" + i, lop, clb, lambdaSink, quotable);\n+                generateMethod(lookup, clName, \"lambda$\" + i, lop, clb, ops, lambdaSink, quotable);\n@@ -187,0 +210,1 @@\n+                                                                     SequencedMap<String, ? extends O> functionTable,\n@@ -197,1 +221,1 @@\n-                                          iop.body().blocks(), cob, lambdaSink, quotable).generate()));\n+                                          iop.body().blocks(), cob, functionTable, lambdaSink, quotable).generate()));\n@@ -214,0 +238,1 @@\n+    private final Map<String, ? extends Invokable> functionMap;\n@@ -226,0 +251,1 @@\n+                              Map<String, ? extends Invokable> functionMap,\n@@ -240,0 +266,1 @@\n+        this.functionMap = functionMap;\n@@ -807,1 +834,1 @@\n-                        final boolean isInterface = refClass.isInterface();\n+                        boolean isInterface =  refClass.isInterface();\n@@ -837,0 +864,20 @@\n+                    case FuncCallOp op -> {\n+                        Invokable fop = functionMap.get(op.funcName());\n+                        if (fop == null) {\n+                            throw new IllegalArgumentException(\"Could not resolve function: \" + op.funcName());\n+                        }\n+                        processOperands(op);\n+                        MethodTypeDesc mDesc = MethodRef.toNominalDescriptor(fop.invokableType());\n+                        cob.invoke(\n+                                Opcode.INVOKESTATIC,\n+                                className,\n+                                op.funcName(),\n+                                mDesc,\n+                                false);\n+                        ClassDesc ret = toClassDesc(op.resultType());\n+                        if (ret.isClassOrInterface() && !ret.equals(mDesc.returnType())) {\n+                            \/\/ Explicit cast if method return type differs\n+                            cob.checkcast(ret);\n+                        }\n+                        push(op.result());\n+                    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":58,"deletions":11,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -114,3 +114,0 @@\n-    static final MethodRef LOCATION_FROM_STRING = MethodRef.method(J_C_LOCATION, \"fromString\",\n-            J_C_LOCATION, J_L_STRING);\n-\n@@ -129,0 +126,51 @@\n+    static final MethodRef LIST_EMPTY = MethodRef.method(List.class, \"of\", List.class);\n+    static final MethodRef LIST_OF_OBJECT = MethodRef.method(List.class, \"of\", List.class, Object.class);\n+    static final MethodRef MAP_EMPTY = MethodRef.method(Map.class, \"of\", Map.class);\n+    static final MethodRef MAP_OF_OBJECT_OBJECT = MethodRef.method(Map.class, \"of\", Map.class, Object.class, Object.class);\n+\n+    static final String LIST_BUILDER_F_NAME = \"$list\";\n+    static final String MAP_BUILDER_F_NAME = \"$map\";\n+    static final String OP_BUILDER_F_NAME_1 = \"$op1\";\n+    static final String OP_BUILDER_F_NAME_2 = \"$op2\";\n+    static final String OP_BUILDER_F_NAME_3 = \"$op3\";\n+\n+    static final FunctionType LIST_BUILDER_F_TYPE = functionType(\n+            J_U_LIST,\n+            J_L_OBJECT);\n+\n+    static final FunctionType MAP_BUILDER_F_TYPE = functionType(\n+            J_U_MAP,\n+            J_L_OBJECT);\n+\n+    static final FunctionType OP_BUILDER_F_OVERRIDE_1 = functionType(\n+            type(Op.class),\n+            J_L_STRING, \/\/ op name\n+            J_C_LOCATION, \/\/ location: Location or null\n+            J_L_OBJECT, \/\/ operand(s): Value, List<Value> or null\n+            J_L_OBJECT, \/\/ successor(s): Block.Reference, List<Block.Reference> or null\n+            J_L_OBJECT, \/\/ result type: TypeElement or null for void\n+            J_L_OBJECT, \/\/ attribute(s): Map<String, Object>, Object or null\n+            J_L_OBJECT); \/\/ body definition(s): Body.Builder, List<Body.Builder> or null\n+\n+    static final FunctionType OP_BUILDER_F_OVERRIDE_2 = functionType(\n+            type(Op.Result.class),\n+            type(Block.Builder.class),\n+            J_L_STRING, \/\/ op name\n+            J_C_LOCATION, \/\/ location: Location or null\n+            J_L_OBJECT, \/\/ operand(s): Value, List<Value> or null\n+            J_L_OBJECT, \/\/ successor(s): Block.Reference, List<Block.Reference> or null\n+            J_L_OBJECT, \/\/ result type: TypeElement or null for void\n+            J_L_OBJECT, \/\/ attribute(s): Map<String, Object>, Object or null\n+            J_L_OBJECT); \/\/ body definition(s): Body.Builder, List<Body.Builder> or null\n+\n+    static final FunctionType OP_BUILDER_F_OVERRIDE_3 = functionType(\n+            type(Op.Result.class),\n+            type(Block.Builder.class),\n+            J_L_STRING, \/\/ op name\n+            INT, \/\/ location.line\n+            INT, \/\/ location.columnt\n+            J_L_OBJECT, \/\/ operand(s): Value, List<Value> or null\n+            J_L_OBJECT, \/\/ successor(s): Block.Reference, List<Block.Reference> or null\n+            J_L_OBJECT, \/\/ result type: TypeElement or null for void\n+            J_L_OBJECT, \/\/ attribute(s): Map<String, Object>, Object or null\n+            J_L_OBJECT); \/\/ body definition(s): Body.Builder, List<Body.Builder> or null\n@@ -140,4 +188,0 @@\n-    final Value dialectFactory;\n-\n-    final Value opFactory;\n-\n@@ -154,1 +198,2 @@\n-     * @param op the code model.\n+     * @param ops the named code models.\n+     * @param functionNameF a function that defines method names of the code models\n@@ -156,1 +201,1 @@\n-     * @return the building code model.\n+     * @return the module with building code models and support functions.\n@@ -158,2 +203,133 @@\n-    public static FuncOp createBuilderFunction(Op op, Function<Block.Builder, Value> dialectFactoryF) {\n-        return new OpBuilder(dialectFactoryF).build(op);\n+    public static ModuleOp createBuilderFunctions(SequencedMap<String, ? extends Op> ops, Function<Block.Builder, Value> dialectFactoryF) {\n+        List<FuncOp> funcs = new ArrayList<>();\n+        for (var e : ops.sequencedEntrySet()) {\n+            funcs.add(new OpBuilder(dialectFactoryF).build(e.getKey(), e.getValue()));\n+        }\n+        funcs.addAll(createSupportFunctions(dialectFactoryF));\n+        ModuleOp module = module(funcs);\n+        module.seal();\n+        return module;\n+    }\n+\n+    static List<FuncOp> createSupportFunctions(Function<Block.Builder, Value> dialectFactoryF) {\n+        return List.of(\n+                \/\/ static List $list(Object o) {\n+                \/\/     if (o == null) return List.of();\n+                \/\/     if (o instanceof List) return (List)o;\n+                \/\/     return List.of(o);\n+                \/\/ }\n+                func(LIST_BUILDER_F_NAME, LIST_BUILDER_F_TYPE).body(bb -> {\n+                    Block.Builder b0 = bb.entryBlock(), b1 = b0.block(), b2 = b0.block(), b3 = b0.block(), b4 = b0.block();\n+                    Value arg = b0.parameters().get(0);\n+                    b0.op(conditionalBranch(b0.op(eq(arg, b0.op(constant(J_L_OBJECT, null)))), b1.successor(), b2.successor()));\n+                    b1.op(return_(b1.op(invoke(LIST_EMPTY))));\n+                    b2.op(conditionalBranch(b2.op(instanceOf(J_U_LIST, arg)), b3.successor(), b4.successor()));\n+                    b3.op(return_(b3.op(cast(J_U_LIST, arg))));\n+                    b4.op(return_(b4.op(invoke(LIST_OF_OBJECT, arg))));\n+                }),\n+                \/\/ static Map $map(Object o) {\n+                \/\/     if (o == null) return Map.of();\n+                \/\/     if (o instanceof Map) return (Map)o;\n+                \/\/     return Map.of(\"\", o);\n+                \/\/ }\n+                func(MAP_BUILDER_F_NAME, MAP_BUILDER_F_TYPE).body(bb -> {\n+                    Block.Builder b0 = bb.entryBlock(), b1 = b0.block(), b2 = b0.block(), b3 = b0.block(), b4 = b0.block();\n+                    Value arg = b0.parameters().get(0);\n+                    b0.op(conditionalBranch(b0.op(eq(arg, b0.op(constant(J_L_OBJECT, null)))), b1.successor(), b2.successor()));\n+                    b1.op(return_(b1.op(invoke(MAP_EMPTY))));\n+                    b2.op(conditionalBranch(b2.op(instanceOf(J_U_MAP, arg)), b3.successor(), b4.successor()));\n+                    b3.op(return_(b3.op(cast(J_U_MAP, arg))));\n+                    b4.op(return_(b4.op(invoke(MAP_OF_OBJECT_OBJECT, b4.op(constant(J_L_STRING, \"\")), arg))));\n+                }),\n+                \/\/ static Op $op1(String name,\n+                \/\/                Location location,\n+                \/\/                Object operands,\n+                \/\/                Object successors,\n+                \/\/                TypeElement resultType,\n+                \/\/                Object attributes,\n+                \/\/                Object bodyDefinitions) {\n+                \/\/     return <dialect factory>.opFactory().constructOp(\n+                \/\/             new ExternalizedOp(name,\n+                \/\/                                location,\n+                \/\/                                $list(operands),\n+                \/\/                                $list(successors),\n+                \/\/                                resultType,\n+                \/\/                                $map(attributes),\n+                \/\/                                $list(bodyDefinitions)));\n+                \/\/ }\n+                func(OP_BUILDER_F_NAME_1, OP_BUILDER_F_OVERRIDE_1).body(bb -> {\n+                    Block.Builder b = bb.entryBlock();\n+                    List<Block.Parameter> args = b.parameters();\n+                    b.op(return_(b.op(invoke(OP_FACTORY_CONSTRUCT,\n+                            b.op(invoke(DIALECT_FACTORY_OP_FACTORY, dialectFactoryF.apply(b))),\n+                            b.op(new_(MethodRef.constructor(EXTERNALIZED_OP_F_TYPE),\n+                                    args.get(0),\n+                                    args.get(1),\n+                                    b.op(funcCall(LIST_BUILDER_F_NAME, LIST_BUILDER_F_TYPE, args.get(2))),\n+                                    b.op(funcCall(LIST_BUILDER_F_NAME, LIST_BUILDER_F_TYPE, args.get(3))),\n+                                    args.get(4),\n+                                    b.op(funcCall(MAP_BUILDER_F_NAME, MAP_BUILDER_F_TYPE, args.get(5))),\n+                                    b.op(funcCall(LIST_BUILDER_F_NAME, LIST_BUILDER_F_TYPE, args.get(6)))))))));\n+                }),\n+                \/\/ static Op.Result $op2(Block.Builder b,\n+                \/\/                       String name,\n+                \/\/                       Location location,\n+                \/\/                       Object operands,\n+                \/\/                       Object successors,\n+                \/\/                       TypeElement resultType,\n+                \/\/                       Object attributes,\n+                \/\/                       Object bodyDefinitions) {\n+                \/\/     return b.op($op1(name,\n+                \/\/                      location,\n+                \/\/                      operands,\n+                \/\/                      successors,\n+                \/\/                      resultType,\n+                \/\/                      attributes,\n+                \/\/                      bodyDefinitions));\n+                \/\/ }\n+                func(OP_BUILDER_F_NAME_2, OP_BUILDER_F_OVERRIDE_2).body(bb -> {\n+                    Block.Builder b = bb.entryBlock();\n+                    List<Block.Parameter> args = b.parameters();\n+                    b.op(return_(b.op(invoke(BLOCK_BUILDER_OP,\n+                            args.get(0),\n+                            b.op(funcCall(OP_BUILDER_F_NAME_1, OP_BUILDER_F_OVERRIDE_1,\n+                                    args.get(1),\n+                                    args.get(2),\n+                                    args.get(3),\n+                                    args.get(4),\n+                                    args.get(5),\n+                                    args.get(6),\n+                                    args.get(7)))))));\n+                }),\n+                \/\/ static Op.Result $op3(Block.Builder b,\n+                \/\/                       String name,\n+                \/\/                       int line,\n+                \/\/                       int column,\n+                \/\/                       Object operands,\n+                \/\/                       Object successors,\n+                \/\/                       TypeElement resultType,\n+                \/\/                       Object attributes,\n+                \/\/                       Object bodyDefinitions) {\n+                \/\/     return $op2(b,\n+                \/\/                 name,\n+                \/\/                 new Location(line, column),\n+                \/\/                 operands,\n+                \/\/                 successors,\n+                \/\/                 resultType,\n+                \/\/                 attributes,\n+                \/\/                 bodyDefinitions);\n+                \/\/ }\n+                func(OP_BUILDER_F_NAME_3, OP_BUILDER_F_OVERRIDE_3).body(bb -> {\n+                    Block.Builder b = bb.entryBlock();\n+                    List<Block.Parameter> args = b.parameters();\n+                    b.op(return_(b.op(funcCall(OP_BUILDER_F_NAME_2, OP_BUILDER_F_OVERRIDE_2,\n+                            args.get(0),\n+                            args.get(1),\n+                            b.op(new_(MethodRef.constructor(Location.class, int.class, int.class), args.get(2), args.get(3))),\n+                            args.get(4),\n+                            args.get(5),\n+                            args.get(6),\n+                            args.get(7),\n+                            args.get(8)))));\n+                })\n+        );\n@@ -170,2 +346,1 @@\n-        this.dialectFactory = dialectFactoryF.apply(builder);\n-        this.opFactory = builder.op(invoke(DIALECT_FACTORY_OP_FACTORY, dialectFactory));\n+        var dialectFactory = dialectFactoryF.apply(builder);\n@@ -175,1 +350,1 @@\n-    FuncOp build(Op op) {\n+    FuncOp build(String name, Op op) {\n@@ -177,1 +352,1 @@\n-        Value result = buildOp(ancestorBody, op);\n+        Value result = buildOp(null, ancestorBody, op);\n@@ -182,2 +357,1 @@\n-        \/\/ @@@ avoid use of opName\n-        return func(\"builder.\" + op.getClass().getName(), builder.parentBody());\n+        return func(name, builder.parentBody());\n@@ -187,1 +361,1 @@\n-    Value buildOp(Value ancestorBody, Op inputOp) {\n+    Value buildOp(Value blockBuilder, Value ancestorBody, Op inputOp) {\n@@ -219,1 +393,2 @@\n-        Value opDef = buildOpDefinition(\n+        return buildOp(\n+                blockBuilder,\n@@ -228,1 +403,0 @@\n-        return builder.op(invoke(OP_FACTORY_CONSTRUCT, opFactory, opDef));\n@@ -231,0 +405,33 @@\n+    Value buildOp(Value blockBuilder,\n+                  Op inputOp,\n+                  String name,\n+                  Location location,\n+                  List<Value> operands,\n+                  List<Value> successors,\n+                  TypeElement resultType,\n+                  Map<String, Object> attributes,\n+                  List<Value> bodies) {\n+\n+        boolean bb = blockBuilder != null;\n+        boolean simpleLoc = bb && location != null && location.sourceRef() == null;\n+\n+        List<Value> args = new ArrayList<>();\n+        if (bb) {\n+            args.add(blockBuilder);\n+        }\n+        args.add(builder.op(constant(J_L_STRING, name)));\n+        if (simpleLoc) {\n+            args.add(builder.op(constant(INT, location.line())));\n+            args.add(builder.op(constant(INT, location.column())));\n+        } else {\n+            args.add(buildLocation(location));\n+        }\n+        args.add(buildFlexibleList(type(Value.class), operands));\n+        args.add(buildFlexibleList(type(Block.Reference.class), successors));\n+        args.add(buildType(resultType));\n+        args.add(buildAttributeMap(inputOp, attributes));\n+        args.add(buildFlexibleList(type(Body.Builder.class), bodies));\n+        return builder.op(bb ? simpleLoc ? funcCall(OP_BUILDER_F_NAME_3, OP_BUILDER_F_OVERRIDE_3, args)\n+                                         : funcCall(OP_BUILDER_F_NAME_2, OP_BUILDER_F_OVERRIDE_2, args)\n+                             : funcCall(OP_BUILDER_F_NAME_1, OP_BUILDER_F_OVERRIDE_1, args));\n+    }\n@@ -232,17 +439,6 @@\n-    Value buildOpDefinition(Op inputOp,\n-                            String name,\n-                            Location location,\n-                            List<Value> operands,\n-                            List<Value> successors,\n-                            TypeElement resultType,\n-                            Map<String, Object> attributes,\n-                            List<Value> bodies) {\n-        List<Value> args = List.of(\n-                builder.op(constant(J_L_STRING, name)),\n-                buildLocation(location),\n-                buildList(type(Value.class), operands),\n-                buildList(type(Block.Reference.class), successors),\n-                buildType(resultType),\n-                buildAttributeMap(inputOp, attributes),\n-                buildList(type(Body.Builder.class), bodies));\n-        return builder.op(new_(MethodRef.constructor(EXTERNALIZED_OP_F_TYPE), args));\n+    Value buildFlexibleList(JavaType elementType, List<Value> elements) {\n+        return switch (elements.size()) {\n+            case 0 -> builder.op(constant(elementType, null));\n+            case 1 -> elements.getFirst();\n+            default -> buildList(elementType, elements);\n+        };\n@@ -255,2 +451,4 @@\n-            return builder.op(invoke(LOCATION_FROM_STRING,\n-                    builder.op(constant(J_L_STRING, l.toString()))));\n+            return builder.op(new_(MethodRef.constructor(Location.class, String.class, int.class, int.class),\n+                    builder.op(constant(J_L_STRING, l.sourceRef())),\n+                    builder.op(constant(INT, l.line())),\n+                    builder.op(constant(INT, l.column()))));\n@@ -291,3 +489,1 @@\n-                Value op = buildOp(body, inputOp);\n-                Value result = builder.op(invoke(BLOCK_BUILDER_OP, block, op));\n-                valueMap.put(inputOp.result(), result);\n+                valueMap.put(inputOp.result(), buildOp(block, body, inputOp));\n@@ -336,0 +532,6 @@\n+        if (attributes.isEmpty()) {\n+            return builder.op(constant(type(Map.class), null));\n+        }\n+        if (attributes.size() == 1 && attributes.get(\"\") instanceof Object o) {\n+            return buildAttributeValue(o);\n+        }\n@@ -346,0 +548,4 @@\n+    private Value box(TypeElement to, Value v) {\n+        return builder.op(invoke(MethodRef.method(to, \"valueOf\", to, v.type()), v));\n+    }\n+\n@@ -348,33 +554,22 @@\n-            case Boolean v -> {\n-                yield builder.op(constant(BOOLEAN, value));\n-            }\n-            case Byte v -> {\n-                yield builder.op(constant(BYTE, value));\n-            }\n-            case Short v -> {\n-                yield builder.op(constant(SHORT, value));\n-            }\n-            case Character v -> {\n-                yield builder.op(constant(CHAR, value));\n-            }\n-            case Integer v -> {\n-                yield builder.op(constant(INT, value));\n-            }\n-            case Long v -> {\n-                yield builder.op(constant(LONG, value));\n-            }\n-            case Float v -> {\n-                yield builder.op(constant(FLOAT, value));\n-            }\n-            case Double v -> {\n-                yield builder.op(constant(DOUBLE, value));\n-            }\n-            case Class<?> v -> {\n-                yield buildType(JavaType.type(v));\n-            }\n-            case String s -> {\n-                yield builder.op(constant(J_L_STRING, value));\n-            }\n-            case TypeElement f -> {\n-                yield buildType(f);\n-            }\n+            case Boolean _ ->\n+                box(J_L_BOOLEAN, builder.op(constant(BOOLEAN, value)));\n+            case Byte _ ->\n+                box(J_L_BYTE, builder.op(constant(BYTE, value)));\n+            case Short _ ->\n+                box(J_L_SHORT, builder.op(constant(SHORT, value)));\n+            case Character _ ->\n+                box(J_L_CHARACTER, builder.op(constant(CHAR, value)));\n+            case Integer _ ->\n+                box(J_L_INTEGER, builder.op(constant(INT, value)));\n+            case Long _ ->\n+                box(J_L_LONG, builder.op(constant(LONG, value)));\n+            case Float _ ->\n+                box(J_L_FLOAT, builder.op(constant(FLOAT, value)));\n+            case Double _ ->\n+                box(J_L_DOUBLE, builder.op(constant(DOUBLE, value)));\n+            case Class<?> v ->\n+                buildType(JavaType.type(v));\n+            case String s ->\n+                builder.op(constant(J_L_STRING, value));\n+            case TypeElement f ->\n+                buildType(f);\n@@ -385,2 +580,2 @@\n-            case Object o when value == ExternalizedOp.NULL_ATTRIBUTE_VALUE -> {\n-                yield builder.op(fieldLoad(FieldRef.field(ExternalizedOp.class,\n+            case Object o when value == ExternalizedOp.NULL_ATTRIBUTE_VALUE ->\n+                builder.op(fieldLoad(FieldRef.field(ExternalizedOp.class,\n@@ -388,1 +583,0 @@\n-            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":272,"deletions":78,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -113,0 +113,11 @@\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.NestHostAttribute;\n+import java.lang.invoke.MethodHandles;\n+import javax.tools.JavaFileManager;\n+import javax.tools.StandardLocation;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -138,0 +149,1 @@\n+    private final JavaFileManager fileManager;\n@@ -145,1 +157,2 @@\n-    private Symbol.ClassSymbol currentClassSym;\n+    private SequencedMap<String, Op> ops;\n+    private Symbol.ClassSymbol currentClassSym, synthClassSym;\n@@ -166,0 +179,1 @@\n+        fileManager = context.get(JavaFileManager.class);\n@@ -184,1 +198,3 @@\n-                classOps.add(opMethodDecl(methodName(symbolToMethodRef(tree.sym)), funcOp, codeModelStorageOption));\n+                Name methodName = methodName(symbolToMethodRef(tree.sym));\n+                classOps.add(opMethodDecl(methodName));\n+                ops.put(methodName.toString(), funcOp);\n@@ -198,0 +214,1 @@\n+        SequencedMap<String, Op> prevOps = ops;\n@@ -199,0 +216,1 @@\n+        Symbol.ClassSymbol prevSynthClassSym = synthClassSym;\n@@ -205,0 +223,2 @@\n+            synthClassSym = new ClassSymbol(0, names.fromString(\"$CM\"), currentClassSym);\n+            ops = new LinkedHashMap<>();\n@@ -207,0 +227,4 @@\n+            if (!ops.isEmpty()) {\n+                synthClassDecl();\n+                currentClassSym.members().enter(synthClassSym);\n+            }\n@@ -210,0 +234,1 @@\n+            ops = prevOps;\n@@ -211,0 +236,1 @@\n+            synthClassSym = prevSynthClassSym;\n@@ -234,1 +260,2 @@\n-            JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n+            Name lambdaName = lambdaName();\n+            JCMethodDecl opMethod = opMethodDecl(lambdaName);\n@@ -236,0 +263,1 @@\n+            ops.put(lambdaName.toString(), funcOp);\n@@ -265,1 +293,3 @@\n-            JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n+            Name lambdaName = lambdaName();\n+            ops.put(lambdaName.toString(), funcOp);\n+            JCMethodDecl opMethod = opMethodDecl(lambdaName);\n@@ -346,1 +376,1 @@\n-    private JCMethodDecl opMethodDecl(Name methodName, CoreOp.FuncOp op, CodeModelStorageOption codeModelStorageOption) {\n+    private JCMethodDecl opMethodDecl(Name methodName) {\n@@ -353,0 +383,7 @@\n+        \/\/ Create the method body calling the synthetic inner class method of the same name\n+        var body = make.Return(make.App(make.Ident(new MethodSymbol(PRIVATE | STATIC | SYNTHETIC, methodName, mt, synthClassSym))));\n+        var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(body)));\n+        return md;\n+    }\n+\n+    private CoreOp.ModuleOp opBuilder() {\n@@ -356,1 +393,2 @@\n-        var opBuilder = OpBuilder.createBuilderFunction(op,\n+        return OpBuilder.createBuilderFunctions(\n+                ops,\n@@ -359,2 +397,0 @@\n-        var codeModelTranslator = new CodeModelTranslator();\n-        var body = codeModelTranslator.translateFuncOp(opBuilder, ms);\n@@ -362,2 +398,27 @@\n-        var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(body)));\n-        return md;\n+    }\n+\n+    private void synthClassDecl() {\n+        try {\n+            JavaFileManager.Location outLocn;\n+            if (fileManager.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {\n+                outLocn = fileManager.getLocationForModule(StandardLocation.CLASS_OUTPUT, currentClassSym.packge().modle.name.toString());\n+            } else {\n+                outLocn = StandardLocation.CLASS_OUTPUT;\n+            }\n+            String className = synthClassSym.flatName().toString();\n+            ClassDesc classDesc = ClassDesc.of(className);\n+            JavaFileObject outFile = fileManager.getJavaFileForOutput(outLocn, className, JavaFileObject.Kind.CLASS, currentClassSym.sourcefile);\n+            ClassDesc parentClass = ClassDesc.of(currentClassSym.className());\n+            CoreOp.ModuleOp module = opBuilder();\n+            byte[] data = BytecodeGenerator.generateClassData(MethodHandles.lookup(), classDesc, module);\n+            \/\/ inject InnerClassesAttribute and NestHostAttribute\n+            data = ClassFile.of().transformClass(ClassFile.of().parse(data), ClassTransform.endHandler(clb ->\n+                    clb.with(InnerClassesAttribute.of(InnerClassInfo.of(classDesc, Optional.of(parentClass), Optional.of(\"$CM\"), ClassFile.ACC_STATIC)))\n+                       .with(NestHostAttribute.of(parentClass))));\n+            try (OutputStream out = outFile.openOutputStream()) {\n+                out.write(data);\n+            }\n+            syms.enterClass(currentClassSym.packge().modle, className);\n+        } catch (IOException e) {\n+            throw new IllegalStateException(e);\n+        }\n@@ -2681,150 +2742,0 @@\n-    \/**\n-     * Translate a code model (a function op) into the corresponding AST.\n-     * The input function op is assumed to be generated by {@code OpBuilder}.\n-     *\/\n-    class CodeModelTranslator {\n-        private static final MethodRef M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n-                Op.Result.class, Op.class);\n-        private static final MethodRef M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\",\n-                Block.Parameter.class, TypeElement.class);\n-        private static final MethodRef M_OP_SEAL = MethodRef.method(Op.class, \"seal\", void.class);\n-\n-        private final Map<Value, JCTree> valueToTree = new HashMap<>();\n-        private int localVarCount = 0; \/\/ used to name variables we introduce in the AST\n-\n-        private JCExpression toExpr(JCTree t) {\n-            return switch (t) {\n-                case JCExpression e -> e;\n-                case JCTree.JCVariableDecl vd -> make.Ident(vd);\n-                case null, default -> throw new IllegalArgumentException();\n-            };\n-        }\n-\n-        private JCTree translateInvokeOp(JavaOp.InvokeOp invokeOp) {\n-            Value receiver = (invokeOp.invokeKind() == JavaOp.InvokeOp.InvokeKind.INSTANCE) ?\n-                    invokeOp.operands().get(0) : null;\n-            com.sun.tools.javac.util.List<Value> arguments = invokeOp.operands().stream()\n-                    .skip(receiver == null ? 0 : 1)\n-                    .collect(com.sun.tools.javac.util.List.collector());\n-            var methodSym = methodDescriptorToSymbol(invokeOp.invokeDescriptor());\n-            var meth = (receiver == null) ?\n-                    make.Ident(methodSym) :\n-                    make.Select(toExpr(translateOp(receiver)), methodSym);\n-            var args = new ListBuffer<JCTree.JCExpression>();\n-            for (Value operand : arguments) {\n-                args.add(toExpr(translateOp(operand)));\n-            }\n-            var methodInvocation = make.App(meth, args.toList());\n-            if (invokeOp.isVarArgs()) {\n-                setVarargs(methodInvocation, invokeOp.invokeDescriptor().type());\n-            }\n-            return methodInvocation;\n-        }\n-\n-        private void setVarargs(JCExpression tree, FunctionType type) {\n-            var lastParam = type.parameterTypes().getLast();\n-            if (lastParam instanceof jdk.incubator.code.dialect.java.ArrayType varargType) {\n-                TreeInfo.setVarargsElement(tree, typeElementToType(varargType.componentType()));\n-            } else {\n-                Assert.error(\"Expected trailing array type: \" + type);\n-            }\n-        }\n-\n-        private static final Set<MethodRef> mRefs = Set.of(M_BLOCK_BUILDER_OP, M_BLOCK_BUILDER_PARAM, M_OP_SEAL);\n-        public JCTree.JCStatement translateFuncOp(CoreOp.FuncOp funcOp, MethodSymbol ms) {\n-            Assert.check(funcOp.parameters().isEmpty());\n-            Assert.check(funcOp.body().blocks().size() == 1);\n-\n-            java.util.List<Value> rootValues = funcOp.traverse(new ArrayList<>(), (l, ce) -> {\n-                boolean isRoot = switch (ce) {\n-                    case JavaOp.InvokeOp invokeOp when mRefs.contains(invokeOp.invokeDescriptor()) -> true;\n-                    case CoreOp.ReturnOp _, JavaOp.ArrayAccessOp.ArrayStoreOp _ -> true;\n-                    case Op op when op.result() != null && op.result().uses().size() > 1 -> true;\n-                    default -> false;\n-                };\n-                if (isRoot) {\n-                    l.add(((Op) ce).result());\n-                }\n-                return l;\n-            });\n-\n-            var stats = new ListBuffer<JCTree.JCStatement>();\n-            for (Value root : rootValues) {\n-                JCTree tree = translateOp(root);\n-                if (tree instanceof JCExpression e) {\n-                    if (!root.uses().isEmpty()) {\n-                        var vs = new Symbol.VarSymbol(LocalVarFlags | SYNTHETIC, names.fromString(\"_$\" + localVarCount++), tree.type, ms);\n-                        tree = make.VarDef(vs, e);\n-                        valueToTree.put(root, tree);\n-                    } else {\n-                        tree = make.Exec(e);\n-                    }\n-                }\n-                stats.add((JCTree.JCStatement) tree);\n-            }\n-            var mb = make.Block(0, stats.toList());\n-\n-            return mb;\n-        }\n-\n-        private JCTree translateOp(Value v) {\n-            if (valueToTree.containsKey(v)) {\n-                return valueToTree.get(v);\n-            }\n-            Op op = ((Op.Result) v).op();\n-            JCTree tree = switch (op) {\n-                case CoreOp.ConstantOp constantOp when constantOp.value() == null ->\n-                        make.Literal(TypeTag.BOT, null).setType(syms.botType);\n-                case CoreOp.ConstantOp constantOp -> make.Literal(constantOp.value());\n-                case JavaOp.InvokeOp invokeOp -> translateInvokeOp(invokeOp);\n-                case JavaOp.NewOp newOp when newOp.resultType() instanceof jdk.incubator.code.dialect.java.ArrayType at -> {\n-                    var elemType = make.Ident(typeElementToType(at.componentType()).tsym);\n-                    var dims = new ListBuffer<JCTree.JCExpression>();\n-                    for (int d = 0; d < at.dimensions(); d++) {\n-                        dims.add(toExpr(translateOp(newOp.operands().get(d))));\n-                    }\n-                    var na = make.NewArray(elemType, dims.toList(), null);\n-                    na.type = typeElementToType(at);\n-                    yield na;\n-                }\n-                case JavaOp.NewOp newOp -> {\n-                    var ownerType = typeElementToType(newOp.constructorDescriptor().refType());\n-                    var clazz = make.Ident(ownerType.tsym);\n-                    var args = new ListBuffer<JCTree.JCExpression>();\n-                    for (Value operand : newOp.operands()) {\n-                        args.add(toExpr(translateOp(operand)));\n-                    }\n-                    var nc = make.NewClass(null, null, clazz, args.toList(), null);\n-                    if (newOp.isVarargs()) {\n-                        setVarargs(nc, newOp.constructorDescriptor().type());\n-                    }\n-                    nc.type = ownerType;\n-                    nc.constructor = constructorDescriptorToSymbol(newOp.constructorDescriptor());\n-                    nc.constructorType = nc.constructor.type;\n-                    yield nc;\n-                }\n-                case CoreOp.ReturnOp returnOp -> make.Return(toExpr(translateOp(returnOp.returnValue())));\n-                case JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp -> {\n-                    var sym = fieldDescriptorToSymbol(fieldLoadOp.fieldDescriptor());\n-                    Assert.check(sym.isStatic());\n-                    yield make.Select(make.Ident(sym.owner), sym);\n-                }\n-                case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n-                    var array = arrayStoreOp.operands().get(0);\n-                    var index = arrayStoreOp.operands().get(1);\n-                    var val = arrayStoreOp.operands().get(2);\n-                    var as = make.Assign(\n-                            make.Indexed(\n-                                    toExpr(translateOp(array)), toExpr(translateOp(index))), toExpr(translateOp(val))\n-                    );\n-                    as.type = typeElementToType(((jdk.incubator.code.dialect.java.ArrayType) array.type()).componentType());\n-                    yield as;\n-                }\n-                default ->\n-                        throw new IllegalStateException(\"Op -> JCTree not supported for :\" + op.getClass().getName());\n-            };\n-            valueToTree.put(v, tree);\n-            return tree;\n-        }\n-    }\n-\n@@ -2968,21 +2879,0 @@\n-\n-    VarSymbol fieldDescriptorToSymbol(FieldRef fieldRef) {\n-        Name name = names.fromString(fieldRef.name());\n-        Type site = typeElementToType(fieldRef.refType());\n-        return resolve.resolveInternalField(attrEnv().enclClass, attrEnv(), site, name);\n-    }\n-\n-    MethodSymbol methodDescriptorToSymbol(MethodRef methodRef) {\n-        Name name = names.fromString(methodRef.name());\n-        Type site = typeElementToType(methodRef.refType());\n-        com.sun.tools.javac.util.List<Type> argtypes = methodRef.type().parameterTypes().stream()\n-                .map(this::typeElementToType).collect(com.sun.tools.javac.util.List.collector());\n-        return resolve.resolveInternalMethod(attrEnv().enclClass, attrEnv(), site, name, argtypes, com.sun.tools.javac.util.List.nil());\n-    }\n-\n-    MethodSymbol constructorDescriptorToSymbol(MethodRef constructorRef) {\n-        Type site = typeElementToType(constructorRef.refType());\n-        com.sun.tools.javac.util.List<Type> argtypes = constructorRef.type().parameterTypes().stream()\n-                .map(this::typeElementToType).collect(com.sun.tools.javac.util.List.collector());\n-        return resolve.resolveInternalConstructor(attrEnv().enclClass, attrEnv(), site, argtypes, com.sun.tools.javac.util.List.nil());\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":71,"deletions":181,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -39,0 +38,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n@@ -41,0 +42,1 @@\n+import jdk.incubator.code.dialect.java.FieldRef;\n@@ -126,2 +128,3 @@\n-        CoreOp.FuncOp fb = OpBuilder.createBuilderFunction(fExpected,\n-                b -> b.parameter(JavaType.type(DialectFactory.class)));\n+        CoreOp.ModuleOp module = OpBuilder.createBuilderFunctions(new LinkedHashMap<>(Map.of(fExpected.funcName(), fExpected)),\n+                b -> b.op(JavaOp.fieldLoad(\n+                        FieldRef.field(JavaOp.class, \"JAVA_DIALECT_FACTORY\", DialectFactory.class))));\n@@ -129,1 +132,1 @@\n-                fb, JavaOp.JAVA_DIALECT_FACTORY);\n+                module.functionTable().get(fExpected.funcName()));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestCodeBuilder.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"}]}