{"files":[{"patch":"@@ -17,4 +17,3 @@\n-6. [`DialectWithInvoke`][https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectWithInvoke.java]:\n-Example of creating a dialect that replaces `Invoke` `Op` with a specific signature with a new `Op`. The dialect is handled as an intrinsic replacement.\n-6. [`DialectFMAOp`][https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectFMAOp.java]: Example of how to extend the code reflection `Op` to create a new dialect. It analysis the code for substitution of Add(Mult) to create a new `FMA` Op.\n-7. [`DynamicFunctionBuild`][https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DynamicFunctionBuild.java]: Example of how to create a new function dynamically to compute the inverse of a square root. The code model is built dynamically for a new method and it is evaluated in the `Interpreter`.\n+5. [`DialectWithInvoke`](https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectWithInvoke.java): Example of creating a dialect that replaces `Invoke` `Op` with a specific signature with a new `Op`. The dialect is handled as an intrinsic replacement.\n+6. [`DialectFMAOp`](https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectFMAOp.java): Example of how to extend the code reflection `Op` to create a new dialect. It analysis the code for substitution of Add(Mult) to create a new `FMA` Op.\n+7. [`DynamicFunctionBuild`](https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DynamicFunctionBuild.java): Example of how to create a new function dynamically to compute the inverse of a square root. The code model is built dynamically for a new method and it is evaluated in the `Interpreter`.\n","filename":"cr-examples\/samples\/README.md","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Arrays;\n@@ -46,0 +47,1 @@\n+import java.util.stream.Collectors;\n@@ -63,1 +65,1 @@\n- *         $ java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DialectFMAOp\n+ *         $ java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DialectFMAOp\n@@ -125,3 +127,0 @@\n-        \/\/ Flag to indicate FMA operations can be placed\n-        AtomicBoolean isFMADetected = new AtomicBoolean(false);\n-\n@@ -130,20 +129,16 @@\n-        Set<Op> nodesInvolved = new HashSet<>();\n-\n-        Stream<CodeElement<?, ?>> elements = functionModel.elements();\n-        elements.forEach(codeElement -> {\n-            if (codeElement instanceof JavaOp.AddOp addOp) {\n-\n-                \/\/ Obtain dependency list of dependencies and check if any of the\n-                \/\/ input parameters comes from a multiply operation\n-                List<Value> inputOperandsAdd = addOp.operands();\n-                Value addDep = inputOperandsAdd.getFirst();\n-                if (addDep instanceof Op.Result result) {\n-                    if (result.op() instanceof JavaOp.MulOp multOp) {\n-                        \/\/ At this point, we know AddOp uses a value from a\n-                        \/\/ result from a multiplication\n-                        isFMADetected.set(true);\n-                        nodesInvolved.add(multOp);\n-                        nodesInvolved.add(addOp);\n-\n-                        \/\/ we don't stop the traversal to take the opportunity\n-                        \/\/ to annotate all possible FMA operations\n+        Stream<CodeElement<?, ?>> elements = functionModel.elements()\n+                .mapMulti( (codeElement, consumer) -> {\n+                        \/\/ Obtain dependency list of dependencies and check if any of the\n+                        \/\/ input parameters comes from a multiply operation\n+                    if (codeElement instanceof JavaOp.AddOp addOp) {\n+                        List<Value> inputOperandsAdd = addOp.operands();\n+                        Value addDep = inputOperandsAdd.getFirst();\n+                        if (addDep instanceof Op.Result result) {\n+                            if (result.op() instanceof JavaOp.MulOp multOp) {\n+                                \/\/ At this point, we know AddOp uses a value from a\n+                                \/\/ result from a multiplication. Thus, we add them\n+                                \/\/ in the processing list\n+                                consumer.accept(multOp);\n+                                consumer.accept(addOp);\n+                            }\n+                        }\n@@ -151,3 +146,1 @@\n-                }\n-            }\n-        });\n+                });\n@@ -155,1 +148,3 @@\n-        if (!isFMADetected.get()) {\n+        \/\/ Collect the stream to a HashSet\n+        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n@@ -165,2 +160,10 @@\n-                pending[0] = mulOp;\n-                context.mapValue(mulOp.result(), context.getValue(mulOp.operands().getFirst()));\n+\n+                \/\/ If it is only used by one operation, we know it is the one we are replacing.\n+                \/\/ In this case, we can eliminate the node (we don't insert it into the builder)\n+                if (mulOp.result().uses().size() == 1) {\n+                    context.mapValue(mulOp.result(), context.getValue(mulOp.operands().getFirst()));\n+                } else {\n+                    \/\/ We need to insert it into the tree because another non-FMA operation also uses this\n+                    \/\/ operand\n+                    builder.op(op);\n+                }\n@@ -171,1 +174,9 @@\n-                if (nodesInvolved.contains(addOp)) {\n+\n+                \/\/ Obtain the fist operand and check if the value comes from an Mult Op.\n+                \/\/ In that case, we check if the mult node is contained in the set of\n+                \/\/ involved nodes. If all of this is true, then we replace it with an\n+                \/\/ FMA operation.\n+                if (addOp.operands().get(0) instanceof Op.Result r &&\n+                        r.op() instanceof JavaOp.MulOp mulOp\n+                        && nodesInvolved.contains(mulOp)) {\n+\n@@ -173,1 +184,1 @@\n-                    List<Value> inputOperandsMult = pending[0].operands();\n+                    List<Value> inputOperandsMult = mulOp.operands();\n@@ -178,1 +189,0 @@\n-\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectFMAOp.java","additions":43,"deletions":33,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- *         $ java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DialectWithInvoke\n+ *         $ java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DialectWithInvoke\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectWithInvoke.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n- * java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DynamicFunctionBuild\n+ * java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DynamicFunctionBuild\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DynamicFunctionBuild.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- *          java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.HelloCodeReflection\n+ *          java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.HelloCodeReflection\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/HelloCodeReflection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- *      java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.InlineExample\n+ *      java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.InlineExample\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/InlineExample.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n- *         java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.MathOptimizer\n+ *         java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.MathOptimizer\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/MathOptimizer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n- *         java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.MathOptimizerWithInlining\n+ *         java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.MathOptimizerWithInlining\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/MathOptimizerWithInlining.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}