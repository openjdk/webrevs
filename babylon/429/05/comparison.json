{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.util.List;\n@@ -31,0 +32,1 @@\n+import oracle.code.onnx.ir.OnnxOps;\n@@ -104,0 +106,21 @@\n+    \/\/ @@@ this should be generated from contrib operators\n+\n+    public record GroupQueryAttention<T>(Tensor<T> output, Tensor<T> present_key, Tensor<T> present_value) { }\n+    public static <T, M> GroupQueryAttention<T> GroupQueryAttention(Tensor<T> query, java.util.Optional<Tensor<T>> key, java.util.Optional<Tensor<T>> value, java.util.Optional<Tensor<T>> past_key, java.util.Optional<Tensor<T>> past_value, Tensor<M> seqlens_k, Tensor<M> total_sequence_length, java.util.Optional<Tensor<T>> cos_cache, java.util.Optional<Tensor<T>> sin_cache, java.util.Optional<Long> do_rotary, long kv_num_heads, java.util.Optional<Long> local_window_size, long num_heads, java.util.Optional<Long> rotary_interleaved, java.util.Optional<Float> scale) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.GroupQueryAttention.class, List.of(query, key, value, past_key, past_value, seqlens_k, total_sequence_length, cos_cache, sin_cache), List.of(do_rotary, kv_num_heads, local_window_size, num_heads, rotary_interleaved, scale));\n+        Object[] resultArray = (Object[]) result;\n+        return new GroupQueryAttention<>((Tensor<T>)resultArray[0], (Tensor<T>)resultArray[1], (Tensor<T>)resultArray[2]);\n+    }\n+\n+    public static <T1, T2, T3, T4> Tensor<T1> MatMulNBits(Tensor<T1> a, Tensor<T2> b, Tensor<T1> scales, java.util.Optional<Tensor<T3>> zero_points, java.util.Optional<Tensor<T4>> g_idx, java.util.Optional<Tensor<T1>> bias, long K, long N, java.util.Optional<Long> accuracy_level, long bits, long block_size) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.MatMulNBits.class, List.of(a, b, scales, zero_points, g_idx, bias), List.of(K, N, accuracy_level, bits, block_size));\n+        return (Tensor<T1>)result;\n+    }\n+\n+    public record SkipSimplifiedLayerNormalization<T>(Tensor<T> output, Tensor<Float> mean, Tensor<Float> inv_std_var, Tensor<Float> input_skip_bias_sum) { }\n+    public static <T> SkipSimplifiedLayerNormalization<T> SkipSimplifiedLayerNormalization(Tensor<T> input, Tensor<T> skip, Tensor<T> gamma, java.util.Optional<Tensor<T>> bias, java.util.Optional<Float> epsilon) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SkipSimplifiedLayerNormalization.class, List.of(input, skip, gamma, bias), List.of(epsilon));\n+        Object[] resultArray = (Object[]) result;\n+        return new SkipSimplifiedLayerNormalization<>((Tensor<T>)resultArray[0], (Tensor<Float>)resultArray[1], (Tensor<Float>)resultArray[2], (Tensor<Float>)resultArray[3]);\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.SequencedMap;\n@@ -47,0 +50,1 @@\n+import oracle.code.onnx.proto.OnnxModel;\n@@ -56,1 +60,1 @@\n-        private final HashMap<String, String> elementsMap;\n+        private final HashMap<String, String> remap;\n@@ -59,3 +63,19 @@\n-        Indexer(Function<CodeItem, String> baseNames) {\n-            this.baseNames = baseNames;\n-            this.elementsMap = new HashMap<>();\n+        Indexer(Op root, Map<Value, String> explicitNames) {\n+            this.baseNames = OpWriter.computeGlobalNames(root);\n+            this.remap = new HashMap<>();\n+            explicitNames.forEach(this::setName);\n+        }\n+\n+        void setName(Value val, String name) {\n+            remap.put(baseName(val), name);\n+            if (val instanceof Op.Result or && or.op() instanceof CoreOp.TupleLoadOp tlo) {\n+                Value tr = tlo.operands().getFirst();\n+                remap.put(baseName(tr, tlo.index()), name);\n+                if (tr instanceof Op.Result tor && tor.op() instanceof CoreOp.TupleOp to) {\n+                    setName(to.operands().get(tlo.index()), name);\n+                }\n+            }\n+        }\n+\n+        private String baseName(Value value) {\n+            return \"%\" + baseNames.apply(value);\n@@ -65,1 +85,1 @@\n-            var name = \"%\" + baseNames.apply(value);\n+            var name = baseName(value);\n@@ -70,1 +90,2 @@\n-            return nameOf(value, 0);\n+            var name = baseName(value);\n+            return remap.getOrDefault(name, name);\n@@ -75,1 +96,1 @@\n-            return elementsMap.getOrDefault(name, name);\n+            return remap.getOrDefault(name, name);\n@@ -79,1 +100,1 @@\n-            elementsMap.put(baseName(tupleLoadResult, 0), nameOf(tuple, elementIndex));\n+            remap.putIfAbsent(baseName(tupleLoadResult), nameOf(tuple, elementIndex));\n@@ -84,1 +105,1 @@\n-                elementsMap.put(baseName(tuple, i), nameOf(elements.get(i)));\n+                remap.putIfAbsent(baseName(tuple, i), nameOf(elements.get(i)));\n@@ -89,2 +110,9 @@\n-    static byte[] build(String domainName, CoreOp.ModuleOp module, List<oracle.code.onnx.Tensor> initializers) {\n-        var indexer = new Indexer(OpWriter.computeGlobalNames(module));\n+    public static byte[] buildModel(String domain, CoreOp.ModuleOp module, List<Object> initializers) {\n+        return buildModel(domain, module, initializers, Map.of(), _ -> null);\n+    }\n+\n+    public record ExternalTensorDataInfo(String location, long offset, long length) {\n+    }\n+\n+    public static byte[] buildModel(String domain, CoreOp.ModuleOp module, List<Object> initializers, Map<Value, String> explicitValueNames, Function<Tensor, ExternalTensorDataInfo> tensorDataExternalizer) {\n+        var indexer = new Indexer(module, explicitValueNames);\n@@ -93,0 +121,13 @@\n+        var imports = new ArrayList<String>();\n+        if (functions.size() > 1) imports.add(domain); \/\/ self domain import if additional functions\n+        for (var f : functions) {\n+            for (var op : f.body().entryBlock().ops()) { \/\/ auto import of op domains\n+                if (op instanceof OnnxOp) {\n+                    int di = op.opName().lastIndexOf('.');\n+                    if (di > 0) {\n+                        String dn = op.opName().substring(0, di);\n+                        if (!imports.contains(dn)) imports.add(dn);\n+                    }\n+                }\n+            }\n+        }\n@@ -96,3 +137,3 @@\n-        var model = build(\n-                graph(mainFunc.funcName(), domainName, indexer, mainBlock, initializers, 0),\n-                List.of(domainName),\n+        var model = buildModel(\n+                graph(domain, mainFunc.funcName(), indexer, mainBlock, initializers, 0, tensorDataExternalizer),\n+                imports,\n@@ -100,3 +141,2 @@\n-                        function(domainName,\n-                                 f.funcName(),\n-                                 f.parameters().stream().map(indexer::nameOf).toList(),\n+                        function(domain, imports, f.funcName(),\n+                                 expandTuples(indexer, f.parameters()),\n@@ -104,1 +144,1 @@\n-                                 nodes(domainName, indexer, f.body().entryBlock().ops()))).toList());\n+                                 nodes(domain, indexer, f.body().entryBlock().ops()))).toList());\n@@ -106,1 +146,1 @@\n-\/\/        OnnxProtoPrinter.printModel(model);\n+\/\/        System.out.println(OnnxModel.readFrom(model).toText());\n@@ -114,4 +154,4 @@\n-    static byte[] build(Block block, List<oracle.code.onnx.Tensor> initializers) {\n-        var indexer = new Indexer(OpWriter.computeGlobalNames(block.parentBody().parentOp()));\n-        var model = build(graph(null, null, indexer, block, initializers, 0), List.of(), List.of());\n-\/\/        OnnxProtoPrinter.printModel(model);\n+    static byte[] buildModel(Block block, List<oracle.code.onnx.Tensor> initializers) {\n+        var indexer = new Indexer(block.parentBody().parentOp(), Map.of());\n+        var model = buildModel(graph(null, null, indexer, block, initializers, 0), List.of(), List.of());\n+\/\/        System.out.println(OnnxModel.readFrom(model).toText());\n@@ -121,2 +161,2 @@\n-    static byte[] build(List<TensorProto> initializers, List<ValueInfoProto> inputs, List<NodeProto> ops, List<String> outputNames) {\n-        return build(graph(null, initializers, inputs, ops, outputNames), List.of(), List.of());\n+    static byte[] buildModel(List<TensorProto> initializers, List<ValueInfoProto> inputs, List<NodeProto> ops, List<String> outputNames) {\n+        return buildModel(graph(null, initializers, inputs, ops, outputNames), List.of(), List.of());\n@@ -125,2 +165,2 @@\n-    static byte[] build(List<TensorProto> initializers, List<ValueInfoProto> inputs, List<NodeProto> ops, List<String> outputNames, List<String> customImportDomains, List<FunctionProto> functions) {\n-        return build(graph(null, initializers, inputs, ops, outputNames), customImportDomains, functions);\n+    static byte[] buildModel(List<TensorProto> initializers, List<ValueInfoProto> inputs, List<NodeProto> ops, List<String> outputNames, List<String> customImportDomains, List<FunctionProto> functions) {\n+        return buildModel(graph(null, initializers, inputs, ops, outputNames), customImportDomains, functions);\n@@ -129,1 +169,1 @@\n-    static byte[] build(GraphProto graph, List<String> customImportDomains, List<FunctionProto> functions) {\n+    static byte[] buildModel(GraphProto graph, List<String> imports, List<FunctionProto> functions) {\n@@ -133,1 +173,1 @@\n-                .forEach(customImportDomains, (m, d) -> m.opsetImport(new OperatorSetIdProto().domain(d)))\n+                .forEach(imports, (m, d) -> m.opsetImport(new OperatorSetIdProto().domain(d).version(1)))\n@@ -139,1 +179,1 @@\n-    static List<String> expandTuples(Indexer indexer, List<Value> values) {\n+    static List<String> expandTuples(Indexer indexer, List<? extends Value> values) {\n@@ -145,1 +185,1 @@\n-    static void expandTuples(Indexer indexer, List<String> names, List<Value> values) {\n+    static void expandTuples(Indexer indexer, List<String> names, List<? extends Value> values) {\n@@ -160,1 +200,5 @@\n-    static GraphProto graph(String graphName, String domainName, Indexer indexer, Block block, List<oracle.code.onnx.Tensor> initializers, int scalarArgs) {\n+    static GraphProto graph(String domain, String graphName, Indexer indexer, Block block, List<? extends Object> initializers, int scalarArgs) {\n+        return graph(domain, graphName, indexer, block, initializers, scalarArgs, _ -> null);\n+    }\n+\n+    static GraphProto graph(String domain, String graphName, Indexer indexer, Block block, List<? extends Object> initializers, int scalarArgs, Function<Tensor, ExternalTensorDataInfo> tensorDataExternalizer) {\n@@ -166,1 +210,13 @@\n-                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.nameOf(params.get(i + firstInitializer)), initializers.get(i))).toList(),\n+                IntStream.range(0, initializers.size()).boxed().<TensorProto>mapMulti((i, tps) -> {\n+                    Object val = initializers.get(i);\n+                    if (val instanceof Record) {\n+                        var rcs = val.getClass().getRecordComponents();\n+                        for (int rci = 0; rci < rcs.length; rci++) try {\n+                            tps.accept(tensorProto(indexer.nameOf(params.get(i + firstInitializer), rci), (Tensor)(rcs[rci].getAccessor().invoke(val)), tensorDataExternalizer));\n+                        } catch (ReflectiveOperationException e) {\n+                            throw new IllegalArgumentException(e);\n+                        }\n+                    } else {\n+                        tps.accept(tensorProto(indexer.nameOf(params.get(i + firstInitializer)), (Tensor)val, tensorDataExternalizer));\n+                    }\n+                }).toList(),\n@@ -168,1 +224,1 @@\n-                nodes(domainName, indexer, block.ops()),\n+                nodes(domain, indexer, block.ops()),\n@@ -172,1 +228,15 @@\n-    static List<NodeProto> nodes(String domainName, Indexer indexer, List<Op> ops) {\n+    static List<String> opInputNames(Indexer indexer, SequencedMap<OnnxOp.OnnxParameter, Object> inputs) {\n+        List<String> inputNames = inputs.sequencedValues().stream()\n+                .<String>mapMulti((v, dump) -> {\n+                    switch (v) {\n+                        case Value val -> dump.accept(indexer.nameOf(val));\n+                        case java.util.Optional<?> o when o.isPresent() && o.get() instanceof Value val -> dump.accept(indexer.nameOf(val));\n+                        case List l -> l.forEach(val -> dump.accept(indexer.nameOf((Value)val)));\n+                        default -> dump.accept(\"\"); \/\/ empty names for unused optional inputs\n+                    }\n+                }).toList();\n+        \/\/ trim trailing empty names\n+        return inputNames.reversed().stream().dropWhile(String::isEmpty).toList().reversed();\n+    }\n+\n+    static List<NodeProto> nodes(String domain, Indexer indexer, List<Op> ops) {\n@@ -181,2 +251,2 @@\n-                                    \"then_branch\", graph(null, domainName, indexer, ifOp.thenBranch().entryBlock(), List.of(), 0),\n-                                    \"else_branch\", graph(null, domainName, indexer, ifOp.elseBranch().entryBlock(), List.of(), 0))));\n+                                    \"then_branch\", graph(domain, null, indexer, ifOp.thenBranch().entryBlock(), List.of(), 0),\n+                                    \"else_branch\", graph(domain, null, indexer, ifOp.elseBranch().entryBlock(), List.of(), 0))));\n@@ -188,1 +258,1 @@\n-                                    \"body\", graph(null, domainName, indexer, loopOp.loopBody().entryBlock(), List.of(), 2))));\n+                                    \"body\", graph(domain, null, indexer, loopOp.loopBody().entryBlock(), List.of(), 2))));\n@@ -193,1 +263,1 @@\n-                            onnxOp.operands().stream().map(indexer::nameOf).toList(),\n+                            opInputNames(indexer, onnxOp.onnxInputs()),\n@@ -198,1 +268,1 @@\n-                            domainName,\n+                            domain,\n@@ -200,1 +270,1 @@\n-                            fco.operands().stream().map(indexer::nameOf).toList(),\n+                            expandTuples(indexer, fco.operands()),\n@@ -253,1 +323,2 @@\n-    static FunctionProto function(String domain, String functionName, List<String> inputNames, List<String> outputNames, List<NodeProto> ops) {\n+    static FunctionProto function(String functionDomain, List<String> imports, String functionName, List<String> inputNames, List<String> outputNames, List<NodeProto> ops) {\n+        int di = functionName.lastIndexOf('.');\n@@ -255,1 +326,1 @@\n-                .domain(domain)\n+                .domain(functionDomain)\n@@ -260,1 +331,2 @@\n-                .opsetImport(new OperatorSetIdProto().version(OPSET_VERSION));\n+                .opsetImport(new OperatorSetIdProto().version(OPSET_VERSION))\n+                .forEach(imports, (f, d) -> f.opsetImport(new OperatorSetIdProto().domain(d).version(1)));\n@@ -273,5 +345,2 @@\n-        return new NodeProto()\n-                .opType(opName)\n-                .forEach(inputNames, (n, iName) -> n.input(iName))\n-                .forEach(attributes.entrySet(), (n, ae) -> n.attribute(attribute(ae.getKey(), ae.getValue())))\n-                .forEach(outputNames, (n, oName) -> n.output(oName));\n+        int di = opName.lastIndexOf('.');\n+        return node(di < 0 ? null : opName.substring(0, di), opName.substring(di + 1), inputNames, outputNames, attributes);\n@@ -292,2 +361,3 @@\n-    static TensorProto tensorProto(String name, oracle.code.onnx.Tensor tensor) {\n-        return new TensorProto()\n+    static TensorProto tensorProto(String name, oracle.code.onnx.Tensor tensor, Function<Tensor, ExternalTensorDataInfo> tensorDataExternalizer) {\n+        ExternalTensorDataInfo extInfo = tensorDataExternalizer.apply(tensor);\n+        TensorProto tp = new TensorProto()\n@@ -295,0 +365,12 @@\n+                .dataType(tensor.elementType().id)\n+                .dims(tensor.shape());\n+        return extInfo == null\n+                ? tp.rawData(tensor.data().toArray(ValueLayout.JAVA_BYTE))\n+                : tp.externalData(new StringStringEntryProto().key(\"location\").value(extInfo.location()))\n+                    .externalData(new StringStringEntryProto().key(\"offset\").value(String.valueOf(extInfo.offset())))\n+                    .externalData(new StringStringEntryProto().key(\"length\").value(String.valueOf(extInfo.length())))\n+                    .dataLocation(DataLocation.EXTERNAL);\n+    }\n+\n+    static TensorProto tensorProto(oracle.code.onnx.Tensor tensor) {\n+        return new TensorProto()\n@@ -320,0 +402,4 @@\n+            case Tensor<?> t -> {\n+                attr.type(AttributeType.TENSOR);\n+                attr.t(tensorProto(t));\n+            }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":137,"deletions":51,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.function.Consumer;\n@@ -88,0 +89,18 @@\n+    \/\/ @@@ temporary set public for ongoing experiments\n+    public static List<Object> getInitValues(MethodHandles.Lookup lookup, SequencedCollection<FieldRef> initializers, SequencedCollection<Object> possibleReceivers) {\n+        return initializers.stream().map(i -> {\n+            try {\n+                Field initializerField = i.resolveToMember(lookup);\n+                VarHandle handle = lookup.unreflectVarHandle(initializerField);\n+                if (initializerField.accessFlags().contains(AccessFlag.STATIC)) {\n+                    return handle.get();\n+                } else {\n+                    Class<?> initializerClass = initializerField.getDeclaringClass();\n+                    return handle.get(possibleReceivers.stream().filter(initializerClass::isInstance).findFirst().orElseThrow());\n+                }\n+            } catch (ReflectiveOperationException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }).toList();\n+    }\n+\n@@ -105,17 +124,0 @@\n-        static List<Tensor> getInitValues(MethodHandles.Lookup lookup, SequencedCollection<FieldRef> initializers, SequencedCollection<Object> possibleReceivers) {\n-            return initializers.stream().map(i -> {\n-                try {\n-                    Field initializerField = i.resolveToMember(lookup);\n-                    VarHandle handle = lookup.unreflectVarHandle(initializerField);\n-                    if (initializerField.accessFlags().contains(AccessFlag.STATIC)) {\n-                        return (Tensor)handle.get();\n-                    } else {\n-                        Class<?> initializerClass = initializerField.getDeclaringClass();\n-                        return (Tensor)handle.get(possibleReceivers.stream().filter(initializerClass::isInstance).findFirst().orElseThrow());\n-                    }\n-                } catch (ReflectiveOperationException ex) {\n-                    throw new RuntimeException(ex);\n-                }\n-            }).toList();\n-        }\n-\n@@ -127,1 +129,1 @@\n-            byte[] protobufModel = OnnxProtoBuilder.build(domainName, mi.module(), getInitValues(l, mi.initializers(), q.capturedValues().sequencedValues()));\n+            byte[] protobufModel = OnnxProtoBuilder.buildModel(domainName, mi.module(), getInitValues(l, mi.initializers(), q.capturedValues().sequencedValues()));\n@@ -157,0 +159,15 @@\n+    private static void expandArg(Object val, Consumer<Tensor> args) {\n+        switch (val) {\n+            case CoreOp.Var<?> v -> expandArg(v.value(), args);\n+            case Tensor t -> args.accept(t);\n+            case Record r -> {\n+                for (var rc : r.getClass().getRecordComponents()) try {\n+                    expandArg(rc.getAccessor().invoke(r), args);\n+                } catch (ReflectiveOperationException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+            default -> {}\n+        }\n+    }\n+\n@@ -163,6 +180,1 @@\n-                .map(val -> val instanceof CoreOp.Var<?> v ? v.value() : val)\n-                .<Tensor>mapMulti((val, args) -> {\n-                    if (val instanceof Tensor t) {\n-                        args.accept(t);\n-                    }\n-                })\n+                .mapMulti(OnnxRuntime::expandArg)\n@@ -228,1 +240,1 @@\n-        var protoModel = OnnxProtoBuilder.build(\n+        var protoModel = OnnxProtoBuilder.buildModel(\n@@ -242,1 +254,1 @@\n-        var protoModel = OnnxProtoBuilder.build(block, inputValues.subList(0, initializers));\n+        var protoModel = OnnxProtoBuilder.buildModel(block, inputValues.subList(0, initializers));\n@@ -324,1 +336,1 @@\n-                shape.length == 0 ? MemorySegment.NULL : autoShape(arena, shape, flatData.byteSize() \/ elementType.size()), (long)shape.length,\n+                shape.length == 0 ? MemorySegment.NULL : autoShape(arena, shape, 8l * flatData.byteSize() \/ elementType.bitSize()), (long)shape.length,\n@@ -374,1 +386,1 @@\n-                * Tensor.ElementType.fromOnnxId(retInt(OrtApi.GetTensorElementType(runtimeAddress, infoAddr, ret))).size();\n+                * Tensor.ElementType.fromOnnxId(retInt(OrtApi.GetTensorElementType(runtimeAddress, infoAddr, ret))).bitSize() \/ 8;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":40,"deletions":28,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-        int size() {\n+        public int bitSize() {\n@@ -225,5 +225,7 @@\n-                case UINT8, INT8, BOOL, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ -> 1;\n-                case UINT16, INT16, FLOAT16, BFLOAT16 -> 2;\n-                case UINT32, INT32, FLOAT -> 4;\n-                case UINT64, INT64, DOUBLE -> 8;\n-                default -> 0;\n+                case INT4, UINT4, FLOAT4E2M1 -> 4;\n+                case UINT8, INT8, BOOL, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ -> 8;\n+                case UINT16, INT16, FLOAT16, BFLOAT16 -> 16;\n+                case UINT32, INT32, FLOAT -> 32;\n+                case UINT64, INT64, DOUBLE, COMPLEX64 -> 64;\n+                case COMPLEX128 -> 128;\n+                case STRING -> -1;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    public record ModuleAndInitializers(CoreOp.ModuleOp module, SequencedCollection<FieldRef> initializers) {}\n+    public record ModuleAndInitializers(CoreOp.ModuleOp module, SequencedCollection<FieldRef> initializers, Map<Value, String> namesMap) {}\n@@ -91,1 +91,2 @@\n-        return new ModuleAndInitializers(transformModule(l, mi.module()), mi.initializers());\n+        Map<Value, String> namesMap = new HashMap<>();\n+        return new ModuleAndInitializers(transformModule(l, mi.module(), namesMap), mi.initializers(), namesMap);\n@@ -141,1 +142,1 @@\n-        record TI(OnnxType type, int index) {}\n+        record TI(TypeElement type, int index) {}\n@@ -143,2 +144,4 @@\n-            if (op instanceof CoreOp.FieldAccessOp.FieldLoadOp flo && flo.resultType() instanceof ClassType ct && ct.rawType().equals(TENSOR_CLASS)) {\n-                i.putIfAbsent(flo.fieldDescriptor(), new TI((OnnxType)convertType(l, ct), i.size()));\n+            if (op instanceof CoreOp.FieldAccessOp.FieldLoadOp flo\n+                    && (flo.resultType() instanceof ClassType ct && ct.rawType().equals(TENSOR_CLASS)\n+                     || isRecord(l, flo.resultType()))) {\n+                i.putIfAbsent(flo.fieldDescriptor(), new TI(convertType(l, flo.resultType()), i.size()));\n@@ -150,1 +153,1 @@\n-            return new ModuleAndInitializers(module, List.of());\n+            return new ModuleAndInitializers(module, List.of(), null);\n@@ -154,1 +157,1 @@\n-        List<OnnxType> initTypes = initializers.sequencedValues().stream().map(TI::type).toList();\n+        List<TypeElement> initTypes = initializers.sequencedValues().stream().map(TI::type).toList();\n@@ -180,1 +183,1 @@\n-        }).toList()), initializers.sequencedKeySet());\n+        }).toList()), initializers.sequencedKeySet(), null);\n@@ -193,1 +196,1 @@\n-    static CoreOp.ModuleOp transformModule(MethodHandles.Lookup l, CoreOp.ModuleOp module) {\n+    static CoreOp.ModuleOp transformModule(MethodHandles.Lookup l, CoreOp.ModuleOp module, Map<Value, String> namesMap) {\n@@ -196,1 +199,1 @@\n-                -> transformFunc(l, f, paramsToDropMap)).toList());\n+                -> transformFunc(l, f, paramsToDropMap, namesMap)).toList());\n@@ -199,1 +202,11 @@\n-    static CoreOp.FuncOp transformFunc(MethodHandles.Lookup l, CoreOp.FuncOp func, Map<String, BitSet> paramsToDropMap) {\n+    static CoreOp.FuncOp transformFunc(MethodHandles.Lookup l, CoreOp.FuncOp func, Map<String, BitSet> paramsToDropMap, Map<Value, String> namesMap) {\n+        \/\/ get original return record class\n+        Class<?> returnRecordClass = null;\n+        try {\n+            if (func.invokableType().returnType() instanceof ClassType ct && ct.rawType().resolve(l) instanceof Class cls && cls.isRecord()) {\n+                returnRecordClass = cls;\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n@@ -213,0 +226,8 @@\n+        \/\/ collect param names\n+        String[] paramNames = new String[func.parameters().size()];\n+        for (int i = 0; i < paramNames.length; i++) {\n+            if (func.parameters().get(i).uses().iterator().next().op() instanceof CoreOp.VarOp vo && !vo.varName().isEmpty()) {\n+                paramNames[i] = vo.varName();\n+            }\n+        }\n+\n@@ -214,1 +235,20 @@\n-        return SSA.transform(func);\n+        func = SSA.transform(func);\n+\n+        \/\/ map param names\n+        for (int i = 0; i < paramNames.length; i++) {\n+            if (paramNames[i] != null) {\n+                namesMap.put(func.parameters().get(i), paramNames[i]);\n+            }\n+        }\n+        \/\/ map return tuple names from the original record components\n+        if (returnRecordClass != null\n+                && func.body().entryBlock().terminatingOp() instanceof CoreOp.ReturnOp ro\n+                && ro.operands().getFirst() instanceof Op.Result or\n+                && or.op() instanceof CoreOp.TupleOp to) {\n+            var rcs = returnRecordClass.getRecordComponents();\n+            for (int i = 0; i < to.operands().size(); i++) {\n+                namesMap.put(to.operands().get(i), rcs[i].getName());\n+            }\n+        }\n+\n+        return func;\n@@ -390,0 +430,8 @@\n+                case CoreOp.FieldAccessOp.FieldLoadOp flo when flo.operands().isEmpty() -> {\n+                    Op.Result result = bb.op(CoreOp.fieldLoad(convertType(l, flo.resultType()), convertType(l, flo.fieldDescriptor())));\n+                    bb.context().mapValue(flo.result(), result);\n+                }\n+                case CoreOp.FieldAccessOp.FieldLoadOp flo -> {\n+                    Op.Result result = bb.op(CoreOp.fieldLoad(convertType(l, flo.resultType()), convertType(l, flo.fieldDescriptor()), bb.context().getValue(flo.operands().getFirst())));\n+                    bb.context().mapValue(flo.result(), result);\n+                }\n@@ -448,2 +496,6 @@\n-            switch (rc.getGenericType()) {\n-                case ParameterizedType pt when pt.getRawType().equals(Tensor.class) -> {\n+            Type type = rc.getGenericType();\n+            if (type instanceof ParameterizedType pt && pt.getRawType().equals(Optional.class)) {\n+                type = pt.getActualTypeArguments()[0];\n+            }\n+            switch (type) {\n+                case ParameterizedType pt -> {\n@@ -523,0 +575,4 @@\n+    static FieldRef convertType(MethodHandles.Lookup l, FieldRef t) {\n+        return FieldRef.field(convertType(l, t.refType()), t.name(), convertType(l, t.type()));\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":70,"deletions":14,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,7610 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+public class OrtGenApi {\n+\n+    OrtGenApi() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    static final Arena LIBRARY_ARENA = Arena.ofAuto();\n+    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n+\n+    static void traceDowncall(String name, Object... args) {\n+         String traceArgs = Arrays.stream(args)\n+                       .map(Object::toString)\n+                       .collect(Collectors.joining(\", \"));\n+         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n+    }\n+\n+    static MemorySegment findOrThrow(String symbol) {\n+        return SYMBOL_LOOKUP.find(symbol)\n+            .orElseThrow(() -> new UnsatisfiedLinkError(\"unresolved symbol: \" + symbol));\n+    }\n+\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MemoryLayout align(MemoryLayout layout, long align) {\n+        return switch (layout) {\n+            case PaddingLayout p -> p;\n+            case ValueLayout v -> v.withByteAlignment(align);\n+            case GroupLayout g -> {\n+                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n+                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n+                yield g instanceof StructLayout ?\n+                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n+            }\n+            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n+        };\n+    }\n+\n+    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n+            .or(Linker.nativeLinker().defaultLookup());\n+\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));\n+    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n+    private static final int __WORDSIZE = (int)64L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __WORDSIZE 64\n+     * }\n+     *\/\n+    public static int __WORDSIZE() {\n+        return __WORDSIZE;\n+    }\n+    private static final int __has_safe_buffers = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __has_safe_buffers 0\n+     * }\n+     *\/\n+    public static int __has_safe_buffers() {\n+        return __has_safe_buffers;\n+    }\n+    private static final int __DARWIN_ONLY_64_BIT_INO_T = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_ONLY_64_BIT_INO_T 1\n+     * }\n+     *\/\n+    public static int __DARWIN_ONLY_64_BIT_INO_T() {\n+        return __DARWIN_ONLY_64_BIT_INO_T;\n+    }\n+    private static final int __DARWIN_ONLY_UNIX_CONFORMANCE = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_ONLY_UNIX_CONFORMANCE 1\n+     * }\n+     *\/\n+    public static int __DARWIN_ONLY_UNIX_CONFORMANCE() {\n+        return __DARWIN_ONLY_UNIX_CONFORMANCE;\n+    }\n+    private static final int __DARWIN_ONLY_VERS_1050 = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_ONLY_VERS_1050 1\n+     * }\n+     *\/\n+    public static int __DARWIN_ONLY_VERS_1050() {\n+        return __DARWIN_ONLY_VERS_1050;\n+    }\n+    private static final int __DARWIN_UNIX03 = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_UNIX03 1\n+     * }\n+     *\/\n+    public static int __DARWIN_UNIX03() {\n+        return __DARWIN_UNIX03;\n+    }\n+    private static final int __DARWIN_64_BIT_INO_T = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_64_BIT_INO_T 1\n+     * }\n+     *\/\n+    public static int __DARWIN_64_BIT_INO_T() {\n+        return __DARWIN_64_BIT_INO_T;\n+    }\n+    private static final int __DARWIN_VERS_1050 = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_VERS_1050 1\n+     * }\n+     *\/\n+    public static int __DARWIN_VERS_1050() {\n+        return __DARWIN_VERS_1050;\n+    }\n+    private static final int __DARWIN_NON_CANCELABLE = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_NON_CANCELABLE 0\n+     * }\n+     *\/\n+    public static int __DARWIN_NON_CANCELABLE() {\n+        return __DARWIN_NON_CANCELABLE;\n+    }\n+    private static final int __STDC_WANT_LIB_EXT1__ = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __STDC_WANT_LIB_EXT1__ 1\n+     * }\n+     *\/\n+    public static int __STDC_WANT_LIB_EXT1__() {\n+        return __STDC_WANT_LIB_EXT1__;\n+    }\n+    private static final int __DARWIN_NO_LONG_LONG = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_NO_LONG_LONG 0\n+     * }\n+     *\/\n+    public static int __DARWIN_NO_LONG_LONG() {\n+        return __DARWIN_NO_LONG_LONG;\n+    }\n+    private static final int _DARWIN_FEATURE_64_BIT_INODE = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define _DARWIN_FEATURE_64_BIT_INODE 1\n+     * }\n+     *\/\n+    public static int _DARWIN_FEATURE_64_BIT_INODE() {\n+        return _DARWIN_FEATURE_64_BIT_INODE;\n+    }\n+    private static final int _DARWIN_FEATURE_ONLY_64_BIT_INODE = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define _DARWIN_FEATURE_ONLY_64_BIT_INODE 1\n+     * }\n+     *\/\n+    public static int _DARWIN_FEATURE_ONLY_64_BIT_INODE() {\n+        return _DARWIN_FEATURE_ONLY_64_BIT_INODE;\n+    }\n+    private static final int _DARWIN_FEATURE_ONLY_VERS_1050 = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define _DARWIN_FEATURE_ONLY_VERS_1050 1\n+     * }\n+     *\/\n+    public static int _DARWIN_FEATURE_ONLY_VERS_1050() {\n+        return _DARWIN_FEATURE_ONLY_VERS_1050;\n+    }\n+    private static final int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1\n+     * }\n+     *\/\n+    public static int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE() {\n+        return _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE;\n+    }\n+    private static final int _DARWIN_FEATURE_UNIX_CONFORMANCE = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define _DARWIN_FEATURE_UNIX_CONFORMANCE 3\n+     * }\n+     *\/\n+    public static int _DARWIN_FEATURE_UNIX_CONFORMANCE() {\n+        return _DARWIN_FEATURE_UNIX_CONFORMANCE;\n+    }\n+    private static final int __has_ptrcheck = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __has_ptrcheck 0\n+     * }\n+     *\/\n+    public static int __has_ptrcheck() {\n+        return __has_ptrcheck;\n+    }\n+    private static final int USE_CLANG_TYPES = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define USE_CLANG_TYPES 0\n+     * }\n+     *\/\n+    public static int USE_CLANG_TYPES() {\n+        return USE_CLANG_TYPES;\n+    }\n+    private static final int __PTHREAD_SIZE__ = (int)8176L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __PTHREAD_SIZE__ 8176\n+     * }\n+     *\/\n+    public static int __PTHREAD_SIZE__() {\n+        return __PTHREAD_SIZE__;\n+    }\n+    private static final int __PTHREAD_ATTR_SIZE__ = (int)56L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __PTHREAD_ATTR_SIZE__ 56\n+     * }\n+     *\/\n+    public static int __PTHREAD_ATTR_SIZE__() {\n+        return __PTHREAD_ATTR_SIZE__;\n+    }\n+    private static final int __PTHREAD_MUTEXATTR_SIZE__ = (int)8L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __PTHREAD_MUTEXATTR_SIZE__ 8\n+     * }\n+     *\/\n+    public static int __PTHREAD_MUTEXATTR_SIZE__() {\n+        return __PTHREAD_MUTEXATTR_SIZE__;\n+    }\n+    private static final int __PTHREAD_MUTEX_SIZE__ = (int)56L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __PTHREAD_MUTEX_SIZE__ 56\n+     * }\n+     *\/\n+    public static int __PTHREAD_MUTEX_SIZE__() {\n+        return __PTHREAD_MUTEX_SIZE__;\n+    }\n+    private static final int __PTHREAD_CONDATTR_SIZE__ = (int)8L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __PTHREAD_CONDATTR_SIZE__ 8\n+     * }\n+     *\/\n+    public static int __PTHREAD_CONDATTR_SIZE__() {\n+        return __PTHREAD_CONDATTR_SIZE__;\n+    }\n+    private static final int __PTHREAD_COND_SIZE__ = (int)40L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __PTHREAD_COND_SIZE__ 40\n+     * }\n+     *\/\n+    public static int __PTHREAD_COND_SIZE__() {\n+        return __PTHREAD_COND_SIZE__;\n+    }\n+    private static final int __PTHREAD_ONCE_SIZE__ = (int)8L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __PTHREAD_ONCE_SIZE__ 8\n+     * }\n+     *\/\n+    public static int __PTHREAD_ONCE_SIZE__() {\n+        return __PTHREAD_ONCE_SIZE__;\n+    }\n+    private static final int __PTHREAD_RWLOCK_SIZE__ = (int)192L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __PTHREAD_RWLOCK_SIZE__ 192\n+     * }\n+     *\/\n+    public static int __PTHREAD_RWLOCK_SIZE__() {\n+        return __PTHREAD_RWLOCK_SIZE__;\n+    }\n+    private static final int __PTHREAD_RWLOCKATTR_SIZE__ = (int)16L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __PTHREAD_RWLOCKATTR_SIZE__ 16\n+     * }\n+     *\/\n+    public static int __PTHREAD_RWLOCKATTR_SIZE__() {\n+        return __PTHREAD_RWLOCKATTR_SIZE__;\n+    }\n+    private static final int INT8_MAX = (int)127L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT8_MAX 127\n+     * }\n+     *\/\n+    public static int INT8_MAX() {\n+        return INT8_MAX;\n+    }\n+    private static final int INT16_MAX = (int)32767L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT16_MAX 32767\n+     * }\n+     *\/\n+    public static int INT16_MAX() {\n+        return INT16_MAX;\n+    }\n+    private static final int INT32_MAX = (int)2147483647L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT32_MAX 2147483647\n+     * }\n+     *\/\n+    public static int INT32_MAX() {\n+        return INT32_MAX;\n+    }\n+    private static final int UINT8_MAX = (int)255L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT8_MAX 255\n+     * }\n+     *\/\n+    public static int UINT8_MAX() {\n+        return UINT8_MAX;\n+    }\n+    private static final int UINT16_MAX = (int)65535L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT16_MAX 65535\n+     * }\n+     *\/\n+    public static int UINT16_MAX() {\n+        return UINT16_MAX;\n+    }\n+    private static final int true_ = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define true 1\n+     * }\n+     *\/\n+    public static int true_() {\n+        return true_;\n+    }\n+    private static final int false_ = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define false 0\n+     * }\n+     *\/\n+    public static int false_() {\n+        return false_;\n+    }\n+    private static final int __bool_true_false_are_defined = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __bool_true_false_are_defined 1\n+     * }\n+     *\/\n+    public static int __bool_true_false_are_defined() {\n+        return __bool_true_false_are_defined;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef signed char int8_t\n+     * }\n+     *\/\n+    public static final OfByte int8_t = OrtGenApi.C_CHAR;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef short int16_t\n+     * }\n+     *\/\n+    public static final OfShort int16_t = OrtGenApi.C_SHORT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int int32_t\n+     * }\n+     *\/\n+    public static final OfInt int32_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef long long int64_t\n+     * }\n+     *\/\n+    public static final OfLong int64_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned char uint8_t\n+     * }\n+     *\/\n+    public static final OfByte uint8_t = OrtGenApi.C_CHAR;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned short uint16_t\n+     * }\n+     *\/\n+    public static final OfShort uint16_t = OrtGenApi.C_SHORT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned int uint32_t\n+     * }\n+     *\/\n+    public static final OfInt uint32_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned long long uint64_t\n+     * }\n+     *\/\n+    public static final OfLong uint64_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int8_t int_least8_t\n+     * }\n+     *\/\n+    public static final OfByte int_least8_t = OrtGenApi.C_CHAR;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int16_t int_least16_t\n+     * }\n+     *\/\n+    public static final OfShort int_least16_t = OrtGenApi.C_SHORT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int32_t int_least32_t\n+     * }\n+     *\/\n+    public static final OfInt int_least32_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int64_t int_least64_t\n+     * }\n+     *\/\n+    public static final OfLong int_least64_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef uint8_t uint_least8_t\n+     * }\n+     *\/\n+    public static final OfByte uint_least8_t = OrtGenApi.C_CHAR;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef uint16_t uint_least16_t\n+     * }\n+     *\/\n+    public static final OfShort uint_least16_t = OrtGenApi.C_SHORT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef uint32_t uint_least32_t\n+     * }\n+     *\/\n+    public static final OfInt uint_least32_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef uint64_t uint_least64_t\n+     * }\n+     *\/\n+    public static final OfLong uint_least64_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int8_t int_fast8_t\n+     * }\n+     *\/\n+    public static final OfByte int_fast8_t = OrtGenApi.C_CHAR;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int16_t int_fast16_t\n+     * }\n+     *\/\n+    public static final OfShort int_fast16_t = OrtGenApi.C_SHORT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int32_t int_fast32_t\n+     * }\n+     *\/\n+    public static final OfInt int_fast32_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int64_t int_fast64_t\n+     * }\n+     *\/\n+    public static final OfLong int_fast64_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef uint8_t uint_fast8_t\n+     * }\n+     *\/\n+    public static final OfByte uint_fast8_t = OrtGenApi.C_CHAR;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef uint16_t uint_fast16_t\n+     * }\n+     *\/\n+    public static final OfShort uint_fast16_t = OrtGenApi.C_SHORT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef uint32_t uint_fast32_t\n+     * }\n+     *\/\n+    public static final OfInt uint_fast32_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef uint64_t uint_fast64_t\n+     * }\n+     *\/\n+    public static final OfLong uint_fast64_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef signed char __int8_t\n+     * }\n+     *\/\n+    public static final OfByte __int8_t = OrtGenApi.C_CHAR;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned char __uint8_t\n+     * }\n+     *\/\n+    public static final OfByte __uint8_t = OrtGenApi.C_CHAR;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef short __int16_t\n+     * }\n+     *\/\n+    public static final OfShort __int16_t = OrtGenApi.C_SHORT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned short __uint16_t\n+     * }\n+     *\/\n+    public static final OfShort __uint16_t = OrtGenApi.C_SHORT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int __int32_t\n+     * }\n+     *\/\n+    public static final OfInt __int32_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned int __uint32_t\n+     * }\n+     *\/\n+    public static final OfInt __uint32_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef long long __int64_t\n+     * }\n+     *\/\n+    public static final OfLong __int64_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned long long __uint64_t\n+     * }\n+     *\/\n+    public static final OfLong __uint64_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef long __darwin_intptr_t\n+     * }\n+     *\/\n+    public static final OfLong __darwin_intptr_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned int __darwin_natural_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_natural_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int __darwin_ct_rune_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_ct_rune_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef long __darwin_ptrdiff_t\n+     * }\n+     *\/\n+    public static final OfLong __darwin_ptrdiff_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned long __darwin_size_t\n+     * }\n+     *\/\n+    public static final OfLong __darwin_size_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __builtin_va_list __darwin_va_list\n+     * }\n+     *\/\n+    public static final AddressLayout __darwin_va_list = OrtGenApi.C_POINTER;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int __darwin_wchar_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_wchar_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __darwin_wchar_t __darwin_rune_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_rune_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int __darwin_wint_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_wint_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned long __darwin_clock_t\n+     * }\n+     *\/\n+    public static final OfLong __darwin_clock_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __uint32_t __darwin_socklen_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_socklen_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef long __darwin_ssize_t\n+     * }\n+     *\/\n+    public static final OfLong __darwin_ssize_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef long __darwin_time_t\n+     * }\n+     *\/\n+    public static final OfLong __darwin_time_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __int64_t __darwin_blkcnt_t\n+     * }\n+     *\/\n+    public static final OfLong __darwin_blkcnt_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __int32_t __darwin_blksize_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_blksize_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __int32_t __darwin_dev_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_dev_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned int __darwin_fsblkcnt_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_fsblkcnt_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned int __darwin_fsfilcnt_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_fsfilcnt_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __uint32_t __darwin_gid_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_gid_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __uint32_t __darwin_id_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_id_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __uint64_t __darwin_ino64_t\n+     * }\n+     *\/\n+    public static final OfLong __darwin_ino64_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __darwin_ino64_t __darwin_ino_t\n+     * }\n+     *\/\n+    public static final OfLong __darwin_ino_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __darwin_natural_t __darwin_mach_port_name_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_mach_port_name_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __darwin_mach_port_name_t __darwin_mach_port_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_mach_port_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __uint16_t __darwin_mode_t\n+     * }\n+     *\/\n+    public static final OfShort __darwin_mode_t = OrtGenApi.C_SHORT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __int64_t __darwin_off_t\n+     * }\n+     *\/\n+    public static final OfLong __darwin_off_t = OrtGenApi.C_LONG_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __int32_t __darwin_pid_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_pid_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __uint32_t __darwin_sigset_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_sigset_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __int32_t __darwin_suseconds_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_suseconds_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __uint32_t __darwin_uid_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_uid_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __uint32_t __darwin_useconds_t\n+     * }\n+     *\/\n+    public static final OfInt __darwin_useconds_t = OrtGenApi.C_INT;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned long __darwin_pthread_key_t\n+     * }\n+     *\/\n+    public static final OfLong __darwin_pthread_key_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef struct _opaque_pthread_t {\n+     *     long __sig;\n+     *     struct __darwin_pthread_handler_rec *__cleanup_stack;\n+     *     char __opaque[8176];\n+     * } *__darwin_pthread_t\n+     * }\n+     *\/\n+    public static final AddressLayout __darwin_pthread_t = OrtGenApi.C_POINTER;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef __darwin_intptr_t intptr_t\n+     * }\n+     *\/\n+    public static final OfLong intptr_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned long uintptr_t\n+     * }\n+     *\/\n+    public static final OfLong uintptr_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef long intmax_t\n+     * }\n+     *\/\n+    public static final OfLong intmax_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned long uintmax_t\n+     * }\n+     *\/\n+    public static final OfLong uintmax_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef long ptrdiff_t\n+     * }\n+     *\/\n+    public static final OfLong ptrdiff_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned long size_t\n+     * }\n+     *\/\n+    public static final OfLong size_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef unsigned long rsize_t\n+     * }\n+     *\/\n+    public static final OfLong rsize_t = OrtGenApi.C_LONG;\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef int wchar_t\n+     * }\n+     *\/\n+    public static final OfInt wchar_t = OrtGenApi.C_INT;\n+    private static final int OgaElementType_undefined = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_undefined = 0\n+     * }\n+     *\/\n+    public static int OgaElementType_undefined() {\n+        return OgaElementType_undefined;\n+    }\n+    private static final int OgaElementType_float32 = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_float32 = 1\n+     * }\n+     *\/\n+    public static int OgaElementType_float32() {\n+        return OgaElementType_float32;\n+    }\n+    private static final int OgaElementType_uint8 = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_uint8 = 2\n+     * }\n+     *\/\n+    public static int OgaElementType_uint8() {\n+        return OgaElementType_uint8;\n+    }\n+    private static final int OgaElementType_int8 = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_int8 = 3\n+     * }\n+     *\/\n+    public static int OgaElementType_int8() {\n+        return OgaElementType_int8;\n+    }\n+    private static final int OgaElementType_uint16 = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_uint16 = 4\n+     * }\n+     *\/\n+    public static int OgaElementType_uint16() {\n+        return OgaElementType_uint16;\n+    }\n+    private static final int OgaElementType_int16 = (int)5L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_int16 = 5\n+     * }\n+     *\/\n+    public static int OgaElementType_int16() {\n+        return OgaElementType_int16;\n+    }\n+    private static final int OgaElementType_int32 = (int)6L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_int32 = 6\n+     * }\n+     *\/\n+    public static int OgaElementType_int32() {\n+        return OgaElementType_int32;\n+    }\n+    private static final int OgaElementType_int64 = (int)7L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_int64 = 7\n+     * }\n+     *\/\n+    public static int OgaElementType_int64() {\n+        return OgaElementType_int64;\n+    }\n+    private static final int OgaElementType_string = (int)8L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_string = 8\n+     * }\n+     *\/\n+    public static int OgaElementType_string() {\n+        return OgaElementType_string;\n+    }\n+    private static final int OgaElementType_bool = (int)9L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_bool = 9\n+     * }\n+     *\/\n+    public static int OgaElementType_bool() {\n+        return OgaElementType_bool;\n+    }\n+    private static final int OgaElementType_float16 = (int)10L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_float16 = 10\n+     * }\n+     *\/\n+    public static int OgaElementType_float16() {\n+        return OgaElementType_float16;\n+    }\n+    private static final int OgaElementType_float64 = (int)11L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_float64 = 11\n+     * }\n+     *\/\n+    public static int OgaElementType_float64() {\n+        return OgaElementType_float64;\n+    }\n+    private static final int OgaElementType_uint32 = (int)12L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_uint32 = 12\n+     * }\n+     *\/\n+    public static int OgaElementType_uint32() {\n+        return OgaElementType_uint32;\n+    }\n+    private static final int OgaElementType_uint64 = (int)13L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_uint64 = 13\n+     * }\n+     *\/\n+    public static int OgaElementType_uint64() {\n+        return OgaElementType_uint64;\n+    }\n+    private static final int OgaElementType_complex64 = (int)14L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_complex64 = 14\n+     * }\n+     *\/\n+    public static int OgaElementType_complex64() {\n+        return OgaElementType_complex64;\n+    }\n+    private static final int OgaElementType_complex128 = (int)15L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_complex128 = 15\n+     * }\n+     *\/\n+    public static int OgaElementType_complex128() {\n+        return OgaElementType_complex128;\n+    }\n+    private static final int OgaElementType_bfloat16 = (int)16L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OgaElementType.OgaElementType_bfloat16 = 16\n+     * }\n+     *\/\n+    public static int OgaElementType_bfloat16() {\n+        return OgaElementType_bfloat16;\n+    }\n+\n+    \/**\n+     * Variadic invoker class for:\n+     * {@snippet lang=c :\n+     * void OgaShutdown()\n+     * }\n+     *\/\n+    public static class OgaShutdown {\n+        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(        );\n+        private static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaShutdown\");\n+\n+        private final MethodHandle handle;\n+        private final FunctionDescriptor descriptor;\n+        private final MethodHandle spreader;\n+\n+        private OgaShutdown(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {\n+            this.handle = handle;\n+            this.descriptor = descriptor;\n+            this.spreader = spreader;\n+        }\n+\n+        \/**\n+         * Variadic invoker factory for:\n+         * {@snippet lang=c :\n+         * void OgaShutdown()\n+         * }\n+         *\/\n+        public static OgaShutdown makeInvoker(MemoryLayout... layouts) {\n+            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);\n+            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());\n+            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);\n+            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);\n+            return new OgaShutdown(mh$, desc$, spreader$);\n+        }\n+\n+        \/**\n+         * {@return the address}\n+         *\/\n+        public static MemorySegment address() {\n+            return ADDR;\n+        }\n+\n+        \/**\n+         * {@return the specialized method handle}\n+         *\/\n+        public MethodHandle handle() {\n+            return handle;\n+        }\n+\n+        \/**\n+         * {@return the specialized descriptor}\n+         *\/\n+        public FunctionDescriptor descriptor() {\n+            return descriptor;\n+        }\n+\n+        public void apply(Object... x0) {\n+            try {\n+                if (TRACE_DOWNCALLS) {\n+                    traceDowncall(\"OgaShutdown\", x0);\n+                }\n+                 spreader.invokeExact(x0);\n+            } catch(IllegalArgumentException | ClassCastException ex$)  {\n+                throw ex$; \/\/ rethrow IAE from passing wrong number\/type of args\n+            } catch (Throwable ex$) {\n+               throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static class OgaResultGetError {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaResultGetError\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * const char *OgaResultGetError(const OgaResult *result)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaResultGetError$descriptor() {\n+        return OgaResultGetError.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * const char *OgaResultGetError(const OgaResult *result)\n+     * }\n+     *\/\n+    public static MethodHandle OgaResultGetError$handle() {\n+        return OgaResultGetError.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * const char *OgaResultGetError(const OgaResult *result)\n+     * }\n+     *\/\n+    public static MemorySegment OgaResultGetError$address() {\n+        return OgaResultGetError.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const char *OgaResultGetError(const OgaResult *result)\n+     * }\n+     *\/\n+    public static MemorySegment OgaResultGetError(MemorySegment result) {\n+        var mh$ = OgaResultGetError.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaResultGetError\", result);\n+            }\n+            return (MemorySegment)mh$.invokeExact(result);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaSetLogBool {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_BOOL\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaSetLogBool\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetLogBool(const char *name, bool value)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaSetLogBool$descriptor() {\n+        return OgaSetLogBool.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetLogBool(const char *name, bool value)\n+     * }\n+     *\/\n+    public static MethodHandle OgaSetLogBool$handle() {\n+        return OgaSetLogBool.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetLogBool(const char *name, bool value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSetLogBool$address() {\n+        return OgaSetLogBool.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetLogBool(const char *name, bool value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSetLogBool(MemorySegment name, boolean value) {\n+        var mh$ = OgaSetLogBool.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaSetLogBool\", name, value);\n+            }\n+            return (MemorySegment)mh$.invokeExact(name, value);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaSetLogString {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaSetLogString\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetLogString(const char *name, const char *value)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaSetLogString$descriptor() {\n+        return OgaSetLogString.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetLogString(const char *name, const char *value)\n+     * }\n+     *\/\n+    public static MethodHandle OgaSetLogString$handle() {\n+        return OgaSetLogString.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetLogString(const char *name, const char *value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSetLogString$address() {\n+        return OgaSetLogString.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetLogString(const char *name, const char *value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSetLogString(MemorySegment name, MemorySegment value) {\n+        var mh$ = OgaSetLogString.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaSetLogString\", name, value);\n+            }\n+            return (MemorySegment)mh$.invokeExact(name, value);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyResult {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyResult\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyResult(OgaResult *result)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyResult$descriptor() {\n+        return OgaDestroyResult.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyResult(OgaResult *result)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyResult$handle() {\n+        return OgaDestroyResult.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyResult(OgaResult *result)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyResult$address() {\n+        return OgaDestroyResult.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyResult(OgaResult *result)\n+     * }\n+     *\/\n+    public static void OgaDestroyResult(MemorySegment result) {\n+        var mh$ = OgaDestroyResult.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyResult\", result);\n+            }\n+            mh$.invokeExact(result);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyString {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyString\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyString(const char *)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyString$descriptor() {\n+        return OgaDestroyString.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyString(const char *)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyString$handle() {\n+        return OgaDestroyString.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyString(const char *)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyString$address() {\n+        return OgaDestroyString.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyString(const char *)\n+     * }\n+     *\/\n+    public static void OgaDestroyString(MemorySegment x0) {\n+        var mh$ = OgaDestroyString.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyString\", x0);\n+            }\n+            mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyNamedTensors {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyNamedTensors\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyNamedTensors(OgaNamedTensors *)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyNamedTensors$descriptor() {\n+        return OgaDestroyNamedTensors.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyNamedTensors(OgaNamedTensors *)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyNamedTensors$handle() {\n+        return OgaDestroyNamedTensors.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyNamedTensors(OgaNamedTensors *)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyNamedTensors$address() {\n+        return OgaDestroyNamedTensors.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyNamedTensors(OgaNamedTensors *)\n+     * }\n+     *\/\n+    public static void OgaDestroyNamedTensors(MemorySegment x0) {\n+        var mh$ = OgaDestroyNamedTensors.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyNamedTensors\", x0);\n+            }\n+            mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateSequences {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateSequences\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateSequences(OgaSequences **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateSequences$descriptor() {\n+        return OgaCreateSequences.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateSequences(OgaSequences **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateSequences$handle() {\n+        return OgaCreateSequences.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateSequences(OgaSequences **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateSequences$address() {\n+        return OgaCreateSequences.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateSequences(OgaSequences **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateSequences(MemorySegment out) {\n+        var mh$ = OgaCreateSequences.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateSequences\", out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroySequences {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroySequences\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroySequences(OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroySequences$descriptor() {\n+        return OgaDestroySequences.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroySequences(OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroySequences$handle() {\n+        return OgaDestroySequences.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroySequences(OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroySequences$address() {\n+        return OgaDestroySequences.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroySequences(OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static void OgaDestroySequences(MemorySegment sequences) {\n+        var mh$ = OgaDestroySequences.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroySequences\", sequences);\n+            }\n+            mh$.invokeExact(sequences);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaSequencesCount {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaSequencesCount\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * size_t OgaSequencesCount(const OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaSequencesCount$descriptor() {\n+        return OgaSequencesCount.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * size_t OgaSequencesCount(const OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static MethodHandle OgaSequencesCount$handle() {\n+        return OgaSequencesCount.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * size_t OgaSequencesCount(const OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSequencesCount$address() {\n+        return OgaSequencesCount.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * size_t OgaSequencesCount(const OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static long OgaSequencesCount(MemorySegment sequences) {\n+        var mh$ = OgaSequencesCount.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaSequencesCount\", sequences);\n+            }\n+            return (long)mh$.invokeExact(sequences);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaAppendTokenSequence {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaAppendTokenSequence\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaAppendTokenSequence(const int32_t *token_ptr, size_t token_cnt, OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaAppendTokenSequence$descriptor() {\n+        return OgaAppendTokenSequence.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaAppendTokenSequence(const int32_t *token_ptr, size_t token_cnt, OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static MethodHandle OgaAppendTokenSequence$handle() {\n+        return OgaAppendTokenSequence.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaAppendTokenSequence(const int32_t *token_ptr, size_t token_cnt, OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static MemorySegment OgaAppendTokenSequence$address() {\n+        return OgaAppendTokenSequence.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaAppendTokenSequence(const int32_t *token_ptr, size_t token_cnt, OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static MemorySegment OgaAppendTokenSequence(MemorySegment token_ptr, long token_cnt, MemorySegment sequences) {\n+        var mh$ = OgaAppendTokenSequence.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaAppendTokenSequence\", token_ptr, token_cnt, sequences);\n+            }\n+            return (MemorySegment)mh$.invokeExact(token_ptr, token_cnt, sequences);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaAppendTokenToSequence {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_INT,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaAppendTokenToSequence\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaAppendTokenToSequence(int32_t token, OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaAppendTokenToSequence$descriptor() {\n+        return OgaAppendTokenToSequence.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaAppendTokenToSequence(int32_t token, OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static MethodHandle OgaAppendTokenToSequence$handle() {\n+        return OgaAppendTokenToSequence.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaAppendTokenToSequence(int32_t token, OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static MemorySegment OgaAppendTokenToSequence$address() {\n+        return OgaAppendTokenToSequence.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaAppendTokenToSequence(int32_t token, OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static MemorySegment OgaAppendTokenToSequence(int token, MemorySegment sequences, long sequence_index) {\n+        var mh$ = OgaAppendTokenToSequence.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaAppendTokenToSequence\", token, sequences, sequence_index);\n+            }\n+            return (MemorySegment)mh$.invokeExact(token, sequences, sequence_index);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaSequencesGetSequenceCount {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaSequencesGetSequenceCount\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * size_t OgaSequencesGetSequenceCount(const OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaSequencesGetSequenceCount$descriptor() {\n+        return OgaSequencesGetSequenceCount.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * size_t OgaSequencesGetSequenceCount(const OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static MethodHandle OgaSequencesGetSequenceCount$handle() {\n+        return OgaSequencesGetSequenceCount.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * size_t OgaSequencesGetSequenceCount(const OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSequencesGetSequenceCount$address() {\n+        return OgaSequencesGetSequenceCount.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * size_t OgaSequencesGetSequenceCount(const OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static long OgaSequencesGetSequenceCount(MemorySegment sequences, long sequence_index) {\n+        var mh$ = OgaSequencesGetSequenceCount.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaSequencesGetSequenceCount\", sequences, sequence_index);\n+            }\n+            return (long)mh$.invokeExact(sequences, sequence_index);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaSequencesGetSequenceData {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaSequencesGetSequenceData\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * const int32_t *OgaSequencesGetSequenceData(const OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaSequencesGetSequenceData$descriptor() {\n+        return OgaSequencesGetSequenceData.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * const int32_t *OgaSequencesGetSequenceData(const OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static MethodHandle OgaSequencesGetSequenceData$handle() {\n+        return OgaSequencesGetSequenceData.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * const int32_t *OgaSequencesGetSequenceData(const OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSequencesGetSequenceData$address() {\n+        return OgaSequencesGetSequenceData.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const int32_t *OgaSequencesGetSequenceData(const OgaSequences *sequences, size_t sequence_index)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSequencesGetSequenceData(MemorySegment sequences, long sequence_index) {\n+        var mh$ = OgaSequencesGetSequenceData.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaSequencesGetSequenceData\", sequences, sequence_index);\n+            }\n+            return (MemorySegment)mh$.invokeExact(sequences, sequence_index);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaLoadImage {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaLoadImage\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImage(const char *image_path, OgaImages **images)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaLoadImage$descriptor() {\n+        return OgaLoadImage.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImage(const char *image_path, OgaImages **images)\n+     * }\n+     *\/\n+    public static MethodHandle OgaLoadImage$handle() {\n+        return OgaLoadImage.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImage(const char *image_path, OgaImages **images)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadImage$address() {\n+        return OgaLoadImage.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImage(const char *image_path, OgaImages **images)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadImage(MemorySegment image_path, MemorySegment images) {\n+        var mh$ = OgaLoadImage.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaLoadImage\", image_path, images);\n+            }\n+            return (MemorySegment)mh$.invokeExact(image_path, images);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaLoadImages {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaLoadImages\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImages(const OgaStringArray *image_paths, OgaImages **images)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaLoadImages$descriptor() {\n+        return OgaLoadImages.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImages(const OgaStringArray *image_paths, OgaImages **images)\n+     * }\n+     *\/\n+    public static MethodHandle OgaLoadImages$handle() {\n+        return OgaLoadImages.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImages(const OgaStringArray *image_paths, OgaImages **images)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadImages$address() {\n+        return OgaLoadImages.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImages(const OgaStringArray *image_paths, OgaImages **images)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadImages(MemorySegment image_paths, MemorySegment images) {\n+        var mh$ = OgaLoadImages.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaLoadImages\", image_paths, images);\n+            }\n+            return (MemorySegment)mh$.invokeExact(image_paths, images);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaLoadImagesFromBuffers {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaLoadImagesFromBuffers\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImagesFromBuffers(const void **image_data, const size_t *image_data_sizes, size_t count, OgaImages **images)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaLoadImagesFromBuffers$descriptor() {\n+        return OgaLoadImagesFromBuffers.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImagesFromBuffers(const void **image_data, const size_t *image_data_sizes, size_t count, OgaImages **images)\n+     * }\n+     *\/\n+    public static MethodHandle OgaLoadImagesFromBuffers$handle() {\n+        return OgaLoadImagesFromBuffers.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImagesFromBuffers(const void **image_data, const size_t *image_data_sizes, size_t count, OgaImages **images)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadImagesFromBuffers$address() {\n+        return OgaLoadImagesFromBuffers.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadImagesFromBuffers(const void **image_data, const size_t *image_data_sizes, size_t count, OgaImages **images)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadImagesFromBuffers(MemorySegment image_data, MemorySegment image_data_sizes, long count, MemorySegment images) {\n+        var mh$ = OgaLoadImagesFromBuffers.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaLoadImagesFromBuffers\", image_data, image_data_sizes, count, images);\n+            }\n+            return (MemorySegment)mh$.invokeExact(image_data, image_data_sizes, count, images);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyImages {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyImages\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyImages(OgaImages *images)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyImages$descriptor() {\n+        return OgaDestroyImages.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyImages(OgaImages *images)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyImages$handle() {\n+        return OgaDestroyImages.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyImages(OgaImages *images)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyImages$address() {\n+        return OgaDestroyImages.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyImages(OgaImages *images)\n+     * }\n+     *\/\n+    public static void OgaDestroyImages(MemorySegment images) {\n+        var mh$ = OgaDestroyImages.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyImages\", images);\n+            }\n+            mh$.invokeExact(images);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaLoadAudio {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaLoadAudio\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudio(const char *audio_path, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaLoadAudio$descriptor() {\n+        return OgaLoadAudio.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudio(const char *audio_path, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static MethodHandle OgaLoadAudio$handle() {\n+        return OgaLoadAudio.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudio(const char *audio_path, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadAudio$address() {\n+        return OgaLoadAudio.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudio(const char *audio_path, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadAudio(MemorySegment audio_path, MemorySegment audios) {\n+        var mh$ = OgaLoadAudio.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaLoadAudio\", audio_path, audios);\n+            }\n+            return (MemorySegment)mh$.invokeExact(audio_path, audios);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaLoadAudios {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaLoadAudios\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudios(const OgaStringArray *audio_paths, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaLoadAudios$descriptor() {\n+        return OgaLoadAudios.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudios(const OgaStringArray *audio_paths, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static MethodHandle OgaLoadAudios$handle() {\n+        return OgaLoadAudios.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudios(const OgaStringArray *audio_paths, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadAudios$address() {\n+        return OgaLoadAudios.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudios(const OgaStringArray *audio_paths, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadAudios(MemorySegment audio_paths, MemorySegment audios) {\n+        var mh$ = OgaLoadAudios.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaLoadAudios\", audio_paths, audios);\n+            }\n+            return (MemorySegment)mh$.invokeExact(audio_paths, audios);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaLoadAudiosFromBuffers {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaLoadAudiosFromBuffers\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudiosFromBuffers(const void **audio_data, const size_t *audio_data_sizes, size_t count, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaLoadAudiosFromBuffers$descriptor() {\n+        return OgaLoadAudiosFromBuffers.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudiosFromBuffers(const void **audio_data, const size_t *audio_data_sizes, size_t count, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static MethodHandle OgaLoadAudiosFromBuffers$handle() {\n+        return OgaLoadAudiosFromBuffers.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudiosFromBuffers(const void **audio_data, const size_t *audio_data_sizes, size_t count, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadAudiosFromBuffers$address() {\n+        return OgaLoadAudiosFromBuffers.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAudiosFromBuffers(const void **audio_data, const size_t *audio_data_sizes, size_t count, OgaAudios **audios)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadAudiosFromBuffers(MemorySegment audio_data, MemorySegment audio_data_sizes, long count, MemorySegment audios) {\n+        var mh$ = OgaLoadAudiosFromBuffers.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaLoadAudiosFromBuffers\", audio_data, audio_data_sizes, count, audios);\n+            }\n+            return (MemorySegment)mh$.invokeExact(audio_data, audio_data_sizes, count, audios);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyAudios {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyAudios\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyAudios(OgaAudios *audios)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyAudios$descriptor() {\n+        return OgaDestroyAudios.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyAudios(OgaAudios *audios)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyAudios$handle() {\n+        return OgaDestroyAudios.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyAudios(OgaAudios *audios)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyAudios$address() {\n+        return OgaDestroyAudios.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyAudios(OgaAudios *audios)\n+     * }\n+     *\/\n+    public static void OgaDestroyAudios(MemorySegment audios) {\n+        var mh$ = OgaDestroyAudios.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyAudios\", audios);\n+            }\n+            mh$.invokeExact(audios);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateRuntimeSettings {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateRuntimeSettings\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateRuntimeSettings(OgaRuntimeSettings **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateRuntimeSettings$descriptor() {\n+        return OgaCreateRuntimeSettings.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateRuntimeSettings(OgaRuntimeSettings **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateRuntimeSettings$handle() {\n+        return OgaCreateRuntimeSettings.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateRuntimeSettings(OgaRuntimeSettings **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateRuntimeSettings$address() {\n+        return OgaCreateRuntimeSettings.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateRuntimeSettings(OgaRuntimeSettings **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateRuntimeSettings(MemorySegment out) {\n+        var mh$ = OgaCreateRuntimeSettings.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateRuntimeSettings\", out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyRuntimeSettings {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyRuntimeSettings\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyRuntimeSettings(OgaRuntimeSettings *settings)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyRuntimeSettings$descriptor() {\n+        return OgaDestroyRuntimeSettings.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyRuntimeSettings(OgaRuntimeSettings *settings)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyRuntimeSettings$handle() {\n+        return OgaDestroyRuntimeSettings.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyRuntimeSettings(OgaRuntimeSettings *settings)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyRuntimeSettings$address() {\n+        return OgaDestroyRuntimeSettings.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyRuntimeSettings(OgaRuntimeSettings *settings)\n+     * }\n+     *\/\n+    public static void OgaDestroyRuntimeSettings(MemorySegment settings) {\n+        var mh$ = OgaDestroyRuntimeSettings.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyRuntimeSettings\", settings);\n+            }\n+            mh$.invokeExact(settings);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaRuntimeSettingsSetHandle {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaRuntimeSettingsSetHandle\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaRuntimeSettingsSetHandle(OgaRuntimeSettings *settings, const char *handle_name, void *handle)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaRuntimeSettingsSetHandle$descriptor() {\n+        return OgaRuntimeSettingsSetHandle.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaRuntimeSettingsSetHandle(OgaRuntimeSettings *settings, const char *handle_name, void *handle)\n+     * }\n+     *\/\n+    public static MethodHandle OgaRuntimeSettingsSetHandle$handle() {\n+        return OgaRuntimeSettingsSetHandle.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaRuntimeSettingsSetHandle(OgaRuntimeSettings *settings, const char *handle_name, void *handle)\n+     * }\n+     *\/\n+    public static MemorySegment OgaRuntimeSettingsSetHandle$address() {\n+        return OgaRuntimeSettingsSetHandle.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaRuntimeSettingsSetHandle(OgaRuntimeSettings *settings, const char *handle_name, void *handle)\n+     * }\n+     *\/\n+    public static MemorySegment OgaRuntimeSettingsSetHandle(MemorySegment settings, MemorySegment handle_name, MemorySegment handle) {\n+        var mh$ = OgaRuntimeSettingsSetHandle.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaRuntimeSettingsSetHandle\", settings, handle_name, handle);\n+            }\n+            return (MemorySegment)mh$.invokeExact(settings, handle_name, handle);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateConfig {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateConfig\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateConfig(const char *config_path, OgaConfig **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateConfig$descriptor() {\n+        return OgaCreateConfig.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateConfig(const char *config_path, OgaConfig **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateConfig$handle() {\n+        return OgaCreateConfig.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateConfig(const char *config_path, OgaConfig **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateConfig$address() {\n+        return OgaCreateConfig.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateConfig(const char *config_path, OgaConfig **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateConfig(MemorySegment config_path, MemorySegment out) {\n+        var mh$ = OgaCreateConfig.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateConfig\", config_path, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(config_path, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaConfigClearProviders {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaConfigClearProviders\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigClearProviders(OgaConfig *config)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaConfigClearProviders$descriptor() {\n+        return OgaConfigClearProviders.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigClearProviders(OgaConfig *config)\n+     * }\n+     *\/\n+    public static MethodHandle OgaConfigClearProviders$handle() {\n+        return OgaConfigClearProviders.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigClearProviders(OgaConfig *config)\n+     * }\n+     *\/\n+    public static MemorySegment OgaConfigClearProviders$address() {\n+        return OgaConfigClearProviders.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigClearProviders(OgaConfig *config)\n+     * }\n+     *\/\n+    public static MemorySegment OgaConfigClearProviders(MemorySegment config) {\n+        var mh$ = OgaConfigClearProviders.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaConfigClearProviders\", config);\n+            }\n+            return (MemorySegment)mh$.invokeExact(config);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaConfigAppendProvider {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaConfigAppendProvider\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigAppendProvider(OgaConfig *config, const char *provider)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaConfigAppendProvider$descriptor() {\n+        return OgaConfigAppendProvider.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigAppendProvider(OgaConfig *config, const char *provider)\n+     * }\n+     *\/\n+    public static MethodHandle OgaConfigAppendProvider$handle() {\n+        return OgaConfigAppendProvider.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigAppendProvider(OgaConfig *config, const char *provider)\n+     * }\n+     *\/\n+    public static MemorySegment OgaConfigAppendProvider$address() {\n+        return OgaConfigAppendProvider.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigAppendProvider(OgaConfig *config, const char *provider)\n+     * }\n+     *\/\n+    public static MemorySegment OgaConfigAppendProvider(MemorySegment config, MemorySegment provider) {\n+        var mh$ = OgaConfigAppendProvider.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaConfigAppendProvider\", config, provider);\n+            }\n+            return (MemorySegment)mh$.invokeExact(config, provider);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaConfigSetProviderOption {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaConfigSetProviderOption\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigSetProviderOption(OgaConfig *config, const char *provider, const char *key, const char *value)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaConfigSetProviderOption$descriptor() {\n+        return OgaConfigSetProviderOption.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigSetProviderOption(OgaConfig *config, const char *provider, const char *key, const char *value)\n+     * }\n+     *\/\n+    public static MethodHandle OgaConfigSetProviderOption$handle() {\n+        return OgaConfigSetProviderOption.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigSetProviderOption(OgaConfig *config, const char *provider, const char *key, const char *value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaConfigSetProviderOption$address() {\n+        return OgaConfigSetProviderOption.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigSetProviderOption(OgaConfig *config, const char *provider, const char *key, const char *value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaConfigSetProviderOption(MemorySegment config, MemorySegment provider, MemorySegment key, MemorySegment value) {\n+        var mh$ = OgaConfigSetProviderOption.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaConfigSetProviderOption\", config, provider, key, value);\n+            }\n+            return (MemorySegment)mh$.invokeExact(config, provider, key, value);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaConfigOverlay {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaConfigOverlay\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigOverlay(OgaConfig *config, const char *json)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaConfigOverlay$descriptor() {\n+        return OgaConfigOverlay.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigOverlay(OgaConfig *config, const char *json)\n+     * }\n+     *\/\n+    public static MethodHandle OgaConfigOverlay$handle() {\n+        return OgaConfigOverlay.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigOverlay(OgaConfig *config, const char *json)\n+     * }\n+     *\/\n+    public static MemorySegment OgaConfigOverlay$address() {\n+        return OgaConfigOverlay.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaConfigOverlay(OgaConfig *config, const char *json)\n+     * }\n+     *\/\n+    public static MemorySegment OgaConfigOverlay(MemorySegment config, MemorySegment json) {\n+        var mh$ = OgaConfigOverlay.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaConfigOverlay\", config, json);\n+            }\n+            return (MemorySegment)mh$.invokeExact(config, json);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateModel {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateModel\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModel(const char *config_path, OgaModel **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateModel$descriptor() {\n+        return OgaCreateModel.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModel(const char *config_path, OgaModel **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateModel$handle() {\n+        return OgaCreateModel.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModel(const char *config_path, OgaModel **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateModel$address() {\n+        return OgaCreateModel.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModel(const char *config_path, OgaModel **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateModel(MemorySegment config_path, MemorySegment out) {\n+        var mh$ = OgaCreateModel.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateModel\", config_path, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(config_path, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateModelFromConfig {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateModelFromConfig\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModelFromConfig(const OgaConfig *config, OgaModel **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateModelFromConfig$descriptor() {\n+        return OgaCreateModelFromConfig.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModelFromConfig(const OgaConfig *config, OgaModel **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateModelFromConfig$handle() {\n+        return OgaCreateModelFromConfig.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModelFromConfig(const OgaConfig *config, OgaModel **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateModelFromConfig$address() {\n+        return OgaCreateModelFromConfig.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModelFromConfig(const OgaConfig *config, OgaModel **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateModelFromConfig(MemorySegment config, MemorySegment out) {\n+        var mh$ = OgaCreateModelFromConfig.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateModelFromConfig\", config, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(config, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateModelWithRuntimeSettings {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateModelWithRuntimeSettings\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModelWithRuntimeSettings(const char *config_path, const OgaRuntimeSettings *settings, OgaModel **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateModelWithRuntimeSettings$descriptor() {\n+        return OgaCreateModelWithRuntimeSettings.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModelWithRuntimeSettings(const char *config_path, const OgaRuntimeSettings *settings, OgaModel **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateModelWithRuntimeSettings$handle() {\n+        return OgaCreateModelWithRuntimeSettings.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModelWithRuntimeSettings(const char *config_path, const OgaRuntimeSettings *settings, OgaModel **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateModelWithRuntimeSettings$address() {\n+        return OgaCreateModelWithRuntimeSettings.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateModelWithRuntimeSettings(const char *config_path, const OgaRuntimeSettings *settings, OgaModel **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateModelWithRuntimeSettings(MemorySegment config_path, MemorySegment settings, MemorySegment out) {\n+        var mh$ = OgaCreateModelWithRuntimeSettings.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateModelWithRuntimeSettings\", config_path, settings, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(config_path, settings, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaModelGetType {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaModelGetType\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaModelGetType(const OgaModel *model, const char **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaModelGetType$descriptor() {\n+        return OgaModelGetType.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaModelGetType(const OgaModel *model, const char **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaModelGetType$handle() {\n+        return OgaModelGetType.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaModelGetType(const OgaModel *model, const char **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaModelGetType$address() {\n+        return OgaModelGetType.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaModelGetType(const OgaModel *model, const char **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaModelGetType(MemorySegment model, MemorySegment out) {\n+        var mh$ = OgaModelGetType.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaModelGetType\", model, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(model, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaModelGetDeviceType {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaModelGetDeviceType\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaModelGetDeviceType(const OgaModel *model, const char **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaModelGetDeviceType$descriptor() {\n+        return OgaModelGetDeviceType.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaModelGetDeviceType(const OgaModel *model, const char **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaModelGetDeviceType$handle() {\n+        return OgaModelGetDeviceType.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaModelGetDeviceType(const OgaModel *model, const char **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaModelGetDeviceType$address() {\n+        return OgaModelGetDeviceType.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaModelGetDeviceType(const OgaModel *model, const char **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaModelGetDeviceType(MemorySegment model, MemorySegment out) {\n+        var mh$ = OgaModelGetDeviceType.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaModelGetDeviceType\", model, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(model, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyConfig {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyConfig\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyConfig(OgaConfig *config)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyConfig$descriptor() {\n+        return OgaDestroyConfig.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyConfig(OgaConfig *config)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyConfig$handle() {\n+        return OgaDestroyConfig.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyConfig(OgaConfig *config)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyConfig$address() {\n+        return OgaDestroyConfig.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyConfig(OgaConfig *config)\n+     * }\n+     *\/\n+    public static void OgaDestroyConfig(MemorySegment config) {\n+        var mh$ = OgaDestroyConfig.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyConfig\", config);\n+            }\n+            mh$.invokeExact(config);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyModel {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyModel\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyModel(OgaModel *model)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyModel$descriptor() {\n+        return OgaDestroyModel.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyModel(OgaModel *model)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyModel$handle() {\n+        return OgaDestroyModel.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyModel(OgaModel *model)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyModel$address() {\n+        return OgaDestroyModel.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyModel(OgaModel *model)\n+     * }\n+     *\/\n+    public static void OgaDestroyModel(MemorySegment model) {\n+        var mh$ = OgaDestroyModel.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyModel\", model);\n+            }\n+            mh$.invokeExact(model);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateGeneratorParams {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateGeneratorParams\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateGeneratorParams(const OgaModel *model, OgaGeneratorParams **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateGeneratorParams$descriptor() {\n+        return OgaCreateGeneratorParams.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateGeneratorParams(const OgaModel *model, OgaGeneratorParams **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateGeneratorParams$handle() {\n+        return OgaCreateGeneratorParams.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateGeneratorParams(const OgaModel *model, OgaGeneratorParams **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateGeneratorParams$address() {\n+        return OgaCreateGeneratorParams.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateGeneratorParams(const OgaModel *model, OgaGeneratorParams **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateGeneratorParams(MemorySegment model, MemorySegment out) {\n+        var mh$ = OgaCreateGeneratorParams.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateGeneratorParams\", model, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(model, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyGeneratorParams {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyGeneratorParams\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyGeneratorParams(OgaGeneratorParams *generator_params)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyGeneratorParams$descriptor() {\n+        return OgaDestroyGeneratorParams.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyGeneratorParams(OgaGeneratorParams *generator_params)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyGeneratorParams$handle() {\n+        return OgaDestroyGeneratorParams.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyGeneratorParams(OgaGeneratorParams *generator_params)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyGeneratorParams$address() {\n+        return OgaDestroyGeneratorParams.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyGeneratorParams(OgaGeneratorParams *generator_params)\n+     * }\n+     *\/\n+    public static void OgaDestroyGeneratorParams(MemorySegment generator_params) {\n+        var mh$ = OgaDestroyGeneratorParams.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyGeneratorParams\", generator_params);\n+            }\n+            mh$.invokeExact(generator_params);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGeneratorParamsSetSearchNumber {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_DOUBLE\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGeneratorParamsSetSearchNumber\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetSearchNumber(OgaGeneratorParams *generator_params, const char *name, double value)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGeneratorParamsSetSearchNumber$descriptor() {\n+        return OgaGeneratorParamsSetSearchNumber.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetSearchNumber(OgaGeneratorParams *generator_params, const char *name, double value)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGeneratorParamsSetSearchNumber$handle() {\n+        return OgaGeneratorParamsSetSearchNumber.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetSearchNumber(OgaGeneratorParams *generator_params, const char *name, double value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetSearchNumber$address() {\n+        return OgaGeneratorParamsSetSearchNumber.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetSearchNumber(OgaGeneratorParams *generator_params, const char *name, double value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetSearchNumber(MemorySegment generator_params, MemorySegment name, double value) {\n+        var mh$ = OgaGeneratorParamsSetSearchNumber.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGeneratorParamsSetSearchNumber\", generator_params, name, value);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator_params, name, value);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGeneratorParamsSetSearchBool {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_BOOL\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGeneratorParamsSetSearchBool\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetSearchBool(OgaGeneratorParams *generator_params, const char *name, bool value)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGeneratorParamsSetSearchBool$descriptor() {\n+        return OgaGeneratorParamsSetSearchBool.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetSearchBool(OgaGeneratorParams *generator_params, const char *name, bool value)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGeneratorParamsSetSearchBool$handle() {\n+        return OgaGeneratorParamsSetSearchBool.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetSearchBool(OgaGeneratorParams *generator_params, const char *name, bool value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetSearchBool$address() {\n+        return OgaGeneratorParamsSetSearchBool.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetSearchBool(OgaGeneratorParams *generator_params, const char *name, bool value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetSearchBool(MemorySegment generator_params, MemorySegment name, boolean value) {\n+        var mh$ = OgaGeneratorParamsSetSearchBool.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGeneratorParamsSetSearchBool\", generator_params, name, value);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator_params, name, value);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_INT\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize(OgaGeneratorParams *generator_params, int32_t max_batch_size)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize$descriptor() {\n+        return OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize(OgaGeneratorParams *generator_params, int32_t max_batch_size)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize$handle() {\n+        return OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize(OgaGeneratorParams *generator_params, int32_t max_batch_size)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize$address() {\n+        return OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize(OgaGeneratorParams *generator_params, int32_t max_batch_size)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize(MemorySegment generator_params, int max_batch_size) {\n+        var mh$ = OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGeneratorParamsTryGraphCaptureWithMaxBatchSize\", generator_params, max_batch_size);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator_params, max_batch_size);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGeneratorParamsSetInputs {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGeneratorParamsSetInputs\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetInputs(OgaGeneratorParams *generator_params, const OgaNamedTensors *named_tensors)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGeneratorParamsSetInputs$descriptor() {\n+        return OgaGeneratorParamsSetInputs.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetInputs(OgaGeneratorParams *generator_params, const OgaNamedTensors *named_tensors)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGeneratorParamsSetInputs$handle() {\n+        return OgaGeneratorParamsSetInputs.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetInputs(OgaGeneratorParams *generator_params, const OgaNamedTensors *named_tensors)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetInputs$address() {\n+        return OgaGeneratorParamsSetInputs.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetInputs(OgaGeneratorParams *generator_params, const OgaNamedTensors *named_tensors)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetInputs(MemorySegment generator_params, MemorySegment named_tensors) {\n+        var mh$ = OgaGeneratorParamsSetInputs.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGeneratorParamsSetInputs\", generator_params, named_tensors);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator_params, named_tensors);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGeneratorParamsSetModelInput {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGeneratorParamsSetModelInput\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetModelInput(OgaGeneratorParams *generator_params, const char *name, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGeneratorParamsSetModelInput$descriptor() {\n+        return OgaGeneratorParamsSetModelInput.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetModelInput(OgaGeneratorParams *generator_params, const char *name, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGeneratorParamsSetModelInput$handle() {\n+        return OgaGeneratorParamsSetModelInput.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetModelInput(OgaGeneratorParams *generator_params, const char *name, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetModelInput$address() {\n+        return OgaGeneratorParamsSetModelInput.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetModelInput(OgaGeneratorParams *generator_params, const char *name, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetModelInput(MemorySegment generator_params, MemorySegment name, MemorySegment tensor) {\n+        var mh$ = OgaGeneratorParamsSetModelInput.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGeneratorParamsSetModelInput\", generator_params, name, tensor);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator_params, name, tensor);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGeneratorParamsSetWhisperInputFeatures {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGeneratorParamsSetWhisperInputFeatures\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetWhisperInputFeatures(OgaGeneratorParams *generator_params, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGeneratorParamsSetWhisperInputFeatures$descriptor() {\n+        return OgaGeneratorParamsSetWhisperInputFeatures.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetWhisperInputFeatures(OgaGeneratorParams *generator_params, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGeneratorParamsSetWhisperInputFeatures$handle() {\n+        return OgaGeneratorParamsSetWhisperInputFeatures.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetWhisperInputFeatures(OgaGeneratorParams *generator_params, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetWhisperInputFeatures$address() {\n+        return OgaGeneratorParamsSetWhisperInputFeatures.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetWhisperInputFeatures(OgaGeneratorParams *generator_params, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetWhisperInputFeatures(MemorySegment generator_params, MemorySegment tensor) {\n+        var mh$ = OgaGeneratorParamsSetWhisperInputFeatures.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGeneratorParamsSetWhisperInputFeatures\", generator_params, tensor);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator_params, tensor);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGeneratorParamsSetGuidance {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGeneratorParamsSetGuidance\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetGuidance(OgaGeneratorParams *generator_params, const char *type, const char *data)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGeneratorParamsSetGuidance$descriptor() {\n+        return OgaGeneratorParamsSetGuidance.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetGuidance(OgaGeneratorParams *generator_params, const char *type, const char *data)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGeneratorParamsSetGuidance$handle() {\n+        return OgaGeneratorParamsSetGuidance.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetGuidance(OgaGeneratorParams *generator_params, const char *type, const char *data)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetGuidance$address() {\n+        return OgaGeneratorParamsSetGuidance.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGeneratorParamsSetGuidance(OgaGeneratorParams *generator_params, const char *type, const char *data)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGeneratorParamsSetGuidance(MemorySegment generator_params, MemorySegment type, MemorySegment data) {\n+        var mh$ = OgaGeneratorParamsSetGuidance.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGeneratorParamsSetGuidance\", generator_params, type, data);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator_params, type, data);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateGenerator {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateGenerator\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateGenerator(const OgaModel *model, const OgaGeneratorParams *params, OgaGenerator **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateGenerator$descriptor() {\n+        return OgaCreateGenerator.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateGenerator(const OgaModel *model, const OgaGeneratorParams *params, OgaGenerator **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateGenerator$handle() {\n+        return OgaCreateGenerator.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateGenerator(const OgaModel *model, const OgaGeneratorParams *params, OgaGenerator **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateGenerator$address() {\n+        return OgaCreateGenerator.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateGenerator(const OgaModel *model, const OgaGeneratorParams *params, OgaGenerator **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateGenerator(MemorySegment model, MemorySegment params, MemorySegment out) {\n+        var mh$ = OgaCreateGenerator.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateGenerator\", model, params, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(model, params, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyGenerator {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyGenerator\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyGenerator(OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyGenerator$descriptor() {\n+        return OgaDestroyGenerator.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyGenerator(OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyGenerator$handle() {\n+        return OgaDestroyGenerator.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyGenerator(OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyGenerator$address() {\n+        return OgaDestroyGenerator.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyGenerator(OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static void OgaDestroyGenerator(MemorySegment generator) {\n+        var mh$ = OgaDestroyGenerator.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyGenerator\", generator);\n+            }\n+            mh$.invokeExact(generator);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_IsDone {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_BOOL,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_IsDone\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * bool OgaGenerator_IsDone(const OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_IsDone$descriptor() {\n+        return OgaGenerator_IsDone.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * bool OgaGenerator_IsDone(const OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_IsDone$handle() {\n+        return OgaGenerator_IsDone.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * bool OgaGenerator_IsDone(const OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_IsDone$address() {\n+        return OgaGenerator_IsDone.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * bool OgaGenerator_IsDone(const OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static boolean OgaGenerator_IsDone(MemorySegment generator) {\n+        var mh$ = OgaGenerator_IsDone.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_IsDone\", generator);\n+            }\n+            return (boolean)mh$.invokeExact(generator);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_IsSessionTerminated {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_BOOL,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_IsSessionTerminated\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * bool OgaGenerator_IsSessionTerminated(const OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_IsSessionTerminated$descriptor() {\n+        return OgaGenerator_IsSessionTerminated.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * bool OgaGenerator_IsSessionTerminated(const OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_IsSessionTerminated$handle() {\n+        return OgaGenerator_IsSessionTerminated.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * bool OgaGenerator_IsSessionTerminated(const OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_IsSessionTerminated$address() {\n+        return OgaGenerator_IsSessionTerminated.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * bool OgaGenerator_IsSessionTerminated(const OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static boolean OgaGenerator_IsSessionTerminated(MemorySegment generator) {\n+        var mh$ = OgaGenerator_IsSessionTerminated.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_IsSessionTerminated\", generator);\n+            }\n+            return (boolean)mh$.invokeExact(generator);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_AppendTokenSequences {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_AppendTokenSequences\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_AppendTokenSequences(OgaGenerator *oga_generator, const OgaSequences *p_sequences)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_AppendTokenSequences$descriptor() {\n+        return OgaGenerator_AppendTokenSequences.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_AppendTokenSequences(OgaGenerator *oga_generator, const OgaSequences *p_sequences)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_AppendTokenSequences$handle() {\n+        return OgaGenerator_AppendTokenSequences.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_AppendTokenSequences(OgaGenerator *oga_generator, const OgaSequences *p_sequences)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_AppendTokenSequences$address() {\n+        return OgaGenerator_AppendTokenSequences.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_AppendTokenSequences(OgaGenerator *oga_generator, const OgaSequences *p_sequences)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_AppendTokenSequences(MemorySegment oga_generator, MemorySegment p_sequences) {\n+        var mh$ = OgaGenerator_AppendTokenSequences.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_AppendTokenSequences\", oga_generator, p_sequences);\n+            }\n+            return (MemorySegment)mh$.invokeExact(oga_generator, p_sequences);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_AppendTokens {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_AppendTokens\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_AppendTokens(OgaGenerator *oga_generator, const int32_t *input_ids, size_t input_ids_count)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_AppendTokens$descriptor() {\n+        return OgaGenerator_AppendTokens.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_AppendTokens(OgaGenerator *oga_generator, const int32_t *input_ids, size_t input_ids_count)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_AppendTokens$handle() {\n+        return OgaGenerator_AppendTokens.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_AppendTokens(OgaGenerator *oga_generator, const int32_t *input_ids, size_t input_ids_count)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_AppendTokens$address() {\n+        return OgaGenerator_AppendTokens.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_AppendTokens(OgaGenerator *oga_generator, const int32_t *input_ids, size_t input_ids_count)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_AppendTokens(MemorySegment oga_generator, MemorySegment input_ids, long input_ids_count) {\n+        var mh$ = OgaGenerator_AppendTokens.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_AppendTokens\", oga_generator, input_ids, input_ids_count);\n+            }\n+            return (MemorySegment)mh$.invokeExact(oga_generator, input_ids, input_ids_count);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_GenerateNextToken {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_GenerateNextToken\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GenerateNextToken(OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_GenerateNextToken$descriptor() {\n+        return OgaGenerator_GenerateNextToken.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GenerateNextToken(OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_GenerateNextToken$handle() {\n+        return OgaGenerator_GenerateNextToken.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GenerateNextToken(OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_GenerateNextToken$address() {\n+        return OgaGenerator_GenerateNextToken.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GenerateNextToken(OgaGenerator *generator)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_GenerateNextToken(MemorySegment generator) {\n+        var mh$ = OgaGenerator_GenerateNextToken.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_GenerateNextToken\", generator);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_GetNextTokens {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_GetNextTokens\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetNextTokens(const OgaGenerator *generator, const int32_t **out, size_t *out_count)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_GetNextTokens$descriptor() {\n+        return OgaGenerator_GetNextTokens.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetNextTokens(const OgaGenerator *generator, const int32_t **out, size_t *out_count)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_GetNextTokens$handle() {\n+        return OgaGenerator_GetNextTokens.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetNextTokens(const OgaGenerator *generator, const int32_t **out, size_t *out_count)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_GetNextTokens$address() {\n+        return OgaGenerator_GetNextTokens.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetNextTokens(const OgaGenerator *generator, const int32_t **out, size_t *out_count)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_GetNextTokens(MemorySegment generator, MemorySegment out, MemorySegment out_count) {\n+        var mh$ = OgaGenerator_GetNextTokens.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_GetNextTokens\", generator, out, out_count);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator, out, out_count);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_SetRuntimeOption {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_SetRuntimeOption\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_SetRuntimeOption(OgaGenerator *generator, const char *key, const char *value)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_SetRuntimeOption$descriptor() {\n+        return OgaGenerator_SetRuntimeOption.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_SetRuntimeOption(OgaGenerator *generator, const char *key, const char *value)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_SetRuntimeOption$handle() {\n+        return OgaGenerator_SetRuntimeOption.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_SetRuntimeOption(OgaGenerator *generator, const char *key, const char *value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_SetRuntimeOption$address() {\n+        return OgaGenerator_SetRuntimeOption.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_SetRuntimeOption(OgaGenerator *generator, const char *key, const char *value)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_SetRuntimeOption(MemorySegment generator, MemorySegment key, MemorySegment value) {\n+        var mh$ = OgaGenerator_SetRuntimeOption.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_SetRuntimeOption\", generator, key, value);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator, key, value);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_RewindTo {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_RewindTo\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_RewindTo(OgaGenerator *generator, size_t new_length)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_RewindTo$descriptor() {\n+        return OgaGenerator_RewindTo.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_RewindTo(OgaGenerator *generator, size_t new_length)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_RewindTo$handle() {\n+        return OgaGenerator_RewindTo.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_RewindTo(OgaGenerator *generator, size_t new_length)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_RewindTo$address() {\n+        return OgaGenerator_RewindTo.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_RewindTo(OgaGenerator *generator, size_t new_length)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_RewindTo(MemorySegment generator, long new_length) {\n+        var mh$ = OgaGenerator_RewindTo.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_RewindTo\", generator, new_length);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator, new_length);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_GetOutput {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_GetOutput\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetOutput(const OgaGenerator *generator, const char *name, OgaTensor **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_GetOutput$descriptor() {\n+        return OgaGenerator_GetOutput.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetOutput(const OgaGenerator *generator, const char *name, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_GetOutput$handle() {\n+        return OgaGenerator_GetOutput.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetOutput(const OgaGenerator *generator, const char *name, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_GetOutput$address() {\n+        return OgaGenerator_GetOutput.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetOutput(const OgaGenerator *generator, const char *name, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_GetOutput(MemorySegment generator, MemorySegment name, MemorySegment out) {\n+        var mh$ = OgaGenerator_GetOutput.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_GetOutput\", generator, name, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator, name, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_GetLogits {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_GetLogits\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetLogits(OgaGenerator *generator, OgaTensor **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_GetLogits$descriptor() {\n+        return OgaGenerator_GetLogits.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetLogits(OgaGenerator *generator, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_GetLogits$handle() {\n+        return OgaGenerator_GetLogits.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetLogits(OgaGenerator *generator, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_GetLogits$address() {\n+        return OgaGenerator_GetLogits.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_GetLogits(OgaGenerator *generator, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_GetLogits(MemorySegment generator, MemorySegment out) {\n+        var mh$ = OgaGenerator_GetLogits.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_GetLogits\", generator, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_SetLogits {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_SetLogits\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_SetLogits(OgaGenerator *generator, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_SetLogits$descriptor() {\n+        return OgaGenerator_SetLogits.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_SetLogits(OgaGenerator *generator, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_SetLogits$handle() {\n+        return OgaGenerator_SetLogits.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_SetLogits(OgaGenerator *generator, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_SetLogits$address() {\n+        return OgaGenerator_SetLogits.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGenerator_SetLogits(OgaGenerator *generator, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_SetLogits(MemorySegment generator, MemorySegment tensor) {\n+        var mh$ = OgaGenerator_SetLogits.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_SetLogits\", generator, tensor);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator, tensor);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_GetSequenceCount {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_GetSequenceCount\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * size_t OgaGenerator_GetSequenceCount(const OgaGenerator *generator, size_t index)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_GetSequenceCount$descriptor() {\n+        return OgaGenerator_GetSequenceCount.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * size_t OgaGenerator_GetSequenceCount(const OgaGenerator *generator, size_t index)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_GetSequenceCount$handle() {\n+        return OgaGenerator_GetSequenceCount.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * size_t OgaGenerator_GetSequenceCount(const OgaGenerator *generator, size_t index)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_GetSequenceCount$address() {\n+        return OgaGenerator_GetSequenceCount.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * size_t OgaGenerator_GetSequenceCount(const OgaGenerator *generator, size_t index)\n+     * }\n+     *\/\n+    public static long OgaGenerator_GetSequenceCount(MemorySegment generator, long index) {\n+        var mh$ = OgaGenerator_GetSequenceCount.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_GetSequenceCount\", generator, index);\n+            }\n+            return (long)mh$.invokeExact(generator, index);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGenerator_GetSequenceData {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGenerator_GetSequenceData\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * const int32_t *OgaGenerator_GetSequenceData(const OgaGenerator *generator, size_t index)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGenerator_GetSequenceData$descriptor() {\n+        return OgaGenerator_GetSequenceData.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * const int32_t *OgaGenerator_GetSequenceData(const OgaGenerator *generator, size_t index)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGenerator_GetSequenceData$handle() {\n+        return OgaGenerator_GetSequenceData.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * const int32_t *OgaGenerator_GetSequenceData(const OgaGenerator *generator, size_t index)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_GetSequenceData$address() {\n+        return OgaGenerator_GetSequenceData.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const int32_t *OgaGenerator_GetSequenceData(const OgaGenerator *generator, size_t index)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGenerator_GetSequenceData(MemorySegment generator, long index) {\n+        var mh$ = OgaGenerator_GetSequenceData.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGenerator_GetSequenceData\", generator, index);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator, index);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateTokenizer {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateTokenizer\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizer(const OgaModel *model, OgaTokenizer **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateTokenizer$descriptor() {\n+        return OgaCreateTokenizer.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizer(const OgaModel *model, OgaTokenizer **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateTokenizer$handle() {\n+        return OgaCreateTokenizer.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizer(const OgaModel *model, OgaTokenizer **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateTokenizer$address() {\n+        return OgaCreateTokenizer.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizer(const OgaModel *model, OgaTokenizer **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateTokenizer(MemorySegment model, MemorySegment out) {\n+        var mh$ = OgaCreateTokenizer.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateTokenizer\", model, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(model, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyTokenizer {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyTokenizer\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyTokenizer(OgaTokenizer *)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyTokenizer$descriptor() {\n+        return OgaDestroyTokenizer.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyTokenizer(OgaTokenizer *)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyTokenizer$handle() {\n+        return OgaDestroyTokenizer.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyTokenizer(OgaTokenizer *)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyTokenizer$address() {\n+        return OgaDestroyTokenizer.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyTokenizer(OgaTokenizer *)\n+     * }\n+     *\/\n+    public static void OgaDestroyTokenizer(MemorySegment x0) {\n+        var mh$ = OgaDestroyTokenizer.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyTokenizer\", x0);\n+            }\n+            mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateMultiModalProcessor {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateMultiModalProcessor\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateMultiModalProcessor(const OgaModel *model, OgaMultiModalProcessor **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateMultiModalProcessor$descriptor() {\n+        return OgaCreateMultiModalProcessor.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateMultiModalProcessor(const OgaModel *model, OgaMultiModalProcessor **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateMultiModalProcessor$handle() {\n+        return OgaCreateMultiModalProcessor.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateMultiModalProcessor(const OgaModel *model, OgaMultiModalProcessor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateMultiModalProcessor$address() {\n+        return OgaCreateMultiModalProcessor.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateMultiModalProcessor(const OgaModel *model, OgaMultiModalProcessor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateMultiModalProcessor(MemorySegment model, MemorySegment out) {\n+        var mh$ = OgaCreateMultiModalProcessor.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateMultiModalProcessor\", model, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(model, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyMultiModalProcessor {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyMultiModalProcessor\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyMultiModalProcessor(OgaMultiModalProcessor *processor)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyMultiModalProcessor$descriptor() {\n+        return OgaDestroyMultiModalProcessor.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyMultiModalProcessor(OgaMultiModalProcessor *processor)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyMultiModalProcessor$handle() {\n+        return OgaDestroyMultiModalProcessor.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyMultiModalProcessor(OgaMultiModalProcessor *processor)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyMultiModalProcessor$address() {\n+        return OgaDestroyMultiModalProcessor.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyMultiModalProcessor(OgaMultiModalProcessor *processor)\n+     * }\n+     *\/\n+    public static void OgaDestroyMultiModalProcessor(MemorySegment processor) {\n+        var mh$ = OgaDestroyMultiModalProcessor.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyMultiModalProcessor\", processor);\n+            }\n+            mh$.invokeExact(processor);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaTokenizerEncode {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaTokenizerEncode\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerEncode(const OgaTokenizer *, const char *str, OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaTokenizerEncode$descriptor() {\n+        return OgaTokenizerEncode.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerEncode(const OgaTokenizer *, const char *str, OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static MethodHandle OgaTokenizerEncode$handle() {\n+        return OgaTokenizerEncode.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerEncode(const OgaTokenizer *, const char *str, OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerEncode$address() {\n+        return OgaTokenizerEncode.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerEncode(const OgaTokenizer *, const char *str, OgaSequences *sequences)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerEncode(MemorySegment x0, MemorySegment str, MemorySegment sequences) {\n+        var mh$ = OgaTokenizerEncode.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaTokenizerEncode\", x0, str, sequences);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, str, sequences);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaTokenizerEncodeBatch {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaTokenizerEncodeBatch\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerEncodeBatch(const OgaTokenizer *, const char **strings, size_t count, OgaTensor **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaTokenizerEncodeBatch$descriptor() {\n+        return OgaTokenizerEncodeBatch.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerEncodeBatch(const OgaTokenizer *, const char **strings, size_t count, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaTokenizerEncodeBatch$handle() {\n+        return OgaTokenizerEncodeBatch.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerEncodeBatch(const OgaTokenizer *, const char **strings, size_t count, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerEncodeBatch$address() {\n+        return OgaTokenizerEncodeBatch.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerEncodeBatch(const OgaTokenizer *, const char **strings, size_t count, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerEncodeBatch(MemorySegment x0, MemorySegment strings, long count, MemorySegment out) {\n+        var mh$ = OgaTokenizerEncodeBatch.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaTokenizerEncodeBatch\", x0, strings, count, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, strings, count, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaTokenizerDecodeBatch {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaTokenizerDecodeBatch\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerDecodeBatch(const OgaTokenizer *, const OgaTensor *tensor, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaTokenizerDecodeBatch$descriptor() {\n+        return OgaTokenizerDecodeBatch.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerDecodeBatch(const OgaTokenizer *, const OgaTensor *tensor, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaTokenizerDecodeBatch$handle() {\n+        return OgaTokenizerDecodeBatch.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerDecodeBatch(const OgaTokenizer *, const OgaTensor *tensor, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerDecodeBatch$address() {\n+        return OgaTokenizerDecodeBatch.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerDecodeBatch(const OgaTokenizer *, const OgaTensor *tensor, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerDecodeBatch(MemorySegment x0, MemorySegment tensor, MemorySegment out) {\n+        var mh$ = OgaTokenizerDecodeBatch.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaTokenizerDecodeBatch\", x0, tensor, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, tensor, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaTokenizerToTokenId {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaTokenizerToTokenId\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerToTokenId(const OgaTokenizer *tokenizer, const char *str, int32_t *token_id)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaTokenizerToTokenId$descriptor() {\n+        return OgaTokenizerToTokenId.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerToTokenId(const OgaTokenizer *tokenizer, const char *str, int32_t *token_id)\n+     * }\n+     *\/\n+    public static MethodHandle OgaTokenizerToTokenId$handle() {\n+        return OgaTokenizerToTokenId.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerToTokenId(const OgaTokenizer *tokenizer, const char *str, int32_t *token_id)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerToTokenId$address() {\n+        return OgaTokenizerToTokenId.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerToTokenId(const OgaTokenizer *tokenizer, const char *str, int32_t *token_id)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerToTokenId(MemorySegment tokenizer, MemorySegment str, MemorySegment token_id) {\n+        var mh$ = OgaTokenizerToTokenId.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaTokenizerToTokenId\", tokenizer, str, token_id);\n+            }\n+            return (MemorySegment)mh$.invokeExact(tokenizer, str, token_id);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaProcessorProcessImages {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaProcessorProcessImages\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessImages(const OgaMultiModalProcessor *, const char *prompt, const OgaImages *images, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaProcessorProcessImages$descriptor() {\n+        return OgaProcessorProcessImages.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessImages(const OgaMultiModalProcessor *, const char *prompt, const OgaImages *images, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static MethodHandle OgaProcessorProcessImages$handle() {\n+        return OgaProcessorProcessImages.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessImages(const OgaMultiModalProcessor *, const char *prompt, const OgaImages *images, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static MemorySegment OgaProcessorProcessImages$address() {\n+        return OgaProcessorProcessImages.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessImages(const OgaMultiModalProcessor *, const char *prompt, const OgaImages *images, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static MemorySegment OgaProcessorProcessImages(MemorySegment x0, MemorySegment prompt, MemorySegment images, MemorySegment input_tensors) {\n+        var mh$ = OgaProcessorProcessImages.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaProcessorProcessImages\", x0, prompt, images, input_tensors);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, prompt, images, input_tensors);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaProcessorProcessAudios {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaProcessorProcessAudios\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessAudios(const OgaMultiModalProcessor *, const OgaAudios *audios, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaProcessorProcessAudios$descriptor() {\n+        return OgaProcessorProcessAudios.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessAudios(const OgaMultiModalProcessor *, const OgaAudios *audios, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static MethodHandle OgaProcessorProcessAudios$handle() {\n+        return OgaProcessorProcessAudios.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessAudios(const OgaMultiModalProcessor *, const OgaAudios *audios, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static MemorySegment OgaProcessorProcessAudios$address() {\n+        return OgaProcessorProcessAudios.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessAudios(const OgaMultiModalProcessor *, const OgaAudios *audios, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static MemorySegment OgaProcessorProcessAudios(MemorySegment x0, MemorySegment audios, MemorySegment input_tensors) {\n+        var mh$ = OgaProcessorProcessAudios.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaProcessorProcessAudios\", x0, audios, input_tensors);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, audios, input_tensors);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaProcessorProcessImagesAndAudios {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaProcessorProcessImagesAndAudios\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessImagesAndAudios(const OgaMultiModalProcessor *, const char *prompt, const OgaImages *images, const OgaAudios *audios, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaProcessorProcessImagesAndAudios$descriptor() {\n+        return OgaProcessorProcessImagesAndAudios.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessImagesAndAudios(const OgaMultiModalProcessor *, const char *prompt, const OgaImages *images, const OgaAudios *audios, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static MethodHandle OgaProcessorProcessImagesAndAudios$handle() {\n+        return OgaProcessorProcessImagesAndAudios.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessImagesAndAudios(const OgaMultiModalProcessor *, const char *prompt, const OgaImages *images, const OgaAudios *audios, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static MemorySegment OgaProcessorProcessImagesAndAudios$address() {\n+        return OgaProcessorProcessImagesAndAudios.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorProcessImagesAndAudios(const OgaMultiModalProcessor *, const char *prompt, const OgaImages *images, const OgaAudios *audios, OgaNamedTensors **input_tensors)\n+     * }\n+     *\/\n+    public static MemorySegment OgaProcessorProcessImagesAndAudios(MemorySegment x0, MemorySegment prompt, MemorySegment images, MemorySegment audios, MemorySegment input_tensors) {\n+        var mh$ = OgaProcessorProcessImagesAndAudios.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaProcessorProcessImagesAndAudios\", x0, prompt, images, audios, input_tensors);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, prompt, images, audios, input_tensors);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaTokenizerDecode {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaTokenizerDecode\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerDecode(const OgaTokenizer *, const int32_t *tokens, size_t token_count, const char **out_string)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaTokenizerDecode$descriptor() {\n+        return OgaTokenizerDecode.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerDecode(const OgaTokenizer *, const int32_t *tokens, size_t token_count, const char **out_string)\n+     * }\n+     *\/\n+    public static MethodHandle OgaTokenizerDecode$handle() {\n+        return OgaTokenizerDecode.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerDecode(const OgaTokenizer *, const int32_t *tokens, size_t token_count, const char **out_string)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerDecode$address() {\n+        return OgaTokenizerDecode.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerDecode(const OgaTokenizer *, const int32_t *tokens, size_t token_count, const char **out_string)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerDecode(MemorySegment x0, MemorySegment tokens, long token_count, MemorySegment out_string) {\n+        var mh$ = OgaTokenizerDecode.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaTokenizerDecode\", x0, tokens, token_count, out_string);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, tokens, token_count, out_string);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaProcessorDecode {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaProcessorDecode\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorDecode(const OgaMultiModalProcessor *, const int32_t *tokens, size_t token_count, const char **out_string)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaProcessorDecode$descriptor() {\n+        return OgaProcessorDecode.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorDecode(const OgaMultiModalProcessor *, const int32_t *tokens, size_t token_count, const char **out_string)\n+     * }\n+     *\/\n+    public static MethodHandle OgaProcessorDecode$handle() {\n+        return OgaProcessorDecode.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorDecode(const OgaMultiModalProcessor *, const int32_t *tokens, size_t token_count, const char **out_string)\n+     * }\n+     *\/\n+    public static MemorySegment OgaProcessorDecode$address() {\n+        return OgaProcessorDecode.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaProcessorDecode(const OgaMultiModalProcessor *, const int32_t *tokens, size_t token_count, const char **out_string)\n+     * }\n+     *\/\n+    public static MemorySegment OgaProcessorDecode(MemorySegment x0, MemorySegment tokens, long token_count, MemorySegment out_string) {\n+        var mh$ = OgaProcessorDecode.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaProcessorDecode\", x0, tokens, token_count, out_string);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, tokens, token_count, out_string);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaTokenizerApplyChatTemplate {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_BOOL,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaTokenizerApplyChatTemplate\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerApplyChatTemplate(const OgaTokenizer *, const char *template_str, const char *messages, bool add_generation_prompt, const char **out_string)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaTokenizerApplyChatTemplate$descriptor() {\n+        return OgaTokenizerApplyChatTemplate.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerApplyChatTemplate(const OgaTokenizer *, const char *template_str, const char *messages, bool add_generation_prompt, const char **out_string)\n+     * }\n+     *\/\n+    public static MethodHandle OgaTokenizerApplyChatTemplate$handle() {\n+        return OgaTokenizerApplyChatTemplate.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerApplyChatTemplate(const OgaTokenizer *, const char *template_str, const char *messages, bool add_generation_prompt, const char **out_string)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerApplyChatTemplate$address() {\n+        return OgaTokenizerApplyChatTemplate.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerApplyChatTemplate(const OgaTokenizer *, const char *template_str, const char *messages, bool add_generation_prompt, const char **out_string)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerApplyChatTemplate(MemorySegment x0, MemorySegment template_str, MemorySegment messages, boolean add_generation_prompt, MemorySegment out_string) {\n+        var mh$ = OgaTokenizerApplyChatTemplate.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaTokenizerApplyChatTemplate\", x0, template_str, messages, add_generation_prompt, out_string);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, template_str, messages, add_generation_prompt, out_string);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateTokenizerStream {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateTokenizerStream\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizerStream(const OgaTokenizer *, OgaTokenizerStream **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateTokenizerStream$descriptor() {\n+        return OgaCreateTokenizerStream.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizerStream(const OgaTokenizer *, OgaTokenizerStream **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateTokenizerStream$handle() {\n+        return OgaCreateTokenizerStream.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizerStream(const OgaTokenizer *, OgaTokenizerStream **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateTokenizerStream$address() {\n+        return OgaCreateTokenizerStream.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizerStream(const OgaTokenizer *, OgaTokenizerStream **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateTokenizerStream(MemorySegment x0, MemorySegment out) {\n+        var mh$ = OgaCreateTokenizerStream.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateTokenizerStream\", x0, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateTokenizerStreamFromProcessor {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateTokenizerStreamFromProcessor\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizerStreamFromProcessor(const OgaMultiModalProcessor *, OgaTokenizerStream **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateTokenizerStreamFromProcessor$descriptor() {\n+        return OgaCreateTokenizerStreamFromProcessor.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizerStreamFromProcessor(const OgaMultiModalProcessor *, OgaTokenizerStream **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateTokenizerStreamFromProcessor$handle() {\n+        return OgaCreateTokenizerStreamFromProcessor.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizerStreamFromProcessor(const OgaMultiModalProcessor *, OgaTokenizerStream **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateTokenizerStreamFromProcessor$address() {\n+        return OgaCreateTokenizerStreamFromProcessor.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTokenizerStreamFromProcessor(const OgaMultiModalProcessor *, OgaTokenizerStream **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateTokenizerStreamFromProcessor(MemorySegment x0, MemorySegment out) {\n+        var mh$ = OgaCreateTokenizerStreamFromProcessor.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateTokenizerStreamFromProcessor\", x0, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyTokenizerStream {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyTokenizerStream\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyTokenizerStream(OgaTokenizerStream *)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyTokenizerStream$descriptor() {\n+        return OgaDestroyTokenizerStream.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyTokenizerStream(OgaTokenizerStream *)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyTokenizerStream$handle() {\n+        return OgaDestroyTokenizerStream.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyTokenizerStream(OgaTokenizerStream *)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyTokenizerStream$address() {\n+        return OgaDestroyTokenizerStream.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyTokenizerStream(OgaTokenizerStream *)\n+     * }\n+     *\/\n+    public static void OgaDestroyTokenizerStream(MemorySegment x0) {\n+        var mh$ = OgaDestroyTokenizerStream.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyTokenizerStream\", x0);\n+            }\n+            mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaTokenizerStreamDecode {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_INT,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaTokenizerStreamDecode\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerStreamDecode(OgaTokenizerStream *, int32_t token, const char **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaTokenizerStreamDecode$descriptor() {\n+        return OgaTokenizerStreamDecode.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerStreamDecode(OgaTokenizerStream *, int32_t token, const char **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaTokenizerStreamDecode$handle() {\n+        return OgaTokenizerStreamDecode.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerStreamDecode(OgaTokenizerStream *, int32_t token, const char **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerStreamDecode$address() {\n+        return OgaTokenizerStreamDecode.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTokenizerStreamDecode(OgaTokenizerStream *, int32_t token, const char **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTokenizerStreamDecode(MemorySegment x0, int token, MemorySegment out) {\n+        var mh$ = OgaTokenizerStreamDecode.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaTokenizerStreamDecode\", x0, token, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, token, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateTensorFromBuffer {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_INT,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateTensorFromBuffer\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTensorFromBuffer(void *data, const int64_t *shape_dims, size_t shape_dims_count, OgaElementType element_type, OgaTensor **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateTensorFromBuffer$descriptor() {\n+        return OgaCreateTensorFromBuffer.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTensorFromBuffer(void *data, const int64_t *shape_dims, size_t shape_dims_count, OgaElementType element_type, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateTensorFromBuffer$handle() {\n+        return OgaCreateTensorFromBuffer.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTensorFromBuffer(void *data, const int64_t *shape_dims, size_t shape_dims_count, OgaElementType element_type, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateTensorFromBuffer$address() {\n+        return OgaCreateTensorFromBuffer.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateTensorFromBuffer(void *data, const int64_t *shape_dims, size_t shape_dims_count, OgaElementType element_type, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateTensorFromBuffer(MemorySegment data, MemorySegment shape_dims, long shape_dims_count, int element_type, MemorySegment out) {\n+        var mh$ = OgaCreateTensorFromBuffer.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateTensorFromBuffer\", data, shape_dims, shape_dims_count, element_type, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(data, shape_dims, shape_dims_count, element_type, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyTensor {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyTensor\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyTensor(OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyTensor$descriptor() {\n+        return OgaDestroyTensor.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyTensor(OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyTensor$handle() {\n+        return OgaDestroyTensor.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyTensor(OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyTensor$address() {\n+        return OgaDestroyTensor.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyTensor(OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static void OgaDestroyTensor(MemorySegment tensor) {\n+        var mh$ = OgaDestroyTensor.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyTensor\", tensor);\n+            }\n+            mh$.invokeExact(tensor);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaTensorGetType {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaTensorGetType\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetType(OgaTensor *, OgaElementType *out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaTensorGetType$descriptor() {\n+        return OgaTensorGetType.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetType(OgaTensor *, OgaElementType *out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaTensorGetType$handle() {\n+        return OgaTensorGetType.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetType(OgaTensor *, OgaElementType *out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTensorGetType$address() {\n+        return OgaTensorGetType.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetType(OgaTensor *, OgaElementType *out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTensorGetType(MemorySegment x0, MemorySegment out) {\n+        var mh$ = OgaTensorGetType.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaTensorGetType\", x0, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaTensorGetShapeRank {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaTensorGetShapeRank\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetShapeRank(OgaTensor *, size_t *out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaTensorGetShapeRank$descriptor() {\n+        return OgaTensorGetShapeRank.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetShapeRank(OgaTensor *, size_t *out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaTensorGetShapeRank$handle() {\n+        return OgaTensorGetShapeRank.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetShapeRank(OgaTensor *, size_t *out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTensorGetShapeRank$address() {\n+        return OgaTensorGetShapeRank.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetShapeRank(OgaTensor *, size_t *out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTensorGetShapeRank(MemorySegment x0, MemorySegment out) {\n+        var mh$ = OgaTensorGetShapeRank.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaTensorGetShapeRank\", x0, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaTensorGetShape {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaTensorGetShape\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetShape(OgaTensor *, int64_t *shape_dims, size_t shape_dims_count)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaTensorGetShape$descriptor() {\n+        return OgaTensorGetShape.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetShape(OgaTensor *, int64_t *shape_dims, size_t shape_dims_count)\n+     * }\n+     *\/\n+    public static MethodHandle OgaTensorGetShape$handle() {\n+        return OgaTensorGetShape.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetShape(OgaTensor *, int64_t *shape_dims, size_t shape_dims_count)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTensorGetShape$address() {\n+        return OgaTensorGetShape.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetShape(OgaTensor *, int64_t *shape_dims, size_t shape_dims_count)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTensorGetShape(MemorySegment x0, MemorySegment shape_dims, long shape_dims_count) {\n+        var mh$ = OgaTensorGetShape.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaTensorGetShape\", x0, shape_dims, shape_dims_count);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, shape_dims, shape_dims_count);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaTensorGetData {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaTensorGetData\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetData(OgaTensor *, void **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaTensorGetData$descriptor() {\n+        return OgaTensorGetData.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetData(OgaTensor *, void **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaTensorGetData$handle() {\n+        return OgaTensorGetData.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetData(OgaTensor *, void **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTensorGetData$address() {\n+        return OgaTensorGetData.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaTensorGetData(OgaTensor *, void **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaTensorGetData(MemorySegment x0, MemorySegment out) {\n+        var mh$ = OgaTensorGetData.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaTensorGetData\", x0, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(x0, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateNamedTensors {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateNamedTensors\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateNamedTensors(OgaNamedTensors **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateNamedTensors$descriptor() {\n+        return OgaCreateNamedTensors.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateNamedTensors(OgaNamedTensors **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateNamedTensors$handle() {\n+        return OgaCreateNamedTensors.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateNamedTensors(OgaNamedTensors **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateNamedTensors$address() {\n+        return OgaCreateNamedTensors.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateNamedTensors(OgaNamedTensors **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateNamedTensors(MemorySegment out) {\n+        var mh$ = OgaCreateNamedTensors.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateNamedTensors\", out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaNamedTensorsGet {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaNamedTensorsGet\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsGet(OgaNamedTensors *named_tensors, const char *name, OgaTensor **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaNamedTensorsGet$descriptor() {\n+        return OgaNamedTensorsGet.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsGet(OgaNamedTensors *named_tensors, const char *name, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaNamedTensorsGet$handle() {\n+        return OgaNamedTensorsGet.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsGet(OgaNamedTensors *named_tensors, const char *name, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaNamedTensorsGet$address() {\n+        return OgaNamedTensorsGet.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsGet(OgaNamedTensors *named_tensors, const char *name, OgaTensor **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaNamedTensorsGet(MemorySegment named_tensors, MemorySegment name, MemorySegment out) {\n+        var mh$ = OgaNamedTensorsGet.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaNamedTensorsGet\", named_tensors, name, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(named_tensors, name, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaNamedTensorsSet {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaNamedTensorsSet\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsSet(OgaNamedTensors *named_tensors, const char *name, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaNamedTensorsSet$descriptor() {\n+        return OgaNamedTensorsSet.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsSet(OgaNamedTensors *named_tensors, const char *name, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MethodHandle OgaNamedTensorsSet$handle() {\n+        return OgaNamedTensorsSet.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsSet(OgaNamedTensors *named_tensors, const char *name, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MemorySegment OgaNamedTensorsSet$address() {\n+        return OgaNamedTensorsSet.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsSet(OgaNamedTensors *named_tensors, const char *name, OgaTensor *tensor)\n+     * }\n+     *\/\n+    public static MemorySegment OgaNamedTensorsSet(MemorySegment named_tensors, MemorySegment name, MemorySegment tensor) {\n+        var mh$ = OgaNamedTensorsSet.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaNamedTensorsSet\", named_tensors, name, tensor);\n+            }\n+            return (MemorySegment)mh$.invokeExact(named_tensors, name, tensor);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaNamedTensorsDelete {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaNamedTensorsDelete\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsDelete(OgaNamedTensors *named_tensors, const char *name)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaNamedTensorsDelete$descriptor() {\n+        return OgaNamedTensorsDelete.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsDelete(OgaNamedTensors *named_tensors, const char *name)\n+     * }\n+     *\/\n+    public static MethodHandle OgaNamedTensorsDelete$handle() {\n+        return OgaNamedTensorsDelete.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsDelete(OgaNamedTensors *named_tensors, const char *name)\n+     * }\n+     *\/\n+    public static MemorySegment OgaNamedTensorsDelete$address() {\n+        return OgaNamedTensorsDelete.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsDelete(OgaNamedTensors *named_tensors, const char *name)\n+     * }\n+     *\/\n+    public static MemorySegment OgaNamedTensorsDelete(MemorySegment named_tensors, MemorySegment name) {\n+        var mh$ = OgaNamedTensorsDelete.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaNamedTensorsDelete\", named_tensors, name);\n+            }\n+            return (MemorySegment)mh$.invokeExact(named_tensors, name);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaNamedTensorsCount {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaNamedTensorsCount\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsCount(const OgaNamedTensors *named_tensors, size_t *out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaNamedTensorsCount$descriptor() {\n+        return OgaNamedTensorsCount.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsCount(const OgaNamedTensors *named_tensors, size_t *out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaNamedTensorsCount$handle() {\n+        return OgaNamedTensorsCount.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsCount(const OgaNamedTensors *named_tensors, size_t *out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaNamedTensorsCount$address() {\n+        return OgaNamedTensorsCount.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsCount(const OgaNamedTensors *named_tensors, size_t *out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaNamedTensorsCount(MemorySegment named_tensors, MemorySegment out) {\n+        var mh$ = OgaNamedTensorsCount.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaNamedTensorsCount\", named_tensors, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(named_tensors, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaNamedTensorsGetNames {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaNamedTensorsGetNames\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsGetNames(const OgaNamedTensors *named_tensors, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaNamedTensorsGetNames$descriptor() {\n+        return OgaNamedTensorsGetNames.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsGetNames(const OgaNamedTensors *named_tensors, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaNamedTensorsGetNames$handle() {\n+        return OgaNamedTensorsGetNames.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsGetNames(const OgaNamedTensors *named_tensors, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaNamedTensorsGetNames$address() {\n+        return OgaNamedTensorsGetNames.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaNamedTensorsGetNames(const OgaNamedTensors *named_tensors, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaNamedTensorsGetNames(MemorySegment named_tensors, MemorySegment out) {\n+        var mh$ = OgaNamedTensorsGetNames.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaNamedTensorsGetNames\", named_tensors, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(named_tensors, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaSetCurrentGpuDeviceId {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_INT\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaSetCurrentGpuDeviceId\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetCurrentGpuDeviceId(int device_id)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaSetCurrentGpuDeviceId$descriptor() {\n+        return OgaSetCurrentGpuDeviceId.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetCurrentGpuDeviceId(int device_id)\n+     * }\n+     *\/\n+    public static MethodHandle OgaSetCurrentGpuDeviceId$handle() {\n+        return OgaSetCurrentGpuDeviceId.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetCurrentGpuDeviceId(int device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSetCurrentGpuDeviceId$address() {\n+        return OgaSetCurrentGpuDeviceId.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetCurrentGpuDeviceId(int device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSetCurrentGpuDeviceId(int device_id) {\n+        var mh$ = OgaSetCurrentGpuDeviceId.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaSetCurrentGpuDeviceId\", device_id);\n+            }\n+            return (MemorySegment)mh$.invokeExact(device_id);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaGetCurrentGpuDeviceId {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaGetCurrentGpuDeviceId\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGetCurrentGpuDeviceId(int *device_id)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaGetCurrentGpuDeviceId$descriptor() {\n+        return OgaGetCurrentGpuDeviceId.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGetCurrentGpuDeviceId(int *device_id)\n+     * }\n+     *\/\n+    public static MethodHandle OgaGetCurrentGpuDeviceId$handle() {\n+        return OgaGetCurrentGpuDeviceId.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGetCurrentGpuDeviceId(int *device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGetCurrentGpuDeviceId$address() {\n+        return OgaGetCurrentGpuDeviceId.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaGetCurrentGpuDeviceId(int *device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OgaGetCurrentGpuDeviceId(MemorySegment device_id) {\n+        var mh$ = OgaGetCurrentGpuDeviceId.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaGetCurrentGpuDeviceId\", device_id);\n+            }\n+            return (MemorySegment)mh$.invokeExact(device_id);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateStringArray {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateStringArray\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateStringArray(OgaStringArray **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateStringArray$descriptor() {\n+        return OgaCreateStringArray.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateStringArray(OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateStringArray$handle() {\n+        return OgaCreateStringArray.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateStringArray(OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateStringArray$address() {\n+        return OgaCreateStringArray.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateStringArray(OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateStringArray(MemorySegment out) {\n+        var mh$ = OgaCreateStringArray.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateStringArray\", out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateStringArrayFromStrings {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateStringArrayFromStrings\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateStringArrayFromStrings(const char *const *strs, size_t count, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateStringArrayFromStrings$descriptor() {\n+        return OgaCreateStringArrayFromStrings.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateStringArrayFromStrings(const char *const *strs, size_t count, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateStringArrayFromStrings$handle() {\n+        return OgaCreateStringArrayFromStrings.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateStringArrayFromStrings(const char *const *strs, size_t count, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateStringArrayFromStrings$address() {\n+        return OgaCreateStringArrayFromStrings.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateStringArrayFromStrings(const char *const *strs, size_t count, OgaStringArray **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateStringArrayFromStrings(MemorySegment strs, long count, MemorySegment out) {\n+        var mh$ = OgaCreateStringArrayFromStrings.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateStringArrayFromStrings\", strs, count, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(strs, count, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyStringArray {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyStringArray\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyStringArray(OgaStringArray *string_array)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyStringArray$descriptor() {\n+        return OgaDestroyStringArray.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyStringArray(OgaStringArray *string_array)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyStringArray$handle() {\n+        return OgaDestroyStringArray.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyStringArray(OgaStringArray *string_array)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyStringArray$address() {\n+        return OgaDestroyStringArray.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyStringArray(OgaStringArray *string_array)\n+     * }\n+     *\/\n+    public static void OgaDestroyStringArray(MemorySegment string_array) {\n+        var mh$ = OgaDestroyStringArray.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyStringArray\", string_array);\n+            }\n+            mh$.invokeExact(string_array);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaStringArrayAddString {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaStringArrayAddString\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayAddString(OgaStringArray *string_array, const char *str)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaStringArrayAddString$descriptor() {\n+        return OgaStringArrayAddString.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayAddString(OgaStringArray *string_array, const char *str)\n+     * }\n+     *\/\n+    public static MethodHandle OgaStringArrayAddString$handle() {\n+        return OgaStringArrayAddString.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayAddString(OgaStringArray *string_array, const char *str)\n+     * }\n+     *\/\n+    public static MemorySegment OgaStringArrayAddString$address() {\n+        return OgaStringArrayAddString.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayAddString(OgaStringArray *string_array, const char *str)\n+     * }\n+     *\/\n+    public static MemorySegment OgaStringArrayAddString(MemorySegment string_array, MemorySegment str) {\n+        var mh$ = OgaStringArrayAddString.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaStringArrayAddString\", string_array, str);\n+            }\n+            return (MemorySegment)mh$.invokeExact(string_array, str);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaStringArrayGetCount {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaStringArrayGetCount\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayGetCount(const OgaStringArray *string_array, size_t *out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaStringArrayGetCount$descriptor() {\n+        return OgaStringArrayGetCount.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayGetCount(const OgaStringArray *string_array, size_t *out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaStringArrayGetCount$handle() {\n+        return OgaStringArrayGetCount.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayGetCount(const OgaStringArray *string_array, size_t *out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaStringArrayGetCount$address() {\n+        return OgaStringArrayGetCount.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayGetCount(const OgaStringArray *string_array, size_t *out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaStringArrayGetCount(MemorySegment string_array, MemorySegment out) {\n+        var mh$ = OgaStringArrayGetCount.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaStringArrayGetCount\", string_array, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(string_array, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaStringArrayGetString {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_LONG,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaStringArrayGetString\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayGetString(const OgaStringArray *string_array, size_t index, const char **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaStringArrayGetString$descriptor() {\n+        return OgaStringArrayGetString.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayGetString(const OgaStringArray *string_array, size_t index, const char **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaStringArrayGetString$handle() {\n+        return OgaStringArrayGetString.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayGetString(const OgaStringArray *string_array, size_t index, const char **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaStringArrayGetString$address() {\n+        return OgaStringArrayGetString.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaStringArrayGetString(const OgaStringArray *string_array, size_t index, const char **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaStringArrayGetString(MemorySegment string_array, long index, MemorySegment out) {\n+        var mh$ = OgaStringArrayGetString.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaStringArrayGetString\", string_array, index, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(string_array, index, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaCreateAdapters {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaCreateAdapters\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateAdapters(const OgaModel *model, OgaAdapters **out)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaCreateAdapters$descriptor() {\n+        return OgaCreateAdapters.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateAdapters(const OgaModel *model, OgaAdapters **out)\n+     * }\n+     *\/\n+    public static MethodHandle OgaCreateAdapters$handle() {\n+        return OgaCreateAdapters.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateAdapters(const OgaModel *model, OgaAdapters **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateAdapters$address() {\n+        return OgaCreateAdapters.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaCreateAdapters(const OgaModel *model, OgaAdapters **out)\n+     * }\n+     *\/\n+    public static MemorySegment OgaCreateAdapters(MemorySegment model, MemorySegment out) {\n+        var mh$ = OgaCreateAdapters.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaCreateAdapters\", model, out);\n+            }\n+            return (MemorySegment)mh$.invokeExact(model, out);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaDestroyAdapters {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaDestroyAdapters\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyAdapters(OgaAdapters *adapters)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaDestroyAdapters$descriptor() {\n+        return OgaDestroyAdapters.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyAdapters(OgaAdapters *adapters)\n+     * }\n+     *\/\n+    public static MethodHandle OgaDestroyAdapters$handle() {\n+        return OgaDestroyAdapters.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * void OgaDestroyAdapters(OgaAdapters *adapters)\n+     * }\n+     *\/\n+    public static MemorySegment OgaDestroyAdapters$address() {\n+        return OgaDestroyAdapters.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void OgaDestroyAdapters(OgaAdapters *adapters)\n+     * }\n+     *\/\n+    public static void OgaDestroyAdapters(MemorySegment adapters) {\n+        var mh$ = OgaDestroyAdapters.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaDestroyAdapters\", adapters);\n+            }\n+            mh$.invokeExact(adapters);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaLoadAdapter {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaLoadAdapter\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAdapter(OgaAdapters *adapters, const char *adapter_file_path, const char *adapter_name)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaLoadAdapter$descriptor() {\n+        return OgaLoadAdapter.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAdapter(OgaAdapters *adapters, const char *adapter_file_path, const char *adapter_name)\n+     * }\n+     *\/\n+    public static MethodHandle OgaLoadAdapter$handle() {\n+        return OgaLoadAdapter.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAdapter(OgaAdapters *adapters, const char *adapter_file_path, const char *adapter_name)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadAdapter$address() {\n+        return OgaLoadAdapter.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaLoadAdapter(OgaAdapters *adapters, const char *adapter_file_path, const char *adapter_name)\n+     * }\n+     *\/\n+    public static MemorySegment OgaLoadAdapter(MemorySegment adapters, MemorySegment adapter_file_path, MemorySegment adapter_name) {\n+        var mh$ = OgaLoadAdapter.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaLoadAdapter\", adapters, adapter_file_path, adapter_name);\n+            }\n+            return (MemorySegment)mh$.invokeExact(adapters, adapter_file_path, adapter_name);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaUnloadAdapter {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaUnloadAdapter\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaUnloadAdapter(OgaAdapters *adapters, const char *adapter_name)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaUnloadAdapter$descriptor() {\n+        return OgaUnloadAdapter.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaUnloadAdapter(OgaAdapters *adapters, const char *adapter_name)\n+     * }\n+     *\/\n+    public static MethodHandle OgaUnloadAdapter$handle() {\n+        return OgaUnloadAdapter.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaUnloadAdapter(OgaAdapters *adapters, const char *adapter_name)\n+     * }\n+     *\/\n+    public static MemorySegment OgaUnloadAdapter$address() {\n+        return OgaUnloadAdapter.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaUnloadAdapter(OgaAdapters *adapters, const char *adapter_name)\n+     * }\n+     *\/\n+    public static MemorySegment OgaUnloadAdapter(MemorySegment adapters, MemorySegment adapter_name) {\n+        var mh$ = OgaUnloadAdapter.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaUnloadAdapter\", adapters, adapter_name);\n+            }\n+            return (MemorySegment)mh$.invokeExact(adapters, adapter_name);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OgaSetActiveAdapter {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER,\n+            OrtGenApi.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = OrtGenApi.findOrThrow(\"OgaSetActiveAdapter\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetActiveAdapter(OgaGenerator *generator, OgaAdapters *adapters, const char *adapter_name)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OgaSetActiveAdapter$descriptor() {\n+        return OgaSetActiveAdapter.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetActiveAdapter(OgaGenerator *generator, OgaAdapters *adapters, const char *adapter_name)\n+     * }\n+     *\/\n+    public static MethodHandle OgaSetActiveAdapter$handle() {\n+        return OgaSetActiveAdapter.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetActiveAdapter(OgaGenerator *generator, OgaAdapters *adapters, const char *adapter_name)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSetActiveAdapter$address() {\n+        return OgaSetActiveAdapter.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OgaResult *OgaSetActiveAdapter(OgaGenerator *generator, OgaAdapters *adapters, const char *adapter_name)\n+     * }\n+     *\/\n+    public static MemorySegment OgaSetActiveAdapter(MemorySegment generator, MemorySegment adapters, MemorySegment adapter_name) {\n+        var mh$ = OgaSetActiveAdapter.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OgaSetActiveAdapter\", generator, adapters, adapter_name);\n+            }\n+            return (MemorySegment)mh$.invokeExact(generator, adapters, adapter_name);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_SUF_EXTSN \"$DARWIN_EXTSN\"\n+     * }\n+     *\/\n+    public static MemorySegment __DARWIN_SUF_EXTSN() {\n+        class Holder {\n+            static final MemorySegment __DARWIN_SUF_EXTSN\n+                = OrtGenApi.LIBRARY_ARENA.allocateFrom(\"$DARWIN_EXTSN\");\n+        }\n+        return Holder.__DARWIN_SUF_EXTSN;\n+    }\n+    private static final long __DARWIN_C_ANSI = 4096L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_C_ANSI 4096\n+     * }\n+     *\/\n+    public static long __DARWIN_C_ANSI() {\n+        return __DARWIN_C_ANSI;\n+    }\n+    private static final long __DARWIN_C_FULL = 900000L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_C_FULL 900000\n+     * }\n+     *\/\n+    public static long __DARWIN_C_FULL() {\n+        return __DARWIN_C_FULL;\n+    }\n+    private static final long __DARWIN_C_LEVEL = 900000L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_C_LEVEL 900000\n+     * }\n+     *\/\n+    public static long __DARWIN_C_LEVEL() {\n+        return __DARWIN_C_LEVEL;\n+    }\n+    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __DARWIN_NULL (void*) 0\n+     * }\n+     *\/\n+    public static MemorySegment __DARWIN_NULL() {\n+        return __DARWIN_NULL;\n+    }\n+    private static final long INT64_MAX = 9223372036854775807L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT64_MAX 9223372036854775807\n+     * }\n+     *\/\n+    public static long INT64_MAX() {\n+        return INT64_MAX;\n+    }\n+    private static final int INT8_MIN = (int)-128L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT8_MIN -128\n+     * }\n+     *\/\n+    public static int INT8_MIN() {\n+        return INT8_MIN;\n+    }\n+    private static final int INT16_MIN = (int)-32768L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT16_MIN -32768\n+     * }\n+     *\/\n+    public static int INT16_MIN() {\n+        return INT16_MIN;\n+    }\n+    private static final int INT32_MIN = (int)-2147483648L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT32_MIN -2147483648\n+     * }\n+     *\/\n+    public static int INT32_MIN() {\n+        return INT32_MIN;\n+    }\n+    private static final long INT64_MIN = -9223372036854775808L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT64_MIN -9223372036854775808\n+     * }\n+     *\/\n+    public static long INT64_MIN() {\n+        return INT64_MIN;\n+    }\n+    private static final int UINT32_MAX = (int)4294967295L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT32_MAX 4294967295\n+     * }\n+     *\/\n+    public static int UINT32_MAX() {\n+        return UINT32_MAX;\n+    }\n+    private static final long UINT64_MAX = -1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT64_MAX -1\n+     * }\n+     *\/\n+    public static long UINT64_MAX() {\n+        return UINT64_MAX;\n+    }\n+    private static final int INT_LEAST8_MIN = (int)-128L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_LEAST8_MIN -128\n+     * }\n+     *\/\n+    public static int INT_LEAST8_MIN() {\n+        return INT_LEAST8_MIN;\n+    }\n+    private static final int INT_LEAST16_MIN = (int)-32768L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_LEAST16_MIN -32768\n+     * }\n+     *\/\n+    public static int INT_LEAST16_MIN() {\n+        return INT_LEAST16_MIN;\n+    }\n+    private static final int INT_LEAST32_MIN = (int)-2147483648L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_LEAST32_MIN -2147483648\n+     * }\n+     *\/\n+    public static int INT_LEAST32_MIN() {\n+        return INT_LEAST32_MIN;\n+    }\n+    private static final long INT_LEAST64_MIN = -9223372036854775808L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_LEAST64_MIN -9223372036854775808\n+     * }\n+     *\/\n+    public static long INT_LEAST64_MIN() {\n+        return INT_LEAST64_MIN;\n+    }\n+    private static final int INT_LEAST8_MAX = (int)127L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_LEAST8_MAX 127\n+     * }\n+     *\/\n+    public static int INT_LEAST8_MAX() {\n+        return INT_LEAST8_MAX;\n+    }\n+    private static final int INT_LEAST16_MAX = (int)32767L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_LEAST16_MAX 32767\n+     * }\n+     *\/\n+    public static int INT_LEAST16_MAX() {\n+        return INT_LEAST16_MAX;\n+    }\n+    private static final int INT_LEAST32_MAX = (int)2147483647L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_LEAST32_MAX 2147483647\n+     * }\n+     *\/\n+    public static int INT_LEAST32_MAX() {\n+        return INT_LEAST32_MAX;\n+    }\n+    private static final long INT_LEAST64_MAX = 9223372036854775807L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_LEAST64_MAX 9223372036854775807\n+     * }\n+     *\/\n+    public static long INT_LEAST64_MAX() {\n+        return INT_LEAST64_MAX;\n+    }\n+    private static final int UINT_LEAST8_MAX = (int)255L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT_LEAST8_MAX 255\n+     * }\n+     *\/\n+    public static int UINT_LEAST8_MAX() {\n+        return UINT_LEAST8_MAX;\n+    }\n+    private static final int UINT_LEAST16_MAX = (int)65535L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT_LEAST16_MAX 65535\n+     * }\n+     *\/\n+    public static int UINT_LEAST16_MAX() {\n+        return UINT_LEAST16_MAX;\n+    }\n+    private static final int UINT_LEAST32_MAX = (int)4294967295L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT_LEAST32_MAX 4294967295\n+     * }\n+     *\/\n+    public static int UINT_LEAST32_MAX() {\n+        return UINT_LEAST32_MAX;\n+    }\n+    private static final long UINT_LEAST64_MAX = -1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT_LEAST64_MAX -1\n+     * }\n+     *\/\n+    public static long UINT_LEAST64_MAX() {\n+        return UINT_LEAST64_MAX;\n+    }\n+    private static final int INT_FAST8_MIN = (int)-128L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_FAST8_MIN -128\n+     * }\n+     *\/\n+    public static int INT_FAST8_MIN() {\n+        return INT_FAST8_MIN;\n+    }\n+    private static final int INT_FAST16_MIN = (int)-32768L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_FAST16_MIN -32768\n+     * }\n+     *\/\n+    public static int INT_FAST16_MIN() {\n+        return INT_FAST16_MIN;\n+    }\n+    private static final int INT_FAST32_MIN = (int)-2147483648L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_FAST32_MIN -2147483648\n+     * }\n+     *\/\n+    public static int INT_FAST32_MIN() {\n+        return INT_FAST32_MIN;\n+    }\n+    private static final long INT_FAST64_MIN = -9223372036854775808L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_FAST64_MIN -9223372036854775808\n+     * }\n+     *\/\n+    public static long INT_FAST64_MIN() {\n+        return INT_FAST64_MIN;\n+    }\n+    private static final int INT_FAST8_MAX = (int)127L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_FAST8_MAX 127\n+     * }\n+     *\/\n+    public static int INT_FAST8_MAX() {\n+        return INT_FAST8_MAX;\n+    }\n+    private static final int INT_FAST16_MAX = (int)32767L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_FAST16_MAX 32767\n+     * }\n+     *\/\n+    public static int INT_FAST16_MAX() {\n+        return INT_FAST16_MAX;\n+    }\n+    private static final int INT_FAST32_MAX = (int)2147483647L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_FAST32_MAX 2147483647\n+     * }\n+     *\/\n+    public static int INT_FAST32_MAX() {\n+        return INT_FAST32_MAX;\n+    }\n+    private static final long INT_FAST64_MAX = 9223372036854775807L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INT_FAST64_MAX 9223372036854775807\n+     * }\n+     *\/\n+    public static long INT_FAST64_MAX() {\n+        return INT_FAST64_MAX;\n+    }\n+    private static final int UINT_FAST8_MAX = (int)255L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT_FAST8_MAX 255\n+     * }\n+     *\/\n+    public static int UINT_FAST8_MAX() {\n+        return UINT_FAST8_MAX;\n+    }\n+    private static final int UINT_FAST16_MAX = (int)65535L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT_FAST16_MAX 65535\n+     * }\n+     *\/\n+    public static int UINT_FAST16_MAX() {\n+        return UINT_FAST16_MAX;\n+    }\n+    private static final int UINT_FAST32_MAX = (int)4294967295L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT_FAST32_MAX 4294967295\n+     * }\n+     *\/\n+    public static int UINT_FAST32_MAX() {\n+        return UINT_FAST32_MAX;\n+    }\n+    private static final long UINT_FAST64_MAX = -1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINT_FAST64_MAX -1\n+     * }\n+     *\/\n+    public static long UINT_FAST64_MAX() {\n+        return UINT_FAST64_MAX;\n+    }\n+    private static final long INTPTR_MAX = 9223372036854775807L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INTPTR_MAX 9223372036854775807\n+     * }\n+     *\/\n+    public static long INTPTR_MAX() {\n+        return INTPTR_MAX;\n+    }\n+    private static final long INTPTR_MIN = -9223372036854775808L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INTPTR_MIN -9223372036854775808\n+     * }\n+     *\/\n+    public static long INTPTR_MIN() {\n+        return INTPTR_MIN;\n+    }\n+    private static final long UINTPTR_MAX = -1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINTPTR_MAX -1\n+     * }\n+     *\/\n+    public static long UINTPTR_MAX() {\n+        return UINTPTR_MAX;\n+    }\n+    private static final long INTMAX_MAX = 9223372036854775807L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INTMAX_MAX 9223372036854775807\n+     * }\n+     *\/\n+    public static long INTMAX_MAX() {\n+        return INTMAX_MAX;\n+    }\n+    private static final long UINTMAX_MAX = -1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define UINTMAX_MAX -1\n+     * }\n+     *\/\n+    public static long UINTMAX_MAX() {\n+        return UINTMAX_MAX;\n+    }\n+    private static final long INTMAX_MIN = -9223372036854775808L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define INTMAX_MIN -9223372036854775808\n+     * }\n+     *\/\n+    public static long INTMAX_MIN() {\n+        return INTMAX_MIN;\n+    }\n+    private static final long PTRDIFF_MIN = -9223372036854775808L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define PTRDIFF_MIN -9223372036854775808\n+     * }\n+     *\/\n+    public static long PTRDIFF_MIN() {\n+        return PTRDIFF_MIN;\n+    }\n+    private static final long PTRDIFF_MAX = 9223372036854775807L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define PTRDIFF_MAX 9223372036854775807\n+     * }\n+     *\/\n+    public static long PTRDIFF_MAX() {\n+        return PTRDIFF_MAX;\n+    }\n+    private static final long SIZE_MAX = -1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define SIZE_MAX -1\n+     * }\n+     *\/\n+    public static long SIZE_MAX() {\n+        return SIZE_MAX;\n+    }\n+    private static final long RSIZE_MAX = 9223372036854775807L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define RSIZE_MAX 9223372036854775807\n+     * }\n+     *\/\n+    public static long RSIZE_MAX() {\n+        return RSIZE_MAX;\n+    }\n+    private static final int WCHAR_MAX = (int)2147483647L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define WCHAR_MAX 2147483647\n+     * }\n+     *\/\n+    public static int WCHAR_MAX() {\n+        return WCHAR_MAX;\n+    }\n+    private static final int WCHAR_MIN = (int)-2147483648L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define WCHAR_MIN -2147483648\n+     * }\n+     *\/\n+    public static int WCHAR_MIN() {\n+        return WCHAR_MIN;\n+    }\n+    private static final int WINT_MIN = (int)-2147483648L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define WINT_MIN -2147483648\n+     * }\n+     *\/\n+    public static int WINT_MIN() {\n+        return WINT_MIN;\n+    }\n+    private static final int WINT_MAX = (int)2147483647L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define WINT_MAX 2147483647\n+     * }\n+     *\/\n+    public static int WINT_MAX() {\n+        return WINT_MAX;\n+    }\n+    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define SIG_ATOMIC_MIN -2147483648\n+     * }\n+     *\/\n+    public static int SIG_ATOMIC_MIN() {\n+        return SIG_ATOMIC_MIN;\n+    }\n+    private static final int SIG_ATOMIC_MAX = (int)2147483647L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define SIG_ATOMIC_MAX 2147483647\n+     * }\n+     *\/\n+    public static int SIG_ATOMIC_MAX() {\n+        return SIG_ATOMIC_MAX;\n+    }\n+    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);\n+    \/**\n+     * {@snippet lang=c :\n+     * #define NULL (void*) 0\n+     * }\n+     *\/\n+    public static MemorySegment NULL() {\n+        return NULL;\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtGenApi.java","additions":7610,"deletions":0,"binary":false,"changes":7610,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.onnx.genai;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import oracle.code.onnx.OnnxProtoBuilder;\n+import oracle.code.onnx.OnnxRuntime;\n+import oracle.code.onnx.compiler.OnnxTransformer;\n+\n+import static oracle.code.onnx.foreign.OrtGenApi.*;\n+\n+public class OnnxGenRuntimeSession implements AutoCloseable {\n+\n+    public static OnnxGenRuntimeSession buildFromCodeReflection(Object codeReflectionModelInstance, String methodName, String promptTemplate, Path targetOnnxModelDir, String targetOnnxModelFileName, String targetExternalDataFileName) throws IOException {\n+        Method method = Stream.of(codeReflectionModelInstance.getClass().getDeclaredMethods()).filter(m -> m.getName().equals(methodName)).findFirst().orElseThrow();\n+        CoreOp.FuncOp javaModel = Op.ofMethod(method).orElseThrow();\n+        OnnxTransformer.ModuleAndInitializers onnxModel = OnnxTransformer.transform(MethodHandles.lookup(), javaModel);\n+        List<Object> initializers = OnnxRuntime.getInitValues(MethodHandles.lookup(), onnxModel.initializers(), List.of(codeReflectionModelInstance));\n+        try (OutputStream dataOutput = Files.newOutputStream(targetOnnxModelDir.resolve(targetExternalDataFileName))) {\n+            AtomicLong offset = new AtomicLong();\n+            byte[] protobufModel = OnnxProtoBuilder.buildModel(\"llm\", onnxModel.module(), initializers, onnxModel.namesMap(), t -> {\n+                byte[] data = t.data().toArray(ValueLayout.JAVA_BYTE);\n+                try {\n+                    dataOutput.write(data);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                return new OnnxProtoBuilder.ExternalTensorDataInfo(targetExternalDataFileName, offset.getAndAdd(data.length), data.length);\n+            });\n+            Files.write(targetOnnxModelDir.resolve(targetOnnxModelFileName), protobufModel);\n+        }\n+        return new OnnxGenRuntimeSession(targetOnnxModelDir.toString(), promptTemplate);\n+    }\n+\n+    private final Arena arena;\n+    private final MemorySegment ret, model, tokenizer, tokenizerStream, generatorParams, generator, count;\n+    private final String promptTemplate;\n+\n+    public OnnxGenRuntimeSession(String onnxModelDir, String promptTemplate) {\n+        this.arena = Arena.ofConfined();\n+        ret = arena.allocate(C_POINTER);\n+        model = call(OgaCreateModel(arena.allocateFrom(onnxModelDir), ret));\n+        tokenizer = call(OgaCreateTokenizer(model, ret));\n+        tokenizerStream = call(OgaCreateTokenizerStream(tokenizer, ret));\n+        generatorParams = call(OgaCreateGeneratorParams(model, ret));\n+        generator = call(OgaCreateGenerator(model, generatorParams, ret));\n+        count = arena.allocate(C_LONG);\n+        this.promptTemplate = promptTemplate;\n+    }\n+\n+    private MemorySegment call(MemorySegment status) {\n+        try {\n+            if (!status.equals(MemorySegment.NULL)) {\n+                status = status.reinterpret(C_INT.byteSize());\n+                if (status.get(C_INT, 0) != 0) {\n+                    String errString = OgaResultGetError(status)\n+                            .reinterpret(Long.MAX_VALUE)\n+                            .getString(0L);\n+                    throw new RuntimeException(errString);\n+                }\n+            }\n+            return ret.get(C_POINTER, 0);\n+        } finally {\n+            OgaDestroyResult(status);\n+        }\n+    }\n+\n+    public void prompt(String userPrompt, Consumer<String> outputConsumer) {\n+        var inputTokens = call(OgaCreateSequences(ret));\n+        try {\n+            call(OgaTokenizerEncode(tokenizer, arena.allocateFrom(promptTemplate.formatted(userPrompt)), inputTokens));\n+            call(OgaGenerator_AppendTokenSequences(generator, inputTokens));\n+            while (!OgaGenerator_IsDone(generator)) {\n+                call(OgaGenerator_GenerateNextToken(generator));\n+                int nextToken = call(OgaGenerator_GetNextTokens(generator, ret, count)).get(C_INT, 0);\n+                String response = call(OgaTokenizerStreamDecode(tokenizerStream, nextToken, ret)).getString(0);\n+                outputConsumer.accept(response);\n+            }\n+            outputConsumer.accept(\"\\n\");\n+        } finally {\n+            OgaDestroySequences(inputTokens);\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+        arena.close();\n+        OgaDestroyGenerator(generator);\n+        OgaDestroyGeneratorParams(generatorParams);\n+        OgaDestroyTokenizerStream(tokenizerStream);\n+        OgaDestroyTokenizer(tokenizer);\n+        OgaDestroyModel(model);\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/genai\/OnnxGenRuntimeSession.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -36,0 +36,539 @@\n+    \/\/ @@@ this should be generated from contrib operators\n+    @OpFactory.OpDeclaration(GroupQueryAttention.NAME)\n+    public static final class GroupQueryAttention extends OnnxOp {\n+        public static final String NAME = \"com.microsoft.GroupQueryAttention\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            do_rotary(Long.class, true, 0),\n+            kv_num_heads(Long.class, false, null),\n+            local_window_size(Long.class, true, -1),\n+            num_heads(Long.class, false, null),\n+            rotary_interleaved(Long.class, true, 0),\n+            scale(Float.class, true, null), \/\/ @@@ Default value is 1\/sqrt(head_size)\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float32())))),\n+            M(new OnnxType.TypeVariable(\"M\", List.of(OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            query(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            key(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            value(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            past_key(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            past_value(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            seqlens_k(TypeConstraint.M.typeVariable(), Quantifier.REQUIRED),\n+            total_sequence_length(TypeConstraint.M.typeVariable(), Quantifier.REQUIRED),\n+            cos_cache(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            sin_cache(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            present_key(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            present_value(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public GroupQueryAttention(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        GroupQueryAttention(GroupQueryAttention that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GroupQueryAttention transform(CopyContext cc, OpTransformer ot) {\n+            return new GroupQueryAttention(this, cc);\n+        }\n+\n+        GroupQueryAttention(TypeElement resultType, Value query, java.util.Optional<Value> key, java.util.Optional<Value> value, java.util.Optional<Value> past_key, java.util.Optional<Value> past_value, Value seqlens_k, Value total_sequence_length, java.util.Optional<Value> cos_cache, java.util.Optional<Value> sin_cache, java.util.Optional<Long> do_rotary, long kv_num_heads, java.util.Optional<Long> local_window_size, long num_heads, java.util.Optional<Long> rotary_interleaved, java.util.Optional<Float> scale) {\n+            super(SCHEMA, resultType, Collections.emptySet(), List.of(query, key, value, past_key, past_value, seqlens_k, total_sequence_length, cos_cache, sin_cache), List.of(do_rotary, kv_num_heads, local_window_size, num_heads, rotary_interleaved, scale));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(query(), key(), value(), past_key(), past_value(), seqlens_k(), total_sequence_length(), cos_cache(), sin_cache()));\n+        }\n+\n+        public Value query() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> key() {\n+            int i = optionalInputArguments.indexOf(InputParameter.key);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> value() {\n+            int i = optionalInputArguments.indexOf(InputParameter.value);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> past_key() {\n+            int i = optionalInputArguments.indexOf(InputParameter.past_key);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> past_value() {\n+            int i = optionalInputArguments.indexOf(InputParameter.past_value);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        private int skipOptional() {\n+            for (int i = optionalInputArguments.size() - 1; i >= 0; i--) {\n+                var opt = optionalInputArguments.get(i);\n+                if (opt != InputParameter.cos_cache && opt != InputParameter.sin_cache) return i;\n+            }\n+            return -1;\n+        }\n+\n+        public Value seqlens_k() {\n+            return operands().get(skipOptional() + 2);\n+        }\n+\n+        public Value total_sequence_length() {\n+            return operands().get(skipOptional() + 3);\n+        }\n+\n+        public java.util.Optional<Value> cos_cache() {\n+            int i = optionalInputArguments.indexOf(InputParameter.cos_cache);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> sin_cache() {\n+            int i = optionalInputArguments.indexOf(InputParameter.sin_cache);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+    }\n+\n+    public static GroupQueryAttention GroupQueryAttention(TypeElement resultType, Value query, java.util.Optional<Value> key, java.util.Optional<Value> value, java.util.Optional<Value> past_key, java.util.Optional<Value> past_value, Value seqlens_k, Value total_sequence_length, java.util.Optional<Value> cos_cache, java.util.Optional<Value> sin_cache, java.util.Optional<Long> do_rotary, long kv_num_heads, java.util.Optional<Long> local_window_size, long num_heads, java.util.Optional<Long> rotary_interleaved, java.util.Optional<Float> scale) {\n+        return new GroupQueryAttention(resultType, query, key, value, past_key, past_value, seqlens_k, total_sequence_length, cos_cache, sin_cache, do_rotary, kv_num_heads, local_window_size, num_heads, rotary_interleaved, scale);\n+    }\n+\n+    \/\/ @@@ this should be generated from contrib operators\n+    @OpFactory.OpDeclaration(MatMulNBits.NAME)\n+    public static final class MatMulNBits extends OnnxOp {\n+        public static final String NAME = \"com.microsoft.MatMulNBits\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            K(Long.class, false, null),\n+            N(Long.class, false, null),\n+            accuracy_level(Long.class, true, 0),\n+            bits(Long.class, false, null),\n+            block_size(Long.class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int32())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32())))),\n+            T4(new OnnxType.TypeVariable(\"T4\", List.of(OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            scales(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            zero_points(TypeConstraint.T3.typeVariable(), Quantifier.OPTIONAL),\n+            g_idx(TypeConstraint.T4.typeVariable(), Quantifier.OPTIONAL),\n+            bias(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public MatMulNBits(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        MatMulNBits(MatMulNBits that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MatMulNBits transform(CopyContext cc, OpTransformer ot) {\n+            return new MatMulNBits(this, cc);\n+        }\n+\n+        MatMulNBits(TypeElement resultType, Value a, Value b, Value scales, java.util.Optional<Value> zero_points, java.util.Optional<Value> g_idx, java.util.Optional<Value> bias, long K, long N, java.util.Optional<Long> accuracy_level, long bits, long block_size) {\n+            super(SCHEMA, resultType, Collections.emptySet(), List.of(a, b, scales, zero_points, g_idx, bias), List.of(K, N, accuracy_level, bits, block_size));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+                    return onnxInputs(SCHEMA, List.of(a(), b(), scales(), zero_points(), g_idx(), bias()));\n+        }\n+\n+        public Value a() {\n+            return operands().get(0);\n+        }\n+\n+        public Value b() {\n+            return operands().get(1);\n+        }\n+\n+        public Value scales() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Value> zero_points() {\n+            int i = optionalInputArguments.indexOf(InputParameter.zero_points);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> g_idx() {\n+            int i = optionalInputArguments.indexOf(InputParameter.g_idx);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> bias() {\n+            int i = optionalInputArguments.indexOf(InputParameter.bias);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+    }\n+\n+    public static MatMulNBits MatMulNBits(TypeElement resultType, Value a, Value b, Value scales, java.util.Optional<Value> zero_points, java.util.Optional<Value> g_idx, java.util.Optional<Value> bias, long K, long N, java.util.Optional<Long> accuracy_level, long bits, long block_size) {\n+        return new MatMulNBits(resultType, a, b, scales, zero_points, g_idx, bias, K, N, accuracy_level, bits, block_size);\n+    }\n+\n+    \/\/ @@@ this should be generated from contrib operators\n+    @OpFactory.OpDeclaration(SkipSimplifiedLayerNormalization.NAME)\n+    public static final class SkipSimplifiedLayerNormalization extends OnnxOp {\n+        public static final String NAME = \"com.microsoft.SkipSimplifiedLayerNormalization\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            epsilon(Float.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            skip(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            gamma(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            bias(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            mean(OnnxType.TENSOR_FLOAT32, Quantifier.OPTIONAL),\n+            inv_std_var(OnnxType.TENSOR_FLOAT32, Quantifier.OPTIONAL),\n+            input_skip_bias_sum(OnnxType.TENSOR_FLOAT32, Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SkipSimplifiedLayerNormalization(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SkipSimplifiedLayerNormalization(SkipSimplifiedLayerNormalization that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SkipSimplifiedLayerNormalization transform(CopyContext cc, OpTransformer ot) {\n+            return new SkipSimplifiedLayerNormalization(this, cc);\n+        }\n+\n+        SkipSimplifiedLayerNormalization(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value input, Value skip, Value gamma, java.util.Optional<Value> bias, java.util.Optional<Float> epsilon) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(input, skip, gamma, bias), List.of(epsilon));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), skip(), gamma(), bias()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public Value skip() {\n+            return operands().get(1);\n+        }\n+\n+        public Value gamma() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Value> bias() {\n+            int i = optionalInputArguments.indexOf(InputParameter.bias);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+    }\n+\n+    public static SkipSimplifiedLayerNormalization SkipSimplifiedLayerNormalization(TypeElement resultType, Set<SkipSimplifiedLayerNormalization.OutputParameter> optionalOutputs, Value input, Value skip, Value gamma, java.util.Optional<Value> bias, java.util.Optional<Float> epsilon) {\n+        return new SkipSimplifiedLayerNormalization(resultType, optionalOutputs, input, skip, gamma, bias, epsilon);\n+    }\n+\n+\n+\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/ExplicitOnnxOps.java","additions":539,"deletions":0,"binary":false,"changes":539,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-            var absOp = ort.createSession(arena, build(\n+            var absOp = ort.createSession(arena, buildModel(\n@@ -49,1 +49,1 @@\n-            var addOp = ort.createSession(arena, build(\n+            var addOp = ort.createSession(arena, buildModel(\n@@ -89,1 +89,1 @@\n-            var ifOp = ort.createSession(arena, build(\n+            var ifOp = ort.createSession(arena, buildModel(\n@@ -118,1 +118,1 @@\n-            var forOp = ort.createSession(arena, build(\n+            var forOp = ort.createSession(arena, buildModel(\n@@ -142,1 +142,1 @@\n-            var customFunction = ort.createSession(arena, build(\n+            var customFunction = ort.createSession(arena, buildModel(\n@@ -145,1 +145,1 @@\n-                    List.of(node(customDomain, \"CustomFunction\", List.of(\"x\"), List.of(\"y\"), Map.of())),\n+                    List.of(node(customDomain + \".CustomFunction\", List.of(\"x\"), List.of(\"y\"), Map.of())),\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -316,0 +316,13 @@\n+    public record ArgRecord(Tensor<Float> a, Tensor<Float> b) {}\n+\n+    @CodeReflection\n+    public Tensor<Float> recordArgAdd(ArgRecord arg) {\n+        return Add(arg.a(), arg.b());\n+    }\n+\n+    @Test\n+    public void testRecordArgAdd() throws Exception {\n+        var arg = new ArgRecord(Tensor.ofFlat(3f), Tensor.ofFlat(4f));\n+        assertEquals(recordArgAdd(arg), execute(() -> recordArgAdd(arg)));\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-import java.nio.ByteOrder;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Field;\n@@ -39,2 +40,1 @@\n-import java.util.SequencedSet;\n-import java.util.stream.Collectors;\n+import java.util.function.Function;\n@@ -42,0 +42,1 @@\n+import jdk.incubator.code.CodeItem;\n@@ -54,0 +55,1 @@\n+import oracle.code.onnx.ir.ExplicitOnnxOps;\n@@ -135,1 +137,1 @@\n-    static final OpFactory ONNX_FACTORY = OpFactory.OP_FACTORY.get(OnnxOps.class);\n+    static final OpFactory ONNX_OP_FACTORY = OpFactory.OP_FACTORY.get(ExplicitOnnxOps.class).andThen(OpFactory.OP_FACTORY.get(OnnxOps.class));\n@@ -137,0 +139,18 @@\n+    static final Map<String, OnnxOp.OnnxSchema> ONNX_SCHEMA_REGISTRY = collectSchemas(ExplicitOnnxOps.class, OnnxOps.class);\n+\n+    private static Map<String, OnnxOp.OnnxSchema> collectSchemas(Class<?>... cls) {\n+        Map<String, OnnxOp.OnnxSchema> reg = new HashMap<>();\n+        for (Class<?> c : cls) {\n+            for (Class<?> nm : c.getNestMembers()) {\n+                for (Field f : nm.getFields()) {\n+                    if (f.accessFlags().contains(AccessFlag.STATIC) && OnnxOp.OnnxSchema.class.isAssignableFrom(f.getType())) try {\n+                        OnnxOp.OnnxSchema sch = (OnnxOp.OnnxSchema)f.get(null);\n+                        reg.put(sch.name(), sch);\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+        }\n+        return reg;\n+    }\n@@ -139,1 +159,2 @@\n-        public String toText() {\n+\n+        private Function<CodeItem, String> namer() {\n@@ -142,1 +163,2 @@\n-            return OpWriter.toText(op, OpWriter.CodeItemNamerOption.of(ci -> ci instanceof Value v ? names.get(namer.computeIfAbsent(v, _ -> namer.size())) : defNamer.apply(ci)));\n+            return ci -> ci instanceof Value v ? names.get(namer.computeIfAbsent(v, _ -> namer.size())) : defNamer.apply(ci);\n+        }\n@@ -144,0 +166,2 @@\n+        public String toText() {\n+            return OpWriter.toText(op, OpWriter.CodeItemNamerOption.of(namer()));\n@@ -147,1 +171,1 @@\n-    static OpWithNames toFuncOp(OnnxModel.GraphProto g) {\n+    static OpWithNames<CoreOp.FuncOp> toFuncOp(OnnxModel.GraphProto g) {\n@@ -162,0 +186,85 @@\n+                String opType = n.opType();\n+\n+                 \/\/ @@@ an old alias ? could not find the spec\n+                if (opType.equals(\"SimplifiedLayerNormalization\")) {\n+                    opType = \"LayerNormalization\";\n+                }\n+\n+                if (n.domain() != null && !n.domain().isEmpty() && !n.domain().equals(\"ai.onnx\")) {\n+                    opType = n.domain() + \".\" + opType;\n+                }\n+\n+                OnnxOp.OnnxSchema schema = ONNX_SCHEMA_REGISTRY.computeIfAbsent(opType, ot -> {throw new IllegalArgumentException(\"Unknown op type: \" + ot);});\n+                Map<String, Object> attributes = new LinkedHashMap<>();\n+                if (n.attribute() != null) {\n+                    for (OnnxModel.AttributeProto a : n.attribute()) {\n+                        attributes.put(a.name(), toAttributeValue(a));\n+                    }\n+                }\n+\n+                \/\/ map inputs\n+                List<Value> inputs = new ArrayList<>();\n+                if (n.input() != null) {\n+                    List<OnnxOp.OnnxParameter> optionalInputs = new ArrayList<>();\n+                    for (int i = 0; i < n.input().size(); i++) {\n+                        OnnxOp.OnnxParameter param = schema.inputs().get(i);\n+                        Value v = valueMap.get(n.input().get(i));\n+                        if (v != null) {\n+                            switch (param.quantifier()) {\n+                                case REQUIRED -> {\n+                                    inputs.add(v);\n+                                }\n+                                case OPTIONAL -> {\n+                                    optionalInputs.add(param);\n+                                    inputs.add(v);\n+                                }\n+                                case VARIADIC -> {\n+                                    inputs.add(v); \/\/ @@@ accumulate variadic inputs into\n+                                }\n+                            }\n+                        }\n+                    }\n+                    if (!optionalInputs.isEmpty()) {\n+                        attributes.put(\"optional_inputs\", optionalInputs);\n+                    }\n+                }\n+\n+                \/\/ map outputs\n+                List<OnnxOp.OnnxParameter> optionalOutputs = new ArrayList<>();\n+                List<String> outputNames = new ArrayList<>();\n+                if (n.output() != null) {\n+                    for (int i = 0; i < n.output().size(); i++) {\n+                        OnnxOp.OnnxParameter param = schema.outputs().get(i);\n+                        if (!n.output().get(i).isEmpty()) {\n+                            outputNames.add(n.output().get(i));\n+                            if (param.quantifier() == OnnxOp.OnnxParameter.Quantifier.OPTIONAL) {\n+                                optionalOutputs.add(param);\n+                            }\n+                        }\n+                    }\n+                    if (!optionalOutputs.isEmpty()) {\n+                        attributes.put(\"optional_outputs\", optionalOutputs);\n+                    }\n+                }\n+\n+                \/\/ inline Constant op tensor attribute as value\n+                if (opType.equals(\"Constant\") && attributes.remove(OnnxOps.Constant.Attribute.value.name()) instanceof Tensor t) {\n+                    switch (t.shape().length) {\n+                        case 0 -> { \/\/ scalar\n+                            switch (t.elementType()) {\n+                                case FLOAT -> attributes.put(OnnxOps.Constant.Attribute.value_float.name(), t.data().get(ValueLayout.JAVA_FLOAT, 0));\n+                                case INT64 -> attributes.put(OnnxOps.Constant.Attribute.value_int.name(), t.data().get(ValueLayout.JAVA_LONG, 0));\n+                                default -> throw new UnsupportedOperationException();\n+                            }\n+                        }\n+                        case 1 -> { \/\/ 1d tensor\n+                            switch (t.elementType()) {\n+                                case FLOAT -> attributes.put(OnnxOps.Constant.Attribute.value_floats.name(), t.data().toArray(ValueLayout.JAVA_FLOAT));\n+                                case INT64 -> attributes.put(OnnxOps.Constant.Attribute.value_ints.name(), t.data().toArray(ValueLayout.JAVA_LONG));\n+                                default -> throw new UnsupportedOperationException();\n+                            }\n+                        }\n+                        default -> throw new UnsupportedOperationException();\n+                    }\n+                }\n+\n@@ -164,2 +273,2 @@\n-                        n.opType(),\n-                        n.input() == null ? List.of() : n.input().stream().map(valueMap::get).toList(),\n+                        opType,\n+                        inputs,\n@@ -168,1 +277,1 @@\n-                        n.attribute() == null ? Map.of() : n.attribute().stream().collect(Collectors.toMap(OnnxModel.AttributeProto::name, OnnxModelTest::toAttributeValue)),\n+                        attributes,\n@@ -170,1 +279,1 @@\n-                OnnxOp rawOp = (OnnxOp)ONNX_FACTORY.constructOpOrFail(extOp);\n+                OnnxOp rawOp = (OnnxOp)ONNX_OP_FACTORY.constructOpOrFail(extOp);\n@@ -183,1 +292,1 @@\n-                Op.Result res = fb.op((OnnxOp)ONNX_FACTORY.constructOpOrFail(extOp));\n+                Op.Result res = fb.op((OnnxOp)ONNX_OP_FACTORY.constructOpOrFail(extOp));\n@@ -186,1 +295,1 @@\n-                if (rawOp.onnxOutputs().size() == 1) {\n+                if (outputNames.size() == 1) {\n@@ -190,2 +299,2 @@\n-                    for (int i = 0; i < n.output().size(); i++) {\n-                        valueMap.put(n.output().get(i), fb.op(CoreOp.tupleLoad(res, i)));\n+                    for (int i = 0; i < outputNames.size(); i++) {\n+                        valueMap.put(outputNames.get(i), fb.op(CoreOp.tupleLoad(res, i)));\n@@ -205,1 +314,1 @@\n-        return new OpWithNames(func, List.of(valueMap.sequencedKeySet().toArray(String[]::new)));\n+        return new OpWithNames<>(func, List.of(valueMap.sequencedKeySet().toArray(String[]::new)));\n@@ -228,1 +337,1 @@\n-                case OnnxOps.ConstantOfShape cos -> \/\/ get tensor type from tensor attribute\n+                case OnnxOps.ConstantOfShape _, OnnxOps.Constant _-> \/\/ get tensor type from tensor attribute\n@@ -333,3 +442,4 @@\n-\/\/                System.out.println(model.toText());\n-                System.out.println(toFuncOp(model.graph()).toText());\n-            }\n+                System.out.println(model.toText());\n+                var liftedModel = toFuncOp(model.graph());\n+                System.out.println(liftedModel.toText());\n+           }\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/proto\/OnnxModelTest.java","additions":130,"deletions":20,"binary":false,"changes":150,"status":"modified"}]}