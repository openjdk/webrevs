{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import java.io.CharArrayWriter;\n@@ -280,1 +281,11 @@\n-        String fieldName = getName() + \"$\" + \"op\";\n+        CharArrayWriter sigB = new CharArrayWriter();\n+        for (var p : parameterTypes) {\n+            sigB.append(p.descriptorString());\n+        }\n+        char[] sig = sigB.toCharArray();\n+        for (int i = 0; i < sig.length; i++) {\n+            switch (sig[i]) {\n+                case '.', ';', '[', '\/': sig[i] = '$';\n+            }\n+        }\n+        String fieldName = getName() + \"$\" + new String(sig) + \"$\" + \"op\";\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+import java.io.CharArrayWriter;\n@@ -194,1 +195,1 @@\n-                classOps.add(opFieldDecl(tree.name, tree.getModifiers().flags, funcOp));\n+                classOps.add(opFieldDecl(methodName(tree), tree.getModifiers().flags, funcOp));\n@@ -357,0 +358,28 @@\n+    Name methodName(JCMethodDecl method) {\n+        CharArrayWriter sig = new CharArrayWriter();\n+        var sigGen = new Types.SignatureGenerator(types) {\n+            @Override\n+            protected void append(char ch) {\n+                sig.append(ch);\n+            }\n+            @Override\n+            protected void append(byte[] ba) {\n+                sig.append(new String(ba));\n+            }\n+            @Override\n+            protected void append(Name name) {\n+                sig.append(name.toString());\n+            }\n+        };\n+        for (var pt : method.sym.externalType(types).getParameterTypes()) {\n+            sigGen.assembleSig(types.erasure(pt));\n+        }\n+        char[] sigCh = sig.toCharArray();\n+        for (int i = 0; i < sigCh.length; i++) {\n+            switch (sigCh[i]) {\n+                case '.', ';', '[', '\/' -> sigCh[i] = '$';\n+            }\n+        }\n+        return method.name.append('$', names.fromChars(sigCh, 0, sigCh.length));\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestOverloads\n+ *\/\n+\n+public class TestOverloads {\n+\n+    @CodeReflection\n+    static int f() {\n+       return 0;\n+    }\n+\n+    @CodeReflection\n+    static int f(int i) {\n+       return 1;\n+    }\n+\n+    @CodeReflection\n+    static int f(Integer i) {\n+       return 2;\n+    }\n+\n+    @CodeReflection\n+    static int f(Object o) {\n+       return 3;\n+    }\n+\n+    @CodeReflection\n+    static int f(List<Integer> l) {\n+       return 4;\n+    }\n+\n+    @CodeReflection\n+    static int f(List<Integer> l, Object o) {\n+       return 5;\n+    }\n+\n+    @DataProvider(name = \"testData\")\n+    public static Object[][]  testData() {\n+        return new Object[][]{\n+            new Object[] {new Class[]{}, new Object[]{}},\n+            new Object[] {new Class[]{int.class}, new Object[]{-1}},\n+            new Object[] {new Class[]{Integer.class}, new Object[]{-1}},\n+            new Object[] {new Class[]{Object.class}, new Object[]{\"hello\"}},\n+            new Object[] {new Class[]{List.class}, new Object[]{List.of()}},\n+            new Object[] {new Class[]{List.class, Object.class}, new Object[]{List.of(), -1}}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testData\")\n+    public static void testOverloads(Class<?>[] paramTypes, Object[] params) {\n+        try {\n+            Class<TestOverloads> clazz = TestOverloads.class;\n+            Method method = clazz.getDeclaredMethod(\"f\", paramTypes);\n+            CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+            var res1 = Interpreter.invoke(MethodHandles.lookup(), f, params);\n+            var res2 = method.invoke(null, params);\n+\n+            Assert.assertEquals(res1, res2);\n+\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOverloads.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -171,1 +171,1 @@\n-    public void finallyReturn() {\n+    public void testFinallyReturn() {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryFinally.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-    public void finallyReturn() {\n+    public void testFinallyReturn() {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}