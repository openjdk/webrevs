{"files":[{"patch":"@@ -28,9 +28,3 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-import java.lang.reflect.code.op.OpDeclaration;\n-import java.lang.reflect.code.op.OpDefinition;\n-import java.lang.reflect.code.op.OpFactory;\n-import java.lang.reflect.code.op.OpWithDefinition;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.*;\n+import java.lang.reflect.code.type.JavaType;\n@@ -44,1 +38,1 @@\n-        final TypeDesc resultType;\n+        final TypeElement resultType;\n@@ -58,1 +52,1 @@\n-        ArithMathOp(String name, TypeDesc resultType, List<? extends Value> operands) {\n+        ArithMathOp(String name, TypeElement resultType, List<? extends Value> operands) {\n@@ -65,1 +59,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -87,2 +81,2 @@\n-        static Object processConstantValue(TypeDesc t, Object value) {\n-            if (t.equals(TypeDesc.BOOLEAN)) {\n+        static Object processConstantValue(TypeElement t, Object value) {\n+            if (t.equals(JavaType.BOOLEAN)) {\n@@ -94,1 +88,1 @@\n-            } else if (t.equals(TypeDesc.BYTE)) {\n+            } else if (t.equals(JavaType.BYTE)) {\n@@ -100,1 +94,1 @@\n-            } else if (t.equals(TypeDesc.SHORT)) {\n+            } else if (t.equals(JavaType.SHORT)) {\n@@ -106,1 +100,1 @@\n-            } else if (t.equals(TypeDesc.CHAR)) {\n+            } else if (t.equals(JavaType.CHAR)) {\n@@ -112,1 +106,1 @@\n-            } else if (t.equals(TypeDesc.INT)) {\n+            } else if (t.equals(JavaType.INT)) {\n@@ -118,1 +112,1 @@\n-            } else if (t.equals(TypeDesc.LONG)) {\n+            } else if (t.equals(JavaType.LONG)) {\n@@ -124,1 +118,1 @@\n-            } else if (t.equals(TypeDesc.FLOAT)) {\n+            } else if (t.equals(JavaType.FLOAT)) {\n@@ -130,1 +124,1 @@\n-            } else if (t.equals(TypeDesc.DOUBLE)) {\n+            } else if (t.equals(JavaType.DOUBLE)) {\n@@ -136,3 +130,2 @@\n-            } else if (t.rawType().equals(TritonOps.TYPE_Tensor)) {\n-                List<TypeDesc> typeDescs = t.typeArguments();\n-                return processConstantValue(typeDescs.getLast(), value);\n+            } else if (t instanceof TensorType tt) {\n+                return processConstantValue(TritonType.fromType(tt.eType()), value);\n@@ -161,1 +154,1 @@\n-        ConstantOp(TypeDesc type, Object value) {\n+        ConstantOp(TypeElement type, Object value) {\n@@ -374,1 +367,1 @@\n-        TruncOp(TypeDesc t, Value a) {\n+        TruncOp(TypeElement t, Value a) {\n@@ -458,6 +451,6 @@\n-    static String maxMinSuffixFromType(TypeDesc t) {\n-        if (t.rawType().equals(TritonOps.TYPE_Tensor)) {\n-            return maxMinSuffixFromType(t.typeArguments().getLast());\n-        } else if (t.rawType().equals(TritonOps.TYPE_Ptr)) {\n-            return maxMinSuffixFromType(t.typeArguments().getFirst());\n-        } else if (TypeDesc.INT.equals(t)) {\n+    static String maxMinSuffixFromType(TypeElement t) {\n+        if (t instanceof TensorType tt) {\n+            return maxMinSuffixFromType(TritonType.fromType(tt.eType()));\n+        } else if (t instanceof PtrType pt) {\n+            return maxMinSuffixFromType(TritonType.fromType(pt.rType()));\n+        } else if (t.equals(JavaType.INT)) {\n@@ -465,1 +458,1 @@\n-        } else if (TypeDesc.FLOAT.equals(t)) {\n+        } else if (t.equals(JavaType.FLOAT)) {\n@@ -472,6 +465,6 @@\n-    static String nameSuffixFromType(TypeDesc t, boolean signed) {\n-        if (t.rawType().equals(TritonOps.TYPE_Tensor)) {\n-            return nameSuffixFromType(t.typeArguments().getLast(), signed);\n-        } else if (t.rawType().equals(TritonOps.TYPE_Ptr)) {\n-            return nameSuffixFromType(t.typeArguments().getFirst(), signed);\n-        } else if (TypeDesc.INT.equals(t) || TypeDesc.LONG.equals(t)) {\n+    static String nameSuffixFromType(TypeElement t, boolean signed) {\n+        if (t instanceof TensorType tt) {\n+            return nameSuffixFromType(TritonType.fromType(tt.eType()), signed);\n+        } else if (t instanceof PtrType pt) {\n+            return nameSuffixFromType(TritonType.fromType(pt.rType()), signed);\n+        } else if (t.equals(JavaType.INT) || t.equals(JavaType.LONG)) {\n@@ -479,1 +472,1 @@\n-        } else if (TypeDesc.FLOAT.equals(t) || TypeDesc.DOUBLE.equals(t) ||\n+        } else if (t.equals(JavaType.FLOAT) || t.equals(JavaType.DOUBLE) ||\n@@ -507,1 +500,1 @@\n-    public static ConstantOp constant(TypeDesc type, Object value) {\n+    public static ConstantOp constant(TypeElement type, Object value) {\n@@ -547,1 +540,1 @@\n-    public static TruncOp trunc(TypeDesc type, Value a) {\n+    public static TruncOp trunc(TypeElement type, Value a) {\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ArithMathOps.java","additions":35,"deletions":42,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -33,0 +32,2 @@\n+    static final String NAME = \"constant\";\n+\n@@ -49,5 +50,0 @@\n-    @Override\n-    public TypeDesc toDesc() {\n-        return fromType(cType);\n-    }\n-\n@@ -69,1 +65,1 @@\n-        return value.toString();\n+        return NAME + \"<\" + fromType(cType).toString() + \", c\" + value + \">\";\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ConstantType.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n@@ -32,1 +33,1 @@\n-    static final TypeDesc FLOAT_16_TYPE = TypeDesc.type(Float16.class);\n+    static final TypeElement FLOAT_16_TYPE = JavaType.type(Float16.class);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Float16.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -33,0 +32,1 @@\n+    static final String NAME = \"ptr\";\n@@ -43,5 +43,0 @@\n-    @Override\n-    public TypeDesc toDesc() {\n-        return TypeDesc.type(TritonOps.TYPE_Ptr, fromType(rType));\n-    }\n-\n@@ -63,1 +58,1 @@\n-        return toDesc().toString();\n+        return NAME + \"<\" + TritonType.fromType(rType) + \">\";\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/PtrType.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -32,0 +31,2 @@\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.TupleType;\n@@ -93,1 +94,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -130,2 +131,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -134,1 +135,1 @@\n-        static TypeDesc yieldType(List<Value> values) {\n+        static TypeElement yieldType(List<Value> values) {\n@@ -138,1 +139,1 @@\n-                return CoreOps.Tuple.typeFromValues(values);\n+                return TupleType.tupleTypeFromValues(values);\n@@ -146,1 +147,1 @@\n-        TypeDesc yieldType = (iterValues.size() == 1)\n+        TypeElement yieldType = (iterValues.size() == 1)\n@@ -148,1 +149,1 @@\n-                : CoreOps.Tuple.typeFromValues(iterValues);\n+                : TupleType.tupleTypeFromValues(iterValues);\n@@ -150,1 +151,1 @@\n-        List<TypeDesc> bodyParameterTypes = new ArrayList<>();\n+        List<TypeElement> bodyParameterTypes = new ArrayList<>();\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SCFOps.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -36,0 +35,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -49,1 +49,1 @@\n-        if (fop.init().yieldType().equals(TypeDesc.VOID)) {\n+        if (fop.init().yieldType().equals(JavaType.VOID)) {\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SimpleCountedForLoopInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-import java.util.ArrayList;\n@@ -33,0 +31,1 @@\n+import java.util.stream.Collectors;\n@@ -35,0 +34,2 @@\n+    static final String NAME = \"tensor\";\n+\n@@ -61,10 +62,0 @@\n-    @Override\n-    public TypeDesc toDesc() {\n-        List<TypeDesc> params = new ArrayList<>();\n-        for (int i : shape) {\n-            params.add(TypeDesc.ofString(\"x\" + i));\n-        }\n-        params.add(fromType(eType));\n-        return TypeDesc.type(TritonOps.TYPE_Tensor, params);\n-    }\n-\n@@ -86,1 +77,10 @@\n-        return toDesc().toString();\n+        StringBuilder s = new StringBuilder();\n+\n+        s.append(NAME);\n+        s.append(\"<\");\n+        s.append(shape.stream().map(i -> \"x\" + i).collect(Collectors.joining(\",\")));\n+        s.append(\",\");\n+        s.append(fromType(eType));\n+        s.append(\">\");\n+\n+        return s.toString();\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TensorType.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -30,1 +31,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -32,4 +32,2 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n+import java.lang.reflect.code.type.*;\n+import java.util.*;\n@@ -39,2 +37,0 @@\n-    static final TypeDesc TYPE_Ptr = TypeDesc.ofString(\"ptr\");\n-    static final TypeDesc TYPE_Tensor = TypeDesc.ofString(\"tensor\");\n@@ -43,1 +39,1 @@\n-        final TypeDesc resultType;\n+        final TypeElement resultType;\n@@ -57,1 +53,1 @@\n-        TritonOp(String name, TypeDesc resultType, List<? extends Value> operands) {\n+        TritonOp(String name, TypeElement resultType, List<? extends Value> operands) {\n@@ -64,1 +60,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -114,1 +110,1 @@\n-            super(NAME, TypeDesc.VOID,\n+            super(NAME, JavaType.VOID,\n@@ -211,1 +207,1 @@\n-            super(NAME, TypeDesc.VOID,\n+            super(NAME, JavaType.VOID,\n@@ -287,1 +283,1 @@\n-        CallOp(String funcName, TypeDesc resultType, List<Value> args) {\n+        CallOp(String funcName, TypeElement resultType, List<Value> args) {\n@@ -411,1 +407,1 @@\n-            super(NAME, TypeDesc.VOID, List.of(r));\n+            super(NAME, JavaType.VOID, List.of(r));\n@@ -450,1 +446,1 @@\n-            super(NAME, TypeDesc.INT, List.of());\n+            super(NAME, JavaType.INT, List.of());\n@@ -518,2 +514,2 @@\n-        static TypeDesc tensorType(int start, int end) {\n-            return new TensorType(int.class, List.of(end - start)).toDesc();\n+        static TensorType tensorType(int start, int end) {\n+            return new TensorType(int.class, List.of(end - start));\n@@ -565,1 +561,1 @@\n-        ExpandOp(int axis, TypeDesc tensorType, Value v) {\n+        ExpandOp(int axis, TypeElement tensorType, Value v) {\n@@ -600,1 +596,1 @@\n-        SplatOp(TypeDesc tensorType, Value v) {\n+        SplatOp(TypeElement tensorType, Value v) {\n@@ -622,1 +618,1 @@\n-        BroadcastOp(TypeDesc tensorType, Value v) {\n+        BroadcastOp(TypeElement tensorType, Value v) {\n@@ -666,1 +662,1 @@\n-        LoadOp(TypeDesc tensorType, Value ptr, Value mask) {\n+        LoadOp(TypeElement tensorType, Value ptr, Value mask) {\n@@ -689,1 +685,1 @@\n-            super(NAME, TypeDesc.VOID, List.of(ptr, v, mask));\n+            super(NAME, JavaType.VOID, List.of(ptr, v, mask));\n@@ -711,1 +707,1 @@\n-            super(NAME, TypeDesc.VOID, List.of());\n+            super(NAME, JavaType.VOID, List.of());\n@@ -715,1 +711,1 @@\n-            super(NAME, TypeDesc.VOID, List.of(v));\n+            super(NAME, JavaType.VOID, List.of(v));\n@@ -736,1 +732,1 @@\n-        DotOp(TypeDesc tensorType, Value a, Value b) {\n+        DotOp(TypeElement tensorType, Value a, Value b) {\n@@ -789,4 +785,1 @@\n-\n-    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(TritonOps.class);\n-\n-    public static ExpandOp expand(int axis, TypeDesc tensorType, Value v) {\n+    public static ExpandOp expand(int axis, TypeElement tensorType, Value v) {\n@@ -797,1 +790,1 @@\n-    public static SplatOp splat(TypeDesc tensorType, Value v) {\n+    public static SplatOp splat(TypeElement tensorType, Value v) {\n@@ -802,1 +795,1 @@\n-    public static BroadcastOp broadcast(TypeDesc tensorType, Value v) {\n+    public static BroadcastOp broadcast(TypeElement tensorType, Value v) {\n@@ -810,1 +803,1 @@\n-    public static LoadOp load(TypeDesc tensorType, Value ptr, Value mask) {\n+    public static LoadOp load(TypeElement tensorType, Value ptr, Value mask) {\n@@ -826,1 +819,1 @@\n-    public static DotOp dot(TypeDesc tensorType, Value a, Value b) {\n+    public static DotOp dot(TypeElement tensorType, Value a, Value b) {\n@@ -829,0 +822,83 @@\n+\n+\n+    \/\/ Operation and type factories\n+\n+    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(TritonOps.class);\n+\n+    static final TypeElementFactory TRITON_TYPE_FACTORY = new TypeElementFactory() {\n+        @Override\n+        public TypeElement constructType(TypeDefinition tree) {\n+            if (tree.isArray()) {\n+                return null;\n+            }\n+            return switch (tree.name()) {\n+                case PtrType.NAME -> {\n+                    if (tree.typeArguments().size() != 1) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    TypeElement v = TRITON_JAVA_TYPE_FACTORY.constructType(tree.typeArguments().getFirst());\n+                    if (v == null) {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+                    if (v instanceof JavaType jt) {\n+                        yield new PtrType(resolve(jt));\n+                    } else if (v instanceof TensorType tt) {\n+                        yield new PtrType(tt);\n+                    } else {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+                }\n+                case TensorType.NAME -> {\n+                    if (tree.typeArguments().size() < 2) {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+\n+                    List<Integer> shape = new ArrayList<>();\n+                    for (int i = 0; i < tree.typeArguments().size() - 1; i++) {\n+                        TypeDefinition a = tree.typeArguments().get(i);\n+                        if (!a.name().startsWith(\"x\")) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        int d;\n+                        try {\n+                            d = Integer.parseInt(a.name().substring(1));\n+                        } catch (NumberFormatException e) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree, e);\n+                        }\n+                        shape.add(d);\n+                    }\n+\n+                    TypeElement v = TRITON_JAVA_TYPE_FACTORY.constructType(tree.typeArguments().getLast());\n+                    if (v == null) {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+                    if (v instanceof JavaType jt) {\n+                        yield new TensorType(resolve(jt), shape);\n+                    } else if (v instanceof TritonType tt) {\n+                        yield new TensorType(tt, shape);\n+                    } else {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+                }\n+                default -> null;\n+            };\n+        }\n+    };\n+\n+    static Class<?> resolve(JavaType t) {\n+        try {\n+            return t.resolve(MethodHandles.lookup());\n+        } catch (ReflectiveOperationException e) {\n+            throw new IllegalArgumentException(\"Bad type: \" + t, e);\n+        }\n+    }\n+\n+    \/\/ Triton types then Java types\n+    static final TypeElementFactory TRITON_JAVA_TYPE_FACTORY =\n+            TRITON_TYPE_FACTORY.andThen(CoreTypeFactory.JAVA_TYPE_FACTORY);\n+\n+    \/\/ Triton types then Java types, combined with code model types\n+    public static final TypeElementFactory TYPE_FACTORY =\n+            CoreTypeFactory.codeModelTypeFactory(TRITON_JAVA_TYPE_FACTORY);\n+\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":109,"deletions":33,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.code.TypeElement;\n@@ -31,1 +32,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -36,0 +36,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -62,2 +63,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTestOps.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -39,0 +38,2 @@\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.VarType;\n@@ -49,1 +50,1 @@\n-    static final TypeDesc TYPE_Triton = TypeDesc.type(Triton.class);\n+    static final JavaType TYPE_Triton = JavaType.type(Triton.class);\n@@ -51,1 +52,1 @@\n-    static final TypeDesc TYPE_Triton_Test = TypeDesc.ofString(\"oracle.code.triton.TritonTest\");\n+    static final JavaType TYPE_Triton_Test = JavaType.ofString(\"oracle.code.triton.TritonTest\");\n@@ -53,1 +54,1 @@\n-    static final TypeDesc TYPE_Tensor = TypeDesc.type(Tensor.class);\n+    static final JavaType TYPE_Tensor = JavaType.type(Tensor.class);\n@@ -55,1 +56,1 @@\n-    static final TypeDesc TYPE_J_L_MATH = TypeDesc.type(Math.class);\n+    static final JavaType TYPE_J_L_MATH = JavaType.type(Math.class);\n@@ -94,1 +95,5 @@\n-            sb.append(argType);\n+            if (argType instanceof ConstantType ct) {\n+                sb.append(ct.value());\n+            } else {\n+                sb.append(argType);\n+            }\n@@ -133,1 +138,1 @@\n-                    TypeDesc td = op.result().type();\n+                    JavaType td = (JavaType) op.result().type();\n@@ -143,1 +148,1 @@\n-                        TypeDesc vtd = (TypeDesc) cop.value();\n+                        JavaType vtd = (JavaType) cop.value();\n@@ -178,1 +183,1 @@\n-                case InvokeOp iop when iop.invokeDescriptor().refType().equals(TypeDesc.J_L_INTEGER) -> {\n+                case InvokeOp iop when iop.invokeDescriptor().refType().equals(JavaType.J_L_INTEGER) -> {\n@@ -216,3 +221,2 @@\n-                    TypeDesc type = fop.init().yieldType();\n-                    assert type.rawType().equals(Var.VAR_TYPE);\n-                    if (type.typeArguments().get(0).equals(TypeDesc.INT)) {\n+                    TypeElement type = fop.init().yieldType();\n+                    if (type instanceof VarType vt && vt.valueType().equals(JavaType.INT)) {\n@@ -564,1 +568,2 @@\n-                            Op.Result cr = fblock.op(ArithMathOps.constant(ct.toDesc(), ct.value()));\n+                            Op.Result cr = fblock.op(ArithMathOps.constant(\n+                                    TritonType.fromType(ct.cType()), ct.value()));\n@@ -599,1 +604,2 @@\n-                    Op.Result r = kblock.op(ArithMathOps.constant(ct.toDesc(), ct.value()));\n+                    Op.Result r = kblock.op(ArithMathOps.constant(\n+                            TritonType.fromType(ct.cType()), ct.value()));\n@@ -611,1 +617,1 @@\n-            case InvokeOp iop when iop.invokeDescriptor().refType().equals(TypeDesc.J_L_INTEGER) -> {\n+            case InvokeOp iop when iop.invokeDescriptor().refType().equals(JavaType.J_L_INTEGER) -> {\n@@ -639,1 +645,1 @@\n-                    Op.Result result = kblock.op(CoreOps.constant(iop.resultType(), aType.toDesc()));\n+                    Op.Result result = kblock.op(CoreOps.constant(iop.resultType(), aType));\n@@ -901,1 +907,1 @@\n-                    rType.toDesc(),\n+                    rType,\n@@ -914,1 +920,1 @@\n-            return block.op(ArithMathOps.constant(rType.toDesc(), zero));\n+            return block.op(ArithMathOps.constant(rType, zero));\n@@ -922,1 +928,1 @@\n-                    rType.toDesc(),\n+                    rType,\n@@ -945,1 +951,1 @@\n-                        rType.toDesc(),\n+                        rType,\n@@ -949,1 +955,1 @@\n-                        rType.toDesc(),\n+                        rType,\n@@ -960,1 +966,1 @@\n-            return block.op(CoreOps.constant(TypeDesc.type(TensorType.class), r.type()));\n+            return block.op(CoreOps.constant(JavaType.type(TensorType.class), r.type()));\n@@ -1035,1 +1041,1 @@\n-            return block.op(TritonOps.dot(rType.toDesc(), a, b));\n+            return block.op(TritonOps.dot(rType, a, b));\n@@ -1130,1 +1136,1 @@\n-            TypeDesc elementType = TritonType.fromType(rType);\n+            TypeElement elementType = TritonType.fromType(rType);\n@@ -1137,1 +1143,1 @@\n-        static TritonOps.FuncOp reduce(TypeDesc elementType,\n+        static TritonOps.FuncOp reduce(TypeElement elementType,\n@@ -1142,1 +1148,1 @@\n-                            methodType(elementType, tensorType.toDesc()))\n+                            methodType(elementType, tensorType))\n@@ -1173,1 +1179,1 @@\n-                    ma = block.op(TritonOps.broadcast(rTensorType.toDesc(), ma));\n+                    ma = block.op(TritonOps.broadcast(rTensorType, ma));\n@@ -1178,1 +1184,1 @@\n-                        mb = block.op(TritonOps.broadcast(bTensorType.toDesc(), mb));\n+                        mb = block.op(TritonOps.broadcast(bTensorType, mb));\n@@ -1180,1 +1186,1 @@\n-                        mb = block.op(TritonOps.broadcast(rTensorType.toDesc(), mb));\n+                        mb = block.op(TritonOps.broadcast(rTensorType, mb));\n@@ -1187,1 +1193,1 @@\n-                    mb = block.op(TritonOps.splat(bTensorType.toDesc(), mb));\n+                    mb = block.op(TritonOps.splat(bTensorType, mb));\n@@ -1189,1 +1195,1 @@\n-                    mb = block.op(TritonOps.splat(rTensorType.toDesc(), mb));\n+                    mb = block.op(TritonOps.splat(rTensorType, mb));\n@@ -1193,1 +1199,1 @@\n-                ma = block.op(TritonOps.splat(rTensorType.toDesc(), ma));\n+                ma = block.op(TritonOps.splat(rTensorType, ma));\n@@ -1207,1 +1213,1 @@\n-                        mb = block.op(TritonOps.broadcast(bTensorType.toDesc(), mb));\n+                        mb = block.op(TritonOps.broadcast(bTensorType, mb));\n@@ -1209,1 +1215,1 @@\n-                        mb = block.op(TritonOps.broadcast(aTensorType.toDesc(), mb));\n+                        mb = block.op(TritonOps.broadcast(aTensorType, mb));\n@@ -1216,1 +1222,1 @@\n-                    mb = block.op(TritonOps.splat(bTensorType.toDesc(), mb));\n+                    mb = block.op(TritonOps.splat(bTensorType, mb));\n@@ -1218,1 +1224,1 @@\n-                    mb = block.op(TritonOps.splat(rTensorType.toDesc(), mb));\n+                    mb = block.op(TritonOps.splat(rTensorType, mb));\n@@ -1234,1 +1240,1 @@\n-                case Op op when !op.result().type().equals(TypeDesc.VOID) -> {\n+                case Op op when !op.result().type().equals(JavaType.VOID) -> {\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTransformer.java","additions":43,"deletions":37,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n@@ -31,1 +32,1 @@\n-public abstract sealed class TritonType implements Type\n+public abstract sealed class TritonType implements Type, TypeElement\n@@ -34,3 +35,1 @@\n-    public abstract TypeDesc toDesc();\n-\n-    public static TypeDesc fromType(Type t) {\n+    public static TypeElement fromType(Type t) {\n@@ -38,1 +37,1 @@\n-            return TypeDesc.type(c);\n+            return JavaType.type(c);\n@@ -40,1 +39,1 @@\n-            return tt.toDesc();\n+            return tt;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonType.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-                    %6 : java.lang.reflect.code.CoreOps$Tuple<tensor<x64, int>, tensor<x64, int>> = scf.for %4 %0 %5 %2 %3 (%7 : int, %8 : tensor<x64, int>, %9 : tensor<x64, int>)java.lang.reflect.code.CoreOps$Tuple<tensor<x64, int>, tensor<x64, int>> -> {\n+                    %6 : Tuple<tensor<x64, int>, tensor<x64,int>> = scf.for %4 %0 %5 %2 %3 (%7 : int, %8 : tensor<x64, int>, %9 : tensor<x64, int>)Tuple<tensor<x64, int>, tensor<x64, int>> -> {\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestCountedLoop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-                    %79 : java.lang.reflect.code.CoreOps$Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<float>>, tensor<x32, x64, ptr<float>>> = scf.for %76 %77 %78 %75 %63 %74 (%80 : int, %81 : tensor<x32, x64, float>, %82 : tensor<x32, x32, ptr<float>>, %83 : tensor<x32, x64, ptr<float>>)java.lang.reflect.code.CoreOps$Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<float>>, tensor<x32, x64, ptr<float>>> -> {\n+                    %79 : Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<float>>, tensor<x32, x64, ptr<float>>> = scf.for %76 %77 %78 %75 %63 %74 (%80 : int, %81 : tensor<x32, x64, float>, %82 : tensor<x32, x32, ptr<float>>, %83 : tensor<x32, x64, ptr<float>>)Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<float>>, tensor<x32, x64, ptr<float>>> -> {\n@@ -392,1 +392,1 @@\n-                    %79 : java.lang.reflect.code.CoreOps$Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<oracle.code.triton.Float16>>, tensor<x32, x64, ptr<oracle.code.triton.Float16>>> = scf.for %76 %77 %78 %75 %63 %74 (%80 : int, %81 : tensor<x32, x64, float>, %82 : tensor<x32, x32, ptr<oracle.code.triton.Float16>>, %83 : tensor<x32, x64, ptr<oracle.code.triton.Float16>>)java.lang.reflect.code.CoreOps$Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<oracle.code.triton.Float16>>, tensor<x32, x64, ptr<oracle.code.triton.Float16>>> -> {\n+                    %79 : Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<oracle.code.triton.Float16>>, tensor<x32, x64, ptr<oracle.code.triton.Float16>>> = scf.for %76 %77 %78 %75 %63 %74 (%80 : int, %81 : tensor<x32, x64, float>, %82 : tensor<x32, x32, ptr<oracle.code.triton.Float16>>, %83 : tensor<x32, x64, ptr<oracle.code.triton.Float16>>)Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<oracle.code.triton.Float16>>, tensor<x32, x64, ptr<oracle.code.triton.Float16>>> -> {\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestMatrix.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+                    TritonOps.TYPE_FACTORY,\n@@ -108,2 +109,3 @@\n-            Assertions.assertEquals(actualTritonKernel.toText(),\n-                    expectedTritonKernel == null ? \"NO @TritonCodeModel\" : expectedTritonKernel.toText());\n+            Assertions.assertEquals(\n+                    expectedTritonKernel == null ? \"NO @TritonCodeModel\" : expectedTritonKernel.toText(),\n+                    actualTritonKernel.toText());\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonTestExtension.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+  $base\/type \\\n+  $base\/type\/impl \\\n","filename":"cr-util\/copy-to-compiler.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,10 +29,1 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n+import java.util.*;\n@@ -40,1 +31,0 @@\n-import java.util.function.BiFunction;\n@@ -63,1 +53,1 @@\n-        Parameter(Block block, TypeDesc type) {\n+        Parameter(Block block, TypeElement type) {\n@@ -139,1 +129,1 @@\n-    Block(Body parentBody, List<TypeDesc> parameterTypes) {\n+    Block(Body parentBody, List<TypeElement> parameterTypes) {\n@@ -142,1 +132,1 @@\n-        for (TypeDesc param : parameterTypes) {\n+        for (TypeElement param : parameterTypes) {\n@@ -190,1 +180,1 @@\n-    public List<TypeDesc> parameterTypes() {\n+    public List<TypeElement> parameterTypes() {\n@@ -477,1 +467,1 @@\n-        public Block.Builder block(TypeDesc... params) {\n+        public Block.Builder block(TypeElement... params) {\n@@ -487,1 +477,1 @@\n-        public Block.Builder block(List<TypeDesc> params) {\n+        public Block.Builder block(List<TypeElement> params) {\n@@ -506,1 +496,1 @@\n-        public Parameter parameter(TypeDesc p) {\n+        public Parameter parameter(TypeElement p) {\n@@ -602,1 +592,1 @@\n-                            List<TypeDesc> param = rop.returnValue() != null\n+                            List<TypeElement> param = rop.returnValue() != null\n@@ -834,1 +824,1 @@\n-    private Parameter appendBlockParameter(TypeDesc type) {\n+    private Parameter appendBlockParameter(TypeElement type) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Block.java","additions":10,"deletions":20,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-\n@@ -32,1 +30,0 @@\n-import java.util.function.BiFunction;\n@@ -59,1 +56,1 @@\n-    final TypeDesc yieldType;\n+    final TypeElement yieldType;\n@@ -70,1 +67,0 @@\n-     *\n@@ -72,1 +68,1 @@\n-    Body(Body ancestorBody, TypeDesc yieldType) {\n+    Body(Body ancestorBody, TypeElement yieldType) {\n@@ -81,1 +77,1 @@\n-    public TypeDesc yieldType() {\n+    public TypeElement yieldType() {\n@@ -448,0 +444,1 @@\n+         *\n@@ -451,1 +448,1 @@\n-            TypeDesc returnType = Body.this.yieldType();\n+            TypeElement returnType = Body.this.yieldType();\n@@ -492,1 +489,1 @@\n-        Block.Builder block(List<TypeDesc> params, CopyContext cc, OpTransformer ot) {\n+        Block.Builder block(List<TypeElement> params, CopyContext cc, OpTransformer ot) {\n@@ -598,1 +595,1 @@\n-    private Block createBlock(List<TypeDesc> params) {\n+    private Block createBlock(List<TypeElement> params) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Body.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * A code item, one of {@link CodeElement}, or {@link Value}.\n+ * A code item, one of {@link CodeElement}, {@link Value}, or {@link TypeElement}.\n@@ -7,1 +7,1 @@\n-        permits CodeElement, Value {\n+        permits CodeElement, Value, TypeElement {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CodeItem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-\n@@ -35,0 +32,1 @@\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n@@ -90,0 +88,1 @@\n+        \/\/ @@@ Replace with FunctionType\n@@ -318,1 +317,1 @@\n-    public abstract TypeDesc resultType();\n+    public abstract TypeElement resultType();\n@@ -328,0 +327,1 @@\n+    \/\/ @@@ Replace with FunctionType\n@@ -329,1 +329,1 @@\n-        List<TypeDesc> operandTypes = operands.stream().map(Value::type).toList();\n+        List<TypeElement> operandTypes = operands.stream().map(Value::type).toList();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Op.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,18 @@\n+package java.lang.reflect.code;\n+\n+\/**\n+ * A type, that defines a set of values.\n+ * <p>\n+ * A type can be assigned to a {@link Value value} in a code model,\n+ * and implies the value is a member of the type's set.\n+ * @apiNote\n+ * Code model types enable reasoning statically about a code model,\n+ * approximating run time behaviour.\n+ *\/\n+public non-sealed interface TypeElement extends CodeItem {\n+    \/\/ @@@ Common useful methods generally associated with properties of a type\n+    \/\/ e.g., arguments, is an array etc. (dimensions)\n+\n+    \/\/ @@@ Declare\n+    \/\/ toString, equals, hashCode\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/TypeElement.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-\n@@ -41,1 +39,1 @@\n-    final TypeDesc type;\n+    final TypeElement type;\n@@ -46,1 +44,1 @@\n-    Value(Block block, TypeDesc type) {\n+    Value(Block block, TypeElement type) {\n@@ -72,1 +70,1 @@\n-    public TypeDesc type() {\n+    public TypeElement type() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Value.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.reflect.code.writer.impl.GlobalValueBlockNaming;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/Liveness.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-import static java.lang.classfile.TypeKind.DoubleType;\n-import static java.lang.classfile.TypeKind.FloatType;\n-import static java.lang.classfile.TypeKind.LongType;\n@@ -59,1 +56,2 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n@@ -222,1 +220,1 @@\n-                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                    !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n@@ -234,1 +232,1 @@\n-            case TypeDesc td -> td.toNominalDescriptor();\n+            case JavaType td -> td.toNominalDescriptor();\n@@ -292,2 +290,3 @@\n-    private static TypeKind toTypeKind(TypeDesc t) {\n-        TypeDesc rbt = t.toBasicType();\n+    private static TypeKind toTypeKind(TypeElement t) {\n+        JavaType jt = (JavaType) t;\n+        TypeElement rbt = jt.toBasicType();\n@@ -295,1 +294,1 @@\n-        if (rbt.equals(TypeDesc.INT)) {\n+        if (rbt.equals(JavaType.INT)) {\n@@ -297,1 +296,1 @@\n-        } else if (rbt.equals(TypeDesc.LONG)) {\n+        } else if (rbt.equals(JavaType.LONG)) {\n@@ -299,1 +298,1 @@\n-        } else if (rbt.equals(TypeDesc.FLOAT)) {\n+        } else if (rbt.equals(JavaType.FLOAT)) {\n@@ -301,1 +300,1 @@\n-        } else if (rbt.equals(TypeDesc.DOUBLE)) {\n+        } else if (rbt.equals(JavaType.DOUBLE)) {\n@@ -303,1 +302,1 @@\n-        } else if (rbt.equals(TypeDesc.J_L_OBJECT)) {\n+        } else if (rbt.equals(JavaType.J_L_OBJECT)) {\n@@ -368,1 +367,2 @@\n-                        ClassDesc type = cb.parameters().get(0).type().toNominalDescriptor();\n+                        JavaType jt = (JavaType) cb.parameters().get(0).type();\n+                        ClassDesc type = jt.toNominalDescriptor();\n@@ -421,2 +421,2 @@\n-                TypeDesc oprType = o.resultType();\n-                TypeKind rvt = oprType.equals(TypeDesc.VOID) ? null : toTypeKind(oprType);\n+                TypeElement oprType = o.resultType();\n+                TypeKind rvt = oprType.equals(JavaType.VOID) ? null : toTypeKind(oprType);\n@@ -425,1 +425,1 @@\n-                        if (op.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                        if (op.resultType().equals(JavaType.J_L_CLASS)) {\n@@ -455,1 +455,1 @@\n-                                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                                    !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n@@ -555,1 +555,2 @@\n-                        TypeDesc t = op.constructorDescriptor().returnType();\n+                        TypeElement t_ = op.constructorDescriptor().returnType();\n+                        JavaType t = (JavaType) t_;\n@@ -568,1 +569,1 @@\n-                                        op.resultType().toNominalDescriptor(),\n+                                        ((JavaType) op.resultType()).toNominalDescriptor(),\n@@ -615,1 +616,1 @@\n-                                md.refType().toNominalDescriptor(),\n+                                ((JavaType) md.refType()).toNominalDescriptor(),\n@@ -623,1 +624,1 @@\n-                        if (op.resultType().equals(TypeDesc.VOID) && !op.operands().isEmpty()) {\n+                        if (op.resultType().equals(JavaType.VOID) && !op.operands().isEmpty()) {\n@@ -631,1 +632,4 @@\n-                            cob.getstatic(fd.refType().toNominalDescriptor(), fd.name(), fd.type().toNominalDescriptor());\n+                            cob.getstatic(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n@@ -633,1 +637,4 @@\n-                            cob.getfield(fd.refType().toNominalDescriptor(), fd.name(), fd.type().toNominalDescriptor());\n+                            cob.getfield(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n@@ -641,1 +648,4 @@\n-                            cob.putstatic(fd.refType().toNominalDescriptor(), fd.name(), fd.type().toNominalDescriptor());\n+                            cob.putstatic(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n@@ -643,1 +653,4 @@\n-                            cob.putfield(fd.refType().toNominalDescriptor(), fd.name(), fd.type().toNominalDescriptor());\n+                            cob.putfield(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n@@ -648,1 +661,1 @@\n-                        cob.instanceof_(op.type().toNominalDescriptor());\n+                        cob.instanceof_(((JavaType) op.type()).toNominalDescriptor());\n@@ -652,1 +665,1 @@\n-                        cob.checkcast(op.type().toNominalDescriptor());\n+                        cob.checkcast(((JavaType) op.type()).toNominalDescriptor());\n@@ -868,1 +881,1 @@\n-            return x.type().equals(TypeDesc.DOUBLE) || x.type().equals(TypeDesc.LONG)\n+            return x.type().equals(JavaType.DOUBLE) || x.type().equals(JavaType.LONG)\n@@ -953,1 +966,1 @@\n-                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                    !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n@@ -974,1 +987,1 @@\n-                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                    !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":44,"deletions":31,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.reflect.code.TypeElement;\n@@ -47,1 +48,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -49,0 +49,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -129,1 +130,1 @@\n-                                                entryBlock.block(List.of(TypeDesc.ofNominalDescriptor(\n+                                                entryBlock.block(List.of(JavaType.ofNominalDescriptor(\n@@ -178,6 +179,6 @@\n-                                case IFNE -> CoreOps.eq(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                                case IFEQ -> CoreOps.neq(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                                case IFGE -> CoreOps.lt(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                                case IFLE -> CoreOps.gt(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                                case IFGT -> CoreOps.le(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                                case IFLT -> CoreOps.ge(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IFNE -> CoreOps.eq(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n+                                case IFEQ -> CoreOps.neq(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n+                                case IFGE -> CoreOps.lt(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n+                                case IFLE -> CoreOps.gt(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n+                                case IFGT -> CoreOps.le(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n+                                case IFLT -> CoreOps.ge(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n@@ -240,1 +241,1 @@\n-                                TypeDesc varType = ((CoreOps.VarOp) local.op()).varType();\n+                                TypeElement varType = ((CoreOps.VarOp) local.op()).varType();\n@@ -253,1 +254,1 @@\n-                                    currentBlock.op(CoreOps.constant(TypeDesc.INT, inst.constant()))))));\n+                                    currentBlock.op(CoreOps.constant(JavaType.INT, inst.constant()))))));\n@@ -257,6 +258,6 @@\n-                                case ClassDesc v -> CoreOps.constant(TypeDesc.J_L_CLASS, TypeDesc.ofNominalDescriptor(v));\n-                                case Double v -> CoreOps.constant(TypeDesc.DOUBLE, v);\n-                                case Float v -> CoreOps.constant(TypeDesc.FLOAT, v);\n-                                case Integer v -> CoreOps.constant(TypeDesc.INT, v);\n-                                case Long v -> CoreOps.constant(TypeDesc.LONG, v);\n-                                case String v -> CoreOps.constant(TypeDesc.J_L_STRING, v);\n+                                case ClassDesc v -> CoreOps.constant(JavaType.J_L_CLASS, JavaType.ofNominalDescriptor(v));\n+                                case Double v -> CoreOps.constant(JavaType.DOUBLE, v);\n+                                case Float v -> CoreOps.constant(JavaType.FLOAT, v);\n+                                case Integer v -> CoreOps.constant(JavaType.INT, v);\n+                                case Long v -> CoreOps.constant(JavaType.LONG, v);\n+                                case String v -> CoreOps.constant(JavaType.J_L_STRING, v);\n@@ -291,1 +292,1 @@\n-                                        TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()),\n+                                        JavaType.ofNominalDescriptor(inst.owner().asSymbol()),\n@@ -293,1 +294,1 @@\n-                                        TypeDesc.ofNominalDescriptor(inst.typeSymbol()));\n+                                        JavaType.ofNominalDescriptor(inst.typeSymbol()));\n@@ -324,1 +325,4 @@\n-                            MethodDesc mDesc = MethodDesc.method(TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()), inst.name().stringValue(), mType);\n+                            MethodDesc mDesc = MethodDesc.method(\n+                                    JavaType.ofNominalDescriptor(inst.owner().asSymbol()),\n+                                    inst.name().stringValue(),\n+                                    mType);\n@@ -347,1 +351,1 @@\n-                            if (!result.type().equals(TypeDesc.VOID)) {\n+                            if (!result.type().equals(JavaType.VOID)) {\n@@ -366,8 +370,8 @@\n-                                        case BooleanType -> TypeDesc.BOOLEAN_ARRAY;\n-                                        case ByteType -> TypeDesc.BYTE_ARRAY;\n-                                        case CharType -> TypeDesc.CHAR_ARRAY;\n-                                        case DoubleType -> TypeDesc.DOUBLE_ARRAY;\n-                                        case FloatType -> TypeDesc.FLOAT_ARRAY;\n-                                        case IntType -> TypeDesc.INT_ARRAY;\n-                                        case LongType -> TypeDesc.LONG_ARRAY;\n-                                        case ShortType -> TypeDesc.SHORT_ARRAY;\n+                                        case BooleanType -> JavaType.BOOLEAN_ARRAY;\n+                                        case ByteType -> JavaType.BYTE_ARRAY;\n+                                        case CharType -> JavaType.CHAR_ARRAY;\n+                                        case DoubleType -> JavaType.DOUBLE_ARRAY;\n+                                        case FloatType -> JavaType.FLOAT_ARRAY;\n+                                        case IntType -> JavaType.INT_ARRAY;\n+                                        case LongType -> JavaType.LONG_ARRAY;\n+                                        case ShortType -> JavaType.SHORT_ARRAY;\n@@ -381,1 +385,1 @@\n-                                    TypeDesc.type(TypeDesc.ofNominalDescriptor(inst.componentType().asSymbol()), 1),\n+                                    JavaType.type(JavaType.ofNominalDescriptor(inst.componentType().asSymbol()), 1),\n@@ -387,2 +391,2 @@\n-                                            TypeDesc.ofNominalDescriptor(inst.arrayType().asSymbol()),\n-                                            Collections.nCopies(inst.dimensions(), TypeDesc.INT)),\n+                                            JavaType.ofNominalDescriptor(inst.arrayType().asSymbol()),\n+                                            Collections.nCopies(inst.dimensions(), JavaType.INT)),\n@@ -392,1 +396,1 @@\n-                            stack.push(currentBlock.op(CoreOps.cast(TypeDesc.ofNominalDescriptor(inst.type().asSymbol()), stack.pop())));\n+                            stack.push(currentBlock.op(CoreOps.cast(JavaType.ofNominalDescriptor(inst.type().asSymbol()), stack.pop())));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":36,"deletions":32,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n@@ -37,1 +39,1 @@\n-    TypeDesc refType();\n+    TypeElement refType();\n@@ -41,1 +43,1 @@\n-    TypeDesc type();\n+    TypeElement type();\n@@ -56,1 +58,1 @@\n-        return field(TypeDesc.type(refType), name, TypeDesc.type(type));\n+        return field(JavaType.type(refType), name, JavaType.type(type));\n@@ -59,1 +61,1 @@\n-    static FieldDesc field(TypeDesc refType, String name, TypeDesc type) {\n+    static FieldDesc field(TypeElement refType, String name, TypeElement type) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/FieldDesc.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-package java.lang.reflect.code.descriptor;\n-\n@@ -28,0 +26,2 @@\n+package java.lang.reflect.code.descriptor;\n+\n@@ -34,0 +34,2 @@\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n@@ -51,1 +53,1 @@\n-    TypeDesc refType();\n+    TypeElement refType();\n@@ -70,1 +72,1 @@\n-        return method(TypeDesc.type(refType), name, MethodTypeDesc.methodType(mt));\n+        return method(JavaType.type(refType), name, MethodTypeDesc.methodType(mt));\n@@ -74,1 +76,1 @@\n-        return method(TypeDesc.type(refType), name, methodType(retType, params));\n+        return method(JavaType.type(refType), name, methodType(retType, params));\n@@ -78,1 +80,1 @@\n-        return method(TypeDesc.type(refType), name, methodType(retType, params));\n+        return method(JavaType.type(refType), name, methodType(retType, params));\n@@ -85,1 +87,1 @@\n-                MethodTypeDesc.methodType(TypeDesc.VOID, mt.parameters()));\n+                MethodTypeDesc.methodType(JavaType.VOID, mt.parameters()));\n@@ -88,1 +90,1 @@\n-    static MethodDesc method(TypeDesc refType, String name, MethodTypeDesc type) {\n+    static MethodDesc method(TypeElement refType, String name, MethodTypeDesc type) {\n@@ -92,1 +94,1 @@\n-    static MethodDesc method(TypeDesc refType, String name, TypeDesc retType, TypeDesc... params) {\n+    static MethodDesc method(TypeElement refType, String name, TypeElement retType, TypeElement... params) {\n@@ -96,1 +98,1 @@\n-    static MethodDesc method(TypeDesc refType, String name, TypeDesc retType, List<TypeDesc> params) {\n+    static MethodDesc method(TypeElement refType, String name, TypeElement retType, List<? extends TypeElement> params) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/MethodDesc.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n@@ -37,1 +39,1 @@\n-    MethodTypeDesc VOID = methodType(TypeDesc.VOID);\n+    MethodTypeDesc VOID = methodType(JavaType.VOID);\n@@ -41,1 +43,1 @@\n-    TypeDesc returnType();\n+    TypeElement returnType();\n@@ -43,1 +45,1 @@\n-    List<TypeDesc> parameters();\n+    List<TypeElement> parameters();\n@@ -71,1 +73,1 @@\n-        return new MethodTypeDescImpl(TypeDesc.type(ret), params.stream().map(TypeDesc::type).toList());\n+        return new MethodTypeDescImpl(JavaType.type(ret), params.stream().map(JavaType::type).toList());\n@@ -75,2 +77,2 @@\n-        return methodType(TypeDesc.ofNominalDescriptor(d.returnType()),\n-                d.parameterList().stream().map(TypeDesc::ofNominalDescriptor).toList());\n+        return methodType(JavaType.ofNominalDescriptor(d.returnType()),\n+                d.parameterList().stream().map(JavaType::ofNominalDescriptor).toList());\n@@ -83,1 +85,1 @@\n-    static MethodTypeDesc methodType(TypeDesc ret, TypeDesc... params) {\n+    static MethodTypeDesc methodType(TypeElement ret, TypeElement... params) {\n@@ -87,1 +89,1 @@\n-    static MethodTypeDesc methodType(TypeDesc ret, List<TypeDesc> params) {\n+    static MethodTypeDesc methodType(TypeElement ret, List<? extends TypeElement> params) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/MethodTypeDesc.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n@@ -36,1 +38,1 @@\n-    TypeDesc recordType();\n+    TypeElement recordType();\n@@ -43,1 +45,1 @@\n-    record ComponentDesc(TypeDesc type, String name) {}\n+    record ComponentDesc(TypeElement type, String name) {}\n@@ -53,1 +55,1 @@\n-                .map(rc -> new ComponentDesc(TypeDesc.type(rc.getType()), rc.getName()))\n+                .map(rc -> new ComponentDesc(JavaType.type(rc.getType()), rc.getName()))\n@@ -55,1 +57,1 @@\n-        return recordType(TypeDesc.type(c), components);\n+        return recordType(JavaType.type(c), components);\n@@ -58,1 +60,1 @@\n-    static RecordTypeDesc recordType(TypeDesc recordType, ComponentDesc... components) {\n+    static RecordTypeDesc recordType(TypeElement recordType, ComponentDesc... components) {\n@@ -62,1 +64,1 @@\n-    static RecordTypeDesc recordType(TypeDesc recordType, List<ComponentDesc> components) {\n+    static RecordTypeDesc recordType(TypeElement recordType, List<ComponentDesc> components) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/RecordTypeDesc.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,220 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.descriptor;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.reflect.code.descriptor.impl.TypeDescImpl;\n-import java.lang.invoke.MethodHandles;\n-import java.util.List;\n-\n-\/**\n- * The symbolic description of a type.\n- *\/\n-public sealed interface TypeDesc permits TypeDescImpl {\n-\n-    TypeDesc VOID = new TypeDescImpl(\"void\");\n-\n-    TypeDesc BOOLEAN = new TypeDescImpl(\"boolean\");\n-\n-    TypeDesc J_L_BOOLEAN = new TypeDescImpl(\"java.lang.Boolean\");\n-\n-    TypeDesc BOOLEAN_ARRAY = new TypeDescImpl(\"boolean\", 1);\n-\n-    TypeDesc BYTE = new TypeDescImpl(\"byte\");\n-\n-    TypeDesc J_L_BYTE = new TypeDescImpl(\"java.lang.Byte\");\n-\n-    TypeDesc BYTE_ARRAY = new TypeDescImpl(\"byte\", 1);\n-\n-    TypeDesc CHAR = new TypeDescImpl(\"char\");\n-\n-    TypeDesc J_L_CHARACTER = new TypeDescImpl(\"java.lang.Character\");\n-\n-    TypeDesc CHAR_ARRAY = new TypeDescImpl(\"char\", 1);\n-\n-    TypeDesc SHORT = new TypeDescImpl(\"short\");\n-\n-    TypeDesc J_L_SHORT = new TypeDescImpl(\"java.lang.Short\");\n-\n-    TypeDesc SHORT_ARRAY = new TypeDescImpl(\"short\", 1);\n-\n-    TypeDesc INT = new TypeDescImpl(\"int\");\n-\n-    TypeDesc J_L_INTEGER = new TypeDescImpl(\"java.lang.Integer\");\n-\n-    TypeDesc INT_ARRAY = new TypeDescImpl(\"int\", 1);\n-\n-    TypeDesc LONG = new TypeDescImpl(\"long\");\n-\n-    TypeDesc J_L_LONG = new TypeDescImpl(\"java.lang.Long\");\n-\n-    TypeDesc LONG_ARRAY = new TypeDescImpl(\"long\", 1);\n-\n-    TypeDesc FLOAT = new TypeDescImpl(\"float\");\n-\n-    TypeDesc J_L_FLOAT = new TypeDescImpl(\"java.lang.Float\");\n-\n-    TypeDesc FLOAT_ARRAY = new TypeDescImpl(\"float\", 1);\n-\n-    TypeDesc DOUBLE = new TypeDescImpl(\"double\");\n-\n-    TypeDesc J_L_DOUBLE = new TypeDescImpl(\"java.lang.Double\");\n-\n-    TypeDesc DOUBLE_ARRAY = new TypeDescImpl(\"double\", 1);\n-\n-    TypeDesc J_L_OBJECT = new TypeDescImpl(\"java.lang.Object\");\n-\n-    TypeDesc J_L_OBJECT_ARRAY = new TypeDescImpl(\"java.lang.Object\", 1);\n-\n-    TypeDesc J_L_CLASS = new TypeDescImpl(\"java.lang.Class\");\n-\n-    TypeDesc J_L_STRING = new TypeDescImpl(\"java.lang.String\");\n-\n-    \/\/\n-\n-    boolean isArray();\n-\n-    int dimensions();\n-\n-    TypeDesc componentType();\n-\n-    TypeDesc rawType();\n-\n-    boolean hasTypeArguments();\n-\n-    List<TypeDesc> typeArguments();\n-\n-    \/\/ Conversions\n-\n-    TypeDesc toBasicType();\n-\n-    String toClassName();\n-\n-    String toInternalName();\n-\n-    String toNominalDescriptorString();\n-\n-    default ClassDesc toNominalDescriptor() {\n-        return ClassDesc.ofDescriptor(toNominalDescriptorString());\n-    }\n-\n-    default Class<?> resolve(MethodHandles.Lookup l) throws ReflectiveOperationException {\n-        return (Class<?>) toNominalDescriptor().resolveConstantDesc(l);\n-    }\n-\n-    \/\/ Factories\n-\n-    static TypeDesc type(Class<?> c) {\n-        int dims = 0;\n-        if (c.isArray()) {\n-            while (c.isArray()) {\n-                c = c.getComponentType();\n-                dims++;\n-            }\n-        }\n-        return new TypeDescImpl(c.getName(), dims);\n-    }\n-\n-    static TypeDesc type(Class<?> c, Class<?>... typeArguments) {\n-        return type(c, List.of(typeArguments));\n-    }\n-\n-    static TypeDesc type(Class<?> c, List<Class<?>> typeArguments) {\n-        int dims = 0;\n-        if (c.isArray()) {\n-            while (c.isArray()) {\n-                c = c.getComponentType();\n-                dims++;\n-            }\n-        }\n-        return new TypeDescImpl(c.getName(), dims, typeArguments.stream().map(TypeDesc::type).toList());\n-    }\n-\n-    static TypeDesc ofNominalDescriptor(ClassDesc d) {\n-        String descriptor = d.descriptorString();\n-        int i = 0;\n-        while (descriptor.charAt(i) == '[') {\n-            i++;\n-        }\n-        int dims = i;\n-\n-        TypeDesc td = switch (descriptor.charAt(i)) {\n-            case 'V' -> TypeDesc.VOID;\n-            case 'I' -> TypeDesc.INT;\n-            case 'J' -> TypeDesc.LONG;\n-            case 'C' -> TypeDesc.CHAR;\n-            case 'S' -> TypeDesc.SHORT;\n-            case 'B' -> TypeDesc.BYTE;\n-            case 'F' -> TypeDesc.FLOAT;\n-            case 'D' -> TypeDesc.DOUBLE;\n-            case 'Z' -> TypeDesc.BOOLEAN;\n-            case 'L' -> {\n-                \/\/ La.b.c.Class;\n-                String typeName = descriptor.substring(i + 1, descriptor.length() - 1).replace('\/', '.');\n-                yield new TypeDescImpl(typeName, 0);\n-            }\n-            default -> throw new InternalError();\n-        };\n-\n-        return TypeDesc.type(td, dims);\n-    }\n-\n-    static TypeDesc ofNominalDescriptorString(String d) {\n-        return ofNominalDescriptor(ClassDesc.ofDescriptor(d));\n-    }\n-\n-    static TypeDesc type(TypeDesc t, TypeDesc... typeArguments) {\n-        return type(t, List.of(typeArguments));\n-    }\n-\n-    static TypeDesc type(TypeDesc t, List<TypeDesc> typeArguments) {\n-        if (t.hasTypeArguments()) {\n-            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n-        }\n-        TypeDescImpl timpl = (TypeDescImpl) t;\n-        return new TypeDescImpl(timpl.type, timpl.dims, typeArguments);\n-    }\n-\n-    static TypeDesc type(TypeDesc t, int dims, TypeDesc... typeArguments) {\n-        return type(t, dims, List.of(typeArguments));\n-    }\n-\n-    static TypeDesc type(TypeDesc t, int dims, List<TypeDesc> typeArguments) {\n-        if (t.isArray()) {\n-            throw new IllegalArgumentException(\"Type descriptor must not be an array: \" + t);\n-        }\n-        if (t.hasTypeArguments()) {\n-            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n-        }\n-        TypeDescImpl timpl = (TypeDescImpl) t;\n-        return new TypeDescImpl(timpl.type, dims, typeArguments);\n-    }\n-\n-    \/\/ Copied code in jdk.compiler module throws UOE\n-    static TypeDesc ofString(String s) {\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseTypeDesc(s);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/TypeDesc.java","additions":0,"deletions":220,"binary":false,"changes":220,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -33,0 +32,2 @@\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n@@ -35,1 +36,1 @@\n-    final TypeDesc refType;\n+    final TypeElement refType;\n@@ -37,1 +38,1 @@\n-    final TypeDesc type;\n+    final TypeElement type;\n@@ -39,1 +40,1 @@\n-    public FieldDescImpl(TypeDesc refType, String name, TypeDesc type) {\n+    public FieldDescImpl(TypeElement refType, String name, TypeElement type) {\n@@ -46,1 +47,1 @@\n-    public TypeDesc refType() {\n+    public TypeElement refType() {\n@@ -56,1 +57,1 @@\n-    public TypeDesc type() {\n+    public TypeElement type() {\n@@ -62,2 +63,2 @@\n-        Class<?> refC = refType.resolve(l);\n-        Class<?> typeC = type.resolve(l);\n+        Class<?> refC = resolve(l, refType);\n+        Class<?> typeC = resolve(l, type);\n@@ -75,2 +76,2 @@\n-        Class<?> refC = refType.resolve(l);\n-        Class<?> typeC = type.resolve(l);\n+        Class<?> refC = resolve(l, refType);\n+        Class<?> typeC = resolve(l, type);\n@@ -104,0 +105,9 @@\n+    static Class<?> resolve(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n+        if (t instanceof JavaType jt) {\n+            return jt.resolve(l);\n+        } else {\n+            \/\/ @@@\n+            throw new ReflectiveOperationException();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/FieldDescImpl.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -36,0 +35,2 @@\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n@@ -38,1 +39,1 @@\n-    final TypeDesc refType;\n+    final TypeElement refType;\n@@ -42,1 +43,1 @@\n-    public MethodDescImpl(TypeDesc refType, String name, MethodTypeDesc type) {\n+    public MethodDescImpl(TypeElement refType, String name, MethodTypeDesc type) {\n@@ -49,1 +50,1 @@\n-    public TypeDesc refType() {\n+    public TypeElement refType() {\n@@ -72,0 +73,1 @@\n+        Class<?> refC = resolve(l, refType);\n@@ -73,1 +75,0 @@\n-        Class<?> refC = refType.resolve(l);\n@@ -102,0 +103,9 @@\n+    static Class<?> resolve(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n+        if (t instanceof JavaType jt) {\n+            return jt.resolve(l);\n+        } else {\n+            \/\/ @@@\n+            throw new ReflectiveOperationException();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/MethodDescImpl.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n@@ -35,2 +36,2 @@\n-    final TypeDesc rtype;\n-    final List<TypeDesc> ptypes;\n+    final TypeElement rtype;\n+    final List<TypeElement> ptypes;\n@@ -38,1 +39,1 @@\n-    public MethodTypeDescImpl(TypeDesc rtype, List<TypeDesc> ptypes) {\n+    public MethodTypeDescImpl(TypeElement rtype, List<? extends TypeElement> ptypes) {\n@@ -44,1 +45,1 @@\n-    public TypeDesc returnType() {\n+    public TypeElement returnType() {\n@@ -49,1 +50,1 @@\n-    public List<TypeDesc> parameters() {\n+    public List<TypeElement> parameters() {\n@@ -55,1 +56,1 @@\n-        return ptypes.stream().map(TypeDesc::toString)\n+        return ptypes.stream().map(TypeElement::toString)\n@@ -81,1 +82,7 @@\n-        return new MethodTypeDescImpl(rtype.rawType(), ptypes.stream().map(TypeDesc::rawType).toList());\n+        return new MethodTypeDescImpl(\n+                erase(rtype),\n+                ptypes.stream().map(MethodTypeDescImpl::erase).toList());\n+    }\n+\n+    static TypeElement erase(TypeElement t) {\n+        return t instanceof JavaType j ? j.rawType() : t;\n@@ -87,1 +94,1 @@\n-                .map(TypeDesc::toNominalDescriptorString)\n+                .map(MethodTypeDescImpl::toNominalDescriptorString)\n@@ -89,1 +96,5 @@\n-                rtype.toNominalDescriptorString();\n+                toNominalDescriptorString(rtype);\n+    }\n+\n+    static String toNominalDescriptorString(TypeElement t) {\n+        return t instanceof JavaType j ? j.toNominalDescriptorString() : t.toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/MethodTypeDescImpl.java","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.TypeElement;\n@@ -36,1 +36,1 @@\n-    final TypeDesc recordType;\n+    final TypeElement recordType;\n@@ -39,1 +39,1 @@\n-    public RecordTypeDescImpl(TypeDesc recordType, List<ComponentDesc> components) {\n+    public RecordTypeDescImpl(TypeElement recordType, List<ComponentDesc> components) {\n@@ -45,1 +45,1 @@\n-    public TypeDesc recordType() {\n+    public TypeElement recordType() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/RecordTypeDescImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,213 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.descriptor.impl;\n-\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-public final class TypeDescImpl implements TypeDesc {\n-    \/\/ Fully qualified name\n-    public final String type;\n-\n-    public final int dims;\n-\n-    public final List<TypeDesc> typeArguments;\n-\n-    public TypeDescImpl(String type) {\n-        this(type, 0, List.of());\n-    }\n-\n-    public TypeDescImpl(String type, int dim) {\n-        this(type, dim, List.of());\n-    }\n-\n-    public TypeDescImpl(String type, int dims, List<TypeDesc> typeArguments) {\n-        this.type = type;\n-        this.dims = dims;\n-        this.typeArguments = List.copyOf(typeArguments);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (dims == 0 && typeArguments.isEmpty()) {\n-            return type;\n-        } else if (typeArguments.isEmpty()) {\n-            return type + \"[]\".repeat(dims);\n-        } else {\n-            String params = typeArguments.stream().map(TypeDesc::toString).collect(Collectors.joining(\", \", \"<\", \">\"));\n-            return type + params + \"[]\".repeat(dims);\n-        }\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        TypeDescImpl typeDesc = (TypeDescImpl) o;\n-\n-        if (dims != typeDesc.dims) return false;\n-        if (!type.equals(typeDesc.type)) return false;\n-        return typeArguments.equals(typeDesc.typeArguments);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = type.hashCode();\n-        result = 31 * result + dims;\n-        result = 31 * result + typeArguments.hashCode();\n-        return result;\n-    }\n-\n-    @Override\n-    public boolean isArray() {\n-        return dims != 0;\n-    }\n-\n-    @Override\n-    public int dimensions() {\n-        return dims;\n-    }\n-\n-    @Override\n-    public TypeDesc componentType() {\n-        if (!isArray()) {\n-            return null;\n-        }\n-\n-        return new TypeDescImpl(type, dims - 1, List.of());\n-    }\n-\n-    @Override\n-    public TypeDescImpl rawType() {\n-        return new TypeDescImpl(type, dims);\n-    }\n-\n-    @Override\n-    public boolean hasTypeArguments() {\n-        return !typeArguments.isEmpty();\n-    }\n-\n-    @Override\n-    public List<TypeDesc> typeArguments() {\n-        return typeArguments;\n-    }\n-\n-    \/\/ Conversions\n-\n-    @Override\n-    public TypeDesc toBasicType() {\n-        if (isArray()) {\n-            return TypeDesc.J_L_OBJECT;\n-        }\n-\n-        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n-        if (bytecodeKind == null) {\n-            return TypeDesc.J_L_OBJECT;\n-        } else {\n-            return switch (bytecodeKind) {\n-                case 'V' -> TypeDesc.VOID;\n-                case 'J' -> TypeDesc.LONG;\n-                case 'F' -> TypeDesc.FLOAT;\n-                case 'D' -> TypeDesc.DOUBLE;\n-                default -> TypeDesc.INT;\n-            };\n-        }\n-    }\n-\n-    @Override\n-    public String toClassName() {\n-        if (isArray()) {\n-            throw new IllegalStateException(\"Array type cannot be converted to class name: \" + type);\n-        }\n-\n-        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n-        if (bytecodeKind != null) {\n-            throw new IllegalStateException(\"Invalid class: \" + type);\n-        }\n-\n-        return type;\n-    }\n-\n-    @Override\n-    public String toInternalName() {\n-        if (isArray()) {\n-            throw new IllegalArgumentException(\"Array type cannot be converted to class descriptor\");\n-        }\n-\n-        return toClassDescriptor(type);\n-    }\n-\n-    @Override\n-    public String toNominalDescriptorString() {\n-        if (!isArray()) {\n-            return toBytecodeDescriptor(type);\n-        }\n-\n-        String arraySignature = \"[\".repeat(dims);\n-        return arraySignature + toBytecodeDescriptor(type);\n-    }\n-\n-    static String toBytecodeDescriptor(String type) {\n-        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n-        if (bytecodeKind != null) {\n-            return bytecodeKind.toString();\n-        }\n-\n-        if (type.equals(\"null\")) {\n-            type = Object.class.getName();\n-        }\n-\n-        return \"L\" + type.replace('.', '\/') + \";\";\n-    }\n-\n-    static String toClassDescriptor(String type) {\n-        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n-        if (bytecodeKind != null) {\n-            throw new IllegalArgumentException(\"Primitive type has no class descriptor\");\n-        }\n-\n-        return type.replace('.', '\/');\n-    }\n-\n-    static Map<String, Character> PRIMITIVE_TYPE_MAP;\n-\n-    static {\n-        PRIMITIVE_TYPE_MAP = Map.of(\n-                \"boolean\", 'Z',\n-                \"byte\", 'B',\n-                \"short\", 'S',\n-                \"char\", 'C',\n-                \"int\", 'I',\n-                \"long\", 'J',\n-                \"float\", 'F',\n-                \"double\", 'D',\n-                \"void\", 'V'\n-        );\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/TypeDescImpl.java","additions":0,"deletions":213,"binary":false,"changes":213,"status":"deleted"},{"patch":"@@ -28,11 +28,1 @@\n-import java.lang.reflect.code.op.CoreOps;\n-import java.lang.reflect.code.descriptor.FieldDesc;\n-import java.lang.reflect.code.descriptor.MethodDesc;\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n+import java.lang.invoke.*;\n@@ -42,8 +32,8 @@\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.lang.reflect.code.descriptor.FieldDesc;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.*;\n@@ -184,2 +174,1 @@\n-    record TupleRecord(List<Object> components)\n-            implements CoreOps.Tuple {\n+    record TupleRecord(List<Object> components) {\n@@ -206,3 +195,3 @@\n-                TypeDesc et = args.get(0).type();\n-                if (et.rawType().equals(CoreOps.Var.VAR_TYPE)) {\n-                    et = et.typeArguments().get(0);\n+                TypeElement et = args.get(0).type();\n+                if (et instanceof VarType vt) {\n+                    et = vt.valueType();\n@@ -355,1 +344,1 @@\n-        if (eArg.type().rawType().equals(CoreOps.Var.VAR_TYPE)) {\n+        if (eArg.type() instanceof VarType) {\n@@ -370,2 +359,2 @@\n-            if (co.resultType().equals(TypeDesc.J_L_CLASS)) {\n-                return resolveToClass(l, (TypeDesc) co.value());\n+            if (co.resultType().equals(JavaType.J_L_CLASS)) {\n+                return resolveToClass(l, (JavaType) co.value());\n@@ -414,1 +403,1 @@\n-            TypeDesc nType = no.constructorDescriptor().returnType();\n+            JavaType nType = (JavaType) no.constructorDescriptor().returnType();\n@@ -596,1 +585,1 @@\n-    static Object isInstance(MethodHandles.Lookup l, TypeDesc d, Object v) {\n+    static Object isInstance(MethodHandles.Lookup l, TypeElement d, Object v) {\n@@ -601,1 +590,1 @@\n-    static Object cast(MethodHandles.Lookup l, TypeDesc d, Object v) {\n+    static Object cast(MethodHandles.Lookup l, TypeElement d, Object v) {\n@@ -630,1 +619,1 @@\n-    public static Class<?> resolveToClass(MethodHandles.Lookup l, TypeDesc d) {\n+    public static Class<?> resolveToClass(MethodHandles.Lookup l, TypeElement d) {\n@@ -632,1 +621,5 @@\n-            return d.resolve(l);\n+            if (d instanceof JavaType jt) {\n+                return jt.resolve(l);\n+            } else {\n+                throw new ReflectiveOperationException();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":25,"deletions":32,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -32,12 +32,6 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-\n-import java.lang.reflect.code.descriptor.impl.TypeDescImpl;\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.TupleType;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.VarType;\n+import java.lang.reflect.code.type.impl.JavaTypeImpl;\n+import java.util.*;\n@@ -46,1 +40,0 @@\n-import java.util.stream.Stream;\n@@ -181,2 +174,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -197,1 +190,1 @@\n-        final TypeDesc resultType;\n+        final TypeElement resultType;\n@@ -228,1 +221,1 @@\n-        FuncCallOp(String funcName, TypeDesc resultType, List<Value> args) {\n+        FuncCallOp(String funcName, TypeElement resultType, List<Value> args) {\n@@ -247,1 +240,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -332,2 +325,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -347,1 +340,1 @@\n-        public static final TypeDesc QUOTED_TYPE = new TypeDescImpl(Quoted_CLASS_NAME);\n+        public static final JavaType QUOTED_TYPE = new JavaTypeImpl(Quoted_CLASS_NAME);\n@@ -441,1 +434,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -455,1 +448,1 @@\n-            final TypeDesc functionalInterface;\n+            final TypeElement functionalInterface;\n@@ -457,1 +450,1 @@\n-            Builder(Body.Builder ancestorBody, MethodTypeDesc functionalDescriptor, TypeDesc functionalInterface) {\n+            Builder(Body.Builder ancestorBody, MethodTypeDesc functionalDescriptor, TypeElement functionalInterface) {\n@@ -472,1 +465,1 @@\n-        final TypeDesc functionalInterface;\n+        final TypeElement functionalInterface;\n@@ -494,1 +487,1 @@\n-        LambdaOp(TypeDesc functionalInterface, Body.Builder bodyC) {\n+        LambdaOp(TypeElement functionalInterface, Body.Builder bodyC) {\n@@ -512,1 +505,1 @@\n-        public TypeDesc functionalInterface() {\n+        public TypeElement functionalInterface() {\n@@ -565,1 +558,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -573,1 +566,1 @@\n-    \/\/ @@@: Maybe drop and move the constants elsewhere\n+    \/\/ @@@: Replace with use of FunctionType\n@@ -576,1 +569,1 @@\n-        TypeDesc CLOSURE_TYPE = new TypeDescImpl(CoreOps_CLASS_NAME +\n+        JavaType CLOSURE_TYPE = new JavaTypeImpl(CoreOps_CLASS_NAME +\n@@ -579,2 +572,2 @@\n-        static TypeDesc type(TypeDesc... types) {\n-            return TypeDesc.type(\n+        static JavaType type(JavaType... types) {\n+            return JavaType.type(\n@@ -585,2 +578,2 @@\n-        static TypeDesc type(List<TypeDesc> types) {\n-            return TypeDesc.type(\n+        static JavaType type(List<JavaType> types) {\n+            return JavaType.type(\n@@ -643,4 +636,4 @@\n-        static TypeDesc closureType(MethodTypeDesc functionalDescriptor) {\n-            List<TypeDesc> l = new ArrayList<>();\n-            l.add(functionalDescriptor.returnType());\n-            l.addAll(functionalDescriptor.parameters());\n+        static JavaType closureType(MethodTypeDesc functionalDescriptor) {\n+            List<JavaType> l = new ArrayList<>();\n+            l.add((JavaType) functionalDescriptor.returnType());\n+            l.addAll(functionalDescriptor.parameters().stream().map(t -> (JavaType) t).toList());\n@@ -709,1 +702,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -741,1 +734,1 @@\n-        static TypeDesc resultType(List<Value> args) {\n+        static JavaType resultType(List<Value> args) {\n@@ -746,1 +739,1 @@\n-            TypeDesc t = args.get(0).type();\n+            JavaType t = (JavaType) args.get(0).type();\n@@ -759,1 +752,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -808,2 +801,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -846,2 +839,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -882,2 +875,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -932,2 +925,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -985,2 +978,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -1052,2 +1045,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -1067,1 +1060,1 @@\n-        final TypeDesc type;\n+        final TypeElement type;\n@@ -1079,2 +1072,2 @@\n-        static Object processConstantValue(TypeDesc t, Object value) {\n-            if (t.equals(TypeDesc.BOOLEAN)) {\n+        static Object processConstantValue(TypeElement t, Object value) {\n+            if (t.equals(JavaType.BOOLEAN)) {\n@@ -1086,1 +1079,1 @@\n-            } else if (t.equals(TypeDesc.BYTE)) {\n+            } else if (t.equals(JavaType.BYTE)) {\n@@ -1092,1 +1085,1 @@\n-            } else if (t.equals(TypeDesc.SHORT)) {\n+            } else if (t.equals(JavaType.SHORT)) {\n@@ -1098,1 +1091,1 @@\n-            } else if (t.equals(TypeDesc.CHAR)) {\n+            } else if (t.equals(JavaType.CHAR)) {\n@@ -1104,1 +1097,1 @@\n-            } else if (t.equals(TypeDesc.INT)) {\n+            } else if (t.equals(JavaType.INT)) {\n@@ -1110,1 +1103,1 @@\n-            } else if (t.equals(TypeDesc.LONG)) {\n+            } else if (t.equals(JavaType.LONG)) {\n@@ -1116,1 +1109,1 @@\n-            } else if (t.equals(TypeDesc.FLOAT)) {\n+            } else if (t.equals(JavaType.FLOAT)) {\n@@ -1122,1 +1115,1 @@\n-            } else if (t.equals(TypeDesc.DOUBLE)) {\n+            } else if (t.equals(JavaType.DOUBLE)) {\n@@ -1128,1 +1121,1 @@\n-            } else if (t.equals(TypeDesc.J_L_STRING)) {\n+            } else if (t.equals(JavaType.J_L_STRING)) {\n@@ -1131,2 +1124,2 @@\n-            } else if (t.equals(TypeDesc.J_L_CLASS)) {\n-                return value == NULL_ATTRIBUTE_VALUE ? null : TypeDesc.ofString(value.toString());\n+            } else if (t.equals(JavaType.J_L_CLASS)) {\n+                return value == NULL_ATTRIBUTE_VALUE ? null : JavaType.ofString(value.toString());\n@@ -1159,1 +1152,1 @@\n-        ConstantOp(TypeDesc type, Object value) {\n+        ConstantOp(TypeElement type, Object value) {\n@@ -1178,1 +1171,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -1183,2 +1176,0 @@\n-    \/\/ @@@: Might be useful for pattern matching, but seems unused for now\n-\n@@ -1203,1 +1194,1 @@\n-        final TypeDesc resultType;\n+        final TypeElement resultType;\n@@ -1239,1 +1230,1 @@\n-        InvokeOp(TypeDesc resultType, MethodDesc invokeDescriptor, List<Value> args) {\n+        InvokeOp(TypeElement resultType, MethodDesc invokeDescriptor, List<Value> args) {\n@@ -1262,1 +1253,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -1275,1 +1266,1 @@\n-        final TypeDesc resultType;\n+        final TypeElement resultType;\n@@ -1294,1 +1285,1 @@\n-        ConvOp(TypeDesc resultType, Value arg) {\n+        ConvOp(TypeElement resultType, Value arg) {\n@@ -1301,1 +1292,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -1315,1 +1306,1 @@\n-        final TypeDesc resultType;\n+        final TypeElement resultType;\n@@ -1350,1 +1341,1 @@\n-        NewOp(TypeDesc resultType, MethodTypeDesc constructorDescriptor, List<Value> args) {\n+        NewOp(TypeElement resultType, MethodTypeDesc constructorDescriptor, List<Value> args) {\n@@ -1364,1 +1355,1 @@\n-        public TypeDesc type() {\n+        public TypeElement type() {\n@@ -1373,1 +1364,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -1470,1 +1461,1 @@\n-            public TypeDesc resultType() {\n+            public TypeElement resultType() {\n@@ -1523,2 +1514,2 @@\n-            public TypeDesc resultType() {\n-                return TypeDesc.VOID;\n+            public TypeElement resultType() {\n+                return JavaType.VOID;\n@@ -1555,2 +1546,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.INT;\n+        public TypeElement resultType() {\n+            return JavaType.INT;\n@@ -1593,2 +1584,2 @@\n-        static TypeDesc resultType(Value array, Value v) {\n-            TypeDesc arrayType = array.type();\n+        static TypeElement resultType(Value array, Value v) {\n+            JavaType arrayType = (JavaType) array.type();\n@@ -1600,1 +1591,1 @@\n-            TypeDesc componentType = arrayType.componentType();\n+            TypeElement componentType = arrayType.componentType();\n@@ -1604,1 +1595,1 @@\n-                return TypeDesc.VOID;\n+                return JavaType.VOID;\n@@ -1634,1 +1625,1 @@\n-            public TypeDesc resultType() {\n+            public TypeElement resultType() {\n@@ -1636,1 +1627,2 @@\n-                return array.type().componentType();\n+                JavaType t = (JavaType) array.type();\n+                return t.componentType();\n@@ -1666,2 +1658,2 @@\n-            public TypeDesc resultType() {\n-                return TypeDesc.VOID;\n+            public TypeElement resultType() {\n+                return JavaType.VOID;\n@@ -1681,1 +1673,1 @@\n-        final TypeDesc typeDescriptor;\n+        final TypeElement typeDescriptor;\n@@ -1688,1 +1680,1 @@\n-            TypeDesc typeDescriptor = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n+            TypeElement typeDescriptor = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n@@ -1690,2 +1682,2 @@\n-                        case String s -> TypeDesc.ofString(s);\n-                        case TypeDesc td -> td;\n+                        case String s -> JavaType.ofString(s);\n+                        case JavaType td -> td;\n@@ -1697,1 +1689,1 @@\n-        InstanceOfOp(OpDefinition def, TypeDesc typeDescriptor) {\n+        InstanceOfOp(OpDefinition def, TypeElement typeDescriptor) {\n@@ -1714,1 +1706,1 @@\n-        InstanceOfOp(TypeDesc t, Value v) {\n+        InstanceOfOp(TypeElement t, Value v) {\n@@ -1728,1 +1720,1 @@\n-        public TypeDesc type() {\n+        public TypeElement type() {\n@@ -1733,2 +1725,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.BOOLEAN;\n+        public TypeElement resultType() {\n+            return JavaType.BOOLEAN;\n@@ -1746,2 +1738,2 @@\n-        final TypeDesc resultType;\n-        final TypeDesc typeDescriptor;\n+        final TypeElement resultType;\n+        final TypeElement typeDescriptor;\n@@ -1754,1 +1746,1 @@\n-            TypeDesc type = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n+            TypeElement type = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n@@ -1756,2 +1748,2 @@\n-                        case String s -> TypeDesc.ofString(s);\n-                        case TypeDesc td -> td;\n+                        case String s -> JavaType.ofString(s);\n+                        case JavaType td -> td;\n@@ -1763,1 +1755,1 @@\n-        CastOp(OpDefinition def, TypeDesc typeDescriptor) {\n+        CastOp(OpDefinition def, TypeElement typeDescriptor) {\n@@ -1782,1 +1774,1 @@\n-        CastOp(TypeDesc resultType, TypeDesc t, Value v) {\n+        CastOp(TypeElement resultType, TypeElement t, Value v) {\n@@ -1796,1 +1788,1 @@\n-        public TypeDesc type() {\n+        public TypeElement type() {\n@@ -1801,1 +1793,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -1807,5 +1799,0 @@\n-    \/\/ Synthetic\/hidden type that is the result of a VarOp operation\n-    \/\/ and is an operand of VarLoad and VarStore operation\n-    \/\/ Instances should never leak out when interpreting an expression\n-    \/\/ or executing a compiled (to bytecode) expression\n-\n@@ -1813,1 +1800,2 @@\n-     * A synthetic var type that can model a Java language local variable\n+     * A runtime representation of a variable.\n+     *\n@@ -1815,0 +1803,2 @@\n+     * @@@ Ideally should never be exposed\n+     * @@@ Move to interpreter?\n@@ -1817,5 +1807,0 @@\n-        \/**\n-         * The type descriptor of the var type.\n-         *\/\n-        TypeDesc VAR_TYPE = new TypeDescImpl(\"Var\");\n-\n@@ -1827,8 +1812,0 @@\n-        \/**\n-         * {@return the parameterized type of a var}\n-         * @param type the value's type.\n-         *\/\n-        static TypeDesc type(TypeDesc type) {\n-            return TypeDesc.type(VAR_TYPE, type);\n-        }\n-\n@@ -1908,2 +1885,2 @@\n-        public TypeDesc varType() {\n-            return descriptor().parameters().get(0);\n+        public TypeElement varType() {\n+            return operands().get(0).type();\n@@ -1913,3 +1890,2 @@\n-        public TypeDesc resultType() {\n-            TypeDesc valueType = operands().get(0).type();\n-            return Var.type(valueType);\n+        public TypeElement resultType() {\n+            return VarType.varType(varType());\n@@ -1941,2 +1917,2 @@\n-            if (!varValue.type().rawType().equals(Var.VAR_TYPE)) {\n-                throw new IllegalArgumentException(\"Value is of type Var: \" + varValue);\n+            if (!(varValue.type() instanceof VarType)) {\n+                throw new IllegalArgumentException(\"Value's type is not a variable type: \" + varValue);\n@@ -1981,16 +1957,0 @@\n-            static TypeDesc getresultType(Value varValue) {\n-                TypeDesc varType = varValue.type();\n-\n-                if (!varType.rawType().equals(Var.VAR_TYPE)) {\n-                    throw new IllegalArgumentException(\n-                            \"Var value type is not of the Var type: \" + varType);\n-                }\n-\n-                if (!varType.hasTypeArguments()) {\n-                    throw new IllegalArgumentException(\n-                            \"Var value type is not parameterized with its value types: \" + varType);\n-                }\n-\n-                return varType.typeArguments().get(0);\n-            }\n-\n@@ -1998,2 +1958,3 @@\n-            public TypeDesc resultType() {\n-                return getresultType(operands().get(0));\n+            public TypeElement resultType() {\n+                VarType vt = (VarType) operands().get(0).type();\n+                return vt.valueType();\n@@ -2039,16 +2000,0 @@\n-            static TypeDesc getresultType(Value varValue) {\n-                TypeDesc varType = varValue.type();\n-\n-                if (!varType.rawType().equals(Var.VAR_TYPE)) {\n-                    throw new IllegalArgumentException(\n-                            \"Var value type is not of the Var type: \" + varType);\n-                }\n-\n-                if (!varType.hasTypeArguments()) {\n-                    throw new IllegalArgumentException(\n-                            \"Var value type is not parameterized with its value types: \" + varType);\n-                }\n-\n-                return TypeDesc.VOID;\n-            }\n-\n@@ -2056,2 +2001,2 @@\n-            public TypeDesc resultType() {\n-                return getresultType(operands().get(0));\n+            public TypeElement resultType() {\n+                return operands().get(0).type();\n@@ -2062,30 +2007,0 @@\n-    \/\/ Synthetic\/hidden type that is the result of a TupleOp operation\n-\n-    \/**\n-     * A synthetic tuple type.\n-     *\/\n-    public interface Tuple {\n-        TypeDesc TUPLE_TYPE = new TypeDescImpl(CoreOps_CLASS_NAME +\n-                \"$\" + Tuple.class.getSimpleName());\n-\n-        static TypeDesc typeFromValues(Value... values) {\n-            return type(Stream.of(values).map(Value::type).toArray(TypeDesc[]::new));\n-        }\n-\n-        static TypeDesc typeFromValues(List<? extends Value> values) {\n-            return type(values.stream().map(Value::type).toArray(TypeDesc[]::new));\n-        }\n-\n-        static TypeDesc type(TypeDesc... types) {\n-            return TypeDesc.type(\n-                    TUPLE_TYPE,\n-                    types);\n-        }\n-\n-        static TypeDesc type(List<TypeDesc> types) {\n-            return TypeDesc.type(\n-                    TUPLE_TYPE,\n-                    types);\n-        }\n-    }\n-\n@@ -2119,2 +2034,2 @@\n-        public TypeDesc resultType() {\n-            return Tuple.typeFromValues(operands());\n+        public TypeElement resultType() {\n+            return TupleType.tupleTypeFromValues(operands());\n@@ -2176,22 +2091,0 @@\n-        static TypeDesc getresultType(Value tupleValue, int index) {\n-            TypeDesc tupleType = tupleValue.type();\n-\n-            if (!tupleType.rawType().equals(Tuple.TUPLE_TYPE)) {\n-                throw new IllegalArgumentException(\n-                        \"Tuple value type is not of the Tuple type: \" + tupleType);\n-            }\n-\n-            if (!tupleType.hasTypeArguments()) {\n-                throw new IllegalArgumentException(\n-                        \"Tuple value type is not parameterized with component types: \" + tupleType);\n-            }\n-\n-            List<TypeDesc> tupleComponentTypes = tupleType.typeArguments();\n-            if (index < 0 || index >= tupleComponentTypes.size()) {\n-                throw new IllegalArgumentException(\n-                        \"Tuple component index out of range:: \" + index);\n-            }\n-\n-            return tupleComponentTypes.get(index);\n-        }\n-\n@@ -2210,1 +2103,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -2212,1 +2105,2 @@\n-            return tupleValue.type().typeArguments().get(index);\n+            TupleType t = (TupleType) tupleValue.type();\n+            return t.componentTypes().get(index);\n@@ -2265,0 +2159,1 @@\n+            \/\/ @@@ Validate tuple type and index\n@@ -2268,23 +2163,0 @@\n-        static TypeDesc getresultType(Value tupleValue, int index, Value value) {\n-            TypeDesc tupleType = tupleValue.type();\n-\n-            if (!tupleType.rawType().equals(Tuple.TUPLE_TYPE)) {\n-                throw new IllegalArgumentException(\n-                        \"Tuple value type is not of the Tuple type: \" + tupleType);\n-            }\n-\n-            if (!tupleType.hasTypeArguments()) {\n-                throw new IllegalArgumentException(\n-                        \"Tuple value type is not parameterized with component types: \" + tupleType);\n-            }\n-\n-            List<TypeDesc> tupleComponentTypes = new ArrayList<>(tupleType.typeArguments());\n-            if (index < 0 || index >= tupleComponentTypes.size()) {\n-                throw new IllegalArgumentException(\n-                        \"Tuple component index out of range:: \" + index);\n-            }\n-\n-            tupleComponentTypes.set(index, value.type());\n-            return Tuple.type(tupleComponentTypes);\n-        }\n-\n@@ -2303,1 +2175,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -2305,0 +2177,1 @@\n+            TupleType tupleType = (TupleType) tupleValue.type();\n@@ -2306,1 +2179,4 @@\n-            return getresultType(tupleValue, index, value);\n+\n+            List<TypeElement> tupleComponentTypes = new ArrayList<>(tupleType.componentTypes());\n+            tupleComponentTypes.set(index, value.type());\n+            return TupleType.tupleType(tupleComponentTypes);\n@@ -2318,1 +2194,1 @@\n-    \/\/ @@@: Maybe drop and move the constants elsewhere\n+    \/\/ @@@: Create as new type element\n@@ -2320,1 +2196,1 @@\n-        TypeDesc EXCEPTION_REGION_TYPE = new TypeDescImpl(\"ExceptionRegion\");\n+        TypeElement EXCEPTION_REGION_TYPE = new JavaTypeImpl(\"ExceptionRegion\");\n@@ -2381,1 +2257,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -2453,2 +2329,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -2524,1 +2400,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -2550,1 +2426,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -2597,2 +2473,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.BOOLEAN;\n+        public TypeElement resultType() {\n+            return JavaType.BOOLEAN;\n@@ -2747,1 +2623,1 @@\n-        NegOp(TypeDesc resultType, Value v) {\n+        NegOp(Value v) {\n@@ -3051,1 +2927,1 @@\n-                                          MethodTypeDesc functionalDescriptor, TypeDesc functionalInterface) {\n+                                          MethodTypeDesc functionalDescriptor, TypeElement functionalInterface) {\n@@ -3061,1 +2937,1 @@\n-    public static LambdaOp lambda(TypeDesc functionalInterface, Body.Builder body) {\n+    public static LambdaOp lambda(TypeElement functionalInterface, Body.Builder body) {\n@@ -3216,1 +3092,1 @@\n-    public static ConstantOp constant(TypeDesc type, Object value) {\n+    public static ConstantOp constant(TypeElement type, Object value) {\n@@ -3250,1 +3126,1 @@\n-    public static InvokeOp invoke(TypeDesc returnType, MethodDesc invokeDescriptor, Value... args) {\n+    public static InvokeOp invoke(TypeElement returnType, MethodDesc invokeDescriptor, Value... args) {\n@@ -3262,1 +3138,1 @@\n-    public static InvokeOp invoke(TypeDesc returnType, MethodDesc invokeDescriptor, List<Value> args) {\n+    public static InvokeOp invoke(TypeElement returnType, MethodDesc invokeDescriptor, List<Value> args) {\n@@ -3273,1 +3149,1 @@\n-    public static ConvOp conv(TypeDesc to, Value from) {\n+    public static ConvOp conv(TypeElement to, Value from) {\n@@ -3307,1 +3183,1 @@\n-    public static NewOp _new(TypeDesc returnType, MethodTypeDesc constructorDescriptor,\n+    public static NewOp _new(TypeElement returnType, MethodTypeDesc constructorDescriptor,\n@@ -3320,1 +3196,1 @@\n-    public static NewOp _new(TypeDesc returnType, MethodTypeDesc constructorDescriptor,\n+    public static NewOp _new(TypeElement returnType, MethodTypeDesc constructorDescriptor,\n@@ -3332,2 +3208,2 @@\n-    public static NewOp newArray(TypeDesc arrayType, Value length) {\n-        return _new(MethodTypeDesc.methodType(arrayType, TypeDesc.INT), length);\n+    public static NewOp newArray(TypeElement arrayType, Value length) {\n+        return _new(MethodTypeDesc.methodType(arrayType, JavaType.INT), length);\n@@ -3421,1 +3297,1 @@\n-    public static InstanceOfOp instanceOf(TypeDesc t, Value v) {\n+    public static InstanceOfOp instanceOf(TypeElement t, Value v) {\n@@ -3432,2 +3308,2 @@\n-    public static CastOp cast(TypeDesc resultType, Value v) {\n-        return new CastOp(resultType, resultType.rawType(), v);\n+    public static CastOp cast(TypeElement resultType, Value v) {\n+        return new CastOp(resultType, resultType, v);\n@@ -3444,1 +3320,1 @@\n-    public static CastOp cast(TypeDesc resultType, TypeDesc t, Value v) {\n+    public static CastOp cast(TypeElement resultType, JavaType t, Value v) {\n@@ -3598,12 +3474,1 @@\n-        return neg(v.type(), v);\n-    }\n-\n-    \/**\n-     * Creates a neg operation.\n-     *\n-     * @param resultType the operation's result type\n-     * @param v the operand\n-     * @return the neg operation\n-     *\/\n-    public static UnaryOp neg(TypeDesc resultType, Value v) {\n-        return new NegOp(resultType, v);\n+        return new NegOp(v);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":156,"deletions":291,"binary":false,"changes":447,"status":"modified"},{"patch":"@@ -32,2 +32,5 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-import java.lang.reflect.code.descriptor.impl.TypeDescImpl;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.TupleType;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.VarType;\n+import java.lang.reflect.code.type.impl.JavaTypeImpl;\n@@ -40,15 +43,1 @@\n-import static java.lang.reflect.code.op.CoreOps.Tuple;\n-import static java.lang.reflect.code.op.CoreOps.YieldOp;\n-import static java.lang.reflect.code.op.CoreOps._throw;\n-import static java.lang.reflect.code.op.CoreOps._yield;\n-import static java.lang.reflect.code.op.CoreOps.add;\n-import static java.lang.reflect.code.op.CoreOps.arrayLength;\n-import static java.lang.reflect.code.op.CoreOps.arrayLoadOp;\n-import static java.lang.reflect.code.op.CoreOps.branch;\n-import static java.lang.reflect.code.op.CoreOps.invoke;\n-import static java.lang.reflect.code.op.CoreOps.conditionalBranch;\n-import static java.lang.reflect.code.op.CoreOps.constant;\n-import static java.lang.reflect.code.op.CoreOps.exceptionRegionEnter;\n-import static java.lang.reflect.code.op.CoreOps.exceptionRegionExit;\n-import static java.lang.reflect.code.op.CoreOps.lt;\n-import static java.lang.reflect.code.descriptor.TypeDesc.*;\n+import static java.lang.reflect.code.op.CoreOps.*;\n@@ -165,2 +154,2 @@\n-        public TypeDesc resultType() {\n-            return TypeDesc.VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -291,2 +280,2 @@\n-        public TypeDesc resultType() {\n-            return VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -333,1 +322,1 @@\n-            if (!body.descriptor().returnType().equals(VOID)) {\n+            if (!body.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -373,2 +362,2 @@\n-        public TypeDesc resultType() {\n-            return VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -413,1 +402,1 @@\n-            if (!body.descriptor().returnType().equals(VOID)) {\n+            if (!body.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -464,2 +453,2 @@\n-        public TypeDesc resultType() {\n-            return VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -475,1 +464,1 @@\n-        static final MethodTypeDesc PREDICATE_TYPE = MethodTypeDesc.methodType(BOOLEAN);\n+        static final MethodTypeDesc PREDICATE_TYPE = MethodTypeDesc.methodType(JavaType.BOOLEAN);\n@@ -611,1 +600,1 @@\n-                    if (!fromPred.descriptor().equals(MethodTypeDesc.methodType(BOOLEAN))) {\n+                    if (!fromPred.descriptor().equals(MethodTypeDesc.methodType(JavaType.BOOLEAN))) {\n@@ -689,2 +678,2 @@\n-        public TypeDesc resultType() {\n-            return VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -701,1 +690,1 @@\n-        final TypeDesc resultType;\n+        final TypeElement resultType;\n@@ -731,1 +720,1 @@\n-        JavaSwitchExpressionOp(TypeDesc resultType, Value target, List<Body.Builder> bodyCs) {\n+        JavaSwitchExpressionOp(TypeElement resultType, Value target, List<Body.Builder> bodyCs) {\n@@ -755,1 +744,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -786,2 +775,2 @@\n-        public TypeDesc resultType() {\n-            return VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -799,1 +788,1 @@\n-            final List<TypeDesc> initTypes;\n+            final List<? extends TypeElement> initTypes;\n@@ -802,1 +791,1 @@\n-                        List<TypeDesc> initTypes) {\n+                        List<? extends TypeElement> initTypes) {\n@@ -804,1 +793,1 @@\n-                this.initTypes = initTypes.stream().map(CoreOps.Var::type).toList();\n+                this.initTypes = initTypes.stream().map(VarType::varType).toList();\n@@ -809,1 +798,1 @@\n-                        MethodTypeDesc.methodType(Tuple.type(initTypes)));\n+                        MethodTypeDesc.methodType(TupleType.tupleType(initTypes)));\n@@ -818,1 +807,1 @@\n-            final List<TypeDesc> initTypes;\n+            final List<? extends TypeElement> initTypes;\n@@ -822,1 +811,1 @@\n-                               List<TypeDesc> initTypes,\n+                               List<? extends TypeElement> initTypes,\n@@ -831,1 +820,1 @@\n-                        MethodTypeDesc.methodType(BOOLEAN, initTypes));\n+                        MethodTypeDesc.methodType(JavaType.BOOLEAN, initTypes));\n@@ -840,1 +829,1 @@\n-            final List<TypeDesc> initTypes;\n+            final List<? extends TypeElement> initTypes;\n@@ -845,1 +834,1 @@\n-                                 List<TypeDesc> initTypes,\n+                                 List<? extends TypeElement> initTypes,\n@@ -855,1 +844,1 @@\n-                        MethodTypeDesc.methodType(VOID, initTypes));\n+                        MethodTypeDesc.methodType(JavaType.VOID, initTypes));\n@@ -865,1 +854,1 @@\n-            final List<TypeDesc> initTypes;\n+            final List<? extends TypeElement> initTypes;\n@@ -871,1 +860,1 @@\n-                               List<TypeDesc> initTypes,\n+                               List<? extends TypeElement> initTypes,\n@@ -882,1 +871,1 @@\n-                        MethodTypeDesc.methodType(VOID, initTypes));\n+                        MethodTypeDesc.methodType(JavaType.VOID, initTypes));\n@@ -934,1 +923,1 @@\n-            if (!update.descriptor().returnType().equals(VOID)) {\n+            if (!update.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -939,1 +928,1 @@\n-            if (!body.descriptor().returnType().equals(VOID)) {\n+            if (!body.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -1045,2 +1034,2 @@\n-        public TypeDesc resultType() {\n-            return VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -1058,2 +1047,2 @@\n-            final TypeDesc iterableType;\n-            final TypeDesc elementType;\n+            final TypeElement iterableType;\n+            final TypeElement elementType;\n@@ -1062,1 +1051,1 @@\n-                              TypeDesc iterableType, TypeDesc elementType) {\n+                              TypeElement iterableType, TypeElement elementType) {\n@@ -1079,1 +1068,1 @@\n-            final TypeDesc elementType;\n+            final TypeElement elementType;\n@@ -1083,1 +1072,1 @@\n-                              TypeDesc elementType, Body.Builder expression) {\n+                              TypeElement elementType, Body.Builder expression) {\n@@ -1093,1 +1082,1 @@\n-            public BodyBuilder definition(TypeDesc bodyElementType, Consumer<Block.Builder> c) {\n+            public BodyBuilder definition(TypeElement bodyElementType, Consumer<Block.Builder> c) {\n@@ -1104,1 +1093,1 @@\n-            final TypeDesc elementType;\n+            final TypeElement elementType;\n@@ -1109,1 +1098,1 @@\n-                        TypeDesc elementType, Body.Builder expression, Body.Builder definition) {\n+                        TypeElement elementType, Body.Builder expression, Body.Builder definition) {\n@@ -1118,1 +1107,1 @@\n-                        MethodTypeDesc.methodType(VOID, elementType));\n+                        MethodTypeDesc.methodType(JavaType.VOID, elementType));\n@@ -1160,1 +1149,1 @@\n-            if (expression.descriptor().returnType().equals(VOID)) {\n+            if (expression.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -1168,1 +1157,1 @@\n-            if (init.descriptor().returnType().equals(VOID)) {\n+            if (init.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -1176,1 +1165,1 @@\n-            if (!body.descriptor().returnType().equals(VOID)) {\n+            if (!body.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -1208,2 +1197,2 @@\n-            TypeDesc elementType = init.entryBlock().parameters().get(0).type();\n-            boolean isArray = expression.descriptor().returnType().isArray();\n+            JavaType elementType = (JavaType) init.entryBlock().parameters().get(0).type();\n+            boolean isArray = ((JavaType) expression.descriptor().returnType()).isArray();\n@@ -1212,1 +1201,1 @@\n-            Block.Builder header = b.block(isArray ? List.of(TypeDesc.INT) : List.of());\n+            Block.Builder header = b.block(isArray ? List.of(JavaType.INT) : List.of());\n@@ -1231,1 +1220,1 @@\n-                Value i = preHeader.op(constant(TypeDesc.INT, 0));\n+                Value i = preHeader.op(constant(JavaType.INT, 0));\n@@ -1265,1 +1254,1 @@\n-                i = update.op(add(i, update.op(constant(TypeDesc.INT, 1))));\n+                i = update.op(add(i, update.op(constant(JavaType.INT, 1))));\n@@ -1268,1 +1257,1 @@\n-                TypeDesc iterable = TypeDesc.type(TypeDesc.type(Iterator.class), elementType);\n+                JavaType iterable = JavaType.type(JavaType.type(Iterator.class), elementType);\n@@ -1305,2 +1294,2 @@\n-        public TypeDesc resultType() {\n-            return VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -1324,1 +1313,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -1374,1 +1363,1 @@\n-            if (!bodies.get(0).descriptor().equals(MethodTypeDesc.methodType(BOOLEAN))) {\n+            if (!bodies.get(0).descriptor().equals(MethodTypeDesc.methodType(JavaType.BOOLEAN))) {\n@@ -1376,1 +1365,1 @@\n-                        \"Predicate body descriptor should be \" + MethodTypeDesc.methodType(BOOLEAN) +\n+                        \"Predicate body descriptor should be \" + MethodTypeDesc.methodType(JavaType.BOOLEAN) +\n@@ -1381,1 +1370,1 @@\n-                        \"Body descriptor should be \" + MethodTypeDesc.methodType(VOID) +\n+                        \"Body descriptor should be \" + MethodTypeDesc.methodType(JavaType.VOID) +\n@@ -1449,2 +1438,2 @@\n-        public TypeDesc resultType() {\n-            return VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -1471,1 +1460,1 @@\n-                Body.Builder predicate = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(BOOLEAN));\n+                Body.Builder predicate = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -1520,1 +1509,1 @@\n-                        \"Body descriptor should be \" + MethodTypeDesc.methodType(VOID) +\n+                        \"Body descriptor should be \" + MethodTypeDesc.methodType(JavaType.VOID) +\n@@ -1523,1 +1512,1 @@\n-            if (!bodies.get(1).descriptor().equals(MethodTypeDesc.methodType(BOOLEAN))) {\n+            if (!bodies.get(1).descriptor().equals(MethodTypeDesc.methodType(JavaType.BOOLEAN))) {\n@@ -1525,1 +1514,1 @@\n-                        \"Predicate body descriptor should be \" + MethodTypeDesc.methodType(BOOLEAN) +\n+                        \"Predicate body descriptor should be \" + MethodTypeDesc.methodType(JavaType.BOOLEAN) +\n@@ -1593,2 +1582,2 @@\n-        public TypeDesc resultType() {\n-            return VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -1632,1 +1621,1 @@\n-                if (!b.descriptor().equals(MethodTypeDesc.methodType(BOOLEAN))) {\n+                if (!b.descriptor().equals(MethodTypeDesc.methodType(JavaType.BOOLEAN))) {\n@@ -1647,1 +1636,1 @@\n-            TypeDesc oprType = cop.result().type();\n+            TypeElement oprType = cop.result().type();\n@@ -1705,2 +1694,2 @@\n-        public TypeDesc resultType() {\n-            return BOOLEAN;\n+        public TypeElement resultType() {\n+            return JavaType.BOOLEAN;\n@@ -1728,1 +1717,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -1783,1 +1772,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -1828,1 +1817,1 @@\n-        final TypeDesc resultType;\n+        final TypeElement resultType;\n@@ -1859,1 +1848,1 @@\n-        JavaConditionalExpressionOp(TypeDesc expressionType, List<Body.Builder> bodyCs) {\n+        JavaConditionalExpressionOp(TypeElement expressionType, List<Body.Builder> bodyCs) {\n@@ -1871,1 +1860,1 @@\n-            if (!cond.descriptor().equals(MethodTypeDesc.methodType(BOOLEAN))) {\n+            if (!cond.descriptor().equals(MethodTypeDesc.methodType(JavaType.BOOLEAN))) {\n@@ -1920,1 +1909,1 @@\n-        public TypeDesc resultType() {\n+        public TypeElement resultType() {\n@@ -1933,1 +1922,1 @@\n-            final List<TypeDesc> resourceTypes;\n+            final List<? extends TypeElement> resourceTypes;\n@@ -1936,1 +1925,1 @@\n-            BodyBuilder(Body.Builder ancestorBody, List<TypeDesc> resourceTypes, Body.Builder resources) {\n+            BodyBuilder(Body.Builder ancestorBody, List<? extends TypeElement> resourceTypes, Body.Builder resources) {\n@@ -1943,1 +1932,2 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(VOID, resourceTypes));\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        MethodTypeDesc.methodType(JavaType.VOID, resourceTypes));\n@@ -1964,1 +1954,1 @@\n-            public CatchBuilder _catch(TypeDesc exceptionType, Consumer<Block.Builder> c) {\n+            public CatchBuilder _catch(TypeElement exceptionType, Consumer<Block.Builder> c) {\n@@ -1966,1 +1956,1 @@\n-                        MethodTypeDesc.methodType(TypeDesc.VOID, exceptionType));\n+                        MethodTypeDesc.methodType(JavaType.VOID, exceptionType));\n@@ -2001,1 +1991,1 @@\n-            if (first.descriptor().returnType().equals(VOID)) {\n+            if (first.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -2052,1 +2042,1 @@\n-                if (resources.descriptor().returnType().equals(VOID)) {\n+                if (resources.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -2063,1 +2053,1 @@\n-            if (!body.descriptor().returnType().equals(VOID)) {\n+            if (!body.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -2069,1 +2059,1 @@\n-                if (!_catch.descriptor().returnType().equals(VOID)) {\n+                if (!_catch.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -2079,1 +2069,1 @@\n-                if (!finalizer.descriptor().returnType().equals(VOID)) {\n+                if (!finalizer.descriptor().returnType().equals(JavaType.VOID)) {\n@@ -2303,1 +2293,1 @@\n-                Block.Parameter t = catcherFinally.parameter(TypeDesc.type(Throwable.class));\n+                Block.Parameter t = catcherFinally.parameter(JavaType.type(Throwable.class));\n@@ -2362,2 +2352,2 @@\n-        public TypeDesc resultType() {\n-            return VOID;\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n@@ -2376,0 +2366,1 @@\n+     * \/\/ @@@ Replace with types extending from TypeElement\n@@ -2399,1 +2390,3 @@\n-        TypeDesc PATTERN_BINDING_TYPE = new TypeDescImpl(Pattern_CLASS_NAME +\n+        \/\/ @@@ Pattern types\n+\n+        JavaType PATTERN_BINDING_TYPE = new JavaTypeImpl(Pattern_CLASS_NAME +\n@@ -2401,1 +2394,1 @@\n-        TypeDesc PATTERN_RECORD_TYPE = new TypeDescImpl(Pattern_CLASS_NAME +\n+        JavaType PATTERN_RECORD_TYPE = new JavaTypeImpl(Pattern_CLASS_NAME +\n@@ -2404,2 +2397,2 @@\n-        static TypeDesc bindingType(TypeDesc t) {\n-            return TypeDesc.type(PATTERN_BINDING_TYPE, t);\n+        static JavaType bindingType(TypeElement t) {\n+            return JavaType.type(PATTERN_BINDING_TYPE, (JavaType) t);\n@@ -2408,2 +2401,2 @@\n-        static TypeDesc recordType(TypeDesc t) {\n-            return TypeDesc.type(PATTERN_RECORD_TYPE, t);\n+        static JavaType recordType(TypeElement t) {\n+            return JavaType.type(PATTERN_RECORD_TYPE, (JavaType) t);\n@@ -2412,2 +2405,2 @@\n-        static TypeDesc targetType(TypeDesc t) {\n-            return t.typeArguments().get(0);\n+        static TypeElement targetType(TypeElement t) {\n+            return ((JavaType) t).typeArguments().get(0);\n@@ -2450,1 +2443,1 @@\n-            final TypeDesc resultType;\n+            final TypeElement resultType;\n@@ -2481,1 +2474,1 @@\n-            BindingPatternOp(TypeDesc targetType, String bindingName) {\n+            BindingPatternOp(TypeElement targetType, String bindingName) {\n@@ -2499,1 +2492,1 @@\n-            public TypeDesc targetType() {\n+            public TypeElement targetType() {\n@@ -2504,1 +2497,1 @@\n-            public TypeDesc resultType() {\n+            public TypeElement resultType() {\n@@ -2567,1 +2560,1 @@\n-            public TypeDesc targetType() {\n+            public TypeElement targetType() {\n@@ -2572,1 +2565,1 @@\n-            public TypeDesc resultType() {\n+            public TypeElement resultType() {\n@@ -2655,1 +2648,1 @@\n-                        endNoMatchBlock.op(constant(BOOLEAN, false)))));\n+                        endNoMatchBlock.op(constant(JavaType.BOOLEAN, false)))));\n@@ -2662,1 +2655,1 @@\n-                                block.op(constant(BOOLEAN, true)))));\n+                                block.op(constant(JavaType.BOOLEAN, true)))));\n@@ -2690,1 +2683,1 @@\n-                TypeDesc targetType = rpOp.targetType();\n+                TypeElement targetType = rpOp.targetType();\n@@ -2718,1 +2711,1 @@\n-                TypeDesc targetType = bpOp.targetType();\n+                TypeElement targetType = bpOp.targetType();\n@@ -2735,2 +2728,2 @@\n-            public TypeDesc resultType() {\n-                return BOOLEAN;\n+            public TypeElement resultType() {\n+                return JavaType.BOOLEAN;\n@@ -2861,1 +2854,2 @@\n-    public static JavaSwitchExpressionOp switchExpression(TypeDesc resultType, Value target, List<Body.Builder> bodies) {\n+    public static JavaSwitchExpressionOp switchExpression(TypeElement resultType, Value target,\n+                                                          List<Body.Builder> bodies) {\n@@ -2881,1 +2875,1 @@\n-    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, TypeDesc... initTypes) {\n+    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, TypeElement... initTypes) {\n@@ -2892,1 +2886,1 @@\n-    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, List<TypeDesc> initTypes) {\n+    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, List<? extends TypeElement> initTypes) {\n@@ -2925,1 +2919,1 @@\n-                                                                  TypeDesc iterableType, TypeDesc elementType) {\n+                                                                  TypeElement iterableType, TypeElement elementType) {\n@@ -3040,1 +3034,2 @@\n-    public static JavaConditionalExpressionOp conditionalExpression(TypeDesc expressionType, List<Body.Builder> bodies) {\n+    public static JavaConditionalExpressionOp conditionalExpression(TypeElement expressionType,\n+                                                                    List<Body.Builder> bodies) {\n@@ -3077,2 +3072,3 @@\n-                                                         List<TypeDesc> resourceTypes, Consumer<Block.Builder> c) {\n-        resourceTypes = resourceTypes.stream().map(CoreOps.Var::type).toList();\n+                                                         List<? extends TypeElement> resourceTypes,\n+                                                         Consumer<Block.Builder> c) {\n+        resourceTypes = resourceTypes.stream().map(VarType::varType).toList();\n@@ -3080,1 +3076,1 @@\n-                MethodTypeDesc.methodType(Tuple.type(resourceTypes)));\n+                MethodTypeDesc.methodType(TupleType.tupleType(resourceTypes)));\n@@ -3127,1 +3123,1 @@\n-    public static PatternOps.BindingPatternOp bindingPattern(TypeDesc type, String bindingName) {\n+    public static PatternOps.BindingPatternOp bindingPattern(TypeElement type, String bindingName) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":133,"deletions":137,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.TypeElement;\n@@ -36,1 +36,1 @@\n- * An operation in generic form that is utilized to construct a concrete subclass of {@code Op},\n+ * An operation in general form that is utilized to construct a concrete subclass of {@link Op},\n@@ -51,1 +51,1 @@\n-                           TypeDesc resultType,\n+                           TypeElement resultType,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpDefinition.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpWithDefinition.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,3 +33,2 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-import java.lang.reflect.code.op.CoreOps;\n-import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.lang.reflect.code.op.*;\n@@ -37,2 +36,0 @@\n-import java.lang.reflect.code.op.OpDefinition;\n-import java.lang.reflect.code.op.OpFactory;\n@@ -44,0 +41,2 @@\n+import java.lang.reflect.code.type.CoreTypeFactory;\n+import java.lang.reflect.code.type.TypeElementFactory;\n@@ -138,0 +137,4 @@\n+        return fromStream(opFactory, CoreTypeFactory.CORE_TYPE_FACTORY, in);\n+    }\n+\n+    public static List<Op> fromStream(OpFactory opFactory, TypeElementFactory typeFactory, InputStream in) throws IOException {\n@@ -139,1 +142,1 @@\n-        return fromString(opFactory, s);\n+        return fromString(opFactory, typeFactory, s);\n@@ -150,1 +153,5 @@\n-        return parse(opFactory, in);\n+        return parse(opFactory, CoreTypeFactory.CORE_TYPE_FACTORY, in);\n+    }\n+\n+    public static List<Op> fromString(OpFactory opFactory, TypeElementFactory typeFactory, String in) {\n+        return parse(opFactory, typeFactory, in);\n@@ -167,1 +174,1 @@\n-    static List<Op> parse(OpFactory opFactory, String in) {\n+    static List<Op> parse(OpFactory opFactory, TypeElementFactory typeFactory, String in) {\n@@ -171,1 +178,1 @@\n-        List<OpNode> opNodes = new OpParser(opFactory, lexer).parseNodes();\n+        List<OpNode> opNodes = new OpParser(lexer).parseNodes();\n@@ -173,2 +180,2 @@\n-        Context c = new Context(opFactory);\n-        return opNodes.stream().map(n -> nodeToOp(n, TypeDesc.VOID, c, null)).toList();\n+        Context c = new Context(opFactory, typeFactory);\n+        return opNodes.stream().map(n -> nodeToOp(n, TypeDefinition.VOID, c, null)).toList();\n@@ -181,0 +188,1 @@\n+        final TypeElementFactory typeFactory;\n@@ -187,0 +195,1 @@\n+            this.typeFactory = that.typeFactory;\n@@ -191,1 +200,1 @@\n-        Context(OpFactory opFactory) {\n+        Context(OpFactory opFactory, TypeElementFactory typeFactory) {\n@@ -194,0 +203,1 @@\n+            this.typeFactory = typeFactory;\n@@ -231,1 +241,1 @@\n-    static Op nodeToOp(OpNode opNode, TypeDesc rtype, Context c, Body.Builder ancestorBody) {\n+    static Op nodeToOp(OpNode opNode, TypeDefinition rtype, Context c, Body.Builder ancestorBody) {\n@@ -236,1 +246,1 @@\n-    static OpDefinition nodeToOpDef(OpNode opNode, TypeDesc rtype, Context c, Body.Builder ancestorBody) {\n+    static OpDefinition nodeToOpDef(OpNode opNode, TypeDefinition rtype, Context c, Body.Builder ancestorBody) {\n@@ -246,1 +256,1 @@\n-                rtype,\n+                c.typeFactory.constructType(rtype),\n@@ -254,1 +264,1 @@\n-                MethodTypeDesc.methodType(n.rtype));\n+                MethodTypeDesc.methodType(c.typeFactory.constructType(n.rtype)));\n@@ -269,1 +279,1 @@\n-                Block.Parameter v = b.parameter(a.type);\n+                Block.Parameter v = b.parameter(c.typeFactory.constructType(a.type));\n@@ -290,1 +300,1 @@\n-                    b.op(nodeToOp(on, TypeDesc.VOID, c, body));\n+                    b.op(nodeToOp(on, TypeDefinition.VOID, c, body));\n@@ -316,1 +326,1 @@\n-    record BodyNode(TypeDesc rtype,\n+    record BodyNode(TypeDefinition rtype,\n@@ -326,1 +336,1 @@\n-                     TypeDesc type) {\n+                     TypeDefinition type) {\n@@ -329,1 +339,0 @@\n-    final OpFactory opFactory;\n@@ -332,2 +341,1 @@\n-    OpParser(OpFactory opFactory, Lexer lexer) {\n-        this.opFactory = opFactory;\n+    OpParser(Lexer lexer) {\n@@ -510,1 +518,1 @@\n-        TypeDesc rtype = parseTypeDesc();\n+        TypeDefinition rtype = parseTypeDesc();\n@@ -548,1 +556,1 @@\n-        TypeDesc type = parseTypeDesc();\n+        TypeDefinition type = parseTypeDesc();\n@@ -595,1 +603,1 @@\n-    TypeDesc parseTypeDesc() {\n+    TypeDefinition parseTypeDesc() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/OpParser.java","additions":34,"deletions":26,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+import java.lang.reflect.code.type.CoreTypeFactory;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.lang.reflect.code.type.impl.TypeDefinitionImpl;\n@@ -41,1 +45,1 @@\n-    public static TypeDesc parseTypeDesc(String desc) {\n+    public static TypeDefinition parseTypeDesc(String desc) {\n@@ -94,1 +98,1 @@\n-    public static TypeDesc parseTypeDesc(Lexer l) {\n+    public static TypeDefinition parseTypeDesc(Lexer l) {\n@@ -108,1 +112,1 @@\n-        List<TypeDesc> ptypes;\n+        List<TypeDefinition> ptypes;\n@@ -113,1 +117,1 @@\n-                TypeDesc pt = parseTypeDesc(l);\n+                TypeDefinition pt = parseTypeDesc(l);\n@@ -130,1 +134,6 @@\n-        return new TypeDescImpl(type.toString(), dims, ptypes);\n+        return new TypeDefinitionImpl(type.toString(), dims, ptypes);\n+    }\n+\n+    static TypeElement parseTypeElement(Lexer l) {\n+        TypeDefinition typeDesc = parseTypeDesc(l);\n+        return CoreTypeFactory.CORE_TYPE_FACTORY.constructType(typeDesc);\n@@ -134,1 +143,1 @@\n-        List<TypeDesc> ptypes = new ArrayList<>();\n+        List<TypeElement> ptypes = new ArrayList<>();\n@@ -137,1 +146,1 @@\n-            ptypes.add(parseTypeDesc(l));\n+            ptypes.add(parseTypeElement(l));\n@@ -139,1 +148,1 @@\n-                ptypes.add(parseTypeDesc(l));\n+                ptypes.add(parseTypeElement(l));\n@@ -143,1 +152,1 @@\n-        TypeDesc rtype = parseTypeDesc(l);\n+        TypeElement rtype = parseTypeElement(l);\n@@ -148,1 +157,1 @@\n-        TypeDesc refType = parseTypeDesc(l);\n+        TypeElement refType = parseTypeElement(l);\n@@ -168,1 +177,1 @@\n-        TypeDesc refType = parseTypeDesc(l);\n+        TypeElement refType = parseTypeElement(l);\n@@ -175,1 +184,1 @@\n-        if (mtype.parameters().size() != 0) {\n+        if (!mtype.parameters().isEmpty()) {\n@@ -186,1 +195,1 @@\n-                TypeDesc componentType = parseTypeDesc(l);\n+                TypeElement componentType = parseTypeElement(l);\n@@ -193,1 +202,1 @@\n-        TypeDesc recordType = parseTypeDesc(l);\n+        TypeElement recordType = parseTypeElement(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/DescParser.java","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.impl.JavaTypeImpl;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public final class CoreTypeFactory {\n+\n+    private CoreTypeFactory() {\n+    }\n+\n+    \/\/ Code model type factory composed\n+\n+    \/**\n+     * Create a code model factory combining and composing the construction\n+     * of code model types with types constructed from the given type factory.\n+     *\n+     * @param f the type factory.\n+     * @return the code model factory.\n+     *\/\n+    public static TypeElementFactory codeModelTypeFactory(TypeElementFactory f) {\n+        class CodeModelFactory implements TypeElementFactory {\n+            final TypeElementFactory thisThenF = this.andThen(f);\n+\n+            @Override\n+            public TypeElement constructType(TypeDefinition tree) {\n+                if (tree.isArray()) {\n+                    return null;\n+                }\n+                return switch (tree.name()) {\n+                    case VarType.NAME -> {\n+                        if (tree.typeArguments().size() != 1) {\n+                            throw new IllegalArgumentException();\n+                        }\n+\n+                        TypeElement v = thisThenF.constructType(tree.typeArguments().getFirst());\n+                        if (v == null) {\n+                            throw new IllegalArgumentException();\n+                        }\n+                        yield VarType.varType(v);\n+                    }\n+                    case TupleType.NAME -> {\n+                        if (tree.typeArguments().isEmpty()) {\n+                            throw new IllegalArgumentException();\n+                        }\n+\n+                        List<TypeElement> cs = new ArrayList<>(tree.typeArguments().size());\n+                        for (TypeDefinition child : tree.typeArguments()) {\n+                            TypeElement c = thisThenF.constructType(child);\n+                            if (c == null) {\n+                                throw new IllegalArgumentException();\n+                            }\n+                            cs.add(c);\n+                        }\n+                        yield TupleType.tupleType(cs);\n+                    }\n+                    default -> null;\n+                };\n+            }\n+        }\n+        if (f instanceof CodeModelFactory) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new CodeModelFactory().thisThenF;\n+    }\n+\n+    \/\/ Java type factory\n+\n+    \/**\n+     * The Java type factory.\n+     *\/\n+    public static final TypeElementFactory JAVA_TYPE_FACTORY = new TypeElementFactory() {\n+        @Override\n+        public TypeElement constructType(TypeDefinition tree) {\n+            String name = tree.name();\n+            int dimensions = tree.dimensions();\n+            List<JavaType> typeArguments = new ArrayList<>(tree.typeArguments().size());\n+            for (TypeDefinition child : tree.typeArguments()) {\n+                TypeElement t = JAVA_TYPE_FACTORY.constructType(child);\n+                if (!(t instanceof JavaType a)) {\n+                    throw new IllegalArgumentException();\n+                }\n+                typeArguments.add(a);\n+            }\n+            return new JavaTypeImpl(name, dimensions, typeArguments);\n+        }\n+    };\n+\n+\n+    \/**\n+     * The core type factory that can construct instance of {@link JavaType}\n+     * or code model types such as {@link VarType} or {@link TupleType} that\n+     * may contain instances of those types.\n+     *\/\n+    public static final TypeElementFactory CORE_TYPE_FACTORY = codeModelTypeFactory(JAVA_TYPE_FACTORY);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * A function type.\n+ *\/\n+public final class FunctionType implements TypeElement {\n+    static final String NAME = \"->\";\n+\n+    final TypeElement returnType;\n+    final List<TypeElement> parameterTypes;\n+\n+    FunctionType(TypeElement returnType, List<? extends TypeElement> parameterTypes) {\n+        this.returnType = returnType;\n+        this.parameterTypes = List.copyOf(parameterTypes);\n+    }\n+\n+    \/**\n+     * {@return the function type's return type}\n+     *\/\n+    public TypeElement returnType() {\n+        return returnType;\n+    }\n+\n+    \/**\n+     * {@return the function type's parameter types}\n+     *\/\n+    public List<TypeElement> parameterTypes() {\n+        return parameterTypes;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String cs = Stream.concat(Stream.of(returnType), parameterTypes.stream())\n+                .map(TypeElement::toString)\n+                .collect(Collectors.joining(\",\", \"<\", \">\"));\n+        return NAME + cs;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof FunctionType that &&\n+                returnType.equals(that.returnType) &&\n+                parameterTypes.equals(that.parameterTypes);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = returnType.hashCode();\n+        result = 31 * result + parameterTypes.hashCode();\n+        return result;\n+    }\n+\n+    \/**\n+     * Constructs a function type.\n+     *\n+     * @param returnType the function type's return type.\n+     * @param parameterTypes the function type's parameter types.\n+     * @return a function type.\n+     *\/\n+    public static FunctionType functionType(TypeElement returnType, List<? extends TypeElement> parameterTypes) {\n+        Objects.requireNonNull(returnType);\n+        Objects.requireNonNull(parameterTypes);\n+        return new FunctionType(returnType, parameterTypes);\n+    }\n+    \/**\n+     * Constructs a function type.\n+     *\n+     * @param returnType the function type's return type.\n+     * @param parameterTypes the function type's parameter types.\n+     * @return a function type.\n+     *\/\n+    public static FunctionType functionType(TypeElement returnType, TypeElement... parameterTypes) {\n+        return functionType(returnType, List.of(parameterTypes));\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/FunctionType.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.impl.JavaTypeImpl;\n+import java.util.List;\n+\n+\/**\n+ * The symbolic description of a Java type.\n+ *\/\n+\/\/ @@@ Extend from this interface to model Java types with more fidelity\n+public sealed interface JavaType extends TypeElement permits JavaTypeImpl {\n+\n+    \/\/ @@@ Share with general void type?\n+    JavaType VOID = new JavaTypeImpl(\"void\");\n+\n+    JavaType BOOLEAN = new JavaTypeImpl(\"boolean\");\n+\n+    JavaType J_L_BOOLEAN = new JavaTypeImpl(\"java.lang.Boolean\");\n+\n+    JavaType BOOLEAN_ARRAY = new JavaTypeImpl(\"boolean\", 1);\n+\n+    JavaType BYTE = new JavaTypeImpl(\"byte\");\n+\n+    JavaType J_L_BYTE = new JavaTypeImpl(\"java.lang.Byte\");\n+\n+    JavaType BYTE_ARRAY = new JavaTypeImpl(\"byte\", 1);\n+\n+    JavaType CHAR = new JavaTypeImpl(\"char\");\n+\n+    JavaType J_L_CHARACTER = new JavaTypeImpl(\"java.lang.Character\");\n+\n+    JavaType CHAR_ARRAY = new JavaTypeImpl(\"char\", 1);\n+\n+    JavaType SHORT = new JavaTypeImpl(\"short\");\n+\n+    JavaType J_L_SHORT = new JavaTypeImpl(\"java.lang.Short\");\n+\n+    JavaType SHORT_ARRAY = new JavaTypeImpl(\"short\", 1);\n+\n+    JavaType INT = new JavaTypeImpl(\"int\");\n+\n+    JavaType J_L_INTEGER = new JavaTypeImpl(\"java.lang.Integer\");\n+\n+    JavaType INT_ARRAY = new JavaTypeImpl(\"int\", 1);\n+\n+    JavaType LONG = new JavaTypeImpl(\"long\");\n+\n+    JavaType J_L_LONG = new JavaTypeImpl(\"java.lang.Long\");\n+\n+    JavaType LONG_ARRAY = new JavaTypeImpl(\"long\", 1);\n+\n+    JavaType FLOAT = new JavaTypeImpl(\"float\");\n+\n+    JavaType J_L_FLOAT = new JavaTypeImpl(\"java.lang.Float\");\n+\n+    JavaType FLOAT_ARRAY = new JavaTypeImpl(\"float\", 1);\n+\n+    JavaType DOUBLE = new JavaTypeImpl(\"double\");\n+\n+    JavaType J_L_DOUBLE = new JavaTypeImpl(\"java.lang.Double\");\n+\n+    JavaType DOUBLE_ARRAY = new JavaTypeImpl(\"double\", 1);\n+\n+    JavaType J_L_OBJECT = new JavaTypeImpl(\"java.lang.Object\");\n+\n+    JavaType J_L_OBJECT_ARRAY = new JavaTypeImpl(\"java.lang.Object\", 1);\n+\n+    JavaType J_L_CLASS = new JavaTypeImpl(\"java.lang.Class\");\n+\n+    JavaType J_L_STRING = new JavaTypeImpl(\"java.lang.String\");\n+\n+    \/\/\n+\n+    boolean isArray();\n+\n+    int dimensions();\n+\n+    JavaType componentType();\n+\n+    JavaType rawType();\n+\n+    boolean hasTypeArguments();\n+\n+    List<JavaType> typeArguments();\n+\n+    \/\/ Conversions\n+\n+    JavaType toBasicType();\n+\n+    String toClassName();\n+\n+    String toInternalName();\n+\n+    String toNominalDescriptorString();\n+\n+    default ClassDesc toNominalDescriptor() {\n+        return ClassDesc.ofDescriptor(toNominalDescriptorString());\n+    }\n+\n+    default Class<?> resolve(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        return (Class<?>) toNominalDescriptor().resolveConstantDesc(l);\n+    }\n+\n+    \/\/ Factories\n+\n+    static JavaType type(Class<?> c) {\n+        int dims = 0;\n+        if (c.isArray()) {\n+            while (c.isArray()) {\n+                c = c.getComponentType();\n+                dims++;\n+            }\n+        }\n+        return new JavaTypeImpl(c.getName(), dims);\n+    }\n+\n+    static JavaType type(Class<?> c, Class<?>... typeArguments) {\n+        return type(c, List.of(typeArguments));\n+    }\n+\n+    static JavaType type(Class<?> c, List<Class<?>> typeArguments) {\n+        int dims = 0;\n+        if (c.isArray()) {\n+            while (c.isArray()) {\n+                c = c.getComponentType();\n+                dims++;\n+            }\n+        }\n+        return new JavaTypeImpl(c.getName(), dims, typeArguments.stream().map(JavaType::type).toList());\n+    }\n+\n+    static JavaType ofNominalDescriptor(ClassDesc d) {\n+        String descriptor = d.descriptorString();\n+        int i = 0;\n+        while (descriptor.charAt(i) == '[') {\n+            i++;\n+        }\n+        int dims = i;\n+\n+        JavaType td = switch (descriptor.charAt(i)) {\n+            case 'V' -> JavaType.VOID;\n+            case 'I' -> JavaType.INT;\n+            case 'J' -> JavaType.LONG;\n+            case 'C' -> JavaType.CHAR;\n+            case 'S' -> JavaType.SHORT;\n+            case 'B' -> JavaType.BYTE;\n+            case 'F' -> JavaType.FLOAT;\n+            case 'D' -> JavaType.DOUBLE;\n+            case 'Z' -> JavaType.BOOLEAN;\n+            case 'L' -> {\n+                \/\/ La.b.c.Class;\n+                String typeName = descriptor.substring(i + 1, descriptor.length() - 1).replace('\/', '.');\n+                yield new JavaTypeImpl(typeName, 0);\n+            }\n+            default -> throw new InternalError();\n+        };\n+\n+        return JavaType.type(td, dims);\n+    }\n+\n+    static JavaType ofNominalDescriptorString(String d) {\n+        return ofNominalDescriptor(ClassDesc.ofDescriptor(d));\n+    }\n+\n+    static JavaType type(JavaType t, JavaType... typeArguments) {\n+        return type(t, List.of(typeArguments));\n+    }\n+\n+    static JavaType type(JavaType t, List<JavaType> typeArguments) {\n+        if (t.hasTypeArguments()) {\n+            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n+        }\n+        JavaTypeImpl timpl = (JavaTypeImpl) t;\n+        return new JavaTypeImpl(timpl.type, timpl.dims, typeArguments);\n+    }\n+\n+    static JavaType type(JavaType t, int dims, JavaType... typeArguments) {\n+        return type(t, dims, List.of(typeArguments));\n+    }\n+\n+    static JavaType type(JavaType t, int dims, List<JavaType> typeArguments) {\n+        if (t.isArray()) {\n+            throw new IllegalArgumentException(\"Type descriptor must not be an array: \" + t);\n+        }\n+        if (t.hasTypeArguments()) {\n+            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n+        }\n+        JavaTypeImpl timpl = (JavaTypeImpl) t;\n+        return new JavaTypeImpl(timpl.type, dims, typeArguments);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static JavaType ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return (JavaType) CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(java.lang.reflect.code.parser.impl.DescParser.parseTypeDesc(s));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * A tuple type.\n+ *\/\n+public final class TupleType implements TypeElement {\n+    static final String NAME = \"Tuple\";\n+\n+    final List<TypeElement> componentTypes;\n+\n+    TupleType(List<? extends TypeElement> componentTypes) {\n+        this.componentTypes = List.copyOf(componentTypes);\n+    }\n+\n+    \/**\n+     * {@return the tuple's component types, in order}\n+     *\/\n+    public List<TypeElement> componentTypes() {\n+        return componentTypes;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String cs = componentTypes.stream().map(TypeElement::toString)\n+                .collect(Collectors.joining(\",\", \"<\", \">\"));\n+        return NAME + cs;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof TupleType that && componentTypes.equals(that.componentTypes);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return componentTypes.hashCode();\n+    }\n+\n+    \/**\n+     * Constructs a tuple type.\n+     *\n+     * @param componentTypes the tuple type's component types.\n+     * @return a tuple type.\n+     *\/\n+    public static TupleType tupleType(List<? extends TypeElement> componentTypes) {\n+        Objects.requireNonNull(componentTypes);\n+        return new TupleType(componentTypes);\n+    }\n+\n+    \/**\n+     * Constructs a tuple type.\n+     *\n+     * @param componentTypes the tuple type's component types.\n+     * @return a tuple type.\n+     *\/\n+    public static TupleType tupleType(TypeElement... componentTypes) {\n+        return tupleType(List.of(componentTypes));\n+    }\n+\n+    \/**\n+     * Constructs a tuple type whose components are the types of\n+     * the given values.\n+     *\n+     * @param values the values.\n+     * @return a tuple type.\n+     *\/\n+    public static TupleType tupleTypeFromValues(List<? extends Value> values) {\n+        return tupleType(values.stream().map(Value::type).toList());\n+    }\n+\n+    \/**\n+     * Constructs a tuple type whose components are the types of\n+     * the given values.\n+     *\n+     * @param values the values.\n+     * @return a tuple type.\n+     *\/\n+    public static TupleType tupleTypeFromValues(Value... values) {\n+        return tupleType(Stream.of(values).map(Value::type).toList());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TupleType.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.type.impl.TypeDefinitionImpl;\n+import java.util.List;\n+\n+\/**\n+ * A type in general form that is utilized to construct a\n+ * concrete subclass of {@link  TypeElement} using a\n+ * {@link TypeElementFactory}\n+ *\/\n+public sealed interface TypeDefinition permits TypeDefinitionImpl {\n+\n+    TypeDefinition VOID = new TypeDefinitionImpl(\"void\");\n+\n+    \/\/\n+\n+    String name();\n+\n+    boolean isArray();\n+\n+    int dimensions();\n+\n+    TypeDefinition componentType();\n+\n+    TypeDefinition rawType();\n+\n+    boolean hasTypeArguments();\n+\n+    List<TypeDefinition> typeArguments();\n+\n+    \/\/ Factories\n+\n+    static TypeDefinition type(TypeDefinition t, TypeDefinition... typeArguments) {\n+        return type(t, List.of(typeArguments));\n+    }\n+\n+    static TypeDefinition type(TypeDefinition t, List<TypeDefinition> typeArguments) {\n+        if (t.hasTypeArguments()) {\n+            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n+        }\n+        TypeDefinitionImpl timpl = (TypeDefinitionImpl) t;\n+        return new TypeDefinitionImpl(timpl.type, timpl.dims, typeArguments);\n+    }\n+\n+    static TypeDefinition type(TypeDefinition t, int dims, TypeDefinition... typeArguments) {\n+        return type(t, dims, List.of(typeArguments));\n+    }\n+\n+    static TypeDefinition type(TypeDefinition t, int dims, List<TypeDefinition> typeArguments) {\n+        if (t.isArray()) {\n+            throw new IllegalArgumentException(\"Type descriptor must not be an array: \" + t);\n+        }\n+        if (t.hasTypeArguments()) {\n+            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n+        }\n+        TypeDefinitionImpl timpl = (TypeDefinitionImpl) t;\n+        return new TypeDefinitionImpl(timpl.type, dims, typeArguments);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static TypeDefinition ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseTypeDesc(s);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeDefinition.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@FunctionalInterface\n+public interface TypeElementFactory {\n+\/\/    record TypeTree(String name, List<TypeTree> children) {}\n+\n+    \/\/ Use TypeDefinition as temporary intermediate type representation\n+    TypeElement constructType(TypeDefinition tree);\n+\n+    default TypeElementFactory andThen(TypeElementFactory after) {\n+        return t -> {\n+            TypeElement te = constructType(t);\n+            return te != null ? te : after.constructType(t);\n+        };\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeElementFactory.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.Objects;\n+\n+\/**\n+ * A variable type.\n+ *\/\n+public final class VarType implements TypeElement {\n+    static final String NAME = \"Var\";\n+\n+    final TypeElement variableType;\n+\n+    VarType(TypeElement variableType) {\n+        this.variableType = variableType;\n+    }\n+\n+    \/**\n+     * {@return the variable type's value type}\n+     *\/\n+    public TypeElement valueType() {\n+        return variableType;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return NAME + \"<\" + variableType + \">\";\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof VarType that &&\n+                variableType.equals(that.variableType);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return variableType.hashCode();\n+    }\n+\n+    \/**\n+     * Constructs a variable type.\n+     *\n+     * @param valueType the variable's value type.\n+     * @return a variable type.\n+     *\/\n+    public static VarType varType(TypeElement valueType) {\n+        Objects.requireNonNull(valueType);\n+        return new VarType(valueType);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/VarType.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type.impl;\n+\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public final class JavaTypeImpl implements JavaType {\n+    \/\/ Fully qualified name\n+    public final String type;\n+\n+    public final int dims;\n+\n+    public final List<JavaType> typeArguments;\n+\n+    public JavaTypeImpl(String type) {\n+        this(type, 0, List.of());\n+    }\n+\n+    public JavaTypeImpl(String type, int dim) {\n+        this(type, dim, List.of());\n+    }\n+\n+    public JavaTypeImpl(String type, int dims, List<JavaType> typeArguments) {\n+        this.type = type;\n+        this.dims = dims;\n+        this.typeArguments = List.copyOf(typeArguments);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (dims == 0 && typeArguments.isEmpty()) {\n+            return type;\n+        } else if (typeArguments.isEmpty()) {\n+            return type + \"[]\".repeat(dims);\n+        } else {\n+            String params = typeArguments.stream().map(JavaType::toString).collect(Collectors.joining(\", \", \"<\", \">\"));\n+            return type + params + \"[]\".repeat(dims);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        JavaTypeImpl typeDesc = (JavaTypeImpl) o;\n+\n+        if (dims != typeDesc.dims) return false;\n+        if (!type.equals(typeDesc.type)) return false;\n+        return typeArguments.equals(typeDesc.typeArguments);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = type.hashCode();\n+        result = 31 * result + dims;\n+        result = 31 * result + typeArguments.hashCode();\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return dims != 0;\n+    }\n+\n+    @Override\n+    public int dimensions() {\n+        return dims;\n+    }\n+\n+    @Override\n+    public JavaType componentType() {\n+        if (!isArray()) {\n+            return null;\n+        }\n+\n+        return new JavaTypeImpl(type, dims - 1, List.of());\n+    }\n+\n+    @Override\n+    public JavaTypeImpl rawType() {\n+        return new JavaTypeImpl(type, dims);\n+    }\n+\n+    @Override\n+    public boolean hasTypeArguments() {\n+        return !typeArguments.isEmpty();\n+    }\n+\n+    @Override\n+    public List<JavaType> typeArguments() {\n+        return typeArguments;\n+    }\n+\n+    \/\/ Conversions\n+\n+    @Override\n+    public JavaType toBasicType() {\n+        if (isArray()) {\n+            return JavaType.J_L_OBJECT;\n+        }\n+\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        if (bytecodeKind == null) {\n+            return JavaType.J_L_OBJECT;\n+        } else {\n+            return switch (bytecodeKind) {\n+                case 'V' -> JavaType.VOID;\n+                case 'J' -> JavaType.LONG;\n+                case 'F' -> JavaType.FLOAT;\n+                case 'D' -> JavaType.DOUBLE;\n+                default -> JavaType.INT;\n+            };\n+        }\n+    }\n+\n+    @Override\n+    public String toClassName() {\n+        if (isArray()) {\n+            throw new IllegalStateException(\"Array type cannot be converted to class name: \" + type);\n+        }\n+\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        if (bytecodeKind != null) {\n+            throw new IllegalStateException(\"Invalid class: \" + type);\n+        }\n+\n+        return type;\n+    }\n+\n+    @Override\n+    public String toInternalName() {\n+        if (isArray()) {\n+            throw new IllegalArgumentException(\"Array type cannot be converted to class descriptor\");\n+        }\n+\n+        return toClassDescriptor(type);\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        if (!isArray()) {\n+            return toBytecodeDescriptor(type);\n+        }\n+\n+        String arraySignature = \"[\".repeat(dims);\n+        return arraySignature + toBytecodeDescriptor(type);\n+    }\n+\n+    static String toBytecodeDescriptor(String type) {\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        if (bytecodeKind != null) {\n+            return bytecodeKind.toString();\n+        }\n+\n+        if (type.equals(\"null\")) {\n+            type = Object.class.getName();\n+        }\n+\n+        return \"L\" + type.replace('.', '\/') + \";\";\n+    }\n+\n+    static String toClassDescriptor(String type) {\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        if (bytecodeKind != null) {\n+            throw new IllegalArgumentException(\"Primitive type has no class descriptor\");\n+        }\n+\n+        return type.replace('.', '\/');\n+    }\n+\n+    static Map<String, Character> PRIMITIVE_TYPE_MAP;\n+\n+    static {\n+        PRIMITIVE_TYPE_MAP = Map.of(\n+                \"boolean\", 'Z',\n+                \"byte\", 'B',\n+                \"short\", 'S',\n+                \"char\", 'C',\n+                \"int\", 'I',\n+                \"long\", 'J',\n+                \"float\", 'F',\n+                \"double\", 'D',\n+                \"void\", 'V'\n+        );\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/JavaTypeImpl.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type.impl;\n+\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public final class TypeDefinitionImpl implements TypeDefinition {\n+    \/\/ Fully qualified name\n+    public final String type;\n+\n+    public final int dims;\n+\n+    public final List<TypeDefinition> typeArguments;\n+\n+    public TypeDefinitionImpl(String type) {\n+        this(type, 0, List.of());\n+    }\n+\n+    public TypeDefinitionImpl(String type, int dim) {\n+        this(type, dim, List.of());\n+    }\n+\n+    public TypeDefinitionImpl(String type, int dims, List<TypeDefinition> typeArguments) {\n+        this.type = type;\n+        this.dims = dims;\n+        this.typeArguments = List.copyOf(typeArguments);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (dims == 0 && typeArguments.isEmpty()) {\n+            return type;\n+        } else if (typeArguments.isEmpty()) {\n+            return type + \"[]\".repeat(dims);\n+        } else {\n+            String params = typeArguments.stream().map(TypeDefinition::toString).collect(Collectors.joining(\", \", \"<\", \">\"));\n+            return type + params + \"[]\".repeat(dims);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        TypeDefinitionImpl typeDesc = (TypeDefinitionImpl) o;\n+\n+        if (dims != typeDesc.dims) return false;\n+        if (!type.equals(typeDesc.type)) return false;\n+        return typeArguments.equals(typeDesc.typeArguments);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = type.hashCode();\n+        result = 31 * result + dims;\n+        result = 31 * result + typeArguments.hashCode();\n+        return result;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return type;\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return dims != 0;\n+    }\n+\n+    @Override\n+    public int dimensions() {\n+        return dims;\n+    }\n+\n+    @Override\n+    public TypeDefinition componentType() {\n+        if (!isArray()) {\n+            return null;\n+        }\n+\n+        return new TypeDefinitionImpl(type, dims - 1, List.of());\n+    }\n+\n+    @Override\n+    public TypeDefinitionImpl rawType() {\n+        return new TypeDefinitionImpl(type, dims);\n+    }\n+\n+    @Override\n+    public boolean hasTypeArguments() {\n+        return !typeArguments.isEmpty();\n+    }\n+\n+    @Override\n+    public List<TypeDefinition> typeArguments() {\n+        return typeArguments;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/TypeDefinitionImpl.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * Descriptors for code models.\n+ * Types for code models.\n@@ -29,1 +29,1 @@\n-package java.lang.reflect.code.descriptor;\n\\ No newline at end of file\n+package java.lang.reflect.code.type;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/package-info.java","status":"copied"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.type.JavaType;\n@@ -188,1 +188,1 @@\n-                        if (!opr.type().equals(TypeDesc.VOID)) {\n+                        if (!opr.type().equals(JavaType.VOID)) {\n@@ -355,1 +355,1 @@\n-            if (!opr.type().equals(TypeDesc.VOID)) {\n+            if (!opr.type().equals(JavaType.VOID)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+    exports java.lang.reflect.code.type;\n@@ -385,0 +386,1 @@\n+    exports java.lang.reflect.code.type.impl;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -36,0 +35,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -205,1 +205,1 @@\n-            if (!or.type().equals(TypeDesc.VOID)) {\n+            if (!or.type().equals(JavaType.VOID)) {\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/SRRenderer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,2 +80,1 @@\n-import jdk.internal.java.lang.reflect.code.Block;\n-import jdk.internal.java.lang.reflect.code.Body;\n+import jdk.internal.java.lang.reflect.code.*;\n@@ -83,1 +82,0 @@\n-import jdk.internal.java.lang.reflect.code.op.CoreOps.Var;\n@@ -85,2 +83,0 @@\n-import jdk.internal.java.lang.reflect.code.Op;\n-import jdk.internal.java.lang.reflect.code.Value;\n@@ -91,2 +87,4 @@\n-import jdk.internal.java.lang.reflect.code.descriptor.TypeDesc;\n-import jdk.internal.java.lang.reflect.code.descriptor.impl.TypeDescImpl;\n+import jdk.internal.java.lang.reflect.code.type.JavaType;\n+import jdk.internal.java.lang.reflect.code.type.TupleType;\n+import jdk.internal.java.lang.reflect.code.type.VarType;\n+import jdk.internal.java.lang.reflect.code.type.impl.JavaTypeImpl;\n@@ -104,1 +102,0 @@\n-import static jdk.internal.java.lang.reflect.code.descriptor.TypeDesc.*;\n@@ -149,3 +146,3 @@\n-    private Map<TypeDesc, Type> primitiveAndBoxTypeMap;\n-    public Map<TypeDesc, Type> primitiveAndBoxTypeMap() {\n-        Map<TypeDesc, Type> m = primitiveAndBoxTypeMap;\n+    private Map<JavaType, Type> primitiveAndBoxTypeMap;\n+    Map<JavaType, Type> primitiveAndBoxTypeMap() {\n+        Map<JavaType, Type> m = primitiveAndBoxTypeMap;\n@@ -154,17 +151,17 @@\n-                    Map.entry(BOOLEAN, syms.booleanType),\n-                    Map.entry(BYTE, syms.byteType),\n-                    Map.entry(SHORT, syms.shortType),\n-                    Map.entry(CHAR, syms.charType),\n-                    Map.entry(INT, syms.intType),\n-                    Map.entry(LONG, syms.longType),\n-                    Map.entry(FLOAT, syms.floatType),\n-                    Map.entry(DOUBLE, syms.doubleType),\n-                    Map.entry(J_L_OBJECT, syms.objectType),\n-                    Map.entry(J_L_BOOLEAN, types.boxedTypeOrType(syms.booleanType)),\n-                    Map.entry(J_L_BYTE, types.boxedTypeOrType(syms.byteType)),\n-                    Map.entry(J_L_SHORT, types.boxedTypeOrType(syms.shortType)),\n-                    Map.entry(J_L_CHARACTER, types.boxedTypeOrType(syms.charType)),\n-                    Map.entry(J_L_INTEGER, types.boxedTypeOrType(syms.intType)),\n-                    Map.entry(J_L_LONG, types.boxedTypeOrType(syms.longType)),\n-                    Map.entry(J_L_FLOAT, types.boxedTypeOrType(syms.floatType)),\n-                    Map.entry(J_L_DOUBLE, types.boxedTypeOrType(syms.doubleType))\n+                    Map.entry(JavaType.BOOLEAN, syms.booleanType),\n+                    Map.entry(JavaType.BYTE, syms.byteType),\n+                    Map.entry(JavaType.SHORT, syms.shortType),\n+                    Map.entry(JavaType.CHAR, syms.charType),\n+                    Map.entry(JavaType.INT, syms.intType),\n+                    Map.entry(JavaType.LONG, syms.longType),\n+                    Map.entry(JavaType.FLOAT, syms.floatType),\n+                    Map.entry(JavaType.DOUBLE, syms.doubleType),\n+                    Map.entry(JavaType.J_L_OBJECT, syms.objectType),\n+                    Map.entry(JavaType.J_L_BOOLEAN, types.boxedTypeOrType(syms.booleanType)),\n+                    Map.entry(JavaType.J_L_BYTE, types.boxedTypeOrType(syms.byteType)),\n+                    Map.entry(JavaType.J_L_SHORT, types.boxedTypeOrType(syms.shortType)),\n+                    Map.entry(JavaType.J_L_CHARACTER, types.boxedTypeOrType(syms.charType)),\n+                    Map.entry(JavaType.J_L_INTEGER, types.boxedTypeOrType(syms.intType)),\n+                    Map.entry(JavaType.J_L_LONG, types.boxedTypeOrType(syms.longType)),\n+                    Map.entry(JavaType.J_L_FLOAT, types.boxedTypeOrType(syms.floatType)),\n+                    Map.entry(JavaType.J_L_DOUBLE, types.boxedTypeOrType(syms.doubleType))\n@@ -458,1 +455,1 @@\n-            List<TypeDesc> parameters = new ArrayList<>();\n+            List<TypeElement> parameters = new ArrayList<>();\n@@ -465,1 +462,1 @@\n-                parameters.add(typeToDesc(tree.sym.owner.type));\n+                parameters.add(typeToTypeElement(tree.sym.owner.type));\n@@ -468,1 +465,1 @@\n-            tree.sym.type.getParameterTypes().stream().map(this::typeToDesc).forEach(parameters::add);\n+            tree.sym.type.getParameterTypes().stream().map(this::typeToTypeElement).forEach(parameters::add);\n@@ -470,1 +467,1 @@\n-            MethodTypeDesc mtDesc = MethodTypeDesc.methodType(typeToDesc(tree.sym.type.getReturnType()), parameters);\n+            MethodTypeDesc mtDesc = MethodTypeDesc.methodType(typeToTypeElement(tree.sym.type.getReturnType()), parameters);\n@@ -500,2 +497,2 @@\n-            MethodTypeDesc mtDesc = MethodTypeDesc.methodType(typeToDesc(mtype.restype),\n-                    mtype.getParameterTypes().map(this::typeToDesc));\n+            MethodTypeDesc mtDesc = MethodTypeDesc.methodType(typeToTypeElement(mtype.restype),\n+                    mtype.getParameterTypes().map(this::typeToTypeElement));\n@@ -536,1 +533,1 @@\n-                var capturedArg = top.block.parameter(typeToDesc(sym.type));\n+                var capturedArg = top.block.parameter(typeToTypeElement(sym.type));\n@@ -548,1 +545,1 @@\n-                    capturedThis = top.block.parameter(typeToDesc(currentClassSym.type));\n+                    capturedThis = top.block.parameter(typeToTypeElement(currentClassSym.type));\n@@ -605,1 +602,1 @@\n-                return append(CoreOps.cast(typeToDesc(targetType), sourceValue));\n+                return append(CoreOps.cast(typeToTypeElement(targetType), sourceValue));\n@@ -612,1 +609,1 @@\n-            Type source = descToType(exprVal.type());\n+            Type source = typeElementToType(exprVal.type());\n@@ -618,1 +615,1 @@\n-            Type source = descToType(exprVal.type());\n+            Type source = typeElementToType(exprVal.type());\n@@ -624,1 +621,1 @@\n-            Type source = descToType(exprVal.type());\n+            Type source = typeElementToType(exprVal.type());\n@@ -634,1 +631,1 @@\n-                    return append(CoreOps.conv(typeToDesc(target), exprVal));\n+                    return append(CoreOps.conv(typeToTypeElement(target), exprVal));\n@@ -653,2 +650,2 @@\n-            MethodDesc boxMethod = MethodDesc.method(typeToDesc(box), names.valueOf.toString(),\n-                    MethodTypeDesc.methodType(typeToDesc(box), typeToDesc(types.unboxedType(box))));\n+            MethodDesc boxMethod = MethodDesc.method(typeToTypeElement(box), names.valueOf.toString(),\n+                    MethodTypeDesc.methodType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n@@ -662,1 +659,1 @@\n-                valueExpr = append(CoreOps.cast(typeToDesc(types.boxedClass(unboxedType).type), valueExpr));\n+                valueExpr = append(CoreOps.cast(typeToTypeElement(types.boxedClass(unboxedType).type), valueExpr));\n@@ -664,1 +661,1 @@\n-            MethodDesc unboxMethod = MethodDesc.method(typeToDesc(box),\n+            MethodDesc unboxMethod = MethodDesc.method(typeToTypeElement(box),\n@@ -666,1 +663,1 @@\n-                    MethodTypeDesc.methodType(typeToDesc(unboxedType), typeToDesc(box)));\n+                    MethodTypeDesc.methodType(typeToTypeElement(unboxedType), typeToTypeElement(box)));\n@@ -760,1 +757,1 @@\n-                TypeDesc resultType = typeToDesc(unboxedType);\n+                JavaType resultType = typeToTypeElement(unboxedType);\n@@ -870,1 +867,1 @@\n-                    if (varOp.type().rawType().equals(Var.VAR_TYPE)) {\n+                    if (varOp.type() instanceof VarType) {\n@@ -919,1 +916,1 @@\n-                result = append(CoreOps.constant(TypeDesc.J_L_CLASS, typeToDesc(tree.selected.type)));\n+                result = append(CoreOps.constant(JavaType.J_L_CLASS, typeToTypeElement(tree.selected.type)));\n@@ -985,1 +982,1 @@\n-                    Value res = append(CoreOps.invoke(typeToDesc(meth.type.getReturnType()), md, args));\n+                    Value res = append(CoreOps.invoke(typeToTypeElement(meth.type.getReturnType()), md, args));\n@@ -1007,1 +1004,1 @@\n-                    Value res = append(CoreOps.invoke(typeToDesc(meth.type.getReturnType()), md, args));\n+                    Value res = append(CoreOps.invoke(typeToTypeElement(meth.type.getReturnType()), md, args));\n@@ -1064,1 +1061,1 @@\n-                    result = append(CoreOps.conv(typeToDesc(type), v));\n+                    result = append(CoreOps.conv(typeToTypeElement(type), v));\n@@ -1074,2 +1071,2 @@\n-                TypeDesc descriptor = typeToDesc(types.erasure(type));\n-                result = append(CoreOps.cast(typeToDesc(type), descriptor, v));\n+                JavaType descriptor = typeToTypeElement(types.erasure(type));\n+                result = append(CoreOps.cast(typeToTypeElement(type), descriptor, v));\n@@ -1086,1 +1083,1 @@\n-                result = append(CoreOps.instanceOf(typeToDesc(tree.pattern.type), target));\n+                result = append(CoreOps.instanceOf(typeToTypeElement(tree.pattern.type), target));\n@@ -1092,1 +1089,1 @@\n-            TypeDesc patternType;\n+            JavaType patternType;\n@@ -1094,1 +1091,1 @@\n-                patternType = ExtendedOps.Pattern.bindingType(typeToDesc(p.type));\n+                patternType = ExtendedOps.Pattern.bindingType(typeToTypeElement(p.type));\n@@ -1096,1 +1093,1 @@\n-                patternType = ExtendedOps.Pattern.recordType(typeToDesc(p.record.type));\n+                patternType = ExtendedOps.Pattern.recordType(typeToTypeElement(p.record.type));\n@@ -1120,1 +1117,1 @@\n-                    result = append(ExtendedOps.bindingPattern(typeToDesc(var.type), var.name.toString()));\n+                    result = append(ExtendedOps.bindingPattern(typeToTypeElement(var.type), var.name.toString()));\n@@ -1167,2 +1164,2 @@\n-            List<TypeDesc> patternDescParams = variables.stream().map(var -> typeToDesc(var.type)).toList();\n-            MethodTypeDesc patternDesc = MethodTypeDesc.methodType(VOID, patternDescParams);\n+            List<JavaType> patternDescParams = variables.stream().map(var -> typeToTypeElement(var.type)).toList();\n+            MethodTypeDesc patternDesc = MethodTypeDesc.methodType(JavaType.VOID, patternDescParams);\n@@ -1216,1 +1213,1 @@\n-            result = append(CoreOps._new(typeToDesc(type), constructorDesc, args));\n+            result = append(CoreOps._new(typeToTypeElement(type), constructorDesc, args));\n@@ -1224,2 +1221,2 @@\n-                        typeToDesc(tree.type),\n-                        append(CoreOps.constant(TypeDesc.INT, length))));\n+                        typeToTypeElement(tree.type),\n+                        append(CoreOps.constant(JavaType.INT, length))));\n@@ -1231,1 +1228,1 @@\n-                            append(CoreOps.constant(TypeDesc.INT, i)),\n+                            append(CoreOps.constant(JavaType.INT, i)),\n@@ -1243,1 +1240,1 @@\n-                TypeDesc arrayType = typeToDesc(tree.type);\n+                JavaType arrayType = typeToTypeElement(tree.type);\n@@ -1303,1 +1300,1 @@\n-                    TypeDesc fiType = typeToDesc(tree.target);\n+                    JavaType fiType = typeToTypeElement(tree.target);\n@@ -1338,1 +1335,1 @@\n-                        MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+                        MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -1387,1 +1384,1 @@\n-            MethodTypeDesc caseLabelType = MethodTypeDesc.methodType(BOOLEAN, target.type());\n+            MethodTypeDesc caseLabelType = MethodTypeDesc.methodType(JavaType.BOOLEAN, target.type());\n@@ -1389,1 +1386,1 @@\n-            MethodTypeDesc actionType = MethodTypeDesc.methodType(typeToDesc(switchType));\n+            MethodTypeDesc actionType = MethodTypeDesc.methodType(typeToTypeElement(switchType));\n@@ -1406,1 +1403,1 @@\n-                        pushBody(pcl.pat, MethodTypeDesc.methodType(BOOLEAN));\n+                        pushBody(pcl.pat, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -1412,1 +1409,1 @@\n-                        pushBody(c.guard, MethodTypeDesc.methodType(BOOLEAN));\n+                        pushBody(c.guard, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -1446,1 +1443,1 @@\n-                            pushBody(ccl, MethodTypeDesc.methodType(BOOLEAN));\n+                            pushBody(ccl, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -1550,1 +1547,1 @@\n-            pushBody(cond, MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+            pushBody(cond, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -1588,1 +1585,1 @@\n-            pushBody(cond, MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+            pushBody(cond, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -1604,1 +1601,1 @@\n-            pushBody(tree.expr, MethodTypeDesc.methodType(typeToDesc(tree.expr.type)));\n+            pushBody(tree.expr, MethodTypeDesc.methodType(typeToTypeElement(tree.expr.type)));\n@@ -1614,2 +1611,2 @@\n-            TypeDesc eType = typeToDesc(var.type);\n-            TypeDesc varEType = CoreOps.Var.type(typeToDesc(var.type));\n+            JavaType eType = typeToTypeElement(var.type);\n+            VarType varEType = VarType.varType(typeToTypeElement(var.type));\n@@ -1628,1 +1625,1 @@\n-            pushBody(tree.body, MethodTypeDesc.methodType(VOID, varEType));\n+            pushBody(tree.body, MethodTypeDesc.methodType(JavaType.VOID, varEType));\n@@ -1662,1 +1659,1 @@\n-                List<TypeDesc> varTypes() {\n+                List<VarType> varTypes() {\n@@ -1664,1 +1661,1 @@\n-                            .map(t -> CoreOps.Var.type(typeToDesc(t.type)))\n+                            .map(t -> VarType.varType(typeToTypeElement(t.type)))\n@@ -1678,1 +1675,1 @@\n-            List<TypeDesc> varTypes = vds.varTypes();\n+            List<VarType> varTypes = vds.varTypes();\n@@ -1682,1 +1679,1 @@\n-                pushBody(null, MethodTypeDesc.methodType(CoreOps.Tuple.type(varTypes)));\n+                pushBody(null, MethodTypeDesc.methodType(TupleType.tupleType(varTypes)));\n@@ -1704,1 +1701,1 @@\n-            pushBody(tree.cond, MethodTypeDesc.methodType(TypeDesc.BOOLEAN, varTypes));\n+            pushBody(tree.cond, MethodTypeDesc.methodType(JavaType.BOOLEAN, varTypes));\n@@ -1712,1 +1709,1 @@\n-                append(CoreOps._yield(append(CoreOps.constant(BOOLEAN, true))));\n+                append(CoreOps._yield(append(CoreOps.constant(JavaType.BOOLEAN, true))));\n@@ -1721,1 +1718,1 @@\n-            pushBody(null, MethodTypeDesc.methodType(TypeDesc.VOID, varTypes));\n+            pushBody(null, MethodTypeDesc.methodType(JavaType.VOID, varTypes));\n@@ -1734,1 +1731,1 @@\n-            pushBody(tree.body, MethodTypeDesc.methodType(TypeDesc.VOID, varTypes));\n+            pushBody(tree.body, MethodTypeDesc.methodType(JavaType.VOID, varTypes));\n@@ -1758,1 +1755,1 @@\n-                    MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+                    MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -1773,1 +1770,1 @@\n-                    MethodTypeDesc.methodType(typeToDesc(condType)));\n+                    MethodTypeDesc.methodType(typeToTypeElement(condType)));\n@@ -1787,1 +1784,1 @@\n-                    MethodTypeDesc.methodType(typeToDesc(condType)));\n+                    MethodTypeDesc.methodType(typeToTypeElement(condType)));\n@@ -1797,1 +1794,1 @@\n-            result = append(ExtendedOps.conditionalExpression(typeToDesc(condType), bodies));\n+            result = append(ExtendedOps.conditionalExpression(typeToTypeElement(condType), bodies));\n@@ -1842,1 +1839,1 @@\n-            Op.Result label = append(CoreOps.constant(TypeDesc.J_L_STRING, labelName));\n+            Op.Result label = append(CoreOps.constant(JavaType.J_L_STRING, labelName));\n@@ -1858,1 +1855,1 @@\n-            List<TypeDesc> rTypes = new ArrayList<>();\n+            List<TypeElement> rTypes = new ArrayList<>();\n@@ -1866,1 +1863,1 @@\n-                        rTypes.add(CoreOps.Var.type(typeToDesc(vdecl.type)));\n+                        rTypes.add(VarType.varType(typeToTypeElement(vdecl.type)));\n@@ -1868,1 +1865,1 @@\n-                        rTypes.add(typeToDesc(resource.type));\n+                        rTypes.add(typeToTypeElement(resource.type));\n@@ -1873,1 +1870,1 @@\n-                pushBody(null, MethodTypeDesc.methodType(CoreOps.Tuple.type(rTypes)));\n+                pushBody(null, MethodTypeDesc.methodType(TupleType.tupleType(rTypes)));\n@@ -1891,2 +1888,6 @@\n-            List<TypeDesc> rVarTypes = rTypes.stream().filter(t -> t.rawType().equals(CoreOps.Var.VAR_TYPE)).toList();\n-            pushBody(tree.body, MethodTypeDesc.methodType(VOID, rVarTypes));\n+            List<VarType> rVarTypes = rTypes.stream().<VarType>mapMulti((t, c) -> {\n+                if (t instanceof VarType vt) {\n+                    c.accept(vt);\n+                }\n+            }).toList();\n+            pushBody(tree.body, MethodTypeDesc.methodType(JavaType.VOID, rVarTypes));\n@@ -1911,1 +1912,1 @@\n-                pushBody(catcher.body, MethodTypeDesc.methodType(VOID, typeToDesc(catcher.param.type)));\n+                pushBody(catcher.body, MethodTypeDesc.methodType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n@@ -1975,1 +1976,1 @@\n-                    result = append(CoreOps.neg(typeToDesc(tree.type), rhs));\n+                    result = append(CoreOps.neg(rhs));\n@@ -1993,1 +1994,1 @@\n-                pushBody(tree.lhs, MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+                pushBody(tree.lhs, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -2003,1 +2004,1 @@\n-                pushBody(tree.rhs, MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+                pushBody(tree.rhs, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n@@ -2017,1 +2018,0 @@\n-                TypeDesc resultType = typeToDesc(tree.type);\n@@ -2052,1 +2052,1 @@\n-            result = append(CoreOps.constant(typeToDesc(constantType), value));\n+            result = append(CoreOps.constant(typeToTypeElement(constantType), value));\n@@ -2109,2 +2109,2 @@\n-        TypeDesc symbolToDesc(Symbol s) {\n-            return typeToDesc(s.type);\n+        JavaType symbolToDesc(Symbol s) {\n+            return typeToTypeElement(s.type);\n@@ -2113,2 +2113,2 @@\n-        TypeDesc symbolToErasedDesc(Symbol s) {\n-            return typeToDesc(s.erasure(types));\n+        JavaType symbolToErasedDesc(Symbol s) {\n+            return typeToTypeElement(s.erasure(types));\n@@ -2117,1 +2117,1 @@\n-        TypeDesc typeToDesc(Type t) {\n+        JavaType typeToTypeElement(Type t) {\n@@ -2120,9 +2120,9 @@\n-                case VOID -> TypeDesc.VOID;\n-                case CHAR -> TypeDesc.CHAR;\n-                case BOOLEAN -> TypeDesc.BOOLEAN;\n-                case BYTE -> TypeDesc.BYTE;\n-                case SHORT -> TypeDesc.SHORT;\n-                case INT -> TypeDesc.INT;\n-                case FLOAT -> TypeDesc.FLOAT;\n-                case LONG -> TypeDesc.LONG;\n-                case DOUBLE -> TypeDesc.DOUBLE;\n+                case VOID -> JavaType.VOID;\n+                case CHAR -> JavaType.CHAR;\n+                case BOOLEAN -> JavaType.BOOLEAN;\n+                case BYTE -> JavaType.BYTE;\n+                case SHORT -> JavaType.SHORT;\n+                case INT -> JavaType.INT;\n+                case FLOAT -> JavaType.FLOAT;\n+                case LONG -> JavaType.LONG;\n+                case DOUBLE -> JavaType.DOUBLE;\n@@ -2137,2 +2137,2 @@\n-                    TypeDesc etd = typeToDesc(et);\n-                    yield new TypeDescImpl(etd.rawType().toString(), dims, etd.typeArguments());\n+                    JavaType etd = typeToTypeElement(et);\n+                    yield new JavaTypeImpl(etd.rawType().toString(), dims, etd.typeArguments());\n@@ -2143,1 +2143,1 @@\n-                    List<TypeDesc> typeArguments;\n+                    List<JavaType> typeArguments;\n@@ -2147,1 +2147,1 @@\n-                            typeArguments.add(typeToDesc(ta));\n+                            typeArguments.add(typeToTypeElement(ta));\n@@ -2154,1 +2154,1 @@\n-                    yield new TypeDescImpl(t.tsym.flatName().toString(), 0, typeArguments);\n+                    yield new JavaTypeImpl(t.tsym.flatName().toString(), 0, typeArguments);\n@@ -2177,1 +2177,1 @@\n-                    typeToDesc(s.owner.type),\n+                    typeToTypeElement(s.owner.type),\n@@ -2179,1 +2179,1 @@\n-                    typeToDesc(s.type));\n+                    typeToTypeElement(s.type));\n@@ -2184,1 +2184,1 @@\n-                    typeToDesc(s.owner.type),\n+                    typeToTypeElement(s.owner.type),\n@@ -2186,2 +2186,2 @@\n-                    typeToDesc(s.type.getReturnType()),\n-                    s.type.getParameterTypes().stream().map(this::typeToDesc).toArray(TypeDesc[]::new));\n+                    typeToTypeElement(s.type.getReturnType()),\n+                    s.type.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n@@ -2200,1 +2200,1 @@\n-                    typeToDesc(s.owner.erasure(types)),\n+                    typeToTypeElement(s.owner.erasure(types)),\n@@ -2202,2 +2202,2 @@\n-                    typeToDesc(erasedType.getReturnType()),\n-                    erasedType.getParameterTypes().stream().map(this::typeToDesc).toArray(TypeDesc[]::new));\n+                    typeToTypeElement(erasedType.getReturnType()),\n+                    erasedType.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n@@ -2212,2 +2212,2 @@\n-                    typeToDesc(t.getReturnType()),\n-                    t.getParameterTypes().stream().map(this::typeToDesc).toArray(TypeDesc[]::new));\n+                    typeToTypeElement(t.getReturnType()),\n+                    t.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n@@ -2217,1 +2217,1 @@\n-            TypeDesc recordType = typeToDesc(s.type);\n+            TypeElement recordType = typeToTypeElement(s.type);\n@@ -2219,1 +2219,1 @@\n-                    .map(rc -> new RecordTypeDesc.ComponentDesc(typeToDesc(rc.type), rc.name.toString()))\n+                    .map(rc -> new RecordTypeDesc.ComponentDesc(typeToTypeElement(rc.type), rc.name.toString()))\n@@ -2226,8 +2226,8 @@\n-                case CHAR -> CoreOps.constant(typeToDesc(t), (char)0);\n-                case BOOLEAN -> CoreOps.constant(typeToDesc(t), false);\n-                case SHORT -> CoreOps.constant(typeToDesc(t), (short)0);\n-                case INT -> CoreOps.constant(typeToDesc(t), 0);\n-                case FLOAT -> CoreOps.constant(typeToDesc(t), 0f);\n-                case LONG -> CoreOps.constant(typeToDesc(t), 0L);\n-                case DOUBLE -> CoreOps.constant(typeToDesc(t), 0d);\n-                default -> CoreOps.constant(typeToDesc(t), null);\n+                case CHAR -> CoreOps.constant(typeToTypeElement(t), (char)0);\n+                case BOOLEAN -> CoreOps.constant(typeToTypeElement(t), false);\n+                case SHORT -> CoreOps.constant(typeToTypeElement(t), (short)0);\n+                case INT -> CoreOps.constant(typeToTypeElement(t), 0);\n+                case FLOAT -> CoreOps.constant(typeToTypeElement(t), 0f);\n+                case LONG -> CoreOps.constant(typeToTypeElement(t), 0L);\n+                case DOUBLE -> CoreOps.constant(typeToTypeElement(t), 0d);\n+                default -> CoreOps.constant(typeToTypeElement(t), null);\n@@ -2239,6 +2239,6 @@\n-                case CHAR -> CoreOps.constant(typeToDesc(t), (char)1);\n-                case SHORT -> CoreOps.constant(typeToDesc(t), (short)1);\n-                case INT -> CoreOps.constant(typeToDesc(t), 1);\n-                case FLOAT -> CoreOps.constant(typeToDesc(t), 1f);\n-                case LONG -> CoreOps.constant(typeToDesc(t), 1L);\n-                case DOUBLE -> CoreOps.constant(typeToDesc(t), 1d);\n+                case CHAR -> CoreOps.constant(typeToTypeElement(t), (char)1);\n+                case SHORT -> CoreOps.constant(typeToTypeElement(t), (short)1);\n+                case INT -> CoreOps.constant(typeToTypeElement(t), 1);\n+                case FLOAT -> CoreOps.constant(typeToTypeElement(t), 1f);\n+                case LONG -> CoreOps.constant(typeToTypeElement(t), 1L);\n+                case DOUBLE -> CoreOps.constant(typeToTypeElement(t), 1d);\n@@ -2259,1 +2259,1 @@\n-        Type descToType(TypeDesc desc) {\n+        Type typeElementToType(TypeElement desc) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":150,"deletions":150,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.type.JavaType.INT;\n+import static java.lang.reflect.code.type.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -40,0 +39,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -43,1 +43,0 @@\n-import static java.lang.reflect.code.op.CoreOps.invoke;\n@@ -50,2 +49,2 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.type.JavaType.INT;\n+import static java.lang.reflect.code.type.JavaType.type;\n@@ -139,1 +138,1 @@\n-        Assert.assertEquals(TypeDesc.type(Quoted.class, CoreOps.ClosureOp.class), fop.funcDescriptor().returnType());\n+        Assert.assertEquals(JavaType.type(Quoted.class, CoreOps.ClosureOp.class), fop.funcDescriptor().returnType());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.type.JavaType;\n@@ -59,1 +59,1 @@\n-            Op.Result p = entry.op(constant(TypeDesc.BOOLEAN, true));\n+            Op.Result p = entry.op(constant(JavaType.BOOLEAN, true));\n@@ -88,1 +88,1 @@\n-            Op.Result p = entry.op(constant(TypeDesc.BOOLEAN, true));\n+            Op.Result p = entry.op(constant(JavaType.BOOLEAN, true));\n@@ -123,1 +123,1 @@\n-            Op.Result p = entry.op(constant(TypeDesc.BOOLEAN, true));\n+            Op.Result p = entry.op(constant(JavaType.BOOLEAN, true));\n@@ -168,1 +168,1 @@\n-            Op.Result p = entry.op(constant(TypeDesc.BOOLEAN, true));\n+            Op.Result p = entry.op(constant(JavaType.BOOLEAN, true));\n@@ -216,1 +216,1 @@\n-            Op.Result p = entry.op(constant(TypeDesc.BOOLEAN, true));\n+            Op.Result p = entry.op(constant(JavaType.BOOLEAN, true));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestDominate.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -45,1 +44,0 @@\n-import static java.lang.reflect.code.op.CoreOps.invoke;\n@@ -51,3 +49,1 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n-import static java.lang.reflect.code.descriptor.TypeDesc.VOID;\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.type.JavaType.*;\n@@ -77,2 +73,2 @@\n-                    var catchER1ISE = fblock.block(TypeDesc.type(IllegalStateException.class));\n-                    var catchER1IAE = fblock.block(TypeDesc.type(IllegalArgumentException.class));\n+                    var catchER1ISE = fblock.block(type(IllegalStateException.class));\n+                    var catchER1IAE = fblock.block(type(IllegalArgumentException.class));\n@@ -168,2 +164,2 @@\n-                    var catchER1ISE = fblock.block(TypeDesc.type(IllegalStateException.class));\n-                    var catchER1T = fblock.block(TypeDesc.type(Throwable.class));\n+                    var catchER1ISE = fblock.block(type(IllegalStateException.class));\n+                    var catchER1T = fblock.block(type(Throwable.class));\n@@ -262,2 +258,2 @@\n-                    var catchER1 = fblock.block(TypeDesc.type(IllegalArgumentException.class));\n-                    var catchER2 = fblock.block(TypeDesc.type(IllegalStateException.class));\n+                    var catchER1 = fblock.block(type(IllegalArgumentException.class));\n+                    var catchER2 = fblock.block(type(IllegalStateException.class));\n@@ -383,2 +379,2 @@\n-                    var catchRE = fblock.block(TypeDesc.type(IllegalStateException.class));\n-                    var catchAll = fblock.block(TypeDesc.type(Throwable.class));\n+                    var catchRE = fblock.block(type(IllegalStateException.class));\n+                    var catchAll = fblock.block(type(Throwable.class));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExceptionRegionOps.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n+import static java.lang.reflect.code.type.JavaType.INT;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -52,2 +51,2 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.type.JavaType.INT;\n+import static java.lang.reflect.code.type.JavaType.type;\n@@ -157,1 +156,1 @@\n-        Assert.assertEquals(TypeDesc.type(Quoted.class, LambdaOp.class), fop.funcDescriptor().returnType());\n+        Assert.assertEquals(type(Quoted.class, LambdaOp.class), fop.funcDescriptor().returnType());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -34,0 +33,2 @@\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n@@ -38,1 +39,0 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n@@ -51,1 +51,1 @@\n-        TypeDesc elementType();\n+        TypeElement elementType();\n@@ -74,1 +74,1 @@\n-        private Queryable insertQuery(TypeDesc et, String name, ClosureOp c) {\n+        private Queryable insertQuery(TypeElement et, String name, ClosureOp c) {\n@@ -101,1 +101,1 @@\n-            TypeDesc resultType = type(type(Stream.class), elementType());\n+            TypeElement resultType = JavaType.type(JavaType.type(Stream.class), (JavaType) elementType());\n@@ -108,1 +108,1 @@\n-            return insertQueryResult(\"count\", TypeDesc.LONG);\n+            return insertQueryResult(\"count\", JavaType.LONG);\n@@ -111,1 +111,1 @@\n-        private QueryResult insertQueryResult(String name, TypeDesc resultType) {\n+        private QueryResult insertQueryResult(String name, TypeElement resultType) {\n@@ -129,1 +129,1 @@\n-        TypeDesc resultType();\n+        TypeElement resultType();\n@@ -138,1 +138,1 @@\n-        TypeDesc queryableType();\n+        TypeElement queryableType();\n@@ -140,1 +140,1 @@\n-        TypeDesc queryResultType();\n+        TypeElement queryResultType();\n@@ -142,1 +142,1 @@\n-        Queryable createQuery(TypeDesc elementType, FuncOp expression);\n+        Queryable createQuery(TypeElement elementType, FuncOp expression);\n@@ -144,1 +144,1 @@\n-        QueryResult createQueryResult(TypeDesc resultType, FuncOp expression);\n+        QueryResult createQueryResult(TypeElement resultType, FuncOp expression);\n@@ -146,1 +146,1 @@\n-        Queryable newQuery(TypeDesc elementType);\n+        Queryable newQuery(TypeElement elementType);\n@@ -153,1 +153,1 @@\n-        final TypeDesc elementType;\n+        final TypeElement elementType;\n@@ -157,1 +157,1 @@\n-        TestQueryable(TypeDesc elementType, TestQueryProvider provider) {\n+        TestQueryable(TypeElement elementType, TestQueryProvider provider) {\n@@ -167,1 +167,1 @@\n-        TestQueryable(TypeDesc elementType, TestQueryProvider provider, FuncOp expression) {\n+        TestQueryable(TypeElement elementType, TestQueryProvider provider, FuncOp expression) {\n@@ -174,1 +174,1 @@\n-        public TypeDesc elementType() {\n+        public TypeElement elementType() {\n@@ -189,1 +189,1 @@\n-    public record TestQueryResult(TypeDesc resultType, FuncOp expression) implements QueryResult {\n+    public record TestQueryResult(TypeElement resultType, FuncOp expression) implements QueryResult {\n@@ -198,2 +198,2 @@\n-        final TypeDesc queryableType;\n-        final TypeDesc queryResultType;\n+        final TypeElement queryableType;\n+        final TypeElement queryResultType;\n@@ -202,2 +202,2 @@\n-            this.queryableType = TypeDesc.type(Queryable.class);\n-            this.queryResultType = TypeDesc.type(QueryResult.class);\n+            this.queryableType = JavaType.type(Queryable.class);\n+            this.queryResultType = JavaType.type(QueryResult.class);\n@@ -207,1 +207,1 @@\n-        public TypeDesc queryableType() {\n+        public TypeElement queryableType() {\n@@ -212,1 +212,1 @@\n-        public TypeDesc queryResultType() {\n+        public TypeElement queryResultType() {\n@@ -217,1 +217,1 @@\n-        public TestQueryable createQuery(TypeDesc elementType, FuncOp expression) {\n+        public TestQueryable createQuery(TypeElement elementType, FuncOp expression) {\n@@ -222,1 +222,1 @@\n-        public QueryResult createQueryResult(TypeDesc resultType, FuncOp expression) {\n+        public QueryResult createQueryResult(TypeElement resultType, FuncOp expression) {\n@@ -227,1 +227,1 @@\n-        public Queryable newQuery(TypeDesc elementType) {\n+        public Queryable newQuery(TypeElement elementType) {\n@@ -246,1 +246,1 @@\n-        QueryResult qr = qp.newQuery(type(Customer.class))\n+        QueryResult qr = qp.newQuery(JavaType.type(Customer.class))\n@@ -255,1 +255,1 @@\n-                qr.expression(), qp.newQuery(type(Customer.class)));\n+                qr.expression(), qp.newQuery(JavaType.type(Customer.class)));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -39,0 +38,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -323,1 +323,1 @@\n-                    if (r != null && !r.type().equals(TypeDesc.VOID)) {\n+                    if (r != null && !r.type().equals(JavaType.VOID)) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLiveness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -38,0 +37,1 @@\n+import java.lang.reflect.code.TypeElement;\n@@ -49,1 +49,0 @@\n-import static java.lang.reflect.code.op.CoreOps.invoke;\n@@ -54,2 +53,1 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n-import static java.lang.reflect.code.descriptor.TypeDesc.J_L_STRING;\n+import static java.lang.reflect.code.type.JavaType.*;\n@@ -267,1 +265,1 @@\n-                newArray(TypeDesc.type(Object[].class), arrayLength));\n+                newArray(type(Object[].class), arrayLength));\n@@ -324,1 +322,1 @@\n-    static String formatString(TypeDesc t) {\n+    static String formatString(TypeElement t) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLocalTransformationsAdaption.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -9,1 +9,0 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.DOUBLE;\n@@ -11,0 +10,1 @@\n+import static java.lang.reflect.code.type.JavaType.DOUBLE;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOpResultTypeNotCopiedBlindly.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.type.JavaType;\n@@ -39,1 +39,1 @@\n-    static final TypeDesc J_L_MATH = TypeDesc.type(Math.class);\n+    static final JavaType J_L_MATH = JavaType.type(Math.class);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ExpressionElimination.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -32,0 +31,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -38,1 +38,0 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.DOUBLE;\n@@ -40,0 +39,1 @@\n+import static java.lang.reflect.code.type.JavaType.DOUBLE;\n@@ -123,1 +123,1 @@\n-    static final TypeDesc J_L_MATH = TypeDesc.type(Math.class);\n+    static final JavaType J_L_MATH = JavaType.type(Math.class);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-import java.util.List;\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.stream.Stream;\n@@ -60,1 +61,1 @@\n-        TypeDesc td = TypeDesc.ofString(tds);\n+        TypeDefinition td = TypeDefinition.ofString(tds);\n@@ -62,2 +63,0 @@\n-        Assert.assertEquals(td.toNominalDescriptorString(), bcd);\n-        Assert.assertEquals(td, TypeDesc.ofNominalDescriptorString(bcd));\n@@ -75,1 +74,1 @@\n-        TypeDesc td = TypeDesc.ofString(tds);\n+        TypeDefinition td = TypeDefinition.ofString(tds);\n@@ -77,1 +76,0 @@\n-        Assert.assertEquals(td.toClassName(), bcd);\n@@ -80,31 +78,0 @@\n-\n-    @DataProvider\n-    public Object[][] basicTypeDescs() {\n-        return new Object[][]{\n-                {\"boolean\", \"int\"},\n-                {\"byte\", \"int\"},\n-                {\"char\", \"int\"},\n-                {\"short\", \"int\"},\n-                {\"int\", \"int\"},\n-                {\"long\", \"long\"},\n-                {\"float\", \"float\"},\n-                {\"double\", \"double\"},\n-                {\"void\", \"void\"},\n-                {\"int[]\", \"java.lang.Object\"},\n-                {\"int[][][][]\", \"java.lang.Object\"},\n-                {\"java.lang.String\", \"java.lang.Object\"},\n-                {\"java.lang.String[][]\", \"java.lang.Object\"},\n-                {\"a.b.C$D\", \"java.lang.Object\"},\n-                {\"java.util.List<T>\", \"java.lang.Object\"},\n-                {\"java.util.List<T>[]\", \"java.lang.Object\"},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"basicTypeDescs\")\n-    public void testBasicTypeDesc(String tds, String btds) {\n-        TypeDesc td = TypeDesc.ofString(tds);\n-        Assert.assertEquals(td.toString(), tds);\n-        Assert.assertEquals(td.toBasicType().toString(), btds);\n-    }\n-\n-\n@@ -126,1 +93,1 @@\n-        TypeDesc td = TypeDesc.ofString(tds);\n+        TypeDefinition td = TypeDefinition.ofString(tds);\n@@ -132,1 +99,1 @@\n-        Assert.assertEquals(td.typeArguments(), List.of(paramTypes).stream().map(TypeDesc::ofString).toList());\n+        Assert.assertEquals(td.typeArguments(), Stream.of(paramTypes).map(TypeDefinition::ofString).toList());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/descriptors\/TestDescriptors.java","additions":6,"deletions":39,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -26,0 +25,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -30,1 +30,1 @@\n-    protected abstract Queryable<?> createQuery(TypeDesc elementDesc, CoreOps.FuncOp queryExpression);\n+    protected abstract Queryable<?> createQuery(JavaType elementDesc, CoreOps.FuncOp queryExpression);\n@@ -32,1 +32,1 @@\n-    protected abstract QueryResult<?> createQueryResult(TypeDesc resultDesc, CoreOps.FuncOp expression);\n+    protected abstract QueryResult<?> createQueryResult(JavaType resultDesc, CoreOps.FuncOp expression);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QueryProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -26,0 +25,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -28,1 +28,1 @@\n-    TypeDesc DESC = TypeDesc.type(QueryResult.class);\n+    JavaType DESC = JavaType.type(QueryResult.class);\n@@ -31,1 +31,1 @@\n-    TypeDesc resultDesc();\n+    JavaType resultDesc();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QueryResult.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.type.JavaType;\n@@ -31,1 +31,0 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n@@ -33,0 +32,1 @@\n+import static java.lang.reflect.code.type.JavaType.type;\n@@ -35,1 +35,1 @@\n-    TypeDesc DESC = TypeDesc.type(Queryable.class);\n+    JavaType DESC = type(Queryable.class);\n@@ -40,1 +40,1 @@\n-    TypeDesc elementDesc();\n+    JavaType elementDesc();\n@@ -54,1 +54,1 @@\n-        return (Queryable<R>) insertQuery(l.funcDescriptor().returnType(), \"select\", l);\n+        return (Queryable<R>) insertQuery((JavaType) l.funcDescriptor().returnType(), \"select\", l);\n@@ -57,1 +57,1 @@\n-    private Queryable<?> insertQuery(TypeDesc elementDesc, String methodName, LambdaOp lambdaOp) {\n+    private Queryable<?> insertQuery(JavaType elementDesc, String methodName, LambdaOp lambdaOp) {\n@@ -60,1 +60,1 @@\n-        TypeDesc queryableDesc = TypeDesc.type(Queryable.DESC, elementDesc);\n+        JavaType queryableDesc = type(Queryable.DESC, elementDesc);\n@@ -67,1 +67,1 @@\n-                            methodType(Queryable.DESC, lambdaOp.functionalInterface().rawType()));\n+                            methodType(Queryable.DESC, ((JavaType) lambdaOp.functionalInterface()).rawType()));\n@@ -78,1 +78,1 @@\n-        TypeDesc resultDesc = type(type(Stream.class), elementDesc());\n+        JavaType resultDesc = type(type(Stream.class), elementDesc());\n@@ -84,1 +84,1 @@\n-        TypeDesc resultDesc = TypeDesc.LONG;\n+        JavaType resultDesc = JavaType.LONG;\n@@ -88,1 +88,1 @@\n-    private QueryResult<?> insertQueryResult(TypeDesc resultDesc, String methodName) {\n+    private QueryResult<?> insertQueryResult(JavaType resultDesc, String methodName) {\n@@ -91,1 +91,1 @@\n-        TypeDesc queryResultDesc = TypeDesc.type(QueryResult.DESC, resultDesc);\n+        JavaType queryResultDesc = JavaType.type(QueryResult.DESC, resultDesc);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -26,0 +25,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -28,1 +28,0 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n@@ -31,0 +30,1 @@\n+import static java.lang.reflect.code.type.JavaType.type;\n@@ -42,1 +42,1 @@\n-    protected Queryable<?> createQuery(TypeDesc elementDesc, CoreOps.FuncOp expression) {\n+    protected Queryable<?> createQuery(JavaType elementDesc, CoreOps.FuncOp expression) {\n@@ -47,1 +47,1 @@\n-    protected QueryResult<?> createQueryResult(TypeDesc resultDesc, CoreOps.FuncOp expression) {\n+    protected QueryResult<?> createQueryResult(JavaType resultDesc, CoreOps.FuncOp expression) {\n@@ -52,1 +52,1 @@\n-        final TypeDesc elementDesc;\n+        final JavaType elementDesc;\n@@ -60,1 +60,1 @@\n-            TypeDesc queryableType = TypeDesc.type(Queryable.DESC, elementDesc);\n+            JavaType queryableType = type(Queryable.DESC, elementDesc);\n@@ -67,1 +67,1 @@\n-        TestQueryable(TypeDesc elementDesc, TestQueryProvider provider, CoreOps.FuncOp expression) {\n+        TestQueryable(JavaType elementDesc, TestQueryProvider provider, CoreOps.FuncOp expression) {\n@@ -79,1 +79,1 @@\n-        public TypeDesc elementDesc() {\n+        public JavaType elementDesc() {\n@@ -89,1 +89,1 @@\n-    record TestQueryResult<T>(TypeDesc resultDesc, CoreOps.FuncOp expression) implements QueryResult<T> {\n+    record TestQueryResult<T>(JavaType resultDesc, CoreOps.FuncOp expression) implements QueryResult<T> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestQueryProvider.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.type.JavaType.INT;\n+import static java.lang.reflect.code.type.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestParse.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -29,0 +28,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -36,1 +36,0 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n@@ -40,0 +39,1 @@\n+import static java.lang.reflect.code.type.JavaType.type;\n@@ -45,1 +45,1 @@\n-    public static StreamExprBuilder fromList(TypeDesc elementType) {\n+    public static StreamExprBuilder fromList(JavaType elementType) {\n@@ -47,1 +47,1 @@\n-        TypeDesc listType = type(type(List.class), elementType);\n+        JavaType listType = type(type(List.class), elementType);\n@@ -89,2 +89,2 @@\n-        final TypeDesc sourceType;\n-        final TypeDesc sourceElementType;\n+        final JavaType sourceType;\n+        final JavaType sourceElementType;\n@@ -94,1 +94,1 @@\n-        StreamExprBuilder(TypeDesc sourceType, TypeDesc sourceElementType,\n+        StreamExprBuilder(JavaType sourceType, JavaType sourceElementType,\n@@ -102,1 +102,1 @@\n-        static JavaEnhancedForOp.BodyBuilder enhancedForLoop(Body.Builder ancestorBody, TypeDesc elementType,\n+        static JavaEnhancedForOp.BodyBuilder enhancedForLoop(Body.Builder ancestorBody, JavaType elementType,\n@@ -160,1 +160,1 @@\n-                            iterable.type(), iterable.type().typeArguments().get(0))\n+                            iterable.type(), ((JavaType) iterable.type()).typeArguments().get(0))\n@@ -185,1 +185,1 @@\n-            return func(\"fused.forEach\", MethodTypeDesc.methodType(TypeDesc.VOID, sourceType))\n+            return func(\"fused.forEach\", MethodTypeDesc.methodType(JavaType.VOID, sourceType))\n@@ -213,1 +213,1 @@\n-            TypeDesc collectType = supplier.funcDescriptor().returnType();\n+            JavaType collectType = (JavaType) supplier.funcDescriptor().returnType();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -28,0 +27,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -32,1 +32,0 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n@@ -36,0 +35,1 @@\n+import static java.lang.reflect.code.type.JavaType.type;\n@@ -60,1 +60,1 @@\n-        TypeDesc elementType = type(elementClass);\n+        JavaType elementType = type(elementClass);\n@@ -62,1 +62,1 @@\n-        TypeDesc listType = type(type(List.class), elementType);\n+        JavaType listType = type(type(List.class), elementType);\n@@ -104,2 +104,2 @@\n-        final TypeDesc sourceType;\n-        final TypeDesc sourceElementType;\n+        final JavaType sourceType;\n+        final JavaType sourceElementType;\n@@ -109,1 +109,1 @@\n-        StreamExprBuilder(TypeDesc sourceType, TypeDesc sourceElementType,\n+        StreamExprBuilder(JavaType sourceType, JavaType sourceElementType,\n@@ -117,1 +117,1 @@\n-        static JavaEnhancedForOp.BodyBuilder enhancedForLoop(Body.Builder ancestorBody, TypeDesc elementType,\n+        static JavaEnhancedForOp.BodyBuilder enhancedForLoop(Body.Builder ancestorBody, JavaType elementType,\n@@ -177,1 +177,1 @@\n-                            iterable.type(), iterable.type().typeArguments().get(0))\n+                            iterable.type(), ((JavaType) iterable.type()).typeArguments().get(0))\n@@ -205,1 +205,1 @@\n-            return func(\"fused.forEach\", MethodTypeDesc.methodType(TypeDesc.VOID, sourceType))\n+            return func(\"fused.forEach\", MethodTypeDesc.methodType(JavaType.VOID, sourceType))\n@@ -238,1 +238,1 @@\n-            TypeDesc collectType = supplier.funcDescriptor().returnType();\n+            JavaType collectType = (JavaType) supplier.funcDescriptor().returnType();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.type.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.stream.Stream;\n+\n+\n+\/*\n+ * @test\n+ * @run testng TestJavaType\n+ *\/\n+\n+public class TestJavaType {\n+\n+    @DataProvider\n+    public Object[][] JavaTypes() {\n+        return new Object[][]{\n+                {\"boolean\", \"Z\"},\n+                {\"byte\", \"B\"},\n+                {\"char\", \"C\"},\n+                {\"short\", \"S\"},\n+                {\"int\", \"I\"},\n+                {\"long\", \"J\"},\n+                {\"float\", \"F\"},\n+                {\"double\", \"D\"},\n+                {\"void\", \"V\"},\n+                {\"int[]\", \"[I\"},\n+                {\"int[][][][]\", \"[[[[I\"},\n+                {\"java.lang.String\", \"Ljava\/lang\/String;\"},\n+                {\"java.lang.String[][]\", \"[[Ljava\/lang\/String;\"},\n+                {\"a.b.C$D\", \"La\/b\/C$D;\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"JavaTypes\")\n+    public void testJavaType(String tds, String bcd) {\n+        JavaType jt = JavaType.ofString(tds);\n+        Assert.assertEquals(jt.toString(), tds);\n+        Assert.assertEquals(jt.toNominalDescriptorString(), bcd);\n+        Assert.assertEquals(jt, JavaType.ofNominalDescriptorString(bcd));\n+    }\n+\n+    @DataProvider\n+    public Object[][] classDescriptors() {\n+        return new Object[][]{\n+                {\"java.lang.String\", \"java.lang.String\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"classDescriptors\")\n+    public void classDescriptor(String tds, String bcd) {\n+        JavaType jt = JavaType.ofString(tds);\n+        Assert.assertEquals(jt.toString(), tds);\n+        Assert.assertEquals(jt.toClassName(), bcd);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] basicJavaTypes() {\n+        return new Object[][]{\n+                {\"boolean\", \"int\"},\n+                {\"byte\", \"int\"},\n+                {\"char\", \"int\"},\n+                {\"short\", \"int\"},\n+                {\"int\", \"int\"},\n+                {\"long\", \"long\"},\n+                {\"float\", \"float\"},\n+                {\"double\", \"double\"},\n+                {\"void\", \"void\"},\n+                {\"int[]\", \"java.lang.Object\"},\n+                {\"int[][][][]\", \"java.lang.Object\"},\n+                {\"java.lang.String\", \"java.lang.Object\"},\n+                {\"java.lang.String[][]\", \"java.lang.Object\"},\n+                {\"a.b.C$D\", \"java.lang.Object\"},\n+                {\"java.util.List<T>\", \"java.lang.Object\"},\n+                {\"java.util.List<T>[]\", \"java.lang.Object\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"basicJavaTypes\")\n+    public void testBasicJavaType(String tds, String btds) {\n+        JavaType jt = JavaType.ofString(tds);\n+        Assert.assertEquals(jt.toString(), tds);\n+        Assert.assertEquals(jt.toBasicType().toString(), btds);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] argumentJavaTypes() {\n+        return new Object[][]{\n+                {\"java.util.List<T>\", \"T\"},\n+                {\"java.util.List<T>[]\", \"T\"},\n+                {\"java.util.List<java.util.function.Supplier<T>>\", \"java.util.function.Supplier<T>\"},\n+                {\"java.util.List<java.util.function.Supplier<T>>[][]\", \"java.util.function.Supplier<T>\"},\n+                {\"java.util.Map<K, V>\", \"K\", \"V\"},\n+                {\"ab<cd<S<T, V>, N>>\", \"cd<S<T, V>, N>\"},\n+                {\"java.util.Consumer<java.util.Function<String, Number>>\", \"java.util.Function<String, Number>\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"argumentJavaTypes\")\n+    public void testArgumentJavaType(String tds, String... argTypes) {\n+        JavaType jt = JavaType.ofString(tds);\n+        Assert.assertEquals(jt.toString(), tds);\n+\n+        Assert.assertTrue(jt.hasTypeArguments());\n+        Assert.assertEquals(argTypes.length, jt.typeArguments().size());\n+\n+        Assert.assertEquals(jt.typeArguments(), Stream.of(argTypes).map(JavaType::ofString).toList());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestJavaType.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -485,1 +485,1 @@\n-                    ^init()java.lang.reflect.code.CoreOps$Tuple<Var<int>, Var<int>> -> {\n+                    ^init()Tuple<Var<int>, Var<int>> -> {\n@@ -490,1 +490,1 @@\n-                        %5 : java.lang.reflect.code.CoreOps$Tuple<Var<int>, Var<int>> = tuple %2 %4;\n+                        %5 : Tuple<Var<int>, Var<int>> = tuple %2 %4;\n","filename":"test\/langtools\/tools\/javac\/reflect\/ForLoopTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-                    ^resources()java.lang.reflect.code.CoreOps$Tuple<Var<TryTest$A>, TryTest$B, Var<TryTest$C>> -> {\n+                    ^resources()Tuple<Var<TryTest$A>, TryTest$B, Var<TryTest$C>> -> {\n@@ -176,1 +176,1 @@\n-                        %9 : java.lang.reflect.code.CoreOps$Tuple<Var<TryTest$A>, TryTest$B, Var<TryTest$C>> = tuple %2 %4 %8;\n+                        %9 : Tuple<Var<TryTest$A>, TryTest$B, Var<TryTest$C>> = tuple %2 %4 %8;\n","filename":"test\/langtools\/tools\/javac\/reflect\/TryTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}