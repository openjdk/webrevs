{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.io.IOException;\n@@ -49,0 +50,7 @@\n+\n+    \/**\n+     * Generate code and emit additional class files for a given class\n+     * @param context the compiler context\n+     * @param cdef   The class definition from which code is generated.\n+     *\/\n+    void genCode(Context context, JCTree.JCClassDecl cdef) throws IOException;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CodeReflectionTransformer.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -788,0 +788,7 @@\n+            if (Feature.REFLECT_METHODS.allowedInSource(source)) {\n+                Optional<CodeReflectionTransformer> reflectMethods = reflectMethods();\n+                if (reflectMethods.isPresent()) {\n+                    reflectMethods.get().genCode(context, cdef);\n+                }\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-public class ReflectMethods extends TreeScannerPrev {\n+public class ReflectMethods extends TreeTranslatorPrev {\n@@ -150,1 +150,0 @@\n-    private final JavaFileManager fileManager;\n@@ -181,1 +180,0 @@\n-        fileManager = context.get(JavaFileManager.class);\n@@ -228,1 +226,0 @@\n-            tree.defs = tree.defs.prependList(opMethodDecls.toList());\n@@ -230,1 +227,2 @@\n-                synthClassDecl();\n+                tree.defs = tree.defs.prependList(opMethodDecls.toList());\n+                tree = new JCReflectMethodsClassDecl(tree, ops);\n@@ -239,0 +237,1 @@\n+            result = tree;\n@@ -339,35 +338,0 @@\n-    private CoreOp.ModuleOp opBuilder() {\n-        return OpBuilder.createBuilderFunctions(\n-                ops,\n-                b -> b.op(JavaOp.fieldLoad(\n-                        FieldRef.field(JavaOp.class, \"JAVA_DIALECT_FACTORY\", DialectFactory.class))));\n-\n-    }\n-\n-    private void synthClassDecl() {\n-        try {\n-            JavaFileManager.Location outLocn;\n-            if (fileManager.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {\n-                outLocn = fileManager.getLocationForModule(StandardLocation.CLASS_OUTPUT, currentClassSym.packge().modle.name.toString());\n-            } else {\n-                outLocn = StandardLocation.CLASS_OUTPUT;\n-            }\n-            String className = codeModelsClassSym.flatName().toString();\n-            ClassDesc classDesc = ClassDesc.of(className);\n-            JavaFileObject outFile = fileManager.getJavaFileForOutput(outLocn, className, JavaFileObject.Kind.CLASS, currentClassSym.sourcefile);\n-            ClassDesc hostClass = ClassDesc.of(currentClassSym.className());\n-            CoreOp.ModuleOp module = opBuilder();\n-            byte[] data = BytecodeGenerator.generateClassData(MethodHandles.lookup(), classDesc, module);\n-            \/\/ inject InnerClassesAttribute and NestHostAttribute\n-            data = ClassFile.of().transformClass(ClassFile.of().parse(data), ClassTransform.endHandler(clb ->\n-                    clb.with(InnerClassesAttribute.of(InnerClassInfo.of(classDesc, Optional.of(hostClass), Optional.of(\"$CM\"), ClassFile.ACC_STATIC)))\n-                       .with(NestHostAttribute.of(hostClass))));\n-            try (OutputStream out = outFile.openOutputStream()) {\n-                out.write(data);\n-            }\n-            syms.enterClass(currentClassSym.packge().modle, className);\n-        } catch (IOException e) {\n-            throw new IllegalStateException(e);\n-        }\n-    }\n-\n@@ -377,2 +341,1 @@\n-        scan(cdef);\n-        return cdef;\n+        return translate(cdef);\n@@ -2684,0 +2647,12 @@\n+    static class JCReflectMethodsClassDecl extends JCClassDecl {\n+\n+        SequencedMap<String, Op> ops;\n+\n+        JCReflectMethodsClassDecl(JCClassDecl cls, SequencedMap<String, Op> ops) {\n+            super(cls.mods, cls.name, cls.typarams, cls.extending, cls.implementing, cls.permitting, cls.defs, cls.sym);\n+            this.pos = cls.pos;\n+            this.type = cls.type;\n+            this.ops = ops;\n+        }\n+    }\n+\n@@ -2689,0 +2664,31 @@\n+\n+        @Override\n+        public void genCode(Context context, JCClassDecl cdef) throws IOException {\n+            if (cdef instanceof JCReflectMethodsClassDecl rmcdef) {\n+                JavaFileManager fileManager = context.get(JavaFileManager.class);\n+                JavaFileManager.Location outLocn;\n+                if (fileManager.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {\n+                    outLocn = fileManager.getLocationForModule(StandardLocation.CLASS_OUTPUT, cdef.sym.packge().modle.name.toString());\n+                } else {\n+                    outLocn = StandardLocation.CLASS_OUTPUT;\n+                }\n+                String className = cdef.sym.flatName().toString() + \"$$CM\";\n+                ClassDesc classDesc = ClassDesc.of(className);\n+                JavaFileObject outFile = fileManager.getJavaFileForOutput(outLocn, className, JavaFileObject.Kind.CLASS, cdef.sym.sourcefile);\n+                ClassDesc hostClass = ClassDesc.of(cdef.sym.flatName().toString());\n+\n+                CoreOp.ModuleOp module = OpBuilder.createBuilderFunctions(\n+                        rmcdef.ops,\n+                        b -> b.op(JavaOp.fieldLoad(\n+                                FieldRef.field(JavaOp.class, \"JAVA_DIALECT_FACTORY\", DialectFactory.class))));\n+                byte[] data = BytecodeGenerator.generateClassData(MethodHandles.lookup(), classDesc, module);\n+                \/\/ inject InnerClassesAttribute and NestHostAttribute\n+                var clm = ClassFile.of().parse(data);\n+                data = ClassFile.of().transformClass(clm, ClassTransform.endHandler(clb ->\n+                        clb.with(InnerClassesAttribute.of(InnerClassInfo.of(classDesc, Optional.of(hostClass), Optional.of(\"$CM\"), ClassFile.ACC_STATIC)))\n+                           .with(NestHostAttribute.of(hostClass))));\n+                try (OutputStream out = outFile.openOutputStream()) {\n+                    out.write(data);\n+                }\n+            }\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":48,"deletions":42,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-        return prevNode;\n+        return currentNode;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/TreeScannerPrev.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+package jdk.incubator.code.internal;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+\n+public class TreeTranslatorPrev extends TreeTranslator {\n+\n+    private JCTree currentNode;\n+    private JCTree prevNode;\n+\n+    @Override\n+    public <T extends JCTree> T translate(T tree) {\n+        JCTree prevPrevNode = prevNode;\n+        prevNode = currentNode;\n+        currentNode = tree;\n+        try {\n+            return super.translate(tree);\n+        } finally {\n+            currentNode = prevNode;\n+            prevNode = prevPrevNode;\n+        }\n+    }\n+\n+    JCTree currentNode() {\n+        return currentNode;\n+    }\n+\n+    JCTree prevNode() {\n+        return prevNode;\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/TreeTranslatorPrev.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"}]}