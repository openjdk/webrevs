{"files":[{"patch":"@@ -1,164 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import hat.ifacemapper.Schema;\n-import hat.buffer.Buffer;\n-\n-public interface Cascade extends Buffer {\n-    int width();\n-\n-    void width(int width);\n-\n-    int height();\n-\n-    void height(int height);\n-\n-    interface Feature extends Buffer.StructChild {\n-        int id();\n-\n-        float threshold();\n-\n-        void id(int id);\n-\n-        void threshold(float threshold);\n-\n-        interface LinkOrValue extends Buffer.StructChild {\n-            interface Anon extends Buffer.UnionChild {\n-                int featureId();\n-\n-                void featureId(int featureId);\n-\n-                float value();\n-\n-                void value(float value);\n-            }\n-\n-            boolean hasValue();\n-\n-            void hasValue(boolean hasValue);\n-\n-            Anon anon();\n-        }\n-\n-        LinkOrValue left();\n-\n-        LinkOrValue right();\n-\n-        interface Rect extends Buffer.StructChild {\n-            byte x();\n-\n-            byte y();\n-\n-            byte width();\n-\n-            byte height();\n-\n-            float weight();\n-\n-            void x(byte x);\n-\n-            void y(byte y);\n-\n-            void width(byte width);\n-\n-            void height(byte height);\n-\n-            void weight(float height);\n-        }\n-\n-        Rect rect(long idx);\n-    }\n-\n-    int featureCount();\n-\n-    void featureCount(int featureCount);\n-    Feature feature(long idx);\n-\n-    interface Stage extends Buffer.StructChild {\n-        float threshold();\n-\n-        short firstTreeId();\n-\n-        short treeCount();\n-\n-        int id();\n-\n-        void id(int id);\n-\n-        void threshold(float threshold);\n-\n-        void firstTreeId(short firstTreeId);\n-\n-        void treeCount(short treeCount);\n-    }\n-\n-    int stageCount();\n-\n-     void stageCount(int stageCount);\n-    Stage stage(long idx);\n-\n-    interface Tree extends Buffer.StructChild {\n-        void id(int id);\n-\n-        void firstFeatureId(short firstFeatureId);\n-\n-        void featureCount(short featureCount);\n-\n-        int id();\n-\n-        short firstFeatureId();\n-\n-        short featureCount();\n-    }\n-\n-    int treeCount();\n-\n-       void treeCount(int treeCount);\n-    Tree tree(long idx);\n-\n-\n-    Schema<Cascade> schema = Schema.of(Cascade.class, cascade -> cascade\n-            .fields(\"width\", \"height\")\n-            .arrayLen(\"featureCount\").array(\"feature\", feature -> feature\n-                    .fields(\"id\", \"threshold\")\n-                    .fields(\"left\", \"right\", linkOrValue -> linkOrValue\n-                            .field(\"hasValue\")\n-                            .pad(3)\n-                            .field(\"anon\", anon -> anon.fields(\"featureId\", \"value\"))\n-                    )\n-                    .array(\"rect\", 3, rect -> rect.fields(\"x\", \"y\", \"width\", \"height\", \"weight\"))\n-            )\n-            .arrayLen(\"treeCount\").array(\"tree\", tree -> tree.fields(\"id\", \"featureCount\", \"firstFeatureId\"))\n-            .arrayLen(\"stageCount\").array(\"stage\", stage -> stage.fields(\"id\", \"threshold\", \"treeCount\", \"firstTreeId\"))\n-    );\n-\n-    public static void main(String[] args) {\n-        Cascade.schema.toText(t -> System.out.print(t));\n-        var cascade = Cascade.schema.allocate( 10, 10, 10);\n-        cascade.featureCount(10);\n-        System.out.println(Buffer.getLayout(cascade));\n-    }\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Cascade.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import hat.buffer.CompleteBuffer;\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-\n-public interface Features extends CompleteBuffer {\n-\n-    StructLayout linkOrValue = MemoryLayout.structLayout(\n-            JAVA_INT.withName(\"featureId\"),\n-            JAVA_FLOAT.withName(\"value\")\n-    ).withName(\"LinkOrValue\");\n-\n-    StructLayout featureLayout = MemoryLayout.structLayout(\n-            linkOrValue.withName(\"left\"),\n-            linkOrValue.withName(\"right\")\n-    ).withName(\"Feature\");\n-\n-\n-    \/*\n-     typedef struct LinkOrValue_s{\n-         int featureId;\n-         float value;\n-     } LinkOrValue_t;\n-\n-     typedef struct Feature_s{\n-         LinkOrValue_t left;\n-         LinkOrvalue_t right;\n-     } Feature_t;\n-\n-     *\/\n-\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Features.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -68,1 +68,2 @@\n-        var a = F32Array.create(accelerator, 100);\n+        var a = F32Array.schema.allocate(accelerator, 100);\n+        a.length(100);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ForTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -17,1 +17,2 @@\n-        S32Array s32Array = S32Array.create(accelerator, 10);\n+        S32Array s32Array = S32Array.schema.allocate(accelerator, 10);\n+        s32Array.length(10);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LambdaTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import hat.ifacemapper.Schema;\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.Arena;\n-\n-public interface ResultTable extends Buffer{\n-    interface Result extends Buffer.StructChild {\n-        float x();\n-        void x(float x);\n-        float y();\n-        void y(float y);\n-        float width();\n-        void width(float width);\n-        float height();\n-        void height(float height);\n-    }\n-    void atomicResultTableCount(int count);\n-    int atomicResultTableCount();\n-    int length();\n-    Result result(long idx);\n-    Schema<ResultTable> schema = Schema.of(ResultTable.class, resultTable->resultTable\n-            .atomic(\"atomicResultTableCount\")\n-            .arrayLen(\"length\").array(\"result\", array->array.fields(\"x\",\"y\",\"width\",\"height\"))\n-    );\n-\n-    public static void main(String[] args) {\n-        BufferAllocator bufferAllocator = new BufferAllocator() {\n-            public <T extends Buffer> T allocate(SegmentMapper<T> s) {\n-                return s.allocate(Arena.global());\n-            }\n-        };\n-        ResultTable.schema.toText(t->System.out.print(t));\n-        System.out.println();\n-        var boundLayout = new Schema.BoundSchema<>(ResultTable.schema, 1000);\n-        System.out.println(boundLayout.groupLayout);\n-        System.out.println(\"[i4(length)i4(atomicResultTableCount)[1000:[f4(x)f4(y)f4(width)f4(height)](Result)](result)](ResultTable)\");\n-       \/\/ var boundSchema = ResultTable.schema.allocate(bufferAllocator, 100);\n-\n-      \/\/  var resultTable = ResultTable.schema.allocate(bufferAllocator, 100).instance;\n-      \/\/  int resultTableLen = resultTable.length();\n-      \/\/  System.out.println(Buffer.getLayout(resultTable));\n-    }\n-\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ResultTable.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.buffer.Buffer;\n+import hat.buffer.S08x3RGBImage;\n+import hat.ifacemapper.Schema;\n+\n+public class S08x3ImageTest implements Buffer {\n+\n+    public static void main(String[] args) {\n+        var boundSchema = S08x3RGBImage.schema.boundSchema( 100,100);\n+        System.out.println(boundSchema.groupLayout);\n+        var rgbS08x3Image = boundSchema.allocate(Schema.GlobalArenaAllocator);\n+        rgbS08x3Image.width(100);\n+        rgbS08x3Image.height(100);\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S08x3ImageTest.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.buffer.S32Array2D;\n@@ -33,1 +34,2 @@\n-        hat.buffer.S32Array os32  = hat.buffer.S32Array.create(Schema.GlobalArenaAllocator, 100);\n+        hat.buffer.S32Array os32  = hat.buffer.S32Array.schema.allocate( 100);\n+        os32.length(100);\n@@ -42,1 +44,1 @@\n-        ResultTable.schema.toText(t->System.out.print(t));\n+        S32Array2D.schema.toText(t->System.out.print(t));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32ArrayTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2024 Intel Corporation. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package experiments;\n-\n-\n-import hat.ifacemapper.Schema;\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.Arena;\n-\n-public class SchemaLayoutTest {\n-\n-    public static void main(String[] args) {\n-        BufferAllocator bufferAllocator= new BufferAllocator() {\n-            public <T extends Buffer> T allocate(SegmentMapper<T> s) {return s.allocate(Arena.global());}\n-        };\n-        hat.buffer.S32Array os32  = hat.buffer.S32Array.create(bufferAllocator,100);\n-        System.out.println(\"Layout from hat S32Array \"+ Buffer.getLayout(os32));\n-\n-        var s32Array = S32Array.schema.allocate(bufferAllocator, 100);\n-        int s23ArrayLen = s32Array.length();\n-        System.out.println(\"Layout from schema \"+Buffer.getLayout(s32Array));\n-        ResultTable.schema.toText(t->System.out.print(t));\n-\n-        var resultTable = ResultTable.schema.allocate(bufferAllocator, 100);\n-        int resultTableLen = resultTable.length();\n-        System.out.println(Buffer.getLayout(resultTable));\n-\n-\n-        Cascade.schema.toText(t->System.out.print(t));\n-        var boundLayout = new Schema.BoundSchema<>(Cascade.schema,10,10,10);\n-        System.out.println(boundLayout.groupLayout);\n-        var cascade = Cascade.schema.allocate(bufferAllocator,10,10,10);\n-\n-        System.out.println(Buffer.getLayout(cascade));\n-        \/\/var layout = Cascade.schema.field.layout();\n-\n-   \/\/     System.out.println(layout);\n-    }\n-}\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SchemaLayoutTest.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -95,3 +95,6 @@\n-        var a = F32Array.create(accelerator, 100);\n-        var b = F32Array.create(accelerator, 100);\n-        var c = F32Array.create(accelerator, 100);\n+        var a = F32Array.schema.allocate(accelerator, 100);\n+        a.length(100);\n+        var b = F32Array.schema.allocate(accelerator, 100);\n+        b.length(100);\n+        var c = F32Array.schema.allocate(accelerator, 100);\n+        c.length(100);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/GetBackend.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -114,3 +114,8 @@\n-        var a = F32Array.create(accelerator, arrA);\n-        var b = F32Array.create(accelerator, arrB);\n-        var c = F32Array.create(accelerator, new float[size * size]);\n+        var a = F32Array.schema.allocate(accelerator, arrA.length);\n+        a.length(arrA.length);\n+        a.copyFrom(arrA);\n+        var b = F32Array.schema.allocate(accelerator, arrB.length);\n+        b.length(arrB.length);\n+        b.copyFrom(arrB);\n+        var c = F32Array.schema.allocate(accelerator, size * size);\n+        c.length(size*size);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/MatrixMultiply.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                s32Array2D.size(), \/\/0..S32Array2D.size()\n+                s32Array2D.width()*s32Array2D.height(), \/\/0..S32Array2D.size()\n@@ -71,1 +71,1 @@\n-        boolean headless = true;\/\/Boolean.getBoolean(\"headless\") ||( args.length>0 && args[0].equals(\"--headless\"));\n+        boolean headless = Boolean.getBoolean(\"headless\") ||( args.length>0 && args[0].equals(\"--headless\"));\n@@ -83,1 +83,3 @@\n-        S32Array2D s32Array2D = S32Array2D.create(accelerator, width, height);\n+        S32Array2D s32Array2D = S32Array2D.schema.allocate(accelerator, width, height);\n+        s32Array2D.width(width);\n+        s32Array2D.height(height);\n@@ -99,1 +101,3 @@\n-        S32Array pallette = S32Array.create(accelerator, palletteArray);\n+        S32Array pallette = S32Array.schema.allocate(accelerator, palletteArray.length);\n+        pallette.length(palletteArray.length);\n+        pallette.copyfrom(palletteArray);\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/MandelCompute.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-            MemorySegment.copy(Buffer.getMemorySegment(s32Array2D), JAVA_INT, offset, ((DataBufferInt) image.getRaster().getDataBuffer()).getData(), 0, s32Array2D.size());\n+            MemorySegment.copy(Buffer.getMemorySegment(s32Array2D), JAVA_INT, offset, ((DataBufferInt) image.getRaster().getDataBuffer()).getData(), 0, s32Array2D.width()*s32Array2D.height());\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/MandelViewer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package mandel.buffers;\n-\n-import hat.buffer.BufferAllocator;\n-import hat.buffer.ImageBuffer;\n-\n-import java.awt.image.BufferedImage;\n-import java.lang.foreign.StructLayout;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-\n-public interface RgbaS32Image extends ImageBuffer {\n-    StructLayout layout =  ImageBuffer.createLayout(RgbaS32Image.class,JAVA_SHORT);\n-    private static RgbaS32Image create(BufferAllocator bufferAllocator, int width, int height) {\n-        return ImageBuffer.create(bufferAllocator, RgbaS32Image.class, layout,width, height, BufferedImage.TYPE_INT_ARGB, 1);\n-    }\n-\n-    static RgbaS32Image create(BufferAllocator bufferAllocator, BufferedImage bufferedImage) {\n-        return create(bufferAllocator, bufferedImage.getWidth(), bufferedImage.getHeight()).syncFromRaster(bufferedImage);\n-\n-    }\n-\n-    short data(long idx);\n-\n-    void data(long idx, short v);\n-\n-    default short get(int x, int y) {\n-        return data((long) y * width() + x);\n-    }\n-\n-    default void set(int x, int y, short v) {\n-        data((long) y * width() + x, v);\n-    }\n-}\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/buffers\/RgbaS32Image.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -61,1 +61,2 @@\n-        var arr = S32Array.create(accelerator, 32);\n+        var arr = S32Array.schema.allocate(accelerator, 32);\n+        arr.length(32);\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Squares.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.Accelerator;\n@@ -32,2 +31,2 @@\n-import violajones.buffers.GreyU16Image;\n-import violajones.buffers.RgbS08x3Image;\n+import hat.buffer.U16GreyImage;\n+import hat.buffer.S08x3RGBImage;\n@@ -54,1 +53,1 @@\n-    final RgbS08x3Image rgbS08x3Image;\n+    final S08x3RGBImage s08X3RGBImage;\n@@ -61,2 +60,2 @@\n-        GreyU16Image integralImageU16;\n-        GreyU16Image integralSqImageU16;\n+        U16GreyImage integralImageU16;\n+        U16GreyImage integralSqImageU16;\n@@ -77,2 +76,2 @@\n-                this.integralImageU16 = GreyU16Image.create(bufferAllocator, integral);\n-                this.integralSqImageU16 = GreyU16Image.create(bufferAllocator, integralSq);\n+                this.integralImageU16 = U16GreyImage.schema.allocate(bufferAllocator,integral.getWidth(),integral.getHeight());\/\/create(bufferAllocator, integral);\n+                this.integralSqImageU16 = U16GreyImage.schema.allocate(bufferAllocator, integral.getWidth(),integral.getHeight());\n@@ -175,1 +174,1 @@\n-                      RgbS08x3Image rgbS08x3Image,\n+                      S08x3RGBImage s08X3RGBImage,\n@@ -182,1 +181,1 @@\n-        this.rgbS08x3Image = rgbS08x3Image;\n+        this.s08X3RGBImage = s08X3RGBImage;\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/HaarViewer.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import violajones.buffers.RgbS08x3Image;\n+import hat.buffer.S08x3RGBImage;\n@@ -70,1 +70,6 @@\n-        RgbS08x3Image rgbImage = RgbS08x3Image.create(accelerator, nasa1996);\n+        S08x3RGBImage rgbImage = S08x3RGBImage.schema.allocate(accelerator, nasa1996.getWidth(),nasa1996.getHeight());\n+        rgbImage.width(nasa1996.getWidth());\n+        rgbImage.height(nasa1996.getHeight());\n+      \/\/  rgbImage.elementsPerPixel(3);\n+      \/\/  rgbImage.bufferedImageType(BufferedImage.TYPE_INT_RGB);\n+        rgbImage.syncFromRaster(nasa1996);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCompute.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.Accelerator;\n@@ -30,2 +29,0 @@\n-import hat.backend.Backend;\n-import hat.buffer.S32Array;\n@@ -33,4 +30,2 @@\n-import org.xml.sax.SAXException;\n-import violajones.attic.ViolaJones;\n-import violajones.attic.ViolaJonesRaw;\n-import violajones.buffers.RgbS08x3Image;\n+import hat.buffer.S08x3RGBImage;\n+import hat.buffer.S32Array;\n@@ -41,2 +36,0 @@\n-import javax.imageio.ImageIO;\n-import javax.xml.parsers.ParserConfigurationException;\n@@ -44,2 +37,0 @@\n-import java.io.IOException;\n-import java.lang.invoke.MethodHandles;\n@@ -61,1 +52,1 @@\n-    public static void rgbToGrey(int id, RgbS08x3Image rgbImage, F32Array2D greyImage) {\n+    public static void rgbToGrey(int id, S08x3RGBImage rgbImage, F32Array2D greyImage) {\n@@ -71,1 +62,1 @@\n-    static long javaRgbToGreyScale(RgbS08x3Image rgb, F32Array2D grey) {\n+    static long javaRgbToGreyScale(S08x3RGBImage rgb, F32Array2D grey) {\n@@ -83,1 +74,1 @@\n-    public static void rgbToGreyKernel(KernelContext kc, RgbS08x3Image rgbImage, F32Array2D greyImage) {\n+    public static void rgbToGreyKernel(KernelContext kc, S08x3RGBImage rgbImage, F32Array2D greyImage) {\n@@ -314,0 +305,7 @@\n+    static F32Array2D createF32Array2D(ComputeContext cc,int width, int height){\n+        F32Array2D f32Array2D = F32Array2D.schema.allocate(cc, width, height);\n+        f32Array2D.width(width);\n+        f32Array2D.height(height);\n+        return f32Array2D;\n+    }\n+\n@@ -315,1 +313,1 @@\n-    static public void compute(final ComputeContext cc, Cascade cascade, BufferedImage bufferedImage, RgbS08x3Image rgbS08x3Image, ResultTable resultTable, ScaleTable scaleTable) {\n+    static public void compute(final ComputeContext cc, Cascade cascade, BufferedImage bufferedImage, S08x3RGBImage s08X3RGBImage, ResultTable resultTable, ScaleTable scaleTable) {\n@@ -317,1 +315,4 @@\n-        int width = rgbS08x3Image.width();\n+        int width = s08X3RGBImage.width();\n+\n+        int height = s08X3RGBImage.height();\n+        F32Array2D greyImage = createF32Array2D(cc, width, height);\n@@ -319,2 +320,0 @@\n-        int height = rgbS08x3Image.height();\n-        F32Array2D greyImage = F32Array2D.create(cc, width, height);\n@@ -323,3 +322,4 @@\n-        cc.dispatchKernel(width * height, kc -> rgbToGreyKernel(kc, rgbS08x3Image, greyImage));\n-        F32Array2D integralImage = F32Array2D.create(cc, width, height);\n-        F32Array2D integralSqImage = F32Array2D.create(cc, width, height);\n+        cc.dispatchKernel(width * height, kc -> rgbToGreyKernel(kc, s08X3RGBImage, greyImage));\n+        F32Array2D integralImage = createF32Array2D(cc, width, height);\n+\n+        F32Array2D integralSqImage = createF32Array2D(cc, width, height);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import violajones.buffers.RgbS08x3Image;\n+import hat.buffer.S08x3RGBImage;\n@@ -53,1 +53,1 @@\n-    public static void rgbToGreyKernel(int id, RgbS08x3Image rgbImage, F32Array2D floatImage) {\n+    public static void rgbToGreyKernel(int id, S08x3RGBImage rgbImage, F32Array2D floatImage) {\n@@ -146,1 +146,1 @@\n-    static long rgbToGreyScale(RgbS08x3Image rgb, F32Array2D grey) {\n+    static long rgbToGreyScale(S08x3RGBImage rgb, F32Array2D grey) {\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/attic\/CoreJavaViolaJones.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import violajones.buffers.RgbS08x3Image;\n+import hat.buffer.S08x3RGBImage;\n@@ -59,1 +59,7 @@\n-        var rgbImage = RgbS08x3Image.create(accelerator, nasa);\n+        S08x3RGBImage rgbImage = S08x3RGBImage.schema.allocate(accelerator, nasa.getWidth(),nasa.getHeight());\n+        rgbImage.width(nasa.getWidth());\n+        rgbImage.height(nasa.getHeight());\n+       \/\/ rgbImage.elementsPerPixel(3);\n+       \/\/ rgbImage.bufferedImageType(BufferedImage.TYPE_INT_RGB);\n+\n+       \/\/ var rgbImage = RgbS08x3Image.create(accelerator, nasa);\n@@ -71,3 +77,9 @@\n-        var greyImageF32 = F32Array2D.create(accelerator, width, height);\n-        var integralImageF32 = F32Array2D.create(accelerator, width, height);\n-        var integralSqImageF32 = F32Array2D.create(accelerator, width, height);\n+        var greyImageF32 = F32Array2D.schema.allocate(accelerator, width, height);\n+        greyImageF32.width(width);\n+        greyImageF32.height(height);\n+        var integralImageF32 = F32Array2D.schema.allocate(accelerator, width, height);\n+        integralImageF32.width(width);\n+        integralImageF32.height(height);\n+        var integralSqImageF32 = F32Array2D.schema.allocate(accelerator, width, height);\n+        integralSqImageF32.width(width);\n+        integralSqImageF32.height(height);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/attic\/ViolaJones.java","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package violajones.buffers;\n-\n-import hat.buffer.BufferAllocator;\n-import hat.buffer.ImageBuffer;\n-\n-import java.awt.image.BufferedImage;\n-import java.lang.foreign.StructLayout;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-\n-public interface GreyU16Image extends ImageBuffer {\n-    StructLayout layout =  ImageBuffer.createLayout(GreyU16Image.class,JAVA_SHORT);\n-    private static GreyU16Image create(BufferAllocator bufferAllocator, int width, int height) {\n-        return ImageBuffer.create(bufferAllocator, GreyU16Image.class, layout,width, height, BufferedImage.TYPE_USHORT_GRAY, 1);\n-    }\n-    static GreyU16Image create(BufferAllocator bufferAllocator, BufferedImage bufferedImage) {\n-        return create(bufferAllocator, bufferedImage.getWidth(), bufferedImage.getHeight()).syncFromRaster(bufferedImage);\n-    }\n-    short data(long idx);\n-    void data(long idx, short v);\n-}\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/buffers\/GreyU16Image.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package violajones.buffers;\n-\n-import hat.buffer.BufferAllocator;\n-import hat.buffer.ImageBuffer;\n-import java.awt.image.BufferedImage;\n-import java.lang.foreign.StructLayout;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-\n-public interface RgbS08x3Image extends ImageBuffer {\n-    StructLayout layout =  ImageBuffer.createLayout(RgbS08x3Image.class,JAVA_BYTE);\n-\n-    private static RgbS08x3Image create(BufferAllocator bufferAllocator, int width, int height) {\n-        return ImageBuffer.create(bufferAllocator, RgbS08x3Image.class,layout, width, height, BufferedImage.TYPE_INT_RGB, 3);\n-    }\n-\n-    static RgbS08x3Image create(BufferAllocator bufferAllocator, BufferedImage bufferedImage) {\n-        return create(bufferAllocator, bufferedImage.getWidth(), bufferedImage.getHeight()).syncFromRaster(bufferedImage);\n-\n-    }\n-    byte data(long idx);\n-\n-    void data(long idx, byte v);\n-\n-}\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/buffers\/RgbS08x3Image.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -30,10 +30,0 @@\n-import hat.buffer.BufferAllocator;\n-import hat.buffer.Table;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ResultTable.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,10 +31,0 @@\n-import hat.buffer.BufferAllocator;\n-import hat.buffer.Table;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ScaleTable.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,4 +0,0 @@\n-package hat.buffer;\n-\n-public interface Array extends IncompleteBuffer {\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Array.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import hat.Accelerator;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-\n-public interface Array1D extends Array {\n-    static <T extends Array1D> StructLayout getLayout(Class<T> clazz, MemoryLayout memoryLayout) {\n-        return MemoryLayout.structLayout(\n-                JAVA_INT.withName(\"length\"),\n-                MemoryLayout.sequenceLayout(0, memoryLayout).withName(\"array\")\n-        ).withName(clazz.getSimpleName());\n-    }\n-\n-    static <T extends Array1D> T create(BufferAllocator bufferAllocator, Class<T> clazz, StructLayout structLayout, int length) {\n-\n-        T buffer = bufferAllocator.allocate(SegmentMapper.ofIncomplete(MethodHandles.lookup(), clazz, structLayout,length));\n-        Buffer.setLength(buffer,length);\n-        return buffer;\n-    }\n-\n-\n-    int length();\n-\n-\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Array1D.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import hat.Accelerator;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-\n-public interface Array2D extends Array {\n-    static <T extends Array2D> StructLayout getLayout(Class<T> iface, MemoryLayout memoryLayout) {\n-        return MemoryLayout.structLayout(\n-                JAVA_INT.withName(\"width\"),\n-                JAVA_INT.withName(\"height\"),\n-                MemoryLayout.sequenceLayout(0, memoryLayout).withName(\"array\")\n-        ).withName(iface.getSimpleName());\n-    }\n-\n-    static <T extends Array2D> T create(BufferAllocator bufferAllocator, Class<T> clazz, StructLayout structLayout,int width, int height) {\n-\n-        T buffer = bufferAllocator.allocate(SegmentMapper.ofIncomplete(MethodHandles.lookup(), clazz, structLayout, (long) width * height));\n-        MemorySegment segment = Buffer.getMemorySegment(buffer);\n-        segment.set(JAVA_INT, structLayout.byteOffset(MemoryLayout.PathElement.groupElement(\"width\")), width);\n-        segment.set(JAVA_INT, structLayout.byteOffset(MemoryLayout.PathElement.groupElement(\"height\")), height);\n-        return buffer;\n-    }\n-\n-    int width();\n-\n-    int height();\n-\n-    default int size() {\n-        return width() * height();\n-    }\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Array2D.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ifacemapper.Schema;\n@@ -33,0 +34,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -34,5 +36,1 @@\n-public interface F32Array extends Array1D {\n-    StructLayout layout  = Array1D.getLayout(F32Array.class, JAVA_FLOAT);\n-    static F32Array create(BufferAllocator bufferAllocator, int length) {\n-        return Array1D.create(bufferAllocator, F32Array.class,layout, length);\n-    }\n+public interface F32Array extends IncompleteBuffer {\n@@ -40,3 +38,4 @@\n-    static F32Array create(BufferAllocator bufferAllocator, float[] source) {\n-        return create(bufferAllocator, source.length).copyFrom(source);\n-    }\n+    int length();\n+    void length(int i);\n+    Schema<F32Array> schema = Schema.of(F32Array.class, s32Array->s32Array\n+            .arrayLen(\"length\").array(\"array\"));\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ifacemapper.Schema;\n@@ -34,5 +35,8 @@\n-public interface F32Array2D extends Array2D {\n-    StructLayout layout  = Array2D.getLayout(F32Array2D.class, JAVA_FLOAT);\n-    static F32Array2D create(BufferAllocator bufferAllocator, int width, int height) {\n-        return Array2D.create(bufferAllocator, F32Array2D.class, layout, width, height);\n-    }\n+public interface F32Array2D extends IncompleteBuffer {\n+    int width();\n+    void height(int i);\n+    int height();\n+    void width(int i);\n+    Schema<F32Array2D> schema = Schema.of(F32Array2D.class, s32Array->s32Array\n+            .arrayLen(\"width\",\"height\").stride(1).array(\"array\"));\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import hat.Accelerator;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.awt.image.BufferedImage;\n-import java.awt.image.DataBuffer;\n-import java.awt.image.DataBufferByte;\n-import java.awt.image.DataBufferInt;\n-import java.awt.image.DataBufferUShort;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-\n-public interface ImageBuffer extends IncompleteBuffer {\n-    static StructLayout createLayout(Class iface, ValueLayout valueLayout) {\n-        return MemoryLayout.structLayout(\n-                JAVA_INT.withName(\"width\"),\n-                JAVA_INT.withName(\"height\"),\n-                JAVA_INT.withName(\"elementsPerPixel\"),\n-                JAVA_INT.withName(\"bufferedImageType\"),\n-                MemoryLayout.sequenceLayout(0, valueLayout).withName(\"data\")\n-        ).withName(iface.getSimpleName());\n-    }\n-    \/* BufferedImage types\n-                 TYPE_INT_RGB, TYPE_INT_ARGB, TYPE_INT_ARGB_PRE, TYPE_INT_BGR,\n-                  TYPE_3BYTE_BGR, TYPE_4BYTE_ABGR, TYPE_4BYTE_ABGR_PRE, TYPE_BYTE_GRAY,\n-                   TYPE_BYTE_BINARY, TYPE_BYTE_INDEXED, TYPE_USHORT_GRAY,\n-                    TYPE_USHORT_565_RGB, TYPE_USHORT_555_RGB, TYPE_CUSTOM\n-\n-     *\/\n-    static <T extends ImageBuffer> T create(BufferAllocator bufferAllocator, Class<T> iface,StructLayout structLayout, int width, int height, int bufferedImageType, int elementsPerPixel) {\n-        T rgba = bufferAllocator.allocate(SegmentMapper.ofIncomplete(MethodHandles.lookup(), iface, structLayout, width * height * elementsPerPixel));\n-        MemorySegment segment = Buffer.getMemorySegment(rgba);\n-        segment.set(JAVA_INT, structLayout.byteOffset(MemoryLayout.PathElement.groupElement(\"width\")), width);\n-        segment.set(JAVA_INT, structLayout.byteOffset(MemoryLayout.PathElement.groupElement(\"height\")), height);\n-        segment.set(JAVA_INT, structLayout.byteOffset(MemoryLayout.PathElement.groupElement(\"elementsPerPixel\")), elementsPerPixel);\n-        segment.set(JAVA_INT, structLayout.byteOffset(MemoryLayout.PathElement.groupElement(\"bufferedImageType\")), bufferedImageType);\n-        return rgba;\n-    }\n-\n-    int elementsPerPixel();\n-\n-    \/\/ void elementsPerPixel(int elementsPerPixel);\n-\n-    int bufferedImageType();\n-\n-    \/\/ void bufferedImageType(int bufferedImageType);\n-    @SuppressWarnings(\"unchecked\")\n-    default <T extends ImageBuffer> T syncToRasterDataBuffer(DataBuffer dataBuffer) { \/\/ int[], byte[], short[]\n-        switch (dataBuffer) {\n-            case DataBufferUShort arr ->\n-                    MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_SHORT, 16L, arr.getData(), 0, arr.getData().length);\n-            case DataBufferInt arr ->\n-                    MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, 16L, arr.getData(), 0, arr.getData().length);\n-            case DataBufferByte arr ->\n-                    MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_BYTE, 16L, arr.getData(), 0, arr.getData().length);\n-            default -> throw new IllegalStateException(\"Unexpected value: \" + dataBuffer);\n-        }\n-        return (T) this;\n-    }\n-\n-    default <T extends ImageBuffer> T syncToRaster(BufferedImage bufferedImage) { \/\/ int[], byte[], short[]\n-        return syncToRasterDataBuffer(bufferedImage.getRaster().getDataBuffer());\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    default <T extends ImageBuffer> T syncFromRasterDataBuffer(DataBuffer dataBuffer) { \/\/ int[], byte[], short[]\n-        switch (dataBuffer) {\n-            case DataBufferInt arr ->\n-                    MemorySegment.copy(arr.getData(), 0, Buffer.getMemorySegment(this), JAVA_INT, 16L, arr.getData().length);\n-            case DataBufferByte arr ->\n-                    MemorySegment.copy(arr.getData(), 0, Buffer.getMemorySegment(this), JAVA_BYTE, 16L, arr.getData().length);\n-            case DataBufferUShort arr ->\n-                    MemorySegment.copy(arr.getData(), 0, Buffer.getMemorySegment(this), JAVA_SHORT, 16L, arr.getData().length);\n-            default -> throw new IllegalStateException(\"Unexpected value: \" + dataBuffer);\n-        }\n-        return (T) this;\n-    }\n-\n-    default <T extends ImageBuffer> T syncFromRaster(BufferedImage bufferedImage) { \/\/ int[], byte[], short[]\n-        return syncFromRasterDataBuffer(bufferedImage.getRaster().getDataBuffer());\n-    }\n-\n-    int width();\n-\n-    int height();\n-\n-    default int size() {\n-        return width() * height();\n-    }\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ImageBuffer.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -0,0 +1,50 @@\n+package hat.buffer;\n+\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferByte;\n+import java.awt.image.DataBufferInt;\n+import java.awt.image.DataBufferUShort;\n+import java.lang.foreign.MemorySegment;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+\n+public interface ImageIfaceBuffer<T extends ImageIfaceBuffer<?>> extends IncompleteBuffer {\n+    @SuppressWarnings(\"unchecked\")\n+    default T syncFromRasterDataBuffer(DataBuffer dataBuffer) { \/\/ int[], byte[], short[]\n+        switch (dataBuffer) {\n+            case DataBufferInt arr ->\n+                    MemorySegment.copy(arr.getData(), 0, Buffer.getMemorySegment(this), JAVA_INT, 16L, arr.getData().length);\n+            case DataBufferByte arr ->\n+                    MemorySegment.copy(arr.getData(), 0, Buffer.getMemorySegment(this), JAVA_BYTE, 16L, arr.getData().length);\n+            case DataBufferUShort arr ->\n+                    MemorySegment.copy(arr.getData(), 0, Buffer.getMemorySegment(this), JAVA_SHORT, 16L, arr.getData().length);\n+            default -> throw new IllegalStateException(\"Unexpected value: \" + dataBuffer);\n+        }\n+        return (T)this;\n+    }\n+\n+    default T syncFromRaster(BufferedImage bufferedImage) { \/\/ int[], byte[], short[]\n+        return syncFromRasterDataBuffer(bufferedImage.getRaster().getDataBuffer());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default T syncToRasterDataBuffer(DataBuffer dataBuffer) { \/\/ int[], byte[], short[]\n+        switch (dataBuffer) {\n+            case DataBufferUShort arr ->\n+                    MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_SHORT, 16L, arr.getData(), 0, arr.getData().length);\n+            case DataBufferInt arr ->\n+                    MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, 16L, arr.getData(), 0, arr.getData().length);\n+            case DataBufferByte arr ->\n+                    MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_BYTE, 16L, arr.getData(), 0, arr.getData().length);\n+            default -> throw new IllegalStateException(\"Unexpected value: \" + dataBuffer);\n+        }\n+        return (T) this;\n+    }\n+\n+    default T syncToRaster(BufferedImage bufferedImage) { \/\/ int[], byte[], short[]\n+        return syncToRasterDataBuffer(bufferedImage.getRaster().getDataBuffer());\n+    }\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ImageIfaceBuffer.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+package hat.buffer;\n+\n+import hat.ifacemapper.Schema;\n+\n+public interface S08x3RGBImage extends ImageIfaceBuffer<S08x3RGBImage> {\n+    byte data(long idx);\n+    void data(long idx, byte v);\n+    int width();\n+    void width(int width);\n+    int height();\n+    void height(int height);\n+    Schema<S08x3RGBImage> schema = Schema.of(S08x3RGBImage.class, s -> s\n+            .arrayLen(\"width\", \"height\").stride(3).array(\"data\")\n+    );\n+\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S08x3RGBImage.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ifacemapper.Schema;\n@@ -35,9 +36,1 @@\n-public interface S32Array extends Array1D {\n-    StructLayout layout  = Array1D.getLayout(S32Array.class, JAVA_INT);\n-    static S32Array create(BufferAllocator bufferAllocator, int length) {\n-        return Array1D.create(bufferAllocator, S32Array.class,layout, length);\n-    }\n-\n-    static S32Array create(BufferAllocator bufferAllocator, int[] source) {\n-        return create(bufferAllocator, source.length).copyfrom(source);\n-    }\n+public interface S32Array extends IncompleteBuffer {\n@@ -45,0 +38,2 @@\n+    int length();\n+    void length(int i);\n@@ -46,0 +41,3 @@\n+    void array(long idx, int i);\n+    Schema<S32Array> schema = Schema.of(S32Array.class, s32Array->s32Array\n+            .arrayLen(\"length\").array(\"array\"));\n@@ -47,4 +45,2 @@\n-    void array(long idx, int f);\n-\n-    default S32Array copyfrom(int[] floats) {\n-        MemorySegment.copy(floats, 0, Buffer.getMemorySegment(this), JAVA_INT, 4, length());\n+    default S32Array copyfrom(int[] ints) {\n+        MemorySegment.copy(ints, 0, Buffer.getMemorySegment(this), JAVA_INT, 4, length());\n@@ -54,2 +50,2 @@\n-    default S32Array copyTo(int[] floats) {\n-        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, 4, floats, 0, length());\n+    default S32Array copyTo(int[] ints) {\n+        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, 4, ints, 0, length());\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ifacemapper.Schema;\n@@ -33,5 +34,1 @@\n-public interface S32Array2D extends Array2D {\n-    StructLayout layout  = Array2D.getLayout(S32Array2D.class, JAVA_INT);\n-    static S32Array2D create(BufferAllocator bufferAllocator, int width, int height) {\n-        return Array2D.create(bufferAllocator, S32Array2D.class, layout, width, height);\n-    }\n+public interface S32Array2D extends IncompleteBuffer {\n@@ -39,0 +36,6 @@\n+    int width();\n+    void height(int i);\n+    int height();\n+    void width(int i);\n+    Schema<S32Array2D> schema = Schema.of(S32Array2D.class, s32Array->s32Array\n+            .arrayLen(\"width\",\"height\").stride(1).array(\"array\"));\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32Array2D.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+import hat.ifacemapper.Schema;\n+\n+public interface S32RGBAImage extends ImageIfaceBuffer<S32RGBAImage> {\n+    int data(long idx);\n+\n+    void data(long idx, int v);\n+\n+    int width();\n+    void width(int width);\n+    int height();\n+    void height(int height);\n+    Schema<S32RGBAImage> schema = Schema.of(S32RGBAImage.class, s -> s\n+            .arrayLen(\"width\", \"height\").stride(1).array(\"data\")\n+    );\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32RGBAImage.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-public interface Table<T> extends IncompleteBuffer {\n-    int length();\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Table.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+import hat.ifacemapper.Schema;\n+\n+public interface U16GreyImage extends ImageIfaceBuffer<U16GreyImage> {\n+    short data(long idx);\n+    void data(long idx, short v);\n+    int width();\n+    void width(int width);\n+    int height();\n+    void height(int height);\n+    Schema<U16GreyImage> schema = Schema.of(U16GreyImage.class, s -> s\n+            .arrayLen(\"width\", \"height\").stride(1).array(\"data\")\n+    );\n+\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/U16GreyImage.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -501,2 +501,2 @@\n-            private TypeSchemaNode fieldControlledArray(String name, ArrayLen arrayLen) {\n-                addField(new FieldControlledArray(this,  modeOf(type, name), typeOf(type, name),name, arrayLen));\n+            private TypeSchemaNode fieldControlledArray(String name, List<ArrayLen> arrayLenFields, int stride) {\n+                addField(new FieldControlledArray(this,  modeOf(type, name), typeOf(type, name),name, arrayLenFields, stride));\n@@ -508,2 +508,2 @@\n-                ArrayLen arrayLenField;\n-\n+                List<ArrayLen> arrayLenFields;\n+                int stride=1;\n@@ -511,1 +511,5 @@\n-                    return typeSchemaNode.fieldControlledArray(name, arrayLenField);\n+                    return typeSchemaNode.fieldControlledArray(name, arrayLenFields, stride);\n+                }\n+                public ArrayBuildState stride(int stride) {\n+                    this.stride = stride;\n+                    return this;\n@@ -513,1 +517,0 @@\n-\n@@ -516,1 +519,1 @@\n-                    this.typeSchemaNode.fieldControlledArray(name, arrayLenField);\n+                    this.typeSchemaNode.fieldControlledArray(name, arrayLenFields, stride);\n@@ -525,1 +528,1 @@\n-                ArrayBuildState(TypeSchemaNode typeSchemaNode, ArrayLen arrayLenField) {\n+                ArrayBuildState(TypeSchemaNode typeSchemaNode, List<ArrayLen> arrayLenFields) {\n@@ -527,1 +530,1 @@\n-                    this.arrayLenField = arrayLenField;\n+                    this.arrayLenFields = arrayLenFields;\n@@ -531,4 +534,8 @@\n-            public ArrayBuildState arrayLen(String arrayLenFieldName) {\n-                var arrayLenField = new ArrayLen(this, modeOf(type, arrayLenFieldName), typeOf(type, arrayLenFieldName),arrayLenFieldName );\n-                addField(arrayLenField);\n-                return new ArrayBuildState(this, arrayLenField);\n+            public ArrayBuildState arrayLen(String ... arrayLenFieldNames) {\n+                 List<ArrayLen> arrayLenFields = new ArrayList<>();\n+                 Arrays.stream(arrayLenFieldNames).forEach(arrayLenFieldName-> {\n+                    var arrayLenField = new ArrayLen(this, modeOf(type, arrayLenFieldName), typeOf(type, arrayLenFieldName), arrayLenFieldName);\n+                    addField(arrayLenField);\n+                    arrayLenFields.add(arrayLenField);\n+                });\n+                return new ArrayBuildState(this, arrayLenFields);\n@@ -629,3 +636,3 @@\n-            ArrayLen arrayLen;\n-\n-            FieldControlledArray(TypeSchemaNode parent,   Mode mode, Class<?> type,String name, ArrayLen arrayLen) {\n+            List<ArrayLen> arrayLenFields;\n+            int stride;\n+            FieldControlledArray(TypeSchemaNode parent,   Mode mode, Class<?> type,String name, List<ArrayLen> arrayLenFields, int stride) {\n@@ -633,1 +640,2 @@\n-                this.arrayLen = arrayLen;\n+                this.arrayLenFields = arrayLenFields;\n+                this.stride = stride;\n@@ -638,1 +646,1 @@\n-                stringConsumer.accept(indent + name + \"[\" + mode+\":\"+type + \"] where len defined by \" + arrayLen.type);\n+                stringConsumer.accept(indent + name + \"[\" + mode+\":\"+type + \"] where len defined by \" + arrayLenFields);\n@@ -643,0 +651,6 @@\n+                \/\/ We have more than one ArrayLen\n+                int i=stride;\n+                for (int c = 0 ; c<arrayLenFields.size(); c++ ){\n+                   var v =  layoutToFieldBindingNode.takeArrayLen();\n+                   i*=v;\n+                }\n@@ -644,1 +658,1 @@\n-                        layoutToFieldBindingNode.takeArrayLen(),\n+                       i,\/\/ layoutToFieldBindingNode.takeArrayLen(),\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":33,"deletions":19,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n-        var arr = S32Array.create(accelerator, 32);\n+        var arr = S32Array.schema.allocate(accelerator, 32);\n+        arr.length(32);\n","filename":"hat\/hat\/src\/main\/test\/hat\/SquaresTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}