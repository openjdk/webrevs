{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -62,1 +63,1 @@\n-            Object preResult = Interpreter.invoke(preFunc,5);\n+            Object preResult = Interpreter.invoke(MethodHandles.lookup(),preFunc,5);\n@@ -64,1 +65,1 @@\n-            Object postResult = Interpreter.invoke(postFunc,5);\n+            Object postResult = Interpreter.invoke(MethodHandles.lookup(),postFunc,5);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrePostInc.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,4 +28,1 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n+import java.util.*;\n@@ -42,1 +39,3 @@\n-    private final Map<Value, Object> capturedValues;\n+    private final SequencedMap<Value, Object> capturedValues;\n+\n+    static final SequencedMap<Value, Object> EMPTY_SEQUENCED_MAP = new LinkedHashMap<>();\n@@ -50,1 +49,1 @@\n-        this(op, Map.of());\n+        this(op, EMPTY_SEQUENCED_MAP);\n@@ -66,1 +65,1 @@\n-    public Quoted(Op op, Map<Value, Object> capturedValues) {\n+    public Quoted(Op op, SequencedMap<Value, Object> capturedValues) {\n@@ -71,1 +70,1 @@\n-        this.capturedValues = Collections.unmodifiableMap(new LinkedHashMap<>(capturedValues));\n+        this.capturedValues = Collections.unmodifiableSequencedMap(new LinkedHashMap<>(capturedValues));\n@@ -94,1 +93,1 @@\n-    public Map<Value, Object> capturedValues() {\n+    public SequencedMap<Value, Object> capturedValues() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Quoted.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -52,0 +51,68 @@\n+    \/**\n+     * Invokes an invokable operation by interpreting the code elements within\n+     * the operations body.\n+     * <p>\n+     * The sequence of arguments must consists of objects corresponding, in order,\n+     * to the invokable operation's {@link Op.Invokable#parameters() parameters}.\n+     * If the invokable operation {@link Op.Invokable#capturedValues() captures values}\n+     * then the sequence of arguments must be appended with objects corresponding,\n+     * in order, to the captured values.\n+     *\n+     * @param l the lookup to use for interpreting reflective operations.\n+     * @param op the invokeable operation to interpret.\n+     * @param args the invokeable's arguments appended with captured arguments, if any.\n+     * @return the interpreter result of invokable operation.\n+     * @param <T> the type of Invokable.\n+     * @throws InterpreterException if there is a failure to interpret\n+     * @throws Throwable if interpretation results in the throwing of an uncaught exception\n+     *\/\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(MethodHandles.Lookup l, T op,\n+                  Object... args) {\n+        \/\/ Arguments can contain null values so we cannot use List.of\n+        return invoke(l, op, Arrays.asList(args));\n+    }\n+\n+    \/**\n+     * Invokes an invokable operation by interpreting the code elements within\n+     * the operations body.\n+     * <p>\n+     * The list of arguments must consists of objects corresponding, in order,\n+     * to the invokable operation's {@link Op.Invokable#parameters() parameters}.\n+     * If the invokable operation {@link Op.Invokable#capturedValues() captures values}\n+     * then the list of arguments must be appended with objects corresponding,\n+     * in order, to the captured values.\n+     *\n+     * @param l the lookup to use for interpreting reflective operations.\n+     * @param op the invokeable operation to interpret.\n+     * @param args the invokeable's arguments appended with captured arguments, if any.\n+     * @return the interpreter result of invokable operation.\n+     * @param <T> the type of Invokable.\n+     * @throws InterpreterException if there is a failure to interpret\n+     * @throws Throwable if interpretation results in the throwing of an uncaught exception\n+     *\/\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(MethodHandles.Lookup l, T op,\n+                  List<Object> args) {\n+        List<Block.Parameter> parameters = op.parameters();\n+        List<Value> capturedValues = op.capturedValues();\n+        if (parameters.size() + capturedValues.size() != args.size()) {\n+            throw interpreterException(new IllegalArgumentException(\n+                    String.format(\"Actual #arguments (%d) differs from #parameters (%d) plus #captured arguments (%d)\",\n+                            args.size(), parameters.size(), capturedValues.size())));\n+        }\n+\n+        \/\/ Map symbolic parameters to runtime arguments\n+        Map<Value, Object> valuesAndArguments = new HashMap<>();\n+        for (int i = 0; i < parameters.size(); i++) {\n+            valuesAndArguments.put(parameters.get(i), args.get(i));\n+        }\n+        \/\/ Map symbolic captured values to the additional runtime arguments\n+        for (int i = 0; i < capturedValues.size(); i++) {\n+            valuesAndArguments.put(capturedValues.get(i), args.get(parameters.size() + i));\n+        }\n+\n+        return interpretEntryBlock(l, op.body().entryBlock(), new OpContext(), valuesAndArguments);\n+    }\n+\n+\n@@ -53,2 +120,2 @@\n-    public static class InterpreterException extends RuntimeException {\n-        public InterpreterException(Throwable cause) {\n+    public static final class InterpreterException extends RuntimeException {\n+        private InterpreterException(Throwable cause) {\n@@ -63,1 +130,1 @@\n-    record BlockContext(Block b, Map<Value, Object> values) {\n+    record BlockContext(Block b, Map<Value, Object> valuesAndArguments) {\n@@ -66,2 +133,0 @@\n-    static final ConcurrentHashMap<Object, ReentrantLock> locks = new ConcurrentHashMap<>();\n-\n@@ -77,1 +142,1 @@\n-                return bc.values.get(v);\n+                return bc.valuesAndArguments.get(v);\n@@ -88,1 +153,1 @@\n-            stack.peek().values.put(v, o);\n+            stack.peek().valuesAndArguments.put(v, o);\n@@ -93,1 +158,1 @@\n-            Optional<BlockContext> ob = stack.stream().filter(b -> b.values.containsKey(v)).findFirst();\n+            Optional<BlockContext> ob = stack.stream().filter(b -> b.valuesAndArguments.containsKey(v)).findFirst();\n@@ -184,1 +249,1 @@\n-                         Map<Value, Object> capturedValues) {\n+                         List<Object> capturedArguments) {\n@@ -216,37 +281,8 @@\n-    public static <T extends Op & Op.Invokable>\n-    Object invoke(T op,\n-                  Object... args) {\n-        return invoke(MethodHandles.publicLookup(), op, args);\n-    }\n-\n-    public static <T extends Op & Op.Invokable>\n-    Object invoke(MethodHandles.Lookup l, T op,\n-                  Object... args) {\n-        return invoke(l, op, new ArrayList<>(Arrays.asList(args)));\n-    }\n-\n-    public static <T extends Op & Op.Invokable>\n-    Object invoke(MethodHandles.Lookup l, T op,\n-                  Map<Value, Object> capturedValues,\n-                  Object... args) {\n-        return invoke(l, op, capturedValues, new ArrayList<>(Arrays.asList(args)));\n-    }\n-\n-    public static <T extends Op & Op.Invokable>\n-    Object invoke(T op,\n-                  List<Object> args) {\n-        return invoke(MethodHandles.publicLookup(), op, args);\n-    }\n-\n-    public static <T extends Op & Op.Invokable>\n-    Object invoke(T op,\n-                  Map<Value, Object> capturedValues,\n-                  List<Object> args) {\n-        return invoke(MethodHandles.publicLookup(), op, capturedValues, args);\n-    }\n-\n-    public static <T extends Op & Op.Invokable>\n-    Object invoke(MethodHandles.Lookup l, T op,\n-                  List<Object> args) {\n-        return invoke(l, op, Map.of(), args);\n-    }\n+    static Object interpretBody(MethodHandles.Lookup l, Body body,\n+                                OpContext oc,\n+                                List<Object> args) {\n+        List<Block.Parameter> parameters = body.entryBlock().parameters();\n+        if (parameters.size() != args.size()) {\n+            throw interpreterException(new IllegalArgumentException(\n+                    \"Incorrect number of arguments arguments\"));\n+        }\n@@ -254,6 +290,5 @@\n-    public static <T extends Op & Op.Invokable>\n-    Object invoke(MethodHandles.Lookup l, T invokableOp,\n-                  Map<Value, Object> capturedValues,\n-                  List<Object> args) {\n-        Body r = invokableOp.bodies().get(0);\n-        return invoke(l, r, capturedValues, new OpContext(), args);\n+        \/\/ Map symbolic parameters to runtime arguments\n+        Map<Value, Object> arguments = new HashMap<>();\n+        for (int i = 0; i < parameters.size(); i++) {\n+            arguments.put(parameters.get(i), args.get(i));\n+        }\n@@ -261,5 +296,1 @@\n-    }\n-    static Object invoke(MethodHandles.Lookup l, Body r,\n-                                 Map<Value, Object> capturedValues, OpContext oc,\n-                                 List<Object> args) {\n-        return invoke(l,r.entryBlock(), capturedValues, oc, args);\n+        return interpretEntryBlock(l, body.entryBlock(), oc, arguments);\n@@ -268,3 +299,4 @@\n-    private static Object invoke(MethodHandles.Lookup l, Block first,\n-                  Map<Value, Object> capturedValues, OpContext oc,\n-                  List<Object> args) {\n+    static Object interpretEntryBlock(MethodHandles.Lookup l, Block entry,\n+                                      OpContext oc,\n+                                      Map<Value, Object> valuesAndArguments) {\n+        assert entry.isEntryBlock();\n@@ -272,7 +304,6 @@\n-        if (args.size() != first.parameters().size()) {\n-            throw interpreterException(new IllegalArgumentException(\"Incorrect number of arguments\"));\n-        }\n-        Map<Value, Object> values = new HashMap<>();\n-        for (int i = 0; i < first.parameters().size(); i++) {\n-            values.put(first.parameters().get(i), args.get(i));\n-        }\n+        \/\/ If the stack is not empty it means we are interpreting\n+        \/\/ an entry block with a parent body whose nearest ancestor body\n+        \/\/ is the current context block's parent body\n+        BlockContext yieldContext = oc.stack.peek();\n+        assert yieldContext == null ||\n+                yieldContext.b().parentBody() == entry.parentBody().parentOp().ancestorBody();\n@@ -281,2 +312,1 @@\n-        oc.stack.push(new BlockContext(first, values));\n-        capturedValues.forEach(oc::setValue);\n+        oc.stack.push(new BlockContext(entry, valuesAndArguments));\n@@ -293,1 +323,1 @@\n-                    Object result = exec(l, oc, op);\n+                    Object result = interpretOp(l, oc, op);\n@@ -332,0 +362,4 @@\n+                if (yieldContext == null) {\n+                    throw interpreterException(\n+                            new IllegalStateException(\"Yielding to no parent body\"));\n+                }\n@@ -333,1 +367,3 @@\n-                return yv == null ? null : oc.getValue(yv);\n+                Object yr = yv == null ? null : oc.getValue(yv);\n+                oc.popTo(yieldContext);\n+                return yr;\n@@ -353,6 +389,0 @@\n-    static <T extends Op & Op.Invokable>\n-    Object interpretBody(MethodHandles.Lookup l, Body r,\n-                         OpContext oc) {\n-        return invoke(l, r, Map.of(), oc, List.of());\n-    }\n-\n@@ -386,1 +416,1 @@\n-    static Object exec(MethodHandles.Lookup l, OpContext oc, Op o) {\n+    static Object interpretOp(MethodHandles.Lookup l, OpContext oc, Op o) {\n@@ -412,2 +442,2 @@\n-                Object[] values = o.operands().stream().map(oc::getValue).toArray();\n-                return Interpreter.invoke(funcOp, values);\n+                List<Object> values = o.operands().stream().map(oc::getValue).toList();\n+                return Interpreter.invoke(l, funcOp, values);\n@@ -447,1 +477,1 @@\n-            Map<Value, Object> capturedValues = qo.capturedValues().stream()\n+            SequencedMap<Value, Object> capturedValues = qo.capturedValues().stream()\n@@ -451,1 +481,1 @@\n-            Map<Value, Object> capturedValues = lo.capturedValues().stream()\n+            SequencedMap<Value, Object> capturedValuesAndArguments = lo.capturedValues().stream()\n@@ -455,2 +485,3 @@\n-            MethodHandle fProxy = INVOKE_LAMBDA_MH.bindTo(l).bindTo(lo).bindTo(capturedValues)\n-                    .asCollector(Object[].class, lo.body().entryBlock().parameters().size());\n+            Object[] capturedArguments = capturedValuesAndArguments.sequencedValues().toArray(Object[]::new);\n+            MethodHandle fProxy = INVOKE_LAMBDA_MH.bindTo(l).bindTo(lo).bindTo(capturedArguments)\n+                    .asCollector(Object[].class, lo.parameters().size());\n@@ -465,1 +496,1 @@\n-                                return new Quoted(lo, capturedValues);\n+                                return new Quoted(lo, capturedValuesAndArguments);\n@@ -475,3 +506,3 @@\n-            Map<Value, Object> capturedValues = co.capturedValues().stream()\n-                    .collect(toMap(v -> v, oc::getValue));\n-            return new ClosureRecord(co, capturedValues);\n+            List<Object> capturedArguments = co.capturedValues().stream()\n+                    .map(oc::getValue).toList();\n+            return new ClosureRecord(co, capturedArguments);\n@@ -482,1 +513,3 @@\n-            return Interpreter.invoke(l, cr.op(), cr.capturedValues, values.subList(1, values.size()));\n+            List<Object> arguments = new ArrayList<>(values.subList(1, values.size()));\n+            arguments.addAll(cr.capturedArguments);\n+            return Interpreter.invoke(l, cr.op(), arguments);\n@@ -559,2 +592,0 @@\n-            \/\/Note: The nature of asserts and munged bodies may require a re-visiting.\n-            \/\/This code seems to work without poisoning contexts. See TestAssert.java in tests for relevant test coverage.\n@@ -562,1 +593,1 @@\n-            boolean testResult = (boolean) interpretBody(l, testBody, oc);\n+            boolean testResult = (boolean) interpretBody(l, testBody, oc, List.of());\n@@ -566,1 +597,1 @@\n-                    String message = String.valueOf(interpretBody(l, messageBody, oc));\n+                    String message = String.valueOf(interpretBody(l, messageBody, oc, List.of()));\n@@ -608,1 +639,1 @@\n-                            CoreOp.LambdaOp.class, Map.class, Object[].class));\n+                            CoreOp.LambdaOp.class, Object[].class, Object[].class));\n@@ -614,2 +645,4 @@\n-    static Object invokeLambda(MethodHandles.Lookup l, CoreOp.LambdaOp op, Map<Value, Object> capturedValues, Object[] args) {\n-        return invoke(l, op, capturedValues, args);\n+    static Object invokeLambda(MethodHandles.Lookup l, CoreOp.LambdaOp op, Object[] capturedArgs, Object[] args) {\n+        List<Object> arguments = new ArrayList<>(Arrays.asList(args));\n+        arguments.addAll(Arrays.asList(capturedArgs));\n+        return invoke(l, op, arguments);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":130,"deletions":97,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -257,0 +257,1 @@\n+    public final MethodSymbol methodHandlesLookup;\n@@ -653,0 +654,5 @@\n+        methodHandlesLookup = new MethodSymbol(PUBLIC | STATIC,\n+                names.fromString(\"lookup\"),\n+                new MethodType(List.nil(), methodHandleLookupType,\n+                        List.nil(), methodClass),\n+                methodHandlesType.tsym);\n@@ -655,1 +661,1 @@\n-                new MethodType(List.of(opType, new ArrayType(objectType, arrayClass)), objectType,\n+                new MethodType(List.of(methodHandleLookupType, opType, new ArrayType(objectType, arrayClass)), objectType,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -246,0 +246,2 @@\n+                        \/\/ @@@ Consider replacing with invokedynamic to quoted bootstrap method\n+                        \/\/ Thereby we avoid certain dependencies and hide specific details\n@@ -248,0 +250,5 @@\n+                        \/\/ Obtain MethodHandles.lookup()\n+                        \/\/ @@@ Could probably use MethodHandles.publicLookup()\n+                        JCMethodInvocation lookup = make.App(make.Ident(syms.methodHandlesLookup), com.sun.tools.javac.util.List.nil());\n+                        interpreterArgs.append(lookup);\n+                        \/\/ Deserialize the func operation\n@@ -250,1 +257,1 @@\n-                        \/\/ append captured vars\n+                        \/\/ Append captured vars\n@@ -254,0 +261,1 @@\n+                        \/\/ Interpret the func operation to produce the quoted instance\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -51,1 +52,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f), f());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f), f());\n@@ -65,1 +66,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f), f2());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f), f2());\n@@ -79,1 +80,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f), f3());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f), f3());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayCreation.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -51,1 +52,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f), f());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f), f());\n@@ -65,1 +66,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f), f2());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f), f2());\n@@ -79,1 +80,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f), f3());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f), f3());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayTypes.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -52,2 +53,2 @@\n-        Assert.assertEquals(Interpreter.invoke(f, true), not(true));\n-        Assert.assertEquals(Interpreter.invoke(f, false), not(false));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, true), not(true));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, false), not(false));\n@@ -67,1 +68,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f, 42), neg(42));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, 42), neg(42));\n@@ -81,1 +82,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f, 42), compl(42));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, 42), compl(42));\n@@ -95,1 +96,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f, 10, 3), mod(10, 3));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, 10, 3), mod(10, 3));\n@@ -109,1 +110,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f, 10, 3), bitand(10, 3));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, 10, 3), bitand(10, 3));\n@@ -123,1 +124,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f, 10, 3), bitor(10, 3));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, 10, 3), bitor(10, 3));\n@@ -137,1 +138,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f, 10, 3), bitxor(10, 3));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, 10, 3), bitxor(10, 3));\n@@ -151,1 +152,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f, true, false), booland(true, false));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, true, false), booland(true, false));\n@@ -165,1 +166,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f, false, true), boolor(false, true));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, false, true), boolor(false, true));\n@@ -179,1 +180,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f, true, true), boolxor(true, true));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, true, true), boolxor(true, true));\n@@ -193,1 +194,1 @@\n-        Assert.assertEquals(Interpreter.invoke(f, 15.6, 2.1), doublemod(15.6, 2.1));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, 15.6, 2.1), doublemod(15.6, 2.1));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBinops.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -29,1 +30,0 @@\n-import java.lang.reflect.code.Op;\n@@ -77,1 +77,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf), f());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf), f());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -34,1 +35,0 @@\n-import java.lang.reflect.code.Op;\n@@ -76,1 +76,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, o), forLoopBreakContinue(o));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, o), forLoopBreakContinue(o));\n@@ -118,1 +118,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lf, o), nestedForLoopBreakContinue(o));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, o), nestedForLoopBreakContinue(o));\n@@ -166,1 +166,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lf, o), forLoopLabeledBreakContinue(o));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, o), forLoopLabeledBreakContinue(o));\n@@ -216,1 +216,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lf, o), blockBreak(o));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, o), blockBreak(o));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBreakContinue.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -62,0 +64,3 @@\n+            List<Object> arguments = new ArrayList<>();\n+            arguments.add(42);\n+            arguments.addAll(c.capturedValues().values());\n@@ -63,1 +68,1 @@\n-                    c.capturedValues(), 42);\n+                    arguments);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -34,1 +35,0 @@\n-import java.lang.reflect.code.Op;\n@@ -57,2 +57,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, true, 1, 2), simpleExpression(true, 1, 2));\n-        Assert.assertEquals(Interpreter.invoke(lf, false, 1, 2), simpleExpression(false, 1, 2));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, true, 1, 2), simpleExpression(true, 1, 2));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, false, 1, 2), simpleExpression(false, 1, 2));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalExpression.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -35,1 +36,0 @@\n-import java.lang.reflect.code.Op;\n@@ -165,1 +165,1 @@\n-            Assert.assertEquals(Interpreter.invoke(f), m.invoke(null));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f), m.invoke(null));\n@@ -188,1 +188,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, (Object) null), compareNull(null));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, (Object) null), compareNull(null));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConstants.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -29,1 +30,0 @@\n-import java.lang.reflect.code.Op;\n@@ -72,1 +72,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf), f());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf), f());\n@@ -96,1 +96,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, ia), array(ia));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, ia), array(ia));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestEnhancedForOp.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -29,1 +30,0 @@\n-import java.lang.reflect.code.Op;\n@@ -62,1 +62,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf), f());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf), f());\n@@ -85,1 +85,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf), f2());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf), f2());\n@@ -110,1 +110,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf), f3());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf), f3());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestForOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -29,1 +30,0 @@\n-import java.lang.reflect.code.Op;\n@@ -80,1 +80,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lf, i), f(i));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, i), f(i));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestIfOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,3 @@\n+            List<Object> arguments = new ArrayList<>();\n+            arguments.add(42);\n+            arguments.addAll(l.capturedValues().values());\n@@ -66,1 +69,1 @@\n-                    l.capturedValues(), 42);\n+                    arguments);\n@@ -184,1 +187,2 @@\n-            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), q.capturedValues(), List.of());\n+            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(),\n+                    new ArrayList<>(q.capturedValues().sequencedValues()));\n@@ -187,5 +191,2 @@\n-            Map<Value, Object> cvs = Map.of(\n-                    q.capturedValues().keySet().iterator().next(),\n-                    CoreOp.Var.of(0)\n-            );\n-            r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), cvs, List.of());\n+            r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(),\n+                    List.of(CoreOp.Var.of(0)));\n@@ -205,1 +206,2 @@\n-            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), q.capturedValues(), List.of());\n+            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(),\n+                    new ArrayList<>(q.capturedValues().sequencedValues()));\n@@ -208,5 +210,2 @@\n-            Map<Value, Object> cvs = Map.of(\n-                    q.capturedValues().keySet().iterator().next(),\n-                    CoreOp.Var.of(0)\n-            );\n-            r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), cvs, List.of());\n+            r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(),\n+                    List.of(CoreOp.Var.of(0)));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, v), mh.invoke(v));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, v), mh.invoke(v));\n@@ -181,1 +181,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, Short.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Short.MAX_VALUE), true);\n@@ -197,2 +197,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, Byte.MAX_VALUE), true);\n-        Assert.assertEquals(Interpreter.invoke(lf, Byte.MIN_VALUE), false);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Byte.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Byte.MIN_VALUE), false);\n@@ -214,2 +214,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n-        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Integer.MIN_VALUE), true);\n@@ -231,2 +231,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n-        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Integer.MIN_VALUE), true);\n@@ -248,2 +248,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, 1), true);\n-        Assert.assertEquals(Interpreter.invoke(lf, (short) 1), false);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, 1), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, (short) 1), false);\n@@ -265,2 +265,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n-        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Integer.MIN_VALUE), true);\n@@ -282,2 +282,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n-        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Integer.MIN_VALUE), true);\n@@ -299,2 +299,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, (Object) null), false);\n-        Assert.assertEquals(Interpreter.invoke(lf, \"str\"), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, (Object) null), false);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, \"str\"), true);\n@@ -316,4 +316,4 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, Float.MAX_VALUE), true);\n-        Assert.assertEquals(Interpreter.invoke(lf, Float.MIN_VALUE), true);\n-        Assert.assertEquals(Interpreter.invoke(lf, Float.POSITIVE_INFINITY), true);\n-        Assert.assertEquals(Interpreter.invoke(lf, Float.NEGATIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Float.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Float.MIN_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Float.POSITIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Float.NEGATIVE_INFINITY), true);\n@@ -335,4 +335,4 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, Float.MAX_VALUE), false);\n-        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), false);\n-        Assert.assertEquals(Interpreter.invoke(lf, Double.POSITIVE_INFINITY), true);\n-        Assert.assertEquals(Interpreter.invoke(lf, Double.NEGATIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Float.MAX_VALUE), false);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Integer.MIN_VALUE), false);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Double.POSITIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Double.NEGATIVE_INFINITY), true);\n@@ -354,2 +354,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n-        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, Integer.MIN_VALUE), true);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -46,1 +47,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf), Interpreter.invoke(lf2));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf), Interpreter.invoke(MethodHandles.lookup(), lf2));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestRemoveFinalVars.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -29,1 +30,0 @@\n-import java.lang.reflect.code.Op;\n@@ -62,2 +62,2 @@\n-        Assert.assertEquals((int) Interpreter.invoke(lf, 0, 0, 1), ifelse(0, 0, 1));\n-        Assert.assertEquals((int) Interpreter.invoke(lf, 0, 0, 11), ifelse(0, 0, 11));\n+        Assert.assertEquals((int) Interpreter.invoke(MethodHandles.lookup(), lf, 0, 0, 1), ifelse(0, 0, 1));\n+        Assert.assertEquals((int) Interpreter.invoke(MethodHandles.lookup(), lf, 0, 0, 11), ifelse(0, 0, 11));\n@@ -93,1 +93,1 @@\n-            Assert.assertEquals((int) Interpreter.invoke(lf, 0, 0, 0, 0, i), ifelseNested(0, 0, 0, 0, i));\n+            Assert.assertEquals((int) Interpreter.invoke(MethodHandles.lookup(), lf, 0, 0, 0, 0, i), ifelseNested(0, 0, 0, 0, i));\n@@ -112,1 +112,1 @@\n-        Assert.assertEquals((int) Interpreter.invoke(lf, 10), loop(10));\n+        Assert.assertEquals((int) Interpreter.invoke(MethodHandles.lookup(), lf, 10), loop(10));\n@@ -132,1 +132,1 @@\n-        Assert.assertEquals((int) Interpreter.invoke(lf, 10), nestedLoop(10));\n+        Assert.assertEquals((int) Interpreter.invoke(MethodHandles.lookup(), lf, 10), nestedLoop(10));\n@@ -151,1 +151,1 @@\n-        Assert.assertEquals((int) Interpreter.invoke(lf, 10), nestedLambdaCapture(10));\n+        Assert.assertEquals((int) Interpreter.invoke(MethodHandles.lookup(), lf, 10), nestedLambdaCapture(10));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSSA.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -104,2 +105,2 @@\n-        var interpreted = Interpreter.invoke(model, args);\n-        var transformed_interpreted = Interpreter.invoke(f_transformed, args);\n+        var interpreted = Interpreter.invoke(MethodHandles.lookup(), model, args);\n+        var transformed_interpreted = Interpreter.invoke(MethodHandles.lookup(), f_transformed, args);\n@@ -139,4 +140,4 @@\n-        var model_interpreted = Interpreter.invoke(model, args);\n-        var transformed_model_interpreted = Interpreter.invoke(transformed_model, args);\n-        var ssa_interpreted = Interpreter.invoke(ssa_model, args);\n-        var ssa_transformed_interpreted = Interpreter.invoke(ssa_transformed_model, args);\n+        var model_interpreted = Interpreter.invoke(MethodHandles.lookup(), model, args);\n+        var transformed_model_interpreted = Interpreter.invoke(MethodHandles.lookup(), transformed_model, args);\n+        var ssa_interpreted = Interpreter.invoke(MethodHandles.lookup(), ssa_model, args);\n+        var ssa_transformed_interpreted = Interpreter.invoke(MethodHandles.lookup(), ssa_transformed_model, args);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringConcatTransform.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseTypePattern(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseTypePattern(arg));\n@@ -84,1 +84,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternWithCaseConstant(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), casePatternWithCaseConstant(arg));\n@@ -104,1 +104,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternMultiLabel(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), casePatternMultiLabel(arg));\n@@ -123,1 +123,1 @@\n-            Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, arg));\n+            Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(MethodHandles.lookup(), lmodel, arg));\n@@ -128,1 +128,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternThrow(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), casePatternThrow(arg));\n@@ -150,2 +150,2 @@\n-            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n-            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), ruleExpression, arg), Interpreter.invoke(MethodHandles.lookup(), ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), ruleExpression, arg), Interpreter.invoke(MethodHandles.lookup(), statement, arg));\n@@ -248,1 +248,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantFallThrough(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseConstantFallThrough(arg));\n@@ -278,1 +278,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantNullLabel(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseConstantNullLabel(arg));\n@@ -293,1 +293,1 @@\n-        Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, 8));\n+        Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(MethodHandles.lookup(), lmodel, 8));\n@@ -296,1 +296,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantThrow(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseConstantThrow(arg));\n@@ -314,1 +314,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantMultiLabels(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseConstantMultiLabels(arg));\n@@ -335,2 +335,2 @@\n-            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n-            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), ruleExpression, arg), Interpreter.invoke(MethodHandles.lookup(), ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), ruleExpression, arg), Interpreter.invoke(MethodHandles.lookup(), statement, arg));\n@@ -383,1 +383,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantConv(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseConstantConv(arg));\n@@ -404,1 +404,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantConv2(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseConstantConv2(arg));\n@@ -423,1 +423,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), unconditionalPattern(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), unconditionalPattern(arg));\n@@ -441,1 +441,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), defaultCaseNotTheLast(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), defaultCaseNotTheLast(arg));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n-            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), ruleExpression, arg), Interpreter.invoke(MethodHandles.lookup(), ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), ruleExpression, arg), Interpreter.invoke(MethodHandles.lookup(), statement, arg));\n@@ -93,1 +93,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantMultiLabels(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseConstantMultiLabels(arg));\n@@ -114,1 +114,1 @@\n-        Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, 8));\n+        Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(MethodHandles.lookup(), lmodel, 8));\n@@ -118,1 +118,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantThrow(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseConstantThrow(arg));\n@@ -138,1 +138,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantNullLabel(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseConstantNullLabel(arg));\n@@ -157,1 +157,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantFallThrough(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseConstantFallThrough(arg));\n@@ -279,1 +279,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, i), nonEnhancedSwStatNoDefault(i));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, i), nonEnhancedSwStatNoDefault(i));\n@@ -301,1 +301,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), enhancedSwStatUnconditionalPattern(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), enhancedSwStatUnconditionalPattern(arg));\n@@ -324,2 +324,2 @@\n-            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n-            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), ruleExpression, arg), Interpreter.invoke(MethodHandles.lookup(), ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), ruleExpression, arg), Interpreter.invoke(MethodHandles.lookup(), statement, arg));\n@@ -379,1 +379,1 @@\n-            Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, arg));\n+            Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(MethodHandles.lookup(), lmodel, arg));\n@@ -384,1 +384,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternThrow(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), casePatternThrow(arg));\n@@ -406,1 +406,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternWithCaseConstant(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), casePatternWithCaseConstant(arg));\n@@ -428,1 +428,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseTypePattern(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseTypePattern(arg));\n@@ -494,1 +494,1 @@\n-            Assert.assertEquals(Interpreter.invoke(lmodel, arg), defaultCaseNotTheLast(arg));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), defaultCaseNotTheLast(arg));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchStatementOp.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.Executable;\n@@ -80,1 +79,1 @@\n-        Interpreter.invoke(module.functionTable().firstEntry().getValue(), 10, r);\n+        Interpreter.invoke(MethodHandles.lookup(), module.functionTable().firstEntry().getValue(), 10, r);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTransitiveInvokeModule.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -76,1 +77,1 @@\n-        Assert.assertThrows(Interpreter.InterpreterException.class, () -> Interpreter.invoke(f, 1));\n+        Assert.assertThrows(Interpreter.InterpreterException.class, () -> Interpreter.invoke(MethodHandles.lookup(), f, 1));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestUninitializedVariable.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -29,1 +30,0 @@\n-import java.lang.reflect.code.Op;\n@@ -62,1 +62,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf), whileLoop());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf), whileLoop());\n@@ -84,1 +84,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf), doWhileLoop());\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf), doWhileLoop());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestWhileOp.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.reflect.code.Op;\n@@ -59,2 +58,2 @@\n-        Assert.assertEquals(Interpreter.invoke(f, 0.0, 1.0), f(0.0, 1.0));\n-        Assert.assertEquals(Interpreter.invoke(f, PI_4, PI_4), f(PI_4, PI_4));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, 0.0, 1.0), f(0.0, 1.0));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, PI_4, PI_4), f(PI_4, PI_4));\n@@ -102,3 +101,3 @@\n-        Assert.assertEquals(Interpreter.invoke(f, 2.0, 6), fcf(2.0, 6));\n-        Assert.assertEquals(Interpreter.invoke(f, 2.0, 5), fcf(2.0, 5));\n-        Assert.assertEquals(Interpreter.invoke(f, 2.0, 4), fcf(2.0, 4));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, 2.0, 6), fcf(2.0, 6));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, 2.0, 5), fcf(2.0, 5));\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, 2.0, 4), fcf(2.0, 4));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/TestForwardAutoDiff.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.lang.runtime.CodeReflection;\n@@ -70,1 +69,1 @@\n-        Assert.assertEquals((int) Interpreter.invoke(f, 42), 42);\n+        Assert.assertEquals((int) Interpreter.invoke(MethodHandles.lookup(), f, 42), 42);\n@@ -85,1 +84,1 @@\n-        Assert.assertEquals((long) Interpreter.invoke(f), 4);\n+        Assert.assertEquals((long) Interpreter.invoke(MethodHandles.lookup(), f), 4);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -46,1 +47,1 @@\n-        Assert.assertEquals((double) Interpreter.invoke(lf, 1.0d), 1.0d);\n+        Assert.assertEquals((double) Interpreter.invoke(MethodHandles.lookup(), lf, 1.0d), 1.0d);\n@@ -53,1 +54,1 @@\n-        Assert.assertEquals((double) Interpreter.invoke(lf, 1.0d, 1.0d), 0.0d);\n+        Assert.assertEquals((double) Interpreter.invoke(MethodHandles.lookup(), lf, 1.0d, 1.0d), 0.0d);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/TestExpressionElimination.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -59,1 +60,2 @@\n-        Interpreter.invoke(lf, List.of(List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 100_000, 20)));\n+        Interpreter.invoke(MethodHandles.lookup(), lf,\n+                List.of(List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 100_000, 20)));\n@@ -89,1 +91,2 @@\n-        List<String> actual = (List<String>) Interpreter.invoke(lf, List.of(source));\n+        List<String> actual = (List<String>) Interpreter.invoke(MethodHandles.lookup(), lf,\n+                List.of(source));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStream.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -58,1 +59,2 @@\n-        Interpreter.invoke(lf, List.of(List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 100_000, 20)));\n+        Interpreter.invoke(MethodHandles.lookup(), lf,\n+                List.of(List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 100_000, 20)));\n@@ -88,1 +90,2 @@\n-        List<String> actual = (List<String>) Interpreter.invoke(lf, List.of(source));\n+        List<String> actual = (List<String>) Interpreter.invoke(MethodHandles.lookup(), lf,\n+                List.of(source));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStreamUsingQuotable.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.List;\n@@ -55,0 +56,3 @@\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n@@ -56,1 +60,1 @@\n-                quoted.capturedValues(), 1);\n+                arguments);\n@@ -71,0 +75,3 @@\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n@@ -72,1 +79,1 @@\n-                quoted.capturedValues(), 1);\n+                arguments);\n@@ -118,0 +125,3 @@\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n@@ -119,1 +129,1 @@\n-                quoted.capturedValues(), 1);\n+                arguments);\n@@ -138,0 +148,3 @@\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n@@ -139,1 +152,1 @@\n-                quoted.capturedValues(), 1);\n+                arguments);\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuotable.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -37,0 +38,1 @@\n+import java.util.List;\n@@ -50,0 +52,3 @@\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n@@ -51,1 +56,1 @@\n-                quoted.capturedValues(), 1);\n+                arguments);\n@@ -72,0 +77,3 @@\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n@@ -73,1 +81,1 @@\n-                quoted.capturedValues(), 1);\n+                arguments);\n@@ -87,0 +95,3 @@\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n@@ -88,1 +99,1 @@\n-                quoted.capturedValues(), 1);\n+                arguments);\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuoted.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"}]}