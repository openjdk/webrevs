{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=24\n+version=25\n@@ -11,1 +11,1 @@\n-branches=\n+branches=.*\n","filename":".jcheck\/conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-        <maven.compiler.source>24<\/maven.compiler.source>\n-        <maven.compiler.target>24<\/maven.compiler.target>\n+        <maven.compiler.source>25<\/maven.compiler.source>\n+        <maven.compiler.target>25<\/maven.compiler.target>\n","filename":"cr-examples\/onnx\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-        <maven.compiler.source>24<\/maven.compiler.source>\n-        <maven.compiler.target>24<\/maven.compiler.target>\n+        <maven.compiler.source>25<\/maven.compiler.source>\n+        <maven.compiler.target>25<\/maven.compiler.target>\n","filename":"cr-examples\/spirv\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-        <maven.compiler.source>24<\/maven.compiler.source>\n-        <maven.compiler.target>24<\/maven.compiler.target>\n+        <maven.compiler.source>25<\/maven.compiler.source>\n+        <maven.compiler.target>25<\/maven.compiler.target>\n@@ -71,1 +71,1 @@\n-                <version>3.11.0<\/version>\n+                <version>3.13.0<\/version>\n","filename":"cr-examples\/triton\/pom.xml","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.ScopedValue;\n@@ -114,1 +115,1 @@\n-            TritonOps.ModuleOp actualTritonKernel = ScopedValue.callWhere(TritonTransformer.SV_SSA, doSSA,() -> {\n+            TritonOps.ModuleOp actualTritonKernel = ScopedValue.where(TritonTransformer.SV_SSA, doSSA).call(() -> {\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonTestExtension.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-java @bldr\/sanity\n+java @hat\/sanity\n@@ -136,1 +136,1 @@\n-java @hat\/run.java ffi-opencl mandel\n+java @hat\/run ffi-opencl mandel\n@@ -160,1 +160,1 @@\n-java --add-modules jdk.incubator.code --enable-preview --source 24 bld\n+java --add-modules jdk.incubator.code --enable-preview --source 25 bld\n@@ -165,1 +165,1 @@\n-We also have a handy `hat\/XXXX` which allows us to avoid specifying common args `--enable-preview --source 24` eash time we launch a script\n+We also have a handy `hat\/XXXX` which allows us to avoid specifying common args `--enable-preview --source 25` eash time we launch a script\n@@ -171,1 +171,1 @@\n-|   ├── sanity      (the args for sanity.java)  \"--enable-preview --source 24 sanity\"\n+|   ├── sanity      (the args for sanity.java)  \"--enable-preview --source 25 sanity\"\n@@ -173,1 +173,1 @@\n-|   ├── run         (the args for sanity.java)  \"--enable-preview --source 24 hatrun\"\n+|   ├── run         (the args for sanity.java)  \"--enable-preview --source 25 hatrun\"\n@@ -175,1 +175,1 @@\n-|   ├── bld         (the args for bld.java)      \"--enable-preview --source 24 bld\"\n+|   ├── bld         (the args for bld.java)      \"--enable-preview --source 25 bld\"\n@@ -187,1 +187,1 @@\n-java --enable-preview --source 24 hat\/bld.java\n+java --enable-preview --source 25 hat\/bld.java\n","filename":"hat\/docs\/hat-01-03-building-hat.md","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1637,1 +1637,1 @@\n-                                .source(24)\n+                                .source(25)\n","filename":"hat\/hat\/Script.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n---enable-preview --source 24 hat\/bld.java\n+--enable-preview --source 25 hat\/bld.java\n","filename":"hat\/hat\/bld","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-           │    ├──bld                                 \/\/  --enable-preview --source 24 hat\/bld.java\n+           │    ├──bld                                 \/\/  --enable-preview --source 25 hat\/bld.java\n@@ -127,1 +127,1 @@\n-           │    ├──run                                 \/\/  --enable-preview --source 24 hat\/run.java\n+           │    ├──run                                 \/\/  --enable-preview --source 25 hat\/run.java\n","filename":"hat\/hat\/bld.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n---enable-preview --source 24 hat\/clean.java\n+--enable-preview --source 25 hat\/clean.java\n","filename":"hat\/hat\/clean","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n--agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=y --enable-preview --source 24 hat\/run.java\n+-agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=y --enable-preview --source 25 hat\/run.java\n","filename":"hat\/hat\/debug","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n---enable-preview --source 24 hat\/extract.java\n+--enable-preview --source 25 hat\/extract.java\n","filename":"hat\/hat\/extract","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-                │    ├──bld                    --enable-preview --source 24 hat\/bld.java\n+                │    ├──bld                    --enable-preview --source 25 hat\/bld.java\n@@ -36,1 +36,1 @@\n-                │    ├──run                    --enable-preview --source 24 hat\/run.java\n+                │    ├──run                    --enable-preview --source 25 hat\/run.java\n","filename":"hat\/hat\/extract.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n---enable-preview --source 24 hat\/mkpoms.java\n+--enable-preview --source 25 hat\/mkpoms.java\n","filename":"hat\/hat\/mkpoms","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n-                      .source(\"24\")\n-                      .target(\"24\")\n+                      .source(\"25\")\n+                      .target(\"25\")\n","filename":"hat\/hat\/mkpoms.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n---enable-preview --source 24 hat\/run.java\n+--enable-preview --source 25 hat\/run.java\n","filename":"hat\/hat\/run","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n---enable-preview --source 24 hat\/run.java ffi-opencl life\n+--enable-preview --source 25 hat\/run.java ffi-opencl life\n","filename":"hat\/hat\/run-ffi-opencl-life","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n---enable-preview --source 24 hat\/run.java  java-mt\n+--enable-preview --source 25 hat\/run.java  java-mt\n","filename":"hat\/hat\/run-java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n---enable-preview --source 24 hat\/run.java ffi-opencl \n+--enable-preview --source 25 hat\/run.java ffi-opencl\n","filename":"hat\/hat\/run-opencl","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n---enable-preview --source 24 hat\/sanity.java\n+--enable-preview --source 25 hat\/sanity.java\n","filename":"hat\/hat\/sanity","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-                    <source>24<\/source>\n-                    <target>24<\/target>\n+                    <source>25<\/source>\n+                    <target>25<\/target>\n","filename":"hat\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+################################################################################\n+\n@@ -62,0 +64,2 @@\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Java.gmk","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -115,3 +115,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n@@ -147,1 +144,1 @@\n-            this.implInfo = caller.revealDirect(implementation); \/\/ may throw SecurityException\n+            this.implInfo = caller.revealDirect(implementation);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,7 +354,1 @@\n-            LambdaForm zero = LambdaForm.zeroForm(type);\n-            String name = zero.kind.defaultLambdaName\n-                   + \"_\" + zero.returnType().basicTypeChar();\n-            if (dedupSet.add(name)) {\n-                names.add(name);\n-                forms.add(zero);\n-            }\n+            String name;\n@@ -369,0 +363,10 @@\n+\n+            if (type != V_TYPE) {\n+                LambdaForm constant = LambdaForm.constantForm(type);\n+                name = constant.kind.defaultLambdaName\n+                        + \"_\" + constant.returnType().basicTypeChar();\n+                if (dedupSet.add(name)) {\n+                    names.add(name);\n+                    forms.add(constant);\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -31,1 +32,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -64,1 +64,1 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n+import jdk.internal.vm.annotation.Stable;\n@@ -75,1 +75,1 @@\n-    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+    private static final @Stable String[] ARG_NAME_CACHE = {\"arg$1\", \"arg$2\", \"arg$3\", \"arg$4\", \"arg$5\", \"arg$6\", \"arg$7\", \"arg$8\"};\n@@ -102,1 +102,1 @@\n-        disableEagerInitialization = GetBooleanAction.privilegedGetProperty(disableEagerInitializationKey);\n+        disableEagerInitialization = Boolean.getBoolean(disableEagerInitializationKey);\n@@ -111,1 +111,0 @@\n-    private final String[] argNames;                 \/\/ Generated names for the constructor arguments\n@@ -154,3 +153,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n@@ -177,1 +173,1 @@\n-        lambdaClassEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(ConstantUtils.concat(\"L\", lambdaClassName, \";\")));\n+        lambdaClassEntry = pool.classEntry(ConstantUtils.internalNameToDesc(lambdaClassName));\n@@ -190,0 +186,2 @@\n+        ClassDesc[] argDescs;\n+        MethodTypeDesc constructorTypeDesc;\n@@ -191,1 +189,0 @@\n-            argNames = new String[parameterCount];\n@@ -194,1 +191,0 @@\n-                argNames[i] = \"arg$\" + (i + 1);\n@@ -197,0 +193,1 @@\n+            constructorTypeDesc = MethodTypeDescImpl.ofValidated(CD_void, argDescs);\n@@ -198,1 +195,1 @@\n-            argNames = EMPTY_STRING_ARRAY;\n+            constructorTypeDesc = MTD_void;\n@@ -201,1 +198,2 @@\n-        constructorTypeDesc = MethodTypeDescImpl.ofValidated(CD_void, argDescs);\n+        this.argDescs = argDescs;\n+        this.constructorTypeDesc = constructorTypeDesc;\n@@ -204,1 +202,5 @@\n-    private static String lambdaClassName(Class<?> targetClass) {\n+    private static String argName(int i) {\n+        return i < ARG_NAME_CACHE.length ? ARG_NAME_CACHE[i] :  \"arg$\" + (i + 1);\n+    }\n+\n+    private static String sanitizedTargetClassName(Class<?> targetClass) {\n@@ -210,1 +212,5 @@\n-        return name.replace('.', '\/').concat(\"$$Lambda\");\n+        return name.replace('.', '\/');\n+    }\n+\n+    private static String lambdaClassName(Class<?> targetClass) {\n+        return sanitizedTargetClassName(targetClass).concat(\"$$Lambda\");\n@@ -329,1 +335,1 @@\n-                    clb.withField(argNames[i], argDescs[i], ACC_PRIVATE | ACC_FINAL);\n+                    clb.withField(argName(i), argDescs[i], ACC_PRIVATE | ACC_FINAL);\n@@ -426,4 +432,3 @@\n-                            cob.aload(0);\n-                            Class<?> argType = factoryType.parameterType(i);\n-                            cob.loadLocal(TypeKind.from(argType), cob.parameterSlot(i));\n-                            cob.putfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                            cob.aload(0)\n+                               .loadLocal(TypeKind.from(factoryType.parameterType(i)), cob.parameterSlot(i))\n+                               .putfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n@@ -471,1 +476,1 @@\n-               .getfield(lambdaClassEntry.asSymbol(), argNames[i], argDescs[i]);\n+               .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n@@ -535,3 +540,3 @@\n-        private static final ClassDesc CD_SerializedLambda = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n-        private static final ClassDesc CD_ObjectOutputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n-        private static final ClassDesc CD_ObjectInputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n+        private static final ClassDesc CD_SerializedLambda = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n+        private static final ClassDesc CD_ObjectOutputStream = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n+        private static final ClassDesc CD_ObjectInputStream = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n@@ -546,1 +551,1 @@\n-        static final ClassDesc CD_NotSerializableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n+        static final ClassDesc CD_NotSerializableException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n@@ -549,1 +554,1 @@\n-                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"));\n+                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ConstantUtils.CD_Object_array);\n@@ -563,1 +568,1 @@\n-                           .ldc(classDesc(targetClass))\n+                           .ldc(ClassDesc.ofInternalName(sanitizedTargetClassName(targetClass)))\n@@ -578,1 +583,1 @@\n-                               .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                               .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n@@ -649,1 +654,1 @@\n-                for (int i = 0; i < argNames.length ; i++) {\n+                for (int i = 0; i < argDescs.length; i++) {\n@@ -651,1 +656,1 @@\n-                       .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                       .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n@@ -699,1 +704,1 @@\n-        return cls.isHidden() ? null : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+        return cls.isHidden() ? null : ConstantUtils.referenceClassDesc(cls.descriptorString());\n@@ -704,1 +709,1 @@\n-                                 : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+                                 : ConstantUtils.referenceClassDesc(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":37,"deletions":32,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -232,0 +232,16 @@\n+ * <p>Uses besides evaluation of lambda expressions and method references are\n+ * unintended.  These linkage methods may change their unspecified behaviors at\n+ * any time to better suit the Java language features they were designed to\n+ * support, and such changes may impact unintended uses.  Unintended uses of\n+ * these linkage methods may lead to resource leaks, or other unspecified\n+ * negative effects.\n+ *\n+ * @implNote In the reference implementation, the classes implementing the created\n+ * function objects are strongly reachable from the defining class loader of the\n+ * caller, like classes and interfaces in Java source code.  This technique\n+ * reduces heap memory use, but as a consequence, the implementation classes can\n+ * be unloaded only if the caller class can be unloaded.  In particular, if the\n+ * caller is a {@linkplain MethodHandles.Lookup.ClassOption#STRONG weak hidden\n+ * class}, the implementation class, a strong hidden class, may not be unloaded\n+ * even if the caller may be unloaded.\n+ *\n@@ -323,3 +339,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n@@ -483,3 +496,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,2 +86,0 @@\n-    \/\/ generic info repository; lazily initialized\n-    private transient volatile MethodRepository genericInfo;\n@@ -91,11 +89,12 @@\n-    @Stable\n-    private MethodAccessor      methodAccessor;\n-    \/\/ For sharing of MethodAccessors. This branching structure is\n-    \/\/ currently only two levels deep (i.e., one root Method and\n-    \/\/ potentially many Method objects pointing to it.)\n-    \/\/\n-    \/\/ If this branching structure would ever contain cycles, deadlocks can\n-    \/\/ occur in annotation code.\n-    private Method              root;\n-    \/\/ Hash code of this object\n-    private int                 hash;\n+\n+    \/**\n+     * Methods are mutable due to {@link AccessibleObject#setAccessible(boolean)}.\n+     * Thus, we return a new copy of a root each time a method is returned.\n+     * Some lazily initialized immutable states can be stored on root and shared to the copies.\n+     *\/\n+    private Method root;\n+    private transient volatile MethodRepository genericInfo;\n+    private @Stable MethodAccessor methodAccessor;\n+    \/\/ End shared states\n+    private int hash; \/\/ not shared right now, eligible if expensive\n+\n@@ -117,4 +116,6 @@\n-        \/\/ lazily initialize repository if necessary\n-            \/\/ create and cache generic info repository\n-            genericInfo = MethodRepository.make(getGenericSignature(),\n-                                                getFactory());\n+            var root = this.root;\n+            if (root != null) {\n+                genericInfo = root.getGenericInfo();\n+            } else {\n+                genericInfo = MethodRepository.make(getGenericSignature(), getFactory());\n+            }\n@@ -124,1 +125,1 @@\n-        return genericInfo; \/\/return cached repository\n+        return genericInfo;\n@@ -160,7 +161,0 @@\n-        \/\/ This routine enables sharing of MethodAccessor objects\n-        \/\/ among Method objects which refer to the same underlying\n-        \/\/ method in the VM. (All of this contortion is only necessary\n-        \/\/ because of the \"accessibility\" bit in AccessibleObject,\n-        \/\/ which implicitly requires that new java.lang.reflect\n-        \/\/ objects be fabricated for each reflective call on Class\n-        \/\/ objects.)\n@@ -174,1 +168,1 @@\n-        \/\/ Might as well eagerly propagate this if already present\n+        \/\/ Propagate shared states\n@@ -176,0 +170,1 @@\n+        res.genericInfo = genericInfo;\n@@ -181,1 +176,0 @@\n-     * @throws SecurityException {@inheritDoc}\n@@ -186,1 +180,0 @@\n-        AccessibleObject.checkPermission();\n@@ -260,1 +253,1 @@\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @SuppressWarnings(\"unchecked\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":23,"deletions":30,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,0 @@\n-    exports java.lang.classfile.components;\n@@ -149,0 +148,2 @@\n+    exports jdk.internal to\n+        jdk.incubator.vector;\n@@ -158,0 +159,1 @@\n+        jdk.crypto.cryptoki, \/\/ participates in preview features\n@@ -171,2 +173,0 @@\n-        java.management.rmi,\n-        java.naming,\n@@ -183,0 +183,2 @@\n+    exports jdk.internal.classfile.components to\n+        jdk.jfr;\n@@ -203,8 +205,0 @@\n-    exports jdk.internal.org.objectweb.asm to\n-        jdk.jfr;\n-    exports jdk.internal.org.objectweb.asm.tree to\n-        jdk.jfr;\n-    exports jdk.internal.org.objectweb.asm.util to\n-        jdk.jfr;\n-    exports jdk.internal.org.objectweb.asm.commons to\n-        jdk.jfr;\n@@ -232,1 +226,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.graal.compiler;\n@@ -297,1 +292,0 @@\n-        java.desktop,\n@@ -322,8 +316,1 @@\n-        java.datatransfer,\n-        java.management,\n-        java.management.rmi,\n-        java.rmi,\n-        java.sql.rowset;\n-    exports sun.security.action to\n-        java.desktop,\n-        java.security.jgss;\n+        java.management;\n@@ -341,1 +328,0 @@\n-        java.rmi,\n@@ -355,2 +341,0 @@\n-        java.desktop,\n-        java.rmi,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":9,"deletions":25,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -151,0 +151,5 @@\n+\n+    \/**\n+      * 25, tbd\n+      *\/\n+    JDK25(\"25\"),\n@@ -203,0 +208,1 @@\n+        case JDK25  -> Target.JDK1_25;\n@@ -265,0 +271,3 @@\n+        JAVA_BASE_TRANSITIVE(JDK24, Fragments.FeatureJavaBaseTransitive, DiagKind.PLURAL),\n+        PRIVATE_MEMBERS_IN_PERMITS_CLAUSE(JDK19),\n+        ERASE_POLY_SIG_RETURN_TYPE(JDK24),\n@@ -352,0 +361,1 @@\n+        case JDK25  -> RELEASE_25;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Type.UnknownType;\n@@ -424,3 +423,0 @@\n-        \/\/ Create the unknown type\n-        unknownType = new UnknownType();\n-\n@@ -436,0 +432,17 @@\n+        noModule = new ModuleSymbol(names.empty, null) {\n+            @Override public boolean isNoModule() {\n+                return true;\n+            }\n+        };\n+        addRootPackageFor(noModule);\n+\n+        Source source = Source.instance(context);\n+        if (Feature.MODULES.allowedInSource(source)) {\n+            java_base = enterModule(names.java_base);\n+            \/\/avoid completing java.base during the Symtab initialization\n+            java_base.completer = Completer.NULL_COMPLETER;\n+            java_base.visiblePackages = Collections.emptyMap();\n+        } else {\n+            java_base = noModule;\n+        }\n+\n@@ -443,1 +456,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -463,1 +475,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -472,7 +483,0 @@\n-        noModule = new ModuleSymbol(names.empty, null) {\n-            @Override public boolean isNoModule() {\n-                return true;\n-            }\n-        };\n-        addRootPackageFor(noModule);\n-\n@@ -491,2 +495,2 @@\n-        unknownSymbol.members_field = new Scope.ErrorScope(unknownSymbol);\n-        unknownSymbol.type = unknownType;\n+        \/\/ Create the unknown type\n+        unknownType = new ErrorType(unknownSymbol, Type.noType);\n@@ -542,10 +546,0 @@\n-        Source source = Source.instance(context);\n-        if (Feature.MODULES.allowedInSource(source)) {\n-            java_base = enterModule(names.java_base);\n-            \/\/avoid completing java.base during the Symtab initialization\n-            java_base.completer = Completer.NULL_COMPLETER;\n-            java_base.visiblePackages = Collections.emptyMap();\n-        } else {\n-            java_base = noModule;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1295,1 +1295,1 @@\n-                if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {\n+                if (t == s || t.qtype == s || s.hasTag(ERROR)) {\n@@ -1545,1 +1545,1 @@\n-                if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {\n+                if (t == s || t.qtype == s || s.hasTag(ERROR)) {\n@@ -1751,0 +1751,6 @@\n+            \/* there are three cases for ts and ss:\n+             *   - one is a class and the other one is an interface (case I)\n+             *   - both are classes                                 (case II)\n+             *   - both are interfaces                              (case III)\n+             * all those cases are covered in JLS 23, section: \"5.1.6.1 Allowed Narrowing Reference Conversion\"\n+             *\/\n@@ -1758,23 +1764,24 @@\n-                if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n-                    return false;\n-                }\n-                \/\/ if both are classes or both are interfaces, shortcut\n-                if (ts.isInterface() == ss.isInterface() && isSubtype(erasure(ss.type), erasure(ts.type))) {\n-                    return false;\n-                }\n-                if (ts.isInterface() && !ss.isInterface()) {\n-                    \/* so ts is interface but ss is a class\n-                     * an interface is disjoint from a class if the class is disjoint form the interface\n-                     *\/\n-                    return areDisjoint(ss, ts);\n-                }\n-                \/\/ a final class that is not subtype of ss is disjoint\n-                if (!ts.isInterface() && ts.isFinal()) {\n-                    return true;\n-                }\n-                \/\/ if at least one is sealed\n-                if (ts.isSealed() || ss.isSealed()) {\n-                    \/\/ permitted subtypes have to be disjoint with the other symbol\n-                    ClassSymbol sealedOne = ts.isSealed() ? ts : ss;\n-                    ClassSymbol other = sealedOne == ts ? ss : ts;\n-                    return sealedOne.getPermittedSubclasses().stream().allMatch(type -> areDisjoint((ClassSymbol)type.tsym, other));\n+\n+                if (ts.isInterface() != ss.isInterface()) { \/\/ case I: one is a class and the other one is an interface\n+                    ClassSymbol isym = ts.isInterface() ? ts : ss; \/\/ isym is the interface and csym the class\n+                    ClassSymbol csym = isym == ts ? ss : ts;\n+                    if (!isSubtype(erasure(csym.type), erasure(isym.type))) {\n+                        if (csym.isFinal()) {\n+                            return true;\n+                        } else if (csym.isSealed()) {\n+                            return areDisjoint(isym, csym.getPermittedSubclasses());\n+                        } else if (isym.isSealed()) {\n+                            \/\/ if the class is not final and not sealed then it has to be freely extensible\n+                            return areDisjoint(csym, isym.getPermittedSubclasses());\n+                        }\n+                    } \/\/ now both are classes or both are interfaces\n+                } else if (!ts.isInterface()) {              \/\/ case II: both are classes\n+                    return !isSubtype(erasure(ss.type), erasure(ts.type)) && !isSubtype(erasure(ts.type), erasure(ss.type));\n+                } else {                                     \/\/ case III: both are interfaces\n+                    if (!isSubtype(erasure(ts.type), erasure(ss.type)) && !isSubtype(erasure(ss.type), erasure(ts.type))) {\n+                        if (ts.isSealed()) {\n+                            return areDisjoint(ss, ts.getPermittedSubclasses());\n+                        } else if (ss.isSealed()) {\n+                            return areDisjoint(ts, ss.getPermittedSubclasses());\n+                        }\n+                    }\n@@ -1782,0 +1789,1 @@\n+                \/\/ at this point we haven't been able to statically prove that the classes or interfaces are disjoint\n@@ -1784,0 +1792,4 @@\n+\n+            boolean areDisjoint(ClassSymbol csym, List<Type> permittedSubtypes) {\n+                return permittedSubtypes.stream().allMatch(psubtype -> areDisjoint(csym, (ClassSymbol) psubtype.tsym));\n+            }\n@@ -2501,1 +2513,1 @@\n-                             NONE, ERROR, UNKNOWN, UNDETVAR, UNINITIALIZED_THIS,\n+                             NONE, ERROR, UNDETVAR, UNINITIALIZED_THIS,\n@@ -3407,0 +3419,4 @@\n+    \/* this class won't substitute all types for example UndetVars are never substituted, this is\n+     * by design as UndetVars are used locally during inference and shouldn't escape from inference routines,\n+     * some specialized applications could need a tailored solution\n+     *\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":42,"deletions":26,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -872,0 +873,1 @@\n+                                      Env<AttrContext> enclosingEnv,\n@@ -874,4 +876,1 @@\n-\n-        DiagnosticPosition prevLintPos\n-                = deferredLintHandler.setPos(variable.pos());\n-\n+        deferredLintHandler.push(variable);\n@@ -880,0 +879,1 @@\n+            doQueueScanTreeAndTypeAnnotateForVarInit(variable, enclosingEnv);\n@@ -892,1 +892,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -896,1 +896,1 @@\n-    \/** Attribute type reference in an `extends' or `implements' clause.\n+    \/** Attribute type reference in an `extends', `implements', or 'permits' clause.\n@@ -1021,1 +1021,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n@@ -1303,5 +1303,1 @@\n-            if (tree.init != null) {\n-                \/\/ Field initializer expression need to be entered.\n-                annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());\n-                annotate.flush();\n-            }\n+            doQueueScanTreeAndTypeAnnotateForVarInit(tree, env);\n@@ -1322,1 +1318,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n@@ -1360,0 +1356,11 @@\n+    private void doQueueScanTreeAndTypeAnnotateForVarInit(JCVariableDecl tree, Env<AttrContext> env) {\n+        if (tree.init != null &&\n+            (tree.mods.flags & Flags.FIELD_INIT_TYPE_ANNOTATIONS_QUEUED) == 0 &&\n+            env.info.scope.owner.kind != MTH && env.info.scope.owner.kind != VAR) {\n+            tree.mods.flags |= Flags.FIELD_INIT_TYPE_ANNOTATIONS_QUEUED;\n+            \/\/ Field initializer expression need to be entered.\n+            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree);\n+            annotate.flush();\n+        }\n+    }\n+\n@@ -1960,2 +1967,2 @@\n-        if (env.info.lint.isEnabled(LintCategory.SYNCHRONIZATION) && isValueBased(tree.lock.type)) {\n-            log.warning(LintCategory.SYNCHRONIZATION, tree.pos(), Warnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n+        if (isValueBased(tree.lock.type)) {\n+            env.info.lint.logIfEnabled(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n@@ -2053,1 +2060,1 @@\n-            Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);\n+            Log.DiagnosticHandler discardHandler = log.new DiscardDiagnosticHandler();\n@@ -2067,3 +2074,2 @@\n-                    chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &&\n-                    env.info.lint.isEnabled(LintCategory.TRY)) {\n-                log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));\n+                    chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes())) {\n+                env.info.lint.logIfEnabled(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n@@ -2512,1 +2518,0 @@\n-                !env.info.isNewClass &&\n@@ -2609,5 +2614,0 @@\n-                    } else if (methName == names._super) {\n-                        \/\/ qualifier omitted; check for existence\n-                        \/\/ of an appropriate implicit qualifier.\n-                        rs.resolveImplicitThis(tree.meth.pos(),\n-                                               localEnv, site, true);\n@@ -2621,0 +2621,9 @@\n+                if (tree.meth.hasTag(IDENT)) {\n+                    \/\/ non-qualified super(...) call; check whether explicit constructor\n+                    \/\/ invocation is well-formed. If the super class is an inner class,\n+                    \/\/ make sure that an appropriate implicit qualifier exists. If the super\n+                    \/\/ class is a local class, make sure that the current class is defined\n+                    \/\/ in the same context as the local class.\n+                    checkNewInnerClass(tree.meth.pos(), localEnv, site, true);\n+                }\n+\n@@ -2794,1 +2803,1 @@\n-            env.info.isNewClass = true;\n+            env.info.isAnonymousNewClass = tree.def != null;\n@@ -2799,1 +2808,1 @@\n-            env.info.isNewClass = false;\n+            env.info.isAnonymousNewClass = false;\n@@ -2820,3 +2829,1 @@\n-        } else if (!clazztype.tsym.isInterface() &&\n-                   (clazztype.tsym.flags_field & NOOUTERTHIS) == 0 &&\n-                   clazztype.getEnclosingType().hasTag(CLASS)) {\n+        } else {\n@@ -2824,1 +2831,1 @@\n-            rs.resolveImplicitThis(tree.pos(), env, clazztype);\n+            checkNewInnerClass(tree.pos(), env, clazztype, false);\n@@ -3089,0 +3096,18 @@\n+        void checkNewInnerClass(DiagnosticPosition pos, Env<AttrContext> env, Type type, boolean isSuper) {\n+            boolean isLocal = type.tsym.owner.kind == VAR || type.tsym.owner.kind == MTH;\n+            if ((type.tsym.flags() & (INTERFACE | ENUM | RECORD)) != 0 ||\n+                    (!isLocal && !type.tsym.isInner()) ||\n+                    (isSuper && env.enclClass.sym.isAnonymous())) {\n+                \/\/ nothing to check\n+                return;\n+            }\n+            Symbol res = isLocal ?\n+                    rs.findLocalClassOwner(env, type.tsym) :\n+                    rs.findSelfContaining(pos, env, type.getEnclosingType().tsym, isSuper);\n+            if (res.exists()) {\n+                rs.accessBase(res, pos, env.enclClass.sym.type, names._this, true);\n+            } else {\n+                log.error(pos, Errors.EnclClassRequired(type.tsym));\n+            }\n+        }\n+\n@@ -3762,1 +3787,0 @@\n-                    case MISSING_ENCL:\n@@ -3813,5 +3837,1 @@\n-                Type enclosingType = exprType.getEnclosingType();\n-                if (enclosingType != null && enclosingType.hasTag(CLASS)) {\n-                    \/\/ Check for the existence of an appropriate outer instance\n-                    rs.resolveImplicitThis(that.pos(), env, exprType);\n-                }\n+                checkNewInnerClass(that.pos(), env, exprType, false);\n@@ -4311,0 +4331,1 @@\n+        chk.validate(tree.var.vartype, env, true);\n@@ -4315,1 +4336,1 @@\n-        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.pos());\n+        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.var);\n@@ -4317,1 +4338,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var.pos());\n+            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var);\n@@ -4320,1 +4341,0 @@\n-        chk.validate(tree.var.vartype, env, true);\n@@ -4554,3 +4574,2 @@\n-                sym.overrides(syms.autoCloseableClose, sitesym.type.tsym, types, true) &&\n-                env.info.lint.isEnabled(LintCategory.TRY)) {\n-            log.warning(LintCategory.TRY, tree, Warnings.TryExplicitCloseCall);\n+                sym.overrides(syms.autoCloseableClose, sitesym.type.tsym, types, true)) {\n+            env.info.lint.logIfEnabled(tree, LintWarnings.TryExplicitCloseCall);\n@@ -4583,1 +4602,1 @@\n-                chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n+                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n@@ -4585,1 +4604,1 @@\n-                chk.warnStatic(tree, Warnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n+                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n@@ -4798,1 +4817,1 @@\n-                        chk.warnUnchecked(tree.pos(), Warnings.UncheckedAssignToVar(v, s));\n+                        chk.warnUnchecked(tree.pos(), LintWarnings.UncheckedAssignToVar(v, s));\n@@ -4841,1 +4860,1 @@\n-                chk.checkPreview(tree.pos(), env.info.scope.owner, sym);\n+                chk.checkPreview(tree.pos(), env.info.scope.owner, site, sym);\n@@ -4996,1 +5015,1 @@\n-                chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedCallMbrOfRawType(sym, s));\n+                chk.warnUnchecked(env.tree.pos(), LintWarnings.UncheckedCallMbrOfRawType(sym, s));\n@@ -5046,1 +5065,1 @@\n-                chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedMethInvocationApplied(kindName(sym),\n+                chk.warnUnchecked(env.tree.pos(), LintWarnings.UncheckedMethInvocationApplied(kindName(sym),\n@@ -5342,1 +5361,1 @@\n-        if (!env.info.isNewClass)\n+        if (!env.info.isAnonymousNewClass)\n@@ -5432,1 +5451,1 @@\n-            deferredLintHandler.flush(env.tree.pos(), lint);\n+            deferredLintHandler.flush(env.tree, lint);\n@@ -5516,0 +5535,4 @@\n+                        if (subType.isErroneous()) {\n+                            \/\/ the type already caused errors, don't produce more potentially misleading errors\n+                            continue;\n+                        }\n@@ -5657,1 +5680,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":76,"deletions":53,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -550,1 +550,1 @@\n-                super(log, d -> {\n+                log.super(d -> {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,1 +223,1 @@\n-                this.hashCode = hashCode = TreeHasher.hash(tree, symbol.params());\n+                this.hashCode = hashCode = TreeHasher.hash(types, tree, symbol.params());\n@@ -232,1 +232,1 @@\n-                    && new TreeDiffer(symbol.params(), dedupedLambda.symbol.params()).scan(tree, dedupedLambda.tree);\n+                    && new TreeDiffer(types, symbol.params(), dedupedLambda.symbol.params()).scan(tree, dedupedLambda.tree);\n@@ -468,0 +468,4 @@\n+            if (tc.hasUnknownPosition()) {\n+                \/\/ Handle container annotations\n+                tc.tryFixPosition();\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,1 @@\n+    private final boolean nullCheckOuterThis;\n@@ -137,0 +138,2 @@\n+        nullCheckOuterThis = options.getBoolean(\"nullCheckOuterThis\",\n+            target.nullCheckOuterThisByDefault());\n@@ -1797,1 +1800,4 @@\n-    \/** Return tree simulating the assignment {@code this.this$n = this$n}.\n+    \/**\n+     * Return tree simulating null checking outer this and\/or assigning. This is\n+     * called when a null check is required (nullCheckOuterThis), or a synthetic\n+     * field is generated (stores).\n@@ -1799,1 +1805,1 @@\n-    JCStatement initOuterThis(int pos, VarSymbol rhs) {\n+    JCStatement initOuterThis(int pos, VarSymbol rhs, boolean stores) {\n@@ -1801,2 +1807,1 @@\n-        VarSymbol lhs = outerThisStack.head;\n-        Assert.check(rhs.owner.owner == lhs.owner);\n+        Assert.check(nullCheckOuterThis || stores); \/\/ One of the flags must be true\n@@ -1804,3 +1809,8 @@\n-        return\n-            make.Exec(\n-                make.Assign(\n+        JCExpression expression = make.Ident(rhs);\n+        if (nullCheckOuterThis) {\n+            expression = attr.makeNullCheck(expression);\n+        }\n+        if (stores) {\n+            VarSymbol lhs = outerThisStack.head;\n+            Assert.check(rhs.owner.owner == lhs.owner);\n+            expression = make.Assign(\n@@ -1808,1 +1818,3 @@\n-                    make.Ident(rhs)).setType(lhs.erasure(types)));\n+                    expression).setType(lhs.erasure(types));\n+        }\n+        return make.Exec(expression);\n@@ -2213,3 +2225,10 @@\n-        if (currentClass.hasOuterInstance() && shouldEmitOuterThis(currentClass)) {\n-            tree.defs = tree.defs.prepend(otdef);\n-            enterSynthetic(tree.pos(), otdef.sym, currentClass.members());\n+        \/\/ otherwise prepend enclosing instance null check code if required\n+        emitOuter:\n+        if (currentClass.hasOuterInstance()) {\n+            boolean storesThis = shouldEmitOuterThis(currentClass);\n+            if (storesThis) {\n+                tree.defs = tree.defs.prepend(otdef);\n+                enterSynthetic(tree.pos(), otdef.sym, currentClass.members());\n+            } else if (!nullCheckOuterThis) {\n+                break emitOuter;\n+            }\n@@ -2221,1 +2240,1 @@\n-                        List<JCStatement> initializer = List.of(initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+                        List<JCStatement> initializer = List.of(initOuterThis(mdef.body.pos, mdef.params.head.sym, storesThis)) ;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+    private final boolean allowPrivateMembersInPermitsClause;\n@@ -150,0 +151,1 @@\n+        allowPrivateMembersInPermitsClause = Feature.PRIVATE_MEMBERS_IN_PERMITS_CLAUSE.allowedInSource(source);\n@@ -428,1 +430,3 @@\n-                 sym.owner.outermostClass())\n+                 sym.owner.outermostClass()\n+                 ||\n+                 privateMemberInPermitsClauseIfAllowed(env, sym))\n@@ -461,0 +465,7 @@\n+\n+    private boolean privateMemberInPermitsClauseIfAllowed(Env<AttrContext> env, Symbol sym) {\n+        return allowPrivateMembersInPermitsClause &&\n+            env.info.isPermitsClause &&\n+            ((JCClassDecl) env.tree).sym.outermostClass() == sym.owner.outermostClass();\n+    }\n+\n@@ -1856,0 +1867,4 @@\n+        if (bestSoFar.kind == AMBIGUOUS) {\n+            AmbiguityError a_err = (AmbiguityError)bestSoFar.baseSymbol();\n+            bestSoFar = a_err.mergeAbstracts(site);\n+        }\n@@ -2137,4 +2152,2 @@\n-    private final RecoveryLoadClass starImportScopeRecovery = (env, name) -> {\n-        Scope importScope = env.toplevel.starImportScope;\n-        Symbol existing = importScope.findFirst(Convert.shortName(name),\n-                                                sym -> sym.kind == TYP && sym.flatName() == name);\n+    private final RecoveryLoadClass starImportScopeRecovery =\n+            onDemandImportScopeRecovery(false);\n@@ -2142,3 +2155,2 @@\n-        if (existing != null) {\n-            try {\n-                existing = finder.loadClass(existing.packge().modle, name);\n+    private final RecoveryLoadClass moduleImportScopeRecovery =\n+            onDemandImportScopeRecovery(true);\n@@ -2146,3 +2158,15 @@\n-                return new InvisibleSymbolError(env, true, existing);\n-            } catch (CompletionFailure cf) {\n-                \/\/ignore\n+    private RecoveryLoadClass onDemandImportScopeRecovery(boolean moduleImportScope) {\n+        return (env, name) -> {\n+            Scope importScope = moduleImportScope ? env.toplevel.moduleImportScope\n+                                                  : env.toplevel.starImportScope;\n+            Symbol existing = importScope.findFirst(Convert.shortName(name),\n+                                                    sym -> sym.kind == TYP && sym.flatName() == name);\n+\n+            if (existing != null) {\n+                try {\n+                    existing = finder.loadClass(existing.packge().modle, name);\n+\n+                    return new InvisibleSymbolError(env, true, existing);\n+                } catch (CompletionFailure cf) {\n+                    \/\/ignore\n+                }\n@@ -2150,3 +2174,3 @@\n-        }\n-        return null;\n-    };\n+            return null;\n+        };\n+    }\n@@ -2421,0 +2445,5 @@\n+\n+            sym = findGlobalType(env, env.toplevel.moduleImportScope, name, moduleImportScopeRecovery);\n+            if (sym.exists()) return sym;\n+\n+            else bestSoFar = bestOf(bestSoFar, sym);\n@@ -2760,1 +2789,1 @@\n-                    Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+                    Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2792,1 +2821,1 @@\n-            Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+            Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2916,1 +2945,1 @@\n-            Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+            Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2975,1 +3004,1 @@\n-                    Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+                    Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -3506,12 +3535,0 @@\n-        @Override\n-        final Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n-            Symbol sym = doLookup(env, phase);\n-            if (sym.kind == AMBIGUOUS) {\n-                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n-                sym = a_err.mergeAbstracts(site);\n-            }\n-            return sym;\n-        }\n-\n-        abstract Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase);\n-\n@@ -3564,4 +3581,0 @@\n-            if (sym.kind == AMBIGUOUS) {\n-                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n-                sym = a_err.mergeAbstracts(site);\n-            }\n@@ -3734,1 +3747,1 @@\n-            Symbol sym = needsInference ?\n+            return needsInference ?\n@@ -3738,1 +3751,0 @@\n-            return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;\n@@ -3783,0 +3795,59 @@\n+    \/**\n+     * Find a \"valid\" reference to an enclosing 'A.this' such that A is a subclass of the provided class symbol.\n+     * A reference to an enclosing 'A.this' is \"valid\" if (a) we're not in the early-construction context for A\n+     * and (b) if the current class is not an inner class of A.\n+     *\/\n+    Symbol findSelfContaining(DiagnosticPosition pos,\n+                    Env<AttrContext> env,\n+                    TypeSymbol c,\n+                    boolean isSuper) {\n+        Env<AttrContext> env1 = isSuper ? env.outer : env;\n+        boolean staticOnly = false;\n+        while (env1.outer != null) {\n+            if (isStatic(env1)) staticOnly = true;\n+            if (env1.enclClass.sym.isSubClass(c, types)) {\n+                Symbol sym = env1.info.scope.findFirst(names._this);\n+                if (sym != null) {\n+                    if (staticOnly) {\n+                        \/\/ current class is not an inner class, stop search\n+                        return new StaticError(sym);\n+                    } else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n+                        \/\/ early construction context, stop search\n+                        return new RefBeforeCtorCalledError(sym);\n+                    } else {\n+                        \/\/ found it\n+                        return sym;\n+                    }\n+                }\n+            }\n+            if ((env1.enclClass.sym.flags() & STATIC) != 0) staticOnly = true;\n+            env1 = env1.outer;\n+        }\n+        return varNotFound;\n+    }\n+\n+    \/**\n+     * Resolve the (method) owner of a local class. This can fail if the local class\n+     * is referenced from a static context nested inside the local class. Effectively,\n+     * this lookup succeeds if we can access a local variable declared inside the owner\n+     * method from the provided env.\n+     *\/\n+    Symbol findLocalClassOwner(Env<AttrContext> env, TypeSymbol c) {\n+        Symbol owner = c.owner;\n+        Assert.check(owner.kind == MTH || owner.kind == VAR);\n+        Env<AttrContext> env1 = env;\n+        boolean staticOnly = false;\n+        while (env1.outer != null) {\n+            if (env1.info.scope.owner == owner) {\n+                return (staticOnly) ?\n+                    new BadLocalClassCreation(c) :\n+                    owner;\n+            }\n+            if (isStatic(env1)) staticOnly = true;\n+            env1 = env1.outer;\n+        }\n+        return owner.kind == MTH ?\n+                methodNotFound :\n+                varNotFound;\n+    }\n+\n@@ -3807,1 +3878,1 @@\n-                                  name, true);\n+                            name, true);\n@@ -3814,2 +3885,2 @@\n-            name == names._super && !isStatic(env) &&\n-            types.isDirectSuperInterface(c, env.enclClass.sym)) {\n+                name == names._super && !isStatic(env) &&\n+                types.isDirectSuperInterface(c, env.enclClass.sym)) {\n@@ -3830,2 +3901,2 @@\n-                              Errors.IllegalDefaultSuperCall(c,\n-                                                             Fragments.RedundantSupertype(c, i)));\n+                            Errors.IllegalDefaultSuperCall(c,\n+                                    Fragments.RedundantSupertype(c, i)));\n@@ -3938,70 +4009,0 @@\n-    \/**\n-     * Resolve `c.this' for an enclosing class c that contains the\n-     * named member.\n-     * @param pos           The position to use for error reporting.\n-     * @param env           The environment current at the expression.\n-     * @param member        The member that must be contained in the result.\n-     *\/\n-    Symbol resolveSelfContaining(DiagnosticPosition pos,\n-                                 Env<AttrContext> env,\n-                                 Symbol member,\n-                                 boolean isSuperCall) {\n-        Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);\n-        if (sym == null) {\n-            log.error(pos, Errors.EnclClassRequired(member));\n-            return syms.errSymbol;\n-        } else {\n-            return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);\n-        }\n-    }\n-\n-    boolean enclosingInstanceMissing(Env<AttrContext> env, Type type) {\n-        if (type.hasTag(CLASS) && type.getEnclosingType().hasTag(CLASS)) {\n-            Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);\n-            return encl == null || encl.kind.isResolutionError();\n-        }\n-        return false;\n-    }\n-\n-    private Symbol resolveSelfContainingInternal(Env<AttrContext> env,\n-                                 Symbol member,\n-                                 boolean isSuperCall) {\n-        Name name = names._this;\n-        Env<AttrContext> env1 = isSuperCall ? env.outer : env;\n-        boolean staticOnly = false;\n-        if (env1 != null) {\n-            while (env1 != null && env1.outer != null) {\n-                if (isStatic(env1)) staticOnly = true;\n-                if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {\n-                    Symbol sym = env1.info.scope.findFirst(name);\n-                    if (sym != null) {\n-                        if (staticOnly) sym = new StaticError(sym);\n-                        return sym;\n-                    }\n-                }\n-                if ((env1.enclClass.sym.flags() & STATIC) != 0)\n-                    staticOnly = true;\n-                env1 = env1.outer;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Resolve an appropriate implicit this instance for t's container.\n-     * JLS 8.8.5.1 and 15.9.2\n-     *\/\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t) {\n-        return resolveImplicitThis(pos, env, t, false);\n-    }\n-\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t, boolean isSuperCall) {\n-        Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)\n-                         ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)\n-                         : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;\n-        if (env.info.ctorPrologue && thisType.tsym == env.enclClass.sym) {\n-            log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n-        }\n-        return thisType;\n-    }\n-\n@@ -4731,0 +4732,22 @@\n+    \/**\n+     * Specialization of {@link StaticError} for illegal\n+     * creation of local class instances from a static context.\n+     *\/\n+    class BadLocalClassCreation extends StaticError {\n+        BadLocalClassCreation(Symbol sym) {\n+            super(sym, \"bad local class creation\");\n+        }\n+\n+        @Override\n+        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,\n+                                   DiagnosticPosition pos,\n+                                   Symbol location,\n+                                   Type site,\n+                                   Name name,\n+                                   List<Type> argtypes,\n+                                   List<Type> typeargtypes) {\n+            return diags.create(dkind, log.currentSource(), pos,\n+                    \"local.cant.be.inst.static\", kindName(sym), sym);\n+        }\n+    }\n+\n@@ -4890,17 +4913,0 @@\n-    \/**\n-     * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,\n-     * but pointing to a class for which an enclosing instance is not available.\n-     *\/\n-    class BadConstructorReferenceError extends InvalidSymbolError {\n-\n-        public BadConstructorReferenceError(Symbol sym) {\n-            super(MISSING_ENCL, sym, \"BadConstructorReferenceError\");\n-        }\n-\n-        @Override\n-        JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List<Type> argtypes, List<Type> typeargtypes) {\n-           return diags.create(dkind, log.currentSource(), pos,\n-                \"cant.access.inner.cls.constr\", site.tsym.name, argtypes, site.getEnclosingType());\n-        }\n-    }\n-\n@@ -5190,1 +5196,0 @@\n-        @SuppressWarnings(\"overrides\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":134,"deletions":129,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -817,2 +817,1 @@\n-        Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;\n-        tree.selector = translate(tree.selector, target);\n+        tree.selector = translate(tree.selector, erasure(tree.selector.type));\n@@ -856,2 +855,1 @@\n-        Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;\n-        tree.selector = translate(tree.selector, target);\n+        tree.selector = translate(tree.selector, erasure(tree.selector.type));\n@@ -1071,1 +1069,7 @@\n-        tree.expr = translate(tree.expr, null);\n+        if (tree.pattern.type.isPrimitive()) {\n+            tree.erasedExprOriginalType = erasure(tree.expr.type);\n+            tree.expr = translate(tree.expr, null);\n+        }\n+        else {\n+            tree.expr = translate(tree.expr, null);\n+        }\n@@ -1168,1 +1172,1 @@\n-            \"The current compile state [%s] of class %s is previous to FLOW\";\n+            \"The current compile state [%s] of class %s is previous to WARN\";\n@@ -1189,1 +1193,1 @@\n-         *  2) has a compile state which is previous to Flow state.\n+         *  2) has a compile state which is previous to WARN state.\n@@ -1197,1 +1201,1 @@\n-                CompileState.FLOW.isAfter(compileStates.get(myEnv))) {\n+                CompileState.WARN.isAfter(compileStates.get(myEnv))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCInstanceOf;\n@@ -241,4 +242,0 @@\n-    \/** Whether or not the options lint category was initially disabled\n-     *\/\n-    boolean optionsCheckingInitiallyDisabled;\n-\n@@ -309,0 +306,4 @@\n+    \/** The warning analyzer.\n+     *\/\n+    protected WarningAnalyzer warningAnalyzer;\n+\n@@ -424,0 +425,1 @@\n+        warningAnalyzer = WarningAnalyzer.instance(context);\n@@ -439,6 +441,0 @@\n-        \/\/ See if lint options checking was explicitly disabled by the\n-        \/\/ user; this is distinct from the options check being\n-        \/\/ enabled\/disabled.\n-        optionsCheckingInitiallyDisabled =\n-            options.isSet(Option.XLINT_CUSTOM, \"-options\") ||\n-            options.isSet(Option.XLINT_CUSTOM, \"none\");\n@@ -928,5 +924,0 @@\n-        \/\/ forcibly set the equivalent of -Xlint:-options, so that no further\n-        \/\/ warnings about command line options are generated from this point on\n-        options.put(XLINT_CUSTOM.primaryName + \"-\" + LintCategory.OPTIONS.option, \"true\");\n-        options.remove(XLINT_CUSTOM.primaryName + LintCategory.OPTIONS.option);\n-\n@@ -967,1 +958,1 @@\n-                    generate(desugar(flow(attribute(todo))));\n+                    generate(desugar(warn(flow(attribute(todo)))));\n@@ -973,1 +964,1 @@\n-                            generate(desugar(flow(attribute(q.remove()))));\n+                            generate(desugar(warn(flow(attribute(q.remove())))));\n@@ -980,1 +971,1 @@\n-                        generate(desugar(flow(attribute(todo.remove()))));\n+                        generate(desugar(warn(flow(attribute(todo.remove())))));\n@@ -1175,1 +1166,1 @@\n-                deferredDiagnosticHandler = new Log.DeferredDiagnosticHandler(log);\n+                deferredDiagnosticHandler = log.new DeferredDiagnosticHandler();\n@@ -1449,0 +1440,50 @@\n+    \/**\n+     * Check for various things to warn about.\n+     *\n+     * @return the list of attributed parse trees\n+     *\/\n+    public Queue<Env<AttrContext>> warn(Queue<Env<AttrContext>> envs) {\n+        ListBuffer<Env<AttrContext>> results = new ListBuffer<>();\n+        for (Env<AttrContext> env: envs) {\n+            warn(env, results);\n+        }\n+        return stopIfError(CompileState.WARN, results);\n+    }\n+\n+    \/**\n+     * Check for various things to warn about in an attributed parse tree.\n+     *\/\n+    public Queue<Env<AttrContext>> warn(Env<AttrContext> env) {\n+        ListBuffer<Env<AttrContext>> results = new ListBuffer<>();\n+        warn(env, results);\n+        return stopIfError(CompileState.WARN, results);\n+    }\n+\n+    \/**\n+     * Check for various things to warn about in an attributed parse tree.\n+     *\/\n+    protected void warn(Env<AttrContext> env, Queue<Env<AttrContext>> results) {\n+        if (compileStates.isDone(env, CompileState.WARN)) {\n+            results.add(env);\n+            return;\n+        }\n+\n+        if (shouldStop(CompileState.WARN))\n+            return;\n+\n+        if (verboseCompilePolicy)\n+            printNote(\"[warn \" + env.enclClass.sym + \"]\");\n+        JavaFileObject prev = log.useSource(\n+                                            env.enclClass.sym.sourcefile != null ?\n+                                            env.enclClass.sym.sourcefile :\n+                                            env.toplevel.sourcefile);\n+        try {\n+            warningAnalyzer.analyzeTree(env);\n+            compileStates.put(env, CompileState.WARN);\n+            results.add(env);\n+        }\n+        finally {\n+            log.useSource(prev);\n+        }\n+    }\n+\n@@ -1507,0 +1548,4 @@\n+        \/\/ Ensure the file has reached the WARN state\n+        if (!compileStates.isDone(env, CompileState.WARN))\n+            warn(env);\n+\n@@ -1565,0 +1610,7 @@\n+            public void visitTypeTest(JCInstanceOf tree) {\n+                if (tree.pattern.type.isPrimitive()) {\n+                    hasPatterns = true;\n+                }\n+                super.visitTypeTest(tree);\n+            }\n+            @Override\n@@ -1583,2 +1635,2 @@\n-        if (!compileStates.isDone(dep, CompileState.FLOW))\n-            desugaredEnvs.put(dep, desugar(flow(attribute(dep))));\n+        if (!compileStates.isDone(dep, CompileState.WARN))\n+            desugaredEnvs.put(dep, desugar(warn(flow(attribute(dep)))));\n@@ -1891,1 +1943,1 @@\n-        DiagnosticHandler dh = new DiscardDiagnosticHandler(log);\n+        DiagnosticHandler dh = log.new DiscardDiagnosticHandler();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":75,"deletions":23,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,0 @@\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.nio.file.Path;\n@@ -45,0 +42,1 @@\n+import javax.tools.Diagnostic;\n@@ -65,1 +63,0 @@\n-import com.sun.tools.javac.file.JavacFileManager;\n@@ -73,0 +70,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -116,1 +114,0 @@\n-    private final boolean lint;\n@@ -129,0 +126,1 @@\n+    private final Lint lint;\n@@ -170,1 +168,0 @@\n-    private SecurityException processorLoaderException;\n@@ -213,1 +210,1 @@\n-        lint = Lint.instance(context).isEnabled(PROCESSING);\n+        lint = Lint.instance(context);\n@@ -272,12 +269,11 @@\n-        try {\n-            if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n-                try {\n-                    serviceLoader = fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, Processor.class);\n-                } catch (IOException e) {\n-                    throw new Abort(e);\n-                }\n-            } else {\n-                \/\/ If processorpath is not explicitly set, use the classpath.\n-                processorClassLoader = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)\n-                    ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)\n-                    : fileManager.getClassLoader(CLASS_PATH);\n+        if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n+            try {\n+                serviceLoader = fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, Processor.class);\n+            } catch (IOException e) {\n+                throw new Abort(e);\n+            }\n+        } else {\n+            \/\/ If processorpath is not explicitly set, use the classpath.\n+            processorClassLoader = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)\n+                ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)\n+                : fileManager.getClassLoader(CLASS_PATH);\n@@ -285,2 +281,2 @@\n-                if (options.isSet(\"accessInternalAPI\"))\n-                    ModuleHelper.addExports(getClass().getModule(), processorClassLoader.getUnnamedModule());\n+            if (options.isSet(\"accessInternalAPI\"))\n+                ModuleHelper.addExports(getClass().getModule(), processorClassLoader.getUnnamedModule());\n@@ -288,3 +284,2 @@\n-                if (processorClassLoader != null && processorClassLoader instanceof Closeable closeable) {\n-                    compiler.closeables = compiler.closeables.prepend(closeable);\n-                }\n+            if (processorClassLoader != null && processorClassLoader instanceof Closeable closeable) {\n+                compiler.closeables = compiler.closeables.prepend(closeable);\n@@ -292,2 +287,0 @@\n-        } catch (SecurityException e) {\n-            processorLoaderException = e;\n@@ -309,20 +302,16 @@\n-            if (processorLoaderException == null) {\n-                \/*\n-                 * If the \"-processor\" option is used, search the appropriate\n-                 * path for the named class.  Otherwise, use a service\n-                 * provider mechanism to create the processor iterator.\n-                 *\n-                 * Note: if an explicit processor path is not set,\n-                 * only the class path and _not_ the module path are\n-                 * searched for processors.\n-                 *\/\n-                String processorNames = options.get(Option.PROCESSOR);\n-                if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n-                    processorIterator = (processorNames == null) ?\n-                            new ServiceIterator(serviceLoader, log) :\n-                            new NameServiceIterator(serviceLoader, log, processorNames);\n-                } else if (processorNames != null) {\n-                    processorIterator = new NameProcessIterator(processorNames, processorClassLoader, log);\n-                } else {\n-                    processorIterator = new ServiceIterator(processorClassLoader, log);\n-                }\n+            \/*\n+             * If the \"-processor\" option is used, search the appropriate\n+             * path for the named class.  Otherwise, use a service\n+             * provider mechanism to create the processor iterator.\n+             *\n+             * Note: if an explicit processor path is not set,\n+             * only the class path and _not_ the module path are\n+             * searched for processors.\n+             *\/\n+            String processorNames = options.get(Option.PROCESSOR);\n+            if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n+                processorIterator = (processorNames == null) ?\n+                        new ServiceIterator(serviceLoader, log) :\n+                        new NameServiceIterator(serviceLoader, log, processorNames);\n+            } else if (processorNames != null) {\n+                processorIterator = new NameProcessIterator(processorNames, processorClassLoader, log);\n@@ -330,8 +319,1 @@\n-                \/*\n-                 * A security exception will occur if we can't create a classloader.\n-                 * Ignore the exception if, with hindsight, we didn't need it anyway\n-                 * (i.e. no processor was specified either explicitly, or implicitly,\n-                 * in service configuration file.) Otherwise, we cannot continue.\n-                 *\/\n-                processorIterator = handleServiceLoaderUnavailability(\"proc.cant.create.loader\",\n-                        processorLoaderException);\n+                processorIterator = new ServiceIterator(processorClassLoader, log);\n@@ -367,41 +349,0 @@\n-    \/**\n-     * Returns an empty processor iterator if no processors are on the\n-     * relevant path, otherwise if processors are present, logs an\n-     * error.  Called when a service loader is unavailable for some\n-     * reason, either because a service loader class cannot be found\n-     * or because a security policy prevents class loaders from being\n-     * created.\n-     *\n-     * @param key The resource key to use to log an error message\n-     * @param e   If non-null, pass this exception to Abort\n-     *\/\n-    private Iterator<Processor> handleServiceLoaderUnavailability(String key, Exception e) {\n-        if (fileManager instanceof JavacFileManager standardFileManager) {\n-            Iterable<? extends Path> workingPath = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)\n-                ? standardFileManager.getLocationAsPaths(ANNOTATION_PROCESSOR_PATH)\n-                : standardFileManager.getLocationAsPaths(CLASS_PATH);\n-\n-            if (needClassLoader(options.get(Option.PROCESSOR), workingPath) )\n-                handleException(key, e);\n-\n-        } else {\n-            handleException(key, e);\n-        }\n-\n-        return Collections.emptyIterator();\n-    }\n-\n-    \/**\n-     * Handle a security exception thrown during initializing the\n-     * Processor iterator.\n-     *\/\n-    private void handleException(String key, Exception e) {\n-        if (e != null) {\n-            log.error(key, e.getLocalizedMessage());\n-            throw new Abort(e);\n-        } else {\n-            log.error(key);\n-            throw new Abort();\n-        }\n-    }\n-\n@@ -421,7 +362,2 @@\n-                try {\n-                    loader = ServiceLoader.load(Processor.class, classLoader);\n-                    this.iterator = loader.iterator();\n-                } catch (Exception e) {\n-                    \/\/ Fail softly if a loader is not actually needed.\n-                    this.iterator = handleServiceLoaderUnavailability(\"proc.no.service\", null);\n-                }\n+                loader = ServiceLoader.load(Processor.class, classLoader);\n+                this.iterator = loader.iterator();\n@@ -694,1 +630,1 @@\n-                       boolean allowModules, ProcessingEnvironment env, boolean lint) {\n+                       boolean allowModules, ProcessingEnvironment env, Lint lint) {\n@@ -717,2 +653,2 @@\n-                    if (lint && !patternAdded) {\n-                        log.warning(Warnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n+                    if (!patternAdded) {\n+                        lint.logIfEnabled(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n@@ -729,2 +665,1 @@\n-                if (lint &&\n-                    supportedAnnotationPatterns.contains(MatchingUtils.validImportStringToPattern(\"*\")) &&\n+                if (supportedAnnotationPatterns.contains(MatchingUtils.validImportStringToPattern(\"*\")) &&\n@@ -732,1 +667,1 @@\n-                    log.warning(Warnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n+                    lint.logIfEnabled(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n@@ -739,2 +674,2 @@\n-                        if (lint && !optionAdded) {\n-                            log.warning(Warnings.ProcDuplicateOptionName(optionName,\n+                        if (!optionAdded) {\n+                            lint.logIfEnabled(LintWarnings.ProcDuplicateOptionName(optionName,\n@@ -957,1 +892,1 @@\n-        if (lint && unmatchedAnnotations.size() > 0) {\n+        if (lint.isEnabled(PROCESSING) && unmatchedAnnotations.size() > 0) {\n@@ -961,1 +896,1 @@\n-                log.warning(Warnings.ProcAnnotationsWithoutProcessors(unmatchedAnnotations.keySet()));\n+                log.warning(LintWarnings.ProcAnnotationsWithoutProcessors(unmatchedAnnotations.keySet()));\n@@ -1074,1 +1009,1 @@\n-                this.deferredDiagnosticHandler = new Log.DeferredDiagnosticHandler(log);\n+                this.deferredDiagnosticHandler = log.new DeferredDiagnosticHandler();\n@@ -1177,15 +1112,3 @@\n-            for (JCDiagnostic d: deferredDiagnosticHandler.getDiagnostics()) {\n-                switch (d.getKind()) {\n-                    case WARNING:\n-                        if (werror)\n-                            return true;\n-                        break;\n-\n-                    case ERROR:\n-                        if (fatalErrors || !d.isFlagSet(RECOVERABLE))\n-                            return true;\n-                        break;\n-                }\n-            }\n-\n-            return false;\n+            return deferredDiagnosticHandler.getDiagnostics().stream()\n+              .anyMatch(d -> (d.getKind() == Diagnostic.Kind.WARNING && werror) ||\n+                             (d.getKind() == Diagnostic.Kind.ERROR && (fatalErrors || !d.isFlagSet(RECOVERABLE))));\n@@ -1552,26 +1475,0 @@\n-    \/*\n-     * Called retroactively to determine if a class loader was required,\n-     * after we have failed to create one.\n-     *\/\n-    private boolean needClassLoader(String procNames, Iterable<? extends Path> workingpath) {\n-        if (procNames != null)\n-            return true;\n-\n-        URL[] urls = new URL[1];\n-        for(Path pathElement : workingpath) {\n-            try {\n-                urls[0] = pathElement.toUri().toURL();\n-                if (ServiceProxy.hasService(Processor.class, urls))\n-                    return true;\n-            } catch (MalformedURLException ex) {\n-                throw new AssertionError(ex);\n-            }\n-            catch (ServiceProxy.ServiceConfigurationError e) {\n-                log.error(Errors.ProcBadConfigFile(e.getLocalizedMessage()));\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n@@ -1756,1 +1653,1 @@\n-    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, boolean lint) {\n+    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, Lint lint) {\n@@ -1782,4 +1679,2 @@\n-    private static Pattern warnAndNoMatches(String s, Processor p, Log log, boolean lint) {\n-        if (lint) {\n-            log.warning(Warnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n-        }\n+    private static Pattern warnAndNoMatches(String s, Processor p, Log log, Lint lint) {\n+        lint.logIfEnabled(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":55,"deletions":160,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -711,0 +711,1 @@\n+# lint: this-escape\n@@ -714,0 +715,1 @@\n+# lint: this-escape\n@@ -734,0 +736,1 @@\n+# lint: text-blocks\n@@ -737,0 +740,1 @@\n+# lint: text-blocks\n@@ -890,0 +894,4 @@\n+# 0: symbol\n+compiler.err.annotation.array.too.large=\\\n+    Annotation array element too large in \\\"{0}\\\"\n+\n@@ -920,4 +928,0 @@\n-# 0: name\n-compiler.err.modifier.not.allowed.here=\\\n-    modifier {0} not allowed here\n-\n@@ -1098,5 +1102,0 @@\n-# 0: symbol, 1: list of type, 2: type\n-compiler.misc.cant.access.inner.cls.constr=\\\n-    cannot access constructor {0}({1})\\n\\\n-    an enclosing instance of type {2} is not in scope\n-\n@@ -1187,3 +1186,0 @@\n-compiler.err.proc.no.service=\\\n-    A ServiceLoader was not usable and is required for annotation processing.\n-\n@@ -1585,0 +1581,1 @@\n+# lint: path\n@@ -1610,0 +1607,1 @@\n+# lint: path\n@@ -1677,0 +1675,1 @@\n+# lint: output-file-clash\n@@ -1889,0 +1888,1 @@\n+# lint: serial\n@@ -1892,0 +1892,1 @@\n+# lint: dangling-doc-comments\n@@ -1896,0 +1897,1 @@\n+# lint: path\n@@ -1900,0 +1902,1 @@\n+# lint: path\n@@ -1904,0 +1907,1 @@\n+# lint: missing-explicit-ctor\n@@ -1907,0 +1911,1 @@\n+# lint: strictfp\n@@ -1910,0 +1915,1 @@\n+# lint: finally\n@@ -1914,0 +1920,1 @@\n+# lint: module\n@@ -1918,0 +1925,1 @@\n+# lint: incubating\n@@ -1922,0 +1930,1 @@\n+# lint: deprecation\n@@ -1926,0 +1935,1 @@\n+# lint: removal\n@@ -1930,0 +1940,1 @@\n+# lint: preview\n@@ -1939,0 +1950,1 @@\n+# lint: preview\n@@ -1943,0 +1955,1 @@\n+# lint: restricted\n@@ -1948,0 +1961,1 @@\n+# lint: deprecation\n@@ -1952,0 +1966,1 @@\n+# lint: removal\n@@ -1963,0 +1978,1 @@\n+# lint: serial\n@@ -1966,0 +1982,1 @@\n+# lint: serial\n@@ -1969,0 +1986,1 @@\n+# lint: serial\n@@ -1991,0 +2009,1 @@\n+# lint: serial\n@@ -1994,0 +2013,1 @@\n+# lint: serial\n@@ -1998,0 +2018,1 @@\n+# lint: serial\n@@ -2002,0 +2023,1 @@\n+# lint: serial\n@@ -2006,0 +2028,1 @@\n+# lint: serial\n@@ -2010,0 +2033,1 @@\n+# lint: serial\n@@ -2014,0 +2038,1 @@\n+# lint: serial\n@@ -2018,0 +2043,1 @@\n+# lint: serial\n@@ -2022,0 +2048,1 @@\n+# lint: serial\n@@ -2026,0 +2053,1 @@\n+# lint: serial\n@@ -2030,0 +2058,1 @@\n+# lint: serial\n@@ -2035,0 +2064,1 @@\n+# lint: serial\n@@ -2038,0 +2068,1 @@\n+# lint: serial\n@@ -2042,0 +2073,1 @@\n+# lint: serial\n@@ -2046,0 +2078,1 @@\n+# lint: serial\n@@ -2050,0 +2083,1 @@\n+# lint: serial\n@@ -2053,0 +2087,1 @@\n+# lint: serial\n@@ -2057,0 +2092,1 @@\n+# lint: serial\n@@ -2061,0 +2097,1 @@\n+# lint: serial\n@@ -2065,0 +2102,1 @@\n+# lint: serial\n@@ -2068,0 +2106,1 @@\n+# lint: serial\n@@ -2071,0 +2110,1 @@\n+# lint: serial\n@@ -2074,0 +2114,1 @@\n+# lint: serial\n@@ -2078,0 +2119,1 @@\n+# lint: serial\n@@ -2081,0 +2123,1 @@\n+# lint: serial\n@@ -2085,0 +2128,1 @@\n+# lint: serial\n@@ -2089,0 +2133,1 @@\n+# lint: overloads\n@@ -2093,0 +2138,1 @@\n+# lint: overrides\n@@ -2097,0 +2143,1 @@\n+# lint: overrides\n@@ -2109,0 +2156,1 @@\n+# lint: path\n@@ -2112,0 +2160,1 @@\n+# lint: fallthrough\n@@ -2116,0 +2165,1 @@\n+# lint: cast\n@@ -2133,0 +2183,1 @@\n+# lint: static\n@@ -2137,0 +2188,1 @@\n+# lint: static\n@@ -2141,0 +2193,1 @@\n+# lint: options\n@@ -2145,0 +2198,1 @@\n+# lint: options\n@@ -2169,0 +2223,1 @@\n+# lint: options\n@@ -2173,0 +2228,1 @@\n+# lint: options\n@@ -2184,0 +2240,1 @@\n+# lint: options\n@@ -2188,0 +2245,1 @@\n+# lint: classfile\n@@ -2191,0 +2249,1 @@\n+# lint: requires-automatic\n@@ -2194,0 +2253,1 @@\n+# lint: requires-transitive-automatic\n@@ -2203,0 +2263,1 @@\n+# lint: processing\n@@ -2207,0 +2268,1 @@\n+# lint: processing\n@@ -2211,0 +2273,1 @@\n+# lint: processing\n@@ -2215,0 +2278,1 @@\n+# lint: processing\n@@ -2219,0 +2283,1 @@\n+# lint: processing\n@@ -2227,0 +2292,1 @@\n+# lint: processing\n@@ -2231,0 +2297,1 @@\n+# lint: processing\n@@ -2239,0 +2306,1 @@\n+# lint: processing\n@@ -2243,0 +2311,1 @@\n+# lint: processing\n@@ -2246,0 +2315,1 @@\n+\n@@ -2247,0 +2317,1 @@\n+# lint: processing\n@@ -2274,0 +2345,1 @@\n+# lint: try\n@@ -2278,0 +2350,1 @@\n+# lint: try\n@@ -2282,0 +2355,1 @@\n+# lint: try\n@@ -2285,0 +2359,1 @@\n+# lint: unchecked\n@@ -2289,0 +2364,1 @@\n+# lint: unchecked\n@@ -2293,0 +2369,1 @@\n+# lint: unchecked\n@@ -2296,0 +2373,1 @@\n+# lint: unchecked\n@@ -2300,0 +2378,1 @@\n+# lint: unchecked\n@@ -2306,0 +2385,1 @@\n+# lint: unchecked\n@@ -2310,0 +2390,1 @@\n+# lint: unchecked\n@@ -2314,0 +2395,1 @@\n+# lint: varargs\n@@ -2317,0 +2399,1 @@\n+# lint: dep-ann\n@@ -2321,0 +2404,1 @@\n+# lint: deprecation\n@@ -2325,0 +2409,1 @@\n+# lint: path\n@@ -2337,0 +2422,1 @@\n+# lint: path\n@@ -2341,0 +2427,1 @@\n+# lint: path\n@@ -2348,0 +2435,1 @@\n+# lint: divzero\n@@ -2351,0 +2439,1 @@\n+# lint: empty\n@@ -2355,0 +2444,1 @@\n+# lint: classfile\n@@ -2359,0 +2449,1 @@\n+# lint: classfile\n@@ -2377,0 +2468,1 @@\n+# lint: rawtypes\n@@ -2394,0 +2486,1 @@\n+# lint: varargs\n@@ -2398,0 +2491,1 @@\n+# lint: serial\n@@ -2402,0 +2496,1 @@\n+# lint: serial\n@@ -2559,0 +2654,1 @@\n+# lint: classfile\n@@ -2565,0 +2661,1 @@\n+# lint: classfile\n@@ -2691,0 +2788,1 @@\n+# lint: unchecked\n@@ -2705,0 +2803,1 @@\n+# lint: lossy-conversions\n@@ -2880,0 +2979,1 @@\n+# lint: auxiliaryclass\n@@ -2893,0 +2993,5 @@\n+## The first argument ({0}) is a \"kindname\".\n+# 0: symbol kind, 1: symbol\n+compiler.err.local.cant.be.inst.static=\\\n+    local {0} {1} cannot be instantiated from a static context\n+\n@@ -3079,0 +3184,1 @@\n+# lint: unchecked\n@@ -3084,0 +3190,1 @@\n+# lint: unchecked\n@@ -3089,0 +3196,1 @@\n+# lint: overrides\n@@ -3181,0 +3289,1 @@\n+# lint: preview\n@@ -3185,0 +3294,1 @@\n+# lint: preview\n@@ -3189,0 +3299,1 @@\n+# lint: preview\n@@ -3258,0 +3369,4 @@\n+# L10N: do not localize: transitive\n+compiler.misc.feature.java.base.transitive=\\\n+    transitive modifier for java.base\n+\n@@ -3568,0 +3683,1 @@\n+# lint: module\n@@ -3663,0 +3779,1 @@\n+# lint: opens\n@@ -3746,0 +3863,1 @@\n+# lint: options\n@@ -3761,0 +3879,1 @@\n+# lint: options\n@@ -3780,1 +3899,1 @@\n-    bad requires flag: {0}\n+    invalid flag for \"requires java.base\": {0}\n@@ -3791,0 +3910,1 @@\n+# lint: exports\n@@ -3794,0 +3914,1 @@\n+# lint: exports\n@@ -3797,0 +3918,1 @@\n+# lint: exports\n@@ -3800,0 +3922,1 @@\n+# lint: exports\n@@ -4129,0 +4252,1 @@\n+# lint: preview\n@@ -4132,0 +4256,1 @@\n+# lint: synchronization\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":139,"deletions":14,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -541,0 +541,2 @@\n+        \/** A scope for all single module imports. *\/\n+        public StarImportScope moduleImportScope;\n@@ -897,1 +899,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -2285,0 +2286,2 @@\n+        public Type erasedExprOriginalType;\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+    public final Name java_se;\n@@ -323,0 +324,1 @@\n+        java_se = fromString(\"java.se\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-                return CodeModelStorageOption.CODE_BUILDER;\n+                return CodeModelStorageOption.TEXT;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-#  Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,2 @@\n-    :jdk_jpackage\n+    :jdk_jpackage \\\n+    :jdk_since_checks\n@@ -101,1 +102,2 @@\n-   -:tier3\n+   -:tier3 \\\n+   :jdk_foreign_stress\n@@ -384,1 +386,6 @@\n-    -java\/foreign\/TestMatrix.java\n+    -java\/foreign\/TestMatrix.java \\\n+    -java\/foreign\/TestUpcallStress.java\n+\n+jdk_foreign_stress = \\\n+    java\/foreign\/TestMatrix.java \\\n+    java\/foreign\/TestUpcallStress.java\n@@ -424,2 +431,1 @@\n-    javax\/accessibility \\\n-    com\/sun\/java\/accessibility\n+    javax\/accessibility\n@@ -628,5 +634,0 @@\n-    com\/sun\/security\/sasl\/gsskerb\/AuthOnly.java \\\n-    com\/sun\/security\/sasl\/gsskerb\/ConfSecurityLayer.java \\\n-    com\/sun\/security\/sasl\/gsskerb\/NoSecurityLayer.java \\\n-    sun\/security\/provider\/PolicyFile\/GrantAllPermToExtWhenNoPolicy.java \\\n-    sun\/security\/provider\/PolicyParser\/PrincipalExpansionError.java \\\n@@ -655,1 +656,0 @@\n-    java\/security\/Policy\/Root\/Root.java \\\n@@ -669,0 +669,4 @@\n+# Set of tests for `@since` checks in source code documentation\n+jdk_since_checks = \\\n+   tools\/sincechecker\/\n+\n","filename":"test\/jdk\/TEST.groups","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n@@ -39,0 +39,1 @@\n+ * @modules java.base\/jdk.internal.classfile.components\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n@@ -57,0 +57,1 @@\n+ * @modules java.base\/jdk.internal.classfile.components\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n@@ -53,1 +53,0 @@\n- * @enablePreview\n@@ -55,0 +54,2 @@\n+ * @modules java.base\/jdk.internal.classfile.components\n+ * @enablePreview\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n@@ -22,0 +22,1 @@\n+ * @modules java.base\/jdk.internal.classfile.components\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -19,0 +19,1 @@\n+compiler.err.annotation.array.too.large                 # Code\n@@ -36,1 +37,0 @@\n-compiler.err.proc.no.service                            # JavacProcessingEnvironment: no service loader available\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}