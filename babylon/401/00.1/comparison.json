{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=babylon\n@@ -7,2 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists,copyright\n-warning=issuestitle,binary\n+error=author,committer,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n@@ -37,5 +36,0 @@\n-\n-[checks \"copyright\"]\n-files=^(?!LICENSE|license\\.txt|.*\\.bin|.*\\.gif|.*\\.jpg|.*\\.png|.*\\.icon|.*\\.tiff|.*\\.dat|.*\\.patch|.*\\.wav|.*\\.class|.*-header|.*\\.jar).*\n-oracle_locator=.*Copyright \\(c\\)(.*)Oracle and\/or its affiliates\\. All rights reserved\\.\n-oracle_validator=.*Copyright \\(c\\) (\\d{4})(?:, (\\d{4}))?, Oracle and\/or its affiliates\\. All rights reserved\\.\n","filename":".jcheck\/conf","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>onnx<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>25<\/maven.compiler.source>\n+        <maven.compiler.target>25<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>com.microsoft.onnxruntime<\/groupId>\n+            <artifactId>onnxruntime<\/artifactId>\n+            <version>1.20.0<\/version>\n+            <scope>runtime<\/scope>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>com.google.protobuf<\/groupId>\n+            <artifactId>protobuf-java<\/artifactId>\n+            <version>4.29.3<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <pluginManagement>\n+            <plugins>\n+                <plugin>\n+                    <groupId>org.apache.maven.plugins<\/groupId>\n+                    <artifactId>maven-surefire-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                    <configuration>\n+                        <argLine>--enable-preview --add-modules jdk.incubator.code\n+                        <\/argLine>\n+                    <\/configuration>\n+                <\/plugin>\n+            <\/plugins>\n+        <\/pluginManagement>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                        <arg>--add-modules<\/arg><arg>jdk.incubator.code<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/onnx\/pom.xml","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2024 Intel Corporation. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>intel.code<\/groupId>\n+    <artifactId>spirv<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>25<\/maven.compiler.source>\n+        <maven.compiler.target>25<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+        <dependency>\n+             <groupId>beehive-lab<\/groupId>\n+             <artifactId>beehive-spirv-lib<\/artifactId>\n+             <version>0.0.3<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                        <arg>--add-modules=jdk.incubator.vector<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+             <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-surefire-plugin<\/artifactId>\n+                <version>3.1.2<\/version>\n+                <configuration>\n+                    <argLine>--enable-preview<\/argLine>\n+                    <argLine>--add-modules=jdk.incubator.vector<\/argLine>\n+                    <redirectTestOutputToFile>false<\/redirectTestOutputToFile>\n+                <\/configuration>\n+            <\/plugin>\n+            <plugin>\n+              <groupId>org.codehaus.mojo<\/groupId>\n+              <artifactId>exec-maven-plugin<\/artifactId>\n+              <version>1.4.0<\/version>\n+              <configuration>\n+                <mainClass>intel.code.spirv.ExampleUseTest<\/mainClass>\n+                <configuration>\n+                    <argLine>--enable-preview<\/argLine>\n+                    <argLine>--add-modules=jdk.incubator.vector<\/argLine>\n+                <\/configuration>\n+             <\/configuration>\n+            <\/plugin>\n+\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/spirv\/pom.xml","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>triton<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>25<\/maven.compiler.source>\n+        <maven.compiler.target>25<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <pluginManagement>\n+            <plugins>\n+                <plugin>\n+                    <groupId>org.apache.maven.plugins<\/groupId>\n+                    <artifactId>maven-surefire-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                    <configuration>\n+                        <argLine>--enable-preview\n+                        <\/argLine>\n+                        <systemPropertyVariables>\n+                            <project.build.directory>${project.build.directory}<\/project.build.directory>\n+                        <\/systemPropertyVariables>\n+                    <\/configuration>\n+                <\/plugin>\n+            <\/plugins>\n+        <\/pluginManagement>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.13.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/triton\/pom.xml","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.ParameterContext;\n+import org.junit.jupiter.api.extension.ParameterResolver;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.lang.ScopedValue;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.parser.OpParser;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TritonTestExtension implements ParameterResolver {\n+\n+    @Target({ElementType.METHOD, ElementType.FIELD})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Kernel {\n+        String value();\n+    }\n+\n+    @Override\n+    public boolean supportsParameter(ParameterContext pc, ExtensionContext ec) {\n+        return pc.getParameter().getType() == TritonTestData.class;\n+    }\n+\n+    @Override\n+    public Object resolveParameter(ParameterContext pc, ExtensionContext ec) {\n+        Kernel k = ec.getRequiredTestMethod().getAnnotation(Kernel.class);\n+        String kernelName = (k != null)\n+            ? k.value()\n+            : ec.getRequiredTestMethod().getName();\n+\n+        return new TritonTestData(ec.getRequiredTestClass(), kernelName);\n+    }\n+\n+    public static class TritonTestData {\n+        final Class<?> testClass;\n+        final String javaKernelName;\n+\n+        public TritonTestData(Class<?> testClass, String javaKernelName) {\n+            this.testClass = testClass;\n+            this.javaKernelName = javaKernelName;\n+        }\n+\n+        public void test(List<? extends TypeElement> argTypes) {\n+            Optional<Method> om = Stream.of(testClass.getDeclaredMethods())\n+                    .filter(m -> m.getName().equals(javaKernelName))\n+                    .filter(m -> m.getAnnotation(CodeReflection.class) != null)\n+                    .findFirst();\n+            Method m = om.get();\n+            TritonCodeModel tcm = m.getAnnotation(TritonCodeModel.class);\n+            boolean doSSA = tcm != null ? tcm.SSA() : true;\n+            test(Op.ofMethod(m).get(), argTypes, expectedTritonKernel(tcm), doSSA);\n+        }\n+\n+        public TritonOps.ModuleOp expectedTritonKernel(TritonCodeModel tcm) {\n+            if (tcm == null || tcm.value().isEmpty()) {\n+                return null;\n+            }\n+\n+            return (TritonOps.ModuleOp) OpParser.fromString(\n+                    TritonOps.FACTORY.andThen(ArithMathOps.FACTORY)\n+                            .andThen(TritonTestOps.FACTORY)\n+                            .andThen(SCFOps.FACTORY)\n+                            .andThen(CoreOp.FACTORY),\n+                    TritonOps.TYPE_FACTORY,\n+                    tcm.value()).get(0);\n+        }\n+\n+        void test(CoreOp.FuncOp javaKernel,\n+                  List<? extends TypeElement> argTypes,\n+                  TritonOps.ModuleOp expectedTritonKernel,\n+                  boolean doSSA) {\n+            TritonOps.ModuleOp actualTritonKernel = ScopedValue.where(TritonTransformer.SV_SSA, doSSA).call(() -> {\n+                return TritonTransformer.tritonModule(javaKernel, JavaType.VOID, argTypes);\n+            });\n+\n+            String mlirText = MLIRGenerator.transform(actualTritonKernel);\n+            Path buildDir = Path.of(System.getProperty(\"project.build.directory\", \"\"));\n+            Path mlirDir = buildDir.resolve(\"mlir\");\n+            try {\n+                Files.createDirectories(mlirDir);\n+                Files.writeString(mlirDir.resolve(javaKernelName + \".mlir\"), mlirText, StandardOpenOption.CREATE);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+\n+            Assertions.assertEquals(\n+                    expectedTritonKernel == null ? \"NO @TritonCodeModel\" : expectedTritonKernel.toText(),\n+                    actualTritonKernel.toText());\n+        }\n+    }\n+\n+}\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonTestExtension.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+# Building HAT\n+\n+----\n+\n+* [Contents](hat-00.md)\n+* House Keeping\n+    * [Project Layout](hat-01-01-project-layout.md)\n+    * [Building Babylon](hat-01-02-building-babylon.md)\n+    * [Building HAT](hat-01-03-building-hat.md)\n+* Programming Model\n+    * [Programming Model](hat-03-programming-model.md)\n+* Interface Mapping\n+    * [Interface Mapping Overview](hat-04-01-interface-mapping.md)\n+    * [Cascade Interface Mapping](hat-04-02-cascade-interface-mapping.md)\n+* Implementation Detail\n+    * [Walkthrough Of Accelerator.compute()](hat-accelerator-compute.md)\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n+\n+---\n+\n+# Building HAT with Script\n+\n+We initially used maven and cmake to build hat.  If you feel more comfortable\n+with maven consider [building with maven and cmake](hat-01-03-building-hat-with-maven.md)\n+but it is possible that maven support will be removed if the `Script` approach takes off.\n+\n+## Dependencies\n+\n+Before we start to build HAT we will need `cmake` and `jextract` installed.\n+\n+You can download jextract from [here](https:\/\/jdk.java.net\/jextract\/)\n+\n+Use `sudo apt` on Linux or `brew install`.\n+\n+```bash\n+sudo apt install cmake\n+\n+```\n+\n+```bash\n+brew install cmake\n+```\n+\n+\n+You will also need a Babylon JDK built (the one we built [here](hat-01-02-building-babylon.md))\n+\n+\n+## Setting your PATH variable\n+\n+To build HAT we will need `JAVA_HOME` to point to our prebuilt babylon jdk\n+\n+I suggest you also create a `JEXTRACT_HOME` var to point to the location where you placed JEXTRACT)\n+\n+In my case\n+```\n+export JEXTRACT_HOME=\/Users\/me\/jextract-22\n+```\n+\n+Make sure also that `cmake` in in your PATH\n+\n+## .\/env.bash\n+\n+Thankfully just sourcing the top level `env.bash` script should then be able to set up your PATH for you.\n+\n+It should detect the arch type (AARCH64 or X86_46) and\n+select the correct relative parent dir for your BABYLON_JDK and inject that dir in your PATH.\n+\n+It should also add jextract to your PATH (based on the value you set above for JEXTRACT_HOME)\n+\n+\n+\n+```bash\n+cd hat\n+export JEXTRACT_HOME=\/Users\/me\/jextract-22\n+. .\/env.bash\n+echo ${JAVA_HOME}\n+\/Users\/me\/github\/babylon\/hat\/..\/build\/macosx-aarch64-server-release\/jdk\n+echo ${PATH}\n+\/Users\/me\/github\/babylon\/hat\/..\/build\/macosx-aarch64-server-release\/jdk\/bin:\/Users\/me\/jextract-22\/bin:\/usr\/local\/bin:......\n+```\n+\n+## Building using bld\n+\n+To build hat artifacts (hat jar + backends and examples)\n+```bash\n+java @hat\/bld\n+```\n+\n+This places build artifacts in the `build` and `stages` dirs\n+\n+```bash\n+cd hat\n+. .\/env.bash\n+java @hat\/bld\n+ls build\n+hat-1.0.jar                         hat-example-heal-1.0.jar        libptx_backend.dylib\n+hat-backend-ffi-cuda-1.0.jar        hat-example-mandel-1.0.jar      libspirv_backend.dylib\n+hat-backend-ffi-mock-1.0.jar        hat-example-squares-1.0.jar     mock_info\n+hat-backend-ffi-opencl-1.0.jar      hat-example-view-1.0.jar        opencl_info\n+hat-backend-ffi-ptx-1.0.jar         hat-example-violajones-1.0.jar  ptx_info\n+hat-backend-ffi-spirv-1.0.jar       libmock_backend.dylib           spirv_info\n+hat-example-experiments-1.0.jar     libopencl_backend.dylib\n+ls stage\n+opencl_jextracted    opengl_jextracted\n+```\n+\n+`bld` relies on cmake to build native code for backends, so if cmake finds OpenCL libs\/headers, you will see libopencl_backend (.so or .dylib) in the build dir, if cmake finds CUDA you will see libcuda_backend(.so or .dylib)\n+\n+We have another script called `sanity` which will check all  .md\/.java\/.cpp\/.h for tabs, lines that end with whitespace\n+or files without appropriate licence headers\n+\n+This is run using\n+\n+```\n+java @hat\/sanity\n+```\n+\n+\n+## Running an example\n+\n+To run a HAT example we can run from the artifacts in `build` dir\n+\n+```bash\n+${JAVA_HOME}\/bin\/java \\\n+   --add-modules jdk.incubator.code --enable-preview --enable-native-access=ALL-UNNAMED \\\n+   --class-path build\/hat-1.0.jar:build\/hat-example-mandel-1.0.jar:build\/hat-backend-ffi-opencl-1.0.jar \\\n+   --add-exports=java.base\/jdk.internal=ALL-UNNAMED \\\n+   -Djava.library.path=build\\\n+   mandel.Main\n+```\n+\n+The `hat\/run.java` script can also be used which simply needs the backend\n+name `ffi-opencl|ffi-java|ffi-cuda|ffi-ptx|ffi-mock` and the package name `mandel`\n+\n+```bash\n+java @hat\/run ffi-opencl mandel\n+```\n+\n+If you pass `headless` as the first arg\n+\n+```bash\n+java @hat\/run headless opencl mandel\n+```\n+\n+This sets `-Dheadless=true` and passes '--headless' to the example.  Some examples can use this to avoid launching UI.\n+\n+\n+# More Bld info\n+`hat\/Script.java` is an evolving set of static methods and types required (so far.. ;) )\n+to be able to build HAT, hat backends and examples via the `bld` script\n+\n+We rely on java's ability to launch java source directly (without needing to javac first)\n+\n+* [JEP 458: Launch Multi-File Source-Code Program](https:\/\/openjdk.org\/jeps\/458)\n+* [JEP 330: Launch Single-File Source-Code Programs](https:\/\/openjdk.org\/jeps\/330)\n+\n+The `hat\/bld.java` script (really java source) can be run like this\n+\n+```bash\n+java --add-modules jdk.incubator.code --enable-preview --source 25 bld\n+```\n+\n+In our case the  magic is under the `hat`subdir\n+\n+We also have a handy `hat\/XXXX` which allows us to avoid specifying common args `--enable-preview --source 25` eash time we launch a script\n+\n+```\n+hat\n+├── hat\n+|   ├── Script.java\n+|   ├── sanity      (the args for sanity.java)  \"--enable-preview --source 25 sanity\"\n+|   |-- sanity.java (the script)\n+|   ├── run         (the args for sanity.java)  \"--enable-preview --source 25 hatrun\"\n+|   |-- run.java    (the script)\n+|   ├── bld         (the args for bld.java)      \"--enable-preview --source 25 bld\"\n+|   ├── bld.java    (the script)\n+\n+```\n+\n+For example\n+```bash\n+java @hat\/bld\n+```\n+\n+Is just a shortcut for\n+```bash\n+java --enable-preview --source 25 hat\/bld.java\n+```\n","filename":"hat\/docs\/hat-01-03-building-hat.md","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,4576 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\n+import com.sun.source.util.JavacTask;\n+import org.w3c.dom.Attr;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpression;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipFile;\n+\n+import static java.io.IO.print;\n+import static java.io.IO.println;\n+\n+public class Script {\n+    public sealed interface PathHolder permits ClassPathEntry, DirPathHolder, FilePathHolder, SourcePathEntry {\n+        default Path path(String subdir) {\n+            return path().resolve(subdir);\n+        }\n+\n+        default String fileName() {\n+            return path().getFileName().toString();\n+        }\n+\n+        default Matcher pathMatcher(Pattern pattern) {\n+            return pattern.matcher(path().toString());\n+        }\n+\n+        default boolean matches(Pattern pattern) {\n+            return pathMatcher(pattern).matches();\n+        }\n+\n+        default boolean matches(String pattern) {\n+            return pathMatcher(Pattern.compile(pattern)).matches();\n+        }\n+        default boolean failsToMatch(String pattern) {\n+            return !pathMatcher(Pattern.compile(pattern)).matches();\n+        }\n+\n+        boolean exists();\n+\n+        Path path();\n+    }\n+\n+    public sealed interface DirPathHolder<T extends DirPathHolder<T>> extends PathHolder\n+            permits BuildDirHolder, DirEntry, SourceDir {\n+\n+        default Stream<Path> find() {\n+            try {\n+                return Files.walk(path());\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        default Stream<Path> find(Predicate<Path> predicate) {\n+            return find().filter(predicate);\n+        }\n+\n+        default Stream<Path> findFiles() {\n+            return find(Files::isRegularFile);\n+        }\n+\n+        default Stream<Path> findDirs() {\n+            return find(Files::isDirectory);\n+        }\n+\n+        default Stream<Path> findFiles(Predicate<Path> predicate) {\n+            return findFiles().filter(predicate);\n+        }\n+\n+        default Stream<Path> findFilesBySuffix(String suffix) {\n+            return findFiles(p -> p.toString().endsWith(suffix));\n+        }\n+\n+        default Stream<SearchableTextFile> findTextFiles(String... suffixes) {\n+            return findFiles()\n+                    .map(SearchableTextFile::new)\n+                    .filter(searchableTextFile -> searchableTextFile.hasSuffix(suffixes));\n+        }\n+\n+        default Stream<Path> findDirs(Predicate<Path> predicate) {\n+            return find(Files::isDirectory).filter(predicate);\n+        }\n+\n+        default boolean exists() {\n+            return Files.isDirectory(path());\n+        }\n+\n+        default BuildDir buildDir(String name) {\n+            return BuildDir.of(path().resolve(name));\n+        }\n+\n+        default SourceDir sourceDir(String s) {\n+            return SourceDir.of(path().resolve(s));\n+        }\n+\n+        default CppSourceFile cppSourceFile(String s) {\n+            return CppSourceFile.of(path().resolve(s));\n+        }\n+\n+        default XMLFile xmlFile(String s) {\n+            return XMLFile.of(path().resolve(s));\n+        }\n+\n+        default TestNGSuiteFile testNGSuiteFile(String s) {\n+            return TestNGSuiteFile.of(path().resolve(s));\n+        }\n+    }\n+\n+    public sealed interface FilePathHolder extends PathHolder {\n+        default boolean exists() {\n+            return Files.isRegularFile(path());\n+        }\n+    }\n+\n+    public sealed interface Executable extends FilePathHolder {\n+        default boolean exists() {\n+            return Files.exists(path()) && Files.isRegularFile(path()) && Files.isExecutable(path());\n+        }\n+    }\n+\n+\n+    public interface ClassPathEntryProvider {\n+        List<ClassPathEntry> classPathEntries();\n+    }\n+\n+    public sealed interface ClassPathEntry extends PathHolder, ClassPathEntryProvider {\n+    }\n+\n+    interface PathHolderList<T extends PathHolder> {\n+        List<T> entries();\n+\n+        default String charSeparated() {\n+            StringBuilder sb = new StringBuilder();\n+            entries().forEach(pathHolder -> {\n+                if (!sb.isEmpty()) {\n+                    sb.append(File.pathSeparatorChar);\n+                }\n+                sb.append(pathHolder.path());\n+            });\n+            return sb.toString();\n+        }\n+    }\n+\n+    public record ClassPath(List<ClassPathEntry> classPathEntries)\n+            implements PathHolderList<ClassPathEntry>, ClassPathEntryProvider {\n+        public static ClassPath of() {\n+            return new ClassPath(new ArrayList<>());\n+        }\n+\n+        public static ClassPath ofOrUse(ClassPath classPath) {\n+            return classPath == null ? of() : classPath;\n+        }\n+\n+        public ClassPath add(List<ClassPathEntryProvider> classPathEntryProviders) {\n+            classPathEntryProviders.forEach(\n+                    classPathEntryProvider ->\n+                            this.classPathEntries.addAll(classPathEntryProvider.classPathEntries()));\n+            return this;\n+        }\n+\n+        public ClassPath add(ClassPathEntryProvider... classPathEntryProviders) {\n+            return add(List.of(classPathEntryProviders));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return charSeparated();\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return this.classPathEntries;\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> entries() {\n+            return this.classPathEntries;\n+        }\n+    }\n+\n+    public record SourcePath(List<SourceDir> entries)\n+            implements PathHolderList<SourceDir> {\n+        public static SourcePath of() {\n+            return new SourcePath(new ArrayList<>());\n+        }\n+\n+        public static SourcePath ofOrUse(SourcePath sourcePath) {\n+            return sourcePath == null ? of() : sourcePath;\n+        }\n+\n+        public SourcePath add(List<SourceDir> sourcePathEntries) {\n+            entries.addAll(sourcePathEntries);\n+            return this;\n+        }\n+\n+        public SourcePath add(SourceDir... sourcePathEntries) {\n+            add(Arrays.asList(sourcePathEntries));\n+            return this;\n+        }\n+\n+        public SourcePath add(SourcePath... sourcePaths) {\n+            List.of(sourcePaths).forEach(sourcePath -> add(sourcePath.entries));\n+            return this;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return charSeparated();\n+        }\n+\n+        public Stream<Path> javaFiles() {\n+            List<Path> javaFiles = new ArrayList<>();\n+            entries.forEach(entry -> entry.javaFiles().forEach(javaFiles::add));\n+            return javaFiles.stream();\n+        }\n+    }\n+\n+    public record DirPath(List<DirPathHolder<?>> entries)\n+            implements PathHolderList<DirPathHolder<?>> {\n+        public static DirPath of() {\n+            return new DirPath(new ArrayList<>());\n+        }\n+\n+        public static DirPath ofOrUse(DirPath dirPath) {\n+            return dirPath == null ? of() : dirPath;\n+        }\n+\n+        public DirPath add(List<DirPathHolder<?>> dirPathHolders) {\n+            entries.addAll(dirPathHolders);\n+            return this;\n+        }\n+\n+        public DirPath add(DirPathHolder<?>... dirPathHolders) {\n+            add(Arrays.asList(dirPathHolders));\n+            return this;\n+        }\n+\n+        public DirPath add(DirPath... dirPaths) {\n+            List.of(dirPaths).forEach(dirPath -> add(dirPath.entries));\n+            return this;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return charSeparated();\n+        }\n+    }\n+\n+    public record CMakeBuildDir(Path path) implements BuildDirHolder<CMakeBuildDir> {\n+        public static CMakeBuildDir of(Path path) {\n+            return new CMakeBuildDir(path);\n+        }\n+\n+        @Override\n+        public CMakeBuildDir create() {\n+            return CMakeBuildDir.of(mkdir(path()));\n+        }\n+\n+        @Override\n+        public CMakeBuildDir remove() {\n+            return CMakeBuildDir.of(rmdir(path()));\n+        }\n+    }\n+\n+    public sealed interface BuildDirHolder<T extends BuildDirHolder<T>> extends DirPathHolder<T> {\n+        T create();\n+\n+        T remove();\n+\n+        default T clean() {\n+            remove();\n+            return create();\n+        }\n+\n+        default Path mkdir(Path path) {\n+            try {\n+                return Files.createDirectories(path);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        default Path rmdir(Path path) {\n+            try {\n+                if (Files.exists(path)) {\n+                    Files.walk(path)\n+                            .sorted(Comparator.reverseOrder())\n+                            .map(Path::toFile)\n+                            .forEach(File::delete);\n+                }\n+            } catch (IOException ioe) {\n+                System.out.println(ioe);\n+            }\n+            return path;\n+        }\n+    }\n+\n+\n+    public record ClassDir(Path path) implements ClassPathEntry, BuildDirHolder<ClassDir> {\n+        public static ClassDir of(Path path) {\n+            return new ClassDir(path);\n+        }\n+\n+        public static ClassDir temp() {\n+            try {\n+                return of(Files.createTempDirectory(\"javacClasses\"));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public ClassDir create() {\n+            return ClassDir.of(mkdir(path()));\n+        }\n+\n+        @Override\n+        public ClassDir remove() {\n+            return ClassDir.of(rmdir(path()));\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return List.of(this);\n+        }\n+    }\n+\n+    public record RepoDir(Path path) implements BuildDirHolder<RepoDir> {\n+        public static RepoDir of(Path path) {\n+            return new RepoDir(path);\n+        }\n+\n+        @Override\n+        public RepoDir create() {\n+            return RepoDir.of(mkdir(path()));\n+        }\n+\n+        @Override\n+        public RepoDir remove() {\n+            return RepoDir.of(rmdir(path()));\n+        }\n+\n+        public JarFile jarFile(String name) {\n+            return JarFile.of(path().resolve(name));\n+        }\n+\n+        public ClassPathEntryProvider classPathEntries(String... specs) {\n+            var repo = new MavenStyleRepository(this);\n+            return repo.classPathEntries(specs);\n+        }\n+    }\n+\n+    public record DirEntry(Path path) implements DirPathHolder<DirEntry> {\n+        public static DirEntry of(Path path) {\n+            return new DirEntry(path);\n+        }\n+\n+        public static DirEntry of(String string) {\n+            return of(Path.of(string));\n+        }\n+\n+        public static DirEntry ofExisting(String string) {\n+            return of(assertExists(Path.of(string)));\n+        }\n+\n+        public static DirEntry current() {\n+            return of(Path.of(System.getProperty(\"user.dir\")));\n+        }\n+\n+        public DirEntry parent() {\n+            return of(path().getParent());\n+        }\n+\n+        public DirEntry dir(String subdir) {\n+            return DirEntry.of(path(subdir));\n+        }\n+\n+        public FileEntry file(String fileName) {\n+            return FileEntry.of(path(fileName));\n+        }\n+\n+        public DirEntry existingDir(String subdir) {\n+            return assertExists(DirEntry.of(path(subdir)));\n+        }\n+\n+        public Stream<DirEntry> subDirs() {\n+            return Stream.of(Objects.requireNonNull(path().toFile().listFiles(File::isDirectory)))\n+                    .map(d -> DirEntry.of(d.getPath()));\n+        }\n+\n+     \/\/   public Stream<DirEntry> subDirs(Predicate<DirEntry> predicate) {\n+       \/\/     return subDirs().filter(predicate);\n+      \/\/  }\n+\n+        public XMLFile pom(\n+                String comment, Consumer<XMLNode.PomXmlBuilder> pomXmlBuilderConsumer) {\n+            XMLFile xmlFile = xmlFile(\"pom.xml\");\n+            XMLNode.createPom(comment, pomXmlBuilderConsumer).write(xmlFile);\n+            return xmlFile;\n+        }\n+\n+        public BuildDir existingBuildDir(String subdir) {\n+            return assertExists(BuildDir.of(path(subdir)));\n+        }\n+\n+\n+            public CMakeBuildDir cMakeBuildDir(String name) {\n+                return CMakeBuildDir.of(path().resolve(name));\n+            }\n+\n+    }\n+\n+    public interface SourcePathEntryProvider {\n+        List<SourcePathEntry> sourcePathEntries();\n+    }\n+\n+    public sealed interface SourcePathEntry extends PathHolder, SourcePathEntryProvider {\n+    }\n+\n+    public record SourceDir(Path path) implements SourcePathEntry, DirPathHolder<SourceDir> {\n+        public static SourceDir of(Path path) {\n+            return new SourceDir(path);\n+        }\n+        public static SourceDir of(DirEntry dirEntry) {\n+            return new SourceDir(dirEntry.path());\n+        }\n+        public static SourceDir of(BuildDir buildDir) {\n+            return new SourceDir(buildDir.path());\n+        }\n+\n+        public Stream<Path> javaFiles() {\n+            return findFilesBySuffix(\".java\");\n+        }\n+\n+        @Override\n+        public List<SourcePathEntry> sourcePathEntries() {\n+            return List.of(this);\n+        }\n+    }\n+\n+    public record RootDirAndSubPath(DirPathHolder<?> root, Path path) {\n+        Path relativize() {\n+            return root().path().relativize(path());\n+        }\n+    }\n+\n+    public record BuildDir(Path path) implements ClassPathEntry, BuildDirHolder<BuildDir> {\n+        public static BuildDir of(Path path) {\n+            return new BuildDir(path);\n+        }\n+\n+        public JarFile jarFile(String name) {\n+            return JarFile.of(path().resolve(name));\n+        }\n+\n+        public ClassPathEntryProvider jarFiles(String... names) {\n+            var classPath = ClassPath.of();\n+            Stream.of(names).forEach(name -> classPath.add(JarFile.of(path().resolve(name))));\n+            return classPath;\n+        }\n+\n+\n+        public CMakeBuildDir cMakeBuildDir(String name) {\n+            return CMakeBuildDir.of(path().resolve(name));\n+        }\n+\n+        public ClassDir classDir(String name) {\n+            return ClassDir.of(path().resolve(name));\n+        }\n+\n+        public RepoDir repoDir(String name) {\n+            return RepoDir.of(path().resolve(name));\n+        }\n+\n+        @Override\n+        public BuildDir create() {\n+            return BuildDir.of(mkdir(path()));\n+        }\n+\n+\n+        @Override\n+        public BuildDir remove() {\n+            return BuildDir.of(rmdir(path()));\n+        }\n+\n+        public BuildDir dir(String subdir) {\n+            return BuildDir.of(path(subdir));\n+        }\n+\n+        public ObjectFile objectFile(String name) {\n+            return ObjectFile.of(path().resolve(name));\n+        }\n+\n+        public ExecutableFile executableFile(String name) {\n+            return ExecutableFile.of(path().resolve(name));\n+        }\n+\n+        public SharedLibraryFile sharedLibraryFile(String name) {\n+            return SharedLibraryFile.of(path().resolve(name));\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return List.of(this);\n+        }\n+\n+        public SearchableTextFile textFile(String file, List<String> strings) {\n+            SearchableTextFile textFile = SearchableTextFile.of(path().resolve(file));\n+            try {\n+                PrintWriter pw = new PrintWriter(Files.newOutputStream(textFile.path(), StandardOpenOption.CREATE));\n+                strings.forEach(pw::print);\n+                pw.close();\n+                return textFile;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        public SearchableTextFile textFile(String file, Consumer<StringBuilder> stringBuilderConsumer) {\n+            SearchableTextFile textFile = SearchableTextFile.of(path().resolve(file));\n+            var sb = new StringBuilder();\n+            stringBuilderConsumer.accept(sb);\n+            try {\n+                Files.writeString(textFile.path, sb.toString());\n+                return textFile;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+\n+        public CMakeLists cmakeLists(Consumer<StringBuilder> stringBuilderConsumer) {\n+            var sb = new StringBuilder();\n+            stringBuilderConsumer.accept(sb);\n+            var ret = CMakeLists.of(path().resolve(\"CMakeLists.txt\"));\n+            try {\n+                Files.writeString(ret.path, sb.toString());\n+                return ret;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public record FileEntry(Path path) implements FilePathHolder {\n+        public static FileEntry of(Path path) {\n+            return new FileEntry(path);\n+        }\n+    }\n+\n+    public record JarFile(Path path) implements ClassPathEntry, FilePathHolder {\n+        public static JarFile of(Path path) {\n+            return new JarFile(path);\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return List.of(this);\n+        }\n+    }\n+\n+    public sealed interface TextFile extends FilePathHolder {\n+\n+        static Path tempContaining(String suffix, String text) {\n+            try {\n+                var path = Files.createTempFile(Files.createTempDirectory(\"bldr\"), \"data\", suffix);\n+                Files.newOutputStream(path).write(text.getBytes());\n+                return path;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+\n+    public sealed interface SourceFile extends TextFile {\n+    }\n+\n+    public static final class CMakeLists implements SourceFile {\n+        Path path;\n+\n+        CMakeLists(Path path) {\n+            this.path = path;\n+        }\n+\n+        public static CMakeLists of(Path path) {\n+            return new CMakeLists(path);\n+        }\n+\n+        @Override\n+        public Path path() {\n+            return path;\n+        }\n+    }\n+\n+    public static final class JavaSourceFile extends SimpleJavaFileObject implements SourceFile {\n+        Path path;\n+\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            try {\n+                return Files.readString(Path.of(toUri()));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        JavaSourceFile(Path path) {\n+            super(path.toUri(), Kind.SOURCE);\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public Path path() {\n+            return path;\n+        }\n+    }\n+\n+    public record JExtractExecutable(Path path) implements Executable {\n+        public static JExtractExecutable of(Path path) {\n+            return new JExtractExecutable(path);\n+        }\n+    }\n+\n+\n+    public record ObjectFile(Path path) implements FilePathHolder {\n+        public static ObjectFile of(Path path) {\n+            return new ObjectFile(path);\n+        }\n+    }\n+\n+    public record ExecutableFile(Path path) implements FilePathHolder {\n+        public static ExecutableFile of(Path path) {\n+            return new ExecutableFile(path);\n+        }\n+    }\n+\n+    public record SharedLibraryFile(Path path) implements FilePathHolder {\n+        public static SharedLibraryFile of(Path path) {\n+            return new SharedLibraryFile(path);\n+        }\n+    }\n+\n+    public record CppSourceFile(Path path) implements SourceFile {\n+        public static CppSourceFile of(Path path) {\n+            return new CppSourceFile(path);\n+        }\n+    }\n+\n+    public record CppHeaderSourceFile(Path path) implements SourceFile {\n+    }\n+\n+    public record XMLFile(Path path) implements TextFile {\n+        public static XMLFile of(Path path) {\n+            return new XMLFile(path);\n+        }\n+\n+        public static XMLFile containing(String text) {\n+            return XMLFile.of(TextFile.tempContaining(\"xml\", text));\n+        }\n+    }\n+\n+    public record TestNGSuiteFile(Path path) implements TextFile {\n+        public static TestNGSuiteFile of(Path path) {\n+            return new TestNGSuiteFile(path);\n+        }\n+\n+        public static TestNGSuiteFile containing(String text) {\n+            return TestNGSuiteFile.of(TextFile.tempContaining(\"xml\", text));\n+        }\n+    }\n+\n+    public interface OS {\n+        String arch();\n+\n+        String name();\n+\n+        String version();\n+\n+        String MacName = \"Mac OS X\";\n+        String LinuxName = \"Linux\";\n+\n+        record Linux(String arch, String name, String version) implements OS {\n+        }\n+\n+        record Mac(String arch, String name, String version) implements OS {\n+            public Path appLibFrameworks() {\n+                return Path.of(\n+                        \"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/\"\n+                                + \"MacOSX.sdk\/System\/Library\/Frameworks\");\n+            }\n+\n+            public Path frameworkHeader(String frameworkName, String headerFileName) {\n+                return appLibFrameworks().resolve(frameworkName + \".framework\/Headers\/\" + headerFileName);\n+            }\n+\n+            public Path libFrameworks() {\n+                return Path.of(\"\/System\/Library\/Frameworks\");\n+            }\n+\n+            public Path frameworkLibrary(String frameworkName) {\n+                return libFrameworks().resolve(frameworkName + \".framework\/\" + frameworkName);\n+            }\n+        }\n+\n+        static OS get() {\n+            String arch = System.getProperty(\"os.arch\");\n+            String name = System.getProperty(\"os.name\");\n+            String version = System.getProperty(\"os.version\");\n+            return switch (name) {\n+                case \"Mac OS X\" -> new Mac(arch, name, version);\n+                case \"Linux\" -> new Linux(arch, name, version);\n+                default -> throw new IllegalStateException(\"No os mapping for \" + name);\n+            };\n+        }\n+    }\n+\n+    public static OS os = OS.get();\n+\n+    public record Java(String version, DirEntry home, int specVersion) {\n+    }\n+\n+    public static Java java =\n+            new Java(\n+                    System.getProperty(\"java.version\"),\n+                    DirEntry.of(System.getProperty(\"java.home\")),\n+                    Integer.parseInt(System.getProperty(\"java.specification.version\"))\n+            );\n+\n+    public record User(DirEntry home, DirEntry pwd) {\n+    }\n+\n+    public static User user =\n+            new User(DirEntry.of(System.getProperty(\"user.home\")), DirEntry.of(System.getProperty(\"user.dir\")));\n+\n+\n+    public abstract sealed static class Builder<T extends Builder<T>> permits CMakeBuilder, FormatBuilder, JExtractBuilder, JarBuilder, JarBuilder.ManifestBuilder, JavaOpts, TestNGBuilder {\n+        public Builder<?> parent;\n+        public boolean verbose;\n+        public boolean quiet;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T self() {\n+            return (T) this;\n+        }\n+\n+        protected T dontCallThisCopy(T other) {\n+            this.verbose = other.verbose;\n+            this.quiet = other.quiet;\n+            return self();\n+        }\n+\n+        public T quiet(boolean quiet) {\n+            this.quiet = quiet;\n+            return self();\n+        }\n+\n+        public T quiet() {\n+            quiet(true);\n+            return self();\n+        }\n+\n+        public T verbose(boolean verbose) {\n+            this.verbose = verbose;\n+            return self();\n+        }\n+\n+        public T verbose() {\n+            verbose(true);\n+            return self();\n+        }\n+\n+        public T when(boolean condition, Consumer<T> consumer) {\n+            if (condition) {\n+                consumer.accept(self());\n+            }\n+            return self();\n+        }\n+\n+        public <P extends PathHolder> T whenExists(P pathHolder, Consumer<T> consumer) {\n+            if (Files.exists(pathHolder.path())) {\n+                consumer.accept(self());\n+            }\n+            return self();\n+        }\n+\n+        public <P extends PathHolder> T whenExists(P pathHolder, BiConsumer<P, T> consumer) {\n+            if (Files.exists(pathHolder.path())) {\n+                consumer.accept(pathHolder, self());\n+            }\n+            return self();\n+        }\n+\n+        public T either(boolean condition, Consumer<T> trueConsumer, Consumer<T> falseConsumer) {\n+            if (condition) {\n+                trueConsumer.accept(self());\n+            } else {\n+                falseConsumer.accept(self());\n+            }\n+            return self();\n+        }\n+\n+        Builder(Builder<?> parent) {\n+            this.parent = parent;\n+        }\n+\n+        Builder() {\n+            this(null);\n+        }\n+\n+        public T mac(Consumer<OS.Mac> macConsumer) {\n+            if (Script.os instanceof OS.Mac mac) {\n+                macConsumer.accept(mac);\n+            }\n+            return self();\n+        }\n+\n+        public T linux(Consumer<OS.Linux> linuxConsumer) {\n+            if (Script.os instanceof OS.Linux linux) {\n+                linuxConsumer.accept(linux);\n+            }\n+            return self();\n+        }\n+\n+        public T os(Consumer<OS.Mac> macConsumer, Consumer<OS.Linux> linuxConsumer) {\n+            switch (Script.os) {\n+                case OS.Linux linux -> linuxConsumer.accept(linux);\n+                case OS.Mac mac -> macConsumer.accept(mac);\n+                default -> throw new IllegalStateException(\"Unexpected value: \" + Script.os);\n+            }\n+            ;\n+            return self();\n+        }\n+    }\n+\n+    public abstract static sealed class Result<T extends Builder<T>> permits JExtractResult, JarResult, JavaResult, JavacResult {\n+        public boolean ok;\n+        public T builder;\n+\n+        Result(T builder) {\n+            this.builder = builder;\n+        }\n+    }\n+\n+    public static class Strings {\n+        public List<String> strings = new ArrayList<>();\n+\n+        Strings() {\n+        }\n+\n+        Strings(Strings strings) {\n+            add(strings);\n+        }\n+\n+        Strings(List<String> strings) {\n+            add(strings);\n+        }\n+\n+        Strings(String... strings) {\n+            add(strings);\n+        }\n+\n+        public Strings add(List<String> strings) {\n+            this.strings.addAll(strings);\n+            return this;\n+        }\n+\n+        public Strings add(String... strings) {\n+            add(Arrays.asList(strings));\n+            return this;\n+        }\n+\n+        public Strings add(Strings strings) {\n+            add(strings.strings);\n+            return this;\n+        }\n+\n+        public String spaceSeparated() {\n+            StringBuilder stringBuilder = new StringBuilder();\n+            strings.forEach(opt -> stringBuilder.append(stringBuilder.isEmpty() ? \"\" : \" \").append(opt));\n+            return stringBuilder.toString();\n+        }\n+    }\n+\n+\n+    public static sealed class JavaOpts<T extends JavaOpts<T>> extends Builder<T> {\n+        public DirEntry jdk = java.home;\n+        public Boolean enablePreview;\n+        public Strings modules;\n+        protected boolean justShowCommandline;\n+\n+        record FromModulePackageToModule(String fromModule, String pkg, String toModule) {\n+        }\n+\n+        List<FromModulePackageToModule> exports;\n+\n+        protected T dontCallThisCopy(T other) {\n+            super.dontCallThisCopy(other);\n+            if (other.jdk != null) {\n+                this.jdk = other.jdk;\n+            }\n+            if (other.enablePreview != null) {\n+                this.enablePreview = other.enablePreview;\n+            }\n+            if (other.modules != null) {\n+                this.modules = new Strings(other.modules);\n+            }\n+            if (other.exports != null) {\n+                this.exports = new ArrayList<>(other.exports);\n+            }\n+\n+            return self();\n+        }\n+\n+        public JavaOpts(Builder<?> parent) {\n+            super(parent);\n+        }\n+\n+        public JavaOpts() {\n+            super();\n+        }\n+\n+        static public JavaOpts<?> of() {\n+            return new JavaOpts<>();\n+        }\n+\n+        public T jdk(DirEntry jdk) {\n+            this.jdk = jdk;\n+            return self();\n+        }\n+\n+        public T add_exports(String fromModule, String pkg, String toModule) {\n+            if (this.exports == null) {\n+                this.exports = new ArrayList<>();\n+            }\n+            exports.add(new FromModulePackageToModule(fromModule, pkg, toModule));\n+            return self();\n+        }\n+\n+        public T add_modules(String... modules) {\n+            if (this.modules == null) {\n+                this.modules = new Strings();\n+            }\n+            this.modules.add(modules);\n+\n+            return self();\n+        }\n+\n+        public T add_exports(String fromModule, List<String> packages, String toModule) {\n+\n+            packages.forEach(p -> add_exports(fromModule, p, toModule));\n+            return self();\n+        }\n+\n+        public T add_exports(String fromModule, String[] packages, String toModule) {\n+            return add_exports(fromModule, Arrays.asList(packages), toModule);\n+        }\n+\n+        public T add_exports_to_all_unnamed(String fromModule, String... packages) {\n+            return add_exports(fromModule, Arrays.asList(packages), \"ALL-UNNAMED\");\n+        }\n+\n+        public T enable_preview() {\n+            this.enablePreview = true;\n+            return self();\n+        }\n+\n+        public T justShowCommandline(boolean justShowCommandline) {\n+            this.justShowCommandline=justShowCommandline;\n+            return self();\n+        }\n+        public T justShowCommandline() {\n+            return justShowCommandline(true);\n+        }\n+\n+    }\n+\n+    public abstract sealed static class JavaToolBuilder<T extends JavaToolBuilder<T>> extends JavaOpts<T> permits JavacBuilder, JavaBuilder {\n+        public ClassPath classPath;\n+\n+\n+        protected T dontCallThisCopy(T other) {\n+            super.dontCallThisCopy(other);\n+            if (other.classPath != null) {\n+                this.classPath = ClassPath.of().add(other.classPath);\n+            }\n+            return self();\n+        }\n+\n+        public JavaToolBuilder(Builder<?> parent) {\n+            super(parent);\n+        }\n+\n+        public JavaToolBuilder() {\n+            super();\n+        }\n+\n+        public T class_path(List<ClassPathEntryProvider> classPathEntryProviders) {\n+            this.classPath = ClassPath.ofOrUse(this.classPath).add(classPathEntryProviders);\n+            return self();\n+        }\n+\n+        public T class_path(ClassPathEntryProvider... classPathEntryProviders) {\n+            return class_path(List.of(classPathEntryProviders));\n+        }\n+    }\n+\n+    public static final class JavacBuilder extends JavaToolBuilder<JavacBuilder> {\n+        public DirEntry mavenStyleRoot;\n+        public ClassDir classDir;\n+        public SourcePath sourcePath;\n+        public ClassPath modulePath;\n+        public SourcePath moduleSourcePath;\n+        public Integer source;\n+        public List<Predicate<JavaSourceFile>> exclusionFilters;\n+\n+        protected JavacBuilder dontCallThisCopy(JavacBuilder other) {\n+            super.dontCallThisCopy(other);\n+            if (other.mavenStyleRoot != null) {\n+                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to maven style dir\");\n+            }\n+            if (other.sourcePath != null) {\n+                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to a SourcePath\");\n+            }\n+            if (other.moduleSourcePath != null) {\n+                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to a ModuleSourcePath\");\n+            }\n+\n+            if (other.source != null) {\n+                this.source = other.source;\n+            }\n+\n+            if (other.classPath != null) {\n+                ClassPath.ofOrUse(this.classPath).add(other.classPath);\n+            }\n+            return this;\n+        }\n+\n+        public JavacBuilder source(int version) {\n+            this.source = version;\n+            return self();\n+        }\n+\n+        public JavacBuilder current_source() {\n+            return source(Script.java.specVersion);\n+        }\n+\n+        public JavacBuilder maven_style_root(DirEntry mavenStyleRoot) {\n+            this.mavenStyleRoot = mavenStyleRoot;\n+            return this;\n+        }\n+\n+        public JavacBuilder class_dir(Path classDir) {\n+            this.classDir = ClassDir.of(classDir);\n+            return this;\n+        }\n+\n+        public JavacBuilder class_dir(ClassDir classDir) {\n+            this.classDir = classDir;\n+            return this;\n+        }\n+\n+        public JavacBuilder d(ClassDir classDir) {\n+            this.classDir = classDir;\n+            return this;\n+        }\n+\n+        public JavacBuilder source_path(List<SourceDir> sourcePaths) {\n+            this.sourcePath = SourcePath.ofOrUse(this.sourcePath).add(sourcePaths);\n+            return this;\n+        }\n+\n+        public JavacBuilder source_path(SourceDir... sourcePathEntries) {\n+            return source_path(List.of(sourcePathEntries));\n+        }\n+\n+        public JavacBuilder source_path(SourcePath sourcePath) {\n+            return source_path(sourcePath.entries);\n+        }\n+\n+        public JavacBuilder module_source_path(List<SourceDir> moduleSourcePathEntries) {\n+            this.moduleSourcePath = SourcePath.ofOrUse(this.moduleSourcePath).add(moduleSourcePathEntries);\n+            return this;\n+        }\n+\n+        public JavacBuilder module_source_path(SourceDir... moduleSourcePathEntries) {\n+            return module_source_path(List.of(moduleSourcePathEntries));\n+        }\n+\n+        public JavacBuilder module_source_path(SourcePath moduleSourcePath) {\n+            return module_source_path(moduleSourcePath.entries());\n+        }\n+\n+        public JavacBuilder() {\n+            super();\n+        }\n+\n+        public JavacBuilder(JarBuilder jarBuilder) {\n+            super(jarBuilder);\n+        }\n+\n+        public JavacBuilder exclude(Predicate<JavaSourceFile> javaSourceFileFilter) {\n+            this.exclusionFilters = (this.exclusionFilters == null ? new ArrayList<>() : this.exclusionFilters);\n+            this.exclusionFilters.add(javaSourceFileFilter);\n+            return self();\n+        }\n+    }\n+\n+    public static final class JavacResult extends Result<JavacBuilder> {\n+        Strings opts = new Strings();\n+        List<JavaSourceFile> sourceFiles = new ArrayList<>();\n+        List<JavaFileObject> classes = new ArrayList<>();\n+        public ClassDir classDir;\n+\n+        JavacResult(JavacBuilder builder) {\n+            super(builder);\n+        }\n+    }\n+\n+    public static JavacResult javac(JavacBuilder javacBuilder) {\n+        JavacResult result = new JavacResult(javacBuilder);\n+\n+        try {\n+            if (javacBuilder.source != null) {\n+                result.opts.add(\"--source\", javacBuilder.source.toString());\n+            }\n+\n+            if (javacBuilder.enablePreview != null && javacBuilder.enablePreview) {\n+                result.opts.add(\"--enable-preview\");\n+            }\n+            if (javacBuilder.modules != null) {\n+                javacBuilder.modules.strings.forEach(module ->\n+                        result.opts.add(\"--add-modules\", module)\n+                );\n+            }\n+\n+            if (javacBuilder.exports != null) {\n+                javacBuilder.exports.forEach(fpt -> {\n+                    result.opts.add(\"--add-exports=\" + fpt.fromModule + \"\/\" + fpt.pkg + \"=\" + fpt.toModule);\n+                });\n+            }\n+\n+            result.classDir = javacBuilder.classDir == null ? ClassDir.temp() : javacBuilder.classDir;\n+            result.opts.add(\"-d\", result.classDir.path().toString());\n+            if (javacBuilder.classPath != null) {\n+                result.opts.add(\"--class-path\", javacBuilder.classPath.charSeparated());\n+            } else if (javacBuilder.modulePath != null) {\n+                \/\/https:\/\/dev.java\/learn\/modules\/building\/\n+                result.opts.add(\"--module-path\", javacBuilder.modulePath.charSeparated());\n+            } else {\n+                \/\/ println(\"Warning no class path or module path \");\n+                \/\/throw new RuntimeException(\"No class path or module path provided\");\n+            }\n+            var mavenStyleRoot =\n+                    ((javacBuilder.parent instanceof JarBuilder jarBuilder) && jarBuilder.mavenStyleRoot instanceof DirEntry fromJarBuilder)\n+                            ? fromJarBuilder\n+                            : javacBuilder.mavenStyleRoot;\n+\n+\n+            if (mavenStyleRoot == null) {\n+                if (javacBuilder.sourcePath != null && !javacBuilder.sourcePath.entries.isEmpty()) {\n+                    result.opts.add(\"--source-path\", javacBuilder.sourcePath.charSeparated());\n+                    result.sourceFiles.addAll(javacBuilder.sourcePath.javaFiles().map(JavaSourceFile::new).toList());\n+                } else if (javacBuilder.moduleSourcePath != null && !javacBuilder.moduleSourcePath.entries.isEmpty()) {\n+                    result.opts.add(\"--module-source-path\", javacBuilder.moduleSourcePath.charSeparated());\n+                    result.sourceFiles.addAll(javacBuilder.moduleSourcePath.javaFiles().map(JavaSourceFile::new).toList());\n+                } else {\n+                    throw new RuntimeException(\"No source path or module source path specified\");\n+                }\n+            } else {\n+                var sourcePath = SourcePath.of().add(SourceDir.of(mavenStyleRoot.path.resolve(\"src\/main\/java\")));\n+                result.sourceFiles.addAll(sourcePath.javaFiles().map(JavaSourceFile::new).toList());\n+                if (result.sourceFiles.isEmpty()) {\n+                    throw new RuntimeException(\"No sources\");\n+                }\n+                result.opts.add(\"--source-path\", sourcePath.charSeparated());\n+\n+                if (javacBuilder.sourcePath != null && !javacBuilder.sourcePath.entries.isEmpty()) {\n+                    throw new RuntimeException(\"You have specified --source-path AND provided maven_style_root \");\n+                }\n+            }\n+            boolean[] failed = {false};\n+\n+            DiagnosticListener<JavaFileObject> diagnosticListener =\n+                    (diagnostic) -> {\n+                        if (diagnostic.getKind().equals(Diagnostic.Kind.ERROR)) {\n+                            failed[0] = true;\n+                        }\n+                        if (!diagnostic.getKind().equals(Diagnostic.Kind.NOTE)) {\n+                            System.out.println(\"javac \"\n+                                    + diagnostic.getKind()\n+                                    + \" \"\n+                                    + ((JavaSourceFile) (diagnostic.getSource())).path().toString()\n+                                    + \"  \"\n+                                    + diagnostic.getLineNumber()\n+                                    + \":\"\n+                                    + diagnostic.getColumnNumber()\n+                                    + \" \"\n+                                    + diagnostic.getMessage(null));\n+                        }\n+                    };\n+\n+            JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n+            if (javacBuilder.exclusionFilters != null) {\n+                javacBuilder.exclusionFilters.forEach(p -> {\n+                    result.sourceFiles = result.sourceFiles.stream().filter(\n+                            javaSourceFile -> {\n+                                var kill = p.test(javaSourceFile);\n+                                if (kill) {\n+                                    println(\"Excluded \" + javaSourceFile);\n+                                }\n+                                return !kill;\n+                            }\n+                    ).toList();\n+                });\n+            }\n+            if (javacBuilder.verbose || javacBuilder.parent instanceof JarBuilder jarBuilder && jarBuilder.verbose) {\n+                print(\"javac \" + result.opts.spaceSeparated());\n+                result.sourceFiles.forEach(s -> print(s + \" \"));\n+                println(\"\");\n+            }\n+            JavaCompiler.CompilationTask compilationTask =\n+                    (javac.getTask(\n+                            new PrintWriter(System.err),\n+                            javac.getStandardFileManager(diagnosticListener, null, null),\n+                            diagnosticListener,\n+                            result.opts.strings,\n+                            null,\n+                            result.sourceFiles\n+                    ));\n+            JavacTask javacTask = (JavacTask) compilationTask;\n+\n+            javacTask.generate().forEach(javaFileObject -> {\n+                result.classes.add(javaFileObject);\n+            });\n+            if (failed[0]) {\n+                throw new RuntimeException(\"javac failed\");\n+            }\n+            return result;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static JavacBuilder javacBuilder(Consumer<JavacBuilder> javacBuilderConsumer) {\n+        JavacBuilder javacBuilder = new JavacBuilder();\n+        javacBuilderConsumer.accept(javacBuilder);\n+        return javacBuilder;\n+    }\n+\n+    public static JavacResult javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n+        return javac(javacBuilder(javacBuilderConsumer));\n+    }\n+\n+    public static final class JavaBuilder extends JavaToolBuilder<JavaBuilder> {\n+        public String mainClass;\n+        public DirPath libraryPath;\n+        public boolean startOnFirstThread;\n+        public Strings vmargs = new Strings();\n+        public Strings args = new Strings();\n+        public Strings nativeAccessModules = new Strings();\n+        private boolean headless;\n+\n+\n+        public JavaBuilder enable_native_access(String module) {\n+            nativeAccessModules.add(module);\n+            return self();\n+        }\n+\n+        public JavaBuilder enable_native_access_to_all_unnamed() {\n+            return enable_native_access(\"ALL-UNNAMED\");\n+        }\n+        public JavaBuilder vmargs(List<String> args) {\n+            this.vmargs.add(args);\n+            return self();\n+        }\n+\n+        public JavaBuilder vmargs(String... args) {\n+            vmargs(Arrays.asList(args));\n+            return self();\n+        }\n+\n+        public JavaBuilder args(List<String> args) {\n+            this.args.add(args);\n+            return self();\n+        }\n+\n+\n+        public JavaBuilder args(String... args) {\n+            args(Arrays.asList(args));\n+            return self();\n+        }\n+\n+        public JavaBuilder main_class(String mainClass) {\n+            this.mainClass = mainClass;\n+            return this;\n+        }\n+\n+        public JavaBuilder library_path(List<DirPathHolder<?>> libraryPathEntries) {\n+            this.libraryPath = DirPath.ofOrUse(this.libraryPath).add(libraryPathEntries);\n+            return this;\n+        }\n+\n+        public JavaBuilder library_path(DirPath libraryPathEntries) {\n+            this.libraryPath = DirPath.ofOrUse(this.libraryPath).add(libraryPathEntries);\n+            return this;\n+        }\n+\n+        public JavaBuilder library_path(DirPathHolder<?>... libraryPathEntries) {\n+            return this.library_path(List.of(libraryPathEntries));\n+        }\n+\n+        public JavaBuilder start_on_first_thread() {\n+            this.startOnFirstThread = true;\n+            return this;\n+        }\n+\n+        public void headless() {\n+            this.headless = true;\n+        }\n+    }\n+\n+    public static final class JavaResult extends Result<JavaBuilder> {\n+        Strings opts = new Strings();\n+\n+        JavaResult(JavaBuilder javaBuilder) {\n+            super(javaBuilder);\n+        }\n+    }\n+\n+    public static JavaBuilder java(JavaBuilder javaBuilder) {\n+        JavaResult result = new JavaResult(javaBuilder);\n+        result.opts.add(javaBuilder.jdk.path().resolve(\"bin\/java\").toString());\n+        if (javaBuilder.enablePreview != null && javaBuilder.enablePreview) {\n+            result.opts.add(\"--enable-preview\");\n+        }\n+        if (javaBuilder.modules != null) {\n+            javaBuilder.modules.strings.forEach(module ->\n+                    result.opts.add(\"--add-modules\", module)\n+            );\n+        }\n+\n+        if (javaBuilder.exports != null) {\n+            javaBuilder.exports.forEach(fpt -> {\n+                result.opts.add(\"--add-exports=\" + fpt.fromModule + \"\/\" + fpt.pkg + \"=\" + fpt.toModule);\n+            });\n+        }\n+        if (javaBuilder.headless) {\n+            result.opts.add(\"-Dheadless=true\");\n+        }\n+        if (javaBuilder.startOnFirstThread) {\n+            result.opts.add(\"-XstartOnFirstThread\");\n+        }\n+\n+        javaBuilder.nativeAccessModules.strings.forEach(module ->\n+                result.opts.add(\"--enable-native-access=\" + module)\n+        );\n+\n+        if (javaBuilder.classPath != null) {\n+            result.opts.add(\"--class-path\", javaBuilder.classPath.charSeparated());\n+        }\n+        if (javaBuilder.libraryPath != null) {\n+            result.opts.add(\"-Djava.library.path=\" + javaBuilder.libraryPath.charSeparated());\n+        }\n+        result.opts.add(javaBuilder.vmargs.strings);\n+        result.opts.add(javaBuilder.mainClass);\n+        result.opts.add(javaBuilder.args.strings);\n+\n+        if (javaBuilder.justShowCommandline) {\n+            println(result.opts.spaceSeparated());\n+            result.ok = false;\n+        }else {\n+            try {\n+                var processBuilder = new ProcessBuilder().inheritIO().command(result.opts.strings);\n+                var process = processBuilder.start();\n+                if (javaBuilder.verbose) {\n+                    println(result.opts.spaceSeparated());\n+                }\n+                process.waitFor();\n+                result.ok = (process.exitValue() == 0);\n+                if (!result.ok) {\n+                    \/\/ println(\"java ok \");\n+                    \/\/}else{\n+                    println(\"java returned error \" + process.exitValue());\n+                }\n+\n+            } catch (InterruptedException | IOException ie) {\n+                System.out.println(ie);\n+            }\n+        }\n+\n+        return javaBuilder;\n+    }\n+\n+    public static JavaBuilder java(Consumer<JavaBuilder> javaBuilderConsumer) {\n+        JavaBuilder javaBuilder = new JavaBuilder();\n+        javaBuilderConsumer.accept(javaBuilder);\n+        return java(javaBuilder);\n+    }\n+\n+    public static JavaBuilder javaBuilder() {\n+        return new JavaBuilder();\n+    }\n+\n+    public static final class FormatBuilder extends Builder<FormatBuilder> {\n+        public SourcePath sourcePath;\n+\n+        public FormatBuilder source_path(List<SourceDir> sourcePaths) {\n+            this.sourcePath = SourcePath.ofOrUse(this.sourcePath).add(sourcePaths);\n+            return this;\n+        }\n+\n+        public FormatBuilder source_path(SourceDir... sourcePaths) {\n+            return source_path(List.of(sourcePaths));\n+        }\n+    }\n+\n+    public static void format(RepoDir repoDir, Consumer<FormatBuilder> formatBuilderConsumer) {\n+        var formatBuilder = new FormatBuilder();\n+        formatBuilderConsumer.accept(formatBuilder);\n+        var classPathEntries = repoDir.classPathEntries(\"com.google.googlejavaformat\/google-java-format\");\n+\n+        java($ -> $\n+                .verbose()\n+                .enable_preview()\n+                .enable_native_access(\"ALL-UNNAMED\")\n+                .add_exports(\"java.base\", \"jdk.internal\", \"ALL-UNNAMED\")\n+                .add_exports(\n+                        \"jdk.compiler\",\n+                        List.of(\n+                                \"com.sun.tools.javac.api\",\n+                                \"com.sun.tools.javac.code\",\n+                                \"com.sun.tools.javac.file\",\n+                                \"com.sun.tools.javac.main\",\n+                                \"com.sun.tools.javac.parser\",\n+                                \"com.sun.tools.javac.tree\",\n+                                \"com.sun.tools.javac.util\"),\n+                        \"ALL-UNNAMED\")\n+                .class_path(classPathEntries)\n+                .main_class(\"com.google.googlejavaformat.java.Main\")\n+                .args(\"-r\")\n+                .args(formatBuilder.sourcePath.javaFiles().map(Path::toString).toList()));\n+    }\n+\n+    public static final class TestNGBuilder extends Builder<TestNGBuilder> {\n+        public SourcePath sourcePath;\n+        public ClassPath classPath;\n+        private SuiteBuilder suiteBuilder;\n+        private JarFile testJar;\n+\n+        public TestNGBuilder class_path(List<ClassPathEntryProvider> classPathEntryProviders) {\n+            this.classPath = ClassPath.ofOrUse(this.classPath).add(classPathEntryProviders);\n+            return this;\n+        }\n+\n+        public TestNGBuilder class_path(ClassPathEntryProvider... classPathEntryProviders) {\n+            class_path(List.of(classPathEntryProviders));\n+            return this;\n+        }\n+\n+        public TestNGBuilder source_path(List<SourceDir> sourcePathEntries) {\n+            this.sourcePath = SourcePath.ofOrUse(this.sourcePath).add(sourcePathEntries);\n+            return this;\n+        }\n+\n+        public TestNGBuilder source_path(SourceDir... sourcePathEntries) {\n+            return source_path(List.of(sourcePathEntries));\n+        }\n+\n+        public TestNGBuilder testJar(JarFile testJar) {\n+            this.testJar = testJar;\n+            return self();\n+        }\n+\n+        public static class SuiteBuilder {\n+            String name;\n+\n+            SuiteBuilder name(String name) {\n+                this.name = name;\n+                return this;\n+            }\n+\n+            List<TestBuilder> testBuilders = new ArrayList<>();\n+\n+            public static class TestBuilder {\n+                String name;\n+                List<String> classNames;\n+\n+                TestBuilder name(String name) {\n+                    this.name = name;\n+                    return this;\n+                }\n+\n+                public TestBuilder classes(List<String> classNames) {\n+                    this.classNames = this.classNames == null ? new ArrayList<>() : this.classNames;\n+                    this.classNames.addAll(classNames);\n+                    return this;\n+                }\n+\n+                public TestBuilder classes(String... classNames) {\n+                    return classes(List.of(classNames));\n+                }\n+            }\n+\n+            public void test(String testName, Consumer<TestBuilder> testBuilderConsumer) {\n+                TestBuilder testBuilder = new TestBuilder();\n+                testBuilder.name(testName);\n+                testBuilderConsumer.accept(testBuilder);\n+                testBuilders.add(testBuilder);\n+            }\n+        }\n+\n+        public TestNGBuilder suite(String suiteName, Consumer<SuiteBuilder> suiteBuilderConsumer) {\n+            this.suiteBuilder = new SuiteBuilder();\n+            suiteBuilder.name(suiteName);\n+            suiteBuilderConsumer.accept(suiteBuilder);\n+            return self();\n+        }\n+    }\n+\n+    public static void testng(RepoDir repoDir, Consumer<TestNGBuilder> testNGBuilderConsumer) {\n+        var testNGBuilder = new TestNGBuilder();\n+        testNGBuilderConsumer.accept(testNGBuilder);\n+\n+        var text =\n+                XMLNode.create(\n+                                \"suite\",\n+                                $ -> {\n+                                    $.attr(\"name\", testNGBuilder.suiteBuilder.name);\n+                                    testNGBuilder.suiteBuilder.testBuilders.forEach(\n+                                            tb -> {\n+                                                $.element(\n+                                                        \"test\",\n+                                                        $$ ->\n+                                                                $$.attr(\"name\", tb.name)\n+                                                                        .element(\n+                                                                                \"classes\",\n+                                                                                $$$ ->\n+                                                                                        tb.classNames.forEach(\n+                                                                                                className ->\n+                                                                                                        $$$.element(\n+                                                                                                                \"class\",\n+                                                                                                                $$$$ -> $$$$.attr(\"name\", className)))));\n+                                            });\n+                                })\n+                        .toString();\n+\n+        println(text);\n+\n+        TestNGSuiteFile testNGSuiteFile = TestNGSuiteFile.containing(text);\n+        var mavenJars = repoDir.classPathEntries(\"org.testng\/testng\", \"org.slf4j\/slf4j-api\");\n+\n+\n+        var testJarResult =\n+                jar(jar -> jar\n+                        .jarFile(testNGBuilder.testJar)\n+                        .javac(javac -> javac\n+                                .source(25)\n+                                .enable_preview()\n+                                .class_path(testNGBuilder.classPath, mavenJars)\n+                                .source_path(testNGBuilder.sourcePath)\n+                        )\n+                );\n+\n+        java(\n+                $ ->\n+                        $.enable_preview()\n+                                .add_exports_to_all_unnamed(\"java.base\", \"jdk.internal\")\n+                                .enable_native_access(\"ALL-UNNAMED\")\n+                                .class_path(testNGBuilder.classPath, mavenJars, testJarResult)\n+                                .main_class(\"org.testng.TestNG\")\n+                                .args(testNGSuiteFile.path().toString()));\n+    }\n+\n+    public static final class JarBuilder extends Builder<JarBuilder> {\n+        public static class Manifest {\n+            public String mainClass;\n+            public String[] classPath;\n+            public String version;\n+            public String createdBy;\n+            public String buildBy;\n+\n+            public void writeTo(JarOutputStream jarStream) {\n+                PrintWriter printWriter = new PrintWriter(jarStream);\n+                if (version != null) {\n+                    printWriter.println(\"Manifest-Version: \" + version);\n+                }\n+                if (mainClass != null) {\n+                    printWriter.println(\"Main-Class: \" + mainClass);\n+                }\n+                if (classPath != null) {\n+                    printWriter.print(\"Class-Path:\");\n+                    for (String s : classPath) {\n+                        printWriter.print(\" \");\n+                        printWriter.print(s);\n+                    }\n+                    printWriter.println();\n+                }\n+                printWriter.flush();\n+            }\n+        }\n+\n+        public static final class ManifestBuilder extends Builder<ManifestBuilder> {\n+\n+            Manifest manifest;\n+\n+            public ManifestBuilder main_class(String mainClass) {\n+                this.manifest.mainClass = mainClass;\n+                return self();\n+            }\n+\n+            public ManifestBuilder version(String version) {\n+                this.manifest.version = version;\n+                return self();\n+            }\n+\n+            public ManifestBuilder created_by(String createdBy) {\n+                this.manifest.createdBy = createdBy;\n+                return self();\n+            }\n+\n+            public ManifestBuilder build_by(String buildBy) {\n+                this.manifest.buildBy = buildBy;\n+                return self();\n+            }\n+\n+            public ManifestBuilder class_path(String... classPath) {\n+                this.manifest.classPath = classPath;\n+                return self();\n+            }\n+\n+            public ManifestBuilder class_path(ClassPathEntry... classPathEntries) {\n+                this.manifest.classPath = Stream.of(classPathEntries).map(classPathEntry -> classPathEntry.path().getFileName().toString()).toArray(String[]::new);\n+                return self();\n+            }\n+\n+            ManifestBuilder(Manifest manifest) {\n+                this.manifest = manifest;\n+            }\n+        }\n+\n+        public DirEntry mavenStyleRoot;\n+        public JarFile jar;\n+        public JavacResult javacResult;\n+        public DirPath dirList;\n+        \/\/  public String mainClass;\n+        public Manifest manifest;\n+\n+        public JarBuilder jarFile(JarFile jar) {\n+            this.jar = jar;\n+            return self();\n+        }\n+\n+        public JarBuilder maven_style_root(DirEntry mavenStyleRoot) {\n+            this.mavenStyleRoot = mavenStyleRoot;\n+            return this;\n+        }\n+\n+        public JarBuilder manifest(Consumer<ManifestBuilder> manifestBuilderConsumer) {\n+            this.manifest = this.manifest == null ? new Manifest() : this.manifest;\n+            var manifestBuilder = new ManifestBuilder(manifest);\n+            manifestBuilderConsumer.accept(manifestBuilder);\n+            return self();\n+        }\n+\n+        private JarBuilder javac(JavacBuilder javacBuilder) {\n+            this.javacResult = Script.javac(javacBuilder);\n+\n+            this.dirList =\n+                    (this.dirList == null)\n+                            ? DirPath.of().add(this.javacResult.classDir)\n+                            : this.dirList.add(this.javacResult.classDir);\n+            if (mavenStyleRoot != null) {\n+                var resources = mavenStyleRoot.dir(\"src\/main\/resources\");\n+                if (resources.exists()) {\n+                    this.dirList.add(resources);\n+                }\n+            }\n+            return self();\n+        }\n+\n+        public JavacBuilder javacBuilder(Consumer<JavacBuilder> javacBuilderConsumer) {\n+            JavacBuilder javacBuilder = new JavacBuilder(this);\n+            javacBuilderConsumer.accept(javacBuilder);\n+            return javacBuilder;\n+        }\n+\n+        public JavacBuilder javacBuilder(JavacBuilder copyMe, Consumer<JavacBuilder> javacBuilderConsumer) {\n+            JavacBuilder javacBuilder = new JavacBuilder(this);\n+            javacBuilder.dontCallThisCopy(copyMe);\n+            javacBuilderConsumer.accept(javacBuilder);\n+            return javacBuilder;\n+        }\n+\n+        public JarBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n+            return javac(javacBuilder(javacBuilderConsumer));\n+        }\n+\n+        public JarBuilder javac(JavacBuilder copyMe, Consumer<JavacBuilder> javacBuilderConsumer) {\n+            return javac(javacBuilder(copyMe, javacBuilderConsumer));\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public <P extends DirPathHolder<P>> JarBuilder dir_list(P... holders) {\n+            Arrays.asList(holders).forEach(holder ->\n+                    this.dirList = DirPath.ofOrUse(this.dirList).add(holder)\n+            );\n+            return self();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public <P extends DirPathHolder<P>> JarBuilder add(P... holders) {\n+            Arrays.asList(holders).forEach(holder ->\n+                    this.dirList = DirPath.ofOrUse(this.dirList).add(holder)\n+            );\n+            return self();\n+        }\n+    }\n+\n+    public static final class JarResult extends Result<JarBuilder> implements ClassPathEntryProvider {\n+        public Strings opts = new Strings();\n+        public List<RootDirAndSubPath> pathsToJar = new ArrayList<>();\n+        public List<Path> paths = new ArrayList<>();\n+        public JarFile jarFile;\n+\n+\n+        public JarResult(JarBuilder jarBuilder) {\n+            super(jarBuilder);\n+            this.jarFile = jarBuilder.jar;\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return List.of(jarFile);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return jarFile.path.toString();\n+        }\n+    }\n+\n+    public static JarResult jar(JarBuilder jarBuilder) {\n+\n+        JarResult result = new JarResult(jarBuilder);\n+        try {\n+\n+            var jarStream = new JarOutputStream(Files.newOutputStream(jarBuilder.jar.path()));\n+            if (jarBuilder.dirList == null) {\n+                throw new RuntimeException(\"Nothing to jar \");\n+            }\n+            if (jarBuilder.manifest != null) {\n+                \/\/ We must add manifest\n+                var entry = new JarEntry(\"META-INF\/MANIFEST.MF\");\n+                \/\/ entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n+\n+                jarStream.putNextEntry(entry);\n+                jarBuilder.manifest.writeTo(jarStream);\n+                jarStream.closeEntry();\n+\n+            }\n+            jarBuilder.dirList.entries.forEach(\n+                    root ->\n+                            root.findFiles()\n+                                    .map(path -> new RootDirAndSubPath(root, path))\n+                                    .forEach(result.pathsToJar::add));\n+            result.pathsToJar.stream()\n+                    .sorted(Comparator.comparing(RootDirAndSubPath::path))\n+                    .forEach(\n+                            rootAndPath -> {\n+                                try {\n+                                    result.paths.add(rootAndPath.path);\n+                                    var entry = new JarEntry(rootAndPath.relativize().toString());\n+                                    entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n+                                    jarStream.putNextEntry(entry);\n+                                    Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n+                                    jarStream.closeEntry();\n+                                    if (jarBuilder.verbose) {\n+                                        println(\"INFO: adding \" + rootAndPath.relativize().toString());\n+                                    }\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                            });\n+            jarStream.finish();\n+            jarStream.close();\n+            if (jarBuilder.verbose) {\n+                println(\"INFO: created \" + jarBuilder.jar.path.toString());\n+            }\n+            return result;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static JarBuilder jarBuilder(Consumer<JarBuilder> jarBuilderConsumer) {\n+        JarBuilder jarBuilder = new JarBuilder();\n+        jarBuilderConsumer.accept(jarBuilder);\n+        return jarBuilder;\n+    }\n+\n+    public static JarBuilder jarBuilder(JarBuilder copyMe, Consumer<JarBuilder> jarBuilderConsumer) {\n+        JarBuilder jarBuilder = new JarBuilder();\n+        jarBuilder.dontCallThisCopy(copyMe);\n+        jarBuilderConsumer.accept(jarBuilder);\n+        return jarBuilder;\n+    }\n+\n+    public static JarResult jar(Consumer<JarBuilder> jarBuilderConsumer) {\n+        return jar(jarBuilder(jarBuilderConsumer));\n+    }\n+\n+    public static JarResult jar(JarBuilder copyMe, Consumer<JarBuilder> jarBuilderConsumer) {\n+        return jar(jarBuilder(copyMe, jarBuilderConsumer));\n+    }\n+\n+    public static final class CMakeBuilder extends Builder<CMakeBuilder> {\n+        public List<String> libraries = new ArrayList<>();\n+        public CMakeBuildDir cmakeBuildDir;\n+        public DirEntry sourceDir;\n+        private Path output;\n+        public BuildDir copyToDir;\n+        public List<String> opts = new ArrayList<>();\n+\n+        public CMakeBuilder opts(List<String> opts) {\n+            this.opts.addAll(opts);\n+            return self();\n+        }\n+\n+        public CMakeBuilder opts(String... opts) {\n+            opts(Arrays.asList(opts));\n+            return self();\n+        }\n+\n+        public CMakeBuilder() {\n+            opts.add(\"cmake\");\n+        }\n+\n+        public CMakeBuilder build_dir(CMakeBuildDir cmakeBuildDir) {\n+            this.cmakeBuildDir = cmakeBuildDir;\n+            opts(\"-B\", cmakeBuildDir.path.toString());\n+            return this;\n+        }\n+\n+        public CMakeBuilder copy_to(BuildDir copyToDir) {\n+            this.copyToDir = copyToDir;\n+            opts(\"-DHAT_TARGET=\" + this.copyToDir.path().toString());\n+            return this;\n+        }\n+\n+        public CMakeBuilder source_dir(DirEntry sourceDir) {\n+            this.sourceDir = sourceDir;\n+            opts(\"-S\", sourceDir.path().toString());\n+            return this;\n+        }\n+\n+        public CMakeBuilder build(CMakeBuildDir cmakeBuildDir) {\n+            this.cmakeBuildDir = cmakeBuildDir;\n+            opts(\"--build\", cmakeBuildDir.path().toString());\n+            return this;\n+        }\n+        public CMakeBuilder target(String target) {\n+            opts(\"--target\", target);\n+            return this;\n+        }\n+    }\n+\n+    public static void cmake(Consumer<CMakeBuilder> cmakeBuilderConsumer) {\n+        CMakeBuilder cmakeBuilder = new CMakeBuilder();\n+        cmakeBuilderConsumer.accept(cmakeBuilder);\n+        cmakeBuilder.cmakeBuildDir.create();\n+        try {\n+            var processBuilder = new ProcessBuilder().inheritIO().command(cmakeBuilder.opts);\n+            var process = processBuilder.start();\n+            if (cmakeBuilder.verbose) {\n+                print(cmakeBuilder.opts);\n+            }\n+            process.waitFor();\n+        } catch (InterruptedException | IOException ie) {\n+            System.out.println(ie);\n+        }\n+    }\n+\n+    static Path unzip(Path in, Path dir) {\n+        try {\n+            Files.createDirectories(dir);\n+            ZipFile zip = new ZipFile(in.toFile());\n+            zip.entries()\n+                    .asIterator()\n+                    .forEachRemaining(\n+                            entry -> {\n+                                try {\n+                                    String currentEntry = entry.getName();\n+\n+                                    Path destFile = dir.resolve(currentEntry);\n+                                    \/\/ destFile = new File(newPath, destFile.getName());\n+                                    Path destinationParent = destFile.getParent();\n+                                    Files.createDirectories(destinationParent);\n+                                    \/\/ create the parent directory structure if needed\n+\n+                                    if (!entry.isDirectory()) {\n+                                        zip.getInputStream(entry).transferTo(Files.newOutputStream(destFile));\n+                                    }\n+                                } catch (IOException ioe) {\n+                                    throw new RuntimeException(ioe);\n+                                }\n+                            });\n+            zip.close();\n+\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return dir;\n+    }\n+\n+\n+    public static final class JExtractBuilder extends Builder<JExtractBuilder> {\n+        public Strings compileFlags = new Strings();\n+        public List<Path> libraries = new ArrayList<>();\n+        public List<Path> headers = new ArrayList<>();\n+        private String targetPackage;\n+        private String headerClassName;\n+        private BuildDir output;\n+\n+        protected JExtractBuilder dontCallThisCopy(JExtractBuilder other) {\n+            this.compileFlags = new Strings(other.compileFlags);\n+            if (other.targetPackage != null) {\n+                throw new RuntimeException(\"You are copying jextract builder already bound to a target package\");\n+            }\n+            if (other.output != null) {\n+                throw new RuntimeException(\"You are copying jextract builder already bound to output directory\");\n+            }\n+            if (!other.libraries.isEmpty()) {\n+                throw new RuntimeException(\"You are copying jextract builder already bound to library(ies)\");\n+            }\n+            if (!other.headers.isEmpty()) {\n+                throw new RuntimeException(\"You are copying jextract builder already bound to headers library(ies)\");\n+            }\n+            return self();\n+        }\n+\n+        public JExtractBuilder target_package(String targetPackage) {\n+            this.targetPackage = targetPackage;\n+            return self();\n+        }\n+\n+        public JExtractBuilder header_class_name(String headerClassName) {\n+            this.headerClassName = headerClassName;\n+            return self();\n+        }\n+\n+        public JExtractBuilder output(BuildDir output) {\n+            this.output = output;\n+            return self();\n+        }\n+\n+        public JExtractBuilder library(List<Path>libraries) {\n+            this.libraries.addAll(libraries);\n+            return self();\n+        }\n+\n+        public JExtractBuilder library(Path... libraries) {\n+            return library(Arrays.asList(libraries));\n+        }\n+\n+        public JExtractBuilder compile_flag(String... compileFlags) {\n+            this.compileFlags.add(compileFlags);\n+            return self();\n+        }\n+\n+        public JExtractBuilder header(Path header) {\n+            this.headers.add(header);\n+            return self();\n+        }\n+\n+        public JExtractBuilder capability(Capabilities.Jextractable jextractable, BuildDir stageDir) {\n+             output(stageDir)\n+                    .target_package(jextractable.packageName())\n+                    .header_class_name(jextractable.headerClassName());\n+              jextractable.inversionOfControl(this);\n+             return self();\n+        }\n+    }\n+\n+    public static final class JExtractResult extends Result<JExtractBuilder> {\n+        public Strings opts = new Strings();\n+\n+        JExtractResult(JExtractBuilder builder) {\n+            super(builder);\n+        }\n+    }\n+\n+    public static JExtractResult jextract(Capabilities.JExtract jextract, Consumer<JExtractBuilder> jextractBuilderConsumer) {\n+      return jextract(JExtractExecutable.of(jextract.path()),jextractBuilderConsumer);\n+    }\n+\n+\n+    public static JExtractResult jextract(JExtractExecutable executable, Consumer<JExtractBuilder> jextractBuilderConsumer) {\n+\n+        var exePath = executable.path;\n+        var homePath = exePath.getParent().getParent();\n+\n+        JExtractBuilder jExtractBuilder = new JExtractBuilder();\n+        JExtractResult result = new JExtractResult(jExtractBuilder);\n+        jextractBuilderConsumer.accept(jExtractBuilder);\n+        result.opts.add(executable.path().toString());\n+\n+        if (jExtractBuilder.targetPackage != null) {\n+            result.opts.add(\"--target-package\", jExtractBuilder.targetPackage);\n+        }\n+        if (jExtractBuilder.output != null) {\n+            jExtractBuilder.output.create();\n+            result.opts.add(\"--output\", jExtractBuilder.output.path().toString());\n+        }\n+        for (Path library : jExtractBuilder.libraries) {\n+            result.opts.add(\"--library\", \":\" + library);\n+        }\n+\n+\n+        if (jExtractBuilder.headers.isEmpty()) {\n+            throw new RuntimeException(\"No headers specified\");\n+        }\n+        for (Path header : jExtractBuilder.headers) {\n+            if (jExtractBuilder.headerClassName != null) {\n+                result.opts.add(\"--header-class-name\", jExtractBuilder.headerClassName);\n+                System.out.println(\"header and class name: \" + header.toString() + \" with \" + jExtractBuilder.headerClassName);\n+            } else {\n+                System.out.println(\"header: \" + header.toString() + \" no header className\");\n+            }\n+            result.opts.add(header.toString());\n+        }\n+\n+\n+        if (jExtractBuilder.compileFlags != null && !jExtractBuilder.compileFlags.strings.isEmpty()) {\n+            jExtractBuilder.output.textFile(\"compile_flags.txt\", jExtractBuilder.compileFlags.strings);\n+        }\n+\n+        if (jExtractBuilder.verbose) {\n+            println(result.opts.spaceSeparated());\n+        }\n+        var processBuilder = new ProcessBuilder();\n+        if (jExtractBuilder.output != null) {\n+            processBuilder.directory(jExtractBuilder.output.path().toFile());\n+        }\n+        processBuilder.inheritIO().command(result.opts.strings);\n+        try {\n+            processBuilder.start().waitFor();\n+        } catch (InterruptedException | IOException ie) {\n+            throw new RuntimeException(ie);\n+        }\n+        return result;\n+    }\n+\n+    public record SearchableTextFile(Path path) implements TextFile {\n+        static SearchableTextFile of(Path path) {\n+            return new SearchableTextFile(path);\n+        }\n+\n+        public Stream<Line> lines() {\n+            try {\n+                int num[] = new int[]{1};\n+                return Files.readAllLines(path(), StandardCharsets.UTF_8).stream()\n+                        .map(line -> new Line(line, num[0]++));\n+            } catch (IOException ioe) {\n+                System.out.println(ioe);\n+                return new ArrayList<Line>().stream();\n+            }\n+        }\n+\n+        public boolean grep(Pattern pattern) {\n+            return lines().anyMatch(line -> pattern.matcher(line.line).matches());\n+        }\n+\n+        public boolean hasSuffix(String... suffixes) {\n+            var suffixSet = Set.of(suffixes);\n+            int dotIndex = path().toString().lastIndexOf('.');\n+            return dotIndex == -1 || suffixSet.contains(path().toString().substring(dotIndex + 1));\n+        }\n+    }\n+\n+    public record Line(String line, int num) {\n+        public boolean grep(Pattern pattern) {\n+            return pattern.matcher(line()).matches();\n+        }\n+    }\n+\n+    public static Path curl(URL url, Path file) {\n+        try {\n+            println(\"Downloading \" + url + \"->\" + file);\n+            url.openStream().transferTo(Files.newOutputStream(file));\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return file;\n+    }\n+\n+    public static Optional<Path> which(String execName) {\n+        \/\/ which and whereis had issues.\n+        return Arrays.asList(System.getenv(\"PATH\").split(File.pathSeparator)).stream()\n+                .map(dirName -> Path.of(dirName).resolve(execName).normalize())\n+                .filter(Files::isExecutable)\n+                .findFirst();\n+    }\n+\n+    public static boolean canExecute(String execName) {\n+        return which(execName).isPresent();\n+    }\n+\n+    public static Path untar(Path tarFile, Path dir) {\n+        try {\n+            new ProcessBuilder()\n+                    .inheritIO()\n+                    .command(\"tar\", \"xvf\", tarFile.toString(), \"--directory\", tarFile.getParent().toString())\n+                    .start()\n+                    .waitFor();\n+            return dir;\n+        } catch (\n+                InterruptedException\n+                        e) { \/\/ We get IOException if the executable not found, at least on Mac so interuppted\n+            \/\/ means it exists\n+            return null;\n+        } catch (IOException e) { \/\/ We get IOException if the executable not found, at least on Mac\n+            \/\/ throw new RuntimeException(e);\n+            return null;\n+        }\n+    }\n+\n+    public static Optional<Path> fromPATH(String name) {\n+        return Arrays.stream(System.getenv(\"PATH\").split(File.pathSeparator))\n+                .map(dirName -> Path.of(dirName).resolve(name).normalize())\n+                .filter(Files::isExecutable)\n+                .filter(Files::isRegularFile)\n+                .findFirst();\n+    }\n+\n+\n+    public static <T extends PathHolder> T assertExists(T testme) {\n+        if (Files.exists(testme.path())) {\n+            return testme;\n+        } else {\n+            throw new IllegalStateException(\"FAILED: \" + testme.path() + \" does not exist\");\n+        }\n+    }\n+\n+    public static <T extends Path> T assertExists(T path) {\n+        if (Files.exists(path)) {\n+            return path;\n+        } else {\n+            throw new IllegalStateException(\"FAILED: \" + path + \" does not exist\");\n+        }\n+    }\n+\n+    public static class CMakeProbe implements Capabilities.Probe {\n+        public interface CMakeVar<T> {\n+            String name();\n+\n+            T value();\n+        }\n+\n+        public record CMakeTypedVar(String name, String type, String value, String comment)\n+                implements CMakeVar<String> {\n+            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+):([^=]*)=(.*)$\");\n+\n+            CMakeTypedVar(Matcher matcher, String comment) {\n+                this(\n+                        \"CMAKE_\" + matcher.group(1).trim(),\n+                        matcher.group(2).trim(),\n+                        matcher.group(3).trim(),\n+                        comment.substring(2).trim());\n+            }\n+\n+            static boolean onMatch(String line, String comment, Consumer<CMakeTypedVar> consumer) {\n+                return regex.matches(line, matcher -> consumer.accept(new CMakeTypedVar(matcher, comment)));\n+            }\n+        }\n+\n+        public record CMakeSimpleVar(String name, String value) implements CMakeVar {\n+            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n+\n+            CMakeSimpleVar(Matcher matcher) {\n+                this(\n+                        \"CMAKE_\" + matcher.group(1).trim(),\n+                        (matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim());\n+            }\n+\n+            static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n+                return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n+            }\n+        }\n+\n+        public record CMakeDirVar(String name, DirPathHolder value) implements CMakeVar {\n+            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n+\n+            static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n+                return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n+            }\n+        }\n+\n+        public record CMakeContentVar(String name, String value) implements CMakeVar {\n+            static final Regex startRegex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)$\");\n+            static final Regex endRegex = Regex.of(\"^(.*)\\\\}>\\\\}$\");\n+        }\n+\n+        public record CMakeRecipeVar(String name, String value) implements CMakeVar<String> {\n+            static final Regex varPattern = Regex.of(\"<([^>]*)>\");\n+            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{<(.*)>\\\\}>\\\\}$\");\n+\n+            CMakeRecipeVar(Matcher matcher) {\n+                this(\n+                        \"CMAKE_\" + matcher.group(1).trim(),\n+                        \"<\" + ((matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim()) + \">\");\n+            }\n+\n+            public String expandRecursively(Map<String, CMakeVar<?>> varMap, String value) { \/\/ recurse\n+                String result = value;\n+                if (varPattern.pattern().matcher(value) instanceof Matcher matcher && matcher.find()) {\n+                    var v = matcher.group(1);\n+                    if (varMap.containsKey(v)) {\n+                        String replacement = varMap.get(v).value().toString();\n+                        result =\n+                                expandRecursively(\n+                                        varMap,\n+                                        value.substring(0, matcher.start())\n+                                                + replacement\n+                                                + value.substring(matcher.end()));\n+                    }\n+                }\n+                return result;\n+            }\n+\n+            public String expand(Map<String, CMakeVar<?>> vars) {\n+                return expandRecursively(vars, value());\n+            }\n+\n+            static boolean onMatch(String line, String comment, Consumer<CMakeRecipeVar> consumer) {\n+                return regex.matches(line, matcher -> consumer.accept(new CMakeRecipeVar(matcher)));\n+            }\n+        }\n+\n+        BuildDir dir;\n+\n+        Map<String, CMakeVar<?>> varMap = new HashMap<>();\n+\n+        public CMakeProbe(BuildDir dir, Capabilities capabilities) {\n+            this.dir = BuildDir.of(dir.path(\"cmakeprobe\"));\n+            this.dir.clean();\n+\n+            try {\n+                this.dir.cmakeLists(cmakeLists -> {\n+                    cmakeLists.append(\n+                            \"\"\"\n+                                    cmake_minimum_required(VERSION 3.21)\n+                                    project(cmakeprobe)\n+                                    set(CMAKE_CXX_STANDARD 14)\n+                                    \"\"\"\n+                    );\n+\n+                    capabilities.capabilities()\n+                            .filter(capability -> capability instanceof Capabilities.CMakeProbeable)\n+                            .map(capability -> (Capabilities.CMakeProbeable) capability)\n+                            .forEach(p ->\n+                                    cmakeLists.append(p.cmakeStanza()).append(\"\\n\")\n+                            );\n+                    cmakeLists.append(\n+                            \"\"\"\n+                                    get_cmake_property(_variableNames VARIABLES ${VarNames})\n+                                    foreach(VarName ${_variableNames})\n+                                        message(\"${VarName}={<{${${VarName}}}>}\")\n+                                    endforeach()\n+                                    \"\"\"\n+                    );\n+                });\n+\n+                var cmakeProcessBuilder =\n+                        new ProcessBuilder()\n+                                .directory(this.dir.path().toFile())\n+                                .redirectErrorStream(true)\n+                                .command(\"cmake\", \"-LAH\")\n+                                .start();\n+                List<String> stdinlines =\n+                        new BufferedReader(new InputStreamReader(cmakeProcessBuilder.getInputStream()))\n+                                .lines()\n+                                .toList();\n+                cmakeProcessBuilder.waitFor();\n+                this.dir.textFile(\"rawlines\", sb -> {\n+                    stdinlines.forEach(line -> sb.append(line).append(\"\\n\"));\n+                    \/\/ stderrlines.forEach(line-> sb.append(\"ERR\").append(line).append(\"\\n\"));\n+                });\n+\n+                String comment = null;\n+                String contentName = null;\n+                StringBuilder content = null;\n+\n+                for (String line : stdinlines) {\n+                    if (line.startsWith(\"\/\/\")) {\n+                        comment = line;\n+                        content = null;\n+\n+                    } else if (comment != null) {\n+                        if (CMakeTypedVar.onMatch(\n+                                line,\n+                                comment,\n+                                v -> {\n+                                    if (varMap.containsKey(v.name())) {\n+                                        var theVar = varMap.get(v.name());\n+                                        if (theVar.value().equals(v.value())) {\n+                                          \/*  println(\n+                                                    \"replacing duplicate variable with typed variant with the name same value\"\n+                                                            + v\n+                                                            + theVar);*\/\n+                                        } else {\n+                                            throw new IllegalStateException(\n+                                                    \"Duplicate variable name different value: \" + v + theVar);\n+                                        }\n+                                        varMap.put(v.name(), v);\n+                                    } else {\n+                                        varMap.put(v.name(), v);\n+                                    }\n+                                })) {\n+                        } else {\n+                            println(\"failed to parse \" + line);\n+                        }\n+                        comment = null;\n+                        content = null;\n+                        contentName = null;\n+                    } else if (!line.isEmpty()) {\n+                        if (content != null) {\n+                            if (CMakeContentVar.endRegex.pattern().matcher(line) instanceof Matcher matcher\n+                                    && matcher.matches()) {\n+                                content.append(\"\\n\").append(matcher.group(1));\n+                                var v = new CMakeContentVar(contentName, content.toString());\n+                                contentName = null;\n+                                content = null;\n+                                varMap.put(v.name(), v);\n+                            } else {\n+                                content.append(\"\\n\").append(line);\n+                            }\n+                        } else if (!line.endsWith(\"}>}\")\n+                                && CMakeContentVar.startRegex.pattern().matcher(line) instanceof Matcher matcher\n+                                && matcher.matches()) {\n+                            contentName = \"CMAKE_\" + matcher.group(1);\n+                            content = new StringBuilder(matcher.group(2));\n+                        } else if (CMakeRecipeVar.regex.pattern().matcher(line) instanceof Matcher matcher\n+                                && matcher.matches()) {\n+                            CMakeVar<String> v = new CMakeRecipeVar(matcher);\n+                            if (varMap.containsKey(v.name())) {\n+                                var theVar = varMap.get(v.name());\n+                                if (theVar.value().equals(v.value())) {\n+                                    \/\/  println(\"Skipping duplicate variable name different value: \" + v + theVar);\n+                                } else {\n+                                    throw new IllegalStateException(\n+                                            \"Duplicate variable name different value: \" + v + theVar);\n+                                }\n+                                varMap.put(v.name(), v);\n+                            } else {\n+                                varMap.put(v.name(), v);\n+                            }\n+                        } else if (CMakeSimpleVar.regex.pattern().matcher(line) instanceof Matcher matcher\n+                                && matcher.matches()) {\n+                            var v = new CMakeSimpleVar(matcher);\n+                            if (varMap.containsKey(v.name())) {\n+                                var theVar = varMap.get(v.name());\n+                                if (theVar.value().equals(v.value())) {\n+                                    \/\/ println(\"Skipping duplicate variable name different value: \" + v + theVar);\n+                                } else {\n+                                    \/\/throw new IllegalStateException(\n+                                    \/\/      \"Duplicate variable name different vars: \" + v + theVar);\n+                                }\n+                                \/\/ note we don't replace a Typed with a Simple\n+                            } else {\n+                                varMap.put(v.name(), v);\n+                            }\n+                        } else {\n+                            \/\/ println(\"Skipping \" + line);\n+                        }\n+                    }\n+                }\n+\n+            } catch (IOException ioe) {\n+                throw new RuntimeException(ioe);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            this.dir.textFile(\"vars\", sb -> {\n+                varMap.values().forEach(v -> sb.append(v.name()).append(\"<{<\").append(v.value().toString()).append(\">}>\").append(\"\\n\"));\n+            });\n+\n+            capabilities\n+                    .capabilities()\n+                    .filter(capability -> capability instanceof Capabilities.CMakeProbeable)\n+                    .map(capability -> (Capabilities.CMakeProbeable) capability)\n+                    .forEach(capability -> capability.accept(this));\n+\n+        }\n+\n+        ObjectFile cxxCompileObject(\n+                ObjectFile target, CppSourceFile source, List<String> frameworks) {\n+            CMakeRecipeVar compileObject = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_COMPILE_OBJECT\");\n+            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n+            localVars.put(\"DEFINES\", new CMakeSimpleVar(\"DEFINES\", \"\"));\n+            localVars.put(\"INCLUDES\", new CMakeSimpleVar(\"INCLUDES\", \"\"));\n+            localVars.put(\"FLAGS\", new CMakeSimpleVar(\"FLAGS\", \"\"));\n+            localVars.put(\"OBJECT\", new CMakeSimpleVar(\"OBJECT\", target.path().toString()));\n+            localVars.put(\"SOURCE\", new CMakeSimpleVar(\"SOURCE\", source.path().toString()));\n+            String executable = compileObject.expand(localVars);\n+            println(executable);\n+            return target;\n+        }\n+\n+        ExecutableFile cxxLinkExecutable(\n+                ExecutableFile target, List<ObjectFile> objFiles, List<String> frameworks) {\n+            CMakeRecipeVar linkExecutable = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_LINK_EXECUTABLE\");\n+            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n+            String executable = linkExecutable.expand(localVars);\n+            println(executable);\n+            return target;\n+        }\n+\n+        SharedLibraryFile cxxCreateSharedLibrary(\n+                SharedLibraryFile target, List<ObjectFile> objFiles, List<String> frameworks) {\n+            CMakeRecipeVar createSharedLibrary =\n+                    (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_CREATE_SHARED_LIBRARY\");\n+            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n+            String executable = createSharedLibrary.expand(localVars);\n+            println(executable);\n+            return target;\n+        }\n+\n+\n+        public String value(String key) {\n+            var v = varMap.get(key);\n+            return v.value().toString();\n+        }\n+\n+        public void dump() {\n+            varMap.forEach((k,v)->System.out.println(\"'\"+k+\"'='\"+v+\"'\"));\n+        }\n+        public boolean hasKey(String includeDirKey) {\n+            return varMap.containsKey(includeDirKey);\n+        }\n+\n+    }\n+\n+    public interface CapabilityHolder {\n+        Capabilities.Capability capability();\n+    }\n+\n+    public static class Capabilities {\n+\n+        public String tickOrCheck() {\n+            StringBuilder stringBuilder = new StringBuilder();\n+            capabilities().forEach(capability -> stringBuilder.append(capability.tickOrCheck()));\n+            return stringBuilder.toString();\n+        }\n+\n+        interface Probe {\n+\n+        }\n+\n+        public static abstract class Capability implements CapabilityHolder {\n+            final public String name;\n+\n+            protected Capability(String name) {\n+                this.name = name;\n+            }\n+\n+            public String name() {\n+                return name;\n+            }\n+\n+            public abstract boolean available();\n+\n+            @Override\n+            public Capability capability() {\n+                return this;\n+            }\n+\n+            public String tickOrCheck() {\n+                return \"[\" +  name + (available() ? \"\\u2714\" : \"\\u2715\") + \"]\";\n+            }\n+        }\n+\n+        public interface CMakeProbeable extends Consumer<Script.CMakeProbe> {\n+\n+            \/\/ void setCmakeProbe(Bldr.CMakeProbe cmakeProbe);\n+            String cmakeStanza();\n+        }\n+\n+        public interface Jextractable {\n+\n+\n+            String name();\n+\n+\n+\n+\n+            default String packageName() {\n+                return name().toLowerCase();\n+            }\n+\n+\n+            default String headerClassName() {\n+                return packageName() + \"_h\";\n+            }\n+\n+\n+\n+            void inversionOfControl(JExtractBuilder jextractBuilder);\n+        }\n+\n+        public Map<String, Capability> capabilityMap = new HashMap<>();\n+\n+        public static Capabilities of(CapabilityHolder... capabilityHolders) {\n+            return new Capabilities(capabilityHolders);\n+        }\n+\n+        public Stream<Capability> capabilities() {\n+            return capabilityMap.values().stream();\n+        }\n+\n+        public Stream<Capability> capabilities(Predicate<Capability> filter) {\n+            return capabilities().filter(filter);\n+        }\n+\n+        public boolean capabilityIsAvailable(String name) {\n+            return capabilities().anyMatch(c -> c.name.equalsIgnoreCase(name));\n+        }\n+\n+        private Capabilities(CapabilityHolder... capabilityHolders) {\n+            List.of(capabilityHolders).forEach(capabilityHolder ->\n+                    capabilityMap.put(capabilityHolder.capability().name, capabilityHolder.capability())\n+            );\n+\n+        }\n+\n+        public static final class OpenCL extends Capability implements CMakeProbeable, Jextractable {\n+            public static String includeDirKey = \"CMAKE_OpenCL_INCLUDE_DIR\";\n+            public static String libKey = \"CMAKE_OpenCL_LIBRARY\";\n+            public static String foundKey = \"CMAKE_OPENCL_FOUND\";\n+            public static String osxSysroot = \"CMAKE_OSX_SYSROOT\";\n+\n+            public OpenCL() {\n+                super(\"OpenCL\");\n+            }\n+\n+            public static OpenCL of() {\n+                return new OpenCL();\n+            }\n+\n+            @Override\n+            public String cmakeStanza() {\n+                return\n+                        \"\"\"\n+                                find_package(OpenCL)\n+                                if(OPENCL_FOUND)\n+                                    if (APPLE)\n+                                       set(OPENCL_INCLUDE_DIR \"-framework OpenCL\")\n+                                       set(OPENCL_LIBRARY_DIR \"-framework OpenCL\")\n+                                    else()\n+                                       set(OPENCL_LIB \"OpenCL\")\n+                                    endif()\n+                                endif()\n+                                \"\"\";\n+            }\n+\n+            public String appLibFrameworks() {\n+                return cmakeProbe.value(osxSysroot);\n+            }\n+\n+            @Override\n+            public boolean available() {\n+                return cmakeProbe.hasKey(foundKey) && cmakeProbe.value(foundKey).equals(\"TRUE\");\n+            }\n+\n+            public String lib() {\n+                return cmakeProbe.value(libKey);\n+            }\n+\n+            public String includeDir() {\n+                return cmakeProbe.value(includeDirKey);\n+            }\n+\n+            public Script.CMakeProbe cmakeProbe;\n+\n+            @Override\n+            public void accept(Script.CMakeProbe cmakeProbe) {\n+                this.cmakeProbe = cmakeProbe;\n+            }\n+\n+\n+            @Override\n+            public void inversionOfControl(JExtractBuilder jextractBuilder) {\n+ jextractBuilder.os(mac -> jextractBuilder\n+                                .compile_flag(\"-F\"\n+                                        + appLibFrameworks() + \"\/System\/library\/Frameworks\")\n+                                .library(mac.frameworkLibrary(\"OpenCL\"))\n+                                .header(Path.of(includeDir()).resolve(\"Headers\/opencl.h\")),\n+         linux -> jextractBuilder\n+                 \/\/ .compile_flag(\"-F\"\n+                 \/\/        + appLibFrameworks() + \"\/System\/library\/Frameworks\")\n+                 .library(Path.of(lib()))\n+                 .header(Path.of(includeDir()).resolve(\"opencl.h\"))\n+                      );\n+            }\n+        }\n+\n+        public static final class OpenGL extends Capability implements CMakeProbeable, Jextractable {\n+            public static String glutIncludeDirKey = \"CMAKE_GLUT_INCLUDE_DIR\";\n+            public static String openGLIncludeDirKey = \"CMAKE_OPENGL_INCLUDE_DIR\";\n+            public static String libKey = \"CMAKE_OPENGL_LIBRARY\";\n+            public static String osxSysroot = \"CMAKE_OSX_SYSROOT\";\n+\n+            public OpenGL() {\n+                super(\"OpenGL\");\n+            }\n+\n+            public static OpenGL of() {\n+                return new OpenGL();\n+            }\n+\n+            @Override\n+            public boolean available() {\n+                return cmakeProbe.hasKey(openGLIncludeDirKey);\n+            }\n+\n+            public DirEntry openglIncludeDir() {\n+                return DirEntry.of(Path.of(cmakeProbe.value(openGLIncludeDirKey)) + \"\/Headers\");\n+            }\n+\n+            public DirEntry glutIncludeDir() {\n+                return DirEntry.of(cmakeProbe.value(osxSysroot)+\"\/System\/Library\/Frameworks\/GLUT.framework\/Headers\");\n+            }\n+\n+            public String appLibFrameworks() {\n+                return cmakeProbe.value(osxSysroot);\n+            }\n+\n+            public List<Path> libs() {\n+                return Arrays.stream(cmakeProbe.value(libKey).split(\";\"))\n+                        .map(s->Path.of(s)).toList();\n+\n+            }\n+\n+            public Path lib(String frameworkName) {\n+                var split = cmakeProbe.value(libKey).split(\";\");\n+                return Path.of(split[0]).resolve(frameworkName + \".framework\/\" + frameworkName);\n+            }\n+\n+            @Override\n+            public String cmakeStanza() {\n+                return\n+                        \"\"\"\n+                                find_package(OpenGL)\n+                                if(OPENGL_FOUND)\n+                                    if (APPLE)\n+                                       set(OPENGL_FRAMEWORK \"-framework OpenGL\")\n+                                    else()\n+                                       set(OPENCL_LIB \"OpenCL\")\n+                                    endif()\n+                                else()\n+                                    message(\"NO OPENGL FOUND\")\n+                                endif()\n+                                \"\"\";\n+            }\n+\n+            public Script.CMakeProbe cmakeProbe;\n+\n+            @Override\n+            public void accept(Script.CMakeProbe cmakeProbe) {\n+\n+                this.cmakeProbe = cmakeProbe;\n+\/*\n+                cmakeProbe.varMap.forEach((k, v) -> {\n+                    if (k.toUpperCase().contains(\"OPENGL\")) {\n+                        println(k);\n+                    }\n+                    if (k.toUpperCase().contains(\"GLUT\")) {\n+                        println(k);\n+                    }\n+                }); *\/\n+\n+            }\n+            @Override public void inversionOfControl(JExtractBuilder jextractBuilder){\n+                jextractBuilder\n+                        .os(\n+                                mac -> jextractBuilder\n+                                   .compile_flag(\"-F\"\n+                                        + appLibFrameworks() + \"\/System\/library\/Frameworks\")\n+                                   .library(mac.frameworkLibrary(\"OpenGL\"))\n+                                   .library(mac.frameworkLibrary(\"GLUT\"))\n+                                   .header(glutIncludeDir().dir(\"glut.h\").path()),\n+                                linux -> jextractBuilder\n+                                  \/\/ .compile_flag(\"-F\"\n+                                    \/\/        + appLibFrameworks() + \"\/System\/library\/Frameworks\")\n+                                    .library(libs())\n+                                   \/\/ .library(lib(\"GLUT\"))\n+                                    .header(glutIncludeDir().dir(\"glut.h\").path())\n+                        );\n+            }\n+        }\n+\n+        public static final class HIP extends Capability implements CMakeProbeable, Jextractable {\n+            public HIP() {\n+                super(\"HIP\");\n+            }\n+\n+            public static HIP of() {\n+                return new HIP();\n+            }\n+\n+            @Override\n+            public boolean available() {\n+                return false;\n+            }\n+\n+            @Override\n+            public String cmakeStanza() {\n+                return\n+                        \"\"\"\n+                                find_package(HIP)\n+                                if(HIP_FOUND)\n+\n+                                else()\n+                                    message(\"NO HIP FOUND\")\n+                                endif()\n+                                \"\"\";\n+            }\n+\n+            public Script.CMakeProbe cmakeProbe;\n+\n+            @Override\n+            public void accept(Script.CMakeProbe cmakeProbe) {\n+\n+                this.cmakeProbe = cmakeProbe;\n+            }\n+\n+            @Override\n+            public void inversionOfControl(JExtractBuilder jextractBuilder) {\n+\n+            }\n+        }\n+\n+        public static final class CUDA extends Capability implements CMakeProbeable, Jextractable {\n+            public static String sdkRootDirKey = \"CMAKE_CUDA_SDK_ROOT_DIR\";\n+            public static String sdkRootDirNotFoundValue = \"CUDA_SDK_ROOT_DIR-NOTFOUND\";\n+\n+            public CUDA() {\n+                super(\"CUDA\");\n+            }\n+\n+            public static CUDA of() {\n+                return new CUDA();\n+            }\n+\n+            @Override\n+            public boolean available() {\n+                return cmakeProbe.hasKey(sdkRootDirKey) && !cmakeProbe.value(sdkRootDirKey).equals(sdkRootDirNotFoundValue);\n+            }\n+\n+            @Override\n+            public String cmakeStanza() {\n+                return\n+                        \"\"\"\n+                                find_package(CUDAToolkit)\n+                                if(CUDAToolkit_FOUND)\n+                                    set(CUDA_FOUND true)\n+                                    set(CUDA_INCLUDE_DIR ${CUDAToolkit_INCLUDE_DIR})\n+                                    set(CUDA_LIBRARY_DIR ${CUDAToolkit_LIBRARY_DIR})\n+                                    set(CUDA_LIBRARIES \"-lcudart -lcuda\")\n+                                else()\n+                                    message(\"NO CUDA FOUND\")\n+                                endif()\n+                                \"\"\";\n+            }\n+\n+            public Script.CMakeProbe cmakeProbe;\n+\n+            @Override\n+            public void accept(Script.CMakeProbe cmakeProbe) {\n+                this.cmakeProbe = cmakeProbe;\n+            }\n+\n+            @Override\n+            public void inversionOfControl(JExtractBuilder jextractBuilder) {\n+\n+            }\n+        }\n+\n+        public static final class JExtract extends Capability implements Executable {\n+            public JExtractExecutable executable;\n+\n+            JExtract() {\n+                super(\"JExtract\");\n+                var optionalExe = fromPATH(\"jextract\");\n+                if (optionalExe.isEmpty()) {\n+                    \/\/  println(\"jextract not in path\");\n+                } else {\n+                    executable = JExtractExecutable.of(optionalExe.get());\n+                }\n+\n+            }\n+\n+            JExtract(Path executable) {\n+                super(\"JExtract\");\n+                this.executable = JExtractExecutable.of(executable);\n+            }\n+\n+            @Override\n+            public boolean available() {\n+                return executable != null && executable.exists();\n+            }\n+\n+            public static JExtract of() {\n+                return new JExtract();\n+            }\n+            public static JExtract required() {\n+                JExtract jExtract = of();\n+                if (!jExtract.available()) {\n+                    throw new RuntimeException(\"jextract is reuired\");\n+                }\n+                return jExtract;\n+            }\n+\n+            public static JExtract of(Path executable) {\n+                return new JExtract(executable);\n+            }\n+\n+\n+            @Override\n+            public Path path() {\n+                return executable.path;\n+            }\n+        }\n+\n+        public static final class CMake extends Capability implements Executable {\n+            public JExtractExecutable executable;\n+            public Script.CMakeProbe cmakeProbe;\n+\n+            CMake() {\n+                super(\"CMake\");\n+                var optionalExe = fromPATH(\"cmake\");\n+                if (optionalExe.isEmpty()) {\n+                    println(\"cmake not in path\");\n+                } else {\n+                    executable = JExtractExecutable.of(optionalExe.get());\n+                }\n+            }\n+\n+            @Override\n+            public boolean available() {\n+                return executable != null && executable.exists();\n+            }\n+\n+            public static CMake of() {\n+                return new CMake();\n+            }\n+\n+            public static CMake required() {\n+                CMake cmake = of();\n+                if (!cmake.available()) {\n+                    throw new RuntimeException(\"cmake is required\");\n+                }\n+                return cmake;\n+            }\n+\n+            public void probe(BuildDir buildDir, Capabilities capabilities) {\n+                this.cmakeProbe = new Script.CMakeProbe(buildDir, capabilities);\n+            }\n+\n+            @Override\n+            public Path path() {\n+                return executable.path();\n+            }\n+        }\n+\n+    }\n+\n+    public record Regex(Pattern pattern) {\n+        Regex(String regex) {\n+            this(Pattern.compile(regex));\n+        }\n+\n+        public static Regex of(String regexString) {\n+            return new Regex(regexString);\n+        }\n+\n+        boolean matches(String text, Consumer<Matcher> matcherConsumer) {\n+            if (pattern().matcher(text) instanceof Matcher matcher && matcher.matches()) {\n+                matcherConsumer.accept(matcher);\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    public static class XMLNode {\n+        Element element;\n+        List<XMLNode> children = new ArrayList<>();\n+        Map<String, String> attrMap = new HashMap<>();\n+\n+        public static class AbstractXMLBuilder<T extends AbstractXMLBuilder<T>> {\n+            final public Element element;\n+\n+            @SuppressWarnings(\"unchecked\")\n+            public T self() {\n+                return (T) this;\n+            }\n+\n+            public T attr(String name, String value) {\n+                element.setAttribute(name, value);\n+                return self();\n+            }\n+\n+            public T attr(URI uri, String name, String value) {\n+                element.setAttributeNS(uri.toString(), name, value);\n+                return self();\n+            }\n+\n+            public T element(String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n+                var node = element.getOwnerDocument().createElement(name);\n+                element.appendChild(node);\n+                var builder = factory.apply(node);\n+                xmlBuilderConsumer.accept(builder);\n+                return self();\n+            }\n+\n+            public T element(\n+                    URI uri, String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n+                var node = element.getOwnerDocument().createElementNS(uri.toString(), name);\n+                element.appendChild(node);\n+                var builder = factory.apply(node);\n+                xmlBuilderConsumer.accept(builder);\n+                return self();\n+            }\n+\n+            AbstractXMLBuilder(Element element) {\n+                this.element = element;\n+            }\n+\n+            public T text(String thisText) {\n+                var node = element.getOwnerDocument().createTextNode(thisText);\n+                element.appendChild(node);\n+                return self();\n+            }\n+\n+            public T comment(String thisComment) {\n+                var node = element.getOwnerDocument().createComment(thisComment);\n+                element.appendChild(node);\n+                return self();\n+            }\n+\n+            <L> T forEach(List<L> list, BiConsumer<T, L> biConsumer) {\n+                list.forEach(l -> biConsumer.accept(self(), l));\n+                return self();\n+            }\n+\n+            <L> T forEach(Stream<L> stream, BiConsumer<T, L> biConsumer) {\n+                stream.forEach(l -> biConsumer.accept(self(), l));\n+                return self();\n+            }\n+\n+            <L> T forEach(Stream<L> stream, Consumer<L> consumer) {\n+                stream.forEach(consumer);\n+                return self();\n+            }\n+\n+            protected T then(Consumer<T> xmlBuilderConsumer) {\n+                xmlBuilderConsumer.accept(self());\n+                return self();\n+            }\n+        }\n+\n+        public static class PomXmlBuilder extends AbstractXMLBuilder<PomXmlBuilder> {\n+            PomXmlBuilder(Element element) {\n+                super(element);\n+            }\n+\n+            public PomXmlBuilder element(String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n+                return element(name, PomXmlBuilder::new, xmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder element(URI uri, String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n+                return element(uri, name, PomXmlBuilder::new, xmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder modelVersion(String s) {\n+                return element(\"modelVersion\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder pom(String groupId, String artifactId, String version) {\n+                return modelVersion(\"4.0.0\").packaging(\"pom\").ref(groupId, artifactId, version);\n+            }\n+\n+            public PomXmlBuilder jar(String groupId, String artifactId, String version) {\n+                return modelVersion(\"4.0.0\").packaging(\"jar\").ref(groupId, artifactId, version);\n+            }\n+\n+            public PomXmlBuilder groupId(String s) {\n+                return element(\"groupId\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder artifactId(String s) {\n+                return element(\"artifactId\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder packaging(String s) {\n+                return element(\"packaging\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder version(String s) {\n+                return element(\"version\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder build(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"build\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder plugins(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"plugins\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder plugin(\n+                    String groupId,\n+                    String artifactId,\n+                    String version,\n+                    Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\n+                        \"plugin\", $ -> $.ref(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n+            }\n+\n+            public PomXmlBuilder antPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return plugin(\n+                        \"org.apache.maven.plugins\",\n+                        \"maven-antrun-plugin\",\n+                        \"1.8\",\n+                        pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder surefirePlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return plugin(\n+                        \"org.apache.maven.plugins\",\n+                        \"maven-surefire-plugin\",\n+                        \"3.1.2\",\n+                        pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder compilerPlugin(\n+                    Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return plugin(\n+                        \"org.apache.maven.plugins\",\n+                        \"maven-compiler-plugin\",\n+                        \"3.11.0\", pomXmlBuilderConsumer\n+                );\n+            }\n+\n+            public PomXmlBuilder execPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return plugin(\"org.codehaus.mojo\", \"exec-maven-plugin\", \"3.1.0\", pomXmlBuilderConsumer);\n+            }\n+\n+\n+            public PomXmlBuilder plugin(\n+                    String groupId, String artifactId, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n+            }\n+\n+            public PomXmlBuilder plugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"plugin\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder parent(String groupId, String artifactId, String version) {\n+                return parent(parent -> parent.ref(groupId, artifactId, version));\n+            }\n+\n+            public PomXmlBuilder parent(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"parent\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder pluginManagement(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"pluginManagement\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder file(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"file\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder activation(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"activation\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder profiles(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"profiles\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder profile(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"profile\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder arguments(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"arguments\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder executions(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"executions\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder execution(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"execution\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder execIdPhaseConf(\n+                    String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return execution(execution -> execution.id(id).phase(phase).goals(gs -> gs.goal(\"exec\")).configuration(pomXmlBuilderConsumer));\n+            }\n+\n+            public PomXmlBuilder exec(\n+                    String phase, String executable, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return execIdPhaseConf(\n+                        executable + \"-\" + phase,\n+                        phase,\n+                        conf -> conf.executable(executable).arguments(pomXmlBuilderConsumer));\n+            }\n+\n+            public PomXmlBuilder cmake(\n+                    String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return execIdPhaseConf(\n+                        id, phase, conf -> conf.executable(\"cmake\").arguments(pomXmlBuilderConsumer));\n+            }\n+\n+            public PomXmlBuilder cmake(String id, String phase, String... args) {\n+                return execIdPhaseConf(\n+                        id,\n+                        phase,\n+                        conf ->\n+                                conf.executable(\"cmake\")\n+                                        .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n+            }\n+\n+            public PomXmlBuilder jextract(String id, String phase, String... args) {\n+                return execIdPhaseConf(\n+                        id,\n+                        phase,\n+                        conf ->\n+                                conf.executable(\"jextract\")\n+                                        .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n+            }\n+\n+            public PomXmlBuilder ant(\n+                    String id, String phase, String goal, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return execution(execution -> execution\n+                        .id(id)\n+                        .phase(phase)\n+                        .goals(gs -> gs.goal(goal))\n+                        .configuration(configuration -> configuration.target(pomXmlBuilderConsumer)));\n+            }\n+\n+            public PomXmlBuilder goals(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"goals\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder target(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"target\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder configuration(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"configuration\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder compilerArgs(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"compilerArgs\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder compilerArgs(String... args) {\n+                return element(\"compilerArgs\", $ -> $.forEach(Stream.of(args), $::arg));\n+            }\n+\n+            public PomXmlBuilder properties(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"properties\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder dependencies(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"dependencies\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder dependsOn(String groupId, String artifactId, String version) {\n+                return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version));\n+            }\n+\n+            public PomXmlBuilder dependsOn(String groupId, String artifactId, String version, String phase) {\n+                return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version, phase));\n+            }\n+\n+            public PomXmlBuilder dependency(String groupId, String artifactId, String version) {\n+                return dependency($ -> $.ref(groupId, artifactId, version));\n+            }\n+\n+            public PomXmlBuilder dependency(\n+                    String groupId, String artifactId, String version, String scope) {\n+                return dependency($ -> $.ref(groupId, artifactId, version).scope(scope));\n+            }\n+\n+            public PomXmlBuilder dependency(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"dependency\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder modules(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"modules\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder modules(List<String> modules) {\n+                return element(\"modules\", $ -> $.forEach(modules.stream(), $::module));\n+            }\n+\n+            public PomXmlBuilder modules(String... modules) {\n+                return modules(List.of(modules));\n+            }\n+\n+            public PomXmlBuilder module(String name) {\n+                return element(\"module\", $ -> $.text(name));\n+            }\n+\n+            public PomXmlBuilder property(String name, String value) {\n+                return element(name, $ -> $.text(value));\n+            }\n+\n+            public PomXmlBuilder antproperty(String name, String value) {\n+                return element(\"property\", $ -> $.attr(\"name\", name).attr(\"value\", value));\n+            }\n+\n+            public PomXmlBuilder scope(String s) {\n+                return element(\"scope\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder phase(String s) {\n+                return element(\"phase\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder argument(String s) {\n+                return element(\"argument\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder goal(String s) {\n+                return element(\"goal\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder copy(String file, String toDir) {\n+                return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n+            }\n+\n+            public PomXmlBuilder antjar(String basedir, String include, String destfile) {\n+                return element(\"jar\", $ -> $.attr(\"basedir\", basedir).attr(\"includes\", include + \"\/**\").attr(\"destfile\", destfile));\n+            }\n+\n+            public PomXmlBuilder echo(String message) {\n+                return element(\"echo\", $ -> $.attr(\"message\", message));\n+            }\n+\n+            public PomXmlBuilder echo(String filename, String message) {\n+                return element(\"echo\", $ -> $.attr(\"message\", message).attr(\"file\", filename));\n+            }\n+\n+            public PomXmlBuilder mkdir(String dirName) {\n+                return element(\"mkdir\", $ -> $.attr(\"dir\", dirName));\n+            }\n+\n+            public PomXmlBuilder groupIdArtifactId(String groupId, String artifactId) {\n+                return groupId(groupId).artifactId(artifactId);\n+            }\n+\n+            public PomXmlBuilder ref(String groupId, String artifactId, String version) {\n+                return groupIdArtifactId(groupId, artifactId).version(version);\n+            }\n+\n+            public PomXmlBuilder skip(String string) {\n+                return element(\"skip\", $ -> $.text(string));\n+            }\n+\n+            public PomXmlBuilder id(String s) {\n+                return element(\"id\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder arg(String s) {\n+                return element(\"arg\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder argLine(String s) {\n+                return element(\"argLine\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder source(String s) {\n+                return element(\"source\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder target(String s) {\n+                return element(\"target\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder showWarnings(String s) {\n+                return element(\"showWarnings\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder showDeprecation(String s) {\n+                return element(\"showDeprecation\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder failOnError(String s) {\n+                return element(\"failOnError\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder exists(String s) {\n+                return element(\"exists\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder activeByDefault(String s) {\n+                return element(\"activeByDefault\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder executable(String s) {\n+                return element(\"executable\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder workingDirectory(String s) {\n+                return element(\"workingDirectory\", $ -> $.text(s));\n+            }\n+        }\n+\n+        public static class ImlBuilder extends AbstractXMLBuilder<ImlBuilder> {\n+\n+            ImlBuilder(Element element) {\n+                super(element);\n+            }\n+\n+            public ImlBuilder element(String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n+                return element(name, ImlBuilder::new, xmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder element(URI uri, String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n+                return element(uri, name, ImlBuilder::new, xmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder modelVersion(String s) {\n+                return element(\"modelVersion\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder groupId(String s) {\n+                return element(\"groupId\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder artifactId(String s) {\n+                return element(\"artifactId\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder packaging(String s) {\n+                return element(\"packaging\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder version(String s) {\n+                return element(\"version\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder build(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"build\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder plugins(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"plugins\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder plugin(\n+                    String groupId,\n+                    String artifactId,\n+                    String version,\n+                    Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\n+                        \"plugin\",\n+                        $ ->\n+                                $.groupIdArtifactIdVersion(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n+            }\n+\n+            public ImlBuilder plugin(\n+                    String groupId, String artifactId, Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\n+                        \"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n+            }\n+\n+            public ImlBuilder plugin(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"plugin\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder parent(String groupId, String artifactId, String version) {\n+                return parent(parent -> parent.groupIdArtifactIdVersion(groupId, artifactId, version));\n+            }\n+\n+            public ImlBuilder parent(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"parent\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder pluginManagement(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"pluginManagement\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder file(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"file\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder activation(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"activation\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder profiles(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"profiles\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder profile(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"profile\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder arguments(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"arguments\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder executions(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"executions\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder execution(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"execution\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder goals(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"goals\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder target(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"target\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder configuration(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"configuration\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder compilerArgs(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"compilerArgs\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder properties(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"properties\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder dependencies(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"dependencies\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder dependency(String groupId, String artifactId, String version) {\n+                return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version));\n+            }\n+\n+            public ImlBuilder dependency(String groupId, String artifactId, String version, String scope) {\n+                return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version).scope(scope));\n+            }\n+\n+            public ImlBuilder dependency(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"dependency\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder modules(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"modules\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder module(String name) {\n+                return element(\"module\", $ -> $.text(name));\n+            }\n+\n+            public ImlBuilder property(String name, String value) {\n+                return element(name, $ -> $.text(value));\n+            }\n+\n+            public ImlBuilder scope(String s) {\n+                return element(\"scope\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder phase(String s) {\n+                return element(\"phase\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder argument(String s) {\n+                return element(\"argument\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder goal(String s) {\n+                return element(\"goal\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder copy(String file, String toDir) {\n+                return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n+            }\n+\n+            public ImlBuilder groupIdArtifactId(String groupId, String artifactId) {\n+                return groupId(groupId).artifactId(artifactId);\n+            }\n+\n+            public ImlBuilder groupIdArtifactIdVersion(String groupId, String artifactId, String version) {\n+                return groupIdArtifactId(groupId, artifactId).version(version);\n+            }\n+\n+            public ImlBuilder skip(String string) {\n+                return element(\"skip\", $ -> $.text(string));\n+            }\n+\n+            public ImlBuilder id(String s) {\n+                return element(\"id\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder arg(String s) {\n+                return element(\"arg\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder argLine(String s) {\n+                return element(\"argLine\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder source(String s) {\n+                return element(\"source\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder target(String s) {\n+                return element(\"target\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder showWarnings(String s) {\n+                return element(\"showWarnings\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder showDeprecation(String s) {\n+                return element(\"showDeprecation\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder failOnError(String s) {\n+                return element(\"failOnError\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder exists(String s) {\n+                return element(\"exists\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder activeByDefault(String s) {\n+                return element(\"activeByDefault\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder executable(String s) {\n+                return element(\"executable\", $ -> $.text(s));\n+            }\n+        }\n+\n+        public static class XMLBuilder extends AbstractXMLBuilder<XMLBuilder> {\n+            XMLBuilder(Element element) {\n+                super(element);\n+            }\n+\n+            public XMLBuilder element(String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+                return element(name, XMLBuilder::new, xmlBuilderConsumer);\n+            }\n+\n+            public XMLBuilder element(URI uri, String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+                return element(uri, name, XMLBuilder::new, xmlBuilderConsumer);\n+            }\n+        }\n+\n+        static XMLNode create(String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+\n+            try {\n+                var doc =\n+                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+                var element = doc.createElement(nodeName);\n+                doc.appendChild(element);\n+                XMLBuilder xmlBuilder = new XMLBuilder(element);\n+                xmlBuilderConsumer.accept(xmlBuilder);\n+                return new XMLNode(element);\n+            } catch (ParserConfigurationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static XMLNode createIml(String commentText, Consumer<ImlBuilder> imlBuilderConsumer) {\n+            try {\n+                var doc =\n+                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+                var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n+                var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n+                var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n+                var comment = doc.createComment(commentText);\n+                doc.appendChild(comment);\n+                var element = doc.createElementNS(uri1.toString(), \"project\");\n+                doc.appendChild(element);\n+                element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n+                ImlBuilder imlBuilder = new ImlBuilder(element);\n+                imlBuilderConsumer.accept(imlBuilder);\n+                return new XMLNode(element);\n+            } catch (ParserConfigurationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        public static XMLNode createPom(\n+                String commentText, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            try {\n+                var doc =\n+                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\n+                var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n+                var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n+                var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n+                var comment = doc.createComment(commentText);\n+                doc.appendChild(comment);\n+                var element = doc.createElementNS(uri1.toString(), \"project\");\n+                doc.appendChild(element);\n+                element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n+                PomXmlBuilder pomXmlBuilder = new PomXmlBuilder(element);\n+                pomXmlBuilderConsumer.accept(pomXmlBuilder);\n+                return new XMLNode(element);\n+            } catch (ParserConfigurationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static XMLNode create(URI uri, String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+            try {\n+                var doc =\n+                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+                var element = doc.createElementNS(uri.toString(), nodeName);\n+                doc.appendChild(element);\n+                XMLBuilder xmlBuilder = new XMLBuilder(element);\n+                xmlBuilderConsumer.accept(xmlBuilder);\n+                return new XMLNode(element);\n+            } catch (ParserConfigurationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        XMLNode(Element element) {\n+            this.element = element;\n+            this.element.normalize();\n+            NodeList nodeList = element.getChildNodes();\n+            for (int i = 0; i < nodeList.getLength(); i++) {\n+                if (nodeList.item(i) instanceof Element e) {\n+                    this.children.add(new XMLNode(e));\n+                }\n+            }\n+            for (int i = 0; i < element.getAttributes().getLength(); i++) {\n+                if (element.getAttributes().item(i) instanceof Attr attr) {\n+                    this.attrMap.put(attr.getName(), attr.getValue());\n+                }\n+            }\n+        }\n+\n+        public boolean hasAttr(String name) {\n+            return attrMap.containsKey(name);\n+        }\n+\n+        public String attr(String name) {\n+            return attrMap.get(name);\n+        }\n+\n+        static Document parse(InputStream is) {\n+            try {\n+                return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static Document parse(Path path) {\n+            try {\n+                return parse(Files.newInputStream(path));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        XMLNode(Path path) {\n+            this(parse(path).getDocumentElement());\n+        }\n+\n+        XMLNode(File file) {\n+            this(parse(file.toPath()).getDocumentElement());\n+        }\n+\n+        XMLNode(URL url) throws Throwable {\n+            this(parse(url.openStream()).getDocumentElement());\n+        }\n+\n+        void write(StreamResult streamResult) throws Throwable {\n+            var transformer = TransformerFactory.newInstance().newTransformer();\n+            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n+            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n+            transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n+            transformer.transform(new DOMSource(element.getOwnerDocument()), streamResult);\n+        }\n+\n+        void write(File file) {\n+            try {\n+                write(new StreamResult(file));\n+            } catch (Throwable t) {\n+                throw new RuntimeException(t);\n+            }\n+        }\n+\n+        public void write(XMLFile xmlFile) {\n+            try {\n+                write(new StreamResult(xmlFile.path().toFile()));\n+            } catch (Throwable t) {\n+                throw new RuntimeException(t);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var stringWriter = new StringWriter();\n+            try {\n+                var transformer = TransformerFactory.newInstance().newTransformer();\n+                transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+                transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n+                transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n+                transformer.transform(new DOMSource(element), new StreamResult(stringWriter));\n+                return stringWriter.toString();\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        XPathExpression xpath(String expression) {\n+            XPath xpath = XPathFactory.newInstance().newXPath();\n+            try {\n+                return xpath.compile(expression);\n+            } catch (XPathExpressionException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        Node node(XPathExpression xPathExpression) {\n+            try {\n+                return (Node) xPathExpression.evaluate(this.element, XPathConstants.NODE);\n+            } catch (XPathExpressionException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        Optional<Node> optionalNode(XPathExpression xPathExpression) {\n+            var nodes = nodes(xPathExpression).toList();\n+            return switch (nodes.size()) {\n+                case 0 -> Optional.empty();\n+                case 1 -> Optional.of(nodes.getFirst());\n+                default -> throw new IllegalStateException(\"Expected 0 or 1 but got more\");\n+            };\n+        }\n+\n+        String str(XPathExpression xPathExpression) {\n+            try {\n+                return (String) xPathExpression.evaluate(this.element, XPathConstants.STRING);\n+            } catch (XPathExpressionException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        String xpathQueryString(String xpathString) {\n+            try {\n+                return (String) xpath(xpathString).evaluate(this.element, XPathConstants.STRING);\n+            } catch (XPathExpressionException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        NodeList nodeList(XPathExpression xPathExpression) {\n+            try {\n+                return (NodeList) xPathExpression.evaluate(this.element, XPathConstants.NODESET);\n+            } catch (XPathExpressionException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        Stream<Node> nodes(XPathExpression xPathExpression) {\n+            var nodeList = nodeList(xPathExpression);\n+            List<Node> nodes = new ArrayList<>();\n+            for (int i = 0; i < nodeList.getLength(); i++) {\n+                nodes.add(nodeList.item(i));\n+            }\n+            return nodes.stream();\n+        }\n+\n+        Stream<Element> elements(XPathExpression xPathExpression) {\n+            return nodes(xPathExpression)\n+                    .filter(n -> n instanceof Element)\n+                    .map(n -> (Element) n);\n+        }\n+\n+        Stream<XMLNode> xmlNodes(XPathExpression xPathExpression) {\n+            return elements(xPathExpression).map(e -> new XMLNode(e));\n+        }\n+    }\n+\n+    public static class MavenStyleRepository {\n+        private final String repoBase = \"https:\/\/repo1.maven.org\/maven2\/\";\n+        private final String searchBase = \"https:\/\/search.maven.org\/solrsearch\/\";\n+        public RepoDir dir;\n+\n+        JarFile jarFile(Id id) {\n+            return dir.jarFile(id.artifactAndVersion() + \".jar\");\n+        }\n+\n+        XMLFile pomFile(Id id) {\n+            return dir.xmlFile(id.artifactAndVersion() + \".pom\");\n+        }\n+\n+        public enum Scope {\n+            TEST,\n+            COMPILE,\n+            PROVIDED,\n+            RUNTIME,\n+            SYSTEM;\n+\n+            static Scope of(String name) {\n+                return switch (name.toLowerCase()) {\n+                    case \"test\" -> TEST;\n+                    case \"compile\" -> COMPILE;\n+                    case \"provided\" -> PROVIDED;\n+                    case \"runtime\" -> RUNTIME;\n+                    case \"system\" -> SYSTEM;\n+                    default -> COMPILE;\n+                };\n+            }\n+        }\n+\n+        public record GroupAndArtifactId(GroupId groupId, ArtifactId artifactId) {\n+\n+            public static GroupAndArtifactId of(String groupAndArtifactId) {\n+                int idx = groupAndArtifactId.indexOf('\/');\n+                return of(groupAndArtifactId.substring(0, idx), groupAndArtifactId.substring(idx + 1));\n+            }\n+\n+            public static GroupAndArtifactId of(GroupId groupId, ArtifactId artifactId) {\n+                return new GroupAndArtifactId(groupId, artifactId);\n+            }\n+\n+            public static GroupAndArtifactId of(String groupId, String artifactId) {\n+                return of(GroupId.of(groupId), ArtifactId.of(artifactId));\n+            }\n+\n+            String location() {\n+                return groupId().string().replace('.', '\/') + \"\/\" + artifactId().string();\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return groupId() + \"\/\" + artifactId();\n+            }\n+        }\n+\n+        public sealed interface Id permits DependencyId, MetaDataId {\n+            MavenStyleRepository mavenStyleRepository();\n+\n+            GroupAndArtifactId groupAndArtifactId();\n+\n+            VersionId versionId();\n+\n+            default String artifactAndVersion() {\n+                return groupAndArtifactId().artifactId().string() + '-' + versionId();\n+            }\n+\n+            default String location() {\n+                return mavenStyleRepository().repoBase + groupAndArtifactId().location() + \"\/\" + versionId();\n+            }\n+\n+            default URL url(String suffix) {\n+                try {\n+                    return new URI(location() + \"\/\" + artifactAndVersion() + \".\" + suffix).toURL();\n+                } catch (MalformedURLException | URISyntaxException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+\n+        public record DependencyId(\n+                MavenStyleRepository mavenStyleRepository,\n+                GroupAndArtifactId groupAndArtifactId,\n+                VersionId versionId,\n+                Scope scope,\n+                boolean required)\n+                implements Id {\n+            @Override\n+            public String toString() {\n+                return groupAndArtifactId().toString()\n+                        + \"\/\"\n+                        + versionId()\n+                        + \":\"\n+                        + scope.toString()\n+                        + \":\"\n+                        + (required ? \"Required\" : \"Optiona\");\n+            }\n+        }\n+\n+        public record Pom(MetaDataId metaDataId, XMLNode xmlNode) {\n+            JarFile getJar() {\n+                var jarFile = metaDataId.mavenStyleRepository().jarFile(metaDataId); \/\/ ;\n+                metaDataId.mavenStyleRepository.queryAndCache(metaDataId.jarURL(), jarFile);\n+                return jarFile;\n+            }\n+\n+            String description() {\n+                return xmlNode().xpathQueryString(\"\/project\/description\/text()\");\n+            }\n+\n+            Stream<DependencyId> dependencies() {\n+                return xmlNode()\n+                        .nodes(xmlNode.xpath(\"\/project\/dependencies\/dependency\"))\n+                        .map(node -> new XMLNode((Element) node))\n+                        .map(\n+                                dependency ->\n+                                        new DependencyId(\n+                                                metaDataId().mavenStyleRepository(),\n+                                                GroupAndArtifactId.of(\n+                                                        GroupId.of(dependency.xpathQueryString(\"groupId\/text()\")),\n+                                                        ArtifactId.of(dependency.xpathQueryString(\"artifactId\/text()\"))),\n+                                                VersionId.of(dependency.xpathQueryString(\"version\/text()\")),\n+                                                Scope.of(dependency.xpathQueryString(\"scope\/text()\")),\n+                                                !Boolean.parseBoolean(dependency.xpathQueryString(\"optional\/text()\"))));\n+            }\n+\n+            Stream<DependencyId> requiredDependencies() {\n+                return dependencies().filter(DependencyId::required);\n+            }\n+        }\n+\n+        public Optional<Pom> pom(Id id) {\n+            return switch (id) {\n+                case MetaDataId metaDataId -> {\n+                    if (metaDataId.versionId() == VersionId.UNSPECIFIED) {\n+                        \/\/ println(\"what to do when the version is unspecified\");\n+                        yield Optional.empty();\n+                    }\n+                    try {\n+                        yield Optional.of(\n+                                new Pom(\n+                                        metaDataId,\n+                                        queryAndCache(\n+                                                metaDataId.pomURL(), metaDataId.mavenStyleRepository.pomFile(metaDataId))));\n+                    } catch (Throwable e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+                case DependencyId dependencyId -> {\n+                    if (metaData(\n+                            id.groupAndArtifactId().groupId().string(),\n+                            id.groupAndArtifactId().artifactId().string())\n+                            instanceof Optional<MetaData> optionalMetaData\n+                            && optionalMetaData.isPresent()) {\n+                        if (optionalMetaData\n+                                .get()\n+                                .metaDataIds()\n+                                .filter(metaDataId -> metaDataId.versionId().equals(id.versionId()))\n+                                .findFirst()\n+                                instanceof Optional<MetaDataId> metaId\n+                                && metaId.isPresent()) {\n+                            yield pom(metaId.get());\n+                        } else {\n+                            yield Optional.empty();\n+                        }\n+                    } else {\n+                        yield Optional.empty();\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        public Optional<Pom> pom(GroupAndArtifactId groupAndArtifactId) {\n+            var metaData = metaData(groupAndArtifactId).orElseThrow();\n+            var metaDataId = metaData.latestMetaDataId().orElseThrow();\n+            return pom(metaDataId);\n+        }\n+\n+        record IdVersions(GroupAndArtifactId groupAndArtifactId, Set<Id> versions) {\n+            static IdVersions of(GroupAndArtifactId groupAndArtifactId) {\n+                return new IdVersions(groupAndArtifactId, new HashSet<>());\n+            }\n+        }\n+\n+        public static class Dag implements ClassPathEntryProvider {\n+            private final MavenStyleRepository repo;\n+            private final List<GroupAndArtifactId> rootGroupAndArtifactIds;\n+            Map<GroupAndArtifactId, IdVersions> nodes = new HashMap<>();\n+            Map<IdVersions, List<IdVersions>> edges = new HashMap<>();\n+\n+            Dag add(Id from, Id to) {\n+                var fromNode =\n+                        nodes.computeIfAbsent(\n+                                from.groupAndArtifactId(), _ -> IdVersions.of(from.groupAndArtifactId()));\n+                fromNode.versions().add(from);\n+                var toNode =\n+                        nodes.computeIfAbsent(\n+                                to.groupAndArtifactId(), _ -> IdVersions.of(to.groupAndArtifactId()));\n+                toNode.versions().add(to);\n+                edges.computeIfAbsent(fromNode, k -> new ArrayList<>()).add(toNode);\n+                return this;\n+            }\n+\n+            void removeUNSPECIFIED() {\n+                nodes\n+                        .values()\n+                        .forEach(\n+                                idversions -> {\n+                                    if (idversions.versions().size() > 1) {\n+                                        List<Id> versions = new ArrayList<>(idversions.versions());\n+                                        idversions.versions().clear();\n+                                        idversions\n+                                                .versions()\n+                                                .addAll(\n+                                                        versions.stream()\n+                                                                .filter(v -> !v.versionId().equals(VersionId.UNSPECIFIED))\n+                                                                .toList());\n+                                        println(idversions);\n+                                    }\n+                                    if (idversions.versions().size() > 1) {\n+                                        throw new IllegalStateException(\"more than one version\");\n+                                    }\n+                                });\n+            }\n+\n+            Dag(MavenStyleRepository repo, List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n+                this.repo = repo;\n+                this.rootGroupAndArtifactIds = rootGroupAndArtifactIds;\n+\n+                Set<Id> unresolved = new HashSet<>();\n+                rootGroupAndArtifactIds.forEach(\n+                        rootGroupAndArtifactId -> {\n+                            var metaData = repo.metaData(rootGroupAndArtifactId).orElseThrow();\n+                            var metaDataId = metaData.latestMetaDataId().orElseThrow();\n+                            var optionalPom = repo.pom(rootGroupAndArtifactId);\n+\n+                            if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n+                                pom.requiredDependencies()\n+                                        .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n+                                        .forEach(\n+                                                dependencyId -> {\n+                                                    add(metaDataId, dependencyId);\n+                                                    unresolved.add(dependencyId);\n+                                                });\n+                            }\n+                        });\n+\n+                while (!unresolved.isEmpty()) {\n+                    var resolveSet = new HashSet<>(unresolved);\n+                    unresolved.clear();\n+                    resolveSet.forEach(id -> {\n+                        if (repo.pom(id) instanceof Optional<Pom> p && p.isPresent()) {\n+                            p.get()\n+                                    .requiredDependencies()\n+                                    .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n+                                    .forEach(\n+                                            dependencyId -> {\n+                                                unresolved.add(dependencyId);\n+                                                add(id, dependencyId);\n+                                            });\n+                        }\n+                    });\n+                }\n+                removeUNSPECIFIED();\n+            }\n+\n+            @Override\n+            public List<ClassPathEntry> classPathEntries() {\n+                return classPath().classPathEntries();\n+            }\n+\n+            ClassPath classPath() {\n+\n+                ClassPath jars = ClassPath.of();\n+                nodes\n+                        .keySet()\n+                        .forEach(\n+                                id -> {\n+                                    Optional<Pom> optionalPom = repo.pom(id);\n+                                    if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n+                                        jars.add(pom.getJar());\n+                                    } else {\n+                                        throw new RuntimeException(\"No pom for \" + id + \" needed by \" + id);\n+                                    }\n+                                });\n+                return jars;\n+            }\n+        }\n+\n+        public ClassPathEntryProvider classPathEntries(String... rootGroupAndArtifactIds) {\n+            return classPathEntries(Stream.of(rootGroupAndArtifactIds).map(GroupAndArtifactId::of).toList());\n+        }\n+\n+        public ClassPathEntryProvider classPathEntries(GroupAndArtifactId... rootGroupAndArtifactIds) {\n+            return classPathEntries(List.of(rootGroupAndArtifactIds));\n+        }\n+\n+        public ClassPathEntryProvider classPathEntries(List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n+            StringBuilder sb = new StringBuilder();\n+            rootGroupAndArtifactIds.forEach(groupAndArtifactId -> sb.append(sb.isEmpty() ? \"\" : \"-\").append(groupAndArtifactId.groupId + \"-\" + groupAndArtifactId.artifactId));\n+            System.out.println(sb);\n+            ClassPathEntryProvider classPathEntries = null;\n+            var pathFileName = sb + \"-path.xml\";\n+            var pathFile = dir.xmlFile(pathFileName);\n+            if (pathFile.exists()) {\n+                System.out.println(pathFileName + \" exists \" + pathFile.path().toString());\n+                XMLNode path = new XMLNode(pathFile.path());\n+                ClassPath classPath = ClassPath.of();\n+                path.nodes(path.xpath(\"\/path\/jar\/text()\")).forEach(e ->\n+                        classPath.add(dir.jarFile(e.getNodeValue()))\n+                );\n+                classPathEntries = classPath;\n+            } else {\n+                var finalClassPathEntries = new Dag(this, rootGroupAndArtifactIds);\n+                XMLNode.create(\"path\", xml -> {\n+                    finalClassPathEntries.classPathEntries().forEach(cpe ->\n+                            xml.element(\"jar\", jar -> jar.text(dir.path().relativize(cpe.path()).toString()))\n+                    );\n+                }).write(pathFile);\n+                System.out.println(\"created \" + pathFile.path());\n+                classPathEntries = finalClassPathEntries;\n+            }\n+            return classPathEntries;\n+        }\n+\n+        public record VersionId(Integer maj, Integer min, Integer point, String classifier)\n+                implements Comparable<VersionId> {\n+            static Integer integerOrNull(String s) {\n+                return (s == null || s.isEmpty()) ? null : Integer.parseInt(s);\n+            }\n+\n+            public static Pattern pattern = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+)(?:\\\\.(\\\\d+)(.*))?)?$\");\n+            static VersionId UNSPECIFIED = new VersionId(null, null, null, null);\n+\n+            static VersionId of(String version) {\n+                Matcher matcher = pattern.matcher(version);\n+                if (matcher.matches()) {\n+                    return new VersionId(\n+                            integerOrNull(matcher.group(1)),\n+                            integerOrNull(matcher.group(2)),\n+                            integerOrNull(matcher.group(3)),\n+                            matcher.group(4));\n+                } else {\n+                    return UNSPECIFIED;\n+                }\n+            }\n+\n+            int cmp(Integer v1, Integer v2) {\n+                if (v1 == null && v2 == null) {\n+                    return 0;\n+                }\n+                if (v1 == null) {\n+                    return -v2;\n+                } else if (v2 == null) {\n+                    return v1;\n+                } else {\n+                    return v1 - v2;\n+                }\n+            }\n+\n+            @Override\n+            public int compareTo(VersionId o) {\n+                if (cmp(maj(), o.maj()) == 0) {\n+                    if (cmp(min(), o.min()) == 0) {\n+                        if (cmp(point(), o.point()) == 0) {\n+                            return classifier().compareTo(o.classifier());\n+                        } else {\n+                            return cmp(point(), o.point());\n+                        }\n+                    } else {\n+                        return cmp(min(), o.min());\n+                    }\n+                } else {\n+                    return cmp(maj(), o.maj());\n+                }\n+            }\n+\n+            @Override\n+            public String toString() {\n+                StringBuilder sb = new StringBuilder();\n+                if (maj() != null) {\n+                    sb.append(maj());\n+                    if (min() != null) {\n+                        sb.append(\".\").append(min());\n+                        if (point() != null) {\n+                            sb.append(\".\").append(point());\n+                            if (classifier() != null) {\n+                                sb.append(classifier());\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    sb.append(\"UNSPECIFIED\");\n+                }\n+                return sb.toString();\n+            }\n+        }\n+\n+        public record GroupId(String string) {\n+            public static GroupId of(String s) {\n+                return new GroupId(s);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return string;\n+            }\n+        }\n+\n+        public record ArtifactId(String string) {\n+            static ArtifactId of(String string) {\n+                return new ArtifactId(string);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return string;\n+            }\n+        }\n+\n+        public record MetaDataId(\n+                MavenStyleRepository mavenStyleRepository,\n+                GroupAndArtifactId groupAndArtifactId,\n+                VersionId versionId,\n+                Set<String> downloadables,\n+                Set<String> tags)\n+                implements Id {\n+\n+            public URL pomURL() {\n+                return url(\"pom\");\n+            }\n+\n+            public URL jarURL() {\n+                return url(\"jar\");\n+            }\n+\n+            public XMLNode getPom() {\n+                if (downloadables.contains(\".pom\")) {\n+                    return mavenStyleRepository.queryAndCache(\n+                            url(\"pom\"), mavenStyleRepository.dir.xmlFile(artifactAndVersion() + \".pom\"));\n+                } else {\n+                    throw new IllegalStateException(\"no pom\");\n+                }\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return groupAndArtifactId().toString() + \".\" + versionId();\n+            }\n+        }\n+\n+        public MavenStyleRepository(RepoDir dir) {\n+            this.dir = dir.create();\n+        }\n+\n+        JarFile queryAndCache(URL query, JarFile jarFile) {\n+            try {\n+                if (!jarFile.exists()) {\n+                    print(\"Querying and caching \" + jarFile.fileName());\n+                    println(\" downloading \" + query);\n+                    curl(query, jarFile.path());\n+                } else {\n+                    \/\/ println(\"Using cached \" + jarFile.fileName());\n+\n+                }\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+            return jarFile;\n+        }\n+\n+        XMLNode queryAndCache(URL query, XMLFile xmlFile) {\n+            XMLNode xmlNode = null;\n+            try {\n+                if (!xmlFile.exists()) {\n+                    print(\"Querying and caching \" + xmlFile.fileName());\n+                    println(\" downloading \" + query);\n+                    xmlNode = new XMLNode(query);\n+                    xmlNode.write(xmlFile.path().toFile());\n+                } else {\n+                    \/\/ println(\"Using cached \" + xmlFile.fileName());\n+                    xmlNode = new XMLNode(xmlFile.path());\n+                }\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+            return xmlNode;\n+        }\n+\n+        public record MetaData(\n+                MavenStyleRepository mavenStyleRepository,\n+                GroupAndArtifactId groupAndArtifactId,\n+                XMLNode xmlNode) {\n+\n+            public Stream<MetaDataId> metaDataIds() {\n+                return xmlNode\n+                        .xmlNodes(xmlNode.xpath(\"\/response\/result\/doc\"))\n+                        .map(\n+                                xmln ->\n+                                        new MetaDataId(\n+                                                this.mavenStyleRepository,\n+                                                GroupAndArtifactId.of(\n+                                                        GroupId.of(xmln.xpathQueryString(\"str[@name='g']\/text()\")),\n+                                                        ArtifactId.of(xmln.xpathQueryString(\"str[@name='a']\/text()\"))),\n+                                                VersionId.of(xmln.xpathQueryString(\"str[@name='v']\/text()\")),\n+                                                new HashSet<>(\n+                                                        xmln.nodes(xmln.xpath(\"arr[@name='ec']\/str\/text()\"))\n+                                                                .map(Node::getNodeValue)\n+                                                                .toList()),\n+                                                new HashSet<>(\n+                                                        xmln.nodes(xmln.xpath(\"arr[@name='tags']\/str\/text()\"))\n+                                                                .map(Node::getNodeValue)\n+                                                                .toList())));\n+            }\n+\n+            public Stream<MetaDataId> sortedMetaDataIds() {\n+                return metaDataIds().sorted(Comparator.comparing(MetaDataId::versionId));\n+            }\n+\n+            public Optional<MetaDataId> latestMetaDataId() {\n+                return metaDataIds().max(Comparator.comparing(MetaDataId::versionId));\n+            }\n+\n+            public Optional<MetaDataId> getMetaDataId(VersionId versionId) {\n+                return metaDataIds().filter(id -> versionId.compareTo(id.versionId()) == 0).findFirst();\n+            }\n+        }\n+\n+        public Optional<MetaData> metaData(String groupId, String artifactId) {\n+            return metaData(GroupAndArtifactId.of(groupId, artifactId));\n+        }\n+\n+        public Optional<MetaData> metaData(GroupAndArtifactId groupAndArtifactId) {\n+            try {\n+                var query = \"g:\" + groupAndArtifactId.groupId() + \" AND a:\" + groupAndArtifactId.artifactId();\n+                URL rowQueryUrl =\n+                        new URI(\n+                                searchBase\n+                                        + \"select?q=\"\n+                                        + URLEncoder.encode(query, StandardCharsets.UTF_8)\n+                                        + \"&core=gav&wt=xml&rows=0\")\n+                                .toURL();\n+                var rowQueryResponse = new XMLNode(rowQueryUrl);\n+                var numFound = rowQueryResponse.xpathQueryString(\"\/response\/result\/@numFound\");\n+\n+                URL url =\n+                        new URI(\n+                                searchBase\n+                                        + \"select?q=\"\n+                                        + URLEncoder.encode(query, StandardCharsets.UTF_8)\n+                                        + \"&core=gav&wt=xml&rows=\"\n+                                        + numFound)\n+                                .toURL();\n+                try {\n+                    \/\/ println(url);\n+                    var xmlNode =\n+                            queryAndCache(url, dir.xmlFile(groupAndArtifactId.artifactId() + \".meta.xml\"));\n+                    if (numFound.isEmpty() || numFound.equals(\"0\")) {\n+                        return Optional.empty();\n+                    } else {\n+                        return Optional.of(new MetaData(this, groupAndArtifactId, xmlNode));\n+                    }\n+                } catch (Throwable e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static class IntelliJ {\n+        public static class IntellijArtifact {\n+            DirEntry projectDir;\n+            XMLNode root;\n+\n+            Stream<XMLNode> query(String xpath) {\n+                return root.nodes(root.xpath(xpath)).map(e -> new XMLNode((Element) e));\n+            }\n+\n+            IntellijArtifact(DirEntry projectDir, XMLNode root) {\n+                this.projectDir = projectDir;\n+                this.root = root;\n+            }\n+        }\n+\n+        public static class Workspace extends IntellijArtifact {\n+\n+            record Application(XMLNode xmlNode) {\n+            }\n+\n+            List<Application> applications;\n+\n+            Workspace(DirEntry projectDir, XMLNode root) {\n+                super(projectDir, root);\n+                this.applications =\n+                        query(\"\/project\/component[@name='RunManager']\/configuration\")\n+                                .map(Application::new)\n+                                .toList();\n+            }\n+        }\n+\n+        public static class Compiler extends IntellijArtifact {\n+            public record JavacSettings(XMLNode xmlNode) {\n+                public String getAdditionalOptions() {\n+                    return xmlNode.xpathQueryString(\"option[@name='ADDITIONAL_OPTIONS_STRING']\/@value\");\n+                }\n+            }\n+\n+            public JavacSettings javacSettings;\n+\n+            Compiler(DirEntry projectDir, XMLNode root) {\n+                super(projectDir, root);\n+                this.javacSettings =\n+                        new JavacSettings(query(\"\/project\/component[@name='JavacSettings']\").findFirst().get());\n+            }\n+        }\n+\n+        public static class ImlGraph extends IntellijArtifact {\n+            public record Module(Path imlPath, XMLNode xmlNode) {\n+                @Override\n+                public String toString() {\n+                    return name();\n+                }\n+\n+                public String name() {\n+                    return imlPath.getFileName().toString();\n+                }\n+\n+                public SourcePath getSourcePath() {\n+                    return null;\n+                }\n+\n+                Stream<XMLNode> query(String xpath) {\n+                    return xmlNode.nodes(xmlNode.xpath(xpath)).map(e -> new XMLNode((Element) e));\n+                }\n+            }\n+\n+            Stream<XMLNode> query(String xpath) {\n+                return root.nodes(root.xpath(xpath)).map(e -> new XMLNode((Element) e));\n+            }\n+\n+            Set<Module> modules = new HashSet<>();\n+            public Map<Module, List<Module>> fromToDependencies = new HashMap<>();\n+            Map<Module, List<Module>> toFromDependencies = new HashMap<>();\n+\n+            ImlGraph(DirEntry projectDir, XMLNode root) {\n+                super(projectDir, root);\n+                Map<String, Module> nameToModule = new HashMap<>();\n+                query(\"\/project\/component[@name='ProjectModuleManager']\/modules\/module\")\n+                        .map(\n+                                xmlNode ->\n+                                        Path.of(\n+                                                xmlNode\n+                                                        .attrMap\n+                                                        .get(\"filepath\")\n+                                                        .replace(\"$PROJECT_DIR$\", projectDir.path().toString())))\n+                        .map(path -> new Module(path, new XMLNode(path)))\n+                        .forEach(\n+                                module -> {\n+                                    modules.add(module);\n+                                    nameToModule.put(module.name(), module);\n+                                });\n+                modules.forEach(\n+                        module ->\n+                                module\n+                                        .xmlNode\n+                                        .nodes(root.xpath(\"\/module\/component\/orderEntry[@type='module']\"))\n+                                        .map(e -> new XMLNode((Element) e))\n+                                        .forEach(\n+                                                e -> {\n+                                                    var dep = nameToModule.get(e.attrMap.get(\"module-name\") + \".iml\");\n+                                                    fromToDependencies.computeIfAbsent(module, _ -> new ArrayList<>()).add(dep);\n+                                                    toFromDependencies.computeIfAbsent(dep, _ -> new ArrayList<>()).add(module);\n+                                                }));\n+            }\n+        }\n+\n+        public static class Project {\n+            public DirEntry intellijDir;\n+            public ImlGraph imlGraph;\n+            public Workspace workSpace;\n+            public Compiler compiler;\n+\n+            public Project(DirEntry intellijDir) {\n+                this.intellijDir = intellijDir;\n+                var ideaDir = intellijDir.existingDir(\".idea\");\n+                imlGraph = new ImlGraph(intellijDir, new XMLNode(ideaDir.xmlFile(\"modules.xml\").path()));\n+                workSpace = new Workspace(intellijDir, new XMLNode(ideaDir.xmlFile(\"workspace.xml\").path()));\n+                compiler = new Compiler(intellijDir, new XMLNode(ideaDir.xmlFile(\"compiler.xml\").path()));\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/hat\/Script.java","additions":4576,"deletions":0,"binary":false,"changes":4576,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 25 hat\/bld.java\n","filename":"hat\/hat\/bld","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,339 @@\n+\/*\n+ *\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import static java.io.IO.println;\n+import static java.lang.System.out;\n+\n+\n+static class MavenStyleProject implements Script.ClassPathEntryProvider {\n+    final Script.JarFile jarFile;\n+    final Script.DirEntry dir;\n+    final String name;\n+\n+    final boolean hasJavaSources;\n+\n+    final List<Script.ClassPathEntryProvider> classPath = new ArrayList<>();\n+    final List<Script.ClassPathEntryProvider> failedDependencies = new ArrayList<>();\n+    MavenStyleProject(Script.JarFile jarFile, Script.DirEntry dir, String name,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n+        this.jarFile = jarFile;\n+        this.dir = dir;\n+        this.name = name;\n+\n+        this.classPath.addAll(List.of(classPathEntryProviders ));\n+\n+        for (Script.ClassPathEntryProvider classPathEntryProvider : classPathEntryProviders) {\n+            classPathEntryProvider.classPathEntries().forEach(classPathEntry -> {\n+                if (!classPathEntry.exists()){\n+                    failedDependencies.add(classPathEntry);\n+                }\n+            });\n+        }\n+        this.hasJavaSources = dir.sourceDir(\"src\/main\/java\").javaFiles().findAny().isPresent();\n+      \/\/  println(name+\" failedDependencies.isEmpty()=\"+failedDependencies.isEmpty()+ \" hasJavaSources=\"+hasJavaSources);\n+    }\n+\n+    static MavenStyleProject example(Script.BuildDir buildDir, Script.DirEntry dir,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n+        return new MavenStyleProject(buildDir.jarFile(\"hat-example-\" + dir.fileName() + \"-1.0.jar\"), dir, dir.fileName(), classPathEntryProviders);\n+    }\n+    static MavenStyleProject javaBackend(Script.BuildDir buildDir, Script.DirEntry dir,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n+        return new MavenStyleProject(buildDir.jarFile(\"hat-backend-java-\" + dir.fileName() + \"-1.0.jar\"), dir, dir.fileName(),classPathEntryProviders);\n+    }\n+    static MavenStyleProject ffiBackend(Script.BuildDir buildDir, Script.DirEntry dir,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n+        return new MavenStyleProject(buildDir.jarFile(\"hat-backend-ffi-\" + dir.fileName() + \"-1.0.jar\"), dir, dir.fileName(),classPathEntryProviders);\n+    }\n+    static MavenStyleProject jextractedBackend(Script.BuildDir buildDir, Script.DirEntry dir,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n+        return new MavenStyleProject(buildDir.jarFile(\"hat-backend-jextracted-\" + dir.fileName() + \"-1.0.jar\"), dir, dir.fileName(),classPathEntryProviders);\n+    }\n+\n+    static MavenStyleProject of(  Script.DirEntry dir, Script.JarFile jarFile, Script.ClassPathEntryProvider ...classPathEntryProviders) {\n+        return new MavenStyleProject(jarFile, dir, dir.fileName(),classPathEntryProviders);\n+    }\n+\n+    boolean canBeBuilt(){\n+        if (hasJavaSources && failedDependencies.isEmpty()) {\n+           return true;\n+        }else if (!hasJavaSources) {\n+            println(\"Skipping \" + jarFile.fileName() + \" no java sources\");\n+        }else  if (!failedDependencies.isEmpty()){\n+            print(\"Skipping \"+jarFile.fileName()+\" failed dependencies \");\n+            for (Script.ClassPathEntryProvider classPathEntryProvider : failedDependencies) {\n+                classPathEntryProvider.classPathEntries().forEach(classPathEntry ->\n+                   print(classPathEntry.fileName())\n+                );\n+            }\n+            println(\"\");\n+        }else{\n+            println(\"Skipping \"+jarFile.fileName()+\"why!\");\n+        }\n+        return false;\n+    }\n+\n+    public MavenStyleProject build() {\n+        if (canBeBuilt()) {\n+            Script.jar(jar -> jar\n+                    .verbose(false)\n+                    .jarFile(jarFile)\n+                    .maven_style_root(dir)\n+                    .javac(javac -> javac\n+                            .enable_preview()\n+                            .add_modules(\"jdk.incubator.code\")\n+                            .current_source()\n+                            .class_path(classPath)\n+                    )\n+            );\n+            println(jarFile.fileName() + \" OK\");\n+        }\n+        return this;\n+    }\n+\n+\n+\n+    @Override\n+    public List<Script.ClassPathEntry> classPathEntries() {\n+        return List.of(jarFile);\n+    }\n+}\n+\n+void main(String[] args) {\n+    var layout = \"\"\"\n+       └──.\/\n+           ├──hat                                      \/\/  All build scripts in each case 'foo' has java options for (and points to) 'foo.java'\n+           │    ├──bld                                 \/\/  --enable-preview --source 25 hat\/bld.java\n+           │    ├──bld.java\n+           │    ├──run                                 \/\/  --enable-preview --source 25 hat\/run.java\n+           │    ├──run.java\n+           │    └──Script                              \/\/  Contains all the tools for building\n+           │\n+           ├──build\/                                   \/\/ All jars, native libs and executables\n+           │    └──cmake-build-debug\/                  \/\/ All intermediate cmake artifacts\n+           │        ├── hat-*wrap-1.0.jar              \/\/ Wrapper jars around extracted * (clwrap, glwrap, cuwrap)\n+           │        ├── hat-core-1.0.jar               \/\/ Base hat jar\n+           │        ├── hat-example-*-1.0.jar          \/\/ Example jars (hat-example-nbody-1.0.jar, hat-example-life-1.0.jar)\n+           │        ├── hat-jextracted-opencl-1.0.jar  \/\/ Raw jextracted jars (hat-jextracted-opencl-1.0.jar ....)\n+           │        ├── lib*_backend.[dylib|so]        \/\/ ffi library backends\n+           │        └── *(no suffix)                   \/\/ various generated executables (opencl_info, cuda_info, cuda_squares)\n+           ├──stage\/\n+           │   └── repo\/\n+           │       └── *                               \/\/ Maven artifacts (poms and jars)\n+           ├──extractions\/\n+           │   ├──CMakeFiles.txt\n+           │   ├── opencl\/                             \/\/ Maven style layout\n+           │   │   ├── CMakeFiles.txt\n+           │   │   └── src\/main\/java\/opencl            \/\/ created by cmake\n+           │   ├── cuda\/                               \/\/ Maven style layout\n+           │   │   ├── CMakeFiles.txt\n+           │   │   └── src\/main\/java\/cuda              \/\/ created by cmake\n+           │   └── opengl\/                             \/\/ Maven style layout\n+           │       ├── CMakeFiles.txt\n+           │       └── src\/main\/java\/opengl            \/\/ created by cmake\n+           ├──wrap\/\n+           │    └──wrap\/\n+           │         ├──wrap\/                          \/\/ Maven style layout\n+           │         ├──clwrap\/                        \/\/ Maven style layout\n+           │         ├──glwrap\/                        \/\/ Maven style layout\n+           │         └──cuwrap\/                        \/\/ Maven style layout\n+           │\n+           ├──hat-core                                 \/\/ Maven style layout\n+           │    ├──src\/main\/java\n+           │    │    └──hat\/\n+           │    │\n+           │    └──src\/main\/test\n+           │         └──hat\/\n+           │\n+           ├──backends\n+           │    ├──java\n+           │    │    ├──mt                             \/\/ Maven style layout\n+           │    │    └──seq                            \/\/ Maven style layout\n+           │    ├──jextracted\n+           │    │    └──opencl                         \/\/ Maven style layout\n+           │    └──ffi\n+           │         ├──opencl                         \/\/ Maven style layout with cmake\n+           │         ├──ptx                            \/\/ Maven style layout with cmake\n+           │         ├──mock                           \/\/ Maven style layout with cmake\n+           │         ├──spirv                          \/\/ Maven style layout with cmake\n+           │         ├──cuda                           \/\/ Maven style layout with cmake\n+           │         └──hip                            \/\/ Maven style layout with cmake\n+           │\n+           └──examples\n+                ├──mandel                              \/\/ Maven style layout\n+                ├──squares                             \/\/ Maven style layout\n+                ├──heal                                \/\/ Maven style layout\n+                ├──life                                \/\/ Maven style layout\n+                ├──nbody                               \/\/ Maven style layout\n+                ├──experiments                         \/\/ Maven style layout\n+                └──violajones                          \/\/ Maven style layout\n+       \"\"\";\n+\n+    var dir = Script.DirEntry.current();\n+    var buildDir = Script.BuildDir.of(dir.path(\"build\")).create();\n+    var cmakeCapability = Script.Capabilities.CMake.required();\n+    Script.Capabilities capabilities = Script.Capabilities.of( cmakeCapability);\n+    cmakeCapability.probe(buildDir, capabilities);\n+    out.println(capabilities.tickOrCheck());\n+\n+\n+    var hatCore = MavenStyleProject.of(\n+            dir.existingDir(\"hat-core\"),\n+            buildDir.jarFile(\"hat-core-1.0.jar\")\n+    ).build();\n+\n+    var wrapsDir = dir.existingDir(\"wrap\");\n+\n+    var wrap = MavenStyleProject.of(wrapsDir.existingDir(\"wrap\"), buildDir.jarFile(\"hat-wrap-1.0.jar\")\n+    ).build();\n+\n+    var extractionsDir = dir.existingDir(\"extractions\");\n+\n+    var extractionsCmakeBuildDir = extractionsDir.cMakeBuildDir(\"cmake-build-debug\");\n+    if (!extractionsCmakeBuildDir.exists()) {\n+        Script.cmake($ -> $\n+                .verbose(false)\n+                .source_dir(extractionsDir)\n+                .build_dir(extractionsCmakeBuildDir)\n+        );\n+    }\n+    Script.cmake($ -> $\n+            .build(extractionsCmakeBuildDir)\n+            .target(\"extract\")\n+    );\n+    var jextractedOpenCLDir = extractionsDir.dir(\"opencl\");\n+    var extractedOpenCLJar = buildDir.jarFile(\"hat-jextracted-opencl-1.0.jar\");\n+    if (jextractedOpenCLDir.dir(\"src\").exists()) {\n+        MavenStyleProject.of(jextractedOpenCLDir,extractedOpenCLJar).build();\n+    }\n+\n+    var extractedOpenGLJar = buildDir.jarFile(\"hat-jextracted-opengl-1.0.jar\");\n+\n+    var jextractedOpenGLDir = extractionsDir.dir(\"opengl\");\n+    if (jextractedOpenGLDir.dir(\"src\").exists()) {\n+        MavenStyleProject.of(jextractedOpenGLDir,extractedOpenGLJar).build();\n+    }\n+\n+    var extractedCudaJar = buildDir.jarFile(\"hat-jextracted-cuda-1.0.jar\");\n+    var jextractedCudaDir = extractionsDir.dir(\"cuda\");\n+    if (jextractedCudaDir.dir(\"src\").exists()) {\n+        MavenStyleProject.of(jextractedCudaDir,extractedCudaJar).build();\n+    }\n+\n+    var clWrap = MavenStyleProject.of(wrapsDir.dir(\"clwrap\"), buildDir.jarFile(\"hat-clwrap-1.0.jar\"),\n+            wrap, hatCore, extractedOpenCLJar\n+    ).build();\n+\n+\n+    var glWrap = MavenStyleProject.of(wrapsDir.dir(\"glwrap\"), buildDir.jarFile(\"hat-glwrap-1.0.jar\"),\n+            wrap, hatCore, extractedOpenGLJar\n+    ); \/\/ we can't use build, we need a custom build because of the file exclusions\n+    if (glWrap.canBeBuilt()) {\n+        Script.jar(jar -> jar\n+                .jarFile(glWrap.jarFile)\n+                .maven_style_root(glWrap.dir)\n+                .javac(javac -> javac\n+                        .current_source()\n+                        .exclude(javaSrc -> javaSrc.matches(\"^.*\/wrap\/glwrap\/GLCallbackEventHandler\\\\.java$\"))\n+                        \/\/.exclude(javaSrc -> javaSrc.matches(\"^.*\/wrap\/glwrap\/GLFuncEventHandler\\\\.java$\"))\n+                        .class_path(wrap, extractedOpenGLJar)\n+                )\n+        );\n+        println(glWrap.jarFile.fileName()+\" OK\");\n+    }\n+\n+    \/\/var cuWrap = MavenStyleProject.of(wrapsDir.dir(\"cuwrap\"), buildDir.jarFile(\"hat-cuwrap-1.0.jar\"),\n+     \/\/       extractedCudaJar\n+    \/\/).build();\n+\n+\n+    var backendsDir = dir.existingDir(\"backends\");\n+\n+    var ffiBackendsDir = backendsDir.existingDir(\"ffi\");\n+\n+    var ffiBackendShared = MavenStyleProject.of(ffiBackendsDir.existingDir(\"shared\"),\n+            buildDir.jarFile(\"hat-backend-ffi-shared-1.0.jar\"),\n+            hatCore\n+    ).build();\n+\n+    ffiBackendsDir.subDirs()\n+            .filter(ffiBackend -> ffiBackend.matches(\"^.*(mock|opencl)$\"))\n+            .map(ffiBackend->MavenStyleProject.ffiBackend(buildDir,ffiBackend,hatCore,ffiBackendShared))\n+            .forEach(MavenStyleProject::build);\n+\n+    var jextractedBackends = backendsDir.existingDir(\"jextracted\");\n+    var jextractedBackendShared = MavenStyleProject.jextractedBackend(buildDir,\n+            jextractedBackends.existingDir(\"shared\"),\n+            hatCore\n+    ).build();\n+\n+    var jextractedBackendOpenCL = MavenStyleProject.jextractedBackend(buildDir,\n+            jextractedBackends.dir(\"opencl\"),\n+            buildDir.jarFile(\"hat-backend-jextracted-opencl-1.0.jar\"),\n+            hatCore, extractedOpenCLJar, jextractedBackendShared\n+            ).build();\n+\n+    var javaBackendsDir = backendsDir.existingDir(\"java\");\n+    javaBackendsDir\n+            .subDirs()\n+            .filter(backend -> backend.matches(\"^.*(mt|seq)$\"))\n+            .map(javaBackend->MavenStyleProject.javaBackend(buildDir,javaBackend,hatCore))\n+            .forEach(MavenStyleProject::build);\n+\n+    var examplesDir = dir.existingDir(\"examples\");\n+    examplesDir\n+            .subDirs()\n+            .filter(exampleDir -> exampleDir.failsToMatch(\"^.*(experiments|nbody|target|.idea)$\"))\n+            .map(exampleDir ->  MavenStyleProject.example(buildDir, exampleDir, hatCore))\n+            .forEach(MavenStyleProject::build);\n+\n+    var ffiOpenCLBackendJar = buildDir.jarFile(\"hat-backend-ffi-opencl-1.0.jar\");\n+    examplesDir\n+            .subDirs()\n+            .filter(exampleDir -> exampleDir.matches(\"^.*(nbody)$\"))\n+            .map(exampleDir ->  MavenStyleProject.example(buildDir,exampleDir,\n+                            hatCore,\n+                            wrap,\n+                            clWrap, extractedOpenCLJar,\n+                            ffiOpenCLBackendJar,\n+                            glWrap, extractedOpenGLJar\n+                            )\n+            )\n+            .forEach(MavenStyleProject::build);\n+\n+\n+        var cmakeBuildDir = buildDir.cMakeBuildDir(\"cmake-build-debug\");\n+        if (!cmakeBuildDir.exists()) {\n+            Script.cmake($ -> $\n+                    .verbose(false)\n+                    .source_dir(ffiBackendsDir)\n+                    .build_dir(cmakeBuildDir)\n+                    .copy_to(buildDir)\n+            );\n+        }\n+        Script.cmake($ -> $\n+                .build(cmakeBuildDir)\n+        );\n+\n+\n+}\n+\n","filename":"hat\/hat\/bld.java","additions":339,"deletions":0,"binary":false,"changes":339,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 25 hat\/clean.java\n","filename":"hat\/hat\/clean","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+-agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=y --enable-preview --source 25 hat\/run.java\n","filename":"hat\/hat\/debug","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 25 hat\/extract.java\n","filename":"hat\/hat\/extract","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ *\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import static java.lang.System.out;\n+\n+void main(String[] args) {\n+    var layout = \"\"\"\n+            └──.\/\n+                ├──hat                         All build scripts in each case 'foo' has java options for (and points to) 'foo.java'\n+                │    ├──bld                    --enable-preview --source 25 hat\/bld.java\n+                │    ├──bld.java\n+                │    ├──run                    --enable-preview --source 25 hat\/run.java\n+                │    ├──run.java\n+                │    └──Script                 Contains all the tools for building\n+                │\n+                ├──build\/                            All jars, native libs and executables\n+                │    └──cmake-build-debug\/           All intermediate cmake artifacts\n+                │        ├── hat-*wrap-1.0.jar              Wrapper jars around extracted * (clwrap, glwrap, cuwrap)\n+                │        ├── hat-core-1.0.jar               Base hat jar\n+                │        ├── hat-example-*-1.0.jar          Example jars (hat-example-nbody-1.0.jar, hat-example-life-1.0.jar)\n+                │        ├── hat-jextracted-opencl-1.0.jar  Raw jextracted jars (hat-jextracted-opencl-1.0.jar ....)\n+                │        ├── lib*_backend.[dylib|so]        ffi library backends\n+                │        └── *(no suffix)                   various generated executables (opencl_info, cuda_info, cuda_squares)\n+                ├──stage\/\n+                │   ├── repo\/\n+                │   │   └── *                      Maven artifacts (poms and jars)\n+                │   ├── opencl_jextracted\/         All jextracted files (created using java @hat\/extract\n+                │   │   ├── compile_flags.txt\n+                │   │   └── opencl\n+                │   ├── cuda_jextracted\/\n+                │   │   ├── compile_flags.txt\n+                │   │   └── cuda\n+                │   └── opengl_jextracted\/\n+                │       ├── compile_flags.txt\n+                │       └── opengl\n+                ├──wrap\/\n+                │    └──wrap\/                 All downloaded maven assets\n+                │         ├──wrap\/                (*)\n+                │         ├──clwrap\/              (*)\n+                │         ├──glwrap\/              (*)\n+                │         └──cuwrap\/              (*)\n+                │\n+                ├──hat-core                       Maven style layout\n+                │    ├──src\/main\/java\n+                │    │    └──hat\/\n+                │    │\n+                │    └──src\/main\/test\n+                │         └──hat\/\n+                │\n+                ├──backends\n+                │    ├──java\n+                │    │    ├──mt                    Maven style layout\n+                │    │    └──seq                   Maven style layout\n+                │    ├──jextracted\n+                │    │    └──opencl                Maven style layout\n+                │    └──ffi\n+                │         ├──opencl                Maven style layout with cmake\n+                │         ├──ptx                   Maven style layout with cmake\n+                │         ├──mock                  Maven style layout with cmake\n+                │         ├──spirv                 Maven style layout with cmake\n+                │         ├──cuda                  Maven style layout with cmake\n+                │         └──hip                   Maven style layout with cmake\n+                │\n+                └──examples\n+                     ├──mandel                     Maven style layout\n+                     ├──squares                    Maven style layout\n+                     ├──heal                       Maven style layout\n+                     ├──life                       Maven style layout\n+                     ├──nbody                      Maven style layout\n+                     ├──experiments                Maven style layout\n+                     └──violajones                 Maven style layout\n+            \"\"\";\n+\n+    var dir = Script.DirEntry.current();\n+    var buildDir = Script.BuildDir.of(dir.path(\"build\")).create();\n+\n+    var jextractCapability = Script.Capabilities.JExtract.required();\n+    var cmakeCapability = Script.Capabilities.CMake.required();\n+\n+\n+    var openclCapability = Script.Capabilities.OpenCL.of();\n+    var openglCapability = Script.Capabilities.OpenGL.of();\n+    var cudaCapability = Script.Capabilities.CUDA.of();\n+    var hipCapability = Script.Capabilities.HIP.of();\n+\n+    Script.Capabilities capabilities = Script.Capabilities.of(openclCapability, openglCapability, cudaCapability, hipCapability, jextractCapability, cmakeCapability);\n+\n+    cmakeCapability.probe(buildDir, capabilities);\n+\n+    var stageDir = dir.buildDir(\"stage\").create();\n+\n+    println(capabilities.tickOrCheck());\n+\n+    Stream.of(openglCapability, openclCapability, cudaCapability,hipCapability)\n+            .filter(capability -> {\n+                          out.println(capability.tickOrCheck());\n+                if (!capability.available()) {\n+                    out.println(\"This platform does not have \" + capability.name);\n+                }\n+                return capability.available();\n+            })\n+            .forEach(capability -> {\n+                var extractedDir = stageDir.buildDir(capability.packageName() + \"_jextracted\");\n+                if (!extractedDir.exists()) {\n+                    Script.jextract(jextractCapability.executable, $ -> $.verbose(true).capability(capability, extractedDir));\n+                } else {\n+                    out.println(\"Using previously extracted  \" + extractedDir.fileName());\n+                }\n+                var extractedJar = buildDir.jarFile(\"hat-jextracted-\" + capability.packageName() + \"-1.0.jar\");\n+                Script.jar(jar -> jar\n+                        .jarFile(extractedJar)\n+                        .javac(javac -> javac\n+                                .current_source()\n+                                .source_path(Script.SourceDir.of(extractedDir))\n+                        )\n+                );\n+            });\n+\n+}\n+\n","filename":"hat\/hat\/extract.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 25 hat\/mkpoms.java\n","filename":"hat\/hat\/mkpoms","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ *\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+void main(String[] argv) {\n+   var pomComment = \"\"\"\n+      Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+      DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+      This code is free software; you can redistribute it and\/or modify it\n+      under the terms of the GNU General Public License version 2 only, as\n+      published by the Free Software Foundation.  Oracle designates this\n+      particular file as subject to the \"Classpath\" exception as provided\n+      by Oracle in the LICENSE file that accompanied this code.\n+\n+      This code is distributed in the hope that it will be useful, but WITHOUT\n+      ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+      FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+      version 2 for more details (a copy is included in the LICENSE file that\n+      accompanied this code).\n+\n+      You should have received a copy of the GNU General Public License version\n+      2 along with this work; if not, write to the Free Software Foundation,\n+      Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+      Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+      or visit www.oracle.com if you need additional information or have any\n+      questions.\n+      \"\"\";\n+\n+  var hatDir = Script.DirEntry.current();\n+  var hatCore = hatDir.existingDir(\"hat-core\");\n+  var backends = hatDir.existingDir(\"backends\");\n+  var examples = hatDir.existingDir(\"examples\");\n+  Script.DirEntry extractions = hatDir.existingDir(\"extractions\");\n+  var buildDir = hatDir.existingBuildDir(\"build\");\n+\n+  var opencl = Script.Capabilities.OpenCL.of();\n+  var opengl = Script.Capabilities.OpenGL.of();\n+  var cuda = Script.Capabilities.CUDA.of();\n+  var hip = Script.Capabilities.HIP.of();\n+  var jextract = Script.Capabilities.JExtract.of();\n+  var cmake = Script.Capabilities.CMake.of();\n+\n+  var capabilities = Script.Capabilities.of(opencl, opengl, cuda, hip, jextract, cmake);\n+\n+  if (cmake.available()) {\n+    cmake.probe(buildDir, capabilities);\n+  }\n+  capabilities.capabilities().forEach(fw -> println((fw.available() ? \"we have \" : \"no \") + fw.name));\n+\n+  hatDir.pom(pomComment, pom -> pom\n+      .comment(\"Auto generated by mkpoms\")\n+      .pom(\"oracle.code\", \"hat-root\", \"1.0\")\n+      .properties(properties -> properties\n+          .property(\"project.build.sourceEncoding\", \"UTF-8\")\n+          .property(\"hat.root\", \"${env.PWD}\")\n+          .property(\"hat.build\", \"${hat.root}\/build\")\n+          .property(\"hat.stage\", \"${hat.root}\/stage\")\n+          .property(\"hat.stage.repo\", \"${hat.stage}\/repo\")\n+          .property(\"hat.stage.jextract\", \"${hat.stage}\/jextract\")\n+          .property(\"mac.app.frameworks\", \"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\")\n+          .property(\"mac.lib.frameworks\", \"\/System\/Library\/Frameworks\")\n+      )\n+      .modules(\"hat\", \"extractions\", \"backends\", \"examples\")\n+      .build(build -> build\n+          .plugins(plugins -> plugins\n+              .compilerPlugin(plugin -> plugin\n+                  .configuration(configuration -> configuration\n+                      .compilerArgs(\n+                          \"--add-modules=jdk.incubator.code\",\n+                          \"--enable-preview\",\n+                          \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+                          \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+                      )\n+                      .source(\"25\")\n+                      .target(\"25\")\n+                      .showDeprecation(\"true\")\n+                      .failOnError(\"true\")\n+                      .showWarnings(\"true\")\n+                  )\n+              )\n+          )\n+      )\n+  );\n+\n+  \/\/ Now hat\/pom.xml\n+  hatCore.pom(pomComment, pom -> pom\n+      .comment(\"Auto generated by mkpoms\")\n+      .jar(\"oracle.code\", \"hat\", \"1.0\")\n+      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+      .dependsOn(\"org.junit.jupiter\", \"junit-jupiter-engine\", \"5.10.0\", \"test\")\n+      .build(build -> build\n+          .pluginManagement(pluginManagement -> pluginManagement\n+              .plugins(plugins -> plugins\n+                  .surefirePlugin(plugin -> plugin\n+                      .configuration(configuration -> configuration\n+                          .argLine(\"-enable-preview\")\n+                      )\n+                  )\n+              )\n+          )\n+          .plugins(plugins -> plugins\n+              .antPlugin(plugin -> plugin\n+                  .executions(executions -> executions\n+                      .ant(\"1\", \"install\", \"run\", ant -> ant\n+                          .copy(\"target\/${project.artifactId}-1.0.jar\", \"${hat.build}\")\n+                      )\n+                  )\n+              )\n+          )\n+      )\n+  );\n+\n+  \/\/ Note that we filter by capability here. So we only create poms (and include modules in parent) if capability is available\n+  var extractionDirs = extractions\n+      .subDirs().filter(extraction -> !extraction.matches(\"^.*(target)$\")).filter(dir -> capabilities.capabilityIsAvailable(dir.fileName())).toList();\n+\n+  extractions.pom(pomComment, pom -> pom\n+      .comment(\"Auto generated by mkpoms\")\n+      .pom(\"oracle.code\", \"hat-extractions\", \"1.0\")\n+      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+      .modules(extractionDirs.stream().map(Script.PathHolder::fileName).toList())\n+      .build(build -> build\n+          .plugins(plugins -> plugins\n+              .antPlugin(plugin -> plugin\n+                  .executions(executions -> executions\n+                      .ant(\"createDir\", \"compile\", \"run\", ant -> ant\n+                          .mkdir(\"${hat.stage.jextract}\")\n+                          .echo(\"${hat.stage.jextract}\/compile_flags.txt\", \"-F${mac.app.frameworks}\")\n+                      )\n+                  )\n+              )\n+          )\n+\n+      )\n+  );\n+\n+  extractionDirs.forEach(extraction -> extraction\n+      .pom(pomComment, examplePom -> examplePom\n+          .comment(\"Auto generated by mkpoms\")\n+          .pom(\"oracle.code\", \"hat-extraction-\" + extraction.fileName(), \"1.0\")\n+          .parent(\"oracle.code\", \"hat-extractions\", \"1.0\")\n+          .build(build -> build\n+              .plugins(plugins -> plugins\n+                  .execPlugin(plugin -> plugin\n+                      .executions(execution -> execution\n+                          .execIdPhaseConf(\"2\", \"compile\", configuration -> configuration\n+                              .executable(\"jextract\")\n+                              .workingDirectory(\"${hat.stage.jextract}\")\n+                              .arguments(arguments -> {\n+                                arguments\n+                                    .argument(\"--output\").argument(\"${hat.stage.jextract}\")\n+                                    .argument(\"-t\").argument(extraction.fileName());\n+                                switch (extraction.fileName()) {\n+                                  case \"opencl\" -> arguments\n+                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenCL.framework\/OpenCL\")\n+                                      .argument(\"${mac.app.frameworks}\/OpenCL.framework\/Headers\/opencl.h\");\n+                                  case \"opengl\" -> arguments\n+                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/GLUT.framework\/GLUT\")\n+                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenGL.framework\/OpenGL\")\n+                                      .argument(\"${mac.app.frameworks}\/GLUT.framework\/Headers\/glut.h\");\n+                                  default ->\n+                                      throw new IllegalStateException(\"Unexpected value: \" + extraction.fileName());\n+                                }\n+                              })\n+                          )\n+                      )\n+                  )\n+                  .antPlugin(plugin -> plugin\n+                      .executions(executions -> executions\n+                          .ant(\"1\", \"install\", \"run\", ant -> ant\n+                                   .antjar(\"${hat.stage.jextract}\", extraction.fileName(), \"${hat.build}\/jextracted-\" + extraction.fileName() + \"-1.0.jar\")\n+                               \/\/.copy(\"target\/jextracted\" + extraction.fileName() + \"-1.0.jar\", \"${hat.build}\")\n+                          )\n+                      )\n+                  )\n+              )\n+          )\n+      )\n+  );\n+\n+  var exampleDirs = examples.subDirs().filter(example -> !example.matches(\"^.*(experiments|target|nbody|.idea)$\")).toList();\n+\n+  \/\/ Here we create examples\/pom.xml and nested inside we create each example\/*\/pom.xml\n+  examples.pom(pomComment, examplesPom -> examplesPom\n+      .comment(\"Auto generated by mkpoms\")\n+      .pom(\"oracle.code\", \"hat-examples\", \"1.0\")\n+      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+      .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+      .modules(exampleDirs.stream().map(Script.PathHolder::fileName).toList())\n+  );\n+\n+  exampleDirs.forEach(example -> example\n+      .pom(pomComment, examplePom -> examplePom\n+          .comment(\"Auto generated by mkpoms\")\n+          .jar(\"oracle.code\", \"hat-example-\" + example.fileName(), \"1.0\")\n+          .parent(\"oracle.code\", \"hat-examples\", \"1.0\")\n+          .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+          .build(build -> build\n+              .plugins(plugins -> plugins\n+                  .antPlugin(plugin -> plugin\n+                      .executions(executions -> executions\n+                          .ant(\"1\", \"install\", \"run\", ant -> ant\n+                              .copy(\"target\/hat-example-\" + example.fileName() + \"-1.0.jar\", \"${hat.build}\")\n+                          )\n+                      )\n+                  )\n+              )\n+          )\n+      )\n+  );\n+  var backendDirs = backends.subDirs().filter(backend -> !backend.matches(\"^.*(jextracted|target|.idea)$\")).toList();\n+\n+  \/\/ Now backends\/pom.xml and backends\/*\/pom.xml\n+  backends.pom(pomComment, backendsPom -> backendsPom\n+      .comment(\"Auto generated by mkpoms\")\n+      .pom(\"oracle.code\", \"hat-backends\", \"1.0\")\n+      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+      .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+      .modules(\"java\", \"ffi\")\n+  );\n+\n+  {\n+    var ffiBackend = backends.dir(\"ffi\");\n+\n+\n+    var ffiBackendDirs = ffiBackend.subDirs().filter(backend -> !backend.matches(\"^.*(hip|spirv|shared|openclx|target|.idea)$\")).toList();\n+\n+    ffiBackend.pom(pomComment, backendsPom -> backendsPom\n+        .comment(\"Auto generated by mkpoms\")\n+        .pom(\"oracle.code\", \"hat-backends-ffi\", \"1.0\")\n+        .parent(\"oracle.code\", \"hat-backends\", \"1.0\")\n+        .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+        .modules(ffiBackendDirs.stream().map(Script.PathHolder::fileName).toList())\n+        .build(build -> build\n+            .plugins(plugins -> plugins\n+                .execPlugin(plugin -> plugin\n+                    .executions(executions -> executions\n+                        .cmake(\"1\", \"compile\", \"-DHAT_TARGET=${hat.build}\", \"-B\", \"${hat.build}\/cmake-build-debug\")\n+                        .cmake(\"2\", \"install\", \"--build\", \"${hat.build}\/cmake-build-debug\")\n+                    )\n+                )\n+            )\n+        )\n+    );\n+\n+    ffiBackendDirs.forEach(backend -> backend\n+        .pom(pomComment, backendPom -> backendPom\n+            .comment(\"Auto generated by mkpoms\")\n+            .jar(\"oracle.code\", \"hat-backend-ffi-\" + backend.fileName(), \"1.0\")\n+            .parent(\"oracle.code\", \"hat-backends-ffi\", \"1.0\")\n+            .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+            .build(build -> build\n+                .plugins(plugins -> plugins\n+                    .execPlugin(plugin -> plugin\n+                        .configuration(configuration -> configuration\n+                            .skip(\"true\")\n+                        )\n+                    )\n+                    .antPlugin(plugin -> plugin\n+                        .executions(executions -> executions\n+                            .ant(\"1\", \"install\", \"run\", ant -> ant\n+                                .copy(\"target\/hat-backend-ffi-\" + backend.fileName() + \"-1.0.jar\", \"${hat.build}\")\n+                            )\n+                        )\n+                    )\n+                )\n+            )\n+        )\n+    );\n+  }\n+  {\n+    var javaBackend = backends.dir(\"java\");\n+    var javaBackendDirs = javaBackend.subDirs().filter(backend -> !backend.matches(\"^.*(target|.idea)$\")).toList();\n+\n+    javaBackend.pom(pomComment, backendsPom -> backendsPom\n+        .comment(\"Auto generated by mkpoms\")\n+        .pom(\"oracle.code\", \"hat-backends-java\", \"1.0\")\n+        .parent(\"oracle.code\", \"hat-backends\", \"1.0\")\n+        .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+        .modules(javaBackendDirs.stream().map(Script.PathHolder::fileName).toList())\n+    );\n+\n+    javaBackendDirs.forEach(backend -> backend\n+        .pom(pomComment, backendPom -> backendPom\n+            .comment(\"Auto generated by mkpoms\")\n+            .jar(\"oracle.code\", \"hat-backend-java-\" + backend.fileName(), \"1.0\")\n+            .parent(\"oracle.code\", \"hat-backends-java\", \"1.0\")\n+            .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+            .build(build -> build\n+                .plugins(plugins -> plugins\n+                    .antPlugin(plugin -> plugin\n+                        .executions(executions -> executions\n+                            .ant(\"1\", \"install\", \"run\", ant -> ant\n+                                .copy(\"target\/hat-backend-java-\" + backend.fileName() + \"-1.0.jar\", \"${hat.build}\")\n+                            )\n+                        )\n+                    )\n+                )\n+            )\n+        )\n+    );\n+  }\n+\n+\n+  var backendJExtracted = backends.dir(\"jextracted\");\n+\n+}\n","filename":"hat\/hat\/mkpoms.java","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 25 hat\/run.java\n","filename":"hat\/hat\/run","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 25 hat\/run.java ffi-opencl life\n","filename":"hat\/hat\/run-ffi-opencl-life","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 25 hat\/run.java  java-mt\n","filename":"hat\/hat\/run-java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 25 hat\/run.java ffi-opencl\n","filename":"hat\/hat\/run-opencl","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 25 hat\/sanity.java\n","filename":"hat\/hat\/sanity","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n+<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+--><!--Auto generated by mkpoms-->\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <packaging>pom<\/packaging>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-root<\/artifactId>\n+    <version>1.0<\/version>\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <hat.root>${env.PWD}<\/hat.root>\n+        <hat.build>${hat.root}\/build<\/hat.build>\n+        <hat.stage>${hat.root}\/stage<\/hat.stage>\n+        <hat.stage.repo>${hat.stage}\/repo<\/hat.stage.repo>\n+        <hat.stage.jextract>${hat.stage}\/jextract<\/hat.stage.jextract>\n+        <mac.app.frameworks>\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks<\/mac.app.frameworks>\n+        <mac.lib.frameworks>\/System\/Library\/Frameworks<\/mac.lib.frameworks>\n+    <\/properties>\n+    <modules>\n+        <module>hat-core<\/module>\n+        <module>backends<\/module>\n+        <module>examples<\/module>\n+        <module>extractions<\/module>\n+        <module>wrap<\/module>\n+    <\/modules>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--add-modules=jdk.incubator.code<\/arg>\n+                        <arg>--enable-preview<\/arg>\n+                        <!-- <arg>- -add-exports=java.base\/jdk.internal=ALL-UNNAMED<\/arg> -->\n+                        <!-- <arg>- -add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED<\/arg> -->\n+                    <\/compilerArgs>\n+                    <source>25<\/source>\n+                    <target>25<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                <\/configuration>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"hat\/pom.xml","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+DISABLED_WARNINGS_java += preview\n@@ -34,3 +35,4 @@\n-DOCLINT += -Xdoclint:all\/protected \\\n-    '-Xdoclint\/package:java.*,javax.*'\n-JAVAC_FLAGS += -XDstringConcat=inline\n+# DOCLINT += -Xdoclint:all\/protected \\\n+#     '-Xdoclint\/package:java.*,javax.*'\n+JAVAC_FLAGS += -XDstringConcat=inline \\\n+    --enable-preview\n","filename":"make\/modules\/java.base\/Java.gmk","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,3 @@\n-\n+    final MethodHandle quotableOpGetter;       \/\/ A getter method handle that is used to retrieve the\n+                                              \/\/ the quotable lambda's associated intermediate representation (can be null).\n+    final MethodHandleInfo quotableOpGetterInfo;  \/\/ Info about the quotable getter method handle (can be null).\n@@ -108,0 +110,3 @@\n+     * @param reflectiveField a {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter}\n+     *                   method handle that is used to retrieve the string representation of the\n+     *                   quotable lambda's associated intermediate representation.\n@@ -119,1 +124,2 @@\n-                                        MethodType[] altMethods)\n+                                        MethodType[] altMethods,\n+                                        MethodHandle reflectiveField)\n@@ -180,0 +186,1 @@\n+        this.quotableOpGetter = reflectiveField;\n@@ -206,0 +213,13 @@\n+\n+        if (reflectiveField != null) {\n+            try {\n+                quotableOpGetterInfo = caller.revealDirect(reflectiveField); \/\/ may throw SecurityException\n+            } catch (IllegalArgumentException e) {\n+                throw new LambdaConversionException(implementation + \" is not direct or cannot be cracked\");\n+            }\n+            if (quotableOpGetterInfo.getReferenceKind() != REF_invokeStatic) {\n+                throw new LambdaConversionException(String.format(\"Unsupported MethodHandle kind: %s\", quotableOpGetterInfo));\n+            }\n+        } else {\n+            quotableOpGetterInfo = null;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.util.logging.PlatformLogger;\n@@ -76,1 +77,0 @@\n-        private final TreeSet<String> linkerTypes = new TreeSet<>();\n@@ -91,6 +91,0 @@\n-        HolderClassBuilder addLinkerType(String methodType) {\n-            validateMethodType(methodType);\n-            linkerTypes.add(methodType);\n-            return this;\n-        }\n-\n@@ -122,1 +116,0 @@\n-\n@@ -125,1 +118,0 @@\n-\n@@ -140,17 +132,1 @@\n-            \/\/ The linker type to ask for is retrieved by removing the first\n-            \/\/ and the last argument, which needs to be of Object.class\n-            MethodType[] linkerMethodTypes = new MethodType[linkerTypes.size()];\n-            index = 0;\n-            for (String linkerType : linkerTypes) {\n-                MethodType mt = asMethodType(linkerType);\n-                final int lastParam = mt.parameterCount() - 1;\n-                if (!checkLinkerTypeParams(mt)) {\n-                    throw new RuntimeException(\n-                            \"Linker type parameter must start and end with Object: \" + linkerType);\n-                }\n-                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n-                linkerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n-                index++;\n-            }\n-\n-            \/\/ argument, which needs to be of Object.class\n+            \/\/ and the last argument, which needs to be of Object.class\n@@ -162,0 +138,1 @@\n+                final int lastParam = mt.parameterCount() - 1;\n@@ -164,1 +141,1 @@\n-                            \"Invoker type parameter must start with 2 Objects: \" + invokerType);\n+                            \"Invoker type parameter must start and end with Object: \" + invokerType);\n@@ -166,1 +143,2 @@\n-                invokerMethodTypes[index] = mt.dropParameterTypes(0, 2);\n+                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                invokerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n@@ -185,1 +163,0 @@\n-\n@@ -195,1 +172,1 @@\n-                            linkerMethodTypes, invokerMethodTypes, callSiteMethodTypes));\n+                            invokerMethodTypes, callSiteMethodTypes));\n@@ -203,1 +180,0 @@\n-\n@@ -209,1 +185,0 @@\n-\n@@ -231,6 +206,0 @@\n-            return (mt.parameterCount() >= 2 &&\n-                    mt.parameterType(0) == Object.class &&\n-                    mt.parameterType(1) == Object.class);\n-        }\n-\n-        public static boolean checkLinkerTypeParams(MethodType mt) {\n@@ -350,4 +319,8 @@\n-                                } else if (parts[2].endsWith(\"nvoker\")) {\n-                                    \/\/ MH.exactInvoker exactInvoker MH.invoker invoker\n-                                    builder.addInvokerType(methodType);\n-                                    builder.addLinkerType(methodType);\n+                                    MethodType mt = HolderClassBuilder.asMethodType(methodType);\n+                                    \/\/ Work around JDK-8327499\n+                                    if (HolderClassBuilder.checkInvokerTypeParams(mt)) {\n+                                        builder.addInvokerType(methodType);\n+                                    } else {\n+                                        PlatformLogger.getLogger(\"java.lang.invoke\")\n+                                                .warning(\"Invalid LF_RESOLVE \" + parts[1] + \" \" + parts[2] + \" \" + parts[3]);\n+                                    }\n@@ -495,2 +468,2 @@\n-     * the invoker forms for the set of supplied {@code linkerMethodTypes}\n-     * {@code invokerMethodTypes}, and {@code callSiteMethodTypes}.\n+     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n+     * and {@code callSiteMethodTypes}.\n@@ -499,2 +472,1 @@\n-            MethodType[] linkerMethodTypes, MethodType[] invokerMethodTypes,\n-            MethodType[] callSiteMethodTypes) {\n+            MethodType[] invokerMethodTypes, MethodType[] callSiteMethodTypes) {\n@@ -505,2 +477,2 @@\n-\n-        int[] invokerTypes = {\n+        int[] types = {\n+            MethodTypeForm.LF_EX_LINKER,\n@@ -508,1 +480,2 @@\n-            MethodTypeForm.LF_GEN_INVOKER,\n+            MethodTypeForm.LF_GEN_LINKER,\n+            MethodTypeForm.LF_GEN_INVOKER\n@@ -511,1 +484,1 @@\n-        for (MethodType methodType : invokerMethodTypes) {\n+        for (int i = 0; i < invokerMethodTypes.length; i++) {\n@@ -513,3 +486,3 @@\n-            if (dedupSet.add(methodType)) {\n-                for (int type : invokerTypes) {\n-                    LambdaForm invokerForm = Invokers.invokeHandleForm(methodType,\n+            if (dedupSet.add(invokerMethodTypes[i])) {\n+                for (int type : types) {\n+                    LambdaForm invokerForm = Invokers.invokeHandleForm(invokerMethodTypes[i],\n@@ -523,18 +496,0 @@\n-        int[] linkerTypes = {\n-                MethodTypeForm.LF_EX_LINKER,\n-                MethodTypeForm.LF_GEN_LINKER,\n-        };\n-\n-        dedupSet = new HashSet<>();\n-        for (MethodType methodType : linkerMethodTypes) {\n-            \/\/ generate methods representing linkers of the specified type\n-            if (dedupSet.add(methodType)) {\n-                for (int type : linkerTypes) {\n-                    LambdaForm linkerForm = Invokers.invokeHandleForm(methodType,\n-                            \/*customized*\/false, type);\n-                    forms.add(linkerForm);\n-                    names.add(linkerForm.kind.defaultLambdaName);\n-                }\n-            }\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":26,"deletions":71,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import java.lang.classfile.constantpool.MethodHandleEntry;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n@@ -42,0 +44,3 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleFinder;\n@@ -56,0 +61,1 @@\n+import static java.lang.invoke.MethodType.methodType;\n@@ -72,0 +78,8 @@\n+    \/\/ Static builders to avoid lambdas\n+    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n+        @Override\n+        public void accept(MethodBuilder mb) {\n+            mb.withCode(code);\n+        }\n+    };\n+\n@@ -77,0 +91,3 @@\n+    private static final String NAME_METHOD_QUOTED = \"__internal_quoted\";\n+    private static final String quotedInstanceFieldName = \"quoted\";\n+\n@@ -145,1 +162,2 @@\n-                                       MethodType[] altMethods)\n+                                       MethodType[] altMethods,\n+                                       MethodHandle reflectiveField)\n@@ -149,1 +167,1 @@\n-              isSerializable, altInterfaces, altMethods);\n+              isSerializable, altInterfaces, altMethods, reflectiveField);\n@@ -320,0 +338,5 @@\n+                \/\/ if quotable, generate the field that will hold the value of quoted\n+                if (quotableOpGetter != null) {\n+                    clb.withField(quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted, ACC_PRIVATE + ACC_FINAL);\n+                }\n+\n@@ -346,0 +369,4 @@\n+\n+                if (quotableOpGetter != null) {\n+                    generateQuotedMethod(clb);\n+                }\n@@ -353,1 +380,8 @@\n-            var classdata = useImplMethodHandle? implementation : null;\n+            List<?> classdata;\n+            if (useImplMethodHandle || quotableOpGetter != null) {\n+                classdata = quotableOpGetter == null ?\n+                        List.of(implementation) :\n+                        List.of(implementation, quotableOpGetter, CodeReflectionSupport.HANDLE_MAKE_QUOTED);\n+            } else {\n+                classdata = null;\n+            }\n@@ -402,0 +436,3 @@\n+                        if (quotableOpGetter != null) {\n+                            generateQuotedFieldInitializer(cob);\n+                        }\n@@ -407,0 +444,94 @@\n+    private void generateQuotedFieldInitializer(CodeBuilder cob) {\n+        ConstantPoolBuilder cp = cob.constantPool();\n+        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+        \/\/ push the receiver on the stack for operand of put field instruction\n+        cob.aload(0)\n+        \/\/ load class data: CodeReflectionSupport.HANDLE_MAKE_QUOTED and quotableOpGetter\n+           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH))\n+           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n+        MethodType mtype = quotableOpGetterInfo.getMethodType();\n+        if (quotableOpGetterInfo.getReferenceKind() != MethodHandleInfo.REF_invokeStatic) {\n+            mtype = mtype.insertParameterTypes(0, implClass);\n+        }\n+        \/\/ load arguments to quotableOpGetter: ExtendedOp.FACTORY and CORE_TYPE_FACTORY\n+        cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.EXTENDED_OP_CLASS.describeConstable().get(),\n+                \"FACTORY\", CodeReflectionSupport.OP_FACTORY_CLASS.describeConstable().get());\n+        cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.CORE_TYPE_FACTORY_CLASS.describeConstable().get(),\n+                \"CORE_TYPE_FACTORY\",\n+                CodeReflectionSupport.TYPE_ELEMENT_FACTORY_CLASS.describeConstable().get());\n+        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get());\n+        cob.checkcast(CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get());\n+\n+        \/\/ load captured args in array\n+\n+        int capturedArity = factoryType.parameterCount();\n+        cob.loadConstant(capturedArity)\n+           .anewarray(CD_Object);\n+        \/\/ initialize quoted captures\n+        for (int i = 0; i < capturedArity; i++) {\n+            cob.dup()\n+               .loadConstant(i)\n+               .aload(0)\n+               .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n+            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n+            cob.aastore();\n+        }\n+\n+        \/\/ Create a Quoted from FuncOp and captured args Object[]\n+\n+        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(CodeReflectionSupport.HANDLE_MAKE_QUOTED.type()))\n+           .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted);\n+    }\n+\n+    static class CodeReflectionSupport {\n+        static final Class<?> QUOTED_CLASS;\n+        static final Class<?> QUOTABLE_CLASS;\n+        static final MethodHandle HANDLE_MAKE_QUOTED;\n+        static final Class<?> EXTENDED_OP_CLASS;\n+        static final Class<?> OP_FACTORY_CLASS;\n+        static final Class<?> CORE_TYPE_FACTORY_CLASS;\n+        static final Class<?> TYPE_ELEMENT_FACTORY_CLASS;\n+        static final Class<?> FUNC_OP_CLASS;\n+\n+        static {\n+            try {\n+                ModuleLayer layer = codeLayer();\n+                ClassLoader cl = layer.findLoader(\"jdk.incubator.code\");\n+                QUOTED_CLASS = cl.loadClass(\"jdk.incubator.code.Quoted\");\n+                QUOTABLE_CLASS = cl.loadClass(\"jdk.incubator.code.Quotable\");\n+                Class<?> quotedHelper = cl.loadClass(\"jdk.incubator.code.internal.QuotedHelper\");\n+                FUNC_OP_CLASS = cl.loadClass(\"jdk.incubator.code.op.CoreOp$FuncOp\");\n+                MethodHandle makeQuoted = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n+                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, FUNC_OP_CLASS, Object[].class));\n+                HANDLE_MAKE_QUOTED = makeQuoted.bindTo(Lookup.IMPL_LOOKUP);\n+                EXTENDED_OP_CLASS = cl.loadClass(\"jdk.incubator.code.op.ExtendedOp\");\n+                OP_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.op.OpFactory\");\n+                CORE_TYPE_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.type.CoreTypeFactory\");\n+                TYPE_ELEMENT_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.type.TypeElementFactory\");\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError(ex);\n+            }\n+        }\n+\n+        static ModuleLayer codeLayer() {\n+            final ModuleLayer codeLayer;\n+            if (ModuleLayer.boot().findModule(\"jdk.incubator.code\").isPresent()) {\n+                \/\/ we are in an exploded build, so just use the boot layer\n+                return ModuleLayer.boot();\n+            } else if (java.lang.module.ModuleFinder.ofSystem().find(\"jdk.incubator.code\").isPresent()) {\n+                \/\/ the code module is installed, but not in the boot layer, create a new layer which contains it\n+                ModuleLayer parent = ModuleLayer.boot();\n+                Configuration cf = parent.configuration()\n+                        .resolve(ModuleFinder.of(), ModuleFinder.ofSystem(), Set.of(\"jdk.incubator.code\"));\n+                ClassLoader scl = ClassLoader.getSystemClassLoader();\n+                return parent.defineModulesWithOneLoader(cf, scl);\n+            } else {\n+                throw new IllegalStateException(\"jdk.incubator.code module not found\");\n+            }\n+        }\n+\n+        static final ClassDesc CD_Quoted = QUOTED_CLASS.describeConstable().get();\n+        static final MethodTypeDesc MTD_Quoted = MethodTypeDescImpl.ofValidated(CD_Quoted);\n+    }\n+\n@@ -463,0 +594,14 @@\n+    \/**\n+    * Generate method #quoted()\n+     *\/\n+    private void generateQuotedMethod(ClassBuilder clb) {\n+        clb.withMethod(NAME_METHOD_QUOTED, CodeReflectionSupport.MTD_Quoted, ACC_PUBLIC + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cob) {\n+                cob.aload(0)\n+                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n+                   .areturn();\n+            }\n+        }));\n+    }\n+\n@@ -506,1 +651,1 @@\n-                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA), List.of()),\n+                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA_AT), List.of(cp.intEntry(0))),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":149,"deletions":4,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -270,0 +270,4 @@\n+    \/** Flag for {@link #altMetafactory} indicating the lambda object\n+     * must be a {@code Quotable} object, inspectable using code reflection. *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -352,1 +356,2 @@\n-                                             EMPTY_MT_ARRAY);\n+                                             EMPTY_MT_ARRAY,\n+                                 null);\n@@ -398,0 +403,1 @@\n+     *                          MethodHandle quotableField    \/\/ IF flags has QUOTABLE set\n@@ -421,0 +427,4 @@\n+     *     <li>{@code quotableField} is a\n+     *     {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter} method handle\n+     *     that is used to retrieve the string representation of the quotable lambda's associated\n+     *     intermediate representation.<\/li>\n@@ -435,0 +445,3 @@\n+     * <p>When FLAG_QUOTABLE is set in {@code flags}, the function objects\n+     * will implement {@code Quotable}.\n+     *\n@@ -500,0 +513,2 @@\n+        \/\/ Getter that returns the op of a Quotable instance\n+        MethodHandle quotableOpGetter = null;\n@@ -520,0 +535,5 @@\n+        if ((flags & FLAG_QUOTABLE) != 0) {\n+            quotableOpGetter = extractArg(args, argIndex++, MethodHandle.class);\n+            altInterfaces = Arrays.copyOf(altInterfaces, altInterfaces.length + 1);\n+            altInterfaces[altInterfaces.length-1] = InnerClassLambdaMetafactory.CodeReflectionSupport.QUOTABLE_CLASS;\n+        }\n@@ -544,1 +564,2 @@\n-                                                  altMethods);\n+                                                  altMethods,\n+                                                  quotableOpGetter);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.Optional;\n@@ -50,0 +51,1 @@\n+import java.util.function.Function;\n@@ -99,0 +101,2 @@\n+    private volatile Optional<?>     codeModel;\n+\n@@ -227,0 +231,15 @@\n+    \/* package *\/\n+    Optional<?> setCodeModelIfNeeded(Function<Method, Optional<?>> modelFactory) {\n+        Optional<?> localRef = codeModel;\n+        if (localRef == null) {\n+            synchronized (this) {\n+                localRef = codeModel;\n+                if (localRef == null) {\n+                    Optional<?> op = modelFactory.apply(this);\n+                    codeModel = localRef = op;\n+                }\n+            }\n+        }\n+        return localRef;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -165,1 +165,4 @@\n-        jdk.jshell; \/\/ participates in preview features\n+        jdk.jshell, \/\/ participates in preview features\n+        jdk.incubator.code; \/\/ participates in preview features\n+    exports jdk.internal.classfile.impl to\n+        jdk.incubator.code;\n@@ -178,1 +181,2 @@\n-        jdk.crypto.cryptoki;\n+        jdk.crypto.cryptoki,\n+        jdk.incubator.code;\n@@ -308,1 +312,2 @@\n-        java.desktop;\n+        java.desktop,\n+        jdk.incubator.code;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -274,0 +274,1 @@\n+        REFLECT_METHODS(JDK22, Fragments.FeatureReflectMethods, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.Type.ArrayType;\n@@ -329,0 +330,12 @@\n+    \/** Enter a class into symbol table.\n+     *  @param s The name of the class.\n+     *\/\n+    public Type enterClass(ModuleSymbol moduleSymbol, String s) {\n+        try {\n+            return enterClass(moduleSymbol, names.fromString(s)).type;\n+        } catch (Throwable ex) {\n+            ex.printStackTrace();\n+            return Type.noType;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -206,0 +206,10 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : UPWARDS_NO_INTERSECTION;\n+            }\n@@ -212,0 +222,42 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : DOWNWARDS_NO_INTERSECTION;\n+            }\n+        },\n+        UPWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return DOWNWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? UPWARDS : this;\n+            }\n+        },\n+        DOWNWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return UPWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? DOWNWARDS : this;\n+            }\n@@ -215,0 +267,2 @@\n+        abstract boolean allowIntersectionTypes();\n+        abstract ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes);\n@@ -253,5 +307,12 @@\n-            if (t.isCompound()) {\n-                List<Type> components = directSupertypes(t);\n-                List<Type> components1 = components.map(c -> c.map(this, pkind));\n-                if (components == components1) return t;\n-                else return makeIntersectionType(components1);\n+            if (t.isUnion() || t.isIntersection()) {\n+                if (pkind.allowIntersectionTypes()) {\n+                    List<Type> components = directSupertypes(t);\n+                    List<Type> components1 = components.map(c -> c.map(this, pkind));\n+                    if (components == components1) return t;\n+                    else return makeIntersectionType(components1);\n+                } else if (t.isIntersection()) {\n+                    return visit(((IntersectionClassType)t).getExplicitComponents().head, pkind);\n+                } else {\n+                    Assert.check(t.isUnion());\n+                    return visit(((UnionClassType)t).getLub(), pkind);\n+                }\n@@ -312,0 +373,1 @@\n+                            case UPWARDS_NO_INTERSECTION:\n@@ -315,0 +377,1 @@\n+                            case DOWNWARDS_NO_INTERSECTION:\n@@ -329,1 +392,1 @@\n-                    return pkind == ProjectionKind.UPWARDS ?\n+                    return (pkind == ProjectionKind.UPWARDS || pkind == ProjectionKind.UPWARDS_NO_INTERSECTION) ?\n@@ -338,1 +401,1 @@\n-            return t.containsAny(vars) ?\n+            return (t.containsAny(vars) || (!pkind.allowIntersectionTypes() && !chk.checkDenotable(t))) ?\n@@ -356,1 +419,1 @@\n-                if (pkind == ProjectionKind.DOWNWARDS) {\n+                if (pkind == ProjectionKind.DOWNWARDS || pkind == ProjectionKind.DOWNWARDS_NO_INTERSECTION) {\n@@ -360,1 +423,1 @@\n-                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);\n+                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS.withIntersectionTypes(pkind.allowIntersectionTypes()));\n@@ -370,1 +433,1 @@\n-                } else if (!lower.hasTag(BOT)) {\n+                } else if (!lower.hasTag(BOT) && (!lower.isIntersection() || pkind.allowIntersectionTypes())) {\n@@ -393,2 +456,2 @@\n-                        bound = wt.type.map(TypeProjection.this, pkind.complement());\n-                        if (bound.hasTag(BOT)) {\n+                        bound = wt.type.map(TypeProjection.this, pkind.withIntersectionTypes(true).complement());\n+                        if (bound.hasTag(BOT) || (bound.isIntersection() && !pkind.allowIntersectionTypes())) {\n@@ -422,1 +485,14 @@\n-        return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);\n+        return upward(t, true, vars);\n+    }\n+\n+    \/**\n+     * Computes an upward projection of given type, and vars. See {@link TypeProjection}.\n+     *\n+     * @param t the type to be projected\n+     * @param allowIntersection whether intersection types should be allowed in the projection\n+     * @param vars the set of type variables to be mapped\n+     * @return the type obtained as result of the projection\n+     *\/\n+    public Type upward(Type t, boolean allowIntersection, List<Type> vars) {\n+        return t.map(new TypeProjection(vars),\n+                allowIntersection ? ProjectionKind.UPWARDS : ProjectionKind.UPWARDS_NO_INTERSECTION);\n@@ -5341,0 +5417,24 @@\n+\n+    \/\/ code reflection\n+\n+    \/\/ The predicates below do not use a predefined symbol in Symtab.\n+    \/\/ This is deliberate, as we cannot initialize symbols in modules\n+    \/\/ other than java.base at startup.\n+\n+    public boolean isQuoted(Type type) {\n+        Symbol s = type.tsym;\n+        return s != null &&\n+                s.kind == TYP &&\n+                s.name.equals(names.quoted) &&\n+                s.packge().fullname.equals(names.jdk_incubator_code) &&\n+                s.packge().modle.name.equals(names.jdk_incubator_code);\n+    }\n+\n+    public boolean isQuotable(Type type) {\n+        Symbol s = type.tsym;\n+        return s != null &&\n+                s.kind == TYP &&\n+                s.name.equals(names.quotable) &&\n+                s.packge().fullname.equals(names.jdk_incubator_code) &&\n+                s.packge().modle.name.equals(names.jdk_incubator_code);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":113,"deletions":13,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n@@ -50,0 +52,1 @@\n+import com.sun.tools.javac.comp.Attr.ResultInfo;\n@@ -51,0 +54,1 @@\n+import com.sun.tools.javac.comp.Check.NestedCheckContext;\n@@ -52,0 +56,1 @@\n+import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;\n@@ -65,0 +70,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;\n@@ -447,0 +453,13 @@\n+    public <R> R runWithAttributedMethod(Env<AttrContext> env, JCMethodDecl tree, Function<JCBlock, R> attributedAction) {\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+        try {\n+            JCBlock dupTree = (JCBlock)deferredAttr.attribSpeculative(tree.body, env, statInfo,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n+                    argumentAttr.withLocalCacheContext());\n+            return attributedAction.apply(dupTree);\n+        } finally {\n+            attrRecover.doRecovery();\n+            log.useSource(prevSource);\n+        }\n+    }\n+\n@@ -3164,0 +3183,8 @@\n+        if (types.isQuoted(pt())) {\n+            attribQuotedLambda(that);\n+        } else {\n+            attribFunctionalLambda(that, wrongContext);\n+        }\n+    }\n+\n+    void attribFunctionalLambda(JCLambda that, boolean wrongContext) {\n@@ -3307,0 +3334,93 @@\n+\n+    void attribQuotedLambda(JCLambda that) {\n+        \/\/ create an environment for attribution of the lambda expression\n+        final Env<AttrContext> localEnv = lambdaEnv(that, env);\n+        try {\n+            \/\/ if quoted lambda is implicit, issue error, and recover\n+            if (that.paramKind == ParameterKind.IMPLICIT) {\n+                log.error(that, Errors.QuotedLambdaMustBeExplicit);\n+                \/\/ recovery\n+                List<JCVariableDecl> params = that.params;\n+                while (params.nonEmpty()) {\n+                    Type argType = syms.errType;\n+                    if (params.head.isImplicitlyTyped()) {\n+                        setSyntheticVariableType(params.head, argType);\n+                    }\n+                    params = params.tail;\n+                }\n+            }\n+            \/\/ attribute lambda parameters\n+            attribStats(that.params, localEnv);\n+            List<Type> explicitParamTypes = TreeInfo.types(that.params);\n+\n+            ListBuffer<Type> restypes = new ListBuffer<>();\n+            ListBuffer<DiagnosticPosition> resPositions = new ListBuffer<>();\n+            ResultInfo bodyResultInfo = localEnv.info.returnResult = unknownExprInfo;\n+\n+            \/\/ type-check lambda body, and capture return types\n+            if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {\n+                attribTree(that.getBody(), localEnv, bodyResultInfo);\n+                restypes.add(that.getBody().type);\n+            } else {\n+                JCBlock body = (JCBlock)that.body;\n+                if (body == breakTree &&\n+                        resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n+                    breakTreeFound(copyEnv(localEnv));\n+                }\n+                attribStats(body.stats, localEnv);\n+                new LambdaReturnScanner() {\n+                    @Override\n+                    public void visitReturn(JCReturn tree) {\n+                        if (tree.expr != null) {\n+                            resPositions.add(tree);\n+                        }\n+                        restypes.add(tree.expr == null ? syms.voidType : tree.expr.type);\n+                    }\n+                }.scan(body);\n+            }\n+\n+            \/\/ check if lambda body can complete normally\n+            preFlow(that);\n+            flow.analyzeLambda(localEnv, that, make, false);\n+\n+            final Type restype;\n+            if (that.getBodyKind() == BodyKind.STATEMENT) {\n+                if (that.canCompleteNormally) {\n+                    \/\/ a lambda that completes normally has an implicit void return\n+                    restypes.add(syms.voidType);\n+                }\n+\n+                boolean hasNonVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t != syms.voidType);\n+                boolean hasVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t == syms.voidType);\n+\n+                if (hasVoidReturn && hasNonVoidReturn) {\n+                    \/\/ void vs. non-void mismatch\n+                    log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+                    restype = syms.errorType;\n+                } else if (hasVoidReturn) {\n+                    restype = syms.voidType;\n+                } else {\n+                    restype = condType(resPositions.toList(), restypes.toList());\n+                }\n+            } else {\n+                restype = restypes.first();\n+            }\n+\n+            \/\/ infer lambda return type using lub\n+            if (restype.hasTag(ERROR)) {\n+                \/\/ some other error occurred\n+                log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+            }\n+\n+            \/\/ infer thrown types\n+            List<Type> thrownTypes = flow.analyzeLambdaThrownTypes(localEnv, that, make);\n+\n+            \/\/ set up target descriptor with explicit parameter types, and inferred thrown\/return types\n+            that.target = new MethodType(explicitParamTypes, restype, thrownTypes, syms.methodClass);\n+            result = that.type = pt();\n+        } finally {\n+            localEnv.info.scope.leave();\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -837,1 +837,1 @@\n-                if (!inferenceContext.inferencevars.contains(pt)) {\n+                if (!types.isQuoted(pt) && !inferenceContext.inferencevars.contains(pt)) {\n@@ -1121,1 +1121,1 @@\n-    abstract static class FilterScanner extends com.sun.tools.javac.tree.TreeScanner {\n+    public abstract static class FilterScanner extends com.sun.tools.javac.tree.TreeScanner {\n@@ -1125,1 +1125,1 @@\n-        FilterScanner(final Set<JCTree.Tag> validTags) {\n+        protected FilterScanner(final Set<JCTree.Tag> validTags) {\n@@ -1143,1 +1143,1 @@\n-        void skip(JCTree tree) {}\n+        protected void skip(JCTree tree) {}\n@@ -1229,1 +1229,1 @@\n-            if (!types.isFunctionalInterface(pt)) {\n+            if (types.isQuoted(pt) || !types.isFunctionalInterface(pt)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -166,0 +166,3 @@\n+    \/** Flag for alternate metafactories indicating the lambda object is intended to be quotable *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -835,0 +838,1 @@\n+        boolean isQuotable = isQuotable(tree);\n@@ -836,1 +840,1 @@\n-                isSerializable || bridges.length() > 1;\n+                isSerializable || isQuotable || bridges.length() > 1;\n@@ -851,0 +855,1 @@\n+                        !types.isQuotable(t) &&\n@@ -857,0 +862,1 @@\n+            flags |= isQuotable ? FLAG_QUOTABLE : 0;\n@@ -879,0 +885,4 @@\n+            if (isQuotable) {\n+                MethodSymbol opMethodSym = tree.codeModel;\n+                staticArgs = staticArgs.append(opMethodSym.asHandle());\n+            }\n@@ -945,0 +955,4 @@\n+    boolean isQuotable(JCFunctionalExpression tree) {\n+        return tree.codeModel != null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-    class FreeVarCollector extends CaptureScanner {\n+    public class FreeVarCollector extends CaptureScanner {\n@@ -277,1 +277,1 @@\n-        FreeVarCollector(JCTree ownerTree) {\n+        protected FreeVarCollector(JCTree ownerTree) {\n@@ -281,1 +281,1 @@\n-        void addFreeVars(ClassSymbol c) {\n+        protected void addFreeVars(ClassSymbol c) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1325,1 +1325,1 @@\n-                void skip(JCTree tree) {\n+                protected void skip(JCTree tree) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -685,0 +685,1 @@\n+                slam.codeModel = tree.codeModel;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.module.Configuration;\n@@ -40,0 +41,1 @@\n+import java.util.Optional;\n@@ -42,0 +44,1 @@\n+import java.util.ServiceLoader;\n@@ -88,2 +91,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -382,0 +383,2 @@\n+    private boolean hasCodeReflectionModule;\n+\n@@ -1048,0 +1051,9 @@\n+\n+        if (modules.modulesInitialized()) {\n+            \/\/ This has to happen precisely here. At this point, we have all we need to\n+            \/\/ determine whether jdk.incubator.module is part of the module graph\n+            \/\/ but we have yet to trigger an ENTER event. This gives the code reflection plugin\n+            \/\/ a window to check whether code reflection should be enabled for this compilation unit.\n+            hasCodeReflectionModule = modules.getObservableModule(names.jdk_incubator_code) != null;\n+        }\n+\n@@ -1661,0 +1673,7 @@\n+            if (Feature.REFLECT_METHODS.allowedInSource(source)) {\n+                Optional<CodeReflectionTransformer> reflectMethods = reflectMethods();\n+                if (reflectMethods.isPresent()) {\n+                    env.tree = reflectMethods.get().translateTopLevelClass(context, env.tree, localMake);\n+                }\n+            }\n+\n@@ -1668,1 +1687,2 @@\n-                env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);\n+                env.tree = TransPatterns.instance(context)\n+                        .translateTopLevelClass(env, env.tree, localMake);\n@@ -1716,0 +1736,33 @@\n+    Optional<CodeReflectionTransformer> reflectMethods() {\n+        return CodeReflectionSupport.CODE_LAYER != null ?\n+                ServiceLoader.load(CodeReflectionSupport.CODE_LAYER, CodeReflectionTransformer.class).findFirst() :\n+                Optional.empty();\n+    }\n+\n+    static class CodeReflectionSupport {\n+        static final ModuleLayer CODE_LAYER;\n+\n+        static {\n+            if (ModuleLayer.boot().findModule(\"jdk.incubator.code\").isPresent()) {\n+                \/\/ we are in an exploded build, so just use the boot layer\n+                CODE_LAYER = ModuleLayer.boot();\n+            } else if (java.lang.module.ModuleFinder.ofSystem().find(\"jdk.incubator.code\").isPresent()) {\n+                \/\/ the code module is installed, but not in the boot layer, create a new layer which contains it\n+                ModuleLayer parent = ModuleLayer.boot();\n+                Configuration cf = parent.configuration()\n+                        .resolve(java.lang.module.ModuleFinder.of(), java.lang.module.ModuleFinder.ofSystem(), Set.of(\"jdk.incubator.code\"));\n+                ClassLoader scl = ClassLoader.getSystemClassLoader();\n+                CODE_LAYER = parent.defineModulesWithOneLoader(cf, scl);\n+                Module codeReflectionModule = CODE_LAYER.findModule(\"jdk.incubator.code\").get();\n+                Module jdkCompilerModule = JavaCompiler.class.getModule();\n+                \/\/ We need to add exports all jdk.compiler packages so that the plugin can use them\n+                for (String packageName : jdkCompilerModule.getPackages()) {\n+                    jdkCompilerModule.addExports(packageName, codeReflectionModule);\n+                }\n+            } else {\n+                \/\/ if we run in bootstrap mode, there might be no jdk.incubator.code\n+                CODE_LAYER = null;\n+            }\n+        }\n+    }\n+\n@@ -1871,0 +1924,4 @@\n+    public boolean hasCodeReflectionModule() {\n+        return hasCodeReflectionModule;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":60,"deletions":3,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1403,0 +1403,8 @@\n+# 0: list of type\n+compiler.err.cant.infer.quoted.lambda.return.type=\\\n+    cannot infer return type for quoted lambda expression\\n\\\n+    (found: {0})\n+\n+compiler.err.quoted.lambda.must.be.explicit=\\\n+    Quoted lambda cannot have implicit parameter types\n+\n@@ -4256,0 +4264,25 @@\n+\n+########################################\n+# Diagnostics for code reflection\n+########################################\n+\n+compiler.misc.feature.reflect.methods=\\\n+    code reflection\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.dump=\\\n+    code reflection enabled for method {0}.{1}\\n\\\n+    {2}\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.skip=\\\n+    unsupported code reflection node {2} found in method {0}.{1}\n+\n+# 0: string\n+compiler.note.quoted.ir.dump=\\\n+    code reflection enabled for method quoted lambda\\n\\\n+    {0}\n+\n+# 0: string\n+compiler.note.quoted.ir.skip=\\\n+    unsupported code reflection node {0} found in quoted lambda\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -803,1 +803,2 @@\n-    public abstract static class JCFunctionalExpression extends JCPolyExpression {\n+    public abstract static sealed class JCFunctionalExpression extends JCPolyExpression\n+                                                               permits JCLambda, JCMemberReference {\n@@ -814,0 +815,2 @@\n+        \/** code reflection specific metadata. *\/\n+        public MethodSymbol codeModel;\n@@ -816,1 +819,8 @@\n-            return target != null ? types.findDescriptorType(target) : types.createErrorType(null);\n+            if (target == null) {\n+                return types.createErrorType(null);\n+            } else if (target.hasTag(TypeTag.METHOD)) {\n+                \/\/ this is a quoted expression\n+                return target;\n+            } else {\n+                return types.findDescriptorType(target);\n+            }\n@@ -2008,1 +2018,1 @@\n-    public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n+    public static final class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n@@ -2597,1 +2607,1 @@\n-    public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n+    public static non-sealed class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -231,0 +231,5 @@\n+    \/\/ code reflection\n+    public final Name jdk_incubator_code;\n+    public final Name quoted;\n+    public final Name quotable;\n+\n@@ -415,0 +420,5 @@\n+\n+        \/\/ code reflection\n+        jdk_incubator_code = fromString(\"jdk.incubator.code\");\n+        quoted = fromString(\"Quoted\");\n+        quotable = fromString(\"Quotable\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,3012 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.internal;\n+\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Kinds.Kind;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.ArrayType;\n+import com.sun.tools.javac.code.Type.ClassType;\n+import com.sun.tools.javac.code.Type.MethodType;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.code.Type.WildcardType;\n+import com.sun.tools.javac.code.TypeTag;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.comp.CaptureScanner;\n+import com.sun.tools.javac.comp.DeferredAttr.FilterScanner;\n+import com.sun.tools.javac.comp.Flow;\n+import com.sun.tools.javac.comp.Lower;\n+import com.sun.tools.javac.comp.CodeReflectionTransformer;\n+import com.sun.tools.javac.comp.Resolve;\n+import com.sun.tools.javac.comp.TypeEnvs;\n+import com.sun.tools.javac.jvm.ByteCodes;\n+import com.sun.tools.javac.jvm.Gen;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCAnnotation;\n+import com.sun.tools.javac.tree.JCTree.JCArrayAccess;\n+import com.sun.tools.javac.tree.JCTree.JCAssign;\n+import com.sun.tools.javac.tree.JCTree.JCBinary;\n+import com.sun.tools.javac.tree.JCTree.JCBlock;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression;\n+import com.sun.tools.javac.tree.JCTree.JCIdent;\n+import com.sun.tools.javac.tree.JCTree.JCLambda;\n+import com.sun.tools.javac.tree.JCTree.JCLiteral;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n+import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n+import com.sun.tools.javac.tree.JCTree.JCModuleDecl;\n+import com.sun.tools.javac.tree.JCTree.JCNewArray;\n+import com.sun.tools.javac.tree.JCTree.JCNewClass;\n+import com.sun.tools.javac.tree.JCTree.JCReturn;\n+import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n+import com.sun.tools.javac.tree.JCTree.JCAssert;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.Note;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Log;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+import com.sun.tools.javac.util.Options;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.type.*;\n+import jdk.incubator.code.type.WildcardType.BoundKind;\n+import jdk.incubator.code.writer.OpBuilder;\n+\n+import javax.lang.model.element.Modifier;\n+import javax.tools.JavaFileObject;\n+import java.lang.constant.ClassDesc;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static com.sun.tools.javac.code.Flags.NOOUTERTHIS;\n+import static com.sun.tools.javac.code.Flags.PARAMETER;\n+import static com.sun.tools.javac.code.Flags.PUBLIC;\n+import static com.sun.tools.javac.code.Flags.STATIC;\n+import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.Kinds.Kind.MTH;\n+import static com.sun.tools.javac.code.Kinds.Kind.TYP;\n+import static com.sun.tools.javac.code.Kinds.Kind.VAR;\n+import static com.sun.tools.javac.code.TypeTag.BOT;\n+import static com.sun.tools.javac.code.TypeTag.METHOD;\n+import static com.sun.tools.javac.code.TypeTag.NONE;\n+import static com.sun.tools.javac.main.Option.G_CUSTOM;\n+\n+\/**\n+ * This a tree translator that adds the code model to all method declaration marked\n+ * with the {@code CodeReflection} annotation. The model is expressed using the code\n+ * reflection API (see jdk.internal.java.lang.reflect.code).\n+ *\/\n+public class ReflectMethods extends TreeTranslator {\n+    protected static final Context.Key<ReflectMethods> reflectMethodsKey = new Context.Key<>();\n+\n+    public static ReflectMethods instance(Context context) {\n+        ReflectMethods instance = context.get(reflectMethodsKey);\n+        if (instance == null)\n+            instance = new ReflectMethods(context);\n+        return instance;\n+    }\n+\n+    private final Types types;\n+    private final Names names;\n+    private final Symtab syms;\n+    private final Resolve resolve;\n+    private final Gen gen;\n+    private final Log log;\n+    private final Lower lower;\n+    private final TypeEnvs typeEnvs;\n+    private final Flow flow;\n+    private final CodeReflectionSymbols crSyms;\n+    private final boolean dumpIR;\n+    private final boolean lineDebugInfo;\n+    private final CodeModelStorageOption codeModelStorageOption;\n+\n+    \/\/ @@@ Separate out mutable state\n+    private TreeMaker make;\n+    private ListBuffer<JCTree> classOps;\n+    \/\/ Also used by BodyScanner\n+    private Symbol.ClassSymbol currentClassSym;\n+    private int lambdaCount;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected ReflectMethods(Context context) {\n+        context.put(reflectMethodsKey, this);\n+        Options options = Options.instance(context);\n+        dumpIR = options.isSet(\"dumpIR\");\n+        lineDebugInfo =\n+                options.isUnset(G_CUSTOM) ||\n+                        options.isSet(G_CUSTOM, \"lines\");\n+        codeModelStorageOption = CodeModelStorageOption.parse(options.get(\"codeModelStorageOption\"));\n+        names = Names.instance(context);\n+        syms = Symtab.instance(context);\n+        resolve = Resolve.instance(context);\n+        types = Types.instance(context);\n+        gen = Gen.instance(context);\n+        log = Log.instance(context);\n+        lower = Lower.instance(context);\n+        typeEnvs = TypeEnvs.instance(context);\n+        flow = Flow.instance(context);\n+        crSyms = new CodeReflectionSymbols(context);\n+    }\n+\n+    \/\/ Cannot compute within constructor due to circular dependencies on bootstrap compilation\n+    \/\/ syms.objectType == null\n+    private Map<JavaType, Type> primitiveAndBoxTypeMap;\n+    Map<JavaType, Type> primitiveAndBoxTypeMap() {\n+        Map<JavaType, Type> m = primitiveAndBoxTypeMap;\n+        if (m == null) {\n+            m = primitiveAndBoxTypeMap = Map.ofEntries(\n+                    Map.entry(JavaType.BOOLEAN, syms.booleanType),\n+                    Map.entry(JavaType.BYTE, syms.byteType),\n+                    Map.entry(JavaType.SHORT, syms.shortType),\n+                    Map.entry(JavaType.CHAR, syms.charType),\n+                    Map.entry(JavaType.INT, syms.intType),\n+                    Map.entry(JavaType.LONG, syms.longType),\n+                    Map.entry(JavaType.FLOAT, syms.floatType),\n+                    Map.entry(JavaType.DOUBLE, syms.doubleType),\n+                    Map.entry(JavaType.J_L_OBJECT, syms.objectType),\n+                    Map.entry(JavaType.J_L_BOOLEAN, types.boxedTypeOrType(syms.booleanType)),\n+                    Map.entry(JavaType.J_L_BYTE, types.boxedTypeOrType(syms.byteType)),\n+                    Map.entry(JavaType.J_L_SHORT, types.boxedTypeOrType(syms.shortType)),\n+                    Map.entry(JavaType.J_L_CHARACTER, types.boxedTypeOrType(syms.charType)),\n+                    Map.entry(JavaType.J_L_INTEGER, types.boxedTypeOrType(syms.intType)),\n+                    Map.entry(JavaType.J_L_LONG, types.boxedTypeOrType(syms.longType)),\n+                    Map.entry(JavaType.J_L_FLOAT, types.boxedTypeOrType(syms.floatType)),\n+                    Map.entry(JavaType.J_L_DOUBLE, types.boxedTypeOrType(syms.doubleType))\n+            );\n+        }\n+        return m;\n+    }\n+\n+    @Override\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        if (tree.sym.attribute(crSyms.codeReflectionType.tsym) != null) {\n+            \/\/ if the method is annotated, scan it\n+            BodyScanner bodyScanner = new BodyScanner(tree);\n+            try {\n+                CoreOp.FuncOp funcOp = bodyScanner.scanMethod();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(MethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n+                }\n+                \/\/ create a static method that returns the op\n+                classOps.add(opMethodDecl(methodName(bodyScanner.symbolToErasedMethodRef(tree.sym)), funcOp, codeModelStorageOption));\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the method body were not supported. Log it and move on.\n+                log.note(ex.tree, MethodIrSkip(tree.sym.enclClass(), tree.sym, ex.tree.getTag().toString()));\n+            }\n+        }\n+        super.visitMethodDef(tree);\n+    }\n+\n+    @Override\n+    public void visitModuleDef(JCModuleDecl that) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ListBuffer<JCTree> prevClassOps = classOps;\n+        Symbol.ClassSymbol prevClassSym = currentClassSym;\n+        int prevLambdaCount = lambdaCount;\n+        JavaFileObject prev = log.useSource(tree.sym.sourcefile);\n+        try {\n+            lambdaCount = 0;\n+            currentClassSym = tree.sym;\n+            classOps = new ListBuffer<>();\n+            super.visitClassDef(tree);\n+            tree.defs = tree.defs.prependList(classOps.toList());\n+        } finally {\n+            lambdaCount = prevLambdaCount;\n+            classOps = prevClassOps;\n+            currentClassSym = prevClassSym;\n+            result = tree;\n+            log.useSource(prev);\n+        }\n+    }\n+\n+    @Override\n+    public void visitLambda(JCLambda tree) {\n+        FunctionalExpressionKind kind = functionalKind(tree);\n+        if (kind.isQuoted) {\n+            \/\/ quoted lambda - scan it\n+            BodyScanner bodyScanner = new BodyScanner(tree, kind);\n+            try {\n+                CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(QuotedIrDump(funcOp.toText()));\n+                }\n+                \/\/ create a static method that returns the FuncOp representing the lambda\n+                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n+                classOps.add(opMethod);\n+\n+                switch (kind) {\n+                    case QUOTED_STRUCTURAL -> {\n+                        \/\/ @@@ Consider replacing with invokedynamic to quoted bootstrap method\n+                        \/\/ Thereby we avoid certain dependencies and hide specific details\n+                        JCIdent opMethodId = make.Ident(opMethod.sym);\n+                        ListBuffer<JCExpression> interpreterArgs = new ListBuffer<>();\n+                        \/\/ Obtain MethodHandles.lookup()\n+                        \/\/ @@@ Could probably use MethodHandles.publicLookup()\n+                        JCMethodInvocation lookup = make.App(make.Ident(crSyms.methodHandlesLookup), com.sun.tools.javac.util.List.nil());\n+                        interpreterArgs.append(lookup);\n+                        \/\/ Get the func operation\n+                        JCFieldAccess opFactory = make.Select(make.Ident(crSyms.extendedOpType.tsym),\n+                                crSyms.extendedOpFactorySym);\n+                        JCFieldAccess typeFactory = make.Select(make.Ident(crSyms.coreTypeFactoryType.tsym),\n+                                crSyms.coreTypeFactorySym);\n+                        JCMethodInvocation op = make.App(opMethodId, com.sun.tools.javac.util.List.of(opFactory, typeFactory));\n+                        interpreterArgs.append(op);\n+                        \/\/ Append captured vars\n+                        ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner);\n+                        interpreterArgs.appendList(capturedArgs.toList());\n+\n+                        \/\/ Interpret the func operation to produce the quoted instance\n+                        JCMethodInvocation interpreterInvoke = make.App(make.Ident(crSyms.opInterpreterInvoke), interpreterArgs.toList());\n+                        interpreterInvoke.varargsElement = syms.objectType;\n+                        super.visitLambda(tree);\n+                        result = interpreterInvoke;\n+                    }\n+                    case QUOTABLE -> {\n+                        \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n+                        tree.codeModel = opMethod.sym;\n+                        super.visitLambda(tree);\n+                    }\n+                }\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n+                log.note(ex.tree, QuotedIrSkip(ex.tree.getTag().toString()));\n+                result = tree;\n+            }\n+        } else {\n+            super.visitLambda(tree);\n+        }\n+    }\n+\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        FunctionalExpressionKind kind = functionalKind(tree);\n+        Assert.check(kind != FunctionalExpressionKind.QUOTED_STRUCTURAL,\n+                \"structural quoting not supported for method references\");\n+        MemberReferenceToLambda memberReferenceToLambda = new MemberReferenceToLambda(tree, currentClassSym);\n+        JCVariableDecl recvDecl = memberReferenceToLambda.receiverVar();\n+        JCLambda lambdaTree = memberReferenceToLambda.lambda();\n+\n+        if (kind.isQuoted) {\n+            \/\/ quoted lambda - scan it\n+            BodyScanner bodyScanner = new BodyScanner(lambdaTree, kind);\n+            try {\n+                CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(QuotedIrDump(funcOp.toText()));\n+                }\n+                \/\/ create a method that returns the FuncOp representing the lambda\n+                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n+                classOps.add(opMethod);\n+                tree.codeModel = opMethod.sym;\n+                super.visitReference(tree);\n+                if (recvDecl != null) {\n+                    result = copyReferenceWithReceiverVar(tree, recvDecl);\n+                }\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n+                log.note(ex.tree, QuotedIrSkip(ex.tree.getTag().toString()));\n+                result = tree;\n+            }\n+        } else {\n+            super.visitReference(tree);\n+        }\n+    }\n+\n+    \/\/ @@@: Only used for quoted lambda, not quotable ones. Remove?\n+    ListBuffer<JCExpression> quotedCapturedArgs(DiagnosticPosition pos, BodyScanner bodyScanner) {\n+        ListBuffer<JCExpression> capturedArgs = new ListBuffer<>();\n+        for (Symbol capturedSym : bodyScanner.stack.localToOp.keySet()) {\n+            if (capturedSym.kind == Kind.VAR) {\n+                \/\/ captured var\n+                VarSymbol var = (VarSymbol)capturedSym;\n+                if (var.getConstValue() == null) {\n+                    capturedArgs.add(make.at(pos).Ident(capturedSym));\n+                }\n+            } else {\n+                throw new AssertionError(\"Unexpected captured symbol: \" + capturedSym);\n+            }\n+        }\n+        if (capturedArgs.size() < bodyScanner.top.body.entryBlock().parameters().size()) {\n+            \/\/ needs to capture 'this'\n+            capturedArgs.prepend(make.at(pos).This(currentClassSym.type));\n+        }\n+        return capturedArgs;\n+    }\n+\n+    \/*\n+     * Creates a let expression of the kind:\n+     * let $recv in $recv::memberRef\n+     *\n+     * This is required to make sure that LambdaToMethod doesn't end up emitting the\n+     * code for capturing the bound method reference receiver twice.\n+     *\/\n+    JCExpression copyReferenceWithReceiverVar(JCMemberReference ref, JCVariableDecl recvDecl) {\n+        JCMemberReference newRef = make.at(ref).Reference(ref.mode, ref.name, make.Ident(recvDecl.sym), ref.typeargs);\n+        newRef.type = ref.type;\n+        newRef.target = ref.target;\n+        newRef.refPolyKind = ref.refPolyKind;\n+        newRef.referentType = ref.referentType;\n+        newRef.kind = ref.kind;\n+        newRef.varargsElement = ref.varargsElement;\n+        newRef.ownerAccessible = ref.ownerAccessible;\n+        newRef.sym = ref.sym;\n+        newRef.codeModel = ref.codeModel;\n+        return make.at(ref).LetExpr(recvDecl, newRef).setType(newRef.type);\n+    }\n+\n+    Name lambdaName() {\n+        return names.fromString(\"lambda\").append('$', names.fromString(String.valueOf(lambdaCount++)));\n+    }\n+\n+    Name methodName(MethodRef method) {\n+        char[] sigCh = method.toString().toCharArray();\n+        for (int i = 0; i < sigCh.length; i++) {\n+            switch (sigCh[i]) {\n+                case '.', ';', '[', '\/' -> sigCh[i] = '$';\n+            }\n+        }\n+        return names.fromChars(sigCh, 0, sigCh.length);\n+    }\n+\n+    private enum CodeModelStorageOption {\n+        TEXT, CODE_BUILDER;\n+\n+        public static CodeModelStorageOption parse(String s) {\n+            if (s == null) {\n+                return CodeModelStorageOption.TEXT;\n+            }\n+            return CodeModelStorageOption.valueOf(s);\n+        }\n+    }\n+\n+    private JCMethodDecl opMethodDecl(Name methodName, CoreOp.FuncOp op, CodeModelStorageOption codeModelStorageOption) {\n+        switch (codeModelStorageOption) {\n+            case TEXT -> {\n+                var paramTypes = com.sun.tools.javac.util.List.of(crSyms.opFactoryType, crSyms.typeElementFactoryType);\n+                var mt = new MethodType(paramTypes, crSyms.opType,\n+                        com.sun.tools.javac.util.List.nil(), syms.methodClass);\n+                var ms = new MethodSymbol(PUBLIC | STATIC | SYNTHETIC, methodName, mt, currentClassSym);\n+                currentClassSym.members().enter(ms);\n+                var opFromStr = make.App(make.Ident(crSyms.opParserFromString),\n+                        com.sun.tools.javac.util.List.of(make.Literal(op.toText())));\n+                var ret = make.Return(opFromStr);\n+                var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(ret)));\n+                return md;\n+            }\n+            case CODE_BUILDER -> {\n+                var opBuilder = OpBuilder.createBuilderFunction(op);\n+                var cmToASTTransformer = new CodeModelToAST(make, names, syms, resolve, types, typeEnvs.get(currentClassSym), crSyms);\n+                return cmToASTTransformer.transformFuncOpToAST(opBuilder, methodName);\n+            }\n+            case null, default ->\n+                    throw new IllegalStateException(\"unknown code model storage option: \" + codeModelStorageOption);\n+        }\n+    }\n+\n+    public JCTree translateTopLevelClass(JCTree cdef, TreeMaker make) {\n+        \/\/ note that this method does NOT support recursion.\n+        this.make = make;\n+        JCTree res = translate(cdef);\n+        return res;\n+    }\n+\n+    public CoreOp.FuncOp getMethodBody(Symbol.ClassSymbol classSym, JCMethodDecl methodDecl, JCBlock attributedBody, TreeMaker make) {\n+        \/\/ if the method is annotated, scan it\n+        \/\/ Called from JavacElements::getBody\n+        try {\n+            this.make = make;\n+            currentClassSym = classSym;\n+            BodyScanner bodyScanner = new BodyScanner(methodDecl, attributedBody);\n+            return bodyScanner.scanMethod();\n+        } finally {\n+            currentClassSym = null;\n+            this.make = null;\n+        }\n+    }\n+\n+    static class BodyStack {\n+        final BodyStack parent;\n+\n+        \/\/ Tree associated with body\n+        final JCTree tree;\n+\n+        \/\/ Body to add blocks\n+        final Body.Builder body;\n+        \/\/ Current block to add operations\n+        Block.Builder block;\n+\n+        \/\/ Map of symbols (method arguments and local variables) to varOp values\n+        final Map<Symbol, Value> localToOp;\n+\n+        \/\/ Label\n+        Map.Entry<String, Op.Result> label;\n+\n+        BodyStack(BodyStack parent, JCTree tree, FunctionType bodyType) {\n+            this.parent = parent;\n+\n+            this.tree = tree;\n+\n+            this.body = Body.Builder.of(parent != null ? parent.body : null, bodyType);\n+            this.block = body.entryBlock();\n+\n+            this.localToOp = new LinkedHashMap<>(); \/\/ order is important for captured values\n+        }\n+\n+        public void setLabel(String labelName, Op.Result labelValue) {\n+            if (label != null) {\n+                throw new IllegalStateException(\"Label already defined: \" + labelName);\n+            }\n+            label = Map.entry(labelName, labelValue);\n+        }\n+    }\n+\n+    class BodyScanner extends FilterScanner {\n+        private final JCTree body;\n+        private final Name name;\n+        private final BodyStack top;\n+        private BodyStack stack;\n+        private Op lastOp;\n+        private Value result;\n+        private Type pt = Type.noType;\n+        private final boolean isQuoted;\n+        private Type bodyTarget;\n+        private JCTree currentNode;\n+        private Map<Symbol, List<Symbol>> localCaptures = new HashMap<>();\n+\n+        \/\/ unsupported tree nodes\n+        private static final EnumSet<JCTree.Tag> UNSUPPORTED_TAGS = EnumSet.of(\n+                \/\/ the nodes below are not as relevant, either because they have already\n+                \/\/ been handled by an earlier compiler pass, or because they are typically\n+                \/\/ not handled directly, but in the context of some enclosing statement.\n+\n+                \/\/ modifiers (these are already turned into symbols by Attr and should not be dealt with directly)\n+                Tag.ANNOTATION, Tag.TYPE_ANNOTATION, Tag.MODIFIERS,\n+                \/\/ toplevel (likely outside the scope for code models)\n+                Tag.TOPLEVEL, Tag.PACKAGEDEF, Tag.IMPORT, Tag.METHODDEF,\n+                \/\/ modules (likely outside the scope for code models)\n+                Tag.MODULEDEF, Tag.EXPORTS, Tag.OPENS, Tag.PROVIDES, Tag.REQUIRES, Tag.USES,\n+                \/\/ classes, ignore local class definitions (allows access to but does not model the definition)\n+                \/\/ Tag.CLASSDEF,\n+                \/\/ switch labels (these are handled by the enclosing construct, SWITCH or SWITCH_EXPRESSION)\n+                Tag.CASE, Tag.DEFAULTCASELABEL, Tag.CONSTANTCASELABEL, Tag.PATTERNCASELABEL,\n+                \/\/ patterns (these are handled by the enclosing construct, like IF, SWITCH_EXPRESSION, TYPETEST)\n+                Tag.ANYPATTERN, Tag.BINDINGPATTERN, Tag.RECORDPATTERN,\n+                \/\/ catch (already handled as part of TRY)\n+                Tag.CATCH,\n+                \/\/ types (these are used to parse types and should not be dealt with directly)\n+                Tag.TYPEAPPLY, Tag.TYPEUNION, Tag.TYPEINTERSECTION, Tag.TYPEPARAMETER, Tag.WILDCARD,\n+                Tag.TYPEBOUNDKIND, Tag.ANNOTATED_TYPE,\n+                \/\/ internal (these are synthetic nodes generated by javac)\n+                Tag.NO_TAG, Tag.ERRONEOUS, Tag.NULLCHK, Tag.LETEXPR);\n+\n+        private static final Set<JCTree.Tag> SUPPORTED_TAGS = EnumSet.complementOf(UNSUPPORTED_TAGS);\n+\n+        BodyScanner(JCMethodDecl tree) {\n+            this(tree, tree.body);\n+        }\n+\n+        BodyScanner(JCMethodDecl tree, JCBlock body) {\n+            super(SUPPORTED_TAGS);\n+\n+            this.currentNode = tree;\n+            this.body = body;\n+            this.name = tree.name;\n+            this.isQuoted = false;\n+\n+            List<TypeElement> parameters = new ArrayList<>();\n+            int blockArgOffset = 0;\n+            \/\/ Instance methods model \"this\" as an additional argument occurring\n+            \/\/ before all other arguments.\n+            \/\/ @@@ Inner classes.\n+            \/\/ We need to capture all \"this\", in nested order, as arguments.\n+            if (!tree.getModifiers().getFlags().contains(Modifier.STATIC)) {\n+                parameters.add(typeToTypeElement(tree.sym.owner.type));\n+                blockArgOffset++;\n+            }\n+            tree.sym.type.getParameterTypes().stream().map(this::typeToTypeElement).forEach(parameters::add);\n+\n+            FunctionType bodyType = FunctionType.functionType(\n+                    typeToTypeElement(tree.sym.type.getReturnType()), parameters);\n+\n+            this.stack = this.top = new BodyStack(null, tree.body, bodyType);\n+\n+            \/\/ @@@ this as local variable? (it can never be stored to)\n+            for (int i = 0 ; i < tree.params.size() ; i++) {\n+                Op.Result paramOp = append(CoreOp.var(\n+                        tree.params.get(i).name.toString(),\n+                        top.block.parameters().get(blockArgOffset + i)));\n+                top.localToOp.put(tree.params.get(i).sym, paramOp);\n+            }\n+\n+            bodyTarget = tree.sym.type.getReturnType();\n+        }\n+\n+        BodyScanner(JCLambda tree, FunctionalExpressionKind kind) {\n+            super(SUPPORTED_TAGS);\n+            assert kind != FunctionalExpressionKind.NOT_QUOTED;\n+\n+            this.currentNode = tree;\n+            this.body = tree;\n+            this.name = names.fromString(\"quotedLambda\");\n+            this.isQuoted = true;\n+\n+            QuotableLambdaCaptureScanner lambdaCaptureScanner =\n+                    new QuotableLambdaCaptureScanner(tree);\n+\n+            List<VarSymbol> capturedSymbols = lambdaCaptureScanner.analyzeCaptures();\n+            int blockParamOffset = 0;\n+\n+            ListBuffer<Type> capturedTypes = new ListBuffer<>();\n+            if (lambdaCaptureScanner.capturesThis) {\n+                capturedTypes.add(currentClassSym.type);\n+                blockParamOffset++;\n+            }\n+            for (Symbol s : capturedSymbols) {\n+                capturedTypes.add(s.type);\n+            }\n+\n+            MethodType mtype = new MethodType(capturedTypes.toList(), crSyms.quotedType,\n+                    com.sun.tools.javac.util.List.nil(), syms.methodClass);\n+            FunctionType mtDesc = FunctionType.functionType(typeToTypeElement(mtype.restype),\n+                    mtype.getParameterTypes().map(this::typeToTypeElement));\n+\n+            this.stack = this.top = new BodyStack(null, tree.body, mtDesc);\n+\n+            \/\/ add captured variables mappings\n+            for (int i = 0 ; i < capturedSymbols.size() ; i++) {\n+                Symbol capturedSymbol = capturedSymbols.get(i);\n+                var capturedArg = top.block.parameters().get(blockParamOffset + i);\n+                top.localToOp.put(capturedSymbol,\n+                        append(CoreOp.var(capturedSymbol.name.toString(), capturedArg)));\n+            }\n+\n+            \/\/ add captured constant mappings\n+            for (Map.Entry<Symbol, Object> constantCapture : lambdaCaptureScanner.constantCaptures.entrySet()) {\n+                Symbol capturedSymbol = constantCapture.getKey();\n+                var capturedArg = append(CoreOp.constant(typeToTypeElement(capturedSymbol.type),\n+                        constantCapture.getValue()));\n+                top.localToOp.put(capturedSymbol,\n+                        append(CoreOp.var(capturedSymbol.name.toString(), capturedArg)));\n+            }\n+\n+            bodyTarget = tree.target.getReturnType();\n+        }\n+\n+        \/**\n+         * Compute the set of local variables captured by a quotable lambda expression.\n+         * Inspired from LambdaToMethod's LambdaCaptureScanner.\n+         *\/\n+        class QuotableLambdaCaptureScanner extends CaptureScanner {\n+            boolean capturesThis;\n+            Set<ClassSymbol> seenClasses = new HashSet<>();\n+            Map<Symbol, Object> constantCaptures = new HashMap<>();\n+\n+            QuotableLambdaCaptureScanner(JCLambda ownerTree) {\n+                super(ownerTree);\n+            }\n+\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                seenClasses.add(tree.sym);\n+                super.visitClassDef(tree);\n+            }\n+\n+            @Override\n+            public void visitIdent(JCIdent tree) {\n+                if (!tree.sym.isStatic() &&\n+                        tree.sym.owner.kind == TYP &&\n+                        (tree.sym.kind == VAR || tree.sym.kind == MTH) &&\n+                        !seenClasses.contains(tree.sym.owner)) {\n+                    \/\/ a reference to an enclosing field or method, we need to capture 'this'\n+                    capturesThis = true;\n+                } else if (tree.sym.kind == VAR && ((VarSymbol)tree.sym).getConstValue() != null) {\n+                    \/\/ record the constant value associated with this\n+                    constantCaptures.put(tree.sym, ((VarSymbol)tree.sym).getConstValue());\n+                } else {\n+                    \/\/ might be a local capture\n+                    super.visitIdent(tree);\n+                }\n+            }\n+\n+            @Override\n+            public void visitSelect(JCFieldAccess tree) {\n+                if (tree.sym.kind == VAR &&\n+                        (tree.sym.name == names._this ||\n+                                tree.sym.name == names._super) &&\n+                        !seenClasses.contains(tree.sym.type.tsym)) {\n+                    capturesThis = true;\n+                }\n+                super.visitSelect(tree);\n+            }\n+\n+            @Override\n+            public void visitNewClass(JCNewClass tree) {\n+                if (tree.type.tsym.owner.kind == MTH &&\n+                        !seenClasses.contains(tree.type.tsym)) {\n+                    throw unsupported(tree);\n+                }\n+                super.visitNewClass(tree);\n+            }\n+\n+            @Override\n+            public void visitAnnotation(JCAnnotation tree) {\n+                \/\/ do nothing (annotation values look like captured instance fields)\n+            }\n+        }\n+\n+        @Override\n+        public void scan(JCTree tree) {\n+            JCTree prev = currentNode;\n+            currentNode = tree;\n+            try {\n+                super.scan(tree);\n+            } finally {\n+                currentNode = prev;\n+            }\n+        }\n+\n+        void pushBody(JCTree tree, FunctionType bodyType) {\n+            stack = new BodyStack(stack, tree, bodyType);\n+            lastOp = null; \/\/ reset\n+        }\n+\n+        void popBody() {\n+            stack = stack.parent;\n+        }\n+\n+        Value varOpValue(Symbol sym) {\n+            BodyStack s = stack;\n+            while (s != null) {\n+                Value v = s.localToOp.get(sym);\n+                if (v != null) {\n+                    return v;\n+                }\n+                s = s.parent;\n+            }\n+            throw new NoSuchElementException(sym.toString());\n+        }\n+\n+        Value thisValue() { \/\/ @@@: outer this?\n+            return top.block.parameters().get(0);\n+        }\n+\n+        Value getLabel(String labelName) {\n+            BodyStack s = stack;\n+            while (s != null) {\n+                if (s.label != null && s.label.getKey().equals(labelName)) {\n+                    return s.label.getValue();\n+                }\n+                s = s.parent;\n+            }\n+            throw new NoSuchElementException(labelName);\n+        }\n+\n+        private Op.Result append(Op op) {\n+            return append(op, generateLocation(currentNode, false), stack);\n+        }\n+\n+        private Op.Result append(Op op, Location l) {\n+            return append(op, l, stack);\n+        }\n+\n+        private Op.Result append(Op op, Location l, BodyStack stack) {\n+            lastOp = op;\n+            op.setLocation(l);\n+            return stack.block.apply(op);\n+        }\n+\n+        Location generateLocation(JCTree node, boolean includeSourceReference) {\n+            if (!lineDebugInfo) {\n+                return Location.NO_LOCATION;\n+            }\n+\n+            int pos = node.getStartPosition();\n+            int line = log.currentSource().getLineNumber(pos);\n+            int col = log.currentSource().getColumnNumber(pos, false);\n+            String path;\n+            if (includeSourceReference) {\n+                path = log.currentSource().getFile().toUri().toString();\n+            } else {\n+                path = null;\n+            }\n+            return new Location(path, line, col);\n+        }\n+\n+        private void appendReturnOrUnreachable(JCTree body) {\n+            \/\/ Append only if an existing terminating operation is not present\n+            if (lastOp == null || !(lastOp instanceof Op.Terminating)) {\n+                \/\/ If control can continue after the body append return.\n+                \/\/ Otherwise, append unreachable.\n+                if (isAliveAfter(body)) {\n+                    append(CoreOp._return());\n+                } else {\n+                    append(CoreOp.unreachable());\n+                }\n+            }\n+        }\n+\n+        private boolean isAliveAfter(JCTree node) {\n+            return flow.aliveAfter(typeEnvs.get(currentClassSym), node, make);\n+        }\n+\n+        private <O extends Op & Op.Terminating> void appendTerminating(Supplier<O> sop) {\n+            \/\/ Append only if an existing terminating operation is not present\n+            if (lastOp == null || !(lastOp instanceof Op.Terminating)) {\n+                append(sop.get());\n+            }\n+        }\n+\n+        public Value toValue(JCExpression expression, Type targetType) {\n+            result = null; \/\/ reset\n+            Type prevPt = pt;\n+            try {\n+                pt = targetType;\n+                scan(expression);\n+                return result != null ?\n+                        coerce(result, expression.type, targetType) :\n+                        null;\n+            } finally {\n+                pt = prevPt;\n+            }\n+        }\n+\n+        public Value toValue(JCExpression expression) {\n+            return toValue(expression, Type.noType);\n+        }\n+\n+        public Value toValue(JCTree.JCStatement statement) {\n+            result = null; \/\/ reset\n+            scan(statement);\n+            return result;\n+        }\n+\n+        Value coerce(Value sourceValue, Type sourceType, Type targetType) {\n+            if (sourceType.isReference() && targetType.isReference() &&\n+                    !types.isSubtype(types.erasure(sourceType), types.erasure(targetType))) {\n+                return append(CoreOp.cast(typeToTypeElement(targetType), sourceValue));\n+            } else {\n+                return convert(sourceValue, targetType);\n+            }\n+        }\n+\n+        Value boxIfNeeded(Value exprVal) {\n+            Type source = typeElementToType(exprVal.type());\n+            return source.hasTag(NONE) ?\n+                    exprVal : convert(exprVal, types.boxedTypeOrType(source));\n+        }\n+\n+        Value unboxIfNeeded(Value exprVal) {\n+            Type source = typeElementToType(exprVal.type());\n+            return source.hasTag(NONE) ?\n+                    exprVal : convert(exprVal, types.unboxedTypeOrType(source));\n+        }\n+\n+        Value convert(Value exprVal, Type target) {\n+            Type source = typeElementToType(exprVal.type());\n+            boolean sourcePrimitive = source.isPrimitive();\n+            boolean targetPrimitive = target.isPrimitive();\n+            if (target.hasTag(NONE)) {\n+                return exprVal;\n+            } else if (sourcePrimitive == targetPrimitive) {\n+                if (!sourcePrimitive || types.isSameType(source, target)) {\n+                    return exprVal;\n+                } else {\n+                    \/\/ implicit primitive conversion\n+                    return append(CoreOp.conv(typeToTypeElement(target), exprVal));\n+                }\n+            } else if (sourcePrimitive) {\n+                \/\/ we need to box\n+                Type unboxedTarget = types.unboxedType(target);\n+                if (!unboxedTarget.hasTag(NONE)) {\n+                    \/\/ non-Object target\n+                    if (!types.isConvertible(source, unboxedTarget)) {\n+                        exprVal = convert(exprVal, unboxedTarget);\n+                    }\n+                    return box(exprVal, target);\n+                } else {\n+                    \/\/ Object target\n+                    return box(exprVal, types.boxedClass(source).type);\n+                }\n+            } else {\n+                \/\/ we need to unbox\n+                return unbox(exprVal, source, target, types.unboxedType(source));\n+            }\n+        }\n+\n+        Value box(Value valueExpr, Type box) {\n+            \/\/ Boxing is a static method e.g., java.lang.Integer::valueOf(int)java.lang.Integer\n+            MethodRef boxMethod = MethodRef.method(typeToTypeElement(box), names.valueOf.toString(),\n+                    FunctionType.functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n+            return append(CoreOp.invoke(boxMethod, valueExpr));\n+        }\n+\n+        Value unbox(Value valueExpr, Type box, Type primitive, Type unboxedType) {\n+            if (unboxedType.hasTag(NONE)) {\n+                \/\/ Object target, first downcast to correct wrapper type\n+                unboxedType = primitive;\n+                box = types.boxedClass(unboxedType).type;\n+                valueExpr = append(CoreOp.cast(typeToTypeElement(box), valueExpr));\n+            }\n+            \/\/ Unboxing is a virtual method e.g., java.lang.Integer::intValue()int\n+            MethodRef unboxMethod = MethodRef.method(typeToTypeElement(box),\n+                    unboxedType.tsym.name.append(names.Value).toString(),\n+                    FunctionType.functionType(typeToTypeElement(unboxedType)));\n+            return append(CoreOp.invoke(unboxMethod, valueExpr));\n+        }\n+\n+        @Override\n+        protected void skip(JCTree tree) {\n+            \/\/ this method is called for unsupported AST nodes (see 'SUPPORTED_TAGS')\n+            throw unsupported(tree);\n+        }\n+\n+        @Override\n+        public void visitVarDef(JCVariableDecl tree) {\n+            JavaType javaType = typeToTypeElement(tree.type);\n+            if (tree.init != null) {\n+                Value initOp = toValue(tree.init, tree.type);\n+                result = append(CoreOp.var(tree.name.toString(), javaType, initOp));\n+            } else {\n+                \/\/ Uninitialized\n+                result = append(CoreOp.var(tree.name.toString(), javaType));\n+            }\n+            stack.localToOp.put(tree.sym, result);\n+        }\n+\n+        @Override\n+        public void visitAssign(JCAssign tree) {\n+            \/\/ Consume top node that applies to write access\n+            JCTree lhs = TreeInfo.skipParens(tree.lhs);\n+            Type target = tree.lhs.type;\n+            switch (lhs.getTag()) {\n+                case IDENT: {\n+                    JCIdent assign = (JCIdent) lhs;\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    Symbol sym = assign.sym;\n+                    switch (sym.getKind()) {\n+                        case LOCAL_VARIABLE, PARAMETER -> {\n+                            Value varOp = varOpValue(sym);\n+                            append(CoreOp.varStore(varOp, result));\n+                        }\n+                        case FIELD -> {\n+                            FieldRef fd = symbolToFieldRef(sym, symbolSiteType(sym));\n+                            if (sym.isStatic()) {\n+                                append(CoreOp.fieldStore(fd, result));\n+                            } else {\n+                                append(CoreOp.fieldStore(fd, thisValue(), result));\n+                            }\n+                        }\n+                        default -> {\n+                            \/\/ @@@ Cannot reach here?\n+                            throw unsupported(tree);\n+                        }\n+                    }\n+                    break;\n+                }\n+                case SELECT: {\n+                    JCFieldAccess assign = (JCFieldAccess) lhs;\n+\n+                    Value receiver = toValue(assign.selected);\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    Symbol sym = assign.sym;\n+                    FieldRef fr = symbolToFieldRef(sym, assign.selected.type);\n+                    if (sym.isStatic()) {\n+                        append(CoreOp.fieldStore(fr, result));\n+                    } else {\n+                        append(CoreOp.fieldStore(fr, receiver, result));\n+                    }\n+                    break;\n+                }\n+                case INDEXED: {\n+                    JCArrayAccess assign = (JCArrayAccess) lhs;\n+\n+                    Value array = toValue(assign.indexed);\n+                    Value index = toValue(assign.index);\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    append(CoreOp.arrayStoreOp(array, index, result));\n+                    break;\n+                }\n+                default:\n+                    throw unsupported(tree);\n+            }\n+        }\n+\n+        @Override\n+        public void visitAssignop(JCTree.JCAssignOp tree) {\n+            \/\/ Capture applying rhs and operation\n+            Function<Value, Value> scanRhs = (lhs) -> {\n+                Type unboxedType = types.unboxedTypeOrType(tree.type);\n+                Value rhs;\n+                if (tree.operator.opcode == ByteCodes.string_add && tree.rhs.type.isPrimitive()) {\n+                    rhs = toValue(tree.rhs);\n+                } else {\n+                    rhs = toValue(tree.rhs, unboxedType);\n+                }\n+                lhs = unboxIfNeeded(lhs);\n+\n+                Value assignOpResult = switch (tree.getTag()) {\n+\n+                    \/\/ Arithmetic operations\n+                    case PLUS_ASG -> {\n+                        if (tree.operator.opcode == ByteCodes.string_add) {\n+                            yield append(CoreOp.concat(lhs, rhs));\n+                        } else {\n+                            yield append(CoreOp.add(lhs, rhs));\n+                        }\n+                    }\n+                    case MINUS_ASG -> append(CoreOp.sub(lhs, rhs));\n+                    case MUL_ASG -> append(CoreOp.mul(lhs, rhs));\n+                    case DIV_ASG -> append(CoreOp.div(lhs, rhs));\n+                    case MOD_ASG -> append(CoreOp.mod(lhs, rhs));\n+\n+                    \/\/ Bitwise operations (including their boolean variants)\n+                    case BITOR_ASG -> append(CoreOp.or(lhs, rhs));\n+                    case BITAND_ASG -> append(CoreOp.and(lhs, rhs));\n+                    case BITXOR_ASG -> append(CoreOp.xor(lhs, rhs));\n+\n+                    \/\/ Shift operations\n+                    case SL_ASG -> append(CoreOp.lshl(lhs, rhs));\n+                    case SR_ASG -> append(CoreOp.ashr(lhs, rhs));\n+                    case USR_ASG -> append(CoreOp.lshr(lhs, rhs));\n+\n+\n+                    default -> throw unsupported(tree);\n+                };\n+                return result = convert(assignOpResult, tree.type);\n+            };\n+\n+            applyCompoundAssign(tree.lhs, scanRhs);\n+        }\n+\n+        void applyCompoundAssign(JCTree.JCExpression lhs, Function<Value, Value> scanRhs) {\n+            \/\/ Consume top node that applies to access\n+            lhs = TreeInfo.skipParens(lhs);\n+            switch (lhs.getTag()) {\n+                case IDENT -> {\n+                    JCIdent assign = (JCIdent) lhs;\n+\n+                    Symbol sym = assign.sym;\n+                    switch (sym.getKind()) {\n+                        case LOCAL_VARIABLE, PARAMETER -> {\n+                            Value varOp = varOpValue(sym);\n+\n+                            Op.Result lhsOpValue = append(CoreOp.varLoad(varOp));\n+                            \/\/ Scan the rhs\n+                            Value r = scanRhs.apply(lhsOpValue);\n+\n+                            append(CoreOp.varStore(varOp, r));\n+                        }\n+                        case FIELD -> {\n+                            FieldRef fr = symbolToFieldRef(sym, symbolSiteType(sym));\n+\n+                            Op.Result lhsOpValue;\n+                            TypeElement resultType = typeToTypeElement(sym.type);\n+                            if (sym.isStatic()) {\n+                                lhsOpValue = append(CoreOp.fieldLoad(resultType, fr));\n+                            } else {\n+                                lhsOpValue = append(CoreOp.fieldLoad(resultType, fr, thisValue()));\n+                            }\n+                            \/\/ Scan the rhs\n+                            Value r = scanRhs.apply(lhsOpValue);\n+\n+                            if (sym.isStatic()) {\n+                                append(CoreOp.fieldStore(fr, r));\n+                            } else {\n+                                append(CoreOp.fieldStore(fr, thisValue(), r));\n+                            }\n+                        }\n+                        default -> {\n+                            \/\/ @@@ Cannot reach here?\n+                            throw unsupported(lhs);\n+                        }\n+                    }\n+                }\n+                case SELECT -> {\n+                    JCFieldAccess assign = (JCFieldAccess) lhs;\n+\n+                    Value receiver = toValue(assign.selected);\n+\n+                    Symbol sym = assign.sym;\n+                    FieldRef fr = symbolToFieldRef(sym, assign.selected.type);\n+\n+                    Op.Result lhsOpValue;\n+                    TypeElement resultType = typeToTypeElement(sym.type);\n+                    if (sym.isStatic()) {\n+                        lhsOpValue = append(CoreOp.fieldLoad(resultType, fr));\n+                    } else {\n+                        lhsOpValue = append(CoreOp.fieldLoad(resultType, fr, receiver));\n+                    }\n+                    \/\/ Scan the rhs\n+                    Value r = scanRhs.apply(lhsOpValue);\n+\n+                    if (sym.isStatic()) {\n+                        append(CoreOp.fieldStore(fr, r));\n+                    } else {\n+                        append(CoreOp.fieldStore(fr, receiver, r));\n+                    }\n+                }\n+                case INDEXED -> {\n+                    JCArrayAccess assign = (JCArrayAccess) lhs;\n+\n+                    Value array = toValue(assign.indexed);\n+                    Value index = toValue(assign.index);\n+\n+                    Op.Result lhsOpValue = append(CoreOp.arrayLoadOp(array, index));\n+                    \/\/ Scan the rhs\n+                    Value r = scanRhs.apply(lhsOpValue);\n+\n+                    append(CoreOp.arrayStoreOp(array, index, r));\n+                }\n+                default -> throw unsupported(lhs);\n+            }\n+        }\n+\n+        @Override\n+        public void visitIdent(JCIdent tree) {\n+            \/\/ Visited only for read access\n+\n+            Symbol sym = tree.sym;\n+            switch (sym.getKind()) {\n+                case LOCAL_VARIABLE, RESOURCE_VARIABLE, BINDING_VARIABLE, PARAMETER, EXCEPTION_PARAMETER ->\n+                        result = loadVar(sym);\n+                case FIELD, ENUM_CONSTANT -> {\n+                    if (sym.name.equals(names._this) || sym.name.equals(names._super)) {\n+                        result = thisValue();\n+                    } else {\n+                        FieldRef fr = symbolToFieldRef(sym, symbolSiteType(sym));\n+                        TypeElement resultType = typeToTypeElement(sym.type);\n+                        if (sym.isStatic()) {\n+                            result = append(CoreOp.fieldLoad(resultType, fr));\n+                        } else {\n+                            result = append(CoreOp.fieldLoad(resultType, fr, thisValue()));\n+                        }\n+                    }\n+                }\n+                case INTERFACE, CLASS, ENUM -> {\n+                    result = null;\n+                }\n+                default -> {\n+                    \/\/ @@@ Cannot reach here?\n+                    throw unsupported(tree);\n+                }\n+            }\n+        }\n+\n+        private Value loadVar(Symbol sym) {\n+            Value varOp = varOpValue(sym);\n+            return varOp.type() instanceof VarType ?\n+                    append(CoreOp.varLoad(varOp)) : \/\/ regular var\n+                    varOp;                          \/\/ captured value\n+        }\n+\n+        @Override\n+        public void visitTypeIdent(JCTree.JCPrimitiveTypeTree tree) {\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitTypeArray(JCTree.JCArrayTypeTree tree) {\n+            result = null; \/\/ MyType[].class is handled in visitSelect just as MyType.class\n+        }\n+\n+        @Override\n+        public void visitSelect(JCFieldAccess tree) {\n+            \/\/ Visited only for read access\n+\n+            Type qualifierTarget = qualifierTarget(tree);\n+            \/\/ @@@: might cause redundant load if accessed symbol is static but the qualifier is not a type\n+            Value receiver = toValue(tree.selected);\n+\n+            if (tree.name.equals(names._class)) {\n+                result = append(CoreOp.constant(JavaType.J_L_CLASS, typeToTypeElement(tree.selected.type)));\n+            } else if (types.isArray(tree.selected.type)) {\n+                if (tree.sym.equals(syms.lengthVar)) {\n+                    result = append(CoreOp.arrayLength(receiver));\n+                } else {\n+                    \/\/ Should not reach here\n+                    throw unsupported(tree);\n+                }\n+            } else {\n+                Symbol sym = tree.sym;\n+                switch (sym.getKind()) {\n+                    case FIELD, ENUM_CONSTANT -> {\n+                        if (sym.name.equals(names._this) || sym.name.equals(names._super)) {\n+                            result = thisValue();\n+                        } else {\n+                            FieldRef fr = symbolToFieldRef(sym, qualifierTarget.hasTag(NONE) ?\n+                                    tree.selected.type : qualifierTarget);\n+                            TypeElement resultType = typeToTypeElement(types.memberType(tree.selected.type, sym));\n+                            if (sym.isStatic()) {\n+                                result = append(CoreOp.fieldLoad(resultType, fr));\n+                            } else {\n+                                result = append(CoreOp.fieldLoad(resultType, fr, receiver));\n+                            }\n+                        }\n+                    }\n+                    case INTERFACE, CLASS, ENUM -> {\n+                        result = null;\n+                    }\n+                    default -> {\n+                        \/\/ @@@ Cannot reach here?\n+                        throw unsupported(tree);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void visitIndexed(JCArrayAccess tree) {\n+            \/\/ Visited only for read access\n+\n+            Value array = toValue(tree.indexed);\n+\n+            Value index = toValue(tree.index, typeElementToType(JavaType.INT));\n+\n+            result = append(CoreOp.arrayLoadOp(array, index));\n+        }\n+\n+        @Override\n+        public void visitApply(JCTree.JCMethodInvocation tree) {\n+            \/\/ @@@ Symbol.externalType, for use with inner classes\n+\n+            \/\/ @@@ this.xyz(...) calls in a constructor\n+\n+            JCTree meth = TreeInfo.skipParens(tree.meth);\n+            switch (meth.getTag()) {\n+                case IDENT: {\n+                    JCIdent access = (JCIdent) meth;\n+\n+                    Symbol sym = access.sym;\n+                    List<Value> args = new ArrayList<>();\n+                    CoreOp.InvokeOp.InvokeKind ik;\n+                    if (!sym.isStatic()) {\n+                        ik = CoreOp.InvokeOp.InvokeKind.INSTANCE;\n+                        args.add(thisValue());\n+                    } else {\n+                        ik = CoreOp.InvokeOp.InvokeKind.STATIC;\n+                    }\n+\n+                    args.addAll(scanMethodArguments(tree.args, tree.meth.type, tree.varargsElement));\n+\n+                    MethodRef mr = symbolToErasedMethodRef(sym, symbolSiteType(sym));\n+                    Value res = append(CoreOp.invoke(ik, tree.varargsElement != null,\n+                            typeToTypeElement(meth.type.getReturnType()), mr, args));\n+                    if (sym.type.getReturnType().getTag() != TypeTag.VOID) {\n+                        result = res;\n+                    }\n+                    break;\n+                }\n+                case SELECT: {\n+                    JCFieldAccess access = (JCFieldAccess) meth;\n+\n+                    Type qualifierTarget = qualifierTarget(access);\n+                    Value receiver = toValue(access.selected, qualifierTarget);\n+\n+                    Symbol sym = access.sym;\n+                    List<Value> args = new ArrayList<>();\n+                    CoreOp.InvokeOp.InvokeKind ik;\n+                    if (!sym.isStatic()) {\n+                        args.add(receiver);\n+                        \/\/ @@@ expr.super(...) for inner class super constructor calls\n+                        ik = switch (access.selected) {\n+                            case JCIdent i when i.sym.name.equals(names._super) -> CoreOp.InvokeOp.InvokeKind.SUPER;\n+                            case JCFieldAccess fa when fa.sym.name.equals(names._super) -> CoreOp.InvokeOp.InvokeKind.SUPER;\n+                            default -> CoreOp.InvokeOp.InvokeKind.INSTANCE;\n+                        };\n+                    } else {\n+                        ik = CoreOp.InvokeOp.InvokeKind.STATIC;\n+                    }\n+\n+                    args.addAll(scanMethodArguments(tree.args, tree.meth.type, tree.varargsElement));\n+\n+                    MethodRef mr = symbolToErasedMethodRef(sym, qualifierTarget.hasTag(NONE) ?\n+                            access.selected.type : qualifierTarget);\n+                    JavaType returnType = typeToTypeElement(meth.type.getReturnType());\n+                    CoreOp.InvokeOp iop = CoreOp.invoke(ik, tree.varargsElement != null,\n+                            returnType, mr, args);\n+                    Value res = append(iop);\n+                    if (sym.type.getReturnType().getTag() != TypeTag.VOID) {\n+                        result = res;\n+                    }\n+                    break;\n+                }\n+                default:\n+                    unsupported(meth);\n+            }\n+        }\n+\n+        List<Value> scanMethodArguments(List<JCExpression> args, Type methodType, Type varargsElement) {\n+            ListBuffer<Value> argValues = new ListBuffer<>();\n+            com.sun.tools.javac.util.List<Type> targetTypes = methodType.getParameterTypes();\n+            if (varargsElement != null) {\n+                targetTypes = targetTypes.reverse().tail;\n+                for (int i = 0 ; i < args.size() - (methodType.getParameterTypes().size() - 1) ; i++) {\n+                    targetTypes = targetTypes.prepend(varargsElement);\n+                }\n+                targetTypes = targetTypes.reverse();\n+            }\n+\n+            for (JCTree.JCExpression arg : args) {\n+                argValues.add(toValue(arg, targetTypes.head));\n+                targetTypes = targetTypes.tail;\n+            }\n+            return argValues.toList();\n+        }\n+\n+        @Override\n+        public void visitReference(JCTree.JCMemberReference tree) {\n+            MemberReferenceToLambda memberReferenceToLambda = new MemberReferenceToLambda(tree, currentClassSym);\n+            JCVariableDecl recv = memberReferenceToLambda.receiverVar();\n+            if (recv != null) {\n+                scan(recv);\n+            }\n+            scan(memberReferenceToLambda.lambda());\n+        }\n+\n+        Type qualifierTarget(JCFieldAccess tree) {\n+            Type selectedType = types.skipTypeVars(tree.selected.type, true);\n+            return selectedType.isCompound() ?\n+                    tree.sym.owner.type :\n+                    Type.noType;\n+        }\n+\n+        @Override\n+        public void visitTypeCast(JCTree.JCTypeCast tree) {\n+            Value v = toValue(tree.expr);\n+\n+            Type expressionType = tree.expr.type;\n+            Type type = tree.type;\n+            if (expressionType.isPrimitive() && type.isPrimitive()) {\n+                if (expressionType.equals(type)) {\n+                    \/\/ Redundant cast\n+                    result = v;\n+                } else {\n+                    result = append(CoreOp.conv(typeToTypeElement(type), v));\n+                }\n+            } else if (expressionType.isPrimitive() || type.isPrimitive()) {\n+                result = convert(v, tree.type);\n+            } else if (!expressionType.hasTag(BOT) &&\n+                    types.isAssignable(expressionType, type)) {\n+                \/\/ Redundant cast\n+                result = v;\n+            } else {\n+                \/\/ Reference cast\n+                JavaType jt = typeToTypeElement(types.erasure(type));\n+                result = append(CoreOp.cast(typeToTypeElement(type), jt, v));\n+            }\n+        }\n+\n+        @Override\n+        public void visitTypeTest(JCTree.JCInstanceOf tree) {\n+            Value target = toValue(tree.expr);\n+\n+            if (tree.pattern.getTag() != Tag.IDENT) {\n+                result = scanPattern(tree.getPattern(), target);\n+            } else {\n+                result = append(CoreOp.instanceOf(typeToTypeElement(tree.pattern.type), target));\n+            }\n+        }\n+\n+        Value scanPattern(JCTree.JCPattern pattern, Value target) {\n+            \/\/ Type of pattern\n+            JavaType patternType;\n+            if (pattern instanceof JCTree.JCBindingPattern p) {\n+                patternType = ExtendedOp.Pattern.bindingType(typeToTypeElement(p.type));\n+            } else if (pattern instanceof JCTree.JCRecordPattern p) {\n+                patternType = ExtendedOp.Pattern.recordType(typeToTypeElement(p.record.type));\n+            } else {\n+                throw unsupported(pattern);\n+            }\n+\n+            \/\/ Push pattern body\n+            pushBody(pattern, FunctionType.functionType(patternType));\n+\n+            \/\/ @@@ Assumes just pattern nodes, likely will change when method patterns are supported\n+            \/\/     that have expressions for any arguments (which perhaps in turn may have pattern expressions)\n+            List<JCVariableDecl> variables = new ArrayList<>();\n+            class PatternScanner extends FilterScanner {\n+\n+                private Value result;\n+\n+                public PatternScanner() {\n+                    super(Set.of(Tag.BINDINGPATTERN, Tag.RECORDPATTERN, Tag.ANYPATTERN));\n+                }\n+\n+                @Override\n+                public void visitBindingPattern(JCTree.JCBindingPattern binding) {\n+                    JCVariableDecl var = binding.var;\n+                    variables.add(var);\n+                    boolean unnamedPatternVariable = var.name.isEmpty();\n+                    String bindingName = unnamedPatternVariable ? null : var.name.toString();\n+                    result = append(ExtendedOp.typePattern(typeToTypeElement(var.type), bindingName));\n+                }\n+\n+                @Override\n+                public void visitRecordPattern(JCTree.JCRecordPattern record) {\n+                    \/\/ @@@ Is always Identifier to record?\n+                    \/\/ scan(record.deconstructor);\n+\n+                    List<Value> nestedValues = new ArrayList<>();\n+                    for (JCTree.JCPattern jcPattern : record.nested) {\n+                        \/\/ @@@ when we support ANYPATTERN, we must add result of toValue only if it's non-null\n+                        \/\/ because passing null to recordPattern methods will cause an error\n+                        nestedValues.add(toValue(jcPattern));\n+                    }\n+\n+                    result = append(ExtendedOp.recordPattern(symbolToRecordTypeRef(record.record), nestedValues));\n+                }\n+\n+                @Override\n+                public void visitAnyPattern(JCTree.JCAnyPattern anyPattern) {\n+                    result = append(ExtendedOp.matchAllPattern());\n+                }\n+\n+                Value toValue(JCTree tree) {\n+                    result = null;\n+                    scan(tree);\n+                    return result;\n+                }\n+            }\n+            \/\/ Scan pattern\n+            Value patternValue = new PatternScanner().toValue(pattern);\n+            append(CoreOp._yield(patternValue));\n+            Body.Builder patternBody = stack.body;\n+\n+            \/\/ Pop body\n+            popBody();\n+\n+            \/\/ Find nearest ancestor body stack element associated with a statement tree\n+            \/\/ @@@ Strengthen check of tree?\n+            BodyStack _variablesStack = stack;\n+            while (!(_variablesStack.tree instanceof JCTree.JCStatement)) {\n+                _variablesStack = _variablesStack.parent;\n+            }\n+            BodyStack variablesStack = _variablesStack;\n+\n+            \/\/ Create pattern var ops for pattern variables using the\n+            \/\/ builder associated with the nearest statement tree\n+            for (JCVariableDecl jcVar : variables) {\n+                \/\/ @@@ use uninitialized variable\n+                Value defaultValue = variablesStack.block.op(defaultValue(jcVar.type));\n+                Value init = convert(defaultValue, jcVar.type);\n+                Op.Result op = variablesStack.block.op(CoreOp.var(jcVar.name.toString(), typeToTypeElement(jcVar.type), init));\n+                variablesStack.localToOp.put(jcVar.sym, op);\n+            }\n+\n+            \/\/ Create pattern descriptor\n+            List<JavaType> patternDescParams = variables.stream().map(var -> typeToTypeElement(var.type)).toList();\n+            FunctionType matchFuncType = FunctionType.functionType(JavaType.VOID, patternDescParams);\n+\n+            \/\/ Create the match body, assigning pattern values to pattern variables\n+            Body.Builder matchBody = Body.Builder.of(patternBody.ancestorBody(), matchFuncType);\n+            Block.Builder matchBuilder = matchBody.entryBlock();\n+            for (int i = 0; i < variables.size(); i++) {\n+                Value v = matchBuilder.parameters().get(i);\n+                Value var = variablesStack.localToOp.get(variables.get(i).sym);\n+                matchBuilder.op(CoreOp.varStore(var, v));\n+            }\n+            matchBuilder.op(CoreOp._yield());\n+\n+            \/\/ Create the match operation\n+            return append(ExtendedOp.match(target, patternBody, matchBody));\n+        }\n+\n+        @Override\n+        public void visitNewClass(JCTree.JCNewClass tree) {\n+            if (tree.def != null) {\n+                scan(tree.def);\n+            }\n+\n+            \/\/ @@@ Support local classes in pre-construction contexts\n+            if (tree.type.tsym.isDirectlyOrIndirectlyLocal() && (tree.type.tsym.flags() & NOOUTERTHIS) != 0) {\n+                throw unsupported(tree);\n+            }\n+\n+            List<TypeElement> argtypes = new ArrayList<>();\n+            Type type = tree.type;\n+            Type outer = type.getEnclosingType();\n+            List<Value> args = new ArrayList<>();\n+            if (!outer.hasTag(TypeTag.NONE)) {\n+                \/\/ Obtain outer value for inner class, and add as first argument\n+                JCTree.JCExpression encl = tree.encl;\n+                Value outerInstance;\n+                if (encl == null) {\n+                    outerInstance = thisValue();\n+                } else {\n+                    outerInstance = toValue(tree.encl);\n+                }\n+                args.add(outerInstance);\n+                argtypes.add(outerInstance.type());\n+            }\n+            if (tree.type.tsym.isDirectlyOrIndirectlyLocal()) {\n+                for (Symbol c : localCaptures.get(tree.type.tsym)) {\n+                    args.add(loadVar(c));\n+                    argtypes.add(symbolToErasedDesc(c));\n+                }\n+            }\n+\n+            \/\/ Create erased method type reference for constructor, where\n+            \/\/ the return type declares the class to instantiate\n+            \/\/ @@@ require symbol site type?\n+            MethodRef methodRef = symbolToErasedMethodRef(tree.constructor);\n+            argtypes.addAll(methodRef.type().parameterTypes());\n+            FunctionType constructorType = FunctionType.functionType(\n+                    symbolToErasedDesc(tree.constructor.owner),\n+                    argtypes);\n+\n+            args.addAll(scanMethodArguments(tree.args, tree.constructorType, tree.varargsElement));\n+\n+            result = append(CoreOp._new(typeToTypeElement(type), constructorType, args));\n+        }\n+\n+        @Override\n+        public void visitNewArray(JCTree.JCNewArray tree) {\n+            if (tree.elems != null) {\n+                int length = tree.elems.size();\n+                Op.Result a = append(CoreOp.newArray(\n+                        typeToTypeElement(tree.type),\n+                        append(CoreOp.constant(JavaType.INT, length))));\n+                int i = 0;\n+                for (JCExpression elem : tree.elems) {\n+                    Value element = toValue(elem, types.elemtype(tree.type));\n+                    append(CoreOp.arrayStoreOp(\n+                            a,\n+                            append(CoreOp.constant(JavaType.INT, i)),\n+                            element));\n+                    i++;\n+                }\n+\n+                result = a;\n+            } else {\n+                List<Value> indexes = new ArrayList<>();\n+                for (JCTree.JCExpression dim : tree.dims) {\n+                    indexes.add(toValue(dim));\n+                }\n+\n+                JavaType arrayType = typeToTypeElement(tree.type);\n+                FunctionType constructorType = FunctionType.functionType(arrayType,\n+                        indexes.stream().map(Value::type).toList());\n+                result = append(CoreOp._new(arrayType, constructorType, indexes));\n+            }\n+        }\n+\n+        @Override\n+        public void visitLambda(JCTree.JCLambda tree) {\n+            FunctionalExpressionKind kind = functionalKind(tree);\n+            final FunctionType lambdaType = switch (kind) {\n+                case QUOTED_STRUCTURAL -> typeToFunctionType(tree.target);\n+                default -> typeToFunctionType(types.findDescriptorType(tree.target));\n+            };\n+\n+            \/\/ Push quoted body\n+            \/\/ We can either be explicitly quoted or a structural quoted expression\n+            \/\/ within some larger reflected code\n+            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+                pushBody(tree.body, FunctionType.VOID);\n+            }\n+\n+            \/\/ Push lambda body\n+            pushBody(tree.body, lambdaType);\n+\n+            \/\/ Map lambda parameters to varOp values\n+            for (int i = 0; i < tree.params.size(); i++) {\n+                JCVariableDecl p = tree.params.get(i);\n+                Op.Result paramOp = append(CoreOp.var(\n+                        p.name.toString(),\n+                        stack.block.parameters().get(i)));\n+                stack.localToOp.put(p.sym, paramOp);\n+            }\n+\n+            \/\/ Scan the lambda body\n+            if (tree.getBodyKind() == LambdaExpressionTree.BodyKind.EXPRESSION) {\n+                Value exprVal = toValue(((JCExpression) tree.body), tree.getDescriptorType(types).getReturnType());\n+                if (!tree.body.type.hasTag(TypeTag.VOID)) {\n+                    append(CoreOp._return(exprVal));\n+                } else {\n+                    appendTerminating(CoreOp::_return);\n+                }\n+            } else {\n+                Type prevBodyTarget = bodyTarget;\n+                try {\n+                    bodyTarget = tree.getDescriptorType(types).getReturnType();\n+                    toValue(((JCTree.JCStatement) tree.body));\n+                    appendReturnOrUnreachable(tree.body);\n+                } finally {\n+                    bodyTarget = prevBodyTarget;\n+                }\n+            }\n+\n+            Op lambdaOp = switch (kind) {\n+                case QUOTED_STRUCTURAL -> {\n+                    yield CoreOp.closure(stack.body);\n+                }\n+                case QUOTABLE, NOT_QUOTED -> {\n+                    \/\/ Get the functional interface type\n+                    JavaType fiType = typeToTypeElement(tree.target);\n+                    \/\/ build functional lambda\n+                    yield CoreOp.lambda(fiType, stack.body);\n+                }\n+            };\n+\n+            \/\/ Pop lambda body\n+            popBody();\n+\n+            Value lambdaResult;\n+            if (isQuoted) {\n+                lambdaResult = append(lambdaOp, generateLocation(tree, true));\n+            } else {\n+                lambdaResult = append(lambdaOp);\n+            }\n+\n+            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+                append(CoreOp._yield(lambdaResult));\n+                CoreOp.QuotedOp quotedOp = CoreOp.quoted(stack.body);\n+\n+                \/\/ Pop quoted body\n+                popBody();\n+\n+                lambdaResult = append(quotedOp);\n+            }\n+\n+            result = lambdaResult;\n+        }\n+\n+        @Override\n+        public void visitIf(JCTree.JCIf tree) {\n+            List<Body.Builder> bodies = new ArrayList<>();\n+\n+            while (tree != null) {\n+                JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+                \/\/ Push if condition\n+                pushBody(cond,\n+                        FunctionType.functionType(JavaType.BOOLEAN));\n+                Value last = toValue(cond);\n+                last = convert(last, typeElementToType(JavaType.BOOLEAN));\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(last));\n+                bodies.add(stack.body);\n+\n+                \/\/ Pop if condition\n+                popBody();\n+\n+                \/\/ Push if body\n+                pushBody(tree.thenpart, FunctionType.VOID);\n+\n+                scan(tree.thenpart);\n+                appendTerminating(CoreOp::_yield);\n+                bodies.add(stack.body);\n+\n+                \/\/ Pop if body\n+                popBody();\n+\n+                JCTree.JCStatement elsepart = tree.elsepart;\n+                if (elsepart == null) {\n+                    tree = null;\n+                } else if (elsepart.getTag() == Tag.IF) {\n+                    tree = (JCTree.JCIf) elsepart;\n+                } else {\n+                    \/\/ Push else body\n+                    pushBody(elsepart, FunctionType.VOID);\n+\n+                    scan(elsepart);\n+                    appendTerminating(CoreOp::_yield);\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop else body\n+                    popBody();\n+\n+                    tree = null;\n+                }\n+            }\n+\n+            append(ExtendedOp._if(bodies));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitSwitchExpression(JCTree.JCSwitchExpression tree) {\n+            Value target = toValue(tree.selector);\n+\n+            Type switchType = adaptBottom(tree.type);\n+            FunctionType caseBodyType = FunctionType.functionType(typeToTypeElement(switchType));\n+\n+            List<Body.Builder> bodies = visitSwitchStatAndExpr(tree, tree.selector, target, tree.cases, caseBodyType,\n+                    !tree.hasUnconditionalPattern);\n+\n+            result = append(ExtendedOp.switchExpression(caseBodyType.returnType(), target, bodies));\n+        }\n+\n+        @Override\n+        public void visitSwitch(JCTree.JCSwitch tree) {\n+            Value target = toValue(tree.selector);\n+\n+            FunctionType actionType = FunctionType.VOID;\n+\n+            List<Body.Builder> bodies = visitSwitchStatAndExpr(tree, tree.selector, target, tree.cases, actionType,\n+                    tree.patternSwitch && !tree.hasUnconditionalPattern);\n+\n+            result = append(ExtendedOp.switchStatement(target, bodies));\n+        }\n+\n+        private List<Body.Builder> visitSwitchStatAndExpr(JCTree tree, JCExpression selector, Value target,\n+                                                          List<JCTree.JCCase> cases, FunctionType caseBodyType,\n+                                                          boolean isDefaultCaseNeeded) {\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            Body.Builder defaultLabel = null;\n+            Body.Builder defaultBody = null;\n+\n+            for (JCTree.JCCase c : cases) {\n+                Body.Builder caseLabel = visitCaseLabel(tree, selector, target, c);\n+                Body.Builder caseBody = visitCaseBody(tree, c, caseBodyType);\n+\n+                if (c.labels.head instanceof JCTree.JCDefaultCaseLabel) {\n+                    defaultLabel = caseLabel;\n+                    defaultBody = caseBody;\n+                } else {\n+                    bodies.add(caseLabel);\n+                    bodies.add(caseBody);\n+                }\n+            }\n+\n+            if (defaultLabel != null) {\n+                bodies.add(defaultLabel);\n+                bodies.add(defaultBody);\n+            } else if (isDefaultCaseNeeded) {\n+                \/\/ label\n+                pushBody(tree, FunctionType.functionType(JavaType.BOOLEAN));\n+                append(CoreOp._yield(append(CoreOp.constant(JavaType.BOOLEAN, true))));\n+                bodies.add(stack.body);\n+                popBody();\n+\n+                \/\/ body\n+                pushBody(tree, caseBodyType);\n+                append(CoreOp._throw(\n+                        append(CoreOp._new(FunctionType.functionType(JavaType.type(MatchException.class))))\n+                ));\n+                bodies.add(stack.body);\n+                popBody();\n+            }\n+\n+            return bodies;\n+        }\n+\n+        private Body.Builder visitCaseLabel(JCTree tree, JCExpression selector, Value target, JCTree.JCCase c) {\n+            Body.Builder body;\n+            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n+\n+            JCTree.JCCaseLabel headCl = c.labels.head;\n+            if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                if (c.labels.size() > 1) {\n+                    throw unsupported(c);\n+                }\n+\n+                pushBody(pcl, caseLabelType);\n+\n+                Value localTarget = stack.block.parameters().get(0);\n+                final Value localResult;\n+                if (c.guard != null) {\n+                    List<Body.Builder> clBodies = new ArrayList<>();\n+\n+                    pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                    Value patVal = scanPattern(pcl.pat, localTarget);\n+                    append(CoreOp._yield(patVal));\n+                    clBodies.add(stack.body);\n+                    popBody();\n+\n+                    pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                    append(CoreOp._yield(toValue(c.guard)));\n+                    clBodies.add(stack.body);\n+                    popBody();\n+\n+                    localResult = append(ExtendedOp.conditionalAnd(clBodies));\n+                } else {\n+                    localResult = scanPattern(pcl.pat, localTarget);\n+                }\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(localResult));\n+                body = stack.body;\n+\n+                \/\/ Pop label\n+                popBody();\n+            } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                pushBody(headCl, caseLabelType);\n+\n+                Value localTarget = stack.block.parameters().get(0);\n+                final Value localResult;\n+                if (c.labels.size() == 1) {\n+                    Value expr = toValue(ccl.expr);\n+                    \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                    \/\/ so, we convert constant to the type of the selector expression\n+                    expr = convert(expr, selector.type);\n+                    if (selector.type.isPrimitive()) {\n+                        localResult = append(CoreOp.eq(localTarget, expr));\n+                    } else {\n+                        localResult = append(CoreOp.invoke(\n+                                MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                localTarget, expr));\n+                    }\n+                } else {\n+                    List<Body.Builder> clBodies = new ArrayList<>();\n+                    for (JCTree.JCCaseLabel cl : c.labels) {\n+                        ccl = (JCTree.JCConstantCaseLabel) cl;\n+                        pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n+\n+                        Value expr = toValue(ccl.expr);\n+                        expr = convert(expr, selector.type);\n+                        final Value labelResult;\n+                        if (selector.type.isPrimitive()) {\n+                            labelResult = append(CoreOp.eq(localTarget, expr));\n+                        } else {\n+                            labelResult = append(CoreOp.invoke(\n+                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                    localTarget, expr));\n+                        }\n+\n+                        append(CoreOp._yield(labelResult));\n+                        clBodies.add(stack.body);\n+\n+                        \/\/ Pop label\n+                        popBody();\n+                    }\n+\n+                    localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                }\n+\n+                append(CoreOp._yield(localResult));\n+                body = stack.body;\n+\n+                \/\/ Pop labels\n+                popBody();\n+            } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                \/\/ @@@ Do we need to model the default label body?\n+                pushBody(headCl, FunctionType.functionType(JavaType.BOOLEAN));\n+\n+                append(CoreOp._yield(append(CoreOp.constant(JavaType.BOOLEAN, true))));\n+                body = stack.body;\n+\n+                \/\/ Pop label\n+                popBody();\n+            } else {\n+                throw unsupported(tree);\n+            }\n+\n+            return body;\n+        }\n+\n+        private Body.Builder visitCaseBody(JCTree tree, JCTree.JCCase c, FunctionType caseBodyType) {\n+            Body.Builder body = null;\n+            Type yieldType = tree.type != null ? adaptBottom(tree.type) : null;\n+\n+            JCTree.JCCaseLabel headCl = c.labels.head;\n+            switch (c.caseKind) {\n+                case RULE -> {\n+                    pushBody(c.body, caseBodyType);\n+\n+                    if (c.body instanceof JCTree.JCExpression e) {\n+                        Value bodyVal = toValue(e, yieldType);\n+                        append(CoreOp._yield(bodyVal));\n+                    } else if (c.body instanceof JCTree.JCStatement s){ \/\/ this includes Block\n+                        \/\/ Otherwise there is a yield statement\n+                        Type prevBodyTarget = bodyTarget;\n+                        try {\n+                            bodyTarget = yieldType;\n+                            toValue(s);\n+                        } finally {\n+                            bodyTarget = prevBodyTarget;\n+                        }\n+                        appendTerminating(c.completesNormally ? CoreOp::_yield : CoreOp::unreachable);\n+                    }\n+                    body = stack.body;\n+\n+                    \/\/ Pop block\n+                    popBody();\n+                }\n+                case STATEMENT -> {\n+                    \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                    \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                    pushBody(c, caseBodyType);\n+\n+                    scan(c.stats);\n+\n+                    appendTerminating(c.completesNormally ?\n+                            headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n+                            : CoreOp::unreachable);\n+\n+                    body = stack.body;\n+\n+                    \/\/ Pop block\n+                    popBody();\n+                }\n+            }\n+            return body;\n+        }\n+\n+        @Override\n+        public void visitYield(JCTree.JCYield tree) {\n+            Value retVal = toValue(tree.value, bodyTarget);\n+            if (retVal == null) {\n+                result = append(ExtendedOp.java_yield());\n+            } else {\n+                result = append(ExtendedOp.java_yield(retVal));\n+            }\n+        }\n+\n+        @Override\n+        public void visitWhileLoop(JCTree.JCWhileLoop tree) {\n+            \/\/ @@@ Patterns\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push while condition\n+            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            Value last = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            last = convert(last, typeElementToType(JavaType.BOOLEAN));\n+            append(CoreOp._yield(last));\n+            Body.Builder condition = stack.body;\n+\n+            \/\/ Pop while condition\n+            popBody();\n+\n+            \/\/ Push while body\n+            pushBody(tree.body, FunctionType.VOID);\n+            scan(tree.body);\n+            appendTerminating(ExtendedOp::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop while body\n+            popBody();\n+\n+            append(ExtendedOp._while(condition, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitDoLoop(JCTree.JCDoWhileLoop tree) {\n+            \/\/ @@@ Patterns\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push while body\n+            pushBody(tree.body, FunctionType.VOID);\n+            scan(tree.body);\n+            appendTerminating(ExtendedOp::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop while body\n+            popBody();\n+\n+            \/\/ Push while condition\n+            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            Value last = toValue(cond);\n+            last = convert(last, typeElementToType(JavaType.BOOLEAN));\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOp._yield(last));\n+            Body.Builder condition = stack.body;\n+\n+            \/\/ Pop while condition\n+            popBody();\n+\n+            append(ExtendedOp.doWhile(body, condition));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {\n+            \/\/ Push expression\n+            pushBody(tree.expr, FunctionType.functionType(typeToTypeElement(tree.expr.type)));\n+            Value last = toValue(tree.expr);\n+            \/\/ Yield the Iterable result of the expression\n+            append(CoreOp._yield(last));\n+            Body.Builder expression = stack.body;\n+\n+            \/\/ Pop expression\n+            popBody();\n+\n+            JCVariableDecl var = tree.getVariable();\n+            JavaType eType = typeToTypeElement(var.type);\n+            VarType varEType = VarType.varType(typeToTypeElement(var.type));\n+\n+            \/\/ Push init\n+            \/\/ @@@ When lhs assignment is a pattern we embed the pattern match into the init body and\n+            \/\/ return the bound variables\n+            pushBody(var, FunctionType.functionType(varEType, eType));\n+            Op.Result varEResult = append(CoreOp.var(var.name.toString(), stack.block.parameters().get(0)));\n+            append(CoreOp._yield(varEResult));\n+            Body.Builder init = stack.body;\n+            \/\/ Pop init\n+            popBody();\n+\n+            \/\/ Push body\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varEType));\n+            stack.localToOp.put(var.sym, stack.block.parameters().get(0));\n+\n+            scan(tree.body);\n+            appendTerminating(ExtendedOp::_continue);\n+            Body.Builder body = stack.body;\n+            \/\/ Pop body\n+            popBody();\n+\n+            append(ExtendedOp.enhancedFor(expression, init, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitForLoop(JCTree.JCForLoop tree) {\n+            class VarDefScanner extends FilterScanner {\n+                final List<JCVariableDecl> decls;\n+\n+                public VarDefScanner() {\n+                    super(Set.of(Tag.VARDEF));\n+                    this.decls = new ArrayList<>();\n+                }\n+\n+                @Override\n+                public void visitVarDef(JCVariableDecl tree) {\n+                    decls.add(tree);\n+                }\n+\n+                void mapVarsToBlockArguments() {\n+                    for (int i = 0; i < decls.size(); i++) {\n+                        stack.localToOp.put(decls.get(i).sym, stack.block.parameters().get(i));\n+                    }\n+                }\n+\n+                List<VarType> varTypes() {\n+                    return decls.stream()\n+                            .map(t -> VarType.varType(typeToTypeElement(t.type)))\n+                            .toList();\n+                }\n+\n+                List<Value> varValues() {\n+                    return decls.stream()\n+                            .map(t -> stack.localToOp.get(t.sym))\n+                            .toList();\n+                }\n+            }\n+\n+            \/\/ Scan local variable declarations\n+            VarDefScanner vds = new VarDefScanner();\n+            vds.scan(tree.init);\n+            List<VarType> varTypes = vds.varTypes();\n+\n+            \/\/ Push init\n+            if (varTypes.size() > 1) {\n+                pushBody(null, FunctionType.functionType(TupleType.tupleType(varTypes)));\n+                scan(tree.init);\n+\n+                \/\/ Capture all local variable declarations in tuple\n+                append(CoreOp._yield(append(CoreOp.tuple(vds.varValues()))));\n+            } else if (varTypes.size() == 1) {\n+                pushBody(null, FunctionType.functionType(varTypes.get(0)));\n+                scan(tree.init);\n+\n+                append(CoreOp._yield(vds.varValues().get(0)));\n+            } else {\n+                pushBody(null, FunctionType.VOID);\n+                scan(tree.init);\n+\n+                append(CoreOp._yield());\n+            }\n+            Body.Builder init = stack.body;\n+\n+            \/\/ Pop init\n+            popBody();\n+\n+            \/\/ Push cond\n+            pushBody(tree.cond, FunctionType.functionType(JavaType.BOOLEAN, varTypes));\n+            if (tree.cond != null) {\n+                vds.mapVarsToBlockArguments();\n+\n+                Value last = toValue(tree.cond);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(last));\n+            } else {\n+                append(CoreOp._yield(append(CoreOp.constant(JavaType.BOOLEAN, true))));\n+            }\n+            Body.Builder cond = stack.body;\n+\n+            \/\/ Pop cond\n+            popBody();\n+\n+            \/\/ Push update\n+            \/\/ @@@ tree.step is a List<JCStatement>\n+            pushBody(null, FunctionType.functionType(JavaType.VOID, varTypes));\n+            if (!tree.step.isEmpty()) {\n+                vds.mapVarsToBlockArguments();\n+\n+                scan(tree.step);\n+            }\n+            append(CoreOp._yield());\n+            Body.Builder update = stack.body;\n+\n+            \/\/ Pop update\n+            popBody();\n+\n+            \/\/ Push body\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varTypes));\n+            if (tree.body != null) {\n+                vds.mapVarsToBlockArguments();\n+\n+                scan(tree.body);\n+            }\n+            appendTerminating(ExtendedOp::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop update\n+            popBody();\n+\n+            append(ExtendedOp._for(init, cond, update, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitConditional(JCTree.JCConditional tree) {\n+            List<Body.Builder> bodies = new ArrayList<>();\n+\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push condition\n+            pushBody(cond,\n+                    FunctionType.functionType(JavaType.BOOLEAN));\n+            Value condVal = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOp._yield(condVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop condition\n+            popBody();\n+\n+            JCTree.JCExpression truepart = TreeInfo.skipParens(tree.truepart);\n+\n+            Type condType = adaptBottom(tree.type);\n+\n+            \/\/ Push true body\n+            pushBody(truepart,\n+                    FunctionType.functionType(typeToTypeElement(condType)));\n+\n+            Value trueVal = toValue(truepart, condType);\n+            \/\/ Yield the result\n+            append(CoreOp._yield(trueVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop true body\n+            popBody();\n+\n+            JCTree.JCExpression falsepart = TreeInfo.skipParens(tree.falsepart);\n+\n+            \/\/ Push false body\n+            pushBody(falsepart,\n+                    FunctionType.functionType(typeToTypeElement(condType)));\n+\n+            Value falseVal = toValue(falsepart, condType);\n+            \/\/ Yield the result\n+            append(CoreOp._yield(falseVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop false body\n+            popBody();\n+\n+            result = append(ExtendedOp.conditionalExpression(typeToTypeElement(condType), bodies));\n+        }\n+\n+        private Type condType(JCExpression tree, Type type) {\n+            if (type.hasTag(BOT)) {\n+                return adaptBottom(tree.type);\n+            } else {\n+                return type;\n+            }\n+        }\n+\n+        private Type adaptBottom(Type type) {\n+            return type.hasTag(BOT) ?\n+                    (pt.hasTag(NONE) ? syms.objectType : pt) :\n+                    type;\n+        }\n+\n+        @Override\n+        public void visitAssert(JCAssert tree) {\n+            \/\/ assert <cond:body1> [detail:body2]\n+\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push condition\n+            pushBody(cond,\n+                    FunctionType.functionType(JavaType.BOOLEAN));\n+            Value condVal = toValue(cond);\n+\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOp._yield(condVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop condition\n+            popBody();\n+\n+            if (tree.detail != null) {\n+                JCTree.JCExpression detail = TreeInfo.skipParens(tree.detail);\n+\n+                pushBody(detail,\n+                        FunctionType.functionType(typeToTypeElement(tree.detail.type)));\n+                Value detailVal = toValue(detail);\n+\n+                append(CoreOp._yield(detailVal));\n+                bodies.add(stack.body);\n+\n+                \/\/Pop detail\n+                popBody();\n+            }\n+\n+            result = append(CoreOp._assert(bodies));\n+\n+        }\n+\n+        @Override\n+        public void visitBlock(JCTree.JCBlock tree) {\n+            if (stack.tree == tree) {\n+                \/\/ Block is associated with the visit of a parent structure\n+                scan(tree.stats);\n+            } else {\n+                \/\/ Otherwise, independent block structure\n+                \/\/ Push block\n+                pushBody(tree, FunctionType.VOID);\n+                scan(tree.stats);\n+                appendTerminating(CoreOp::_yield);\n+                Body.Builder body = stack.body;\n+\n+                \/\/ Pop block\n+                popBody();\n+\n+                append(ExtendedOp.block(body));\n+            }\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitSynchronized(JCTree.JCSynchronized tree) {\n+            \/\/ Push expr\n+            pushBody(tree.lock, FunctionType.functionType(typeToTypeElement(tree.lock.type)));\n+            Value last = toValue(tree.lock);\n+            append(CoreOp._yield(last));\n+            Body.Builder expr = stack.body;\n+\n+            \/\/ Pop expr\n+            popBody();\n+\n+            \/\/ Push body block\n+            pushBody(tree.body, FunctionType.VOID);\n+            \/\/ Scan body block statements\n+            scan(tree.body.stats);\n+            appendTerminating(CoreOp::_yield);\n+            Body.Builder blockBody = stack.body;\n+\n+            \/\/ Pop body block\n+            popBody();\n+\n+            append(ExtendedOp.synchronized_(expr, blockBody));\n+        }\n+\n+        @Override\n+        public void visitLabelled(JCTree.JCLabeledStatement tree) {\n+            \/\/ Push block\n+            pushBody(tree, FunctionType.VOID);\n+            \/\/ Create constant for label\n+            String labelName = tree.label.toString();\n+            Op.Result label = append(CoreOp.constant(JavaType.J_L_STRING, labelName));\n+            \/\/ Set label on body stack\n+            stack.setLabel(labelName, label);\n+            scan(tree.body);\n+            appendTerminating(CoreOp::_yield);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop block\n+            popBody();\n+\n+            result = append(ExtendedOp.labeled(body));\n+        }\n+\n+        @Override\n+        public void visitTry(JCTree.JCTry tree) {\n+            List<JCVariableDecl> rVariableDecls = new ArrayList<>();\n+            List<TypeElement> rTypes = new ArrayList<>();\n+            Body.Builder resources;\n+            if (!tree.resources.isEmpty()) {\n+                \/\/ Resources body returns a tuple that contains the resource variables\/values\n+                \/\/ in order of declaration\n+                for (JCTree resource : tree.resources) {\n+                    if (resource instanceof JCVariableDecl vdecl) {\n+                        rVariableDecls.add(vdecl);\n+                        rTypes.add(VarType.varType(typeToTypeElement(vdecl.type)));\n+                    } else {\n+                        rTypes.add(typeToTypeElement(resource.type));\n+                    }\n+                }\n+\n+                \/\/ Push resources body\n+                pushBody(null, FunctionType.functionType(TupleType.tupleType(rTypes)));\n+\n+                List<Value> rValues = new ArrayList<>();\n+                for (JCTree resource : tree.resources) {\n+                    if (resource instanceof JCTree.JCExpression e) {\n+                        rValues.add(toValue(e));\n+                    } else if (resource instanceof JCTree.JCStatement s) {\n+                        rValues.add(toValue(s));\n+                    }\n+                }\n+\n+                append(CoreOp._yield(append(CoreOp.tuple(rValues))));\n+                resources = stack.body;\n+\n+                \/\/ Pop resources body\n+                popBody();\n+            } else {\n+                resources = null;\n+            }\n+\n+            \/\/ Push body\n+            \/\/ Try body accepts the resource variables (in order of declaration).\n+            List<VarType> rVarTypes = rTypes.stream().<VarType>mapMulti((t, c) -> {\n+                if (t instanceof VarType vt) {\n+                    c.accept(vt);\n+                }\n+            }).toList();\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, rVarTypes));\n+            for (int i = 0; i < rVariableDecls.size(); i++) {\n+                stack.localToOp.put(rVariableDecls.get(i).sym, stack.block.parameters().get(i));\n+            }\n+            scan(tree.body);\n+            appendTerminating(CoreOp::_yield);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop block\n+            popBody();\n+\n+            List<Body.Builder> catchers = new ArrayList<>();\n+            for (JCTree.JCCatch catcher : tree.catchers) {\n+                \/\/ Push body\n+                pushBody(catcher.body, FunctionType.functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n+                Op.Result exVariable = append(CoreOp.var(\n+                        catcher.param.name.toString(),\n+                        stack.block.parameters().get(0)));\n+                stack.localToOp.put(catcher.param.sym, exVariable);\n+                scan(catcher.body);\n+                appendTerminating(CoreOp::_yield);\n+                catchers.add(stack.body);\n+\n+                \/\/ Pop block\n+                popBody();\n+            }\n+\n+            Body.Builder finalizer;\n+            if (tree.finalizer != null) {\n+                \/\/ Push body\n+                pushBody(tree.finalizer, FunctionType.VOID);\n+                scan(tree.finalizer);\n+                appendTerminating(CoreOp::_yield);\n+                finalizer = stack.body;\n+\n+                \/\/ Pop block\n+                popBody();\n+            }\n+            else {\n+                finalizer = null;\n+            }\n+\n+            result = append(ExtendedOp._try(resources, body, catchers, finalizer));\n+        }\n+\n+        @Override\n+        public void visitUnary(JCTree.JCUnary tree) {\n+            Tag tag = tree.getTag();\n+            switch (tag) {\n+                case POSTINC, POSTDEC, PREINC, PREDEC -> {\n+                    \/\/ Capture applying rhs and operation\n+                    Function<Value, Value> scanRhs = (lhs) -> {\n+                        Type unboxedType = types.unboxedTypeOrType(tree.type);\n+                        Value one = convert(append(numericOneValue(unboxedType)), unboxedType);\n+                        Value unboxedLhs = unboxIfNeeded(lhs);\n+\n+                        Value unboxedLhsPlusOne = switch (tree.getTag()) {\n+                            \/\/ Arithmetic operations\n+                            case POSTINC, PREINC -> append(CoreOp.add(unboxedLhs, one));\n+                            case POSTDEC, PREDEC -> append(CoreOp.sub(unboxedLhs, one));\n+\n+                            default -> throw unsupported(tree);\n+                        };\n+                        Value lhsPlusOne = convert(unboxedLhsPlusOne, tree.type);\n+\n+                        \/\/ Assign expression result\n+                        result =  switch (tree.getTag()) {\n+                            case POSTINC, POSTDEC -> lhs;\n+                            case PREINC, PREDEC -> lhsPlusOne;\n+\n+                            default -> throw unsupported(tree);\n+                        };\n+                        return lhsPlusOne;\n+                    };\n+\n+                    applyCompoundAssign(tree.arg, scanRhs);\n+                }\n+                case NEG -> {\n+                    Value rhs = toValue(tree.arg, tree.type);\n+                    result = append(CoreOp.neg(rhs));\n+                }\n+                case NOT -> {\n+                    Value rhs = toValue(tree.arg, tree.type);\n+                    result = append(CoreOp.not(rhs));\n+                }\n+                case COMPL -> {\n+                    Value rhs = toValue(tree.arg, tree.type);\n+                    result = append(CoreOp.compl(rhs));\n+                }\n+                case POS -> {\n+                    \/\/ Result is value of the operand\n+                    result = toValue(tree.arg, tree.type);\n+                }\n+                default -> throw unsupported(tree);\n+            }\n+        }\n+\n+        @Override\n+        public void visitBinary(JCBinary tree) {\n+            Tag tag = tree.getTag();\n+            if (tag == Tag.AND || tag == Tag.OR) {\n+                \/\/ Logical operations\n+                \/\/ @@@ Flatten nested sequences\n+\n+                \/\/ Push lhs\n+                pushBody(tree.lhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                Value lhs = toValue(tree.lhs);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(lhs));\n+                Body.Builder bodyLhs = stack.body;\n+\n+                \/\/ Pop lhs\n+                popBody();\n+\n+                \/\/ Push rhs\n+                pushBody(tree.rhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                Value rhs = toValue(tree.rhs);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(rhs));\n+                Body.Builder bodyRhs = stack.body;\n+\n+                \/\/ Pop lhs\n+                popBody();\n+\n+                List<Body.Builder> bodies = List.of(bodyLhs, bodyRhs);\n+                result = append(tag == Tag.AND\n+                        ? ExtendedOp.conditionalAnd(bodies)\n+                        : ExtendedOp.conditionalOr(bodies));\n+            } else if (tag == Tag.PLUS && tree.operator.opcode == ByteCodes.string_add) {\n+                \/\/Ignore the operator and query both subexpressions for their type with concats\n+                Type lhsType = tree.lhs.type;\n+                Type rhsType = tree.rhs.type;\n+\n+                Value lhs = toValue(tree.lhs, lhsType);\n+                Value rhs = toValue(tree.rhs, rhsType);\n+\n+                result = append(CoreOp.concat(lhs, rhs));\n+            }\n+            else {\n+                Type opType = tree.operator.type.getParameterTypes().getFirst();\n+                \/\/ @@@ potentially handle shift input conversion like other binary ops\n+                boolean isShift = tag == Tag.SL || tag == Tag.SR || tag == Tag.USR;\n+                Value lhs = toValue(tree.lhs, opType);\n+                Value rhs = toValue(tree.rhs, isShift ? tree.operator.type.getParameterTypes().getLast() : opType);\n+\n+                result = switch (tag) {\n+                    \/\/ Arithmetic operations\n+                    case PLUS -> append(CoreOp.add(lhs, rhs));\n+                    case MINUS -> append(CoreOp.sub(lhs, rhs));\n+                    case MUL -> append(CoreOp.mul(lhs, rhs));\n+                    case DIV -> append(CoreOp.div(lhs, rhs));\n+                    case MOD -> append(CoreOp.mod(lhs, rhs));\n+\n+                    \/\/ Test operations\n+                    case EQ -> append(CoreOp.eq(lhs, rhs));\n+                    case NE -> append(CoreOp.neq(lhs, rhs));\n+                    \/\/\n+                    case LT -> append(CoreOp.lt(lhs, rhs));\n+                    case LE -> append(CoreOp.le(lhs, rhs));\n+                    case GT -> append(CoreOp.gt(lhs, rhs));\n+                    case GE -> append(CoreOp.ge(lhs, rhs));\n+\n+                    \/\/ Bitwise operations (including their boolean variants)\n+                    case BITOR -> append(CoreOp.or(lhs, rhs));\n+                    case BITAND -> append(CoreOp.and(lhs, rhs));\n+                    case BITXOR -> append(CoreOp.xor(lhs, rhs));\n+\n+                    \/\/ Shift operations\n+                    case SL -> append(CoreOp.lshl(lhs, rhs));\n+                    case SR -> append(CoreOp.ashr(lhs, rhs));\n+                    case USR -> append(CoreOp.lshr(lhs, rhs));\n+\n+                    default -> throw unsupported(tree);\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public void visitLiteral(JCLiteral tree) {\n+            Object value = switch (tree.type.getTag()) {\n+                case BOOLEAN -> tree.value instanceof Integer i && i == 1;\n+                case CHAR -> (char) (int) tree.value;\n+                default -> tree.value;\n+            };\n+            Type constantType = adaptBottom(tree.type);\n+            result = append(CoreOp.constant(typeToTypeElement(constantType), value));\n+        }\n+\n+        @Override\n+        public void visitReturn(JCReturn tree) {\n+            Value retVal = toValue(tree.expr, bodyTarget);\n+            if (retVal == null) {\n+                result = append(CoreOp._return());\n+            } else {\n+                result = append(CoreOp._return(retVal));\n+            }\n+        }\n+\n+        @Override\n+        public void visitThrow(JCTree.JCThrow tree) {\n+            Value throwVal = toValue(tree.expr);\n+            result = append(CoreOp._throw(throwVal));\n+        }\n+\n+        @Override\n+        public void visitBreak(JCTree.JCBreak tree) {\n+            Value label = tree.label != null\n+                    ? getLabel(tree.label.toString())\n+                    : null;\n+            result = append(ExtendedOp._break(label));\n+        }\n+\n+        @Override\n+        public void visitContinue(JCTree.JCContinue tree) {\n+            Value label = tree.label != null\n+                    ? getLabel(tree.label.toString())\n+                    : null;\n+            result = append(ExtendedOp._continue(label));\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            if (tree.sym.isDirectlyOrIndirectlyLocal()) {\n+                \/\/ we need to keep track of captured locals using same strategy as Lower\n+                class FreeVarScanner extends Lower.FreeVarCollector {\n+                    FreeVarScanner() {\n+                        lower.super(tree);\n+                    }\n+\n+                    @Override\n+                    protected void addFreeVars(ClassSymbol c) {\n+                        localCaptures.getOrDefault(c, List.of())\n+                                .forEach(s -> addFreeVar((VarSymbol)s));\n+                    }\n+                }\n+                FreeVarScanner fvs = new FreeVarScanner();\n+                localCaptures.put(tree.sym, List.copyOf(fvs.analyzeCaptures()));\n+            }\n+        }\n+\n+        UnsupportedASTException unsupported(JCTree tree) {\n+            return new UnsupportedASTException(tree);\n+        }\n+\n+        CoreOp.FuncOp scanMethod() {\n+            scan(body);\n+            appendReturnOrUnreachable(body);\n+            CoreOp.FuncOp func = CoreOp.func(name.toString(), stack.body);\n+            func.setLocation(generateLocation(currentNode, true));\n+            return func;\n+        }\n+\n+        CoreOp.FuncOp scanLambda() {\n+            scan(body);\n+            \/\/ Return the quoted result\n+            append(CoreOp._return(result));\n+            return CoreOp.func(name.toString(), stack.body);\n+        }\n+\n+        JavaType symbolToErasedDesc(Symbol s) {\n+            return typeToTypeElement(s.erasure(types));\n+        }\n+\n+        JavaType typeToTypeElement(Type t) {\n+            t = normalizeType(t);\n+            return switch (t.getTag()) {\n+                case VOID -> JavaType.VOID;\n+                case CHAR -> JavaType.CHAR;\n+                case BOOLEAN -> JavaType.BOOLEAN;\n+                case BYTE -> JavaType.BYTE;\n+                case SHORT -> JavaType.SHORT;\n+                case INT -> JavaType.INT;\n+                case FLOAT -> JavaType.FLOAT;\n+                case LONG -> JavaType.LONG;\n+                case DOUBLE -> JavaType.DOUBLE;\n+                case ARRAY -> {\n+                    Type et = ((ArrayType)t).elemtype;\n+                    yield JavaType.array(typeToTypeElement(et));\n+                }\n+                case WILDCARD -> {\n+                    Type.WildcardType wt = (Type.WildcardType)t;\n+                    yield wt.isUnbound() ?\n+                            JavaType.wildcard() :\n+                            JavaType.wildcard(wt.isExtendsBound() ? BoundKind.EXTENDS : BoundKind.SUPER, typeToTypeElement(wt.type));\n+                }\n+                case TYPEVAR -> t.tsym.owner.kind == Kind.MTH ?\n+                        JavaType.typeVarRef(t.tsym.name.toString(), symbolToErasedMethodRef(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound())) :\n+                        JavaType.typeVarRef(t.tsym.name.toString(),\n+                                (jdk.incubator.code.type.ClassType)symbolToErasedDesc(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound()));\n+                case CLASS -> {\n+                    Assert.check(!t.isIntersection() && !t.isUnion());\n+                    JavaType typ;\n+                    if (t.getEnclosingType() != Type.noType) {\n+                        Name innerName = t.tsym.flatName().subName(t.getEnclosingType().tsym.flatName().length() + 1);\n+                        typ = JavaType.qualified(typeToTypeElement(t.getEnclosingType()), innerName.toString());\n+                    } else {\n+                        typ = JavaType.type(ClassDesc.of(t.tsym.flatName().toString()));\n+                    }\n+\n+                    List<JavaType> typeArguments;\n+                    if (t.getTypeArguments().nonEmpty()) {\n+                        typeArguments = new ArrayList<>();\n+                        for (Type ta : t.getTypeArguments()) {\n+                            typeArguments.add(typeToTypeElement(ta));\n+                        }\n+                    } else {\n+                        typeArguments = List.of();\n+                    }\n+\n+                    \/\/ Use flat name to ensure demarcation of nested classes\n+                    yield JavaType.parameterized(typ, typeArguments);\n+                }\n+                default -> {\n+                    throw new UnsupportedOperationException(\"Unsupported type: kind=\" + t.getKind() + \" type=\" + t);\n+                }\n+            };\n+        }\n+\n+        Type symbolSiteType(Symbol s) {\n+            boolean isMember = s.owner == syms.predefClass ||\n+                    s.isMemberOf(currentClassSym, types);\n+            return isMember ? currentClassSym.type : s.owner.type;\n+        }\n+\n+        FieldRef symbolToFieldRef(Symbol s, Type site) {\n+            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n+            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+            return symbolToErasedFieldRef(gen.binaryQualifier(s, types.erasure(site)));\n+        }\n+\n+        FieldRef symbolToErasedFieldRef(Symbol s) {\n+            Type erasedType = s.erasure(types);\n+            return FieldRef.field(\n+                    typeToTypeElement(s.owner.erasure(types)),\n+                    s.name.toString(),\n+                    typeToTypeElement(erasedType));\n+        }\n+\n+        MethodRef symbolToErasedMethodRef(Symbol s, Type site) {\n+            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n+            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+            return symbolToErasedMethodRef(gen.binaryQualifier(s, types.erasure(site)));\n+        }\n+\n+        MethodRef symbolToErasedMethodRef(Symbol s) {\n+            Type erasedType = s.erasure(types);\n+            return MethodRef.method(\n+                    typeToTypeElement(s.owner.erasure(types)),\n+                    s.name.toString(),\n+                    typeToTypeElement(erasedType.getReturnType()),\n+                    erasedType.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n+        }\n+\n+        FunctionType symbolToFunctionType(Symbol s) {\n+            return typeToFunctionType(s.type);\n+        }\n+\n+        FunctionType typeToFunctionType(Type t) {\n+            return FunctionType.functionType(\n+                    typeToTypeElement(t.getReturnType()),\n+                    t.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n+        }\n+\n+        RecordTypeRef symbolToRecordTypeRef(Symbol.ClassSymbol s) {\n+            TypeElement recordType = typeToTypeElement(s.type);\n+            List<RecordTypeRef.ComponentRef> components = s.getRecordComponents().stream()\n+                    .map(rc -> new RecordTypeRef.ComponentRef(typeToTypeElement(rc.type), rc.name.toString()))\n+                    .toList();\n+            return RecordTypeRef.recordType(recordType, components);\n+        }\n+\n+        Op defaultValue(Type t) {\n+            return switch (t.getTag()) {\n+                case BYTE, SHORT, INT -> CoreOp.constant(JavaType.INT, 0);\n+                case CHAR -> CoreOp.constant(typeToTypeElement(t), (char)0);\n+                case BOOLEAN -> CoreOp.constant(typeToTypeElement(t), false);\n+                case FLOAT -> CoreOp.constant(typeToTypeElement(t), 0f);\n+                case LONG -> CoreOp.constant(typeToTypeElement(t), 0L);\n+                case DOUBLE -> CoreOp.constant(typeToTypeElement(t), 0d);\n+                default -> CoreOp.constant(typeToTypeElement(t), null);\n+            };\n+        }\n+\n+        Op numericOneValue(Type t) {\n+            return switch (t.getTag()) {\n+                case BYTE, SHORT, INT -> CoreOp.constant(JavaType.INT, 1);\n+                case CHAR -> CoreOp.constant(typeToTypeElement(t), (char)1);\n+                case FLOAT -> CoreOp.constant(typeToTypeElement(t), 1f);\n+                case LONG -> CoreOp.constant(typeToTypeElement(t), 1L);\n+                case DOUBLE -> CoreOp.constant(typeToTypeElement(t), 1d);\n+                default -> throw new UnsupportedOperationException(t.toString());\n+            };\n+        }\n+\n+        Type normalizeType(Type t) {\n+            Assert.check(!t.hasTag(METHOD));\n+            return types.upward(t, false, types.captures(t));\n+        }\n+\n+        Type typeElementToType(TypeElement desc) {\n+            return primitiveAndBoxTypeMap().getOrDefault(desc, Type.noType);\n+        }\n+\n+        public boolean checkDenotableInTypeDesc(Type t) {\n+            return denotableChecker.visit(t, null);\n+        }\n+        \/\/ where\n+\n+        \/**\n+         * A type visitor that descends into the given type looking for types that are non-denotable\n+         * in code model types. Examples of such types are: type-variables (regular or captured),\n+         * wildcard type argument, intersection types, union types. The visit methods return false\n+         * as soon as a non-denotable type is encountered and true otherwise. (see {@link Check#checkDenotable(Type)}.\n+         *\/\n+        private static final Types.SimpleVisitor<Boolean, Void> denotableChecker = new Types.SimpleVisitor<>() {\n+            @Override\n+            public Boolean visitType(Type t, Void s) {\n+                return true;\n+            }\n+            @Override\n+            public Boolean visitClassType(ClassType t, Void s) {\n+                if (t.isUnion() || t.isIntersection()) {\n+                    \/\/ union and intersections cannot be denoted in code model types\n+                    return false;\n+                }\n+                \/\/ @@@ What about enclosing types?\n+                for (Type targ : t.getTypeArguments()) {\n+                    \/\/ propagate into type arguments\n+                    if (!visit(targ, s)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Void s) {\n+                \/\/ type variables cannot be denoted in code model types\n+                return false;\n+            }\n+\n+            @Override\n+            public Boolean visitWildcardType(WildcardType t, Void s) {\n+                \/\/ wildcards cannot de denoted in code model types\n+                return false;\n+            }\n+\n+            @Override\n+            public Boolean visitArrayType(ArrayType t, Void s) {\n+                \/\/ propagate into element type\n+                return visit(t.elemtype, s);\n+            }\n+        };\n+\n+    }\n+\n+    \/**\n+     * An exception thrown when an unsupported AST node is found when building a method IR.\n+     *\/\n+    static class UnsupportedASTException extends RuntimeException {\n+\n+        private static final long serialVersionUID = 0;\n+        transient final JCTree tree;\n+\n+        public UnsupportedASTException(JCTree tree) {\n+            this.tree = tree;\n+        }\n+    }\n+\n+    enum FunctionalExpressionKind {\n+        QUOTED_STRUCTURAL(true), \/\/ this is transitional\n+        QUOTABLE(true),\n+        NOT_QUOTED(false);\n+\n+        final boolean isQuoted;\n+\n+        FunctionalExpressionKind(boolean isQuoted) {\n+            this.isQuoted = isQuoted;\n+        }\n+    }\n+\n+    FunctionalExpressionKind functionalKind(JCFunctionalExpression functionalExpression) {\n+        if (functionalExpression.target.hasTag(TypeTag.METHOD)) {\n+            return FunctionalExpressionKind.QUOTED_STRUCTURAL;\n+        } else if (types.asSuper(functionalExpression.target, crSyms.quotableType.tsym) != null) {\n+            return FunctionalExpressionKind.QUOTABLE;\n+        } else {\n+            return FunctionalExpressionKind.NOT_QUOTED;\n+        }\n+    }\n+\n+    \/*\n+     * Converts a method reference which cannot be used directly into a lambda.\n+     * This code has been derived from LambdaToMethod::MemberReferenceToLambda. The main\n+     * difference is that, while that code concerns with translation strategy, boxing\n+     * conversion and type erasure, this version does not and, as such, can remain\n+     * at a higher level. Note that this code needs to create a synthetic variable\n+     * declaration in case of a bounded method reference whose receiver expression\n+     * is other than 'this'\/'super' (this is done to prevent the receiver expression\n+     * from being computed twice).\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final Symbol owner;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private JCVariableDecl receiverVar = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree, Symbol currentClass) {\n+            this.tree = tree;\n+            this.owner = new MethodSymbol(0, names.lambda, tree.target, currentClass);\n+            if (tree.kind == ReferenceKind.BOUND && !isThisOrSuper(tree.getQualifierExpression())) {\n+                \/\/ true bound method reference, hoist receiver expression out\n+                Type recvType = types.asSuper(tree.getQualifierExpression().type, tree.sym.owner);\n+                VarSymbol vsym = makeSyntheticVar(\"rec$\", recvType);\n+                receiverVar = make.VarDef(vsym, tree.getQualifierExpression());\n+            }\n+        }\n+\n+        JCVariableDecl receiverVar() {\n+            return receiverVar;\n+        }\n+\n+        JCLambda lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                return slam;\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            com.sun.tools.javac.util.List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+            VarSymbol receiverParam = null;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    if (receiverVar != null) {\n+                        receiverParam = receiverVar.sym;\n+                    }\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    receiverParam = addParameter(\"rec$\", descPTypes.head, false);\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+            }\n+            for (int i = 0; descPTypes.nonEmpty(); ++i) {\n+                \/\/ By default use the implementation method parameter type\n+                Type parmType = descPTypes.head;\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                descPTypes = descPTypes.tail;\n+            }\n+\n+            return receiverParam;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol receiverParam) {\n+            JCExpression qualifier = receiverParam != null ?\n+                    make.at(tree.pos).Ident(receiverParam) :\n+                    tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.referentType;\n+\n+            \/\/create the method call expression\n+            JCMethodInvocation apply = make.Apply(com.sun.tools.javac.util.List.nil(), select, args.toList()).\n+                    setType(tree.referentType.getReturnType());\n+\n+            apply.varargsElement = tree.varargsElement;\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            Type expectedType = tree.referentType.getReturnType().hasTag(TypeTag.VOID) ?\n+                    tree.expr.type : tree.referentType.getReturnType();\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(expectedType)),\n+                        com.sun.tools.javac.util.List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCExpression newType = make.Type(types.erasure(expectedType));\n+                if (expectedType.tsym.type.getTypeArguments().nonEmpty()) {\n+                    newType = make.TypeApply(newType, com.sun.tools.javac.util.List.nil());\n+                }\n+                JCNewClass newClass = make.NewClass(null,\n+                        com.sun.tools.javac.util.List.nil(),\n+                        newType,\n+                        args.toList(),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.referentType;\n+                newClass.type = expectedType;\n+                newClass.varargsElement = tree.varargsElement;\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol makeSyntheticVar(String name, Type type) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), type, owner);\n+            vsym.pos = tree.pos;\n+            return vsym;\n+        }\n+\n+        private VarSymbol addParameter(String name, Type type, boolean genArg) {\n+            VarSymbol vsym = makeSyntheticVar(name, type);\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+\n+        boolean isThisOrSuper(JCExpression expression) {\n+            return TreeInfo.isThisQualifier(expression) || TreeInfo.isSuperQualifier(tree);\n+        }\n+    }\n+\n+    \/**\n+     * compiler.note.quoted.ir.dump=\\\n+     *    code reflection enabled for method quoted lambda\\n\\\n+     *    {0}\n+     *\/\n+    public static Note QuotedIrDump(String arg0) {\n+        return new Note(\"compiler\", \"quoted.ir.dump\", arg0);\n+    }\n+\n+    \/**\n+     * compiler.note.quoted.ir.skip=\\\n+     *    unsupported code reflection node {0} found in quoted lambda\n+     *\/\n+    public static Note QuotedIrSkip(String arg0) {\n+        return new Note(\"compiler\", \"quoted.ir.skip\", arg0);\n+    }\n+\n+    \/**\n+     * compiler.note.method.ir.dump=\\\n+     *    code reflection enabled for method {0}.{1}\\n\\\n+     *    {2}\n+     *\/\n+    public static Note MethodIrDump(Symbol arg0, Symbol arg1, String arg2) {\n+        return new Note(\"compiler\", \"method.ir.dump\", arg0, arg1, arg2);\n+    }\n+\n+    \/**\n+     * compiler.note.method.ir.skip=\\\n+     *    unsupported code reflection node {2} found in method {0}.{1}\n+     *\/\n+    public static Note MethodIrSkip(Symbol arg0, Symbol arg1, String arg2) {\n+        return new Note(\"compiler\", \"method.ir.skip\", arg0, arg1, arg2);\n+    }\n+\n+    public static class Provider implements CodeReflectionTransformer {\n+        @Override\n+        public JCTree translateTopLevelClass(Context context, JCTree tree, TreeMaker make) {\n+            return ReflectMethods.instance(context).translateTopLevelClass(tree, make);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":3012,"deletions":0,"binary":false,"changes":3012,"status":"added"},{"patch":"@@ -628,1 +628,1 @@\n-    javax\/xml\/jaxp\/datatype\/8033980\/GregorianCalAndDurSerDataUtil.java \n+    javax\/xml\/jaxp\/datatype\/8033980\/GregorianCalAndDurSerDataUtil.java\n@@ -672,0 +672,3 @@\n+\n+jdk_lang_reflect_code = \\\n+   java\/lang\/reflect\/code\n","filename":"test\/jdk\/TEST.groups","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import static java.lang.classfile.Opcode.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import jdk.incubator.code.bytecode.BranchCompactor;\n+import java.util.List;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @modules java.base\/jdk.internal.classfile.components\n+ * @enablePreview\n+ * @run testng TestBranchCompactor\n+ *\/\n+public class TestBranchCompactor {\n+\n+    @Test\n+    public void testBranchCompactor() {\n+        var cc = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+        var clm = cc.parse(cc.build(ClassDesc.of(\"c\"), clb -> clb.withMethodBody(\"m\", ConstantDescs.MTD_void, 0,\n+                cb -> cb.transforming(new BranchCompactor(), cob -> {\n+                    var l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .lineNumber(1)\n+                       .labelBinding(l)\n+                       .nop();\n+\n+                    l = cob.newLabel();\n+                    cob.goto_w(l) \/\/compact\n+                       .lineNumber(2)\n+                       .labelBinding(l);\n+\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .labelBinding(l);\n+\n+                    cob.iconst_0();\n+                    l = cob.newLabel();\n+                    cob.ifeq(l) \/\/do not compact\n+                       .labelBinding(l);\n+\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/do not compact\n+                       .nop()\n+                       .labelBinding(l)\n+                       .return_();\n+                }))));\n+        var code = clm.methods().get(0).code().get();\n+        ClassPrinter.toYaml(code, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+        Assert.assertEquals(\n+                code.elementList().stream().mapMulti((e, ec) -> {if (e instanceof Instruction i) ec.accept(i.opcode());}).toList(),\n+                List.of(NOP, ICONST_0, IFEQ, GOTO, NOP, RETURN));\n+        Assert.assertEquals(code.findAttribute(Attributes.lineNumberTable()).get().lineNumbers().size(), 2);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,739 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.AccessFlag;\n+import org.testng.Assert;\n+import org.testng.SkipException;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.bytecode.BytecodeLift;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @modules java.base\/jdk.internal.classfile.components\n+ * @enablePreview\n+ * @run testng\/othervm -Djdk.invoke.MethodHandle.dumpClassFiles=true TestBytecode\n+ *\/\n+\n+public class TestBytecode {\n+\n+    @CodeReflection\n+    static int intNumOps(int i, int j, int k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static byte byteNumOps(byte i, byte j, byte k) {\n+        k++;\n+        i = (byte) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static short shortNumOps(short i, short j, short k) {\n+        k++;\n+        i = (short) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static char charNumOps(char i, char j, char k) {\n+        k++;\n+        i = (char) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static long longNumOps(long i, long j, long k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static float floatNumOps(float i, float j, float k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static double doubleNumOps(double i, double j, double k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static int intBitOps(int i, int j, int k) {\n+        return ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static byte byteBitOps(byte i, byte j, byte k) {\n+        return (byte) ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static short shortBitOps(short i, short j, short k) {\n+        return (short) ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static char charBitOps(char i, char j, char k) {\n+        return (char) ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static long longBitOps(long i, long j, long k) {\n+        return ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static boolean boolBitOps(boolean i, boolean j, boolean k) {\n+        return i & j | k ^ j;\n+    }\n+\n+    @CodeReflection\n+    static int intShiftOps(int i, int j, int k) {\n+        return ((-1 >> i) << (j << k)) >>> (k - j);\n+    }\n+\n+    @CodeReflection\n+    static byte byteShiftOps(byte i, byte j, byte k) {\n+        return (byte) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    static short shortShiftOps(short i, short j, short k) {\n+        return (short) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    static char charShiftOps(char i, char j, char k) {\n+        return (char) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    static long longShiftOps(long i, long j, long k) {\n+        return ((-1 >> i) << (j << k)) >>> (k - j);\n+    }\n+\n+    @CodeReflection\n+    static Object[] boxingAndUnboxing(int i, byte b, short s, char c, Integer ii, Byte bb, Short ss, Character cc) {\n+        ii += i; ii += b; ii += s; ii += c;\n+        i += ii; i += bb; i += ss; i += cc;\n+        b += ii; b += bb; b += ss; b += cc;\n+        s += ii; s += bb; s += ss; s += cc;\n+        c += ii; c += bb; c += ss; c += cc;\n+        return new Object[]{i, b, s, c};\n+    }\n+\n+    @CodeReflection\n+    static String constructor(String s, int i, int j) {\n+        return new String(s.getBytes(), i, j);\n+    }\n+\n+    @CodeReflection\n+    static Class<?> classArray(int i, int j) {\n+        Class<?>[] ifaces = new Class[1 + i + j];\n+        ifaces[0] = Function.class;\n+        return ifaces[0];\n+    }\n+\n+    @CodeReflection\n+    static String[] stringArray(int i, int j) {\n+        return new String[i];\n+    }\n+\n+    @CodeReflection\n+    static String[][] stringArray2(int i, int j) {\n+        return new String[i][];\n+    }\n+\n+    @CodeReflection\n+    static String[][] stringArrayMulti(int i, int j) {\n+        return new String[i][j];\n+    }\n+\n+    @CodeReflection\n+    static int[][] initializedIntArray(int i, int j) {\n+        return new int[][]{{i, j}, {i + j}};\n+    }\n+\n+    @CodeReflection\n+    static int ifElseCompare(int i, int j) {\n+        if (i < 3) {\n+            i += 1;\n+        } else {\n+            j += 2;\n+        }\n+        return i + j;\n+    }\n+\n+    @CodeReflection\n+    static int ifElseEquality(int i, int j) {\n+        if (j != 0) {\n+            if (i != 0) {\n+                i += 1;\n+            } else {\n+                i += 2;\n+            }\n+        } else {\n+            if (j != 0) {\n+                i += 3;\n+            } else {\n+                i += 4;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static int objectsCompare(Boolean b1, Boolean b2, Boolean b3) {\n+        Object a = b1;\n+        Object b = b2;\n+        Object c = b3;\n+        return a == b ? (a != c ? 1 : 2) : (b != c ? 3 : 4);\n+    }\n+\n+    @CodeReflection\n+    static int conditionalExpr(int i, int j) {\n+        return ((i - 1 >= 0) ? i - 1 : j - 1);\n+    }\n+\n+    @CodeReflection\n+    static int nestedConditionalExpr(int i, int j) {\n+        return (i < 2) ? (j < 3) ? i : j : i + j;\n+    }\n+\n+    static final int[] MAP = {0, 1, 2, 3, 4};\n+\n+    @CodeReflection\n+    static int deepStackBranches(boolean a, boolean b) {\n+        return MAP[a ? MAP[b ? 1 : 2] : MAP[b ? 3 : 4]];\n+    }\n+\n+    @CodeReflection\n+    static int tryFinally(int i, int j) {\n+        try {\n+            i = i + j;\n+        } finally {\n+            i = i + j;\n+        }\n+        return i;\n+    }\n+\n+    public record A(String s) {}\n+\n+    @CodeReflection\n+    static A newWithArgs(int i, int j) {\n+        return new A(\"hello world\".substring(i, i + j));\n+    }\n+\n+    @CodeReflection\n+    static int loop(int n, int j) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            sum = sum + j;\n+        }\n+        return sum;\n+    }\n+\n+\n+    @CodeReflection\n+    static int ifElseNested(int a, int b) {\n+        int c = a + b;\n+        int d = 10 - a + b;\n+        if (b < 3) {\n+            if (a < 3) {\n+                a += 1;\n+            } else {\n+                b += 2;\n+            }\n+            c += 3;\n+        } else {\n+            if (a > 2) {\n+                a += 4;\n+            } else {\n+                b += 5;\n+            }\n+            d += 6;\n+        }\n+        return a + b + c + d;\n+    }\n+\n+    @CodeReflection\n+    static int nestedLoop(int m, int n) {\n+        int sum = 0;\n+        for (int i = 0; i < m; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum = sum + i + j;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @CodeReflection\n+    static int methodCall(int a, int b) {\n+        int i = Math.max(a, b);\n+        return Math.negateExact(i);\n+    }\n+\n+    @CodeReflection\n+    static int[] primitiveArray(int i, int j) {\n+        int[] ia = new int[i + 1];\n+        ia[0] = j;\n+        return ia;\n+    }\n+\n+    @CodeReflection\n+    static boolean not(boolean b) {\n+        return !b;\n+    }\n+\n+    @CodeReflection\n+    static boolean notCompare(int i, int j) {\n+        boolean b = i < j;\n+        return !b;\n+    }\n+\n+    @CodeReflection\n+    static int mod(int i, int j) {\n+        return i % (j + 1);\n+    }\n+\n+    @CodeReflection\n+    static int xor(int i, int j) {\n+        return i ^ j;\n+    }\n+\n+    @CodeReflection\n+    static int whileLoop(int i, int n) { int\n+        counter = 0;\n+        while (i < n && counter < 3) {\n+            counter++;\n+            if (counter == 4) {\n+                break;\n+            }\n+            i++;\n+        }\n+        return counter;\n+    }\n+\n+    public interface Func {\n+        int apply(int a);\n+    }\n+\n+    public interface QuotableFunc extends Quotable {\n+        int apply(int a);\n+    }\n+\n+    static int consume(int i, Func f) {\n+        return f.apply(i + 1);\n+    }\n+\n+    static int consumeQuotable(int i, QuotableFunc f) {\n+        Assert.assertNotNull(Op.ofQuotable(f).get());\n+        Assert.assertNotNull(Op.ofQuotable(f).get().op());\n+        Assert.assertTrue(Op.ofQuotable(f).get().op() instanceof CoreOp.LambdaOp);\n+        return f.apply(i + 1);\n+    }\n+\n+    @CodeReflection\n+    static int lambda(int i) {\n+        return consume(i, a -> -a);\n+    }\n+\n+    @CodeReflection\n+    static int quotableLambda(int i) {\n+        return consumeQuotable(i, a -> -a);\n+    }\n+\n+    @CodeReflection\n+    static int lambdaWithCapture(int i, String s) {\n+        return consume(i, a -> a + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int quotableLambdaWithCapture(int i, String s) {\n+        return consumeQuotable(i, a -> a + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int nestedLambdasWithCaptures(int i, int j, String s) {\n+        return consume(i, a -> consume(a, b -> a + b + j - s.length()) + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int nestedQuotableLambdasWithCaptures(int i, int j, String s) {\n+        return consumeQuotable(i, a -> consumeQuotable(a, b -> a + b + j - s.length()) + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int methodHandle(int i) {\n+        return consume(i, Math::negateExact);\n+    }\n+\n+    int instanceMethod(int i) {\n+        return -i + 13;\n+    }\n+\n+    @CodeReflection\n+    int instanceMethodHandle(int i) {\n+        return consume(i, this::instanceMethod);\n+    }\n+\n+    static void consume(boolean b, Consumer<Object> requireNonNull) {\n+        if (b) {\n+            requireNonNull.accept(new Object());\n+        } else try {\n+            requireNonNull.accept(null);\n+            throw new AssertionError(\"Expectend NPE\");\n+        } catch (NullPointerException expected) {\n+        }\n+    }\n+\n+    @CodeReflection\n+    static void nullReturningMethodHandle(boolean b) {\n+        consume(b, Objects::requireNonNull);\n+    }\n+\n+    @CodeReflection\n+    static boolean compareLong(long i, long j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static boolean compareFloat(float i, float j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static boolean compareDouble(double i, double j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static int lookupSwitch(int i) {\n+        return switch (1000 * i) {\n+            case 1000 -> 1;\n+            case 2000 -> 2;\n+            case 3000 -> 3;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    static int tableSwitch(int i) {\n+        return switch (i) {\n+            case 1 -> 1;\n+            case 2 -> 2;\n+            case 3 -> 3;\n+            default -> 0;\n+        };\n+    }\n+\n+    int instanceField = -1;\n+\n+    @CodeReflection\n+    int instanceFieldAccess(int i) {\n+        int ret = instanceField;\n+        instanceField = i;\n+        return ret;\n+    }\n+\n+    @CodeReflection\n+    static String stringConcat(String a, String b) {\n+        return \"a\"+ a +\"\\u0001\" + a + \"b\\u0002c\" + b + \"\\u0001\\u0002\" + b + \"dd\";\n+    }\n+\n+    @CodeReflection\n+    static String multiTypeConcat(int i, Boolean b, char c, Short s, float f, Double d) {\n+        return \"i:\"+ i +\" b:\" + b + \" c:\" + c + \" f:\" + f + \" d:\" + d;\n+    }\n+\n+    @CodeReflection\n+    static int ifTrue(int i) {\n+        if (true) {\n+            return i;\n+        }\n+        return -i;\n+    }\n+\n+    @CodeReflection\n+    static int excHandlerFollowingSplitTable(boolean b) {\n+        try {\n+            if (b) return 1;\n+            else throw new Exception();\n+        } catch (Exception ex) {}\n+        return 2;\n+    }\n+\n+    @CodeReflection\n+    static int varModifiedInTryBlock(boolean b) {\n+        int i = 0;\n+        try {\n+            i++;\n+            if (b) throw new Exception();\n+            i++;\n+            throw new Exception();\n+        } catch (Exception ex) {\n+            return i;\n+        }\n+    }\n+\n+    @CodeReflection\n+    static boolean finallyWithLoop(boolean b) {\n+        try {\n+            while (b) {\n+                if (b)\n+                    return false;\n+                b = !b;\n+            }\n+            return true;\n+        } finally {\n+            b = false;\n+        }\n+    }\n+\n+    @CodeReflection\n+    static long doubleUseOfOperand(int x) {\n+        long piece = x;\n+        return piece * piece;\n+    }\n+\n+    record TestData(Method testMethod) {\n+        @Override\n+        public String toString() {\n+            String s = testMethod.getName() + Arrays.stream(testMethod.getParameterTypes())\n+                    .map(Class::getSimpleName).collect(Collectors.joining(\",\", \"(\", \")\"));\n+            if (s.length() > 30) s = s.substring(0, 27) + \"...\";\n+            return s;\n+        }\n+    }\n+\n+    @DataProvider(name = \"testMethods\")\n+    public static TestData[]testMethods() {\n+        return Stream.of(TestBytecode.class.getDeclaredMethods())\n+                .filter(m -> m.isAnnotationPresent(CodeReflection.class))\n+                .map(TestData::new).toArray(TestData[]::new);\n+    }\n+\n+    private static byte[] CLASS_DATA;\n+    private static ClassModel CLASS_MODEL;\n+\n+    @BeforeClass\n+    public static void setup() throws Exception {\n+        CLASS_DATA = TestBytecode.class.getResourceAsStream(\"TestBytecode.class\").readAllBytes();\n+        CLASS_MODEL = ClassFile.of().parse(CLASS_DATA);\n+    }\n+\n+    private static MethodTypeDesc toMethodTypeDesc(Method m) {\n+        return MethodTypeDesc.of(\n+                m.getReturnType().describeConstable().orElseThrow(),\n+                Arrays.stream(m.getParameterTypes())\n+                        .map(cls -> cls.describeConstable().orElseThrow()).toList());\n+    }\n+\n+\n+    private static final Map<Class<?>, Object[]> TEST_ARGS = new IdentityHashMap<>();\n+    private static Object[] values(Object... values) {\n+        return values;\n+    }\n+    private static void initTestArgs(Object[] values, Class<?>... argTypes) {\n+        for (var argType : argTypes) TEST_ARGS.put(argType, values);\n+    }\n+    static {\n+        initTestArgs(values(1, 2, 4), int.class, Integer.class);\n+        initTestArgs(values((byte)1, (byte)3, (byte)4), byte.class, Byte.class);\n+        initTestArgs(values((short)1, (short)2, (short)3), short.class, Short.class);\n+        initTestArgs(values((char)2, (char)3, (char)4), char.class, Character.class);\n+        initTestArgs(values(false, true), boolean.class, Boolean.class);\n+        initTestArgs(values(\"Hello World\"), String.class);\n+        initTestArgs(values(1l, 2l, 4l), long.class, Long.class);\n+        initTestArgs(values(1f, 3f, 4f), float.class, Float.class);\n+        initTestArgs(values(1d, 2d, 3d), double.class, Double.class);\n+    }\n+\n+    interface Executor {\n+        void execute(Object[] args) throws Throwable;\n+    }\n+\n+    private static void permutateAllArgs(Class<?>[] argTypes, Executor executor) throws Throwable {\n+        final int argn = argTypes.length;\n+        Object[][] argValues = new Object[argn][];\n+        for (int i = 0; i < argn; i++) {\n+            argValues[i] = TEST_ARGS.get(argTypes[i]);\n+        }\n+        int[] argIndexes = new int[argn];\n+        Object[] args = new Object[argn];\n+        while (true) {\n+            for (int i = 0; i < argn; i++) {\n+                args[i] = argValues[i][argIndexes[i]];\n+            }\n+            executor.execute(args);\n+            int i = argn - 1;\n+            while (i >= 0 && argIndexes[i] == argValues[i].length - 1) i--;\n+            if (i < 0) return;\n+            argIndexes[i++]++;\n+            while (i < argn) argIndexes[i++] = 0;\n+        }\n+    }\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testLift(TestData d) throws Throwable {\n+        CoreOp.FuncOp flift;\n+        try {\n+            flift = BytecodeLift.lift(CLASS_DATA, d.testMethod.getName(), toMethodTypeDesc(d.testMethod));\n+        } catch (Throwable e) {\n+            ClassPrinter.toYaml(ClassFile.of().parse(TestBytecode.class.getResourceAsStream(\"TestBytecode.class\").readAllBytes())\n+                    .methods().stream().filter(m -> m.methodName().equalsString(d.testMethod().getName())).findAny().get(),\n+                    ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+            System.out.println(\"Lift failed, compiled model:\");\n+            Op.ofMethod(d.testMethod).ifPresent(f -> f.writeTo(System.out));\n+            throw e;\n+        }\n+        try {\n+            Object receiver1, receiver2;\n+            if (d.testMethod.accessFlags().contains(AccessFlag.STATIC)) {\n+                receiver1 = null;\n+                receiver2 = null;\n+            } else {\n+                receiver1 = new TestBytecode();\n+                receiver2 = new TestBytecode();\n+            }\n+            permutateAllArgs(d.testMethod.getParameterTypes(), args ->\n+                Assert.assertEquals(invokeAndConvert(flift, receiver1, args), d.testMethod.invoke(receiver2, args)));\n+        } catch (Throwable e) {\n+            System.out.println(\"Compiled model:\");\n+            Op.ofMethod(d.testMethod).ifPresent(f -> f.writeTo(System.out));\n+            System.out.println(\"Lifted model:\");\n+            flift.writeTo(System.out);\n+            throw e;\n+        }\n+    }\n+\n+    private static Object invokeAndConvert(CoreOp.FuncOp func, Object receiver, Object... args) {\n+        List argl = new ArrayList(args.length + 1);\n+        if (receiver != null) argl.add(receiver);\n+        argl.addAll(Arrays.asList(args));\n+        Object ret = Interpreter.invoke(MethodHandles.lookup(), func, argl);\n+        if (ret instanceof Integer i) {\n+            TypeElement rt = func.invokableType().returnType();\n+            if (rt.equals(JavaType.BOOLEAN)) {\n+                return i != 0;\n+            } else if (rt.equals(JavaType.BYTE)) {\n+                return i.byteValue();\n+            } else if (rt.equals(JavaType.CHAR)) {\n+                return (short)i.intValue();\n+            } else if (rt.equals(JavaType.SHORT)) {\n+                return i.shortValue();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testGenerate(TestData d) throws Throwable {\n+        CoreOp.FuncOp func = Op.ofMethod(d.testMethod).get();\n+\n+        CoreOp.FuncOp lfunc;\n+        try {\n+            lfunc = func.transform(CopyContext.create(), OpTransformer.LOWERING_TRANSFORMER);\n+        } catch (UnsupportedOperationException uoe) {\n+            throw new SkipException(\"lowering caused:\", uoe);\n+        }\n+\n+        try {\n+            MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lfunc);\n+            Object receiver1, receiver2;\n+            if (d.testMethod.accessFlags().contains(AccessFlag.STATIC)) {\n+                receiver1 = null;\n+                receiver2 = null;\n+            } else {\n+                receiver1 = new TestBytecode();\n+                receiver2 = new TestBytecode();\n+            }\n+            permutateAllArgs(d.testMethod.getParameterTypes(), args -> {\n+                    List argl = new ArrayList(args.length + 1);\n+                    if (receiver1 != null) argl.add(receiver1);\n+                    argl.addAll(Arrays.asList(args));\n+                    Assert.assertEquals(mh.invokeWithArguments(argl), d.testMethod.invoke(receiver2, args));\n+            });\n+        } catch (Throwable e) {\n+            func.writeTo(System.out);\n+            lfunc.writeTo(System.out);\n+            String methodName = d.testMethod().getName();\n+            for (var mm : CLASS_MODEL.methods()) {\n+                if (mm.methodName().equalsString(methodName)\n+                        || mm.methodName().stringValue().startsWith(\"lambda$\" + methodName + \"$\")) {\n+                    ClassPrinter.toYaml(mm,\n+                                        ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES,\n+                                        System.out::print);\n+                }\n+            }\n+            Files.list(Path.of(\"DUMP_CLASS_FILES\")).forEach(p -> {\n+                if (p.getFileName().toString().matches(methodName + \"\\\\..+\\\\.class\")) try {\n+                    ClassPrinter.toYaml(ClassFile.of().parse(p),\n+                                        ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES,\n+                                        System.out::print);\n+                } catch (IOException ignore) {}\n+            });\n+            throw e;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":739,"deletions":0,"binary":false,"changes":739,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.StringWriter;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import java.lang.classfile.instruction.*;\n+import java.lang.invoke.MethodHandles;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.bytecode.BytecodeLift;\n+import jdk.incubator.code.interpreter.Verifier;\n+import jdk.incubator.code.op.CoreOp;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.testng.Assert;\n+import org.testng.annotations.Ignore;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @modules java.base\/java.lang.invoke:open\n+ * @modules java.base\/jdk.internal.classfile.components\n+ * @enablePreview\n+ * @run testng TestSmallCorpus\n+ *\/\n+public class TestSmallCorpus {\n+\n+    private static final String ROOT_PATH = \"modules\/java.base\/\";\n+    private static final String CLASS_NAME_SUFFIX = \".class\";\n+    private static final String METHOD_NAME = null;\n+    private static final int ROUNDS = 3;\n+\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+    private static final ClassFile CF = ClassFile.of();\n+    private static final int COLUMN_WIDTH = 150;\n+    private static final MethodHandles.Lookup TRUSTED_LOOKUP;\n+    static {\n+        try {\n+            var lf = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n+            lf.setAccessible(true);\n+            TRUSTED_LOOKUP = (MethodHandles.Lookup)lf.get(null);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private MethodModel bytecode;\n+    CoreOp.FuncOp reflection;\n+    private int stable, unstable;\n+    private Long[] stats = new Long[6];\n+\n+    @Ignore\n+    @Test\n+    public void testRoundTripStability() throws Exception {\n+        stable = 0;\n+        unstable = 0;\n+        Arrays.fill(stats, 0l);\n+        for (Path p : Files.walk(JRT.getPath(ROOT_PATH))\n+                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(CLASS_NAME_SUFFIX))\n+                .toList()) {\n+            testRoundTripStability(p);\n+        }\n+\n+        System.out.println(\"\"\"\n+        statistics     original  generated\n+        code length: %1$,10d %4$,10d\n+        max locals:  %2$,10d %5$,10d\n+        max stack:   %3$,10d %6$,10d\n+        \"\"\".formatted((Object[])stats));\n+\n+        \/\/ Roundtrip is 100% stable after 3 rounds, no exceptions, no verification errors\n+        Assert.assertTrue(stable > 54500 && unstable == 0, String.format(\"stable: %d unstable: %d\", stable, unstable));\n+    }\n+\n+    private void testRoundTripStability(Path path) throws Exception {\n+        var clm = CF.parse(path);\n+        for (var originalModel : clm.methods()) {\n+            if (originalModel.code().isPresent() && (METHOD_NAME == null || originalModel.methodName().equalsString(METHOD_NAME))) try {\n+                bytecode = originalModel;\n+                reflection = null;\n+                MethodModel prevBytecode = null;\n+                CoreOp.FuncOp prevReflection = null;\n+                for (int round = 1; round <= ROUNDS; round++) try {\n+                    prevBytecode = bytecode;\n+                    prevReflection = reflection;\n+                    lift();\n+                    verifyReflection();\n+                    generate();\n+                    verifyBytecode();\n+                } catch (UnsupportedOperationException uoe) {\n+                    throw uoe;\n+                } catch (Throwable t) {\n+                    System.out.println(\" at \" + path + \" \" + originalModel.methodName() + originalModel.methodType() + \" round \" + round);\n+                    throw t;\n+                }\n+                if (ROUNDS > 0) {\n+                    var normPrevBytecode = normalize(prevBytecode);\n+                    var normBytecode = normalize(bytecode);\n+                    if (normPrevBytecode.equals(normBytecode)) {\n+                        stable++;\n+                    } else {\n+                        unstable++;\n+                        System.out.println(\"Unstable code \" + path + \" \" + originalModel.methodName() + originalModel.methodType() + \" after \" + ROUNDS +\" round(s)\");\n+                        if (prevReflection != null) printInColumns(prevReflection, reflection);\n+                        printInColumns(normPrevBytecode, normBytecode);\n+                        System.out.println();\n+                    }\n+                    var ca = (CodeAttribute)originalModel.code().get();\n+                    stats[0] += ca.codeLength();\n+                    stats[1] += ca.maxLocals();\n+                    stats[2] += ca.maxStack();\n+                    ca = (CodeAttribute)bytecode.code().get();\n+                    stats[3] += ca.codeLength();\n+                    stats[4] += ca.maxLocals();\n+                    stats[5] += ca.maxStack();\n+                }\n+            } catch (UnsupportedOperationException uoe) {\n+                \/\/ InvokeOp when InvokeKind == SUPER\n+            }\n+        }\n+    }\n+\n+    private void verifyReflection() {\n+        var errors = Verifier.verify(TRUSTED_LOOKUP, reflection);\n+        if (!errors.isEmpty()) {\n+            printBytecode();\n+            System.out.println(\"Code reflection model verification failed:\");\n+            errors.forEach(e -> System.out.println(e.getMessage()));\n+            System.out.println(errors.getFirst().getPrintedContext());\n+            throw new AssertionError(\"Code reflection model verification failed\");\n+        }\n+    }\n+\n+    private void verifyBytecode() {\n+        var errors = ClassFile.of().verify(bytecode.parent().get()).stream()\n+                .filter(e -> !e.getMessage().contains(\"Illegal call to internal method\")).toList();\n+        if (!errors.isEmpty()) {\n+            printReflection();\n+            System.out.println(\"Bytecode verification failed:\");\n+            errors.forEach(e -> System.out.println(e.getMessage()));\n+            printBytecode();\n+            throw new AssertionError(\"Bytecode verification failed\");\n+        }\n+    }\n+\n+    private static void printInColumns(CoreOp.FuncOp first, CoreOp.FuncOp second) {\n+        StringWriter fw = new StringWriter();\n+        first.writeTo(fw);\n+        StringWriter sw = new StringWriter();\n+        second.writeTo(sw);\n+        printInColumns(fw.toString().lines().toList(), sw.toString().lines().toList());\n+    }\n+\n+    private static void printInColumns(List<String> first, List<String> second) {\n+        System.out.println(\"-\".repeat(COLUMN_WIDTH ) + \"--+-\" + \"-\".repeat(COLUMN_WIDTH ));\n+        for (int i = 0; i < first.size() || i < second.size(); i++) {\n+            String f = i < first.size() ? first.get(i) : \"\";\n+            String s = i < second.size() ? second.get(i) : \"\";\n+            System.out.println(\" \" + f + (f.length() < COLUMN_WIDTH ? \" \".repeat(COLUMN_WIDTH - f.length()) : \"\") + (f.equals(s) ? \" | \" : \" x \") + s);\n+        }\n+    }\n+\n+    private void lift() {\n+        try {\n+            reflection = BytecodeLift.lift(bytecode);\n+        } catch (Throwable t) {\n+            printReflection();\n+            printBytecode();\n+            System.out.println(\"Lift failed\");\n+            throw t;\n+        }\n+    }\n+\n+    private void generate() {\n+        try {\n+            bytecode = CF.parse(BytecodeGenerator.generateClassData(\n+                TRUSTED_LOOKUP,\n+                reflection)).methods().getFirst();\n+        } catch (UnsupportedOperationException uoe) {\n+            throw uoe;\n+        } catch (Throwable t) {\n+            printBytecode();\n+            printReflection();\n+            System.out.println(\"Generation failed\");\n+            throw t;\n+        }\n+    }\n+\n+    private void printBytecode() {\n+        ClassPrinter.toYaml(bytecode, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+    }\n+\n+    private void printReflection() {\n+        if (reflection != null) System.out.println(reflection.toText());\n+    }\n+\n+    public static List<String> normalize(MethodModel mm) {\n+        record El(int index, String format, Label... targets) {\n+            public El(int index, Instruction i, Object format, Label... targets) {\n+                this(index, trim(i.opcode()) + \" \" + format, targets);\n+            }\n+            public String toString(Map<Label, Integer> targetsMap) {\n+                return \"%3d: \".formatted(index) + (targets.length == 0 ? format : format.formatted(Stream.of(targets).map(l -> targetsMap.get(l)).toArray()));\n+            }\n+        }\n+\n+        Map<Label, Integer> targetsMap = new HashMap<>();\n+        List<El> elements = new ArrayList<>();\n+        Label lastLabel = null;\n+        int i = 0;\n+        for (var e : mm.code().orElseThrow()) {\n+            var er = switch (e) {\n+                case LabelTarget lt -> {\n+                    lastLabel = lt.label();\n+                    yield null;\n+                }\n+                case ExceptionCatch ec ->\n+                    new El(i++, \"ExceptionCatch start: @%d end: @%d handler: @%d\" + ec.catchType().map(ct -> \" catch type: \" + ct.asInternalName()).orElse(\"\"), ec.tryStart(), ec.tryEnd(), ec.handler());\n+                case BranchInstruction ins ->\n+                    new El(i++, ins, \"@%d\", ins.target());\n+                case ConstantInstruction ins ->\n+                    new El(i++, \"LDC \" + ins.constantValue());\n+                case FieldInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \".\" + ins.name().stringValue());\n+                case InvokeDynamicInstruction ins ->\n+                    new El(i++, ins, ins.name().stringValue() + ins.typeSymbol() + \" \" + ins.bootstrapMethod() + \"(\" + ins.bootstrapArgs() + \")\");\n+                case InvokeInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \"::\" + ins.name().stringValue() + ins.typeSymbol().displayDescriptor());\n+                case LoadInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case StoreInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case IncrementInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot() + \" \" + ins.constant());\n+                case LookupSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case NewMultiArrayInstruction ins ->\n+                    new El(i++, ins, ins.arrayType().asInternalName() + \"(\" + ins.dimensions() + \")\");\n+                case NewObjectInstruction ins ->\n+                    new El(i++, ins, ins.className().asInternalName());\n+                case NewPrimitiveArrayInstruction ins ->\n+                    new El(i++, ins, ins.typeKind());\n+                case NewReferenceArrayInstruction ins ->\n+                    new El(i++, ins, ins.componentType().asInternalName());\n+                case TableSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case TypeCheckInstruction ins ->\n+                    new El(i++, ins, ins.type().asInternalName());\n+                case Instruction ins ->\n+                    new El(i++, ins, \"\");\n+                default -> null;\n+            };\n+            if (er != null) {\n+                if (lastLabel != null) {\n+                    targetsMap.put(lastLabel, elements.size());\n+                    lastLabel = null;\n+                }\n+                elements.add(er);\n+            }\n+        }\n+        return elements.stream().map(el -> el.toString(targetsMap)).toList();\n+    }\n+\n+    private static String trim(Opcode opcode) {\n+        var name = opcode.toString();\n+        int i = name.indexOf('_');\n+        return i > 2 ? name.substring(0, i) : name;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.op.CoreOp;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules jdk.incubator.code\n+ * @modules java.base\/jdk.internal.classfile.components\n+ * @run testng TestVarArg\n+ *\n+ *\/\n+public class TestVarArg {\n+\n+    @Test\n+    void test() throws Throwable {\n+        var f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        var lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        var bytes = BytecodeGenerator.generateClassData(MethodHandles.lookup(), f);\n+        var classModel = ClassFile.of().parse(bytes);\n+        ClassPrinter.toYaml(classModel, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+\n+        MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        Assert.assertEquals(mh.invoke(), f());\n+    }\n+\n+    @CodeReflection\n+    static String f() {\n+        String r = \"\";\n+        String ls = System.lineSeparator();\n+\n+        r += ls + h(1);\n+        r += ls + h(2, 3);\n+        r += ls + h(4, (byte) 5);\n+\n+        r += ls + k(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+\n+        r += ls + j(\"s1\", \"s2\", \"s3\");\n+\n+        r += ls + w(8, 9);\n+\n+        r += k();\n+\n+        r += l(11L, 12L);\n+\n+        r += d(21.0, 22.0);\n+\n+        return r;\n+    }\n+\n+    static String h(int i, int... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static String k(byte... s) {\n+        return Arrays.toString(s);\n+    }\n+\n+    static String j(String i, String... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static <T extends Number> String w(T... ts) {\n+        return Arrays.toString(ts);\n+    }\n+\n+    static String l(long... a) {\n+        return Arrays.toString(a);\n+    }\n+\n+    static String d(double... a) {\n+        return Arrays.toString(a);\n+    }\n+\n+    private CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(this.getClass().getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return Op.ofMethod(m).get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -215,0 +215,7 @@\n+compiler.misc.feature.reflect.methods                         # code reflection\n+compiler.note.method.ir.dump                                  # code reflection\n+compiler.note.method.ir.skip                                  # code reflection\n+compiler.err.cant.infer.quoted.lambda.return.type             # code reflection\n+compiler.err.quoted.lambda.must.be.explicit                   # code reflection\n+compiler.note.quoted.ir.dump                                  # code reflection\n+compiler.note.quoted.ir.skip                                  # code reflection\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}