{"files":[{"patch":"@@ -58,1 +58,1 @@\n-            this.kernelContext =KernelContext.create(c99NativeBackend.arena,kernelCallGraph.computeContext.accelerator.lookup,0,0);\n+            this.kernelContext =KernelContext.create(c99NativeBackend,0,0);\n@@ -64,1 +64,0 @@\n-         \/\/   KernelContext kernelContext = (KernelContext) args[0];\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/C99NativeBackend.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.Accelerator;\n@@ -29,4 +28,0 @@\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n@@ -35,1 +30,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -37,3 +31,0 @@\n-\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n@@ -41,3 +32,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n@@ -45,3 +33,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-\n@@ -53,9 +38,0 @@\n-             \/*   MemoryLayout layout = MemoryLayout.structLayout(\n-                        ADDRESS.withName(\"address\"), \/\/ segment ptr\n-                        JAVA_LONG.withName(\"bytes\"),\n-                        ADDRESS.withName(\"vendorPtr\"), \/\/ CLBuf *buf;   CUdeviceptr buf; void *buf ?\n-                        JAVA_BYTE.withName(\"access\"), \/\/0=??\/1=RO\/2=WO\/3=RW\n-                        JAVA_BYTE.withName(\"state\"), \/\/0=UNKNOWN\/1=GPUDIRTY\/2=JAVADIRTY\n-                        MemoryLayout.paddingLayout(16 - JAVA_BYTE.byteSize() - JAVA_BYTE.byteSize())\n-                ).withName(Buf.class.getSimpleName()); *\/\n-\n@@ -81,1 +57,0 @@\n-\n@@ -84,14 +59,0 @@\n-           \/* MemoryLayout layout = MemoryLayout.unionLayout(\n-                    JAVA_BOOLEAN.withName(\"z1\"),\n-                    JAVA_BYTE.withName(\"s8\"),\n-                    JAVA_CHAR.withName(\"u16\"),\n-                    JAVA_SHORT.withName(\"s16\"),\n-                    JAVA_INT.withName(\"s32\"),\n-                    JAVA_INT.withName(\"u32\"),\n-                    JAVA_FLOAT.withName(\"f32\"),\n-                    JAVA_LONG.withName(\"s64\"),\n-                    JAVA_LONG.withName(\"u64\"),\n-                    JAVA_DOUBLE.withName(\"f64\"),\n-                    Buf.layout.withName(\"buf\")\n-            ).withName(Value.class.getSimpleName());*\/\n-\n@@ -141,7 +102,0 @@\n-      \/*  MemoryLayout layout = MemoryLayout.structLayout(\n-                JAVA_INT.withName(\"idx\"),      \/\/4\n-                JAVA_BYTE.withName(\"variant\"), \/\/5\n-                MemoryLayout.paddingLayout(16 - JAVA_INT.byteSize() - JAVA_BYTE.byteSize()),\n-                Value.layout.withName(\"value\")\n-        ).withName(Arg.class.getSimpleName());*\/\n-\n@@ -263,0 +217,16 @@\n+    int argc();\n+\n+    void argc(int argc);\n+\n+    int schemaLen();\n+\n+    void schemaLen(int schemaLen);\n+\n+    byte schemaBytes(long idx);\n+\n+    void schemaBytes(long idx, byte b);\n+    Arg arg(long idx);\n+\n+    MemorySegment vendorPtr();\n+\n+    void vendorPtr(MemorySegment vendorPtr);\n@@ -298,28 +268,0 @@\n-    static void update(ArgArray argArray, Object... args) {\n-        for (int i = 0; i < args.length; i++) {\n-            Object argObject = args[i];\n-            Arg arg = argArray.arg(i);\n-            arg.idx(i);\n-            switch (argObject) {\n-                case Boolean z1 -> arg.z1(z1);\n-                case Byte s8 -> arg.s8(s8);\n-                case Short s16 -> arg.s16(s16);\n-                case Character u16 -> arg.u16(u16);\n-                case Float f32 -> arg.f32(f32);\n-                case Integer s32 -> arg.s32(s32);\n-                case Long s64 -> arg.s64(s64);\n-                case Double f64 -> arg.f64(f64);\n-                case Buffer buffer -> {\n-                    MemorySegment segment = Buffer.getMemorySegment(buffer);\n-                    arg.variant((byte) '&');\n-                    Arg.Value value = arg.value();\n-                    Arg.Value.Buf buf = value.buf();\n-                    buf.address(segment);\n-                    buf.bytes(segment.byteSize());\n-                }\n-                default -> throw new IllegalStateException(\"Unexpected value: \" + argObject);\n-            }\n-\n-        }\n-    }\n-\n@@ -351,23 +293,1 @@\n-\/*\n-        ArgArray argArray1 = bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), ArgArray.class,\n-                JAVA_INT.withName(\"argc\"),\n-                MemoryLayout.paddingLayout(16 - JAVA_INT.byteSize()),\n-                MemoryLayout.sequenceLayout(args.length, Arg.layout).withName(\"arg\"),\n-                ADDRESS.withName(\"vendorPtr\"),\n-                JAVA_INT.withName(\"schemaLen\"),\n-                MemoryLayout.sequenceLayout(schemaStr.length() + 1, JAVA_BYTE).withName(\"schemaBytes\")\n-        ));\n-        argArray1.argc(args.length);\n-        argArray1.setSchemaBytes(schemaStr);\n-\n-        String layout = Buffer.getLayout(argArray1).toString();\n-        *\/\n-        var boundSchema = schema.boundSchema(args.length,schemaStr.length() + 1);\n-      \/*  String layoutFromSchema = boundSchema.groupLayout.toString();\n-         if (!layoutFromSchema.equals(layout)){\n-            System.err.println(\"          layout:\"+layout);\n-            System.err.println(\"          schema:\"+layoutFromSchema);\n-           \/\/ System.exit(1);\n-\n-         } *\/\n-        ArgArray argArray = boundSchema.allocate(bufferAllocator);\n+        ArgArray argArray = schema.allocate(bufferAllocator,args.length,schemaStr.length() + 1);\n@@ -376,0 +296,5 @@\n+        update(argArray, args);\n+        return argArray;\n+    }\n+\n+    static void update(ArgArray argArray, Object... args) {\n@@ -399,1 +324,0 @@\n-\n@@ -401,1 +325,0 @@\n-        return argArray;\n@@ -404,11 +327,0 @@\n-    int argc();\n-\n-    void argc(int argc);\n-\n-    int schemaLen();\n-\n-    void schemaLen(int schemaLen);\n-\n-    byte schemaBytes(long idx);\n-\n-    void schemaBytes(long idx, byte b);\n@@ -435,6 +347,0 @@\n-    Arg arg(long idx);\n-\n-    MemorySegment vendorPtr();\n-\n-    void vendorPtr(MemorySegment vendorPtr);\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":22,"deletions":116,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import hat.ifacemapper.Schema;\n@@ -14,4 +15,6 @@\n-    StructLayout layout = MemoryLayout.structLayout(\n-            JAVA_INT.withName(\"x\"),\n-            JAVA_INT.withName(\"maxX\")\n-    ).withName(KernelContext.class.getSimpleName());\n+    int x();\n+    void x(int x);\n+    int maxX();\n+    void maxX(int maxX);\n+\n+    Schema<KernelContext> schema = Schema.of(KernelContext.class, s->s.fields(\"x\",\"maxX\"));\n@@ -19,3 +22,2 @@\n-    static KernelContext create(Arena arena, MethodHandles.Lookup lookup, int x, int maxX) {\n-        KernelContext kernelContext = SegmentMapper.of(lookup, KernelContext.class,layout).allocate(arena, new HatData() {\n-        });\n+    static KernelContext create(BufferAllocator bufferAllocator, int x, int maxX) {\n+        KernelContext kernelContext =  schema.allocate(bufferAllocator);\n@@ -26,4 +28,1 @@\n-    int x();\n-    void x(int x);\n-    int maxX();\n-    void maxX(int maxX);\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/KernelContext.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"}]}