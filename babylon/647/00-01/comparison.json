{"files":[{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.annotations;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target({ElementType.TYPE_USE})\n-public @interface HATVectorType {\n-    String primitiveType() default \"float\";\n-    int lanes() default 0;\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/annotations\/HATVectorType.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.lang.reflect.Method;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+public class HATPhaseUtils {\n+\n+    public static TypeElement getVectorElementType(String primitive) {\n+        return switch (primitive) {\n+            case \"float\" -> JavaType.FLOAT;\n+            case \"double\" -> JavaType.DOUBLE;\n+            case \"int\" -> JavaType.INT;\n+            case \"long\" -> JavaType.LONG;\n+            case \"short\" -> JavaType.SHORT;\n+            case \"byte\" -> JavaType.BYTE;\n+            case \"char\" -> JavaType.CHAR;\n+            case \"boolean\" -> JavaType.BOOLEAN;\n+            default -> null;\n+        };\n+    }\n+\n+    public record VectorMetaData(TypeElement vectorTypeElement, int lanes) {\n+    }\n+\n+    public static VectorMetaData getVectorTypeInfo(JavaOp.InvokeOp invokeOp, int param) {\n+        Value varValue = invokeOp.operands().get(param);\n+        if (varValue instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return getVectorTypeInfoWithCodeReflection(varLoadOp.resultType());\n+        }\n+        return null;\n+    }\n+\n+    public static VectorMetaData getVectorTypeInfo(JavaOp.InvokeOp invokeOp) {\n+        return getVectorTypeInfoWithCodeReflection(invokeOp.resultType());\n+    }\n+\n+    private static CoreOp.FuncOp buildCodeModelFor(Class<?> klass, String methodName) {\n+        Optional<Method> methodFunction = Stream.of(klass.getMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+        return Op.ofMethod(methodFunction.get()).get();\n+    }\n+\n+    \/**\n+     * This method inspects the Vector Type Methods to obtain two methods for code-model:\n+     * 1) Method `type` to obtain the primitive base type of the vector type.\n+     * 2) Method `width` to obtain the number of lanes.\n+     *\n+     * @param typeElement\n+     *  {@link TypeElement}\n+     * @return\n+     * {@link VectorMetaData}\n+     *\/\n+    public static VectorMetaData getVectorTypeInfoWithCodeReflection(TypeElement typeElement) {\n+        Class<?> aClass;\n+        try {\n+            aClass = Class.forName(typeElement.toString());\n+        } catch (ClassNotFoundException e) {\n+            \/\/ TODO: Add control for exceptions in HAT (HATExceptions Handler)\n+            throw new RuntimeException(e);\n+        }\n+        CoreOp.FuncOp codeModelType = buildCodeModelFor(aClass, \"type\");\n+        AtomicReference<TypeElement> vectorElement = new AtomicReference<>();\n+        codeModelType.elements().forEach(codeElement -> {\n+            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n+                Value v = returnOp.operands().getFirst();\n+                if (v instanceof Op.Result r && r.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                    String primitiveTypeName = fieldLoadOp.fieldDescriptor().name();\n+                    vectorElement.set(getVectorElementType(primitiveTypeName.toLowerCase()));\n+                }\n+            }\n+        });\n+\n+        AtomicInteger lanes = new AtomicInteger(1);\n+        CoreOp.FuncOp codeModelWidth = buildCodeModelFor(aClass, \"width\");\n+        codeModelWidth.elements().forEach(codeElement -> {\n+            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n+                Value v = returnOp.operands().getFirst();\n+                if (v instanceof Op.Result r && r.op() instanceof CoreOp.ConstantOp constantOp) {\n+                    lanes.set((Integer) constantOp.value());\n+                }\n+            }\n+        });\n+        return new VectorMetaData(vectorElement.get(), lanes.get());\n+    }\n+\n+    public static int getWitdh(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return getWitdh(varLoadOp.operands().getFirst());\n+    }\n+\n+    public static int getWitdh(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return getWitdh(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.vectorN();\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    public static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findVectorTypeElement(varLoadOp.operands().getFirst());\n+    }\n+\n+    public static TypeElement findVectorTypeElement(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findVectorTypeElement(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.vectorElementType;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().getFirst());\n+    }\n+\n+    public static String findNameVector(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findNameVector(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPhaseUtils.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-import java.lang.reflect.Method;\n-import java.util.Optional;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.stream.Stream;\n-\n-public class Utils {\n-\n-    public static TypeElement getVectorElementType(String primitive) {\n-        return switch (primitive) {\n-            case \"float\" -> JavaType.FLOAT;\n-            case \"double\" -> JavaType.DOUBLE;\n-            case \"int\" -> JavaType.INT;\n-            case \"long\" -> JavaType.LONG;\n-            case \"short\" -> JavaType.SHORT;\n-            case \"byte\" -> JavaType.BYTE;\n-            case \"char\" -> JavaType.CHAR;\n-            case \"boolean\" -> JavaType.BOOLEAN;\n-            default -> null;\n-        };\n-    }\n-\n-    public record VectorMetaData(TypeElement vectorTypeElement, int lanes) {\n-    }\n-\n-    public static VectorMetaData getVectorTypeInfo(JavaOp.InvokeOp invokeOp, int param) {\n-        Value varValue = invokeOp.operands().get(param);\n-        if (varValue instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            \/\/return getVectorMetaData(varLoadOp.resultType());\n-            return getVectorTypeInfoWithCodeReflection(varLoadOp.resultType());\n-        }\n-        return null;\n-    }\n-\n-    public static VectorMetaData getVectorTypeInfo(JavaOp.InvokeOp invokeOp) {\n-        \/\/return getVectorMetaData(invokeOp.resultType());\n-        return getVectorTypeInfoWithCodeReflection(invokeOp.resultType());\n-    }\n-\n-\n-    private static CoreOp.FuncOp buildCodeModelFor(Class<?> klass, String methodName) {\n-        Optional<Method> myFunction = Stream.of(klass.getMethods())\n-                .filter(m -> m.getName().equals(methodName))\n-                .findFirst();\n-        Method method = myFunction.get();\n-        return Op.ofMethod(method).get();\n-    }\n-\n-    public static VectorMetaData getVectorTypeInfoWithCodeReflection(TypeElement typeElement) {\n-        Class<?> aClass;\n-        try {\n-            aClass = Class.forName(typeElement.toString());\n-        } catch (ClassNotFoundException e) {\n-            \/\/ TODO: Add control for exceptions in HAT (HATExceptions Handler)\n-            throw new RuntimeException(e);\n-        }\n-        CoreOp.FuncOp codeModelType = buildCodeModelFor(aClass, \"type\");\n-        AtomicReference<TypeElement> vectorElement = new AtomicReference<>();\n-        codeModelType.elements().forEach(codeElement -> {\n-            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n-                Value v = returnOp.operands().getFirst();\n-                if (v instanceof Op.Result r && r.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                    String primitiveTypeName = fieldLoadOp.fieldDescriptor().name();\n-                    vectorElement.set(getVectorElementType(primitiveTypeName.toLowerCase()));\n-                }\n-            }\n-        });\n-\n-        AtomicInteger lanes = new AtomicInteger(1);\n-        CoreOp.FuncOp codeModelWidth = buildCodeModelFor(aClass, \"width\");\n-        codeModelWidth.elements().forEach(codeElement -> {\n-            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n-                Value v = returnOp.operands().getFirst();\n-                if (v instanceof Op.Result r && r.op() instanceof CoreOp.ConstantOp constantOp) {\n-                    lanes.set((Integer) constantOp.value());\n-                }\n-            }\n-        });\n-        return new VectorMetaData(vectorElement.get(), lanes.get());\n-    }\n-\n-\/\/    public static VectorMetaData getVectorMetaData(TypeElement typeElement) {\n-\/\/        try {\n-\/\/            Class<?> aClass = Class.forName(typeElement.toString());\n-\/\/            if (!aClass.isPrimitive()) {\n-\/\/                Annotation[] annotations = aClass.getAnnotations();\n-\/\/                for (Annotation annotation : annotations) {\n-\/\/                    if (annotation instanceof HATVectorType hatVectorType) {\n-\/\/                        return new VectorMetaData(getVectorElementType(hatVectorType.primitiveType()), hatVectorType.lanes());\n-\/\/                    }\n-\/\/                }\n-\/\/            }\n-\/\/        } catch (ClassNotFoundException _) {\n-\/\/        }\n-\/\/        return null;\n-\/\/    }\n-\n-\n-    public static int getWitdh(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return getWitdh(varLoadOp.operands().getFirst());\n-    }\n-\n-    public static int getWitdh(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return getWitdh(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.vectorN();\n-            }\n-            return -1;\n-        }\n-    }\n-\n-    public static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findVectorTypeElement(varLoadOp.operands().getFirst());\n-    }\n-\n-    public static TypeElement findVectorTypeElement(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findVectorTypeElement(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.vectorElementType;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().getFirst());\n-    }\n-\n-    public static String findNameVector(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findNameVector(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.varName();\n-            }\n-            return null;\n-        }\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/Utils.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -60,2 +60,5 @@\n-import static hat.dialect.Utils.*;\n-import static hat.dialect.Utils.getVectorTypeInfo;\n+import static hat.dialect.HATPhaseUtils.VectorMetaData;\n+import static hat.dialect.HATPhaseUtils.findNameVector;\n+import static hat.dialect.HATPhaseUtils.findVectorTypeElement;\n+import static hat.dialect.HATPhaseUtils.getVectorTypeInfo;\n+import static hat.dialect.HATPhaseUtils.getWitdh;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.dialect.Utils;\n+import hat.dialect.HATPhaseUtils;\n@@ -138,1 +138,1 @@\n-                Utils.VectorMetaData vectorMetaData  = Utils.getVectorTypeInfo(invokeOp, 1);\n+                HATPhaseUtils.VectorMetaData vectorMetaData  = HATPhaseUtils.getVectorTypeInfo(invokeOp, 1);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}