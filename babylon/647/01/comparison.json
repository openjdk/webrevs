{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import hat.types._V4;\n@@ -28,0 +29,2 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -32,1 +35,1 @@\n-public interface Float4 extends HatVector {\n+public interface Float4 extends _V4 {\n@@ -39,0 +42,6 @@\n+    @CodeReflection\n+    @Override\n+    default PrimitiveType type() {\n+        return JavaType.FLOAT;\n+    }\n+\n@@ -107,1 +116,0 @@\n-    @CodeReflection\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/Float4.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-public interface HatVector extends Buffer {\n+public interface HATVector {\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/HATVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/buffer\/HatVector.java","status":"renamed"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.lang.reflect.Method;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+public class HATPhaseUtils {\n+\n+    public static TypeElement getVectorElementType(String primitive) {\n+        return switch (primitive) {\n+            case \"float\" -> JavaType.FLOAT;\n+            case \"double\" -> JavaType.DOUBLE;\n+            case \"int\" -> JavaType.INT;\n+            case \"long\" -> JavaType.LONG;\n+            case \"short\" -> JavaType.SHORT;\n+            case \"byte\" -> JavaType.BYTE;\n+            case \"char\" -> JavaType.CHAR;\n+            case \"boolean\" -> JavaType.BOOLEAN;\n+            default -> null;\n+        };\n+    }\n+\n+    public record VectorMetaData(TypeElement vectorTypeElement, int lanes) {\n+    }\n+\n+    public static VectorMetaData getVectorTypeInfo(JavaOp.InvokeOp invokeOp, int param) {\n+        Value varValue = invokeOp.operands().get(param);\n+        if (varValue instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return getVectorTypeInfoWithCodeReflection(varLoadOp.resultType());\n+        }\n+        return null;\n+    }\n+\n+    public static VectorMetaData getVectorTypeInfo(JavaOp.InvokeOp invokeOp) {\n+        return getVectorTypeInfoWithCodeReflection(invokeOp.resultType());\n+    }\n+\n+    private static CoreOp.FuncOp buildCodeModelFor(Class<?> klass, String methodName) {\n+        Optional<Method> methodFunction = Stream.of(klass.getMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+        return Op.ofMethod(methodFunction.get()).get();\n+    }\n+\n+    \/**\n+     * This method inspects the Vector Type Methods to obtain two methods for code-model:\n+     * 1) Method `type` to obtain the primitive base type of the vector type.\n+     * 2) Method `width` to obtain the number of lanes.\n+     *\n+     * @param typeElement\n+     *  {@link TypeElement}\n+     * @return\n+     * {@link VectorMetaData}\n+     *\/\n+    public static VectorMetaData getVectorTypeInfoWithCodeReflection(TypeElement typeElement) {\n+        Class<?> aClass;\n+        try {\n+            aClass = Class.forName(typeElement.toString());\n+        } catch (ClassNotFoundException e) {\n+            \/\/ TODO: Add control for exceptions in HAT (HATExceptions Handler)\n+            throw new RuntimeException(e);\n+        }\n+        CoreOp.FuncOp codeModelType = buildCodeModelFor(aClass, \"type\");\n+        AtomicReference<TypeElement> vectorElement = new AtomicReference<>();\n+        codeModelType.elements().forEach(codeElement -> {\n+            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n+                Value v = returnOp.operands().getFirst();\n+                if (v instanceof Op.Result r && r.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                    String primitiveTypeName = fieldLoadOp.fieldDescriptor().name();\n+                    vectorElement.set(getVectorElementType(primitiveTypeName.toLowerCase()));\n+                }\n+            }\n+        });\n+\n+        AtomicInteger lanes = new AtomicInteger(1);\n+        CoreOp.FuncOp codeModelWidth = buildCodeModelFor(aClass, \"width\");\n+        codeModelWidth.elements().forEach(codeElement -> {\n+            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n+                Value v = returnOp.operands().getFirst();\n+                if (v instanceof Op.Result r && r.op() instanceof CoreOp.ConstantOp constantOp) {\n+                    lanes.set((Integer) constantOp.value());\n+                }\n+            }\n+        });\n+        return new VectorMetaData(vectorElement.get(), lanes.get());\n+    }\n+\n+    public static int getWitdh(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return getWitdh(varLoadOp.operands().getFirst());\n+    }\n+\n+    public static int getWitdh(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return getWitdh(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.vectorN();\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    public static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findVectorTypeElement(varLoadOp.operands().getFirst());\n+    }\n+\n+    public static TypeElement findVectorTypeElement(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findVectorTypeElement(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.vectorElementType;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().getFirst());\n+    }\n+\n+    public static String findNameVector(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findNameVector(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPhaseUtils.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -37,2 +37,2 @@\n-    public HATVectorAddOp(String varName, TypeElement typeElement, List<Value> operands) {\n-        super(varName, typeElement, OpType.ADD, operands);\n+    public HATVectorAddOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n+        super(varName, typeElement, OpType.ADD, vectorElementType, width, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorAddOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,4 +54,2 @@\n-    public HATVectorBinaryOp(String varName, TypeElement typeElement, OpType operationType, List<Value> operands) {\n-        int l = typeElement.toString().length();\n-        int vectorN = Integer.parseInt(typeElement.toString().substring(l - 1, l));\n-        super(varName, typeElement, vectorN, operands);\n+    public HATVectorBinaryOp(String varName, TypeElement typeElement, OpType operationType, TypeElement vectorElementType, int width, List<Value> operands) {\n+        super(varName, typeElement, vectorElementType, width, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorBinaryOp.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    public HATVectorDivOp(String varName, TypeElement typeElement, List<Value> operands) {\n-        super(varName, typeElement, OpType.DIV, operands);\n+    public HATVectorDivOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n+        super(varName, typeElement, OpType.DIV, vectorElementType, width, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorDivOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        super(varName, typeElement, loadN, operands);\n+        super(varName, typeElement, vectorType, loadN, operands);\n@@ -77,8 +77,0 @@\n-\n-    public String buildType() {\n-        \/\/ floatN\n-        if (vectorType.toString().startsWith(\"hat.buffer.Float\")) {\n-            return \"float\" + loadN;\n-        }\n-        throw new RuntimeException(\"Unexpected vector type \" + vectorType);\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorLoadOp.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        super(varName, typeElement, loadN, operands);\n+        super(varName, typeElement, typeElement, loadN, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorMakeOfOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    public HATVectorMulOp(String varName, TypeElement typeElement, List<Value> operands) {\n-        super(varName, typeElement, OpType.MUL, operands);\n+    public HATVectorMulOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n+        super(varName, typeElement, OpType.MUL, vectorElementType, width, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorMulOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-    public HATVectorOfOp(TypeElement typeElement, int loadN, List<Value> operands) {\n-        super(\"\", typeElement, loadN, operands);\n+    public HATVectorOfOp(TypeElement typeElement, TypeElement vectorTypeElement, int loadN, List<Value> operands) {\n+        super(\"\", typeElement, vectorTypeElement, loadN, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorOfOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,3 +35,4 @@\n-    private String varName;\n-    private final TypeElement typeElement;\n-    private final int vectorN;\n+    protected String varName;\n+    protected final TypeElement typeElement;\n+    protected final int vectorN;\n+    protected final TypeElement vectorElementType;\n@@ -39,1 +40,1 @@\n-    public HATVectorOp(String varName, TypeElement typeElement, int vectorN, List<Value> operands) {\n+    public HATVectorOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int vectorN, List<Value> operands) {\n@@ -44,0 +45,1 @@\n+        this.vectorElementType = vectorElementType;\n@@ -51,0 +53,1 @@\n+        this.vectorElementType = that.vectorElementType;\n@@ -71,14 +74,0 @@\n-    public enum VectorType {\n-        FLOAT4(\"float4\");\n-\n-        private final String type;\n-\n-        VectorType(String type) {\n-            this.type = type;\n-        }\n-\n-        public String type() {\n-            return type;\n-        }\n-    }\n-\n@@ -86,5 +75,1 @@\n-        \/\/ floatN\n-        if (typeElement.toString().startsWith(\"hat.buffer.Float\")) {\n-            return \"float\" + vectorN;\n-        }\n-        throw new RuntimeException(\"Unexpected vector type \" + typeElement);\n+        return vectorElementType.toString() + vectorN;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorOp.java","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        super(varName, typeElement, -1, operands);\n+        super(varName, typeElement, typeElement, -1, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSelectLoadOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        super(varName, typeElement, -1, operands);\n+        super(varName, typeElement, typeElement, -1, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSelectStoreOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-    private final TypeElement elementType;\n-    private final int storeN;\n@@ -41,1 +39,0 @@\n-    private final VectorType vectorType;\n@@ -43,4 +40,2 @@\n-    public HATVectorStoreView(String varName, TypeElement elementType, int storeN, VectorType vectorType, boolean isSharedOrPrivate, List<Value> operands) {\n-        super(varName, elementType, storeN, operands);\n-        this.elementType = elementType;\n-        this.storeN = storeN;\n+    public HATVectorStoreView(String varName, TypeElement elementType, int storeN, TypeElement vectorElementType, boolean isSharedOrPrivate, List<Value> operands) {\n+        super(varName, elementType, vectorElementType, storeN, operands);\n@@ -48,1 +43,0 @@\n-        this.vectorType = vectorType;\n@@ -53,2 +47,0 @@\n-        this.elementType = op.elementType;\n-        this.storeN = op.storeN;\n@@ -56,1 +48,0 @@\n-        this.vectorType = op.vectorType;\n@@ -66,1 +57,1 @@\n-        return elementType;\n+        return super.typeElement;\n@@ -71,1 +62,1 @@\n-        return Map.of(\"hat.dialect.floatNStoreView.\" + varName(), elementType);\n+        return Map.of(\"hat.dialect.\" + vectorElementType.toString() + vectorN() + \"StoreView.\" + varName(), typeElement);\n@@ -78,5 +69,0 @@\n-    @Override\n-    public String buildType() {\n-        \/\/ floatN\n-        return vectorType.type();\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorStoreView.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    public HATVectorSubOp(String varName, TypeElement typeElement, List<Value> operands) {\n-        super(varName, typeElement, OpType.SUB, operands);\n+    public HATVectorSubOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n+        super(varName, typeElement, OpType.SUB, vectorElementType, width, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSubOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,5 +38,2 @@\n-    private final TypeElement typeElement;\n-\n-    public HATVectorVarLoadOp(String varName, TypeElement typeElement, List<Value> operands) {\n-        super(varName, typeElement, 0, operands);\n-        this.typeElement = typeElement;\n+    public HATVectorVarLoadOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n+        super(varName, typeElement, vectorElementType, width, operands);\n@@ -47,1 +44,0 @@\n-        this.typeElement = op.typeElement;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorVarLoadOp.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-    private final VarType typeElement;\n@@ -42,3 +41,2 @@\n-    public HATVectorVarOp(String varName, VarType typeElement, int loadN, List<Value> operands) {\n-        super(varName, typeElement, loadN, operands);\n-        this.typeElement = typeElement;\n+    public HATVectorVarOp(String varName, VarType typeElement, TypeElement vectorElementType, int loadN, List<Value> operands) {\n+        super(varName, typeElement, vectorElementType, loadN, operands);\n@@ -50,1 +48,0 @@\n-        this.typeElement = op.typeElement;\n@@ -69,8 +66,0 @@\n-    @Override\n-    public String buildType() {\n-        \/\/ floatN\n-        if (typeElement.valueType().toString().startsWith(\"hat.buffer.Float\")) {\n-            return \"float\" + loadN;\n-        }\n-        throw new RuntimeException(\"Unexpected vector type \" + typeElement);\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorVarOp.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -68,0 +71,16 @@\n+\n+    default Set<Class<?>> inspectAllInterfaces(Class<?> klass) {\n+        Set<Class<?>> interfaceSet = new HashSet<>();\n+        while (klass != null) {\n+            Arrays.stream(klass.getInterfaces()).forEach(interfaceClass -> inspectNewLevel(interfaceClass, interfaceSet));\n+            klass = klass.getSuperclass();\n+        }\n+        return interfaceSet;\n+    }\n+\n+    default void inspectNewLevel(Class<?> interaceClass, Set<Class<?>> interfaceSet) {\n+        if (interfaceSet.add(interaceClass)) {\n+            \/\/ only if we add a new interface class, we inspect all interfaces that extends the current inspected class\n+            Arrays.stream(interaceClass.getInterfaces()).forEach(superInterface -> inspectNewLevel(superInterface, interfaceSet));\n+        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialect.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import hat.types._V;\n+import jdk.incubator.code.Block;\n@@ -58,0 +60,6 @@\n+import static hat.dialect.HATPhaseUtils.VectorMetaData;\n+import static hat.dialect.HATPhaseUtils.findNameVector;\n+import static hat.dialect.HATPhaseUtils.findVectorTypeElement;\n+import static hat.dialect.HATPhaseUtils.getVectorTypeInfo;\n+import static hat.dialect.HATPhaseUtils.getWitdh;\n+\n@@ -61,1 +69,3 @@\n-    @Override  public Accelerator accelerator(){\n+\n+    @Override\n+    public Accelerator accelerator() {\n@@ -64,0 +74,1 @@\n+\n@@ -67,1 +78,1 @@\n-       this.accelerator = accelerator;\n+        this.accelerator = accelerator;\n@@ -71,2 +82,0 @@\n-\n-\n@@ -92,0 +101,1 @@\n+\n@@ -99,19 +109,5 @@\n-        boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\n-        return isHatVectorType\n-                && OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp)\n-                && isMethod(invokeOp, vectorOperation.methodName);\n-    }\n-\n-    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().get(0));\n-    }\n-\n-    private String findNameVector(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findNameVector(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.varName();\n-            }\n-            return null;\n+        Set<Class<?>> interfaces = Set.of();\n+        try {\n+            Class<?> aClass = Class.forName(typeElement.toString());\n+            interfaces = inspectAllInterfaces(aClass);\n+        } catch (ClassNotFoundException _) {\n@@ -119,0 +115,1 @@\n+        return interfaces.contains(_V.class) && isMethod(invokeOp, vectorOperation.methodName);\n@@ -129,1 +126,0 @@\n-            \/\/ Leaf of tree -\n@@ -137,1 +133,1 @@\n-    private HATVectorBinaryOp buildVectorBinaryOp(HATVectorBinaryOp.OpType opType, String varName, TypeElement resultType, List<Value> outputOperands) {\n+    private HATVectorBinaryOp buildVectorBinaryOp(HATVectorBinaryOp.OpType opType, String varName, TypeElement resultType, TypeElement vectorElementType, int witdh, List<Value> outputOperands) {\n@@ -139,4 +135,4 @@\n-            case ADD -> new HATVectorAddOp(varName, resultType, outputOperands);\n-            case SUB -> new HATVectorSubOp(varName, resultType, outputOperands);\n-            case MUL -> new HATVectorMulOp(varName, resultType, outputOperands);\n-            case DIV -> new HATVectorDivOp(varName, resultType, outputOperands);\n+            case ADD -> new HATVectorAddOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+            case SUB -> new HATVectorSubOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+            case MUL -> new HATVectorMulOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+            case DIV -> new HATVectorDivOp(varName, resultType, vectorElementType, witdh, outputOperands);\n@@ -146,0 +142,74 @@\n+    private void insertVectorLoadOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp, CoreOp.VarOp varOp, boolean isShared) {\n+        List<Value> inputOperandsVarOp = invokeOp.operands();\n+        List<Value> outputOperandsVarOp = blockBuilder.context().getValues(inputOperandsVarOp);\n+        VectorMetaData metaData = getVectorTypeInfo(invokeOp);\n+        HATVectorOp memoryViewOp = new HATVectorLoadOp(varOp.varName(), varOp.resultType(), metaData.vectorTypeElement(), metaData.lanes(), isShared, outputOperandsVarOp);\n+        Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n+        memoryViewOp.setLocation(varOp.location());\n+        blockBuilder.context().mapValue(invokeOp.result(), hatLocalResult);\n+    }\n+\n+    private void inertVectorVarOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, Map<Op, VectorMetaData> vectorMetaData) {\n+        List<Value> inputOperandsVarOp = varOp.operands();\n+        List<Value> outputOperandsVarOp = blockBuilder.context().getValues(inputOperandsVarOp);\n+        VectorMetaData vmd = vectorMetaData.get(varOp);\n+        HATVectorOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperandsVarOp);\n+        Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n+        memoryViewOp.setLocation(varOp.location());\n+        blockBuilder.context().mapValue(varOp.result(), hatLocalResult);\n+    }\n+\n+    public void insertBinaryOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp, Map<Op, VectorMetaData> vectorMetaData, Map<JavaOp.InvokeOp, HATVectorBinaryOp.OpType> binaryOperation) {\n+        List<Value> inputOperands = invokeOp.operands();\n+        List<Value> outputOperands = blockBuilder.context().getValues(inputOperands);\n+        HATVectorBinaryOp.OpType binaryOpType = binaryOperation.get(invokeOp);\n+        VectorMetaData vmd = vectorMetaData.get(invokeOp);\n+        HATVectorOp memoryViewOp = buildVectorBinaryOp(binaryOpType, varOp.varName(), invokeOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperands);\n+        Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n+        memoryViewOp.setLocation(varOp.location());\n+        blockBuilder.context().mapValue(invokeOp.result(), hatVectorOpResult);\n+    }\n+\n+    private void insertVectorVarLoadOp(Block.Builder blockBuilder, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        List<Value> inputOperandsVarLoad = varLoadOp.operands();\n+        List<Value> outputOperandsVarLoad = blockBuilder.context().getValues(inputOperandsVarLoad);\n+        String varLoadName = findNameVector(varLoadOp);\n+        int lanes = getWitdh(varLoadOp);\n+        TypeElement vectorElementType = findVectorTypeElement(varLoadOp);\n+        HATVectorOp memoryViewOp = new HATVectorVarLoadOp(varLoadName, varLoadOp.resultType(), vectorElementType, lanes, outputOperandsVarLoad);\n+        Op.Result hatVectorResult = blockBuilder.op(memoryViewOp);\n+        memoryViewOp.setLocation(varLoadOp.location());\n+        blockBuilder.context().mapValue(varLoadOp.result(), hatVectorResult);\n+    }\n+\n+    public void insertVectorBinaryOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp, Map<JavaOp.InvokeOp, HATVectorBinaryOp.OpType> binaryOperation) {\n+        List<Value> inputOperands = invokeOp.operands();\n+        List<Value> outputOperands = blockBuilder.context().getValues(inputOperands);\n+        VectorMetaData vectorMetaData = getVectorTypeInfo(invokeOp);\n+        HATVectorOp memoryViewOp = buildVectorBinaryOp(binaryOperation.get(invokeOp), \"null\", invokeOp.resultType(), vectorMetaData.vectorTypeElement(), vectorMetaData.lanes(), outputOperands);\n+        Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n+        memoryViewOp.setLocation(invokeOp.location());\n+        blockBuilder.context().mapValue(invokeOp.result(), hatVectorOpResult);\n+    }\n+\n+    public void insertVectorOfOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp, Map<Op, VectorMetaData> vectorMetaData) {\n+        List<Value> inputOperandsVarOp = invokeOp.operands();\n+        List<Value> outputOperandsVarOp = blockBuilder.context().getValues(inputOperandsVarOp);\n+        VectorMetaData vmd = vectorMetaData.get(invokeOp);\n+        HATVectorOfOp memoryViewOp = new HATVectorOfOp(invokeOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperandsVarOp);\n+        Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n+        memoryViewOp.setLocation(invokeOp.location());\n+        blockBuilder.context().mapValue(invokeOp.result(), hatLocalResult);\n+    }\n+\n+    public void insertVectorMakeOfOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp, Map<Op, VectorMetaData> vectorMetaData) {\n+        List<Value> inputOperandsVarOp = invokeOp.operands();\n+        List<Value> outputOperandsVarOp = blockBuilder.context().getValues(inputOperandsVarOp);\n+        String varName = findNameVector(invokeOp.operands().getFirst());\n+        VectorMetaData vmd = vectorMetaData.get(invokeOp);\n+        HATVectorMakeOfOp makeOf = new HATVectorMakeOfOp(varName, invokeOp.resultType(), vmd.lanes(), outputOperandsVarOp);\n+        Op.Result hatLocalResult = blockBuilder.op(makeOf);\n+        makeOf.setLocation(invokeOp.location());\n+        blockBuilder.context().mapValue(invokeOp.result(), hatLocalResult);\n+    }\n+\n@@ -147,3 +217,4 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyVectorLoad\" );\n-        before(here,funcOp);\n-            Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyVectorLoad\");\n+        Map<Op, VectorMetaData> vectorMetaData = new HashMap<>();\n+        before(here, funcOp);\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n@@ -157,0 +228,5 @@\n+                                        \/\/ Associate both ops to the vectorTypeInfo for easy\n+                                        \/\/ access to type and lanes\n+                                        VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n+                                        vectorMetaData.put(invokeOp, vectorTypeInfo);\n+                                        vectorMetaData.put(varOp, vectorTypeInfo);\n@@ -168,2 +244,1 @@\n-\n-        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n+        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n@@ -180,6 +255,1 @@\n-                        List<Value> inputOperandsVarOp = invokeOp.operands();\n-                        List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                        HATVectorOp memoryViewOp = new HATVectorLoadOp(varOp.varName(), varOp.resultType(), invokeOp.resultType(), 4, isShared, outputOperandsVarOp);\n-                        Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n-                        memoryViewOp.setLocation(varOp.location());\n-                        context.mapValue(invokeOp.result(), hatLocalResult);\n+                        insertVectorLoadOp(blockBuilder, invokeOp, varOp, isShared);\n@@ -189,11 +259,1 @@\n-                \/\/ pass value\n-                \/\/context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n-                List<Value> inputOperandsVarOp = varOp.operands();\n-                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                HATVectorOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n-                Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n-                memoryViewOp.setLocation(varOp.location());\n-                context.mapValue(varOp.result(), hatLocalResult);\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ pass value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -208,3 +268,4 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyVectorOf\" );\n-        before(here,funcOp);\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyVectorOf\");\n+        Map<Op, VectorMetaData> vectorMetaData = new HashMap<>();\n+        before(here, funcOp);\n+        Stream<CodeElement<?, ?>> vectorNodes = funcOp.elements()\n@@ -219,0 +280,3 @@\n+                                    VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n+                                    vectorMetaData.put(invokeOp, vectorTypeInfo);\n+                                    vectorMetaData.put(varOp, vectorTypeInfo);\n@@ -225,1 +289,1 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        Set<CodeElement<?, ?>> nodesInvolved = vectorNodes.collect(Collectors.toSet());\n@@ -227,2 +291,1 @@\n-        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n+        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n@@ -232,6 +295,1 @@\n-                List<Value> inputOperandsVarOp = invokeOp.operands();\n-                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                HATVectorOfOp memoryViewOp = new HATVectorOfOp(invokeOp.resultType(), 4, outputOperandsVarOp);\n-                Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n-                memoryViewOp.setLocation(invokeOp.location());\n-                context.mapValue(invokeOp.result(), hatLocalResult);\n+                insertVectorOfOp(blockBuilder, invokeOp, vectorMetaData);\n@@ -239,6 +297,1 @@\n-                List<Value> inputOperandsVarOp = varOp.operands();\n-                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                HATVectorOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n-                Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n-                memoryViewOp.setLocation(varOp.location());\n-                context.mapValue(varOp.result(), hatLocalResult);\n+                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -256,0 +309,1 @@\n+        Map<Op, VectorMetaData> vectorMetaData = new HashMap<>();\n@@ -267,0 +321,3 @@\n+                                        VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n+                                        vectorMetaData.put(invokeOp, vectorTypeInfo);\n+                                        vectorMetaData.put(varOp, vectorTypeInfo);\n@@ -279,2 +336,1 @@\n-            CopyContext context = blockBuilder.context();\n-                if (op instanceof JavaOp.InvokeOp invokeOp) {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n@@ -282,2 +338,0 @@\n-                List<Value> inputOperands = invokeOp.operands();\n-                List<Value> outputOperands = context.getValues(inputOperands);\n@@ -287,5 +341,1 @@\n-                        HATVectorBinaryOp.OpType binaryOpType = binaryOperation.get(invokeOp);\n-                        HATVectorOp memoryViewOp = buildVectorBinaryOp(binaryOpType, varOp.varName(), invokeOp.resultType(), outputOperands);\n-                        Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n-                        memoryViewOp.setLocation(varOp.location());\n-                        context.mapValue(invokeOp.result(), hatVectorOpResult);\n+                        insertBinaryOp(blockBuilder, varOp, invokeOp, vectorMetaData, binaryOperation);\n@@ -296,6 +346,1 @@\n-                List<Value> inputOperandsVarOp = varOp.operands();\n-                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                HATVectorOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n-                Op.Result hatVectorResult = blockBuilder.op(memoryViewOp);\n-                memoryViewOp.setLocation(varOp.location());\n-                context.mapValue(varOp.result(), hatVectorResult);\n+                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -305,1 +350,1 @@\n-       after(here,funcOp);\n+        after(here, funcOp);\n@@ -310,2 +355,3 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyMutableOf\" );\n-        before(here,funcOp);\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyMutableOf\");\n+        before(here, funcOp);\n+        Map<Op, VectorMetaData> vectorMetaData = new HashMap<>();\n@@ -317,0 +363,2 @@\n+                            VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n+                            vectorMetaData.put(invokeOp, vectorTypeInfo);\n@@ -321,0 +369,1 @@\n+                                    vectorMetaData.put(varOp, vectorTypeInfo);\n@@ -329,2 +378,1 @@\n-        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n+        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n@@ -334,7 +382,1 @@\n-                List<Value> inputOperandsVarOp = invokeOp.operands();\n-                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                String varName = findNameVector(invokeOp.operands().getFirst());\n-                HATVectorMakeOfOp makeOf = new HATVectorMakeOfOp(varName, invokeOp.resultType(), 4, outputOperandsVarOp);\n-                Op.Result hatLocalResult = blockBuilder.op(makeOf);\n-                makeOf.setLocation(invokeOp.location());\n-                context.mapValue(invokeOp.result(), hatLocalResult);\n+                insertVectorMakeOfOp(blockBuilder, invokeOp, vectorMetaData);\n@@ -342,6 +384,1 @@\n-                List<Value> inputOperandsVarOp = varOp.operands();\n-                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                HATVectorOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n-                Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n-                memoryViewOp.setLocation(varOp.location());\n-                context.mapValue(varOp.result(), hatLocalResult);\n+                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -359,1 +396,1 @@\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+        Stream<CodeElement<?, ?>> vectorNodes = funcOp.elements()\n@@ -383,1 +420,1 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        Set<CodeElement<?, ?>> nodesInvolved = vectorNodes.collect(Collectors.toSet());\n@@ -387,2 +424,1 @@\n-         funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n+        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n@@ -392,6 +428,1 @@\n-                List<Value> inputOperands = invokeOp.operands();\n-                List<Value> outputOperands = context.getValues(inputOperands);\n-                HATVectorOp memoryViewOp = buildVectorBinaryOp(binaryOperation.get(invokeOp), \"null\", invokeOp.resultType(), outputOperands);\n-                Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n-                memoryViewOp.setLocation(invokeOp.location());\n-                context.mapValue(invokeOp.result(), hatVectorOpResult);\n+                insertVectorBinaryOp(blockBuilder, invokeOp, binaryOperation);\n@@ -399,7 +430,1 @@\n-                List<Value> inputOperandsVarLoad = varLoadOp.operands();\n-                List<Value> outputOperandsVarLoad = context.getValues(inputOperandsVarLoad);\n-                String varLoadName = findNameVector(varLoadOp);\n-                HATVectorOp memoryViewOp = new HATVectorVarLoadOp(varLoadName, varLoadOp.resultType(), outputOperandsVarLoad);\n-                Op.Result hatVectorResult = blockBuilder.op(memoryViewOp);\n-                memoryViewOp.setLocation(varLoadOp.location());\n-                context.mapValue(varLoadOp.result(), hatVectorResult);\n+                insertVectorVarLoadOp(blockBuilder, varLoadOp);\n@@ -409,1 +434,1 @@\n-      after(here,funcOp);\n+        after(here, funcOp);\n@@ -415,10 +440,9 @@\n-        if (Objects.requireNonNull(vectorOperation) == OpView.FLOAT4_LOAD) {\n-            funcOp = dialectifyVectorLoad(funcOp);\n-        } else if (Objects.requireNonNull(vectorOperation) == OpView.OF) {\n-            funcOp = dialectifyVectorOf(funcOp);\n-        } else if (Objects.requireNonNull(vectorOperation) == OpView.MAKE_MUTABLE) {\n-            funcOp = dialectifyMutableOf(funcOp);\n-        } else {\n-            \/\/ Find binary operations\n-            funcOp = dialectifyVectorBinaryOps(funcOp);\n-            funcOp = dialectifyVectorBinaryWithConcatenationOps(funcOp);\n+        switch (Objects.requireNonNull(vectorOperation)) {\n+            case FLOAT4_LOAD -> funcOp = dialectifyVectorLoad(funcOp);\n+            case OF -> funcOp = dialectifyVectorOf(funcOp);\n+            case MAKE_MUTABLE -> funcOp = dialectifyMutableOf(funcOp);\n+            default -> {\n+                \/\/ Find binary operations\n+                funcOp = dialectifyVectorBinaryOps(funcOp);\n+                funcOp = dialectifyVectorBinaryWithConcatenationOps(funcOp);\n+            }\n@@ -429,1 +453,1 @@\n-    public static class AddPhase extends HATDialectifyVectorOpPhase{\n+    public static class AddPhase extends HATDialectifyVectorOpPhase {\n@@ -432,1 +456,1 @@\n-           super(accelerator, OpView.ADD);\n+            super(accelerator, OpView.ADD);\n@@ -436,1 +460,1 @@\n-    public static class DivPhase extends HATDialectifyVectorOpPhase{\n+    public static class DivPhase extends HATDialectifyVectorOpPhase {\n@@ -439,1 +463,1 @@\n-           super(accelerator, OpView.DIV);\n+            super(accelerator, OpView.DIV);\n@@ -443,1 +467,1 @@\n-    public static class MakeMutable extends HATDialectifyVectorOpPhase{\n+    public static class MakeMutable extends HATDialectifyVectorOpPhase {\n@@ -453,1 +477,1 @@\n-           super(accelerator, OpView.FLOAT4_LOAD);\n+            super(accelerator, OpView.FLOAT4_LOAD);\n@@ -464,1 +488,1 @@\n-    public static class MulPhase extends HATDialectifyVectorOpPhase{\n+    public static class MulPhase extends HATDialectifyVectorOpPhase {\n@@ -467,1 +491,1 @@\n-           super(accelerator, OpView.MUL);\n+            super(accelerator, OpView.MUL);\n@@ -471,1 +495,1 @@\n-    public static class SubPhase extends HATDialectifyVectorOpPhase{\n+    public static class SubPhase extends HATDialectifyVectorOpPhase {\n@@ -474,1 +498,1 @@\n-           super(accelerator, OpView.SUB);\n+            super(accelerator, OpView.SUB);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":164,"deletions":140,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.types._V;\n@@ -73,5 +74,8 @@\n-        String invokeClass = invokeOp.invokeDescriptor().refType().toString();\n-        boolean isHatVectorType = invokeClass.startsWith(\"hat.buffer.Float\");\n-        return isHatVectorType\n-                && OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp)\n-                && (isVectorLane(invokeOp));\n+        String typeElement = invokeOp.invokeDescriptor().refType().toString();\n+        Set<Class<?>> interfaces = Set.of();\n+        try {\n+            Class<?> aClass = Class.forName(typeElement);\n+            interfaces = inspectAllInterfaces(aClass);\n+        } catch (ClassNotFoundException _) {\n+        }\n+        return interfaces.contains(_V.class) && isVectorLane(invokeOp);\n@@ -110,1 +114,0 @@\n-\n@@ -114,1 +117,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.dialect.HATPhaseUtils;\n@@ -33,0 +34,1 @@\n+import hat.types._V;\n@@ -59,2 +61,0 @@\n-\n-\n@@ -70,2 +70,1 @@\n-        if (varValue instanceof Op.Result r\n-                && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        if (varValue instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n@@ -73,4 +72,7 @@\n-            boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\/\/\/ UGGHHH!\n-            return isHatVectorType\n-                    && OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp)\n-                    && isMethod(invokeOp, vectorOperation.methodName);\n+            Set<Class<?>> interfaces = Set.of();\n+            try {\n+                Class<?> aClass = Class.forName(typeElement.toString());\n+                interfaces = inspectAllInterfaces(aClass);\n+            } catch (ClassNotFoundException _) {\n+            }\n+            return interfaces.contains(_V.class) && isMethod(invokeOp, vectorOperation.methodName);\n@@ -113,1 +115,1 @@\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+        Stream<CodeElement<?, ?>> vectorNodesInvolved = funcOp.elements()\n@@ -116,2 +118,1 @@\n-                        if ((invokeOp.operands().size() >= 3)\n-                                && (isVectorOperation(invokeOp, invokeOp.operands().get(1)))) {\n+                        if ((invokeOp.operands().size() >= 3) && (isVectorOperation(invokeOp, invokeOp.operands().get(1)))) {\n@@ -123,1 +124,1 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        Set<CodeElement<?, ?>> nodesInvolved = vectorNodesInvolved.collect(Collectors.toSet());\n@@ -129,1 +130,0 @@\n-                \/\/ Don't insert the invoke node\n@@ -132,0 +132,1 @@\n+\n@@ -133,2 +134,2 @@\n-                Value v = invokeOp.operands().get(1);\n-                String name = findNameVector(v);\n+                String name = findNameVector(invokeOp.operands().get(1));\n+\n@@ -137,3 +138,3 @@\n-                HATVectorOp storeView = switch (vectorOperation) {\n-                    case FLOAT4_STORE -> new HATVectorStoreView(name, invokeOp.resultType(), 4, HATVectorOp.VectorType.FLOAT4, isSharedOrPrivate,  outputOperandsVarOp);\n-                };\n+                HATPhaseUtils.VectorMetaData vectorMetaData  = HATPhaseUtils.getVectorTypeInfo(invokeOp, 1);\n+                TypeElement vectorElementType = vectorMetaData.vectorTypeElement();\n+                HATVectorOp storeView = new HATVectorStoreView(name, invokeOp.resultType(), vectorMetaData.lanes(), vectorElementType, isSharedOrPrivate,  outputOperandsVarOp);\n@@ -149,1 +150,1 @@\n-       after(here, funcOp);\n+        after(here, funcOp);\n@@ -157,1 +158,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.types;\n+\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n+public interface _V {\n+    PrimitiveType type();\n+    int width();\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/_V.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.types;\n+\n+import jdk.incubator.code.CodeReflection;\n+\n+public interface _V4 extends _V {\n+\n+    @CodeReflection\n+    @Override\n+    default int width() {\n+        return 4;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/_V4.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -255,0 +255,11 @@\n+    @CodeReflection\n+    public static void vectorOps15(@RO KernelContext kernelContext, @RW F32ArrayPadded a) {\n+        \/\/ in this sample, we don't perform the vload, but rather the vstore directly\n+        \/\/ from a new float4.\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 result = Float4.of(1.0f, 2.0f, 3.0f, 4.0f);\n+            a.storeFloat4View(result, index * 4);\n+        }\n+    }\n+\n@@ -347,0 +358,7 @@\n+    @CodeReflection\n+    public static void computeGraph15(@RO ComputeContext cc, @RW F32ArrayPadded a, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps15(kernelContext, a));\n+    }\n+\n@@ -661,0 +679,22 @@\n+    @HatTest\n+    public void testVectorTypes15() {\n+        final int size = 2048;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(73);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph15(cc, arrayA, size));\n+\n+        Float4 v = Float4.of(1.0f, 2.0f, 3.0f, 4.0f);\n+        for (int i = 0; i < size; i += 4) {\n+            HatAsserts.assertEquals(v.x(), arrayA.array(i), 0.001f);\n+            HatAsserts.assertEquals(v.y(), arrayA.array(i + 1), 0.001f);\n+            HatAsserts.assertEquals(v.z(), arrayA.array(i + 2), 0.001f);\n+            HatAsserts.assertEquals(v.w(), arrayA.array(i + 3), 0.001f);\n+        }\n+    }\n+\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorTypes.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}