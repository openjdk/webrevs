{"files":[{"patch":"@@ -37,1 +37,1 @@\n-import optkl.util.StreamMutable;\n+import optkl.util.Mutable;\n@@ -70,1 +70,1 @@\n-        var changed  = StreamMutable.of(true);\n+        var changed  = Mutable.of(true);\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import optkl.util.StreamMutable;\n@@ -33,2 +32,0 @@\n-import java.text.SimpleDateFormat;\n-import java.util.Date;\n","filename":"hat\/core\/src\/main\/java\/hat\/FFIConfigCreator.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import optkl.util.StreamMutable;\n+import optkl.util.Mutable;\n@@ -105,1 +105,1 @@\n-            var i = StreamMutable.of(START_BIT_INDEX);\n+            var i = Mutable.of(START_BIT_INDEX);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATConfigBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-import optkl.util.StreamMutable;\n+import optkl.util.Mutable;\n@@ -201,1 +201,1 @@\n-                    var fieldIdx = StreamMutable.of(0);\n+                    var fieldIdx = Mutable.of(0);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.code.Block;\n@@ -37,0 +36,2 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -41,1 +42,0 @@\n-import optkl.ifacemapper.AccessType;\n@@ -45,0 +45,1 @@\n+import optkl.util.Mutable;\n@@ -47,0 +48,1 @@\n+import java.util.HashSet;\n@@ -48,0 +50,2 @@\n+import java.util.Map;\n+import java.util.Set;\n@@ -49,2 +53,0 @@\n-import static hat.ComputeContext.WRAPPER.ACCESS;\n-import static hat.ComputeContext.WRAPPER.MUTATE;\n@@ -52,0 +54,4 @@\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Func.*;\n+import static optkl.OpHelper.Statement.createOpToStatementSpanMap;\n+import static optkl.OpHelper.getFuncParamOrNull;\n+\n@@ -63,3 +69,1 @@\n-\n-        int l = s32Array.length();\n-\n+        int l = 40*s32Array.length()+25;\n@@ -67,1 +71,1 @@\n-\n+        s32Array.array(0,s32Array.array(0)+1);\n@@ -70,1 +74,1 @@\n-            System.out.println(i);\/\/s32Array.array(0));\n+            System.out.println(i);\n@@ -74,11 +78,0 @@\n-    static Block.Parameter getFuncParamOrNull(Op op, int n) {\n-        while (op != null && !(op instanceof CoreOp.FuncOp)) {\n-            System.out.println(op);\n-            op = op.ancestorOp();\n-        }\n-        if (op instanceof CoreOp.FuncOp funcOp) {\n-            return funcOp.bodies().get(0).entryBlock().parameters().get(n);\n-        } else {\n-            return null;\n-        }\n-    }\n@@ -86,5 +79,14 @@\n-    static Block.Parameter getFuncParamOrThrow(Op op, int n) {\n-        if (getFuncParamOrNull(op, n) instanceof Block.Parameter parameter) {\n-            return parameter;\n-        } else {\n-            throw new IllegalStateException(\"cant find func parameter parameter \" + n);\n+    public static void main(String[] args) throws NoSuchMethodException {\n+        var lookup = MethodHandles.lookup();\n+        var func = func(lookup, InjectBufferTracking.class,\"add\",ComputeContext.class, S32Array.class, int.class, int.class);\n+\n+        record StatementSpanImpl(Set<Value> mutates, Set<Value> accesses, \/\/ Either Access or Mutate\n+                                 Mutable<Value> mutableIfaceBuffer,\n+                                 List<Op> ops) implements Statement.Span {\n+            void put(Value value, boolean mutate){\n+                if (mutate){\n+                    mutates.add(value);\n+                }else {\n+                    accesses.add(value);\n+                }\n+            }\n@@ -92,1 +94,0 @@\n-    }\n@@ -94,0 +95,6 @@\n+        \/\/ The resulting map, maps all ops to their enclosing statements but only if the statement contains an invokeOp.\n+        \/\/ Here we look for iface->set\/get and add value -> access type mappings\n+        Map<Op,StatementSpanImpl> opToStatementSpans = createOpToStatementSpanMap(func.op(),\n+                op->op instanceof JavaOp.InvokeOp, \/\/ we only care if the statement actually contains an invoke\n+                ops-> new StatementSpanImpl(new HashSet<>(), new HashSet<>(), Mutable.of(null),ops)\n+        );\n@@ -95,2 +102,1 @@\n-    public static void main(String[] args) throws NoSuchMethodException {\n-        var lookup = MethodHandles.lookup();\n+        \/\/ This query helps locate mappedIfaceBuffer accessors or mutators\n@@ -98,3 +104,18 @@\n-        Trxfmr.of(lookup,\n-                        InjectBufferTracking.class,\"add\",ComputeContext.class, S32Array.class, int.class, int.class)\n-                .toText(\"COMPUTE before injecting buffer tracking...\")\n+\n+        opToStatementSpans.values().forEach(statementSpan -> {\n+            statementSpan.ops().forEach(opInStatement -> {\n+                if (mappedIfaceBufferInvokeQuery.matches(opInStatement) instanceof Match match) {\n+                    statementSpan.put(match.helper().instance(), match.mutatesBuffer());\n+                }else if (Invoke.invoke(lookup, opInStatement) instanceof Invoke invoke\n+                        && invoke.isInstance() && !invoke.refIs(ComputeContext.class) && invoke.operandCount() > 0) {\n+                    invoke.paramaterAccessList().stream()\n+                            .filter(typeAndAccess -> typeAndAccess.isIface(lookup))\n+                            .forEach(typeAndAccess -> statementSpan.put(typeAndAccess.value(), typeAndAccess.mutatesBuffer()));\n+                }\n+            });\n+        });\n+\n+        \/\/ Now we have enough info to transform.  We now look like statement first and last ops and inject before or after ,\n+        MethodRef Println = MethodRef.method(IO.class, \"println\", void.class, Object.class);\n+        Trxfmr.of(lookup,func.op())\n+               \/\/ .toText(\"COMPUTE before injecting buffer tracking...\")\n@@ -102,27 +123,61 @@\n-                .transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n-                    if (mappedIfaceBufferInvokeQuery.matches(c.op()) instanceof Match match) {\n-                       Value computeContext = c.getValue(getFuncParamOrThrow(match.helper().op(), 0));\n-                       Value ifaceMappedBuffer = c.mappedOperand(0);\n-                       c.add(JavaOp.invoke(match.mutatesBuffer()? MUTATE.pre : ACCESS.pre, computeContext, ifaceMappedBuffer));\n-                       c.retain();\n-                       c.add(JavaOp.invoke(match.mutatesBuffer()? MUTATE.post : ACCESS.post, computeContext, ifaceMappedBuffer));\n-                    } else if (Invoke.invoke(lookup, c.op()) instanceof Invoke invoke && !invoke.refIs(ComputeContext.class) && invoke.operandCount() > 0) {\n-                        List<AccessType.TypeAndAccess> typeAndAccesses = invoke.paramaterAccessList();\n-                        Value computeContext = c.getValue(getFuncParamOrThrow(invoke.op(), 0));\/\/ c.getValue(invoke.op().operands().getFirst());\n-                        typeAndAccesses.stream()\n-                                .filter(typeAndAccess -> typeAndAccess.isIface(lookup))\n-                                .forEach(typeAndAccess ->\n-                                        c.add(JavaOp.invoke(\n-                                                typeAndAccess.ro() ? ACCESS.pre : MUTATE.pre,\n-                                                computeContext, c.getValue(typeAndAccess.value()))\n-                                        )\n-                                );\n-                        c.retain();\n-                        typeAndAccesses.stream()\n-                                .filter(typeAndAccess -> OpHelper.isAssignable(lookup, typeAndAccess.javaType(), MappableIface.class))\n-                                .forEach(typeAndAccess ->\n-                                        c.add(JavaOp.invoke(\n-                                                typeAndAccess.ro() ? ACCESS.post : MUTATE.post,\n-                                                computeContext, c.getValue(typeAndAccess.value()))\n-                                        )\n-                                );\n+                .transform((block, op) ->{\n+                    if (opToStatementSpans.containsKey(op)) {\n+                        var statementSpan = opToStatementSpans.get(op);\n+                        if (statementSpan.firstOrLast(op)) {\n+                            var computeContext = getFuncParamOrNull(op, 0);\n+                            \/\/Value mappedComputeContext = block.context().mapValue(getFuncParamOrNull(op, 0));\n+                            if (!OpHelper.isAssignable(lookup, computeContext.type(), ComputeContext.class)) {\n+                             \/\/   System.out.println(\"ok we found the compute context\");\n+                            \/\/}else {\n+                                throw new RuntimeException(\"parameter 0 is not compute context \"+computeContext.type());\n+                            }\n+                            if (statementSpan.isFrom(op)) {\n+                                statementSpan.ops.stream()\n+                                        .filter(o->o instanceof JavaOp.InvokeOp)\n+                                        .map(o->Invoke.invoke(lookup,o))\n+                                        .filter(Invoke::isInstance)\n+                                        .forEach(invoke -> {\n+                                            if (OpHelper.isAssignable(lookup,invoke.refType(),MappableIface.class)){\n+                                                boolean mutates = statementSpan.mutates.contains(invoke.op().operands().getFirst());\n+                                                boolean accesses  = statementSpan.accesses.contains(invoke.op().operands().getFirst());\n+                                               var before = block.op(CoreOp.constant(JavaType.J_L_STRING, \"The following statement \"\n+                                                       +(mutates?\"mutates \":\"\")+ ((mutates&accesses)?\"and \":\"\")+(accesses?\"accesses \":\"\")+\n+                                                       \"iface mapped buffer \"));\n+                                               block.op(JavaOp.invoke( JavaType.VOID, Println, before));\n+                                            } else {\n+                                                \/\/ System.out.println(\"nope\");\n+                                                }\n+\n+                                    \/\/ var mappedIfaceBuffer =c.getValue(ifaceBuffer);\n+                                    \/\/ c.add(JavaOp.invoke(accessOrMutateWrapper.pre, mappedComputeContext,ifaceBuffer));\n+                                    \/\/c.retain();\n+                                });\n+                                block.op(op);\n+                            } else if (statementSpan.isTo(op)) {\n+                                block.op(op);\n+                                statementSpan.ops.stream()\n+                                        .filter(o->o instanceof JavaOp.InvokeOp)\n+                                        .map(o->Invoke.invoke(lookup,o))\n+                                        .filter(Invoke::isInstance)\n+                                        .forEach(invoke -> {\n+                                            if (OpHelper.isAssignable(lookup,invoke.refType(),MappableIface.class)){\n+                                                boolean mutates = statementSpan.mutates.contains(invoke.op().operands().getFirst());\n+                                                boolean accesses  = statementSpan.accesses.contains(invoke.op().operands().getFirst());\n+                                                var after = block.op(CoreOp.constant(JavaType.J_L_STRING,\n+                                                        \"The previous statement \"\n+                                                                +(mutates?\"mutates \":\"\")+ ((mutates&accesses)?\"and \":\"\")+(accesses?\"accesses \":\"\")+\n+                                                                \"iface mapped buffer \"));\n+                                                block.op(JavaOp.invoke( JavaType.VOID, Println, after));\n+                                            } else {\n+                                                \/\/  System.out.println(\"nope\");\n+                                            }\n+                                    \/\/ var mappedIfaceBuffer =c.getValue(ifaceBuffer);\n+                                    \/\/  c.retain();\n+                                    \/\/ c.add(JavaOp.invoke(accessorMutateWrapper.post, mappedComputeContext,mappedIfaceBuffer));\n+                                });\n+                            }\n+                        }else {\n+                            block.op(op);\n+                        }\n+                    }else {\n+                        block.op(op);\n@@ -130,0 +185,1 @@\n+                    return block;\n@@ -131,2 +187,3 @@\n-                .toText(\"COMPUTE after injecting buffer tracking...\")\n-                .toJava();\n+\n+             \/\/   .toText(\"COMPUTE after injecting buffer tracking...\")\n+                .toJava(\"COMPUTE (java) after injecting buffer tracking...\");\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InjectBufferTracking.java","additions":117,"deletions":60,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import optkl.util.StreamMutable;\n+import optkl.util.Mutable;\n@@ -174,1 +174,1 @@\n-        final var mesh = StreamMutable.of((F32Mesh3D) null);\n+        final var mesh = Mutable.of((F32Mesh3D) null);\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/EliteMeshParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import optkl.util.StreamMutable;\n+import optkl.util.Mutable;\n@@ -57,1 +57,1 @@\n-        var triSumIdx = StreamMutable.of(faces.getFirst().centerVec3Idx);\n+        var triSumIdx = Mutable.of(faces.getFirst().centerVec3Idx);\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Mesh3D.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.code.dialect.core.VarType;\n@@ -55,0 +54,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n@@ -58,1 +59,0 @@\n-import java.util.Optional;\n@@ -60,0 +60,1 @@\n+import java.util.function.Function;\n@@ -424,1 +425,1 @@\n-                static Func invoke(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+                static Func func(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n@@ -427,0 +428,9 @@\n+                static Func func(MethodHandles.Lookup lookup,Class<?> clazz,String name , Class<?> ...parameterTypes) {\n+                    try {\n+                        var addMethod = Op.ofMethod(clazz.getDeclaredMethod(name, parameterTypes)).orElseThrow();\n+                        return func(lookup,addMethod);\n+                    }catch (NoSuchMethodException nsme){\n+                        throw new RuntimeException(nsme);\n+                    }\n+                }\n+\n@@ -614,0 +624,43 @@\n+        interface Span {\n+            List<Op> ops();\n+            default Op from() {\n+                return ops().getFirst();\n+            }\n+            default Op to() {\n+                return ops().getLast();\n+            }\n+            default boolean firstOrLast(Op op){\n+                return isTo(op)||isFrom(op);\n+            }\n+            default boolean isTo(Op op) {\n+                return to().equals(op);\n+            }\n+            default boolean isFrom(Op op) {\n+                return from().equals(op);\n+            }\n+        }\n+\n+        static <T extends Span> Map<Op,T> createOpToStatementSpanMap(CoreOp.FuncOp funcOp,\n+                                                                     Predicate<Op> predicate,\n+                                                                     Function<List<Op>,T> factory ) {\n+            Map<Op, T> opToStatementSpanMap = new LinkedHashMap<>();\n+            funcOp.elements()\n+                    .filter(ce -> ce instanceof Block)\n+                    .map(ce -> (Block) ce)\n+                    .forEach(block -> {\n+                        var statementOps = new LinkedList<Op>();\n+                        block.ops().forEach(op -> {\n+                            statementOps.add(op);\n+                            if (Statement.asStatementOpOrNull(op) != null) {\n+                               if (statementOps.stream().anyMatch(predicate)) {\n+                                   T span = factory.apply(new LinkedList<>(statementOps));\n+                                   statementOps.forEach(opInList -> \/\/ we take a snapshot of statementOps\n+                                           opToStatementSpanMap.put(opInList, span)\n+                                   );\n+                               }\n+                                statementOps.clear(); \/\/ and then cleat for the next one\n+                            }\n+                        });\n+                    });\n+            return opToStatementSpanMap;\n+        }\n@@ -615,1 +668,1 @@\n-       private  static Op asStatementOpOrNull(CodeElement<?, ?> ce) {\n+        static Op asStatementOpOrNull(CodeElement<?, ?> ce) {\n@@ -620,1 +673,1 @@\n-                                        || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n+                                        || (op instanceof CoreOp.VarOp || (op.result() instanceof Op.Result result && result.uses().isEmpty()))\n@@ -638,1 +691,1 @@\n-       private static boolean isStatementOp(CodeElement<?, ?> ce) {\n+        static boolean isStatementOp(CodeElement<?, ?> ce) {\n@@ -728,0 +781,20 @@\n+    static Block.Parameter getFuncParamOrNull(Op op, int n) {\n+        while (op != null && !(op instanceof CoreOp.FuncOp)) {\n+          \/\/  System.out.println(op);\n+            op = op.ancestorOp();\n+        }\n+        if (op instanceof CoreOp.FuncOp funcOp) {\n+            return funcOp.bodies().get(0).entryBlock().parameters().get(n);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static Block.Parameter getFuncParamOrThrow(Op op, int n) {\n+        if (getFuncParamOrNull(op, n) instanceof Block.Parameter parameter) {\n+            return parameter;\n+        } else {\n+            throw new IllegalStateException(\"cant find func parameter parameter \" + n);\n+        }\n+    }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":79,"deletions":6,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import optkl.util.StreamMutable;\n+import optkl.util.Mutable;\n@@ -495,1 +495,1 @@\n-        var first = StreamMutable.of(true);\n+        var first = Mutable.of(true);\n@@ -546,1 +546,1 @@\n-        var first = StreamMutable.of(true);\n+        var first = Mutable.of(true);\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/CodeBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import optkl.util.StreamMutable;\n+import optkl.util.Mutable;\n@@ -300,2 +300,2 @@\n-            var lastWasBody = StreamMutable.of(false);\n-            var i = StreamMutable.of(0);\n+            var lastWasBody = Mutable.of(false);\n+            var i = Mutable.of(0);\n@@ -505,8 +505,26 @@\n-        scopedCodeBuilderContext().lambdaScope(lambdaOp,()->\n-          braceNlIndented(_-> {\n-            blockInlineComment(\"LAMBDA\");\n-            nlSeparated(OpHelper.Statement.bodyStatements(lambdaOp.body()),\n-                    this::statement\n-            );\n-            blockInlineComment(\"ADBMAL\");\n-          })\n+        scopedCodeBuilderContext().lambdaScope(lambdaOp,()-> {\n+                    var parameters = lambdaOp.body().entryBlock().parameters();\n+                  \/\/  if (parameters.isEmpty()) {\n+                    \/\/    ocparen();\n+                    \/\/}else{\n+                        parenWhen(parameters.size()!=1,_->{\n+                           commaSpaceSeparated(parameters,$->\n+                               varName((CoreOp.VarOp)$.uses().stream().findFirst().get().op())\n+                           );\n+                        });\n+                    \/\/}\n+                    space().rarrow().space();\n+                    braceNlIndented(_ -> {\n+                        nlSeparated(OpHelper.Statement.bodyStatements(lambdaOp.body()),\n+                                op->{\n+                                    if (op instanceof CoreOp.VarOp varOp\n+                                            && varOp.operands().getFirst() instanceof Block.Parameter parameter\n+                                           ){\n+                                        varName(varOp);\n+                                    }else {\n+                                        statement(op);\n+                                    }\n+                                }\n+                        );\n+                    });\n+                }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaOrC99StyleCodeBuilder.java","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -27,8 +27,0 @@\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.util.StreamMutable;\n-\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n-\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/ScopedCodeBuilder.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,0 +86,3 @@\n+        public boolean mutatesBuffer(){\n+            return rw()||wo();\n+        }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/ifacemapper\/AccessType.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import optkl.util.StreamMutable;\n+import optkl.util.Mutable;\n@@ -224,1 +224,1 @@\n-        var typeStreamMutable = StreamMutable.of(null);\n+        var typeStreamMutable = Mutable.of(null);\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/ifacemapper\/MapperUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.util;\n+\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class BiMapOfSets<From, To> {\n+    private Map<From, Set<To>> fromTo = new LinkedHashMap<>();\n+    private Map<To, Set<From>> toFrom = new LinkedHashMap<>();\n+\n+    public void add(From from, To to) {\n+        fromTo.computeIfAbsent(from,_->new LinkedHashSet<>()).add(to);\n+        toFrom.computeIfAbsent(to,_->new LinkedHashSet<>()).add(from);\n+    }\n+\n+    public Set<From> getFrom(To to) {\n+        return toFrom.get(to);\n+    }\n+\n+    public Set<To> getTo(From from) {\n+        return fromTo.get(from);\n+    }\n+\n+    public boolean containsFrom(From from) {\n+        return fromTo.containsKey(from);\n+    }\n+\n+    public boolean containsTo(To to) {\n+        return toFrom.containsKey(to);\n+    }\n+\n+    public Iterable<From> fromKeys() {\n+        return fromTo.keySet();\n+    }\n+    public Iterable<To> toKeys() {\n+        return toFrom.keySet();\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/util\/BiMapOfSets.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.util;\n+\n+public class Mutable<R> {\n+    private R value;\n+    public R get() {\n+        return value;\n+    }\n+    public Mutable<R> setIf(boolean iff, R value) {\n+        this.value = iff?value:this.value;\n+        return this;\n+    }\n+    public Mutable<R> set(R value) {\n+      return setIf(true, value);\n+    }\n+    public boolean eq(R r){\n+        return value == null && r == null  || r.equals(value);\n+    }\n+    private Mutable(){}\n+    static public <R> Mutable<R> of(R value){\n+        return new Mutable<R>().set(value);\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/util\/Mutable.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl.util;\n-\n-public class StreamMutable<R> {\n-    private R value;\n-    public R get() {\n-        return value;\n-    }\n-    public StreamMutable<R> setIf(boolean iff,R value) {\n-        this.value = iff?value:this.value;\n-        return this;\n-    }\n-    public StreamMutable<R> set(R value) {\n-      return setIf(true, value);\n-    }\n-    public boolean eq(R r){\n-        return value == null && r == null  || r.equals(value);\n-    }\n-    private StreamMutable(){}\n-    static public <R> StreamMutable<R> of(R value){\n-        return new StreamMutable<R>().set(value);\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/util\/StreamMutable.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"}]}