{"files":[{"patch":"@@ -85,2 +85,2 @@\n-            TypeElement resultType = new PointerType(jvop.varType(), StorageType.CROSSWORKGROUP);\n-            SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.attributes().get(\"\"), resultType, jvop.varType());\n+            TypeElement resultType = new PointerType(jvop.varValueType(), StorageType.CROSSWORKGROUP);\n+            SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.attributes().get(\"\"), resultType, jvop.varValueType());\n@@ -100,2 +100,2 @@\n-                    TypeElement resultType = new PointerType(jvop.varType(), StorageType.CROSSWORKGROUP);\n-                    SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.attributes().get(\"\"), resultType, jvop.varType());\n+                    TypeElement resultType = new PointerType(jvop.varValueType(), StorageType.CROSSWORKGROUP);\n+                    SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.attributes().get(\"\"), resultType, jvop.varValueType());\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-        return (JavaType) op().varType();\n+        return (JavaType) op().varValueType();\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -695,1 +695,1 @@\n-         * @param args        the list of values to map to the parameters of the body's entry block\n+         * @param args        the list of output values to map to the input parameters of the body's entry block\n@@ -724,1 +724,1 @@\n-         * @param args            the list of values to map to the parameters of the body's entry block\n+         * @param args            the list of output values to map to the input parameters of the body's entry block\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Block.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-                                    varOp -> bb.parameter(varOp.varType())));\n+                                    varOp -> bb.parameter(varOp.varValueType())));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/SSA.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1992,1 +1992,1 @@\n-        final TypeElement resultType;\n+        final VarType resultType;\n@@ -2011,1 +2011,1 @@\n-            this.resultType = def.resultType();\n+            this.resultType = (VarType) def.resultType();\n@@ -2018,1 +2018,6 @@\n-            this.resultType = that.resultType;\n+            this.resultType = that.isResultTypeOverridable()\n+                    ? VarType.varType(initOperand().type()) : that.resultType;\n+        }\n+\n+        boolean isResultTypeOverridable() {\n+            return resultType().valueType().equals(initOperand().type());\n@@ -2048,0 +2053,4 @@\n+        public Value initOperand() {\n+            return operands().getFirst();\n+        }\n+\n@@ -2052,2 +2061,2 @@\n-        public TypeElement varType() {\n-            return ((VarType) resultType).valueType();\n+        public TypeElement varValueType() {\n+            return resultType.valueType();\n@@ -2057,1 +2066,1 @@\n-        public TypeElement resultType() {\n+        public VarType resultType() {\n@@ -2080,0 +2089,8 @@\n+        public Value varOperand() {\n+            return operands().getFirst();\n+        }\n+\n+        public VarType varType() {\n+            return (VarType) varOperand().type();\n+        }\n+\n@@ -2081,5 +2098,8 @@\n-            \/\/ @@@ At a high-level a Var value occur as a BlockArgument.\n-            \/\/ Lowering should remove such cases and the var definition should emerge\n-            \/\/ @@@ This method is used when transforming to pure SSA\n-            Result variable = (Result) operands().get(0);\n-            return (VarOp) variable.op();\n+            if (!(varOperand() instanceof Result varValue)) {\n+                throw new IllegalStateException(\"Variable access to block parameter: \" + varOperand());\n+            }\n+\n+            \/\/ At a high-level a variable value can be a BlockArgument.\n+            \/\/ Lowering should remove such cases and the var declaration should emerge\n+            \/\/ This method is primarily used when transforming to pure SSA\n+            return (VarOp) varValue.op();\n@@ -2088,1 +2108,1 @@\n-        static Value checkIsVarOp(Value varValue) {\n+        static void checkIsVarOp(Value varValue) {\n@@ -2092,1 +2112,0 @@\n-            return varValue;\n@@ -2132,2 +2151,1 @@\n-                VarType vt = (VarType) operands().get(0).type();\n-                return vt.valueType();\n+                return varType().valueType();\n@@ -2174,0 +2192,4 @@\n+            public Value storeOperand() {\n+                return operands().get(1);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":37,"deletions":15,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-    final TypeElement variableType;\n+    final TypeElement valueType;\n@@ -15,2 +15,2 @@\n-    VarType(TypeElement variableType) {\n-        this.variableType = variableType;\n+    VarType(TypeElement valueType) {\n+        this.valueType = valueType;\n@@ -23,1 +23,1 @@\n-        return variableType;\n+        return valueType;\n@@ -28,1 +28,1 @@\n-        return new ExternalizedTypeElement(NAME, List.of(variableType.externalize()));\n+        return new ExternalizedTypeElement(NAME, List.of(valueType.externalize()));\n@@ -40,1 +40,1 @@\n-                variableType.equals(that.variableType);\n+                valueType.equals(that.valueType);\n@@ -45,1 +45,1 @@\n-        return variableType.hashCode();\n+        return valueType.hashCode();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/VarType.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -273,4 +273,1 @@\n-                    .body(builder -> builder.transformBody(original.body(), builder.parameters(), (block, op) -> {\n-                                block.context().mapValue(op.result(), block.op(retype(block.context(), op)));\n-                                return block;\n-                            })\n+                    .body(builder -> builder.transformBody(original.body(), builder.parameters(), OpTransformer.COPYING_TRANSFORMER)\n@@ -280,8 +277,0 @@\n-        private static Op retype(CopyContext context, Op op) {\n-            return switch (op) {\n-                case CoreOp.VarOp varOp ->\n-                        CoreOp.var(varOp.varName(), context.getValueOrDefault(varOp.operands().getFirst(), varOp.operands().getFirst()));\n-                default -> op;\n-            };\n-        }\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/CoreBinaryOpsTest.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestVarOp\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestVarOp {\n+\n+    @CodeReflection\n+    static Object f(String s) {\n+        Object o = s;\n+        return o;\n+    }\n+\n+    @Test\n+    public void testTypeSubstitutionAndPreserve() {\n+        CoreOp.FuncOp f = getFuncOp(\"f\");\n+        CoreOp.FuncOp ft = CoreOp.func(\"f\", FunctionType.functionType(JavaType.J_L_OBJECT, JavaType.type(CharSequence.class)))\n+                .body(fb -> {\n+                    fb.transformBody(f.body(), fb.parameters(), OpTransformer.COPYING_TRANSFORMER);\n+                });\n+\n+        List<CoreOp.VarOp> vops = ft.elements()\n+                .flatMap(ce -> ce instanceof CoreOp.VarOp vop ? Stream.of(vop) : null)\n+                .toList();\n+        \/\/ VarOp for block parameter, translate from String to CharSequence\n+        Assert.assertEquals(vops.get(0).resultType().valueType(), JavaType.type(CharSequence.class));\n+        \/\/ VarOp for local variable, preserve Object\n+        Assert.assertEquals(vops.get(1).resultType().valueType(), JavaType.J_L_OBJECT);\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestVarOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarOp.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"}]}