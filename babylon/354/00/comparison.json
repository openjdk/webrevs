{"files":[{"patch":"@@ -71,2 +71,2 @@\n-    public CudaHatKernelBuilder functionDeclaration(MethodHandles.Lookup lookup,JavaType javaType, String name) {\n-        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(lookup,javaType).space().identifier(name);\n+    public CudaHatKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext,JavaType javaType, String name) {\n+        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(codeBuilderContext,javaType).space().identifier(name);\n@@ -82,1 +82,1 @@\n-    public CudaHatKernelBuilder atomicInc(CodeBuilderContext buildContext, MethodHandles.Lookup lookup,Op.Result instanceResult, String name){\n+    public CudaHatKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n@@ -84,1 +84,1 @@\n-             ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op(),lookup));\n+             ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHatKernelBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-    public OpenCLHatKernelBuilder functionDeclaration(MethodHandles.Lookup lookup,JavaType type, String name) {\n-        return keyword(\"inline\").space().type(lookup,type).space().identifier(name);\n+    public OpenCLHatKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext,JavaType type, String name) {\n+        return keyword(\"inline\").space().type(codeBuilderContext,type).space().identifier(name);\n@@ -78,1 +78,1 @@\n-    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext, MethodHandles.Lookup lookup, Op.Result instanceResult, String name){\n+    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext,  Op.Result instanceResult, String name){\n@@ -80,1 +80,1 @@\n-              ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op(),lookup));\n+              ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHatKernelBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.entrypoint.funcOpWrapper().op(),kernelCallGraph.computeContext.accelerator.lookup);\n+        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op());\n@@ -121,1 +121,1 @@\n-            FuncOpWrapper calledFunc = new FuncOpWrapper(k.funcOpWrapper().op(),kernelCallGraph.computeContext.accelerator.lookup);\n+            FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,k.funcOpWrapper().op());\n@@ -140,1 +140,1 @@\n-        return FuncOpWrapper.wrap(func.op().transform((block, op) -> {\n+        return FuncOpWrapper.wrap(func.lookup,func.op().transform((block, op) -> {\n@@ -144,1 +144,1 @@\n-                    && OpWrapper.wrap(invokeOp, func.lookup) instanceof InvokeOpWrapper invokeOpWrapper) {\n+                    && OpWrapper.wrap(func.lookup,invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n@@ -168,1 +168,1 @@\n-        }),func.lookup);\n+        }));\n@@ -185,1 +185,1 @@\n-        ssa.firstBody().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(o,lowered.lookup))));\n+        ssa.firstBody().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(lowered.lookup,o))));\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXBackend.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-                call().uni().space().oparen().retVal().cparen().commaSpace().append(op.methodNoLookup().getName()).commaSpace();\n+                call().uni().space().oparen().retVal().cparen().commaSpace().append(op.method().getName()).commaSpace();\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-    public OpenCLHatKernelBuilder functionDeclaration(MethodHandles.Lookup lookup,JavaType type, String name) {\n-        return keyword(\"inline\").space().type(lookup,type).space().identifier(name);\n+    public OpenCLHatKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext,JavaType type, String name) {\n+        return keyword(\"inline\").space().type(codeBuilderContext,type).space().identifier(name);\n@@ -77,1 +77,1 @@\n-    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext, MethodHandles.Lookup lookup, Op.Result instanceResult, String name){\n+    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext,  Op.Result instanceResult, String name){\n@@ -79,1 +79,1 @@\n-              ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op(),lookup));\n+              ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -322,2 +323,2 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n-        var accelerator = new Accelerator(lookup, Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Chess.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST_NATIVE);\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LambdaTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        FuncOpWrapper wf = OpWrapper.wrap(f, lookup);\n+        FuncOpWrapper wf = OpWrapper.wrap(lookup,f);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.JAVA_MULTITHREADED);\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/attic\/ViolaJonesRaw.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,2 +194,2 @@\n-        LambdaOpWrapper lambda = OpWrapper.wrap((CoreOp.LambdaOp) quoted.op(),lookup);\n-        Method method = lambda.getQuotableTargetMethod(this.lookup);\n+        LambdaOpWrapper lambda = OpWrapper.wrap(lookup,(CoreOp.LambdaOp) quoted.op());\n+        Method method = lambda.getQuotableTargetMethod();\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/Accelerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-        FuncOpWrapper funcOpWrapper = OpWrapper.wrap(Op.ofMethod(computeMethod).orElseThrow(),accelerator.lookup);\n+        FuncOpWrapper funcOpWrapper = OpWrapper.wrap(accelerator.lookup,Op.ofMethod(computeMethod).orElseThrow());\n@@ -130,1 +130,1 @@\n-        LambdaOpWrapper lambdaOpWrapper = OpWrapper.wrap((CoreOp.LambdaOp) quoted.op(),computeCallGraph.computeContext.accelerator.lookup);\n+        LambdaOpWrapper lambdaOpWrapper = OpWrapper.wrap(computeCallGraph.computeContext.accelerator.lookup,(CoreOp.LambdaOp) quoted.op());\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/ComputeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-                        && OpWrapper.wrap(invokeOp,lookup) instanceof InvokeOpWrapper invokeOpWrapper\n+                        && OpWrapper.wrap(lookup, invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/OpsAndTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+        CodeBuilderContext buildContext = new CodeBuilderContext(funcOpWrapper);\n@@ -44,1 +45,1 @@\n-                commaSeparated(funcOpWrapper.paramTable.list(), (info) -> type(funcOpWrapper.lookup,(JavaType) info.parameter.type()).space().varName(info.varOp))\n+                commaSeparated(funcOpWrapper.paramTable.list(), (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n@@ -46,1 +47,1 @@\n-        CodeBuilderContext buildContext = new CodeBuilderContext(funcOpWrapper);\n+\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATComputeBuilder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,2 +88,2 @@\n-    public T type(MethodHandles.Lookup lookup,JavaType javaType) {\n-        if (InvokeOpWrapper.isIface(lookup,javaType) && javaType instanceof ClassType classType) {\n+    public T type(CodeBuilderContext buildContext,JavaType javaType) {\n+        if (InvokeOpWrapper.isIfaceUsingLookup(buildContext.lookup(),javaType) && javaType instanceof ClassType classType) {\n@@ -110,1 +110,1 @@\n-            functionDeclaration(buildContext.funcOpWrapper.lookup,buildContext.funcOpWrapper.getReturnType(), buildContext.funcOpWrapper.functionName());\n+            functionDeclaration(buildContext,buildContext.funcOpWrapper.getReturnType(), buildContext.funcOpWrapper.functionName());\n@@ -114,1 +114,1 @@\n-                    commaSeparated(list, (info) -> type(buildContext.funcOpWrapper.lookup,info.javaType).space().varName(info.varOp))\n+                    commaSeparated(list, (info) -> type(buildContext,info.javaType).space().varName(info.varOp))\n@@ -147,1 +147,1 @@\n-                                comma().space().type(buildContext.funcOpWrapper.lookup,info.javaType).space().varName(info.varOp)\n+                                comma().space().type(buildContext,info.javaType).space().varName(info.varOp)\n@@ -169,1 +169,1 @@\n-    public abstract T functionDeclaration(MethodHandles.Lookup lookup,JavaType javaType, String name);\n+    public abstract T functionDeclaration(CodeBuilderContext codeBuilderContext,JavaType javaType, String name);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATKernelBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-         T parencedence(CodeBuilderContext buildContext, MethodHandles.Lookup lookup, Op parent, Op child);\n+         T parencedence(CodeBuilderContext buildContext,  Op parent, Op child);\n@@ -369,1 +369,3 @@\n-\n+        public MethodHandles.Lookup lookup(){\n+            return funcOpWrapper.lookup;\n+        }\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -140,3 +140,2 @@\n-    public T type(MethodHandles.Lookup lookup,JavaType javaType) {\n-       \/\/ if (FuncOpWrapper.ParamTable.Info.isIfaceBuffer(javaType) && javaType instanceof ClassType classType)\n-        if (InvokeOpWrapper.isIface(lookup,javaType) && javaType instanceof ClassType classType) {\n+    public T type(CodeBuilderContext buildContext,JavaType javaType) {\n+        if (InvokeOpWrapper.isIfaceUsingLookup(buildContext.lookup(),javaType) && javaType instanceof ClassType classType) {\n@@ -181,1 +180,1 @@\n-            type(varDeclarationOpWrapper.lookup,varDeclarationOpWrapper.javaType()).space().identifier(varDeclarationOpWrapper.varName());\n+            type(buildContext,varDeclarationOpWrapper.javaType()).space().identifier(varDeclarationOpWrapper.varName());\n@@ -183,1 +182,1 @@\n-            type(varDeclarationOpWrapper.lookup,varDeclarationOpWrapper.javaType()).space().identifier(varDeclarationOpWrapper.varName()).space().equals().space();\n+            type(buildContext,varDeclarationOpWrapper.javaType()).space().identifier(varDeclarationOpWrapper.varName()).space().equals().space();\n@@ -199,3 +198,1 @@\n-        } else if (fieldLoadOpWrapper.isStaticFinalPrimitive()) {\n-\n-            Object value = fieldLoadOpWrapper.getStaticFinalPrimitiveValue();\n+        } else if (fieldLoadOpWrapper.isStaticFinalPrimitive()) {    Object value = fieldLoadOpWrapper.getStaticFinalPrimitiveValue();\n@@ -248,1 +245,1 @@\n-        parencedence(buildContext, unaryOperatorOpWrapper.lookup,unaryOperatorOpWrapper.op(), unaryOperatorOpWrapper.operandNAsResult(0).op());\n+        parencedence(buildContext, unaryOperatorOpWrapper.op(), unaryOperatorOpWrapper.operandNAsResult(0).op());\n@@ -254,1 +251,1 @@\n-        parencedence(buildContext, binaryOperatorOpWrapper.lookup,binaryOperatorOpWrapper.op(), binaryOperatorOpWrapper.lhsAsOp());\n+        parencedence(buildContext, binaryOperatorOpWrapper.op(), binaryOperatorOpWrapper.lhsAsOp());\n@@ -256,1 +253,1 @@\n-        parencedence(buildContext, binaryOperatorOpWrapper.lookup,binaryOperatorOpWrapper.op(), binaryOperatorOpWrapper.rhsAsOp());\n+        parencedence(buildContext, binaryOperatorOpWrapper.op(), binaryOperatorOpWrapper.rhsAsOp());\n@@ -274,1 +271,1 @@\n-        parencedence(buildContext, binaryTestOpWrapper.lookup,binaryTestOpWrapper.op(), binaryTestOpWrapper.lhsAsOp());\n+        parencedence(buildContext, binaryTestOpWrapper.op(), binaryTestOpWrapper.lhsAsOp());\n@@ -276,1 +273,1 @@\n-        parencedence(buildContext, binaryTestOpWrapper.lookup,binaryTestOpWrapper.op(), binaryTestOpWrapper.rhsAsOp());\n+        parencedence(buildContext, binaryTestOpWrapper.op(), binaryTestOpWrapper.rhsAsOp());\n@@ -284,1 +281,1 @@\n-            paren(_ -> type(convOpWrapper.lookup,JavaType.FLOAT));\n+            paren(_ -> type(buildContext,JavaType.FLOAT));\n@@ -286,1 +283,1 @@\n-            paren(_ -> type(convOpWrapper.lookup,convOpWrapper.resultJavaType()));\n+            paren(_ -> type(buildContext,convOpWrapper.resultJavaType()));\n@@ -308,1 +305,1 @@\n-            recurse(buildContext, OpWrapper.wrap(result.op(),yieldOpWrapper.lookup));\n+            recurse(buildContext, OpWrapper.wrap(buildContext.lookup(), result.op()));\n@@ -327,1 +324,1 @@\n-                recurse(buildContext, OpWrapper.wrap(result.op(),tupleOpWrapper.lookup));\n+                recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),result.op()));\n@@ -355,1 +352,1 @@\n-        var labelNameOp = OpWrapper.wrap(javaLabeledOpWrapper.firstBlockOfFirstBody().ops().get(0),javaLabeledOpWrapper.lookup);\n+        var labelNameOp = OpWrapper.wrap(buildContext.lookup(),javaLabeledOpWrapper.firstBlockOfFirstBody().ops().get(0));\n@@ -359,1 +356,1 @@\n-        recurse(buildContext, OpWrapper.wrap(forLoopOp,javaLabeledOpWrapper.lookup));\n+        recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),forLoopOp));\n@@ -528,1 +525,1 @@\n-    public T atomicInc(CodeBuilderContext buildContext, MethodHandles.Lookup lookup,Op.Result instanceResult, String name) {\n+    public T atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n@@ -544,1 +541,1 @@\n-                    atomicInc(buildContext, invokeOpWrapper.lookup,instanceResult, name.substring(0, name.length() - 3));\n+                    atomicInc(buildContext, instanceResult, name.substring(0, name.length() - 3));\n@@ -600,1 +597,1 @@\n-                    recurse(buildContext, OpWrapper.wrap(instanceResult.op(),invokeOpWrapper.lookup));\n+                    recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n@@ -610,1 +607,1 @@\n-                                    equals().recurse(buildContext, OpWrapper.wrap(result1.op(),invokeOpWrapper.lookup));\n+                                    equals().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),result1.op()));\n@@ -619,2 +616,2 @@\n-                                    sbrace(_ -> recurse(buildContext, OpWrapper.wrap(result1.op(),invokeOpWrapper.lookup)));\n-                                    equals().recurse(buildContext, OpWrapper.wrap(result2.op(),invokeOpWrapper.lookup));\n+                                    sbrace(_ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),result1.op())));\n+                                    equals().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),result2.op()));\n@@ -632,1 +629,1 @@\n-                            var rhs = OpWrapper.wrap(result1.op(),invokeOpWrapper.lookup);\n+                            var rhs = OpWrapper.wrap(buildContext.lookup(),result1.op());\n@@ -647,1 +644,1 @@\n-                            recurse(buildContext, OpWrapper.wrap(result.op(),invokeOpWrapper.lookup));\n+                            recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),result.op()));\n@@ -684,2 +681,2 @@\n-    public T parencedence(CodeBuilderContext buildContext, MethodHandles.Lookup lookup, Op parent, Op child) {\n-        return parenWhen(precedenceOf(parent) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(child,lookup)));\n+    public T parencedence(CodeBuilderContext buildContext,  Op parent, Op child) {\n+        return parenWhen(precedenceOf(parent) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),child)));\n@@ -689,1 +686,1 @@\n-        return parenWhen(precedenceOf(parent.op()) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(child,parent.lookup)));\n+        return parenWhen(precedenceOf(parent.op()) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),child)));\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilderWithContext.java","additions":27,"deletions":30,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(prevFOW.lookup, javaType))\n+                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, javaType))\n@@ -128,1 +128,1 @@\n-                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(prevFOW.lookup,javaType))\n+                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup,javaType))\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(prevFOW.lookup,javaType))\n+                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup,javaType))\n@@ -123,1 +123,1 @@\n-                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(prevFOW.lookup,javaType))\n+                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup,javaType))\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                        } else if (InvokeOpWrapper.isIface(fow.lookup,paramInfo.javaType)) {\n+                        } else if (InvokeOpWrapper.isIfaceUsingLookup(fow.lookup,paramInfo.javaType)) {\n@@ -151,1 +151,1 @@\n-            Method invokeWrapperCalledMethod = invokeWrapper.method(this.computeContext.accelerator.lookup);\n+            Method invokeWrapperCalledMethod = invokeWrapper.method();\n@@ -171,1 +171,1 @@\n-                    FuncOpWrapper fow = OpWrapper.wrap(optionalFuncOp.get(),computeContext.accelerator.lookup);\n+                    FuncOpWrapper fow = OpWrapper.wrap(computeContext.accelerator.lookup,optionalFuncOp.get());\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-            Method invokeOpCalledMethod = invokeOpWrapper.method(this.computeContext.accelerator.lookup);\n+            Method invokeOpCalledMethod = invokeOpWrapper.method();\n@@ -112,1 +112,1 @@\n-                            new KernelReachableResolvedMethodCall(this, methodRef, invokeOpCalledMethod, OpWrapper.wrap(optionalFuncOp.get(),computeContext.accelerator.lookup)\n+                            new KernelReachableResolvedMethodCall(this, methodRef, invokeOpCalledMethod, OpWrapper.wrap(computeContext.accelerator.lookup,optionalFuncOp.get())\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    BinaryArithmeticOrLogicOperation(CoreOp.BinaryOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    BinaryArithmeticOrLogicOperation( MethodHandles.Lookup lookup, CoreOp.BinaryOp op) {\n+        super(lookup, op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryArithmeticOrLogicOperation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    BinaryLogicalOpWrapper(CoreOp.BinaryOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    BinaryLogicalOpWrapper( MethodHandles.Lookup lookup,CoreOp.BinaryOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryLogicalOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    BinaryOpWrapper(T op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    BinaryOpWrapper( MethodHandles.Lookup lookup,T op) {\n+        super(lookup, op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    BinaryTestOpWrapper(CoreOp.BinaryTestOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    BinaryTestOpWrapper( MethodHandles.Lookup lookup,CoreOp.BinaryTestOp op) {\n+        super(lookup, op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryTestOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    ConstantOpWrapper(CoreOp.ConstantOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    ConstantOpWrapper( MethodHandles.Lookup lookup,CoreOp.ConstantOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ConstantOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    public ConvOpWrapper(CoreOp.ConvOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public ConvOpWrapper( MethodHandles.Lookup lookup,CoreOp.ConvOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ConvOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    FieldAccessOpWrapper(T op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    FieldAccessOpWrapper( MethodHandles.Lookup lookup,T op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldAccessOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    FieldLoadOpWrapper(CoreOp.FieldAccessOp.FieldLoadOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    FieldLoadOpWrapper( MethodHandles.Lookup lookup,CoreOp.FieldAccessOp.FieldLoadOp op) {\n+        super(lookup,op);\n@@ -41,1 +41,1 @@\n-            Class<?> clazz = (Class<?>) classTypeToType(lookup,classType);\n+            Class<?> clazz = (Class<?>) classTypeToType(classType);\n@@ -46,3 +46,1 @@\n-            } catch (NoSuchFieldException e) {\n-                throw new RuntimeException(e);\n-            } catch (IllegalAccessException e) {\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldLoadOpWrapper.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    FieldStoreOpWrapper(CoreOp.FieldAccessOp.FieldStoreOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    FieldStoreOpWrapper( MethodHandles.Lookup lookup,CoreOp.FieldAccessOp.FieldStoreOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldStoreOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    ForOpWrapper(ExtendedOp.JavaForOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    ForOpWrapper( MethodHandles.Lookup lookup,ExtendedOp.JavaForOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ForOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public FuncCallOpWrapper(CoreOp.FuncCallOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public FuncCallOpWrapper( MethodHandles.Lookup lookup,CoreOp.FuncCallOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FuncCallOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,2 +168,2 @@\n-    public FuncOpWrapper(CoreOp.FuncOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public FuncOpWrapper( MethodHandles.Lookup lookup,CoreOp.FuncOp op) {\n+        super(lookup,op);\n@@ -192,1 +192,1 @@\n-        return OpWrapper.wrap(op().transform((block, op) -> {\n+        return OpWrapper.wrap(lookup,op().transform((block, op) -> {\n@@ -199,1 +199,1 @@\n-        }),lookup);\n+        }));\n@@ -203,1 +203,1 @@\n-        return OpWrapper.wrap(SSA.transform(op()),lookup);\n+        return OpWrapper.wrap(lookup,SSA.transform(op()));\n@@ -230,1 +230,1 @@\n-        return OpWrapper.wrap(op().transform((b, op) -> {\n+        return OpWrapper.wrap(lookup,op().transform((b, op) -> {\n@@ -232,1 +232,1 @@\n-                wrappedOpTransformer.apply(b, OpWrapper.wrap(invokeOp,lookup));\n+                wrappedOpTransformer.apply(b, OpWrapper.wrap(lookup,invokeOp));\n@@ -237,1 +237,1 @@\n-        }),lookup);\n+        }));\n@@ -241,1 +241,1 @@\n-        return OpWrapper.wrap(op().transform((b, op) -> {\n+        return OpWrapper.wrap(lookup,op().transform((b, op) -> {\n@@ -243,1 +243,1 @@\n-                InvokeOpWrapper wrapped = OpWrapper.wrap(invokeOp,lookup);\n+                InvokeOpWrapper wrapped = OpWrapper.wrap(lookup,invokeOp);\n@@ -253,1 +253,1 @@\n-        }),lookup);\n+        }));\n@@ -285,2 +285,2 @@\n-        return OpWrapper.wrap(op().transform((b, op) -> {\n-            var replacer = new WrappedOpReplacer(b, OpWrapper.wrap(op,lookup));\n+        return OpWrapper.wrap(lookup, op().transform((b, op) -> {\n+            var replacer = new WrappedOpReplacer(b, OpWrapper.wrap(lookup,op));\n@@ -292,1 +292,1 @@\n-        }),lookup);\n+        }));\n@@ -299,2 +299,2 @@\n-        return OpWrapper.wrap(op().transform((b, op) -> {\n-            var opWrapper = OpWrapper.wrap(op,lookup);\n+        return OpWrapper.wrap(lookup, op().transform((b, op) -> {\n+            var opWrapper = OpWrapper.wrap(lookup,op);\n@@ -311,1 +311,1 @@\n-        }),lookup);\n+        }));\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    public IfOpWrapper(ExtendedOp.JavaIfOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public IfOpWrapper(MethodHandles.Lookup lookup,ExtendedOp.JavaIfOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/IfOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.code.Block;\n@@ -40,1 +39,0 @@\n-import java.util.stream.Stream;\n@@ -42,1 +40,0 @@\n-\/\/ Is this really a root?\n@@ -46,2 +43,2 @@\n-    public InvokeOpWrapper(CoreOp.InvokeOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public InvokeOpWrapper( MethodHandles.Lookup lookup,CoreOp.InvokeOp op) {\n+        super(lookup,op);\n@@ -59,1 +56,1 @@\n-        return isIface(lookup,javaRefType());\n+        return isIface(javaRefType());\n@@ -62,1 +59,0 @@\n-\n@@ -64,1 +60,1 @@\n-        boolean isRawKernelCall = (operandCount() > 1 && operandNAsValue(0) instanceof Value value\n+        return (operandCount() > 1 && operandNAsValue(0) instanceof Value value\n@@ -66,1 +62,1 @@\n-                && (isAssignable(lookup,javaType, hat.KernelContext.class) || isAssignable(lookup,javaType, hat.buffer.KernelContext.class))\n+                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, KernelContext.class))\n@@ -68,1 +64,0 @@\n-        return isRawKernelCall;\n@@ -72,1 +67,1 @@\n-        return isAssignable(lookup,javaRefType(), KernelContext.class);\n+        return isAssignable(javaRefType(), KernelContext.class);\n@@ -77,1 +72,1 @@\n-        return isAssignable(lookup,javaRefType(), ComputeContext.class);\n+        return isAssignable(javaRefType(), ComputeContext.class);\n@@ -93,1 +88,1 @@\n-\n+\/*\n@@ -111,2 +106,2 @@\n-    }\n-    public Method method(MethodHandles.Lookup lookup) {\n+    } *\/\n+    public Method method() {\n@@ -115,3 +110,3 @@\n-            invokedMethod = methodRef().resolveToMethod(lookup, op().invokeKind());\n-            MethodRef methodRef = methodRef();\n-            return invokedMethod;\n+            return methodRef().resolveToMethod(lookup, op().invokeKind());\n+          \/\/  MethodRef methodRef = methodRef();\n+         \/\/   return invokedMethod;\n@@ -156,1 +151,1 @@\n-            return Optional.of((Class<?>)classTypeToType(lookup,classType));\n+            return Optional.of((Class<?>)classTypeToType(classType));\n@@ -164,1 +159,1 @@\n-            return Optional.of((Class<?>)classTypeToType(lookup,classType));\n+            return Optional.of((Class<?>)classTypeToType(classType));\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public JavaBreakOpWrapper(ExtendedOp.JavaBreakOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public JavaBreakOpWrapper( MethodHandles.Lookup lookup,ExtendedOp.JavaBreakOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaBreakOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public JavaContinueOpWrapper(ExtendedOp.JavaContinueOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public JavaContinueOpWrapper(MethodHandles.Lookup lookup,ExtendedOp.JavaContinueOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaContinueOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public JavaLabeledOpWrapper(ExtendedOp.JavaLabeledOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public JavaLabeledOpWrapper( MethodHandles.Lookup lookup,ExtendedOp.JavaLabeledOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaLabeledOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-    public LambdaOpWrapper(CoreOp.LambdaOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public LambdaOpWrapper( MethodHandles.Lookup lookup, CoreOp.LambdaOp op) {\n+        super(lookup,op);\n@@ -50,1 +50,1 @@\n-        return OpWrapper.wrap(result.get(),lookup);\n+        return OpWrapper.wrap(lookup, result.get());\n@@ -57,2 +57,2 @@\n-    public Method getQuotableTargetMethod(MethodHandles.Lookup lookup) {\n-        return getQuotableTargetInvokeOpWrapper().method(lookup);\n+    public Method getQuotableTargetMethod() {\n+        return getQuotableTargetInvokeOpWrapper().method();\n@@ -62,1 +62,1 @@\n-        return OpWrapper.wrap(op().body().entryBlock().ops().stream()\n+        return OpWrapper.wrap(lookup, op().body().entryBlock().ops().stream()\n@@ -65,1 +65,1 @@\n-                .findFirst().get(),lookup);\n+                .findFirst().get());\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LambdaOpWrapper.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    LogicalOpWrapper(ExtendedOp.JavaConditionalOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    LogicalOpWrapper(MethodHandles.Lookup lookup,ExtendedOp.JavaConditionalOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LogicalOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    LoopOpWrapper(T op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    LoopOpWrapper(MethodHandles.Lookup lookup, T op ) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LoopOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    ModuleOpWrapper(CoreOp.ModuleOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    ModuleOpWrapper(MethodHandles.Lookup lookup,CoreOp.ModuleOp op) {\n+        super(lookup,op);\n@@ -53,1 +53,1 @@\n-    public static ModuleOpWrapper createTransitiveInvokeModule(MethodHandles.Lookup lookup,\n+    public  ModuleOpWrapper createTransitiveInvokeModule(\n@@ -57,1 +57,1 @@\n-            return OpWrapper.wrap(createTransitiveInvokeModule(lookup, MethodRef.method(entryPoint), codeModel.get()),lookup);\n+            return OpWrapper.wrap(lookup, createTransitiveInvokeModule( MethodRef.method(entryPoint), codeModel.get()));\n@@ -59,1 +59,1 @@\n-            return OpWrapper.wrap(CoreOp.module(List.of()),lookup);\n+            return OpWrapper.wrap(lookup, CoreOp.module(List.of()));\n@@ -62,1 +62,1 @@\n-   \/* static Method resolveToMethod(MethodHandles.Lookup lookup, MethodRef invokedMethodRef){\n+   \/*  Method resolveToMethod(MethodHandles.Lookup lookup, MethodRef invokedMethodRef){\n@@ -72,1 +72,1 @@\n-    static CoreOp.ModuleOp createTransitiveInvokeModule(MethodHandles.Lookup lookup,\n+     CoreOp.ModuleOp createTransitiveInvokeModule(\n@@ -81,2 +81,2 @@\n-                            if (op instanceof CoreOp.InvokeOp invokeOp && OpWrapper.wrap(invokeOp,lookup) instanceof InvokeOpWrapper invokeOpWrapper) {\n-                                Method invokedMethod = invokeOpWrapper.method(lookup);\n+                            if (op instanceof CoreOp.InvokeOp invokeOp && OpWrapper.wrap(lookup, invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n+                                Method invokedMethod = invokeOpWrapper.method();\n@@ -84,1 +84,1 @@\n-                                if (optionalInvokedFuncOp.isPresent() && OpWrapper.wrap(optionalInvokedFuncOp.get(),lookup) instanceof FuncOpWrapper funcOpWrapper) {\n+                                if (optionalInvokedFuncOp.isPresent() && OpWrapper.wrap(lookup, optionalInvokedFuncOp.get()) instanceof FuncOpWrapper funcOpWrapper) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    public static <O extends Op, OW extends OpWrapper<O>> OW wrap(O op, MethodHandles.Lookup lookup) {\n+    public static <O extends Op, OW extends OpWrapper<O>> OW wrap(MethodHandles.Lookup lookup,O op) {\n@@ -55,1 +55,1 @@\n-            \/\/ use the raw model. Basically we want a different wrapper for VarDeclations\n+            \/\/ use the raw model. Basically we want a different wrapper for VarDeclarations\n@@ -61,1 +61,1 @@\n-                return (OW) new VarFuncDeclarationOpWrapper(varOp, funcOp, parameter,lookup);\n+                return (OW) new VarFuncDeclarationOpWrapper(lookup,varOp, funcOp, parameter);\n@@ -65,28 +65,28 @@\n-            case CoreOp.ModuleOp $ -> (OW) new ModuleOpWrapper($,lookup);\n-            case ExtendedOp.JavaForOp $ -> (OW) new ForOpWrapper($,lookup);\n-            case ExtendedOp.JavaWhileOp $ -> (OW) new WhileOpWrapper($,lookup);\n-            case ExtendedOp.JavaIfOp $ -> (OW) new IfOpWrapper($,lookup);\n-            case CoreOp.NotOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper($,lookup);\n-            case CoreOp.NegOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper($,lookup);\n-            case CoreOp.BinaryOp $ -> (OW) new BinaryArithmeticOrLogicOperation($,lookup);\n-            case CoreOp.BinaryTestOp $ -> (OW) new BinaryTestOpWrapper($,lookup);\n-            case CoreOp.FuncOp $ -> (OW) new FuncOpWrapper($,lookup);\n-            case CoreOp.VarOp $ -> (OW) new VarDeclarationOpWrapper($,lookup);\n-            case CoreOp.YieldOp $ -> (OW) new YieldOpWrapper($,lookup);\n-            case CoreOp.FuncCallOp $ -> (OW) new FuncCallOpWrapper($,lookup);\n-            case CoreOp.ConvOp $ -> (OW) new ConvOpWrapper($,lookup);\n-            case CoreOp.ConstantOp $ -> (OW) new ConstantOpWrapper($,lookup);\n-            case CoreOp.ReturnOp $ -> (OW) new ReturnOpWrapper($,lookup);\n-            case CoreOp.VarAccessOp.VarStoreOp $ -> (OW) new VarStoreOpWrapper($,lookup);\n-            case CoreOp.VarAccessOp.VarLoadOp $ -> (OW) new VarLoadOpWrapper($,lookup);\n-            case CoreOp.FieldAccessOp.FieldStoreOp $ -> (OW) new FieldStoreOpWrapper($,lookup);\n-            case CoreOp.FieldAccessOp.FieldLoadOp $ -> (OW) new FieldLoadOpWrapper($,lookup);\n-            case CoreOp.InvokeOp $ -> (OW) new InvokeOpWrapper($,lookup);\n-            case CoreOp.TupleOp $ -> (OW) new TupleOpWrapper($,lookup);\n-            case CoreOp.LambdaOp $ -> (OW) new LambdaOpWrapper($,lookup);\n-            case ExtendedOp.JavaConditionalOp $ -> (OW) new LogicalOpWrapper($,lookup);\n-            case ExtendedOp.JavaConditionalExpressionOp $ -> (OW) new TernaryOpWrapper($,lookup);\n-            case ExtendedOp.JavaLabeledOp $ -> (OW) new JavaLabeledOpWrapper($,lookup);\n-            case ExtendedOp.JavaBreakOp $ -> (OW) new JavaBreakOpWrapper($,lookup);\n-            case ExtendedOp.JavaContinueOp $ -> (OW) new JavaContinueOpWrapper($,lookup);\n-            default -> (OW) new OpWrapper<>(op,lookup);\n+            case CoreOp.ModuleOp $ -> (OW) new ModuleOpWrapper(lookup, $);\n+            case ExtendedOp.JavaForOp $ -> (OW) new ForOpWrapper(lookup, $);\n+            case ExtendedOp.JavaWhileOp $ -> (OW) new WhileOpWrapper(lookup, $);\n+            case ExtendedOp.JavaIfOp $ -> (OW) new IfOpWrapper(lookup, $);\n+            case CoreOp.NotOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper(lookup, $);\n+            case CoreOp.NegOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper(lookup, $);\n+            case CoreOp.BinaryOp $ -> (OW) new BinaryArithmeticOrLogicOperation(lookup, $);\n+            case CoreOp.BinaryTestOp $ -> (OW) new BinaryTestOpWrapper(lookup, $);\n+            case CoreOp.FuncOp $ -> (OW) new FuncOpWrapper(lookup, $);\n+            case CoreOp.VarOp $ -> (OW) new VarDeclarationOpWrapper(lookup, $);\n+            case CoreOp.YieldOp $ -> (OW) new YieldOpWrapper(lookup, $);\n+            case CoreOp.FuncCallOp $ -> (OW) new FuncCallOpWrapper(lookup, $);\n+            case CoreOp.ConvOp $ -> (OW) new ConvOpWrapper(lookup, $);\n+            case CoreOp.ConstantOp $ -> (OW) new ConstantOpWrapper(lookup, $);\n+            case CoreOp.ReturnOp $ -> (OW) new ReturnOpWrapper(lookup, $);\n+            case CoreOp.VarAccessOp.VarStoreOp $ -> (OW) new VarStoreOpWrapper(lookup, $);\n+            case CoreOp.VarAccessOp.VarLoadOp $ -> (OW) new VarLoadOpWrapper(lookup, $);\n+            case CoreOp.FieldAccessOp.FieldStoreOp $ -> (OW) new FieldStoreOpWrapper(lookup, $);\n+            case CoreOp.FieldAccessOp.FieldLoadOp $ -> (OW) new FieldLoadOpWrapper(lookup, $);\n+            case CoreOp.InvokeOp $ -> (OW) new InvokeOpWrapper(lookup, $);\n+            case CoreOp.TupleOp $ -> (OW) new TupleOpWrapper(lookup, $);\n+            case CoreOp.LambdaOp $ -> (OW) new LambdaOpWrapper(lookup, $);\n+            case ExtendedOp.JavaConditionalOp $ -> (OW) new LogicalOpWrapper(lookup, $);\n+            case ExtendedOp.JavaConditionalExpressionOp $ -> (OW) new TernaryOpWrapper(lookup, $);\n+            case ExtendedOp.JavaLabeledOp $ -> (OW) new JavaLabeledOpWrapper(lookup, $);\n+            case ExtendedOp.JavaBreakOp $ -> (OW) new JavaBreakOpWrapper(lookup, $);\n+            case ExtendedOp.JavaContinueOp $ -> (OW) new JavaContinueOpWrapper(lookup, $);\n+            default -> (OW) new OpWrapper<>(lookup,op);\n@@ -98,2 +98,1 @@\n-    OpWrapper(T op, MethodHandles.Lookup lookup) {\n-        this.op = op;\n+    OpWrapper( MethodHandles.Lookup lookup,T op) {\n@@ -101,0 +100,2 @@\n+        this.op = op;\n+\n@@ -138,1 +139,1 @@\n-                consumer.accept(wrap(invokeOp, lookup));\n+                consumer.accept(wrap(lookup,invokeOp));\n@@ -146,1 +147,1 @@\n-                consumer.accept(wrap(varOp, lookup));\n+                consumer.accept(wrap(lookup,varOp));\n@@ -214,1 +215,1 @@\n-        return block.ops().stream().map(o->wrap(o,lookup));\n+        return block.ops().stream().map(o->wrap(lookup,o));\n@@ -223,1 +224,1 @@\n-        return block.ops().stream().filter(rootSet::contains).map(o->wrap(o, lookup));\n+        return block.ops().stream().filter(rootSet::contains).map(o->wrap(lookup,o));\n@@ -253,3 +254,5 @@\n-\n-    public static boolean isIface(MethodHandles.Lookup lookup,JavaType javaType) {\n-        return  (isAssignable(lookup,javaType, MappableIface.class));\n+    public  static boolean isIfaceUsingLookup(MethodHandles.Lookup lookup,JavaType javaType) {\n+        return  (isAssignableUsingLookup(lookup,javaType, MappableIface.class));\n+    }\n+    public  boolean isIface(JavaType javaType) {\n+        return  (isAssignable(javaType, MappableIface.class));\n@@ -257,3 +260,0 @@\n-    \/\/public static Type classTypeToType(ClassType classType){\n-\n-      \/\/  return classTypeToType(classType,MethodHandles.lookup());\n@@ -261,2 +261,1 @@\n-    \/\/}\n-    public static Type classTypeToType(MethodHandles.Lookup lookup,ClassType classType) {\n+    public  static Type classTypeToTypeUsingLookup(MethodHandles.Lookup lookup,ClassType classType) {\n@@ -272,1 +271,4 @@\n-    public static boolean isAssignable(MethodHandles.Lookup lookup,JavaType javaType, Class<?> ... classes) {\n+    public  Type classTypeToType(ClassType classType) {\n+       return classTypeToTypeUsingLookup(lookup,classType);\n+    }\n+    public  static boolean isAssignableUsingLookup(MethodHandles.Lookup lookup,JavaType javaType, Class<?> ... classes) {\n@@ -274,1 +276,1 @@\n-            Type type = classTypeToType(lookup,classType);\n+            Type type = classTypeToTypeUsingLookup(lookup,classType);\n@@ -277,1 +279,1 @@\n-                        return true;\n+                    return true;\n@@ -284,0 +286,4 @@\n+    public  boolean isAssignable(JavaType javaType, Class<?> ... classes) {\n+       return isAssignableUsingLookup(lookup,javaType,classes);\n+\n+    }\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":54,"deletions":48,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public ReturnOpWrapper(CoreOp.ReturnOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public ReturnOpWrapper( MethodHandles.Lookup lookup,CoreOp.ReturnOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ReturnOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    StructuralOpWrapper(T op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    StructuralOpWrapper(MethodHandles.Lookup lookup,T op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/StructuralOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    public TernaryOpWrapper(ExtendedOp.JavaConditionalExpressionOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public TernaryOpWrapper( MethodHandles.Lookup lookup,ExtendedOp.JavaConditionalExpressionOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/TernaryOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public TupleOpWrapper(CoreOp.TupleOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public TupleOpWrapper( MethodHandles.Lookup lookup,CoreOp.TupleOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/TupleOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    UnaryArithmeticOrLogicOpWrapper(CoreOp.UnaryOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    UnaryArithmeticOrLogicOpWrapper( MethodHandles.Lookup lookup,CoreOp.UnaryOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/UnaryArithmeticOrLogicOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    UnaryOpWrapper(T op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    UnaryOpWrapper(MethodHandles.Lookup lookup,T op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/UnaryOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    VarAccessOpWrapper(T op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    VarAccessOpWrapper( MethodHandles.Lookup lookup,T op) {\n+        super(lookup, op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarAccessOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public VarDeclarationOpWrapper(CoreOp.VarOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public VarDeclarationOpWrapper( MethodHandles.Lookup lookup,CoreOp.VarOp op) {\n+        super(lookup, op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarDeclarationOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    public VarFuncDeclarationOpWrapper(CoreOp.VarOp op, CoreOp.FuncOp funcOp, Block.Parameter blockParameter, MethodHandles.Lookup lookup) {\n-        super(op, lookup);\n+    public VarFuncDeclarationOpWrapper( MethodHandles.Lookup lookup, CoreOp.VarOp op, CoreOp.FuncOp funcOp, Block.Parameter blockParameter) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarFuncDeclarationOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    VarLoadOpWrapper(CoreOp.VarAccessOp.VarLoadOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    VarLoadOpWrapper( MethodHandles.Lookup lookup,CoreOp.VarAccessOp.VarLoadOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarLoadOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    public VarOpWrapper(CoreOp.VarOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public VarOpWrapper(MethodHandles.Lookup lookup,CoreOp.VarOp op) {\n+        super(lookup, op);\n@@ -46,1 +46,1 @@\n-        return isIface(lookup,javaType());\n+        return isIface(javaType());\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    VarStoreOpWrapper(CoreOp.VarAccessOp.VarStoreOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    VarStoreOpWrapper( MethodHandles.Lookup lookup,CoreOp.VarAccessOp.VarStoreOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarStoreOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    WhileOpWrapper(ExtendedOp.JavaWhileOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    WhileOpWrapper( MethodHandles.Lookup lookup,ExtendedOp.JavaWhileOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/WhileOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public YieldOpWrapper(CoreOp.YieldOp op, MethodHandles.Lookup lookup) {\n-        super(op,lookup);\n+    public YieldOpWrapper(MethodHandles.Lookup lookup,CoreOp.YieldOp op) {\n+        super(lookup,op);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/YieldOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}