{"files":[{"patch":"@@ -134,14 +134,30 @@\n-        OpTk.traverse(here, f, (map, op) -> {\n-            if (op instanceof CoreOp.BranchOp b) {\n-                mapBranch(l, b.branch());\n-            } else if (op instanceof  CoreOp.ConditionalBranchOp cb) {\n-                mapBranch(l, cb.trueBranch()); \/\/ handle true branch\n-                mapBranch(l, cb.falseBranch()); \/\/ handle false branch\n-            } else if (op instanceof JavaOp.InvokeOp iop) { \/\/ (almost) all the buffer accesses happen here\n-                if (OpTk.isAssignable(l, (JavaType) iop.invokeDescriptor().refType(), MappableIface.class)) {\n-                    updateAccessType(getRootValue(iop), getAccessType(iop)); \/\/ update buffer access\n-                    if (OpTk.isAssignable(l, (JavaType) iop.invokeDescriptor().refType(), Buffer.class)\n-                            && iop.result() != null && !(iop.resultType() instanceof PrimitiveType)\n-                            && OpTk.isAssignable(l, (JavaType) iop.resultType(), MappableIface.class)) {\n-                        \/\/ if we access a struct\/union from a buffer, we map the struct\/union to the buffer root\n-                        remappedVals.put(iop.result(), getRootValue(iop));\n+        f.elements().forEach(op -> {\n+            switch (op) {\n+                case CoreOp.BranchOp b -> {\n+                    mapBranch(l, b.branch());\n+                }\n+                case CoreOp.ConditionalBranchOp cb -> {\n+                    mapBranch(l, cb.trueBranch()); \/\/ handle true branch\n+                    mapBranch(l, cb.falseBranch()); \/\/ handle false branch\n+                }\n+                case JavaOp.InvokeOp iop -> { \/\/ (almost) all the buffer accesses happen here\n+                    \/\/ actually now that we have arrayview we'll need to map the corresponding arrays too\n+                    if (OpTk.isAssignable(l, (JavaType) iop.invokeDescriptor().refType(), MappableIface.class)) {\n+                        updateAccessType(getRootValue(iop), getAccessType(iop)); \/\/ update buffer access\n+                        if (OpTk.isAssignable(l, (JavaType) iop.invokeDescriptor().refType(), Buffer.class)\n+                                && iop.result() != null && !(iop.resultType() instanceof PrimitiveType)\n+                                && (OpTk.isAssignable(l, (JavaType) iop.resultType(), MappableIface.class)\n+                                    || iop.resultType() instanceof ArrayType)) {\n+                            \/\/ if we access a struct\/union from a buffer, we map the struct\/union to the buffer root\n+                            remappedVals.put(iop.result(), getRootValue(iop));\n+                        }\n+                    }\n+                }\n+                case CoreOp.VarOp vop -> { \/\/ map the new VarOp to the \"root\" param\n+                    if (OpTk.isAssignable(l, (JavaType) vop.resultType().valueType(), Buffer.class)) {\n+                        remappedVals.put(vop.initOperand(), getRootValue(vop));\n+                    }\n+                }\n+                case JavaOp.FieldAccessOp.FieldLoadOp flop -> {\n+                    if (OpTk.isAssignable(l, (JavaType) flop.fieldDescriptor().refType(), KernelContext.class)) {\n+                        updateAccessType(getRootValue(flop), AccessType.RO); \/\/ handle kc access\n@@ -150,3 +166,2 @@\n-            } else if (op instanceof CoreOp.VarOp vop) { \/\/ map the new VarOp to the \"root\" param\n-                if (OpTk.isAssignable(l, (JavaType) vop.resultType().valueType(), Buffer.class)) {\n-                    remappedVals.put(vop.initOperand(), getRootValue(vop));\n+                case JavaOp.ArrayAccessOp.ArrayLoadOp alop -> {\n+                    updateAccessType(getRootValue(alop), AccessType.RO);\n@@ -154,3 +169,2 @@\n-            } else if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp flop) {\n-                if (OpTk.isAssignable(l, (JavaType) flop.fieldDescriptor().refType(), KernelContext.class)) {\n-                    updateAccessType(getRootValue(flop), AccessType.RO); \/\/ handle kc access\n+                case JavaOp.ArrayAccessOp.ArrayStoreOp asop -> {\n+                    updateAccessType(getRootValue(asop), AccessType.WO);\n@@ -158,0 +172,1 @@\n+                default -> {}\n@@ -159,1 +174,0 @@\n-            return map;\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":35,"deletions":21,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-            arr[kc.x] += arr[kc.x];\n+            arr[kc.x] *= arr[kc.x];\n","filename":"hat\/examples\/arrayview\/src\/main\/java\/arrayview\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}