{"files":[{"patch":"@@ -87,5 +87,0 @@\n-        \/\/ We need these to build\n-        var javacOpts = Jar.JavacOpts.of(vm->vm.add(\"--source=26\",\"--enable-preview\",\"--add-modules=jdk.incubator.code\", \"-g\"));\n-        \/\/ These to run\n-        var javaOpts = Jar.JavaOpts.of(v->v.add(\"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\", \"--add-modules=jdk.incubator.code\"));\n-\n@@ -93,3 +88,16 @@\n-                Path.of(System.getProperty(\"user.dir\")),\n-                javacOpts, \/\/ These opts are applied to all javac compilations in the project\n-                Reporter.progressAndErrors);\n+                Util.currentDirAsPath(),\n+                \/\/ These opts will be applied to all javac, cmake and jextract tools\n+                Jar.JavacConfig.of(o->o.progress(true)\n+                        .debug().enablePreview().source(26).addModules(\"jdk.incubator.code\")\n+                ),\n+                CMake.Config.of(o->o.progress(true)),\n+                JExtract.Config.of(o->o.progress(true))\n+        );\n+\n+        var commonJavaOpts = Jar.JavaConfig.of(o -> o\n+                .verbose(true)\n+                .command(true)\n+                .enablePreview()\n+                .addModules(\"jdk.incubator.code\")\n+                .enableNativeAccess(\"ALL-UNNAMED\"));\n+\n@@ -118,0 +126,2 @@\n+        var jextractOpts= JExtract.Config.of(o-> o.command(true));\n+        var cmakeOpts = CMake.Config.of(o->o.command(true));\n@@ -170,6 +180,0 @@\n-        class Stats {\n-            int passed = 0;\n-            int failed = 0;\n-            int unsupported = 0;\n-        }\n-        var testEngine = \"hat.test.engine.HATTestEngine\";\n@@ -177,0 +181,2 @@\n+        var testEnginePackage = \"hat.test.engine\";\n+        var testEngineClassName = \"HATTestEngine\";\n@@ -181,1 +187,1 @@\n-                case \"clean\" -> hat.clean();\n+                case \"clean\" -> hat.clean(true);\n@@ -183,3 +189,1 @@\n-                    var dag = hat.all();\n-                    var available = dag.available();\n-                    Files.writeString(Path.of(\"bld.dot\") , available.toDot());\n+                    Files.writeString(Path.of(\"bld.dot\") , hat.all().available().toDot());\n@@ -189,3 +193,1 @@\n-                    var dag = hat.all();\n-                    var available = dag.available();\n-                    hat.build(available);\n+                    hat.build(hat.all().available());\n@@ -220,6 +222,0 @@\n-                        \/\/ We transfer all command line opts starting with - across as opts to java\n-                        while (args.getFirst() instanceof String  possibleVmOpt &&  possibleVmOpt.startsWith(\"-\")){\n-                            javaOpts.opts().add(args.removeFirst());\n-                        }\n-                        \/\/ Next should be the runnable name\n-                        var runnableName = args.removeFirst();\n@@ -227,9 +223,6 @@\n-                            if (hat.get(runnableName) instanceof Jar runnable) {\n-                                \/\/ we conditionally add this if we need OpenGL on MAC\n-                                if (runnableName.equals(\"nbody\") && mac.isAvailable()){\n-                                     javaOpts.opts().add(\"-XstartOnFirstThread\");\n-                                }\n-                                \/\/ move the rest of command line args to the args of the vm\n-                                javaOpts.args().addAll(args);args.clear();\n-\n-                                runnable.run(runnableName + \".Main\", new job.Dag(runnable, backend).ordered(), javaOpts);\n+                            var javaOpts = commonJavaOpts.with( o -> o\n+                                    .collectVmOpts(args).mainClass(args.removeFirst(),\"Main\")\n+                                    .startOnFirstThreadIf(o.packageName().equals(\"nbody\") && mac.isAvailable()).collectArgs(args)\n+                            );\n+                            if (hat.get(javaOpts.packageName()) instanceof Jar runnable) {\n+                                runnable.run(javaOpts,runnable, backend);\n@@ -237,1 +230,1 @@\n-                                System.err.println(\"Found backend \"+ backendName  +\" but failed to find runnable\/example \" + runnableName);\n+                                System.err.println(\"Found backend \"+ backendName  +\" but failed to find runnable\/example \" + javaOpts.packageName());\n@@ -247,1 +240,1 @@\n-                    if (args.size() > 0) {\n+                    if (!args.isEmpty()) {\n@@ -250,4 +243,5 @@\n-                            \/\/ We transfer all command line opts starting with - across as opts to java\n-                            while (!args.isEmpty() && args.getFirst() instanceof String  possibleVmOpt &&  possibleVmOpt.startsWith(\"-\")){\n-                                javaOpts.opts().add(args.removeFirst());\n-                            }\n+                            System.out.println(\"\"\"\n+                            *****************************************************************\n+                            HAT Test Report\n+                            *****************************************************************\n+                            \"\"\");\n@@ -256,18 +250,8 @@\n-                           var suiteRe = Pattern.compile(\"(hat\/test\/Test[a-zA-Z0-9]*).class\");\n-                           var jarFile = new JarFile(tests.jarFile().toString());\n-                           var entries = jarFile.entries();\n-                           var orderedDag  = new job.Dag(tests, backend).ordered();\n-                           while (entries.hasMoreElements()) {\n-                              if (suiteRe.matcher(entries.nextElement().getName()) instanceof Matcher matched && matched.matches()){\n-                                  javaOpts.args().clear();\n-                                  javaOpts.args().addAll(args);\/\/ so we have all the trailing args to pass to all tests\n-                                  javaOpts.args().add(matched.group(1).replace('\/','.'));\n-                                  tests.run(testEngine, orderedDag, javaOpts);\n-                              }\n-                           }\n-                            args.clear();\n-                           System.out.println(\"\\n\\n\");\n-                           System.out.println(\"*****************************************************************\");\n-                           logo();\n-                           System.out.println(\"                     HAT Test Report \");\n-                           System.out.println(\"*****************************************************************\");\n+                             var commonTestSuiteJavaOpts = commonJavaOpts.with( o -> o\n+                                     .command(false).collectVmOpts(args).mainClass(testEnginePackage,testEngineClassName) \/\/  note no app args as add them below\n+                            );\n+\n+                            tests.forEachMatchingEntry(\"(hat\/test\/Test[a-zA-Z0-9]*).class\", (_,matcher)->\n+                                    tests.run(Jar.JavaConfig.of(commonTestSuiteJavaOpts, o-> o.arg(matcher.group(1).replace('\/','.'))),  tests, backend)\n+                            );\n+                           args.clear();\n@@ -275,0 +259,9 @@\n+                            class Stats {\n+                                int passed = 0;\n+                                int failed = 0;\n+                                int unsupported = 0;\n+                                @Override public String toString(){\n+                                    return String.format(\"Global passed: %d, failed: %d, unsupported: %d, pass-rate: %.2f%%\\\\n\",\n+                                            passed, failed, unsupported, ((float)(passed * 100 \/ (passed + failed + unsupported))));\n+                                }\n+                            }\n@@ -277,1 +270,3 @@\n-                              System.out.println(line);\n+                               if (!commonTestSuiteJavaOpts.verbose()) { \/\/We already dumped this info to stdout above\n+                                   System.out.println(line);\n+                               }\n@@ -283,4 +278,3 @@\n-                          });\n-                          System.out.printf(\"Global passed: %d, failed: %d, unsupported: %d, pass-rate: %.2f%%\\\\n\",\n-                                stats.passed, stats.failed, stats.unsupported, ((float)(stats.passed * 100 \/ (stats.passed + stats.failed + stats.unsupported))));\n-                        } else {\n+                            });\n+                            System.out.println(stats);\n+                            } else {\n@@ -293,1 +287,1 @@\n-                case \"test\" -> {\n+                case \"test\"-> {\n@@ -296,1 +290,0 @@\n-\n@@ -298,12 +291,4 @@\n-                                 \/\/ We transfer all command line opts starting with - across as opts to java\n-                            while (!args.isEmpty() && args.getFirst() instanceof String  possibleVmOpt &&  possibleVmOpt.startsWith(\"-\")){\n-                                javaOpts.opts().add(args.removeFirst());\n-                            }\n-                            \/\/ This should be the class name\n-                            var classAndMethod = args.removeFirst();\n-                            javaOpts.args().add(classAndMethod);\n-                            \/\/ move the rest of command line args to the args of the vm\n-                            javaOpts.args().addAll(args);args.clear();\n-                            var orderedDag  = new job.Dag(tests, backend).ordered();\n-                            tests.run(testEngine, orderedDag, javaOpts);\n-\n+                            var javaOpts = commonJavaOpts.with( o -> o\n+                                    .verbose(true).command(true).collectVmOpts(args).mainClass(testEnginePackage,testEngineClassName).collectArgs(args)\n+                            );\n+                            tests.run(javaOpts,tests,backend);\n@@ -314,4 +299,6 @@\n-                        System.err.println(\"For test we require a backend and a TestClass.\");\n-                        System.err.println(\"Examples: \");\n-                        System.err.println(\"$ test ffi-opencl hat.test.TestMatMul\");\n-                        System.err.println(\"$ test ffi-opencl hat.test.TestMatMul#method\");\n+                        System.err.println(\"\"\"\n+                           For test we require a backend and a TestClass.\");\n+                           Examples:\n+                               $ test ffi-opencl hat.test.TestMatMul\n+                               $ test ffi-opencl hat.test.TestMatMul#method\n+                           \"\"\");\n@@ -324,6 +311,0 @@\n-                        var runnableName = \"experiments\";\n-                        var vmOpts = new ArrayList<String>(List.of());\n-                        while (args.getFirst() instanceof String  possibleVmOpt &&  possibleVmOpt.startsWith(\"-\")){\n-                            vmOpts.add(args.removeFirst());\n-                        }\n-                        var className = args.removeFirst();\n@@ -331,2 +312,5 @@\n-                            if (hat.get(runnableName) instanceof Jar runnable) {\n-                                runnable.run(runnableName + \".\"+className, new job.Dag(runnable, backend).ordered(), vmOpts,args);\n+                            var javaOpts = Jar.JavaConfig.of(commonJavaOpts, o -> o\n+                                    .collectVmOpts(args).mainClass(\"experiments\", args.removeFirst()).collectArgs(args)\n+                            );\n+                            if (hat.get(javaOpts.packageName()) instanceof Jar runnable) {\n+                                runnable.run(javaOpts,runnable, backend);\n@@ -334,1 +318,1 @@\n-                                System.err.println(\"Failed to find runnable \" + runnableName);\n+                                System.err.println(\"Failed to find runnable \" + javaOpts.mainClassName());\n","filename":"hat\/hat.java","additions":76,"deletions":92,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+-cp hat\/job.jar --enable-preview --source 26 hat.java dot\n","filename":"hat\/hat\/dot","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"filename":"hat\/hat\/job.jar","binary":true,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.ArrayList;\n@@ -34,0 +35,1 @@\n+\n@@ -35,5 +37,14 @@\n-        ForkExec.Opts opts = ForkExec.Opts.of(\"cmake\");\n-        tailopts.forEach(opts::add);\n-        id.project().reporter.command(this, opts.toString());\n-        id.project().reporter.progress(this, opts.toString());\n-        var result =  ForkExec.forkExec(this, id.project().rootPath(), opts);\n+        StringList stringList = StringList.of()\n+                .add(\"cmake\")\n+                .add(tailopts);\n+\n+        if (id().project().cmakeOpts().command()) {\n+            System.out.println(stringList);\n+        }\n+        if (id().project().cmakeOpts().progress()) {\n+            System.out.println(\"cmake \"+id().fullHyphenatedName());\n+        }\n+        if (id().project().cmakeOpts().verbose()) {\n+            System.out.println(stringList);\n+        }\n+        var result =  ForkExec.forkExec(this, false, id.project().rootPath(), stringList);\n@@ -42,1 +53,3 @@\n-            id().project().reporter.info(this, line);\n+            if (id().project().cmakeOpts().verbose()) {\n+               System.out.println( line);\n+            }\n@@ -46,1 +59,1 @@\n-            id().project().reporter.error(this, opts.toString());\n+            System.err.println( stringList);\n@@ -52,5 +65,0 @@\n-    @Override\n-    public List<Path> generatedPaths() {\n-        throw new IllegalStateException(\"who called me\");\n-    }\n-\n@@ -80,4 +88,2 @@\n-        cmakeInit(_ -> {\n-        });\n-        cmakeBuild(_ -> {\n-        });\n+        cmakeInit(_ -> {});\n+        cmakeBuild(_ -> {});\n@@ -88,5 +94,3 @@\n-    public boolean clean() {\n-        cmakeInit(_ -> {\n-        });\n-        cmakeClean(_ -> {\n-        });\n+    public boolean clean(boolean verbose) {\n+        cmakeInit(_ -> {});\n+        cmakeClean(_ -> {});\n@@ -131,0 +135,97 @@\n+    public  interface Config extends CommonConfig<Config>{\n+        boolean command();\n+\n+        boolean verbose();\n+        boolean progress();\n+\n+        boolean warnings();\n+        List<String> vmOpts();\n+\n+        record ConfigImpl(boolean command, boolean warnings, boolean progress, boolean verbose, List<String> vmOpts) implements Config {\n+        }\n+\n+        static Config of(boolean command, boolean warnings, boolean progress, boolean verbose, List<String> vmOpts) {\n+            return new ConfigImpl(command, warnings,progress,verbose, vmOpts);\n+        }\n+\n+        interface Builder extends Config {\n+            Builder command(boolean f);\n+            Builder warnings(boolean f);\n+            Builder progress(boolean f);\n+            Builder verbose(boolean f);\n+\n+            Builder vmOpt(String... s);\n+\n+\n+            class Impl implements Builder {\n+                boolean command;\n+                boolean warnings;\n+                boolean progress;\n+                boolean verbose;\n+                List<String> vmOpts = new ArrayList<>();\n+\n+                @Override\n+                public Builder command(boolean f) {\n+                    command = f;\n+                    return this;\n+                }\n+                @Override\n+                public Builder warnings(boolean f) {\n+                    warnings= f;\n+                    return this;\n+                }\n+                @Override\n+                public Builder progress(boolean f) {\n+                    progress= f;\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder verbose(boolean f) {\n+                    verbose = f;\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder vmOpt(String... opts) {\n+                    List.of(opts).forEach(s -> vmOpts.add(s));\n+                    return this;\n+                }\n+\n+\n+                @Override\n+                public boolean command() {\n+                    return command;\n+                }\n+\n+                @Override\n+                public boolean verbose() {\n+                    return verbose;\n+                }\n+                @Override\n+                public boolean warnings() {\n+                    return warnings;\n+                }\n+                @Override\n+                public boolean progress() {\n+                    return progress;\n+                }\n+\n+                @Override\n+                public List<String> vmOpts() {\n+                    return new ArrayList<>();\n+                }\n+            }\n+        }\n+\n+\n+        static Config of(Consumer<Builder> javacOptBuilderConsumer) {\n+            Builder builder = new Builder.Impl();\n+            javacOptBuilderConsumer.accept(builder);\n+            return of(builder.command(), builder.warnings(), builder.progress(), builder.verbose(), builder.vmOpts());\n+        }\n+\n+        static Config of() {\n+            return of(false, false, false,false,new ArrayList<>());\n+        }\n+    }\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/CMake.java","additions":122,"deletions":21,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-    CMakeInfo(Project.Id id, String find, String response, Set<String> varsIn, Set<Dependency> buildDependencies) {\n+    CMakeInfo(Project.Id id,  String find, String response, Set<String> varsIn, Set<Dependency> buildDependencies) {\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/CMakeInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+public interface CommonConfig<T extends CommonConfig<T>> {\n+    boolean command();\n+\n+    boolean warnings();\n+\n+    boolean verbose();\n+\n+    boolean progress();\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/CommonConfig.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -45,1 +45,1 @@\n-        this(id, Set.of(dependencies));\n+        this(id,Set.of(dependencies));\n@@ -49,1 +49,1 @@\n-    public void jExtractOpts(ForkExec.Opts opts) {\n+    public void jExtractOpts(StringList stringList) {\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Cuda.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+        public static Set<Dependency> ordered(Dependency ... deps){\n+              return new Dag(deps).ordered();\n+        }\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Dag.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.nio.file.Path;\n-import java.util.List;\n@@ -41,4 +39,1 @@\n-\n-        boolean clean();\n-\n-        List<Path> generatedPaths();\n+        boolean clean(boolean verbose);\n@@ -51,1 +46,1 @@\n-        boolean run(String mainClassName, Set<Dependency> depsInOrder, List<String> vmOpts, List<String> args);\n+        boolean run(Jar.JavaConfig javaOpts, Dependency ...unorderedDeps);\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Dependency.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-            Opts opts,\n+            StringList stringList,\n@@ -42,1 +42,1 @@\n-    static Result forkExec(Dependency dependency, Path path, Opts opts) {\n+    static Result forkExec(Dependency dependency,boolean show, Path path, StringList stringList) {\n@@ -47,1 +47,1 @@\n-                    .command(opts.opts)\n+                    .command(stringList.list())\n@@ -51,1 +51,3 @@\n-                System.out.println(line);\n+                if (show) {\n+                    System.out.println(line);\n+                }\n@@ -55,1 +57,1 @@\n-            return new Result(dependency, path, opts, process.exitValue(), stdErrAndOut);\n+            return new Result(dependency, path, stringList, process.exitValue(), stdErrAndOut);\n@@ -63,25 +65,0 @@\n-    public static class Opts {\n-        List<String> opts = new ArrayList<>();\n-        private Opts(){\n-\n-        }\n-        Opts add(String ...opts){\n-            return add(List.of(opts));\n-        }\n-        Opts add(List<String>opts){\n-            this.opts.addAll(opts);\n-            return this;\n-        }\n-\n-        public static Opts of(String executable) {\n-            Opts opts = new Opts();\n-            opts.add(executable);\n-            return opts;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.join(\" \", opts);\n-        }\n-\n-    }\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/ForkExec.java","additions":7,"deletions":30,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -29,0 +31,1 @@\n+import java.util.function.Consumer;\n@@ -32,3 +35,5 @@\n-\n-    private JExtract(Project.Id id, JavacOpts javacOpts, Set<Path> exclude, Set<Dependency> dependencies) {\n-        super(id,javacOpts, exclude, dependencies);\n+    public void check(){\n+       \/\/ We dont care if the src does not exist unlike a clean jar\n+    }\n+    private JExtract(Project.Id id,  Set<Path> exclude, Set<Dependency> dependencies) {\n+        super(id, exclude, dependencies);\n@@ -50,1 +55,2 @@\n-            var opts = ForkExec.Opts.of(\"jextract\").add(\n+            var opts = StringList.of().add(\n+                    \"jextract\",\n@@ -56,7 +62,10 @@\n-            id().project().reporter.command(this, opts.toString());\n-            System.out.println(String.join(\" \", opts.toString()));\n-            id().project().reporter.progress(this, \"extracting\");\n-            var result= ForkExec.forkExec(this, id.project().rootPath(),opts);\n-            result.stdErrAndOut().forEach((line)->{\n-                id().project().reporter.warning(this, line);\n-            });\n+            if (id.project().jextractOpts().command()) {\n+                System.out.println(opts.toString());\n+            }\n+            if (id.project().jextractOpts().progress()) {\n+                System.out.println(\"extracting \"+id().fullHyphenatedName());\n+            }\n+            var result = ForkExec.forkExec(this, false, id.project().rootPath(), opts);\n+            if (id.project().jextractOpts().verbose()){\n+                result.stdErrAndOut().forEach(System.out::println);\n+             }\n@@ -71,1 +80,1 @@\n-    public boolean clean() {\n+    public boolean clean(boolean verbose) {\n@@ -74,8 +83,2 @@\n-    static public JExtract extract(Project.Id id, JavacOpts javacOpts, Set<Dependency> dependencies) {\n-        return new JExtract(id, javacOpts,Set.of(), dependencies);\n-    }\n-    static public JExtract extract(Project.Id id, Set<Dependency> dependencies) {\n-        return new JExtract(id, JavacOpts.of(),Set.of(), dependencies);\n-    }\n-    static public JExtract extract(Project.Id id,JavacOpts javacOpts, Dependency... dependencies) {\n-        return new JExtract(id, javacOpts,Set.of(), Set.of(dependencies));\n+    static public JExtract extract(Project.Id id,  Set<Dependency> dependencies) {\n+        return new JExtract(id,Set.of(), dependencies);\n@@ -83,2 +86,85 @@\n-    static public JExtract extract(Project.Id id, Dependency... dependencies) {\n-        return new JExtract(id, JavacOpts.of(),Set.of(), Set.of(dependencies));\n+\n+    public  interface Config extends CommonConfig<Config>{\n+        boolean command();\n+        boolean warnings();\n+        boolean progress();\n+        boolean verbose();\n+\n+\n+\n+        record ConfigImpl(boolean command ,boolean warnings, boolean progress,  boolean verbose) implements Config {\n+        }\n+\n+        static Config of(boolean command, boolean warnings, boolean progress,boolean verbose) {\n+            return new ConfigImpl(command, warnings,progress,verbose);\n+        }\n+\n+        interface Builder extends Config {\n+            Builder command(boolean f);\n+\n+            Builder warnings(boolean f);\n+            Builder progress(boolean f);\n+\n+            Builder verbose(boolean f);\n+\n+\n+\n+            class Impl implements Builder {\n+                boolean command;\n+                boolean warnings;\n+                boolean progress;\n+                boolean verbose;\n+\n+\n+                @Override\n+                public Builder command(boolean f) {\n+                    command = f;\n+                    return this;\n+                }\n+                @Override\n+                public Builder warnings(boolean f) {\n+                    warnings = f;\n+                    return this;\n+                }\n+                @Override\n+                public Builder progress(boolean f) {\n+                    progress = f;\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder verbose(boolean f) {\n+                    verbose = f;\n+                    return this;\n+                }\n+                @Override\n+                public boolean command() {\n+                    return command;\n+                }\n+                @Override\n+                public boolean warnings() {\n+                    return warnings;\n+                }\n+                @Override\n+                public boolean progress() {\n+                    return progress;\n+                }\n+\n+                @Override\n+                public boolean verbose() {\n+                    return verbose;\n+                }\n+\n+            }\n+        }\n+\n+\n+        static Config of(Consumer<Builder> javacOptBuilderConsumer) {\n+            Builder builder = new Builder.Impl();\n+            javacOptBuilderConsumer.accept(builder);\n+            return of(builder.command(), builder.warnings(),builder.progress(),builder.verbose());\n+        }\n+\n+        static Config of() {\n+            return of(false, false, false, false);\n+        }\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/JExtract.java","additions":108,"deletions":22,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-    void jExtractOpts(ForkExec.Opts opts);\n+    void jExtractOpts(StringList stringList);\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/JExtractOptProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.function.BiConsumer;\n@@ -45,0 +46,2 @@\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n@@ -49,0 +52,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -53,56 +58,0 @@\n-    final JavacOpts javacOpts;\n-    public interface StringListBuilder {\n-        List<String> strings();\n-        StringListBuilder add(String ...s);\n-        StringListBuilder add(List<String> list);\n-        StringListBuilder addIf(boolean c, String ...s);\n-        StringListBuilder addIf(boolean c, List<String> list);\n-        static StringListBuilder of(){\n-            record StringListBuilderImpl (List<String> strings) implements StringListBuilder{\n-                @Override\n-                public StringListBuilder add(String ...s) {\n-                    return add(List.of(s));\n-                }\n-                @Override\n-                public StringListBuilder add(List<String> list) {\n-                    strings.addAll(list);\n-                    return this;\n-                }\n-                @Override\n-                public StringListBuilder addIf(boolean c, List<String> list) {\n-                    if (c){\n-                        strings.addAll(list);\n-                    }\n-                    return this;\n-                }\n-                @Override\n-                public StringListBuilder addIf(boolean c, String ...s) {\n-                   return addIf(c, List.of(s));\n-                }\n-            }\n-            return new StringListBuilderImpl(new ArrayList<>());\n-        }\n-    }\n-    public interface JavacOpts{\n-        List<String> vmOpts();\n-        List<String> opts();\n-\n-        static JavacOpts of(List<String> vmOpts, List<String> opts){\n-            record JavacOptsImpl(List<String> vmOpts, List<String> opts) implements JavacOpts{\n-            }\n-            return new JavacOptsImpl(vmOpts,opts);\n-        }\n-        static JavacOpts of(Consumer<StringListBuilder> v){\n-            StringListBuilder vmOptBuilder = StringListBuilder.of();\n-            StringListBuilder optBuilder = StringListBuilder.of();\n-            v.accept(vmOptBuilder);\n-            return of(vmOptBuilder.strings(),optBuilder.strings());\n-        }\n-\n-        static JavacOpts of(Consumer<StringListBuilder> v, Consumer<StringListBuilder> o){\n-            StringListBuilder vmOptBuilder = StringListBuilder.of();\n-            StringListBuilder optBuilder = StringListBuilder.of();\n-            v.accept(vmOptBuilder);\n-            o.accept(optBuilder);\n-            return of(vmOptBuilder.strings(),optBuilder.strings());\n-        }\n@@ -110,38 +59,1 @@\n-        static JavacOpts of(){\n-            return of(new ArrayList<>(),new ArrayList<>());\n-        }\n-    }\n-\n-    public interface JavaOpts{\n-        List<String> opts();\n-        List<String> args();\n-\n-        static JavaOpts of(List<String> opts, List<String> args){\n-            record JavaOptsImpl(List<String>opts, List<String> args) implements JavaOpts{\n-            }\n-            return new JavaOptsImpl(opts,args);\n-        }\n-        static JavaOpts of(Consumer<StringListBuilder> v){\n-            StringListBuilder vmOptBuilder = StringListBuilder.of();\n-            StringListBuilder optBuilder = StringListBuilder.of();\n-            v.accept(vmOptBuilder);\n-            return of(vmOptBuilder.strings(),optBuilder.strings());\n-        }\n-\n-        static JavaOpts of(Consumer<StringListBuilder> v, Consumer<StringListBuilder> o){\n-            StringListBuilder vmOptBuilder = StringListBuilder.of();\n-            StringListBuilder optBuilder = StringListBuilder.of();\n-            v.accept(vmOptBuilder);\n-            o.accept(optBuilder);\n-            return of(vmOptBuilder.strings(),optBuilder.strings());\n-        }\n-\n-        static JavaOpts of(){\n-            return of(new ArrayList<>(),new ArrayList<>());\n-        }\n-    }\n-\n-    protected Jar(Project.Id id, JavacOpts javacOpts,Set<Path> exclude, Set<Dependency> dependencies) {\n-        super(id, dependencies);\n-        this.javacOpts = javacOpts;\n-        this.exclude = exclude;\n+    public void check(){\n@@ -155,4 +67,0 @@\n-        id.project().add(this);\n-    }\n-    public static Jar of(Project.Id id, JavacOpts javacOpts, Set<Path> exclude, Set<Dependency> dependencies) {\n-        return new Jar(id, javacOpts,exclude, dependencies);\n@@ -161,2 +69,5 @@\n-    public static Jar of(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n-        return new Jar(id, JavacOpts.of(), exclude, dependencies);\n+    protected Jar(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n+        super(id, dependencies);\n+        this.exclude = exclude;\n+        check(); \/\/ some targets might skip this\n+        id.project().add(this);\n@@ -164,2 +75,2 @@\n-    public static Jar of(Project.Id id, JavacOpts javacOpts, Set<Dependency> dependencies) {\n-        return new Jar(id, javacOpts,Set.of(), dependencies);\n+    public static Jar of(Project.Id id,  Set<Path> exclude, Set<Dependency> dependencies) {\n+        return new Jar(id, exclude, dependencies);\n@@ -170,1 +81,1 @@\n-        return new Jar(id,JavacOpts.of(), Set.of(), dependencies);\n+        return new Jar(id, Set.of(), dependencies);\n@@ -181,1 +92,16 @@\n-    public static class JavaSource extends SimpleJavaFileObject {\n+    public void forEachEntry(Predicate<JarEntry> jarEntryPredicate,Consumer<JarEntry> jarEntryConsumer) {\n+       Util.forEachEntry(jarFile(),jarEntryPredicate,jarEntryConsumer);\n+    }\n+    public void forEachMatchingEntry(String re, BiConsumer<JarEntry, Matcher> matchingJarEntryConsumer){\n+        var pattern = Pattern.compile(re);\n+        forEachEntry(jarEntry->{\n+            if (pattern.matcher(jarEntry.getName()) instanceof Matcher matched && matched.matches()){\n+                matchingJarEntryConsumer.accept(jarEntry,matched);\n+            }\n+        });\n+    }\n+    public void forEachEntry(Consumer<JarEntry> jarEntryConsumer) {\n+        Util.forEachEntry(jarFile(),jarEntryConsumer);\n+    }\n+\n+    private static class JavaSource extends SimpleJavaFileObject {\n@@ -204,8 +130,2 @@\n-    public List<Path> generatedPaths() {\n-        throw new IllegalStateException(\"who called me\");\n-    }\n-\n-\n-    @Override\n-    public boolean clean() {\n-        id().project().clean(null, classesDir(), jarFile());\n+    public boolean clean(boolean verbose) {\n+        id().project().clean(verbose,null, classesDir(), jarFile());\n@@ -217,7 +137,0 @@\n-        List<String> opts = new ArrayList<>();\n-        opts.addAll(id().project().javacOpts().vmOpts());\n-        opts.addAll(javacOpts.vmOpts());\n-        opts.addAll(List.of(\n-                \"-d\", classesDirName()\n-                )\n-        );\n@@ -226,0 +139,5 @@\n+        StringList javacCombinedOps = StringList.of()\n+                .add(id().project().javacOpts().vmOpts())\n+                .add(\"-d\", classesDirName())\n+                .addIf(!deps.isEmpty(), \"--class-path=\"+deps)\n+                .add(\"--source-path=\" + javaSourcePathName());\n@@ -227,7 +145,0 @@\n-        if (!deps.isEmpty()) {\n-            opts.add(\"--class-path=\" + deps);\n-        }\n-        opts.addAll(id.project().javacOpts().opts());\n-        opts.addAll(javacOpts.opts());\n-        opts.add(\"--source-path=\" + javaSourcePathName());\n-        \/\/System.out.println(\"javac opts \"+ String.join(\" \", opts));\n@@ -236,1 +147,1 @@\n-        id().project().clean(this, classesDir());\n+        id().project().clean(id().project().javacOpts().verbose(), this, classesDir());\n@@ -241,5 +152,8 @@\n-                id().project().reporter.command(this, \"javac \" +\n-                        String.join(\" \", opts) + \" \" + String.join(\" \",\n-                        listOfSources.stream().map(JavaSource::getName).collect(Collectors.toList())));\n-\n-\n+                if (id().project().javacOpts().command()){\n+                    var commandLine = \"javac \" +\n+                            javacCombinedOps + \" \" + String.join(\" \", listOfSources.stream().map(JavaSource::getName).collect(Collectors.toList()));\n+                    System.out.println(commandLine);\n+                }\n+               \/\/ if (id().project().javacOpts().progress()){\n+                 \/\/   System.out.println(\"javac \"+id.fullHyphenatedName());\n+               \/\/ }\n@@ -250,1 +164,1 @@\n-                            id().project().reporter.error(Jar.this, diagnostic.toString());\n+                            System.err.println(diagnostic.getKind() + \":\"+ diagnostic);\n@@ -252,1 +166,1 @@\n-                            id().project().reporter.warning(Jar.this, diagnostic.toString());\n+                            System.out.println(diagnostic.getKind() + \":\"+ diagnostic);\n@@ -254,1 +168,1 @@\n-                            id().project().reporter.warning(Jar.this, \"!!\" + diagnostic.toString());\n+                            System.out.println(diagnostic.getKind() + \":\"+ diagnostic);\n@@ -256,1 +170,3 @@\n-                            id().project().reporter.note(Jar.this, diagnostic.toString());\n+                            if (id().project().javacOpts().verbose()) {\n+                                System.out.println(diagnostic.getKind() + \":\"+ diagnostic);\n+                            }\n@@ -258,1 +174,2 @@\n-                            id().project().reporter.warning(Jar.this, diagnostic.getKind() + \":\" + diagnostic.toString());\n+                            System.out.println(diagnostic.getKind() + \":\"+ diagnostic);\n+                          \/\/  id().project().reporter.warning(Jar.this, diagnostic.getKind() + \":\" + diagnostic.toString());\n@@ -266,1 +183,1 @@\n-                        opts,\n+                        javacCombinedOps.list(),\n@@ -269,2 +186,5 @@\n-                )).generate().forEach(gc ->\n-                        id.project().reporter.note(this, gc.getName())\n+                )).generate().forEach(gc -> {\n+                            if (id().project().javacOpts().verbose()) {\n+                               System.out.println(gc.getName());\n+                            }\n+                        }\n@@ -281,2 +201,0 @@\n-               \/\/ mainAttributes.put(Attributes.Name.MAIN_CLASS,   id().shortHyphenatedName()+\".Main\");\n-               \/\/ mainAttributes.put(Attributes.Name.IMPLEMENTATION_VENDOR, \"HAT's Java Opinionated Builder (JOB)\");\n@@ -286,4 +204,7 @@\n-                id().project().reporter.command(this, \"jar cvf \" + jarFile() + \" \" +\n-                        String.join(dirsToJar.stream().map(Path::toString).collect(Collectors.joining(\" \"))));\n-                id().project().reporter.progress(this, \"compiled \" + listOfSources.size() + \" file\" + (listOfSources.size() > 1 ? \"s\" : \"\") + \" to \" + jarFile().getFileName());\n-\n+                if (id().project().javacOpts().command()) {\n+                    System.out.println( \"jar cvf \" + jarFile() + \" \" +\n+                            String.join(dirsToJar.stream().map(Path::toString).collect(Collectors.joining(\" \"))));\n+                }\n+                if (id().project().javacOpts().progress()) {\n+                    System.out.println(\"compiled \" + listOfSources.size() + \" file\" + (listOfSources.size() > 1 ? \"s\" : \"\") + \" to \" + jarFile().getFileName());\n+                }\n@@ -292,1 +213,0 @@\n-\n@@ -370,0 +290,1 @@\n+\n@@ -371,16 +292,18 @@\n-    public boolean run(String mainClassName, Set<Dependency> depsInOrder, List<String> vmOpts, List<String> args) {\n-        ForkExec.Opts opts = ForkExec.Opts.of(ProcessHandle.current()\n-                .info()\n-                .command()\n-                .orElseThrow()).add(vmOpts);\n-        opts.add(\n-                \"--class-path\", classPathWithThisLast(depsInOrder),\n-                \"-Djava.library.path=\" + id().project().buildPath()\n-        );\n-        vmOpts.forEach(opts::add);\n-        opts.add(mainClassName);\n-        args.forEach(opts::add);\n-        id().project().reporter.command(this, opts.toString());\n-        System.out.println(String.join(\" \", opts.toString()));\n-        id().project().reporter.progress(this, \"running\");\n-        var result = ForkExec.forkExec(this, id().project().rootPath(), opts);\n+    public boolean run(JavaConfig javaConfig, Dependency ...unorderedDeps) {\n+        \/\/ unordered deps just contains the min . we need a full ordered dag\n+        var depsInOrder = Dag.ordered(unorderedDeps);\n+        StringList stringList = StringList.of()\n+                .add(Util.currentProcessPath())\n+                .add(javaConfig.vmOpts())\n+                .add(\n+                   \"--class-path\", classPathWithThisLast(depsInOrder),\n+                   \"-Djava.library.path=\" + id().project().buildPath()\n+                )\n+                .add(javaConfig.vmOpts())\n+                .add(javaConfig.mainClassName());\n+                stringList.add(javaConfig.args());\n+        if (javaConfig.command()) {\n+           \/\/ id().project().reporter.command(this, stringList.toString());\n+            System.out.println(stringList.toString());\n+        }\n+        var result = ForkExec.forkExec(this, javaConfig.verbose(), id().project().rootPath(), stringList);\n@@ -388,1 +311,3 @@\n-            id().project().reporter.warning(this, line);\n+            if (javaConfig.verbose()) {\n+               System.out.println(line);\n+            }\n@@ -395,2 +320,0 @@\n-    public boolean run(String mainClassName, Set<Dependency> depsInOrder, JavaOpts javaOpts) {\n-        return run(mainClassName,depsInOrder,javaOpts.opts(),javaOpts.args());\n@@ -398,0 +321,386 @@\n+    public  interface JavacConfig extends CommonConfig<JavacConfig> {\n+\n+\n+        List<String> vmOpts();\n+\n+        record JavacConfigImpl(boolean command, boolean warnings, boolean progress, boolean verbose, List<String> vmOpts) implements JavacConfig {\n+        }\n+\n+        static JavacConfig of(boolean command,boolean warnings, boolean progress, boolean verbose, List<String> vmOpts) {\n+            return new JavacConfigImpl(command,warnings, progress, verbose, vmOpts);\n+        }\n+\n+\n+\n+\n+        interface Builder extends  JavacConfig {\n+            Builder command(boolean f);\n+            Builder warnings(boolean f);\n+            Builder verbose(boolean f);\n+            Builder progress(boolean f);\n+            Builder vmOpt(String... s);\n+\n+            Builder debug();\n+\n+            Builder enablePreview();\n+\n+            Builder source(int n);\n+\n+            Builder addModules(String moduleName);\n+\n+\n+            class Impl implements Builder {\n+                boolean command;\n+                boolean warnings;\n+                boolean progress;\n+                boolean verbose;\n+                List<String> vmOpts = new ArrayList<>();\n+\n+                @Override\n+                public Builder command(boolean f) {\n+                    command = f;\n+                    return this;\n+                }\n+                @Override\n+                public Builder warnings(boolean f) {\n+                    warnings = f;\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder verbose(boolean f) {\n+                    verbose = f;\n+                    return this;\n+                }\n+                @Override\n+                public Builder progress(boolean f) {\n+                    progress = f;\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder vmOpt(String... opts) {\n+                    List.of(opts).forEach(s -> vmOpts.add(s));\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder debug() {\n+                    return vmOpt(\"-g\");\n+                }\n+\n+                @Override\n+                public Builder enablePreview() {\n+                    return vmOpt(\"--enable-preview\");\n+                }\n+\n+                @Override\n+                public Builder source(int n) {\n+                    return vmOpt(\"--source=\" + n);\n+                }\n+\n+                @Override\n+                public Builder addModules(String moduleName) {\n+                    return vmOpt(\"--add-modules=\" + moduleName);\n+                }\n+\n+                @Override\n+                public boolean command() {\n+                    return command;\n+                }\n+\n+                @Override\n+                public boolean verbose() {\n+                    return verbose;\n+                }\n+                @Override\n+                public boolean progress() {\n+                    return progress;\n+                }\n+                @Override\n+                public boolean warnings() {\n+                    return warnings;\n+                }\n+                @Override\n+                public List<String> vmOpts() {\n+                    return new ArrayList<>();\n+                }\n+            }\n+        }\n+\n+\n+        static JavacConfig of(Consumer<Builder> javacOptBuilderConsumer) {\n+            Builder builder = new Builder.Impl();\n+            javacOptBuilderConsumer.accept(builder);\n+            return of(builder.command(),builder.warnings(),builder.progress(), builder.verbose(), builder.vmOpts());\n+        }\n+\n+        static JavacConfig of() {\n+            return of(false, false,false,false, new ArrayList<>());\n+        }\n+    }\n+\n+    public  interface JavaConfig extends CommonConfig<JavaConfig> {\n+\n+        String packageName();\n+\n+        String mainClassName();\n+\n+        List<String> vmOpts();\n+\n+        List<String> args();\n+\n+\n+        record JavaConfigImpl(boolean command, boolean warnings, boolean progress, boolean verbose, String packageName,\n+                              String mainClassName, List<String> vmOpts, List<String> args) implements JavaConfig {\n+        }\n+\n+        static JavaConfig of(boolean command, boolean warnings, boolean progress, boolean verbose, String packageName, String mainClassName, List<String> vmOpts, List<String> args) {\n+            return new JavaConfigImpl(command, warnings, progress, verbose, packageName, mainClassName, vmOpts, args);\n+        }\n+\n+        interface Builder extends JavaConfig {\n+            Builder command(boolean f);\n+\n+            Builder warnings(boolean f);\n+            Builder progress(boolean f);\n+            Builder verbose(boolean f);\n+\n+            Builder vmOpt(String... s);\n+\n+            Builder arg(String... s);\n+\n+            Builder vmOpts(List<String> vmOpts);\n+\n+            Builder args(List<String> vmOpts);\n+\n+            Builder debug();\n+\n+            Builder enablePreview();\n+\n+            Builder source(int n);\n+\n+            Builder addModules(String moduleName);\n+\n+            Builder enableNativeAccess(String moduleName);\n+\n+            Builder startOnFirstThreadIf();\n+\n+            Builder startOnFirstThreadIf(boolean flag);\n+\n+            Builder mainClassName(String mainClassName);\n+\n+            Builder packageName(String packageName);\n+\n+            Builder mainClass(String packageName, String className);\n+\n+            Builder with(Consumer<Builder> builder);\n+\n+            Builder whilst(Supplier<Boolean> predicate, Consumer<Builder> builder);\n+\n+            Builder collectVmOpts(List<String> args);\n+\n+            Builder collectArgs(List<String> args);\n+\n+            class Impl implements Builder {\n+                boolean command;\n+                boolean warnings;\n+                boolean verbose;\n+                boolean progress;\n+                String packageName;\n+                String mainClassName;\n+                List<String> vmOpts = new ArrayList<>();\n+                List<String> args = new ArrayList<>();\n+\n+                @Override\n+                public Builder command(boolean f) {\n+                    command = f;\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder warnings(boolean f) {\n+                    warnings = f;\n+                    return this;\n+                }\n+                @Override\n+                public Builder progress(boolean f) {\n+                    progress = f;\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder verbose(boolean f) {\n+                    verbose = f;\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder vmOpt(String... vmOpts) {\n+                    this.vmOpts(List.of(vmOpts));\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder vmOpts(List<String> vmOpts) {\n+                    this.vmOpts.addAll(vmOpts);\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder arg(String... args) {\n+                    this.args(List.of(args));\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder args(List<String> args) {\n+                    this.args.addAll(args);\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder debug() {\n+                    return vmOpt(\"-g\");\n+                }\n+\n+                @Override\n+                public Builder enablePreview() {\n+                    return vmOpt(\"--enable-preview\");\n+                }\n+\n+                @Override\n+                public Builder startOnFirstThreadIf() {\n+                    return vmOpt(\"-XstartOnFirstThread\");\n+                }\n+\n+                @Override\n+                public Builder startOnFirstThreadIf(boolean flag) {\n+                    if (flag) {\n+                        startOnFirstThreadIf();\n+                    }\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder source(int n) {\n+                    return vmOpt(\"--source=\" + n);\n+                }\n+\n+                @Override\n+                public Builder addModules(String moduleName) {\n+                    return vmOpt(\"--add-modules=\" + moduleName);\n+                }\n+\n+                @Override\n+                public Builder enableNativeAccess(String moduleName) {\n+                    return vmOpt(\"--enable-native-access=\" + moduleName);\n+                }\n+\n+                @Override\n+                public Builder mainClassName(String mainClassName) {\n+                    this.mainClassName = mainClassName;\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder packageName(String packageName) {\n+                    this.packageName = packageName;\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder mainClass(String packageName, String mainClassName) {\n+                    this.packageName = packageName;\n+                    this.mainClassName = packageName + \".\" + mainClassName;\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder with(Consumer<Builder> nestedBuilder) {\n+                    nestedBuilder.accept(this);\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder whilst(Supplier<Boolean> predicate, Consumer<Builder> nestedBuilder) {\n+                    while (predicate.get()) {\n+                        nestedBuilder.accept(this);\n+                    }\n+                    return this;\n+                }\n+\n+                @Override\n+                public Builder collectVmOpts(List<String> args) {\n+                    return whilst(() -> (!args.isEmpty() && args.getFirst() instanceof String s && s.startsWith(\"-\")), _ -> vmOpt(args.removeFirst()));\n+                }\n+\n+                @Override\n+                public Builder collectArgs(List<String> args) {\n+                    return whilst(() -> !args.isEmpty(), _ -> arg(args.removeFirst()));\n+                }\n+\n+                @Override\n+                public String mainClassName() {\n+                    return mainClassName;\n+                }\n+\n+                @Override\n+                public String packageName() {\n+                    return packageName;\n+                }\n+\n+                @Override\n+                public boolean command() {\n+                    return command;\n+                }\n+\n+                @Override\n+                public boolean warnings() {\n+                    return warnings;\n+                }\n+                @Override\n+                public boolean progress() {\n+                    return progress;\n+                }\n+\n+                @Override\n+                public boolean verbose() {\n+                    return verbose;\n+                }\n+\n+                @Override\n+                public List<String> vmOpts() {\n+                    return vmOpts;\n+                }\n+\n+                @Override\n+                public List<String> args() {\n+                    return args;\n+                }\n+            }\n+        }\n+\n+\n+        static JavaConfig of(Consumer<Builder> javaOptBuilderConsumer) {\n+            Builder builder = new Builder.Impl();\n+            javaOptBuilderConsumer.accept(builder);\n+            return of(builder.command(), builder.warnings(), builder.progress(),builder.verbose(), builder.packageName(), builder.mainClassName(), builder.vmOpts(), builder.args());\n+        }\n+\n+        static JavaConfig of(JavaConfig javaOpts, Consumer<Builder> javaOptBuilderConsumer) {\n+            Builder builder = new Builder.Impl();\n+            builder\n+                    .verbose(javaOpts.verbose())\n+                    .command(javaOpts.command())\n+                    .packageName(javaOpts.packageName())\n+                    .mainClassName(javaOpts.mainClassName())\n+                    .vmOpts(javaOpts.vmOpts())\n+                    .args(javaOpts.args());\n+            javaOptBuilderConsumer.accept(builder);\n+            return of(builder.command(), builder.warnings(), builder.progress(),builder.verbose(), builder.packageName(), builder.mainClassName(), builder.vmOpts(), builder.args());\n+        }\n+\n+        default JavaConfig with(Consumer<Builder> javaOptsBuilderConsumer){\n+            return JavaConfig.of(this,javaOptsBuilderConsumer);\n+        }\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Jar.java","additions":475,"deletions":166,"binary":false,"changes":641,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public void jExtractOpts(ForkExec.Opts opts) {\n+    public void jExtractOpts(StringList stringList) {\n@@ -47,1 +47,1 @@\n-                opts.add(\n+                stringList.add(\n@@ -53,1 +53,1 @@\n-                opts.add(\n+                stringList.add(\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/OpenCL.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public OpenGL(Project.Id id, Set<Dependency> buildDependencies) {\n+    public OpenGL(Project.Id id,  Set<Dependency> buildDependencies) {\n@@ -50,1 +50,1 @@\n-    public void jExtractOpts(ForkExec.Opts opts) {\n+    public void jExtractOpts(StringList stringList) {\n@@ -53,2 +53,2 @@\n-                List.of(\"GLUT\", \"OpenGL\").forEach(s -> opts.add(\"--library\", \":\/System\/Library\/Frameworks\/\" + s + \".framework\/\" + s));\n-                opts.add(\"--header-class-name\", \"opengl_h\", fwk + \"\/GLUT.framework\/Headers\/GLUT.h\");\n+                List.of(\"GLUT\", \"OpenGL\").forEach(s -> stringList.add(\"--library\", \":\/System\/Library\/Frameworks\/\" + s + \".framework\/\" + s));\n+                stringList.add(\"--header-class-name\", \"opengl_h\", fwk + \"\/GLUT.framework\/Headers\/GLUT.h\");\n@@ -56,2 +56,2 @@\n-                asSemiSeparatedStringList(\"OPENGL_LIBRARY\").forEach(lib -> opts.add(\"--library\", \":\" + lib));\n-                opts.add(\n+                asSemiSeparatedStringList(\"OPENGL_LIBRARY\").forEach(lib -> stringList.add(\"--library\", \":\" + lib));\n+                stringList.add(\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/OpenGL.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+        return JExtract.extract(id(strId),Set.of(dependencies));\n+    }\n+    public JExtract jextract(String strId, Set<Dependency> dependencies){\n@@ -70,1 +73,0 @@\n-\n@@ -209,1 +211,3 @@\n-    private final Jar.JavacOpts javacOpts;\n+    private final Jar.JavacConfig javacOpts;\n+    private final CMake.Config cmakeOpts;\n+    private final JExtract.Config jextractOpts;\n@@ -215,1 +219,3 @@\n-    public Jar.JavacOpts javacOpts() {return javacOpts;}\n+    public Jar.JavacConfig javacOpts() {return javacOpts;}\n+    public CMake.Config cmakeOpts() {return cmakeOpts;}\n+    public JExtract.Config jextractOpts() {return jextractOpts;}\n@@ -228,1 +234,0 @@\n-    public final Reporter reporter;\n@@ -230,1 +235,1 @@\n-    public Project(Path root, Jar.JavacOpts javacOpts,Reporter reporter) {\n+    public Project(Path root, Jar.JavacConfig javacConfig, CMake.Config cmakeConfig, JExtract.Config jextractConfig) {\n@@ -232,1 +237,3 @@\n-        this.javacOpts = javacOpts;\n+        this.javacOpts = javacConfig;\n+        this.cmakeOpts = cmakeConfig;\n+        this.jextractOpts = jextractConfig;\n@@ -238,4 +245,0 @@\n-        this.reporter = reporter;\n-    }\n-    public Project(Path root, Reporter reporter) {\n-        this(root, Jar.JavacOpts.of(),reporter);\n@@ -266,1 +269,1 @@\n-    public void clean(Dependency dependency, Path... paths) {\n+    public void clean(boolean verbose, Dependency dependency, Path... paths) {\n@@ -271,1 +274,3 @@\n-                    reporter.command(dependency, \"rm -rf \" + path);\n+                    if (verbose){\n+                        System.out.println(\"rm -rf \" + path);\n+                    }\n@@ -273,1 +278,3 @@\n-                    reporter.command(dependency, \"mkdir -p \" + path);\n+                    if (verbose){\n+                        System.out.println(\"mkdir -p \" + path);\n+                    }\n@@ -293,1 +300,1 @@\n-    public Dag clean(Set<Dependency> dependencies) {\n+    public Dag clean(boolean verbose,Set<Dependency> dependencies) {\n@@ -303,1 +310,1 @@\n-                .forEach(Dependency.Buildable::clean);\n+                .forEach(d->d.clean(verbose));\n@@ -310,2 +317,2 @@\n-    public Dag clean(String... names) {\n-        return clean(Set.of(names).stream().map(s -> this.artifacts.get(s)).collect(Collectors.toSet()));\n+    public Dag clean(boolean verbose, String... names) {\n+        return clean(verbose,Set.of(names).stream().map(s -> this.artifacts.get(s)).collect(Collectors.toSet()));\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Project.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package job;\n-\n-import java.util.function.Consumer;\n-\n-public class Reporter {\n-    public final Consumer<String> command = System.out::println;\n-    public final Consumer<String> progress = System.out::println;\n-    public final Consumer<String> error = System.out::println;\n-    public final Consumer<String> info = System.out::println;\n-    public final Consumer<String> warning = System.out::println;\n-    public final Consumer<String> note = System.out::println;\n-\n-    public void command(Dependency dependency, String command) {\n-        if (dependency != null) {\n-            this.command.accept(\"# \" + dependency.id().projectRelativeHyphenatedName() + \" command line \");\n-        }\n-        this.command.accept(command);\n-    }\n-\n-    public void progress(Dependency dependency, String command) {\n-        if (dependency != null) {\n-            progress.accept(\"# \" + dependency.id().projectRelativeHyphenatedName() + \" \" + command);\n-        }\n-    }\n-\n-    public void error(Dependency dependency, String command) {\n-        if (dependency != null) {\n-            error.accept(\"# \" + dependency.id().projectRelativeHyphenatedName() + \" error \");\n-        }\n-        error.accept(command);\n-    }\n-\n-    public void info(Dependency dependency, String command) {\n-        \/\/ if (dependency != null) {\n-        \/\/     info.accept(\"# \"+dependency.id().projectRelativeHyphenatedName+\" info \");\n-        \/\/  }\n-        info.accept(command);\n-    }\n-\n-    public void note(Dependency dependency, String command) {\n-        \/\/  if (dependency != null) {\n-        \/\/    note.accept(\"# \"+dependency.id().projectRelativeHyphenatedName+\" note \");\n-        \/\/  }\n-        note.accept(command);\n-    }\n-\n-    public void warning(Dependency dependency, String command) {\n-        \/\/   if (dependency != null) {\n-        \/\/      warning.accept(\"# \"+dependency.id().projectRelativeHyphenatedName+\" warning \");\n-        \/\/  }\n-        warning.accept(command);\n-    }\n-\n-    static Reporter verbose = new Reporter();\n-    public static Reporter commandsAndErrors = new Reporter() {\n-        @Override\n-        public void warning(Dependency dependency, String command) {\n-\n-        }\n-\n-        @Override\n-        public void info(Dependency dependency, String command) {\n-\n-        }\n-\n-        @Override\n-        public void note(Dependency dependency, String command) {\n-\n-        }\n-\n-        @Override\n-        public void progress(Dependency dependency, String command) {\n-\n-        }\n-\n-    };\n-\n-    public static Reporter progressAndErrors = new Reporter() {\n-        @Override\n-        public void warning(Dependency dependency, String command) {\n-\n-        }\n-\n-        @Override\n-        public void info(Dependency dependency, String command) {\n-\n-        }\n-\n-        @Override\n-        public void note(Dependency dependency, String command) {\n-\n-        }\n-\n-        @Override\n-        public void command(Dependency dependency, String command) {\n-\n-        }\n-\n-        public void progress(Dependency dependency, String command) {\n-            if (dependency != null) {\n-                progress.accept(dependency.id().projectRelativeHyphenatedName() + \":\" + command);\n-            }\n-        }\n-    };\n-}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Reporter.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class StringList {\n+    private List<String> opts = new ArrayList<>();\n+    public List<String> list(){\n+        return opts;\n+    }\n+    private StringList() {\n+\n+    }\n+    StringList addIf(boolean condition, String... opts) {\n+        return condition?add(List.of(opts)):this;\n+    }\n+\n+    StringList add(String... opts) {\n+        return add(List.of(opts));\n+    }\n+\n+    StringList add(List<String> opts) {\n+        this.opts.addAll(opts);\n+        return this;\n+    }\n+\n+  \/\/  public static Opts of(String executable) {\n+    \/\/    return of().add(executable);\n+   \/\/ }\n+    public static StringList of() {\n+        return new StringList();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.join(\" \", opts);\n+    }\n+\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/StringList.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -34,0 +34,2 @@\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n@@ -94,0 +96,25 @@\n+\n+    public static Path currentDirAsPath() {\n+        return Path.of(System.getProperty(\"user.dir\"));\n+    }\n+\n+    public static String currentProcessPath() {\n+        return ProcessHandle.current().info().command().orElseThrow();\n+    }\n+\n+    public static void forEachEntry(Path path, Predicate<JarEntry> jarEntryPredicate, Consumer<JarEntry> jarEntryConsumer) {\n+        try {\n+            var jarFile = new JarFile(path.toString());\n+            var entries = jarFile.entries();\n+            while (entries.hasMoreElements() && entries.nextElement() instanceof JarEntry jarEntry) {\n+                if (jarEntryPredicate.test(jarEntry)) {\n+                    jarEntryConsumer.accept(jarEntry);\n+                }\n+            }\n+        }catch (IOException ioe){\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+    public static void forEachEntry(Path path, Consumer<JarEntry> jarEntryConsumer) {\n+       forEachEntry(path,jarEntry -> true, jarEntryConsumer);\n+    }\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Util.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"}]}