{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.classfile.Opcode;\n@@ -50,1 +51,1 @@\n-            if (coe instanceof BranchInstruction bi && BytecodeHelpers.isUnconditionalBranch(bi.opcode())) {\n+            if (coe instanceof BranchInstruction bi && isUnconditionalBranch(bi.opcode())) {\n@@ -92,0 +93,7 @@\n+\n+    static boolean isUnconditionalBranch(Opcode opcode) {\n+        return switch (opcode) {\n+            case GOTO, ATHROW, GOTO_W, LOOKUPSWITCH, TABLESWITCH -> true;\n+            default -> opcode.kind() == Opcode.Kind.RETURN;\n+        };\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/BranchCompactor.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,16 +0,0 @@\n-package jdk.incubator.code.bytecode.impl;\n-\n-import java.lang.classfile.Opcode;\n-\n-public final class BytecodeHelpers {\n-\n-    \/\/ Copied from java.base\/jdk.internal.classfile.impl.BytecodeHelpers\n-    \/\/ to avoid export of package from java.base to jdk.incubator.code\n-\n-    public static boolean isUnconditionalBranch(Opcode opcode) {\n-        return switch (opcode) {\n-            case GOTO, ATHROW, GOTO_W, LOOKUPSWITCH, TABLESWITCH -> true;\n-            default -> opcode.kind() == Opcode.Kind.RETURN;\n-        };\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/BytecodeHelpers.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import jdk.incubator.code.bytecode.BytecodeLift;\n@@ -29,2 +28,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.interpreter.Interpreter;\n@@ -636,54 +633,0 @@\n-    @ParameterizedTest\n-    @MethodSource(\"testMethods\")\n-    public void testLift(TestData d) throws Throwable {\n-        CoreOp.FuncOp flift;\n-        try {\n-            flift = BytecodeLift.lift(CLASS_DATA, d.testMethod.getName(), toMethodTypeDesc(d.testMethod));\n-        } catch (Throwable e) {\n-            ClassPrinter.toYaml(ClassFile.of().parse(TestBytecode.class.getResourceAsStream(\"TestBytecode.class\").readAllBytes())\n-                    .methods().stream().filter(m -> m.methodName().equalsString(d.testMethod().getName())).findAny().get(),\n-                    ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n-            System.out.println(\"Lift failed, compiled model:\");\n-            Op.ofMethod(d.testMethod).ifPresent(f -> System.out.println(f.toText()));\n-            throw e;\n-        }\n-        try {\n-            Object receiver1, receiver2;\n-            if (d.testMethod.accessFlags().contains(AccessFlag.STATIC)) {\n-                receiver1 = null;\n-                receiver2 = null;\n-            } else {\n-                receiver1 = new TestBytecode();\n-                receiver2 = new TestBytecode();\n-            }\n-            permutateAllArgs(d.testMethod.getParameterTypes(), args ->\n-                    assertEquals(d.testMethod.invoke(receiver2, args), invokeAndConvert(flift, receiver1, args)));\n-        } catch (Throwable e) {\n-            System.out.println(\"Compiled model:\");\n-            Op.ofMethod(d.testMethod).ifPresent(f -> System.out.println(f.toText()));\n-            System.out.println(\"Lifted model:\");\n-            System.out.println(flift.toText());\n-            throw e;\n-        }\n-    }\n-\n-    private static Object invokeAndConvert(CoreOp.FuncOp func, Object receiver, Object... args) {\n-        List argl = new ArrayList(args.length + 1);\n-        if (receiver != null) argl.add(receiver);\n-        argl.addAll(Arrays.asList(args));\n-        Object ret = Interpreter.invoke(MethodHandles.lookup(), func, argl);\n-        if (ret instanceof Integer i) {\n-            TypeElement rt = func.invokableType().returnType();\n-            if (rt.equals(JavaType.BOOLEAN)) {\n-                return i != 0;\n-            } else if (rt.equals(JavaType.BYTE)) {\n-                return i.byteValue();\n-            } else if (rt.equals(JavaType.CHAR)) {\n-                return (short)i.intValue();\n-            } else if (rt.equals(JavaType.SHORT)) {\n-                return i.shortValue();\n-            }\n-        }\n-        return ret;\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":1,"deletions":58,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,0 @@\n-package jdk.incubator.code.bytecode;\n-\n-import jdk.incubator.code.bytecode.impl.BytecodeHelpers;\n@@ -253,1 +250,1 @@\n-                case BranchInstruction inst when BytecodeHelpers.isUnconditionalBranch(inst.opcode()) -> {\n+                case BranchInstruction inst when isUnconditionalBranch(inst.opcode()) -> {\n@@ -953,0 +950,7 @@\n+\n+    private static boolean isUnconditionalBranch(Opcode opcode) {\n+        return switch (opcode) {\n+            case GOTO, ATHROW, GOTO_W, LOOKUPSWITCH, TABLESWITCH -> true;\n+            default -> opcode.kind() == Opcode.Kind.RETURN;\n+        };\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/BytecodeLift.java","additions":9,"deletions":5,"binary":false,"changes":14,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeLift.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-package jdk.incubator.code.bytecode;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/SlotOp.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/SlotOp.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-package jdk.incubator.code.bytecode;\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/SlotToVarTransformer.java","additions":1,"deletions":3,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/SlotToVarTransformer.java","status":"renamed"},{"patch":"","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TEST.properties","status":"renamed"},{"patch":"@@ -0,0 +1,695 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.opentest4j.TestSkippedException;\n+\n+import java.io.IOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\/jdk.incubator.code.internal\n+ * @modules java.base\/jdk.internal.classfile.components\n+ * @enablePreview\n+ * @run junit\/othervm -Djdk.invoke.MethodHandle.dumpClassFiles=true TestBytecodeLift\n+ *\/\n+\n+public class TestBytecodeLift {\n+\n+    @CodeReflection\n+    static int intNumOps(int i, int j, int k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static byte byteNumOps(byte i, byte j, byte k) {\n+        k++;\n+        i = (byte) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static short shortNumOps(short i, short j, short k) {\n+        k++;\n+        i = (short) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static char charNumOps(char i, char j, char k) {\n+        k++;\n+        i = (char) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static long longNumOps(long i, long j, long k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static float floatNumOps(float i, float j, float k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static double doubleNumOps(double i, double j, double k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static int intBitOps(int i, int j, int k) {\n+        return ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static byte byteBitOps(byte i, byte j, byte k) {\n+        return (byte) ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static short shortBitOps(short i, short j, short k) {\n+        return (short) ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static char charBitOps(char i, char j, char k) {\n+        return (char) ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static long longBitOps(long i, long j, long k) {\n+        return ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static boolean boolBitOps(boolean i, boolean j, boolean k) {\n+        return i & j | k ^ j;\n+    }\n+\n+    @CodeReflection\n+    static int intShiftOps(int i, int j, int k) {\n+        return ((-1 >> i) << (j << k)) >>> (k - j);\n+    }\n+\n+    @CodeReflection\n+    static byte byteShiftOps(byte i, byte j, byte k) {\n+        return (byte) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    static short shortShiftOps(short i, short j, short k) {\n+        return (short) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    static char charShiftOps(char i, char j, char k) {\n+        return (char) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    static long longShiftOps(long i, long j, long k) {\n+        return ((-1 >> i) << (j << k)) >>> (k - j);\n+    }\n+\n+    @CodeReflection\n+    static Object[] boxingAndUnboxing(int i, byte b, short s, char c, Integer ii, Byte bb, Short ss, Character cc) {\n+        ii += i; ii += b; ii += s; ii += c;\n+        i += ii; i += bb; i += ss; i += cc;\n+        b += ii; b += bb; b += ss; b += cc;\n+        s += ii; s += bb; s += ss; s += cc;\n+        c += ii; c += bb; c += ss; c += cc;\n+        return new Object[]{i, b, s, c};\n+    }\n+\n+    @CodeReflection\n+    static String constructor(String s, int i, int j) {\n+        return new String(s.getBytes(), i, j);\n+    }\n+\n+    @CodeReflection\n+    static Class<?> classArray(int i, int j) {\n+        Class<?>[] ifaces = new Class[1 + i + j];\n+        ifaces[0] = Function.class;\n+        return ifaces[0];\n+    }\n+\n+    @CodeReflection\n+    static String[] stringArray(int i, int j) {\n+        return new String[i];\n+    }\n+\n+    @CodeReflection\n+    static String[][] stringArray2(int i, int j) {\n+        return new String[i][];\n+    }\n+\n+    @CodeReflection\n+    static String[][] stringArrayMulti(int i, int j) {\n+        return new String[i][j];\n+    }\n+\n+    @CodeReflection\n+    static int[][] initializedIntArray(int i, int j) {\n+        return new int[][]{{i, j}, {i + j}};\n+    }\n+\n+    @CodeReflection\n+    static int ifElseCompare(int i, int j) {\n+        if (i < 3) {\n+            i += 1;\n+        } else {\n+            j += 2;\n+        }\n+        return i + j;\n+    }\n+\n+    @CodeReflection\n+    static int ifElseEquality(int i, int j) {\n+        if (j != 0) {\n+            if (i != 0) {\n+                i += 1;\n+            } else {\n+                i += 2;\n+            }\n+        } else {\n+            if (j != 0) {\n+                i += 3;\n+            } else {\n+                i += 4;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static int objectsCompare(Boolean b1, Boolean b2, Boolean b3) {\n+        Object a = b1;\n+        Object b = b2;\n+        Object c = b3;\n+        return a == b ? (a != c ? 1 : 2) : (b != c ? 3 : 4);\n+    }\n+\n+    @CodeReflection\n+    static int conditionalExpr(int i, int j) {\n+        return ((i - 1 >= 0) ? i - 1 : j - 1);\n+    }\n+\n+    @CodeReflection\n+    static int nestedConditionalExpr(int i, int j) {\n+        return (i < 2) ? (j < 3) ? i : j : i + j;\n+    }\n+\n+    static final int[] MAP = {0, 1, 2, 3, 4};\n+\n+    @CodeReflection\n+    static int deepStackBranches(boolean a, boolean b) {\n+        return MAP[a ? MAP[b ? 1 : 2] : MAP[b ? 3 : 4]];\n+    }\n+\n+    @CodeReflection\n+    static int tryFinally(int i, int j) {\n+        try {\n+            i = i + j;\n+        } finally {\n+            i = i + j;\n+        }\n+        return i;\n+    }\n+\n+    public record A(String s) {}\n+\n+    @CodeReflection\n+    static A newWithArgs(int i, int j) {\n+        return new A(\"hello world\".substring(i, i + j));\n+    }\n+\n+    @CodeReflection\n+    static int loop(int n, int j) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            sum = sum + j;\n+        }\n+        return sum;\n+    }\n+\n+\n+    @CodeReflection\n+    static int ifElseNested(int a, int b) {\n+        int c = a + b;\n+        int d = 10 - a + b;\n+        if (b < 3) {\n+            if (a < 3) {\n+                a += 1;\n+            } else {\n+                b += 2;\n+            }\n+            c += 3;\n+        } else {\n+            if (a > 2) {\n+                a += 4;\n+            } else {\n+                b += 5;\n+            }\n+            d += 6;\n+        }\n+        return a + b + c + d;\n+    }\n+\n+    @CodeReflection\n+    static int nestedLoop(int m, int n) {\n+        int sum = 0;\n+        for (int i = 0; i < m; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum = sum + i + j;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @CodeReflection\n+    static int methodCall(int a, int b) {\n+        int i = Math.max(a, b);\n+        return Math.negateExact(i);\n+    }\n+\n+    @CodeReflection\n+    static int[] primitiveArray(int i, int j) {\n+        int[] ia = new int[i + 1];\n+        ia[0] = j;\n+        return ia;\n+    }\n+\n+    @CodeReflection\n+    static boolean not(boolean b) {\n+        return !b;\n+    }\n+\n+    @CodeReflection\n+    static boolean notCompare(int i, int j) {\n+        boolean b = i < j;\n+        return !b;\n+    }\n+\n+    @CodeReflection\n+    static int mod(int i, int j) {\n+        return i % (j + 1);\n+    }\n+\n+    @CodeReflection\n+    static int xor(int i, int j) {\n+        return i ^ j;\n+    }\n+\n+    @CodeReflection\n+    static int whileLoop(int i, int n) { int\n+        counter = 0;\n+        while (i < n && counter < 3) {\n+            counter++;\n+            if (counter == 4) {\n+                break;\n+            }\n+            i++;\n+        }\n+        return counter;\n+    }\n+\n+    public interface Func {\n+        int apply(int a);\n+    }\n+\n+    public interface QuotableFunc extends Quotable {\n+        int apply(int a);\n+    }\n+\n+    static int consume(int i, Func f) {\n+        return f.apply(i + 1);\n+    }\n+\n+    static int consumeQuotable(int i, QuotableFunc f) {\n+        Assertions.assertNotNull(Op.ofQuotable(f).get());\n+        Assertions.assertNotNull(Op.ofQuotable(f).get().op());\n+        Assertions.assertTrue(Op.ofQuotable(f).get().op() instanceof JavaOp.LambdaOp);\n+        return f.apply(i + 1);\n+    }\n+\n+    @CodeReflection\n+    static int lambda(int i) {\n+        return consume(i, a -> -a);\n+    }\n+\n+    @CodeReflection\n+    static int quotableLambda(int i) {\n+        return consumeQuotable(i, a -> -a);\n+    }\n+\n+    @CodeReflection\n+    static int lambdaWithCapture(int i, String s) {\n+        return consume(i, a -> a + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int quotableLambdaWithCapture(int i, String s) {\n+        return consumeQuotable(i, a -> a + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int nestedLambdasWithCaptures(int i, int j, String s) {\n+        return consume(i, a -> consume(a, b -> a + b + j - s.length()) + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int nestedQuotableLambdasWithCaptures(int i, int j, String s) {\n+        return consumeQuotable(i, a -> consumeQuotable(a, b -> a + b + j - s.length()) + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int methodHandle(int i) {\n+        return consume(i, Math::negateExact);\n+    }\n+\n+    int instanceMethod(int i) {\n+        return -i + 13;\n+    }\n+\n+    @CodeReflection\n+    int instanceMethodHandle(int i) {\n+        return consume(i, this::instanceMethod);\n+    }\n+\n+    static void consume(boolean b, Consumer<Object> requireNonNull) {\n+        if (b) {\n+            requireNonNull.accept(new Object());\n+        } else try {\n+            requireNonNull.accept(null);\n+            throw new AssertionError(\"Expectend NPE\");\n+        } catch (NullPointerException expected) {\n+        }\n+    }\n+\n+    @CodeReflection\n+    static void nullReturningMethodHandle(boolean b) {\n+        consume(b, Objects::requireNonNull);\n+    }\n+\n+    @CodeReflection\n+    static boolean compareLong(long i, long j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static boolean compareFloat(float i, float j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static boolean compareDouble(double i, double j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static int lookupSwitch(int i) {\n+        return switch (1000 * i) {\n+            case 1000 -> 1;\n+            case 2000 -> 2;\n+            case 3000 -> 3;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    static int tableSwitch(int i) {\n+        return switch (i) {\n+            case 1 -> 1;\n+            case 2 -> 2;\n+            case 3 -> 3;\n+            default -> 0;\n+        };\n+    }\n+\n+    int instanceField = -1;\n+\n+    @CodeReflection\n+    int instanceFieldAccess(int i) {\n+        int ret = instanceField;\n+        instanceField = i;\n+        return ret;\n+    }\n+\n+    @CodeReflection\n+    static String stringConcat(String a, String b) {\n+        return \"a\"+ a +\"\\u0001\" + a + \"b\\u0002c\" + b + \"\\u0001\\u0002\" + b + \"dd\";\n+    }\n+\n+    @CodeReflection\n+    static String multiTypeConcat(int i, Boolean b, char c, Short s, float f, Double d) {\n+        return \"i:\"+ i +\" b:\" + b + \" c:\" + c + \" f:\" + f + \" d:\" + d;\n+    }\n+\n+    @CodeReflection\n+    static int ifTrue(int i) {\n+        if (true) {\n+            return i;\n+        }\n+        return -i;\n+    }\n+\n+    @CodeReflection\n+    static int excHandlerFollowingSplitTable(boolean b) {\n+        try {\n+            if (b) return 1;\n+            else throw new Exception();\n+        } catch (Exception ex) {}\n+        return 2;\n+    }\n+\n+    @CodeReflection\n+    static int varModifiedInTryBlock(boolean b) {\n+        int i = 0;\n+        try {\n+            i++;\n+            if (b) throw new Exception();\n+            i++;\n+            throw new Exception();\n+        } catch (Exception ex) {\n+            return i;\n+        }\n+    }\n+\n+    @CodeReflection\n+    static boolean finallyWithLoop(boolean b) {\n+        try {\n+            while (b) {\n+                if (b)\n+                    return false;\n+                b = !b;\n+            }\n+            return true;\n+        } finally {\n+            b = false;\n+        }\n+    }\n+\n+    @CodeReflection\n+    static long doubleUseOfOperand(int x) {\n+        long piece = x;\n+        return piece * piece;\n+    }\n+\n+    record TestData(Method testMethod) {\n+        @Override\n+        public String toString() {\n+            String s = testMethod.getName() + Arrays.stream(testMethod.getParameterTypes())\n+                    .map(Class::getSimpleName).collect(Collectors.joining(\",\", \"(\", \")\"));\n+            if (s.length() > 30) s = s.substring(0, 27) + \"...\";\n+            return s;\n+        }\n+    }\n+\n+    public static Stream<TestData> testMethods() {\n+        return Stream.of(TestBytecodeLift.class.getDeclaredMethods())\n+                .filter(m -> m.isAnnotationPresent(CodeReflection.class))\n+                .map(TestData::new);\n+    }\n+\n+    private static byte[] CLASS_DATA;\n+    private static ClassModel CLASS_MODEL;\n+\n+    @BeforeAll\n+    public static void setup() throws Exception {\n+        CLASS_DATA = TestBytecodeLift.class.getResourceAsStream(\"TestBytecodeLift.class\").readAllBytes();\n+        CLASS_MODEL = ClassFile.of().parse(CLASS_DATA);\n+    }\n+\n+    private static MethodTypeDesc toMethodTypeDesc(Method m) {\n+        return MethodTypeDesc.of(\n+                m.getReturnType().describeConstable().orElseThrow(),\n+                Arrays.stream(m.getParameterTypes())\n+                        .map(cls -> cls.describeConstable().orElseThrow()).toList());\n+    }\n+\n+\n+    private static final Map<Class<?>, Object[]> TEST_ARGS = new IdentityHashMap<>();\n+    private static Object[] values(Object... values) {\n+        return values;\n+    }\n+    private static void initTestArgs(Object[] values, Class<?>... argTypes) {\n+        for (var argType : argTypes) TEST_ARGS.put(argType, values);\n+    }\n+    static {\n+        initTestArgs(values(1, 2, 4), int.class, Integer.class);\n+        initTestArgs(values((byte)1, (byte)3, (byte)4), byte.class, Byte.class);\n+        initTestArgs(values((short)1, (short)2, (short)3), short.class, Short.class);\n+        initTestArgs(values((char)2, (char)3, (char)4), char.class, Character.class);\n+        initTestArgs(values(false, true), boolean.class, Boolean.class);\n+        initTestArgs(values(\"Hello World\"), String.class);\n+        initTestArgs(values(1l, 2l, 4l), long.class, Long.class);\n+        initTestArgs(values(1f, 3f, 4f), float.class, Float.class);\n+        initTestArgs(values(1d, 2d, 3d), double.class, Double.class);\n+    }\n+\n+    interface Executor {\n+        void execute(Object[] args) throws Throwable;\n+    }\n+\n+    private static void permutateAllArgs(Class<?>[] argTypes, Executor executor) throws Throwable {\n+        final int argn = argTypes.length;\n+        Object[][] argValues = new Object[argn][];\n+        for (int i = 0; i < argn; i++) {\n+            argValues[i] = TEST_ARGS.get(argTypes[i]);\n+        }\n+        int[] argIndexes = new int[argn];\n+        Object[] args = new Object[argn];\n+        while (true) {\n+            for (int i = 0; i < argn; i++) {\n+                args[i] = argValues[i][argIndexes[i]];\n+            }\n+            executor.execute(args);\n+            int i = argn - 1;\n+            while (i >= 0 && argIndexes[i] == argValues[i].length - 1) i--;\n+            if (i < 0) return;\n+            argIndexes[i++]++;\n+            while (i < argn) argIndexes[i++] = 0;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testMethods\")\n+    public void testLift(TestData d) throws Throwable {\n+        CoreOp.FuncOp flift;\n+        try {\n+            flift = BytecodeLift.lift(CLASS_DATA, d.testMethod.getName(), toMethodTypeDesc(d.testMethod));\n+        } catch (Throwable e) {\n+            ClassPrinter.toYaml(ClassFile.of().parse(TestBytecodeLift.class.getResourceAsStream(\"TestBytecodeLift.class\").readAllBytes())\n+                    .methods().stream().filter(m -> m.methodName().equalsString(d.testMethod().getName())).findAny().get(),\n+                    ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+            System.out.println(\"Lift failed, compiled model:\");\n+            Op.ofMethod(d.testMethod).ifPresent(f -> System.out.println(f.toText()));\n+            throw e;\n+        }\n+        try {\n+            Object receiver1, receiver2;\n+            if (d.testMethod.accessFlags().contains(AccessFlag.STATIC)) {\n+                receiver1 = null;\n+                receiver2 = null;\n+            } else {\n+                receiver1 = new TestBytecodeLift();\n+                receiver2 = new TestBytecodeLift();\n+            }\n+            permutateAllArgs(d.testMethod.getParameterTypes(), args ->\n+                    assertEquals(d.testMethod.invoke(receiver2, args), invokeAndConvert(flift, receiver1, args)));\n+        } catch (Throwable e) {\n+            System.out.println(\"Compiled model:\");\n+            Op.ofMethod(d.testMethod).ifPresent(f -> System.out.println(f.toText()));\n+            System.out.println(\"Lifted model:\");\n+            System.out.println(flift.toText());\n+            throw e;\n+        }\n+    }\n+\n+    private static Object invokeAndConvert(CoreOp.FuncOp func, Object receiver, Object... args) {\n+        List argl = new ArrayList(args.length + 1);\n+        if (receiver != null) argl.add(receiver);\n+        argl.addAll(Arrays.asList(args));\n+        Object ret = Interpreter.invoke(MethodHandles.lookup(), func, argl);\n+        if (ret instanceof Integer i) {\n+            TypeElement rt = func.invokableType().returnType();\n+            if (rt.equals(JavaType.BOOLEAN)) {\n+                return i != 0;\n+            } else if (rt.equals(JavaType.BYTE)) {\n+                return i.byteValue();\n+            } else if (rt.equals(JavaType.CHAR)) {\n+                return (short)i.intValue();\n+            } else if (rt.equals(JavaType.SHORT)) {\n+                return i.shortValue();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    private static void assertEquals(Object expected, Object actual) {\n+        switch (expected) {\n+            case int[] expArr when actual instanceof int[] actArr -> Assertions.assertArrayEquals(expArr, actArr);\n+            case Object[] expArr when actual instanceof Object[] actArr -> Assertions.assertArrayEquals(expArr, actArr);\n+            case null, default -> Assertions.assertEquals(expected, actual);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestBytecodeLift.java","additions":695,"deletions":0,"binary":false,"changes":695,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import jdk.incubator.code.bytecode.BytecodeLift;\n@@ -38,1 +37,1 @@\n- * @modules jdk.incubator.code\n+ * @modules jdk.incubator.code\/jdk.incubator.code.internal\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestLiftCustomBytecode.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import jdk.incubator.code.bytecode.BytecodeLift;\n@@ -38,1 +37,1 @@\n- * @modules jdk.incubator.code\n+ * @modules jdk.incubator.code\/jdk.incubator.code.internal\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestLiftExample.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftExample.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import jdk.incubator.code.bytecode.BytecodeLift;\n@@ -47,1 +46,1 @@\n- * @modules jdk.incubator.code\n+ * @modules jdk.incubator.code\/jdk.incubator.code.internal\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestSmallCorpus.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-package jdk.incubator.code.bytecode;\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/UnresolvedType.java","additions":1,"deletions":3,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/UnresolvedType.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-package jdk.incubator.code.bytecode;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/UnresolvedTypesTransformer.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/UnresolvedTypesTransformer.java","status":"renamed"},{"patch":"","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/Verifier.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/Verifier.java","status":"renamed"}]}