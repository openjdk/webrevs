{"files":[{"patch":"@@ -10,0 +10,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.TreeInfo;\n@@ -83,6 +85,4 @@\n-            var lastParam = invokeOp.invokeDescriptor().type().parameterTypes().getLast();\n-            if (lastParam instanceof ArrayType varargType) {\n-                methodInvocation.varargsElement = typeElementToType(varargType.componentType());\n-            } else {\n-                Assert.error(\"Vararg method doesn't have a trailing array type: \" + invokeOp.invokeDescriptor());\n-            }\n+            setVarargs(methodInvocation, invokeOp.invokeDescriptor().type());\n+        }\n+        if (invokeOp.result().uses().isEmpty()) {\n+            return treeMaker.Exec(methodInvocation);\n@@ -93,0 +93,9 @@\n+    void setVarargs(JCExpression tree, FunctionType type) {\n+        var lastParam = type.parameterTypes().getLast();\n+        if (lastParam instanceof ArrayType varargType) {\n+            TreeInfo.setVarargsElement(tree, typeElementToType(varargType.componentType()));\n+        } else {\n+            Assert.error(\"Expected trailing array type: \" + type);\n+        }\n+    }\n+\n@@ -99,10 +108,5 @@\n-            case CoreOp.NewOp newOp -> {\n-                if (newOp.resultType() instanceof ArrayType at) {\n-                    var elemType = treeMaker.Ident(typeElementToType(at.componentType()).tsym);\n-                    var dims = new ListBuffer<JCTree.JCExpression>();\n-                    for (int d = 0; d < at.dimensions(); d++) {\n-                        dims.add(exprTree(newOp.operands().get(d)));\n-                    }\n-                    var na = treeMaker.NewArray(elemType, dims.toList(), null);\n-                    na.type = typeElementToType(at);\n-                    yield na;\n+            case CoreOp.NewOp newOp when newOp.resultType() instanceof ArrayType at -> {\n+                var elemType = treeMaker.Ident(typeElementToType(at.componentType()).tsym);\n+                var dims = new ListBuffer<JCTree.JCExpression>();\n+                for (int d = 0; d < at.dimensions(); d++) {\n+                    dims.add(exprTree(newOp.operands().get(d)));\n@@ -110,0 +114,5 @@\n+                var na = treeMaker.NewArray(elemType, dims.toList(), null);\n+                na.type = typeElementToType(at);\n+                yield na;\n+            }\n+            case CoreOp.NewOp newOp -> {\n@@ -117,3 +126,2 @@\n-                var argTypes = new ListBuffer<Type>();\n-                for (Value operand : newOp.operands()) {\n-                    argTypes.add(typeElementToType(operand.type()));\n+                if (newOp.isVarArgs()) {\n+                    setVarargs(nc, newOp.constructorType());\n@@ -122,3 +130,2 @@\n-                \/\/ TODO: this should be fixed to use a MethodRef in the new op (once that is added)\n-                nc.constructorType = new Type.MethodType(argTypes.toList(), syms.voidType, List.nil(), syms.methodClass);\n-                nc.constructor = new Symbol.MethodSymbol(PUBLIC, names.init, nc.constructorType, ownerType.tsym);\n+                nc.constructor = constructorTypeToSymbol(newOp.constructorType());\n+                nc.constructorType = nc.constructor.type;\n@@ -212,2 +219,7 @@\n-    \/\/ TODO: generate AST in SSA form\n-    \/\/ TODO: drop addVarsWhenNecessary\n+    MethodSymbol constructorTypeToSymbol(FunctionType constructorType) {\n+        Type site = typeElementToType(constructorType.returnType());\n+        List<Type> argtypes = constructorType.parameterTypes().stream()\n+                .map(this::typeElementToType).collect(List.collector());\n+        return resolve.resolveInternalConstructor(attrEnv.enclClass, attrEnv, site, argtypes, List.nil());\n+    }\n+\n@@ -215,1 +227,0 @@\n-    \/\/ TODO: share method and constructor code\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":36,"deletions":25,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1498,1 +1498,1 @@\n-            result = append(CoreOp._new(typeToTypeElement(type), constructorType, args));\n+            result = append(CoreOp._new(typeToTypeElement(type), tree.varargsElement != null, constructorType, args));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.op.CoreOp.InvokeOp.InvokeKind;\n@@ -1622,0 +1623,1 @@\n+        public static final String ATTRIBUTE_NEW_VARARGS = NAME + \".varargs\";\n@@ -1625,0 +1627,1 @@\n+        final boolean isVarArgs;\n@@ -1640,1 +1643,9 @@\n-            return new NewOp(def, constructorType);\n+\n+            \/\/ If not present defaults to false\n+            boolean isVarArgs = def.extractAttributeValue(ATTRIBUTE_NEW_VARARGS,\n+                    false, v -> switch (v) {\n+                        case String s -> Boolean.valueOf(s);\n+                        case Boolean b -> b;\n+                        case null, default -> false;\n+                    });\n+            return new NewOp(def, constructorType, isVarArgs);\n@@ -1643,1 +1654,10 @@\n-        NewOp(ExternalizedOp def, FunctionType constructorType) {\n+        static void validateArgCount(boolean isVarArgs, FunctionType constructorType, List<Value> operands) {\n+            int paramCount = constructorType.parameterTypes().size();\n+            int argCount = operands.size();\n+            if ((!isVarArgs && argCount != paramCount)\n+                    || argCount < paramCount - 1) {\n+                throw new IllegalArgumentException(isVarArgs + \" \" + constructorType);\n+            }\n+        }\n+\n+        NewOp(ExternalizedOp def, FunctionType constructorType, boolean isVarArgs) {\n@@ -1646,0 +1666,2 @@\n+            validateArgCount(isVarArgs, constructorType, def.operands());\n+\n@@ -1647,0 +1669,1 @@\n+            this.isVarArgs = isVarArgs;\n@@ -1654,0 +1677,1 @@\n+            this.isVarArgs = that.isVarArgs;\n@@ -1662,5 +1686,1 @@\n-        NewOp(FunctionType constructorType, List<Value> args) {\n-            this(constructorType.returnType(), constructorType, args);\n-        }\n-\n-        NewOp(TypeElement resultType, FunctionType constructorType, List<Value> args) {\n+        NewOp(TypeElement resultType, boolean isVarArgs, FunctionType constructorType, List<Value> args) {\n@@ -1669,0 +1689,2 @@\n+            validateArgCount(isVarArgs, constructorType, args);\n+\n@@ -1670,0 +1692,1 @@\n+            this.isVarArgs = isVarArgs;\n@@ -1677,0 +1700,3 @@\n+            if (isVarArgs) {\n+                m.put(ATTRIBUTE_NEW_VARARGS, isVarArgs);\n+            }\n@@ -1680,0 +1706,4 @@\n+        public boolean isVarArgs() {\n+            return isVarArgs;\n+        }\n+\n@@ -3857,1 +3887,1 @@\n-        return new NewOp(constructorType, args);\n+        return _new(constructorType.returnType(), constructorType, args);\n@@ -3883,1 +3913,15 @@\n-        return new NewOp(returnType, constructorType, args);\n+        return _new(returnType, false, constructorType, args);\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param returnType      the instance type\n+     * @param isVarArgs       true if an invocation to a variable argument constructor\n+     * @param constructorType the constructor type\n+     * @param args            the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(TypeElement returnType, boolean isVarArgs, FunctionType constructorType,\n+                             List<Value> args) {\n+        return new NewOp(returnType, isVarArgs, constructorType, args);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":53,"deletions":9,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -619,1 +619,1 @@\n-                %5 : BoxingConversionTest$Box2 = new %3 %4 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n+                %5 : BoxingConversionTest$Box2 = new %3 %4 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\" @new.varargs=\"true\";\n@@ -635,1 +635,1 @@\n-                %7 : BoxingConversionTest$Box2 = new %3 %4 %6 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n+                %7 : BoxingConversionTest$Box2 = new %3 %4 %6 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\" @new.varargs=\"true\";\n@@ -653,1 +653,1 @@\n-                %9 : BoxingConversionTest$Box2 = new %3 %4 %6 %8 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n+                %9 : BoxingConversionTest$Box2 = new %3 %4 %6 %8 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\" @new.varargs=\"true\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/BoxingConversionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -532,1 +532,1 @@\n-                %5 : ImplicitConversionTest$Box = new %3 %4 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n+                %5 : ImplicitConversionTest$Box = new %3 %4 @\"func<ImplicitConversionTest$Box, int, int, long[]>\" @new.varargs=\"true\";\n@@ -548,1 +548,1 @@\n-               %7 : ImplicitConversionTest$Box = new %3 %4 %6 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n+               %7 : ImplicitConversionTest$Box = new %3 %4 %6 @\"func<ImplicitConversionTest$Box, int, int, long[]>\" @new.varargs=\"true\";\n@@ -566,1 +566,1 @@\n-                %9 : ImplicitConversionTest$Box = new %3 %4 %6 %8 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n+                %9 : ImplicitConversionTest$Box = new %3 %4 %6 %8 @\"func<ImplicitConversionTest$Box, int, int, long[]>\" @new.varargs=\"true\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -237,0 +237,82 @@\n+\n+    static class V {\n+        V(int i, int... values) { }\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : NewTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : NewTest$V = new %3 @\"func<NewTest$V, int, int[]>\" @new.varargs=\"true\";\n+                return;\n+            };\n+            \"\"\")\n+    void test12(int i) {\n+        new V(i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : NewTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : NewTest$V = new %3 %4 @\"func<NewTest$V, int, int[]>\" @new.varargs=\"true\";\n+                return;\n+            };\n+            \"\"\")\n+    void test13(int i) {\n+        new V(i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : NewTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : NewTest$V = new %3 %4 %5 @\"func<NewTest$V, int, int[]>\" @new.varargs=\"true\";\n+                return;\n+            };\n+            \"\"\")\n+    void test14(int i) {\n+        new V(i, i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : NewTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int[] = constant @null;\n+                %5 : NewTest$V = new %3 %4 @\"func<NewTest$V, int, int[]>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test15(int i) {\n+        new V(i, null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test16\" (%0 : NewTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"2\";\n+                %5 : int[] = new %4 @\"func<int[], int>\";\n+                %6 : int = var.load %2;\n+                %7 : int = constant @\"0\";\n+                array.store %5 %7 %6;\n+                %8 : int = var.load %2;\n+                %9 : int = constant @\"1\";\n+                array.store %5 %9 %8;\n+                %10 : NewTest$V = new %3 %5 @\"func<NewTest$V, int, int[]>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test16(int i) {\n+        new V(i, new int[] { i, i});\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-                %2 : NullTest$Box = new %1 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\";\n+                %2 : NullTest$Box = new %1 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\" @new.varargs=\"true\";\n@@ -518,1 +518,1 @@\n-                %4 : NullTest$Box = new %1 %2 %3 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\";\n+                %4 : NullTest$Box = new %1 %2 %3 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\" @new.varargs=\"true\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/NullTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}