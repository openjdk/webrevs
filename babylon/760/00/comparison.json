{"files":[{"patch":"@@ -32,1 +32,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n@@ -34,0 +34,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -446,1 +447,1 @@\n-                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(buffer);\n+                    BoundSchema<?> boundSchema = MappableIface.getBoundSchema(buffer);\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import hat.ifacemapper.Buffer;\n@@ -42,0 +43,2 @@\n+import hat.ifacemapper.BufferTracker;\n+import hat.ifacemapper.MappableIface;\n@@ -49,1 +52,0 @@\n-import java.lang.reflect.Method;\n@@ -209,1 +211,1 @@\n-                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(ifaceBuffer);\n+                    BoundSchema<?> boundSchema = MappableIface.getBoundSchema(ifaceBuffer);\n@@ -330,1 +332,1 @@\n-    public void preMutate(Buffer b) {\n+    public void preMutate(MappableIface b) {\n@@ -358,1 +360,1 @@\n-    public void postMutate(Buffer b) {\n+    public void postMutate(MappableIface b) {\n@@ -371,1 +373,1 @@\n-    public void preAccess(Buffer b) {\n+    public void preAccess(MappableIface b) {\n@@ -401,1 +403,1 @@\n-    public void postAccess(Buffer b) {\n+    public void postAccess(MappableIface b) {\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n@@ -59,1 +59,1 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n+    public <T extends MappableIface> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.MappableIface;\n@@ -65,1 +65,1 @@\n-                    this.ndrange_MPtr.invoke(handle, Buffer.getMemorySegment(argArray));\n+                    this.ndrange_MPtr.invoke(handle, MappableIface.getMemorySegment(argArray));\n@@ -144,2 +144,2 @@\n-        public Buffer getBufferFromDeviceIfDirty(Buffer buffer) {\n-            MemorySegment memorySegment = Buffer.getMemorySegment(buffer);\n+        public MappableIface getBufferFromDeviceIfDirty(MappableIface buffer) {\n+            MemorySegment memorySegment = MappableIface.getMemorySegment(buffer);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackendDriver.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n@@ -37,0 +37,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -86,1 +87,1 @@\n-                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(ifaceBuffer);\n+                    BoundSchema<?> boundSchema = MappableIface.getBoundSchema(ifaceBuffer);\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n@@ -54,1 +54,1 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n+    public <T extends MappableIface> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.buffer.Buffer;\n@@ -34,5 +33,0 @@\n-import java.lang.invoke.MethodHandle;\n-\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackendDriver.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n-import hat.buffer.BufferTracker;\n+\n+import hat.ifacemapper.BufferAllocator;\n+import hat.ifacemapper.BufferTracker;\n@@ -33,0 +33,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -112,1 +113,1 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundShema) {\n+    public <T extends MappableIface> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundShema) {\n@@ -117,1 +118,1 @@\n-    public void preMutate(Buffer b) {\n+    public void preMutate(MappableIface b) {\n@@ -124,1 +125,1 @@\n-    public void postMutate(Buffer b) {\n+    public void postMutate(MappableIface b) {\n@@ -131,1 +132,1 @@\n-    public void preAccess(Buffer b) {\n+    public void preAccess(MappableIface b) {\n@@ -138,1 +139,1 @@\n-    public void postAccess(Buffer b) {\n+    public void postAccess(MappableIface b) {\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n-import hat.buffer.BufferTracker;\n+import hat.ifacemapper.BufferAllocator;\n+import hat.ifacemapper.BufferTracker;\n@@ -33,0 +32,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -72,2 +72,2 @@\n-            this.pre = MethodRef.method(ComputeContext.class, \"pre\" + name, void.class, Buffer.class);\n-            this.post = MethodRef.method(ComputeContext.class, \"post\" + name, void.class, Buffer.class);\n+            this.pre = MethodRef.method(ComputeContext.class, \"pre\" + name, void.class, MappableIface.class);\n+            this.post = MethodRef.method(ComputeContext.class, \"post\" + name, void.class, MappableIface.class);\n@@ -142,1 +142,1 @@\n-    public void preMutate(Buffer b) {\n+    public void preMutate(MappableIface b) {\n@@ -149,1 +149,1 @@\n-    public void postMutate(Buffer b) {\n+    public void postMutate(MappableIface b) {\n@@ -157,1 +157,1 @@\n-    public void preAccess(Buffer b) {\n+    public void preAccess(MappableIface b) {\n@@ -165,1 +165,1 @@\n-    public void postAccess(Buffer b) {\n+    public void postAccess(MappableIface b) {\n@@ -172,1 +172,1 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n+    public <T extends MappableIface> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import hat.buffer.BufferAllocator;\n+import hat.ifacemapper.BufferAllocator;\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/Backend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.buffer.Buffer;\n@@ -34,0 +33,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -74,1 +74,1 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n+    public <T extends MappableIface> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/BackendAdaptor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.buffer.Buffer;\n@@ -33,0 +32,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -44,1 +44,1 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema){\n+    public <T extends MappableIface> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema){\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/java\/JavaBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import hat.ifacemapper.Buffer;\n+import hat.ifacemapper.MappableIface;\n@@ -31,0 +33,1 @@\n+import hat.ifacemapper.SchemaBuilder;\n@@ -270,1 +273,1 @@\n-                case Buffer buffer -> \"(?:\" +SchemaBuilder.schema(buffer)+\")\";\n+                case Buffer buffer -> \"(?:\" + SchemaBuilder.schema(buffer)+\")\";\n@@ -320,1 +323,1 @@\n-                    MemorySegment segment = Buffer.getMemorySegment(buffer);\n+                    MemorySegment segment = MappableIface.getMemorySegment(buffer);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/BF16Array.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-\n-import hat.ifacemapper.BoundSchema;\n-import hat.ifacemapper.BufferState;\n-import hat.ifacemapper.MappableIface;\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.reflect.InvocationTargetException;\n-\n-import static hat.ifacemapper.MapperUtil.SECRET_BOUND_SCHEMA_METHOD_NAME;\n-import static hat.ifacemapper.MapperUtil.SECRET_LAYOUT_METHOD_NAME;\n-import static hat.ifacemapper.MapperUtil.SECRET_OFFSET_METHOD_NAME;\n-import static hat.ifacemapper.MapperUtil.SECRET_SEGMENT_METHOD_NAME;\n-\n-public interface Buffer extends MappableIface {\n-\n-    default int getState(){\n-        return BufferState.of(this).getState();\n-    }\n-    default void setState(int newState ){\n-         BufferState.of(this).setState(newState);\n-    }\n-\n-    default String getStateString(){\n-        return BufferState.of(this).getStateString();\n-    }\n-\n-    interface Union extends MappableIface {\n-    }\n-\n-    interface Struct extends MappableIface {\n-    }\n-\n-    static <T extends Buffer> MemorySegment getMemorySegment(T buffer) {\n-       try {\n-            return (MemorySegment) buffer.getClass().getDeclaredMethod(SECRET_SEGMENT_METHOD_NAME).invoke(buffer);\n-        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static <T extends Buffer> BoundSchema<?> getBoundSchema(T buffer) {\n-        try {\n-            return (BoundSchema<?>) buffer.getClass().getDeclaredMethod(SECRET_BOUND_SCHEMA_METHOD_NAME).invoke(buffer);\n-        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static <T extends Buffer> MemoryLayout getLayout(T buffer) {\n-        try {\n-            return (MemoryLayout) buffer.getClass().getDeclaredMethod(SECRET_LAYOUT_METHOD_NAME).invoke(buffer);\n-        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static <T extends Buffer> long getOffset(T buffer) {\n-        try {\n-            return (long) buffer.getClass().getDeclaredMethod(SECRET_OFFSET_METHOD_NAME).invoke(buffer);\n-        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import hat.ifacemapper.BoundSchema;\n-import hat.ifacemapper.SegmentMapper;\n-\n-public interface BufferAllocator {\n-    <T extends Buffer>T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> buffer);\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/BufferAllocator.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-public interface BufferTracker {\n-\n-     void preMutate(Buffer b);\n-\n-     void postMutate(Buffer b) ;\n-\n-     void preAccess(Buffer b);\n-\n-     void postAccess(Buffer b);\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/BufferTracker.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F16Array.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import hat.ifacemapper.Buffer;\n+import hat.ifacemapper.MappableIface;\n@@ -51,1 +53,1 @@\n-        MemorySegment.copy(floats, 0, Buffer.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, length());\n+        MemorySegment.copy(floats, 0, MappableIface.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, length());\n@@ -60,1 +62,1 @@\n-        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, floats, 0, length());\n+        MemorySegment.copy(MappableIface.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, floats, 0, length());\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import hat.ifacemapper.Buffer;\n+import hat.ifacemapper.MappableIface;\n@@ -50,1 +52,1 @@\n-        MemorySegment.copy(floats, 0, Buffer.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, length());\n+        MemorySegment.copy(floats, 0, MappableIface.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, length());\n@@ -59,1 +61,1 @@\n-        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, floats, 0, length());\n+        MemorySegment.copy(MappableIface.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, floats, 0, length());\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32ArrayPadded.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import hat.ifacemapper.Buffer;\n+import hat.ifacemapper.MappableIface;\n+\n@@ -43,1 +46,1 @@\n-                    MemorySegment.copy(arr.getData(), 0, Buffer.getMemorySegment(this), JAVA_INT, 16L, arr.getData().length);\n+                    MemorySegment.copy(arr.getData(), 0, MappableIface.getMemorySegment(this), JAVA_INT, 16L, arr.getData().length);\n@@ -45,1 +48,1 @@\n-                    MemorySegment.copy(arr.getData(), 0, Buffer.getMemorySegment(this), JAVA_BYTE, 16L, arr.getData().length);\n+                    MemorySegment.copy(arr.getData(), 0, MappableIface.getMemorySegment(this), JAVA_BYTE, 16L, arr.getData().length);\n@@ -47,1 +50,1 @@\n-                    MemorySegment.copy(arr.getData(), 0, Buffer.getMemorySegment(this), JAVA_SHORT, 16L, arr.getData().length);\n+                    MemorySegment.copy(arr.getData(), 0, MappableIface.getMemorySegment(this), JAVA_SHORT, 16L, arr.getData().length);\n@@ -61,1 +64,1 @@\n-                    MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_SHORT, 16L, arr.getData(), 0, arr.getData().length);\n+                    MemorySegment.copy(MappableIface.getMemorySegment(this), JAVA_SHORT, 16L, arr.getData(), 0, arr.getData().length);\n@@ -63,1 +66,1 @@\n-                    MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, 16L, arr.getData(), 0, arr.getData().length);\n+                    MemorySegment.copy(MappableIface.getMemorySegment(this), JAVA_INT, 16L, arr.getData(), 0, arr.getData().length);\n@@ -65,1 +68,1 @@\n-                    MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_BYTE, 16L, arr.getData(), 0, arr.getData().length);\n+                    MemorySegment.copy(MappableIface.getMemorySegment(this), JAVA_BYTE, 16L, arr.getData(), 0, arr.getData().length);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ImageIfaceBuffer.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelBufferContext.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import hat.ifacemapper.Buffer;\n+import hat.ifacemapper.MappableIface;\n@@ -54,1 +56,1 @@\n-        MemorySegment.copy(ints, 0, Buffer.getMemorySegment(this), JAVA_INT, HEADER_BYTES, length());\n+        MemorySegment.copy(ints, 0, MappableIface.getMemorySegment(this), JAVA_INT, HEADER_BYTES, length());\n@@ -58,1 +60,1 @@\n-        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, HEADER_BYTES, ints, 0, length());\n+        MemorySegment.copy(MappableIface.getMemorySegment(this), JAVA_INT, HEADER_BYTES, ints, 0, length());\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import hat.ifacemapper.Buffer;\n+import hat.ifacemapper.MappableIface;\n@@ -59,1 +61,1 @@\n-        MemorySegment.copy(ints, 0, Buffer.getMemorySegment(this), JAVA_INT, 2* JAVA_INT.byteSize(), width()*height());\n+        MemorySegment.copy(ints, 0, MappableIface.getMemorySegment(this), JAVA_INT, 2* JAVA_INT.byteSize(), width()*height());\n@@ -63,1 +65,1 @@\n-        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, 2* JAVA_INT.byteSize(),  ints, 0, width()*height());\n+        MemorySegment.copy(MappableIface.getMemorySegment(this), JAVA_INT, 2* JAVA_INT.byteSize(),  ints, 0, width()*height());\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array2D.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n@@ -33,1 +33,0 @@\n-import jdk.incubator.code.dialect.core.VarType;\n@@ -36,1 +35,0 @@\n-import java.lang.invoke.MethodHandles;\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-\/\/import jdk.internal.vm.annotation.Stable;\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/AbstractSegmentMapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n@@ -40,1 +38,1 @@\n-public class BoundSchema<T extends Buffer> {\n+public class BoundSchema<T extends MappableIface> {\n@@ -111,1 +109,1 @@\n-        this.rootBoundSchemaNode = new BoundSchemaNode<>((BoundSchema<Buffer>) this, null, this.schema.rootIfaceType);\n+        this.rootBoundSchemaNode = new BoundSchemaNode<>((BoundSchema) this, null, this.schema.rootIfaceType);\n@@ -158,1 +156,1 @@\n-        final public  BoundSchema<Buffer> boundSchema;\n+        final public  BoundSchema<T> boundSchema;\n@@ -165,1 +163,1 @@\n-        BoundSchemaNode(BoundSchema<Buffer> boundSchema, BoundSchemaNode<T> parent, Schema.IfaceType ifaceType) {\n+        BoundSchemaNode(BoundSchema<T> boundSchema, BoundSchemaNode<T> parent, Schema.IfaceType ifaceType) {\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/BoundSchema.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,2 +25,4 @@\n-package optkl.textmodel.tokens;\n-public interface Comment extends Leaf {\n+package hat.ifacemapper;\n+\n+\n+public interface Buffer extends MappableIface {\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/Buffer.java","additions":4,"deletions":2,"binary":false,"changes":6,"previous_filename":"hat\/optkl\/src\/main\/java\/optkl\/textmodel\/tokens\/Comment.java","status":"copied"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.ifacemapper;\n+\n+public interface BufferAllocator {\n+    <T extends MappableIface>T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> buffer);\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/BufferAllocator.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.buffer.Buffer;\n+\n@@ -120,2 +120,2 @@\n-        Buffer buffer = (Buffer) Objects.requireNonNull(t);\n-        MemorySegment s = Buffer.getMemorySegment(buffer);\n+        MappableIface buffer = (MappableIface) Objects.requireNonNull(t);\n+        MemorySegment s = MappableIface.getMemorySegment(buffer);\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/BufferState.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.ifacemapper;\n+\n+public interface BufferTracker {\n+\n+     void preMutate(MappableIface b);\n+\n+     void postMutate(MappableIface b) ;\n+\n+     void preAccess(MappableIface b);\n+\n+     void postAccess(MappableIface b);\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/BufferTracker.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -31,2 +31,0 @@\n-\/\/import jdk.internal.ValueBased;\n-\/\/import jdk.internal.ValueBased;\n@@ -34,2 +32,0 @@\n-\n-import java.lang.classfile.Annotation;\n@@ -39,1 +35,0 @@\n-import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -80,1 +75,0 @@\n-\n@@ -91,1 +85,0 @@\n-\n@@ -105,3 +98,0 @@\n-        \/\/ @ValueBased\n-       \/\/ Annotation valueBased = Annotation.of(desc(ValueBased.class));\n-        \/\/cb.with(RuntimeVisibleAnnotationsAttribute.of(valueBased));\n@@ -256,14 +246,0 @@\n-\n-        \/*\n-        Was\n-        public ArgList.Arg args(long var1) {\n-            return (ArgList.Arg)((MethodHandle)\"_\").invokeExact(this.segment, this.offset + 8L + Objects.checkIndex(var1, 4L) * 4L);\n-        }\n-        Now\n-        public ArgList.Arg args(long var1) {\n-            MethodHandle var10000 = (MethodHandle)\"_\";\n-            return (ArgList.Arg)this.segment.invokeExact((MethodHandle)\"_\", this.layout, this.offset + 8L + Objects.checkIndex(var1, 4L) * 4L);\n-        }\n-\n-         *\/\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/ByteCodeGenerator.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,8 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import static hat.ifacemapper.MapperUtil.SECRET_BOUND_SCHEMA_METHOD_NAME;\n+import static hat.ifacemapper.MapperUtil.SECRET_LAYOUT_METHOD_NAME;\n+import static hat.ifacemapper.MapperUtil.SECRET_OFFSET_METHOD_NAME;\n+import static hat.ifacemapper.MapperUtil.SECRET_SEGMENT_METHOD_NAME;\n@@ -42,0 +50,50 @@\n+\n+    interface Union extends MappableIface {\n+    }\n+\n+    interface Struct extends MappableIface {\n+    }\n+\n+\n+    default int getState(){\n+        return BufferState.of(this).getState();\n+    }\n+    default void setState(int newState ){\n+        BufferState.of(this).setState(newState);\n+    }\n+\n+    default String getStateString(){\n+        return BufferState.of(this).getStateString();\n+    }\n+\n+    static <T extends MappableIface> MemorySegment getMemorySegment(T buffer) {\n+        try {\n+            return (MemorySegment) buffer.getClass().getDeclaredMethod(SECRET_SEGMENT_METHOD_NAME).invoke(buffer);\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static <T extends Buffer> BoundSchema<?> getBoundSchema(T buffer) {\n+        try {\n+            return (BoundSchema<?>) buffer.getClass().getDeclaredMethod(SECRET_BOUND_SCHEMA_METHOD_NAME).invoke(buffer);\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static <T extends Buffer> MemoryLayout getLayout(T buffer) {\n+        try {\n+            return (MemoryLayout) buffer.getClass().getDeclaredMethod(SECRET_LAYOUT_METHOD_NAME).invoke(buffer);\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static <T extends Buffer> long getOffset(T buffer) {\n+        try {\n+            return (long) buffer.getClass().getDeclaredMethod(SECRET_OFFSET_METHOD_NAME).invoke(buffer);\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/MappableIface.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-\/\/import jdk.internal.ValueBased;\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/MapperCache.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.buffer.Buffer;\n+\n@@ -185,1 +185,1 @@\n-        return  Buffer.class.isAssignableFrom(clazz);\n+        return  MappableIface.class.isAssignableFrom(clazz);\n@@ -189,1 +189,1 @@\n-        return  Buffer.Struct.class.isAssignableFrom(clazz);\n+        return  MappableIface.Struct.class.isAssignableFrom(clazz);\n@@ -200,1 +200,1 @@\n-        return  Buffer.Union.class.isAssignableFrom(clazz);\n+        return  MappableIface.Union.class.isAssignableFrom(clazz);\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/MapperUtil.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.buffer.Buffer;\n@@ -47,1 +46,1 @@\n-public class Schema<T extends Buffer> {\n+public class Schema<T extends MappableIface> {\n@@ -101,1 +100,1 @@\n-        MemorySegment memorySegment = Buffer.getMemorySegment(instance);\n+        MemorySegment memorySegment = MappableIface.getMemorySegment(instance);\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.buffer;\n+package hat.ifacemapper;\n@@ -27,0 +27,1 @@\n+import hat.buffer.ArgArray;\n@@ -65,2 +66,2 @@\n-            return new SchemaBuilder().literal(Buffer.getMemorySegment(buffer).byteSize())\n-                    .hash().layout(Buffer.getLayout(buffer)).toString();\n+            return new SchemaBuilder().literal(MappableIface.getMemorySegment(buffer).byteSize())\n+                    .hash().layout(MappableIface.getLayout(buffer)).toString();\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/SchemaBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"previous_filename":"hat\/core\/src\/main\/java\/hat\/buffer\/SchemaBuilder.java","status":"renamed"},{"patch":"@@ -33,1 +33,0 @@\n-\/\/import jdk.internal.vm.annotation.Stable;\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/SegmentInterfaceMapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.buffer.Buffer;\n+\n@@ -704,1 +704,1 @@\n-    static <T extends Buffer> SegmentMapper<T> of(MethodHandles.Lookup lookup, Class<T> type, GroupLayout layout, BoundSchema<?> boundSchema) {\n+    static <T extends MappableIface> SegmentMapper<T> of(MethodHandles.Lookup lookup, Class<T> type, GroupLayout layout, BoundSchema<?> boundSchema) {\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+    public static final MethodType SET_TYPE = MethodType.methodType(void.class,\n+            MemorySegment.class, long.class, Object.class);\n@@ -52,1 +54,0 @@\n-    static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n@@ -54,1 +55,3 @@\n-    public static final MethodType GET_TYPE = MethodType.methodType(Object.class,\n+    static private final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    static private final MethodType GET_TYPE = MethodType.methodType(Object.class,\n@@ -56,2 +59,0 @@\n-    public static final MethodType SET_TYPE = MethodType.methodType(void.class,\n-            MemorySegment.class, long.class, Object.class);\n@@ -60,1 +61,1 @@\n-    static final MethodHandle SUM_LONG;\n+    static private final MethodHandle SUM_LONG;\n@@ -62,1 +63,1 @@\n-    public static final MethodHandle SET_NO_OP = MethodHandles.empty(SET_TYPE);\n+    static private final MethodHandle SET_NO_OP = MethodHandles.empty(SET_TYPE);\n@@ -66,1 +67,1 @@\n-    public static final MethodHandle LIST_OF;\n+     static private final MethodHandle LIST_OF;\n@@ -70,1 +71,1 @@\n-    public static final MethodHandle SET_AS_COPY_OF_LIST;\n+    static public final MethodHandle SET_AS_COPY_OF_LIST;\n@@ -74,1 +75,1 @@\n-    public static final MethodHandle LIST_AS_COPY_OF_SET;\n+    static public final MethodHandle LIST_AS_COPY_OF_SET;\n@@ -78,1 +79,1 @@\n-    public static final MethodHandle REQUIRE_ARRAY_LENGTH;\n+    static public final MethodHandle REQUIRE_ARRAY_LENGTH;\n@@ -134,2 +135,1 @@\n-        return (int) Stream.<Class<?>>iterate(arrayClass, Class::isArray, Class::componentType)\n-                .count();\n+        return (int) Stream.<Class<?>>iterate(arrayClass, Class::isArray, Class::componentType).count();\n@@ -213,1 +213,1 @@\n-    public static MethodHandle findStaticListToArray(MethodType methodType) throws NoSuchMethodException, IllegalAccessException {\n+    static public MethodHandle findStaticListToArray(MethodType methodType) throws NoSuchMethodException, IllegalAccessException {\n@@ -217,1 +217,1 @@\n-    public static MethodHandle findStaticArrayToList(MethodType methodType) throws NoSuchMethodException, IllegalAccessException {\n+    static public MethodHandle findStaticArrayToList(MethodType methodType) throws NoSuchMethodException, IllegalAccessException {\n@@ -221,0 +221,53 @@\n+    static private MemorySegment slice(MemorySegment segment,\n+                                       MemoryLayout elementLayout,\n+                                       long offset,\n+                                       long count) {\n+\n+        return segment.asSlice(offset, elementLayout.byteSize() * count);\n+    }\n+\n+    static public Class<?> firstGenericType(RecordComponent rc) {\n+        Type genericType = rc.getGenericType();\n+        if (genericType instanceof ParameterizedType parameterizedType) {\n+            Type firstGenericParameter = parameterizedType.getActualTypeArguments()[0];\n+            if (firstGenericParameter instanceof Class<?> c) {\n+                return c;\n+            }\n+            throw new IllegalArgumentException(\"Type is not a Class \" + firstGenericParameter);\n+        }\n+        throw new IllegalArgumentException(\"Unable to determine the generic type of \" + rc);\n+    }\n+\n+    static void assertSequenceLayoutValid(SequenceLayout sl) {\n+        if (sl.elementLayout() instanceof SequenceLayout) {\n+            \/\/ We only support single dimension arrays\n+            throw new IllegalArgumentException(\"A sequence layout can not have an element layout that is\" +\n+                    \"also a sequence layout \" + sl);\n+        }\n+\n+        if (sl.elementCount() > Integer.MAX_VALUE - 8) {\n+            throw new IllegalArgumentException(\"Unable to map'\" + sl +\n+                    \"' because the element count is too big \" + sl.elementCount());\n+        }\n+\n+        if (sl.elementLayout() instanceof ValueLayout.OfBoolean) {\n+            throw new IllegalArgumentException(\"Arrays of booleans (\" + sl.elementLayout() + \") are not supported\");\n+        }\n+    }\n+\n+    static public Class<?> baseComponentType(Class<?> type) {\n+        Class<?> componentType = type.componentType();\n+        if (componentType == null) {\n+            return type;\n+        }\n+        return baseComponentType(componentType);\n+    }\n+\n+    static public Object requireArrayLength(Object array, int expected) {\n+        int actual = Array.getLength(array);\n+        if (actual != expected) {\n+            throw new IllegalArgumentException(\n+                    \"Expected an array length of \" + expected + \" but it was actually \" + actual);\n+        }\n+        return array;\n+    }\n@@ -222,1 +275,0 @@\n-    \/\/ Begin: Reflectively used methods\n@@ -224,1 +276,1 @@\n-    \/\/ Get operations\n+    \/\/ BEWARE the methods below are accessed reflectively so if IDE indicates they are unused.  They are not!\n@@ -295,1 +347,1 @@\n-    private static byte[] listToArray(ValueLayout.OfByte layout,\n+    static private byte[] listToArray(ValueLayout.OfByte layout,\n@@ -305,1 +357,1 @@\n-    private static short[] listToArray(ValueLayout.OfShort layout,\n+    static private short[] listToArray(ValueLayout.OfShort layout,\n@@ -315,1 +367,1 @@\n-    private static char[] listToArray(ValueLayout.OfChar layout,\n+    static private char[] listToArray(ValueLayout.OfChar layout,\n@@ -325,1 +377,1 @@\n-    private static int[] listToArray(ValueLayout.OfInt layout,\n+    static private int[] listToArray(ValueLayout.OfInt layout,\n@@ -335,1 +387,1 @@\n-    private static float[] listToArray(ValueLayout.OfFloat layout,\n+    static private float[] listToArray(ValueLayout.OfFloat layout,\n@@ -345,1 +397,1 @@\n-    private static long[] listToArray(ValueLayout.OfLong layout,\n+    static private long[] listToArray(ValueLayout.OfLong layout,\n@@ -355,1 +407,1 @@\n-    private static double[] listToArray(ValueLayout.OfDouble layout,\n+    static private double[] listToArray(ValueLayout.OfDouble layout,\n@@ -365,3 +417,1 @@\n-    \/\/ Extract a List from an array.\n-\n-    private static List<Byte> arrayToList(ValueLayout.OfByte layout,\n+    static private List<Byte> arrayToList(ValueLayout.OfByte layout,\n@@ -377,1 +427,1 @@\n-    private static List<Short> arrayToList(ValueLayout.OfShort layout,\n+    static private List<Short> arrayToList(ValueLayout.OfShort layout,\n@@ -387,1 +437,1 @@\n-    private static List<Character> arrayToList(ValueLayout.OfChar layout,\n+    static private List<Character> arrayToList(ValueLayout.OfChar layout,\n@@ -397,1 +447,1 @@\n-    private static List<Integer> arrayToList(ValueLayout.OfInt layout,\n+    static private List<Integer> arrayToList(ValueLayout.OfInt layout,\n@@ -407,1 +457,1 @@\n-    private static List<Float> arrayToList(ValueLayout.OfFloat layout,\n+    static private List<Float> arrayToList(ValueLayout.OfFloat layout,\n@@ -417,1 +467,1 @@\n-    private static List<Long> arrayToList(ValueLayout.OfLong layout,\n+    static private List<Long> arrayToList(ValueLayout.OfLong layout,\n@@ -427,1 +477,1 @@\n-    private static List<Double> arrayToList(ValueLayout.OfDouble layout,\n+    static private List<Double> arrayToList(ValueLayout.OfDouble layout,\n@@ -437,1 +487,1 @@\n-    private static List<?> arrayToList(Object[] in) {\n+    static private List<?> arrayToList(Object[] in) {\n@@ -441,1 +491,1 @@\n-    private static <T> Collection<T> listAsCollection(List<T> list) {\n+    static private <T> Collection<T> listAsCollection(List<T> list) {\n@@ -445,1 +495,1 @@\n-    private static <T> Collection<T> setAsCollection(Set<T> set) {\n+    static private <T> Collection<T> setAsCollection(Set<T> set) {\n@@ -451,53 +501,0 @@\n-    private static MemorySegment slice(MemorySegment segment,\n-                                       MemoryLayout elementLayout,\n-                                       long offset,\n-                                       long count) {\n-\n-        return segment.asSlice(offset, elementLayout.byteSize() * count);\n-    }\n-\n-    public static Class<?> firstGenericType(RecordComponent rc) {\n-        Type genericType = rc.getGenericType();\n-        if (genericType instanceof ParameterizedType parameterizedType) {\n-            Type firstGenericParameter = parameterizedType.getActualTypeArguments()[0];\n-            if (firstGenericParameter instanceof Class<?> c) {\n-                return c;\n-            }\n-            throw new IllegalArgumentException(\"Type is not a Class \" + firstGenericParameter);\n-        }\n-        throw new IllegalArgumentException(\"Unable to determine the generic type of \" + rc);\n-    }\n-\n-    static void assertSequenceLayoutValid(SequenceLayout sl) {\n-        if (sl.elementLayout() instanceof SequenceLayout) {\n-            \/\/ We only support single dimension arrays\n-            throw new IllegalArgumentException(\"A sequence layout can not have an element layout that is\" +\n-                    \"also a sequence layout \" + sl);\n-        }\n-\n-        if (sl.elementCount() > Integer.MAX_VALUE - 8) {\n-            throw new IllegalArgumentException(\"Unable to map'\" + sl +\n-                    \"' because the element count is too big \" + sl.elementCount());\n-        }\n-\n-        if (sl.elementLayout() instanceof ValueLayout.OfBoolean) {\n-            throw new IllegalArgumentException(\"Arrays of booleans (\" + sl.elementLayout() + \") are not supported\");\n-        }\n-    }\n-\n-    public static Class<?> baseComponentType(Class<?> type) {\n-        Class<?> componentType = type.componentType();\n-        if (componentType == null) {\n-            return type;\n-        }\n-        return baseComponentType(componentType);\n-    }\n-\n-    public static Object requireArrayLength(Object array, int expected) {\n-        int actual = Array.getLength(array);\n-        if (actual != expected) {\n-            throw new IllegalArgumentException(\n-                    \"Expected an array length of \" + expected + \" but it was actually \" + actual);\n-        }\n-        return array;\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/component\/Util.java","additions":85,"deletions":88,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n@@ -40,1 +40,0 @@\n-import jdk.incubator.code.analysis.SSA;\n@@ -42,1 +41,0 @@\n-import jdk.incubator.code.extern.OpFactory;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LocalArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -35,1 +36,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n@@ -147,2 +148,2 @@\n-        String layoutNew = Buffer.getLayout(meshDataNew).toString();\n-        String layoutOld = Buffer.getLayout(meshDataOld).toString();\n+        String layoutNew = MappableIface.getLayout(meshDataNew).toString();\n+        String layoutOld = MappableIface.getLayout(meshDataOld).toString();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Reduction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n+import hat.ifacemapper.Buffer;\n@@ -32,2 +31,0 @@\n-import hat.ifacemapper.BoundSchema;\n-import hat.ifacemapper.SegmentMapper;\n@@ -35,1 +32,0 @@\n-import java.lang.foreign.Arena;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S08x3ImageTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n+import hat.ifacemapper.MappableIface;\n@@ -43,1 +44,1 @@\n-        GroupLayout groupLayout = (GroupLayout) Buffer.getLayout(s32Array2D);\n+        GroupLayout groupLayout = (GroupLayout) MappableIface.getLayout(s32Array2D);\n@@ -45,1 +46,1 @@\n-        BoundSchema<?> boundSchema = Buffer.getBoundSchema(s32Array2D);\n+        BoundSchema<?> boundSchema = MappableIface.getBoundSchema(s32Array2D);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32ArrayTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import hat.buffer.SchemaBuilder;\n+import hat.ifacemapper.SchemaBuilder;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/MatrixMultiply.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Box.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/XYRGBList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n+import hat.ifacemapper.MappableIface;\n@@ -81,1 +82,1 @@\n-            MemorySegment.copy(Buffer.getMemorySegment(this), valueLayout, offset, bytes, 0, width() * height());\n+            MemorySegment.copy(MappableIface.getMemorySegment(this), valueLayout, offset, bytes, 0, width() * height());\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.buffer.Buffer;\n@@ -29,0 +28,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -124,2 +124,2 @@\n-            long offset = Buffer.getLayout(s32Array2D).byteOffset(MemoryLayout.PathElement.groupElement(\"array\"));\n-            MemorySegment.copy(Buffer.getMemorySegment(s32Array2D), JAVA_INT, offset, ((DataBufferInt) image.getRaster().getDataBuffer()).getData(), 0, s32Array2D.width()*s32Array2D.height());\n+            long offset = MappableIface.getLayout(s32Array2D).byteOffset(MemoryLayout.PathElement.groupElement(\"array\"));\n+            MemorySegment.copy(MappableIface.getMemorySegment(s32Array2D), JAVA_INT, offset, ((DataBufferInt) image.getRaster().getDataBuffer()).getData(), 0, s32Array2D.width()*s32Array2D.height());\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/Viewer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Universe.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/Cascade.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n+import hat.ifacemapper.Buffer;\n@@ -32,2 +31,0 @@\n-import java.lang.invoke.MethodHandles;\n-\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ResultTable.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n+import hat.ifacemapper.Buffer;\n@@ -33,2 +32,0 @@\n-import java.lang.invoke.MethodHandles;\n-\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ScaleTable.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-                    Stream.of(\"hat\", \"core\", \"tools\", \"examples\", \"backends\", \"docs\", \"wraps\")\n+                    Stream.of(\"hat\", \"optkl\", \"core\", \"tools\", \"examples\", \"backends\", \"docs\", \"wraps\")\n","filename":"hat\/hat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrayView.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestNbody.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.Buffer;\n@@ -29,0 +29,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -249,1 +250,1 @@\n-                                MemorySegment memorySegment = Buffer.getMemorySegment(buffer);\n+                                MemorySegment memorySegment = MappableIface.getMemorySegment(buffer);\n@@ -347,1 +348,1 @@\n-                                MemorySegment memorySegment = Buffer.getMemorySegment(buffer);\n+                                MemorySegment memorySegment = MappableIface.getMemorySegment(buffer);\n","filename":"hat\/wraps\/opencl\/src\/main\/java\/wrap\/opencl\/CLPlatform.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}