{"files":[{"patch":"@@ -453,3 +453,1 @@\n-        StringWriter w = new StringWriter();\n-        writeTo(w);\n-        return w.toString();\n+        return OpWriter.toText(this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Op.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.StringWriter;\n@@ -176,30 +177,4 @@\n-    public static Map<CodeItem, String> computeGlobalNames(Op root) {\n-        GlobalValueBlockNaming gn = root.traverse(new GlobalValueBlockNaming(), (n, e) -> {\n-            switch (e) {\n-                case Op op -> {\n-                    for (Block.Reference r : op.successors()) {\n-                        n.apply(r.targetBlock());\n-                    }\n-\n-                    if (root != op) {\n-                        Op.Result opr = op.result();\n-                        if (!opr.type().equals(JavaType.VOID)) {\n-                            n.apply(opr);\n-                        }\n-                    }\n-                }\n-                case Block block -> {\n-                    if (!block.isEntryBlock()) {\n-                        n.apply(block);\n-                    }\n-                    for (Block.Parameter p : block.parameters()) {\n-                        n.apply(p);\n-                    }\n-                }\n-                default -> {\n-                }\n-            }\n-            return n;\n-        });\n-\n-        return gn.gn;\n+    public static Function<CodeItem, String> computeGlobalNames(Op root) {\n+        OpWriter w = new OpWriter(Writer.nullWriter());\n+        w.writeOp(root);\n+        return w.namer();\n@@ -211,2 +186,1 @@\n-     * A carriage return will be written after the model is writen, and\n-     * then character stream will be flushed.\n+     * The character stream will be flushed after the model is writen.\n@@ -220,1 +194,0 @@\n-        ow.write(\"\\n\");\n@@ -231,2 +204,1 @@\n-     * A carriage return will be written after the model is writen, and\n-     * then character stream will be flushed.\n+     * The character stream will be flushed after the model is writen.\n@@ -241,1 +213,0 @@\n-        ow.write(\"\\n\");\n@@ -243,0 +214,1 @@\n+            \/\/ @@@ Is this needed?\n@@ -249,0 +221,23 @@\n+    \/**\n+     * Writes a code model (an operation) to a string.\n+     *\n+     * @param op the code model\n+     *\/\n+    public static String toText(Op op) {\n+        StringWriter w = new StringWriter();\n+        writeTo(w, op);\n+        return w.toString();\n+    }\n+\n+    \/**\n+     * Writes a code model (an operation) to a string.\n+     *\n+     * @param op the code model\n+     * @param options the writer options\n+     *\/\n+    public static String toText(Op op, OpWriter.Option... options) {\n+        StringWriter w = new StringWriter();\n+        writeTo(w, op, options);\n+        return w.toString();\n+    }\n+\n@@ -288,0 +283,28 @@\n+    \/**\n+     * An option describing whether an operation's descendant code elements should be written or dropped.\n+     *\/\n+    public enum OpDescendantsOption implements Option {\n+        \/** Writes descendants of an operation, if any *\/\n+        WRITE_DESCENDANTS,\n+        \/** Drops descendants of an operation, if any *\/\n+        DROP_DESCENDANTS;\n+\n+        public static OpDescendantsOption defaultValue() {\n+            return WRITE_DESCENDANTS;\n+        }\n+    }\n+\n+    \/**\n+     * An option describing whether an operation's result be written or dropped if its type is void.\n+     *\/\n+    public enum VoidOpResultOption implements Option {\n+        \/** Writes void operation result *\/\n+        WRITE_VOID,\n+        \/** Drops void operation result *\/\n+        DROP_VOID;\n+\n+        public static VoidOpResultOption defaultValue() {\n+            return DROP_VOID;\n+        }\n+    }\n+\n@@ -291,0 +314,2 @@\n+    final boolean dropOpDescendants;\n+    final boolean writeVoidOpResult;\n@@ -301,0 +326,2 @@\n+        this.dropOpDescendants = false;\n+        this.writeVoidOpResult = false;\n@@ -312,0 +339,2 @@\n+        boolean dropOpDescendants = false;\n+        boolean writeVoidOpResult = false;\n@@ -321,0 +350,7 @@\n+                case OpDescendantsOption opDescendantsOption -> {\n+                    dropOpDescendants = opDescendantsOption ==\n+                            OpDescendantsOption.DROP_DESCENDANTS;\n+                }\n+                case VoidOpResultOption voidOpResultOption -> {\n+                    writeVoidOpResult = voidOpResultOption == VoidOpResultOption.WRITE_VOID;\n+                }\n@@ -327,0 +363,2 @@\n+        this.dropOpDescendants = dropOpDescendants;\n+        this.writeVoidOpResult = writeVoidOpResult;\n@@ -342,0 +380,7 @@\n+        if (op.parent() != null) {\n+            Op.Result opr = op.result();\n+            if (writeVoidOpResult || !opr.type().equals(JavaType.VOID)) {\n+                writeValueDeclaration(opr);\n+                write(\" = \");\n+            }\n+        }\n@@ -365,1 +410,1 @@\n-        if (!op.bodies().isEmpty()) {\n+        if (!dropOpDescendants && !op.bodies().isEmpty()) {\n@@ -439,5 +484,0 @@\n-            Op.Result opr = op.result();\n-            if (!opr.type().equals(JavaType.VOID)) {\n-                writeValueDeclaration(opr);\n-                write(\" = \");\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpWriter.java","additions":82,"deletions":42,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.function.Function;\n@@ -78,6 +79,1 @@\n-        Map<CodeItem, String> cNamer = OpWriter.computeGlobalNames(op);\n-\n-        StringWriter w = new StringWriter();\n-        new OpWriter(w, OpWriter.CodeItemNamerOption.of(cNamer::get)).writeOp(op);\n-        w.write(\"\\n\");\n-        String actual = w.toString();\n+        Function<CodeItem, String> cNamer = OpWriter.computeGlobalNames(op);\n@@ -85,0 +81,1 @@\n+        String actual = OpWriter.toText(op, OpWriter.CodeItemNamerOption.of(cNamer));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestNaming.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestOptions\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestOptions {\n+\n+    @CodeReflection\n+    static int f(int n) {\n+        return n;\n+    }\n+\n+    @Test\n+    public void testDropWriteVoid() {\n+        CoreOp.FuncOp f = getFuncOp(\"f\");\n+\n+        Assert.assertFalse(OpWriter.toText(f).contains(\"void\"));\n+        Assert.assertFalse(OpWriter.toText(f, OpWriter.VoidOpResultOption.DROP_VOID).contains(\"void\"));\n+        Assert.assertTrue(OpWriter.toText(f, OpWriter.VoidOpResultOption.WRITE_VOID).contains(\"void\"));\n+    }\n+\n+    @Test\n+    public void testDropWriteDescendants() {\n+        CoreOp.FuncOp f = getFuncOp(\"f\");\n+\n+        Assert.assertTrue(OpWriter.toText(f).lines().count() > 1);\n+        Assert.assertTrue(OpWriter.toText(f, OpWriter.OpDescendantsOption.WRITE_DESCENDANTS).lines().count() > 1);\n+        Assert.assertTrue(OpWriter.toText(f, OpWriter.OpDescendantsOption.DROP_DESCENDANTS).lines().count() == 1);\n+    }\n+\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestOptions.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestOptions.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}