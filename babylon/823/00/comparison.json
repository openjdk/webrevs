{"files":[{"patch":"@@ -440,1 +440,1 @@\n-        return Trxfmr.of(funcOp).transform(_->true,(block, op) -> {\n+        return Trxfmr.of(lookup,funcOp).transform(_->true,(block, op) -> {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-It was auto generated 2026-01-06 18:19:54.731 by hat.FFIConfigCreator\n+It was auto generated 2026-01-08 12:22:32.577 by hat.FFIConfigCreator\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/include\/config.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-    public record Bit(int index, int size, String name, String description) implements Comparable<Bit> {\n-        static Bit of(int index, int size, String name, String description){\n-            return new Bit(index,size,name,description);\n+    public record Bit(int index, int size, String name, String alt, String description) implements Comparable<Bit> {\n+        static Bit of(int index, int size, String name, String alt, String description){\n+            return new Bit(index,size,name, alt, description);\n@@ -38,2 +38,2 @@\n-        public static Bit of(int index, String name, String description){\n-            return new Bit(index,1,name,description);\n+        public static Bit of(int index, String name, String alt,  String description){\n+            return new Bit(index,1,name, alt,description);\n@@ -42,2 +42,2 @@\n-        public static Bit nextBit(Bit bit, int size, String name, String description){\n-            return new Bit(bit.index+bit.size,size,name, description);\n+        public static Bit nextBit(Bit bit, int size, String name, String alt,String description){\n+            return new Bit(bit.index+bit.size,size,name, alt, description);\n@@ -45,2 +45,2 @@\n-        public static Bit nextBit(Bit bit, String name, String description){\n-            return nextBit(bit, 1,name,description);\n+        public static Bit nextBit(Bit bit, String name, String alt, String description){\n+            return nextBit(bit, 1,name,alt, description);\n@@ -68,3 +68,3 @@\n-    public static final Bit PLATFORM =  Bit.of(0,4, \"PLATFORM\", \"FFI ONLY platform id (0-15)\");\n-    public static final Bit DEVICE = Bit.nextBit(PLATFORM, 4, \"DEVICE\",\"FFI ONLY device id (0-15)\");\n-    private static final Bit MINIMIZE_COPIES =  Bit.nextBit(DEVICE, \"MINIMIZE_COPIES\",\"FFI ONLY Try to minimize copies\");\n+    public static final Bit PLATFORM =  Bit.of(0,4, \"PLATFORM\",\"P\", \"FFI ONLY platform id (0-15)\");\n+    public static final Bit DEVICE = Bit.nextBit(PLATFORM, 4, \"DEVICE\",\"D\",\"FFI ONLY device id (0-15)\");\n+    private static final Bit MINIMIZE_COPIES =  Bit.nextBit(DEVICE, \"MINIMIZE_COPIES\",\"MC\",\"FFI ONLY Try to minimize copies\");\n@@ -74,3 +74,3 @@\n-    private static final Bit TRACE = Bit.nextBit(MINIMIZE_COPIES,\"TRACE\", \"FFI ONLY trace code\");\n-    private static final Bit PROFILE = Bit.nextBit(TRACE, \"PROFILE\", \"FFI ONLY Turn on profiling\");\n-    private static final Bit SHOW_CODE = Bit.nextBit(PROFILE,\"SHOW_CODE\",\"Show generated code (PTX\/OpenCL\/CUDA)\");\n+    private static final Bit TRACE = Bit.nextBit(MINIMIZE_COPIES,\"TRACE\", \"T\",\"FFI ONLY trace code\");\n+    private static final Bit PROFILE = Bit.nextBit(TRACE, \"PROFILE\", \"P\",\"FFI ONLY Turn on profiling\");\n+    private static final Bit SHOW_CODE = Bit.nextBit(PROFILE,\"SHOW_CODE\",\"SC\",\"Show generated code (PTX\/OpenCL\/CUDA)\");\n@@ -80,1 +80,1 @@\n-    private static final Bit SHOW_KERNEL_MODEL = Bit.nextBit(SHOW_CODE,\"SHOW_KERNEL_MODEL\", \"Show (via OpWriter) Kernel Model\");\n+    private static final Bit SHOW_KERNEL_MODEL = Bit.nextBit(SHOW_CODE,\"SHOW_KERNEL_MODEL\", \"SKM\",\"Show (via OpWriter) Kernel Model\");\n@@ -84,1 +84,1 @@\n-    private static final Bit SHOW_COMPUTE_MODEL = Bit.nextBit(SHOW_KERNEL_MODEL,\"SHOW_COMPUTE_MODEL\", \"Show (via OpWriter) Compute Model\");\n+    private static final Bit SHOW_COMPUTE_MODEL = Bit.nextBit(SHOW_KERNEL_MODEL,\"SHOW_COMPUTE_MODEL\", \"SCM\",\"Show (via OpWriter) Compute Model\");\n@@ -88,10 +88,10 @@\n-    private static final Bit SHOW_DEVICE_INFO = Bit.nextBit(SHOW_COMPUTE_MODEL, \"SHOW_DEVICE_INFO\", \"FFI show platform and device info\");\n-    public static final Bit INFO = Bit.nextBit(SHOW_DEVICE_INFO, \"INFO\", \"INFO level logging\");\n-    public static final Bit WARN = Bit.nextBit(INFO, \"WARN\", \"WARN(ing) level logging \");\n-    public static final Bit UNIT = Bit.nextBit(WARN, \"UNIT\", \"UNIT test level logging  \");\n-    private static final Bit TRACE_COPIES = Bit.nextBit(UNIT, \"TRACE_COPIES\", \"FFI ONLY trace copies\");\n-    private static final Bit TRACE_SKIPPED_COPIES = Bit.nextBit(TRACE_COPIES, \"TRACE_SKIPPED_COPIES\", \"FFI ONLY Trace skipped copies (see MINIMIZE_COPIES) \");\n-    private static final Bit TRACE_ENQUEUES = Bit.nextBit(TRACE_SKIPPED_COPIES,\"TRACE_ENQUEUES\", \"FFI ONLY trace enqueued tasks\");\n-    private static final Bit TRACE_CALLS= Bit.nextBit(TRACE_ENQUEUES, \"TRACE_CALLS\", \"FFI ONLY trace calls (enter\/leave)\");\n-    private static final Bit SHOW_WHY = Bit.nextBit(TRACE_CALLS, \"SHOW_WHY\", \"FFI ONLY show why we decided to copy buffer (H to D)\");\n-    private static final Bit SHOW_STATE = Bit.nextBit(SHOW_WHY, \"SHOW_STATE\", \"Show iface buffer state changes\");\n+    private static final Bit SHOW_DEVICE_INFO = Bit.nextBit(SHOW_COMPUTE_MODEL, \"SHOW_DEVICE_INFO\", \"SDI\",\"FFI show platform and device info\");\n+    public static final Bit INFO = Bit.nextBit(SHOW_DEVICE_INFO, \"INFO\", \"I\",\"INFO level logging\");\n+    public static final Bit WARN = Bit.nextBit(INFO, \"WARN\", \"W\",\"WARN(ing) level logging \");\n+    public static final Bit UNIT = Bit.nextBit(WARN, \"UNIT\", \"U\",\"UNIT test level logging  \");\n+    private static final Bit TRACE_COPIES = Bit.nextBit(UNIT, \"TRACE_COPIES\", \"TC\",\"FFI ONLY trace copies\");\n+    private static final Bit TRACE_SKIPPED_COPIES = Bit.nextBit(TRACE_COPIES,\"TRACE_SKIPPED_COPIES\", \"TSC\",  \"FFI ONLY Trace skipped copies (see MINIMIZE_COPIES) \");\n+    private static final Bit TRACE_ENQUEUES = Bit.nextBit(TRACE_SKIPPED_COPIES,\"TRACE_ENQUEUES\",\"TE\", \"FFI ONLY trace enqueued tasks\");\n+    private static final Bit TRACE_CALLS= Bit.nextBit(TRACE_ENQUEUES, \"TRACE_CALLS\", \"TCALLS\",\"FFI ONLY trace calls (enter\/leave)\");\n+    private static final Bit SHOW_WHY = Bit.nextBit(TRACE_CALLS, \"SHOW_WHY\", \"SW\",\"FFI ONLY show why we decided to copy buffer (H to D)\");\n+    private static final Bit SHOW_STATE = Bit.nextBit(SHOW_WHY, \"SHOW_STATE\", \"SS\",\"Show iface buffer state changes\");\n@@ -99,1 +99,1 @@\n-    private static final Bit PTX = Bit.nextBit(SHOW_STATE, \"PTX\", \"FFI (NVIDIA) ONLY pass PTX rather than C99 CUDA code\");\n+    private static final Bit PTX = Bit.nextBit(SHOW_STATE, \"PTX\", \"PTX\",\"FFI (NVIDIA) ONLY pass PTX rather than C99 CUDA code\");\n@@ -101,1 +101,1 @@\n-    private static final Bit INTERPRET = Bit.nextBit(PTX, \"INTERPRET\", \"Interpret the code model rather than converting to bytecode\");\n+    private static final Bit INTERPRET = Bit.nextBit(PTX, \"INTERPRET\", \"I\",\"Interpret the code model rather than converting to bytecode\");\n@@ -105,1 +105,1 @@\n-    private static final Bit HEADLESS = Bit.nextBit(INTERPRET, \"HEADLESS\", \"Don't show UI\");\n+    private static final Bit HEADLESS = Bit.nextBit(INTERPRET, \"HEADLESS\", \"H\",\"Don't show UI\");\n@@ -112,1 +112,1 @@\n-    private static final Bit SHOW_LOWERED_KERNEL_MODEL = Bit.nextBit(HEADLESS,\"SHOW_LOWERED_KERNEL_MODEL\", \"Show (via OpWriter) Lowered Kernel Model\");\n+    private static final Bit SHOW_LOWERED_KERNEL_MODEL = Bit.nextBit(HEADLESS,\"SHOW_LOWERED_KERNEL_MODEL\", \"SLKM\",\"Show (via OpWriter) Lowered Kernel Model\");\n@@ -116,1 +116,1 @@\n-    private static final Bit SHOW_COMPILATION_PHASES = Bit.nextBit(SHOW_LOWERED_KERNEL_MODEL, \"SHOW_COMPILATION_PHASES\", \"Show HAT compilation phases\");\n+    private static final Bit SHOW_COMPILATION_PHASES = Bit.nextBit(SHOW_LOWERED_KERNEL_MODEL, \"SHOW_COMPILATION_PHASES\",\"SCP\", \"Show HAT compilation phases\");\n@@ -120,1 +120,1 @@\n-    private static final Bit PROFILE_CUDA_KERNEL = Bit.nextBit(SHOW_COMPILATION_PHASES, \"PROFILE_CUDA_KERNEL\", \"Add -lineinfo to CUDA kernel compilation for profiling and debugging\");\n+    private static final Bit PROFILE_CUDA_KERNEL = Bit.nextBit(SHOW_COMPILATION_PHASES, \"PROFILE_CUDA_KERNEL\",\"PCK\", \"Add -lineinfo to CUDA kernel compilation for profiling and debugging\");\n@@ -125,1 +125,1 @@\n-    private static final Bit SHOW_COMPUTE_MODEL_JAVA_CODE = Bit.nextBit(PROFILE_CUDA_KERNEL, \"SHOW_COMPUTE_MODEL_JAVA_CODE\", \"Show java code view of compute model\");\n+    private static final Bit SHOW_COMPUTE_MODEL_JAVA_CODE = Bit.nextBit(PROFILE_CUDA_KERNEL, \"SHOW_COMPUTE_MODEL_JAVA_CODE\",\"SCMJC\", \"Show java code view of compute model\");\n@@ -194,0 +194,5 @@\n+        } else if (spec.equals(\"HELP\")) {\n+          bitList.forEach(bit -> System.out.println(bit.name+ \"\/\"+bit.alt+\" \".repeat(40-(bit.name.length()+bit.alt.length()))+(bit.index<10?\" \":\"\")+bit.index+((bit.size>1)?\"-\"+(bit.index+bit.size-1):\"  \")+ \" \"+bit.description));\n+          if(spec.equals(\"HELP\")){\n+              System.exit(0);\n+          }\n@@ -197,1 +202,1 @@\n-            returnValue=  bitList.stream().filter(bit->bit.name().equals(spec)).findFirst().map(b->fromIntBits(b.mask()));\n+            returnValue=  bitList.stream().filter(bit->bit.name().equals(spec)||bit.alt().equals(spec)).findFirst().map(b->fromIntBits(b.mask()));\n@@ -201,1 +206,1 @@\n-                var optBit = bitList.stream().filter(bit -> bit.name().equals(split[0])).findFirst();\n+                var optBit = bitList.stream().filter(bit -> bit.name().equals(split[0])||bit.alt().equals(split[0])).findFirst();\n","filename":"hat\/core\/src\/main\/java\/hat\/Config.java","additions":41,"deletions":36,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        var transformer = Trxfmr.of(funcOp);\n+        var transformer = Trxfmr.of(lookup,funcOp);\n@@ -112,1 +112,1 @@\n-                    .when(config.showComputeModelJavaCode(), trxfmr -> trxfmr.toJavaSource(lookup, \"COMPUTE (Java) before injecting buffer tracking...\"))\n+                    .when(config.showComputeModelJavaCode(), trxfmr -> trxfmr.toJava(\"COMPUTE (Java) before injecting buffer tracking...\"))\n@@ -116,2 +116,2 @@\n-                            Value computeContext = c.builder().context().getValue(paramTable.list().getFirst().parameter);\n-                            Value ifaceMappedBuffer = c.builder().context().getValue(invoke.op().operands().getFirst());\n+                            Value computeContext = c.getValue(paramTable.list().getFirst().parameter);\n+                            Value ifaceMappedBuffer = c.mappedOperand(0);\n@@ -123,1 +123,1 @@\n-                            Value computeContext = c.builder().context().getValue(paramTable.list().getFirst().parameter);\n+                            Value computeContext = c.getValue(paramTable.list().getFirst().parameter);\n@@ -129,1 +129,1 @@\n-                                                    computeContext, c.builder().context().getValue(typeAndAccess.value()))\n+                                                    computeContext, c.getValue(typeAndAccess.value()))\n@@ -138,1 +138,1 @@\n-                                                    computeContext, c.builder().context().getValue(typeAndAccess.value()))\n+                                                    computeContext, c.getValue(typeAndAccess.value()))\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/Backend.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-            return Trxfmr.of(funcOp).transform( (blockBuilder, op) -> {\n+            return Trxfmr.of(this,funcOp).transform( (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.code.Op;\n@@ -43,5 +42,8 @@\n-         return Trxfmr.of(funcOp).transform(\n-                     ce-> invoke(lookup(),ce) instanceof Invoke $ && $.named(HATBarrierOp.NAME), \/* predicate *\/\n-                     c-> {\n-                        removeMe.add(((Op.Result)c.op().operands().getFirst()).op());\n-                        c.replace(new HATBarrierOp());\n+         return Trxfmr.of(this,funcOp).transform(c-> {\n+                         if (invoke(lookup(),c.op()) instanceof Invoke invoke\n+                                 && invoke.isInstanceAccessedViaVarAccess()\n+                                 && invoke.named(HATBarrierOp.NAME)\n+                         ){\n+                             removeMe.add(invoke.instanceVarAccess().op());\n+                             c.replace(new HATBarrierOp());\n+                         }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-        return Trxfmr.of(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n@@ -244,1 +244,1 @@\n-        return  Trxfmr.of(funcOp).transform(ce->nodesInvolved.contains(ce),(blockBuilder, op) -> {\n+        return  Trxfmr.of(this,funcOp).transform(ce->nodesInvolved.contains(ce),(blockBuilder, op) -> {\n@@ -272,1 +272,1 @@\n-        return Trxfmr.of(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n@@ -292,1 +292,1 @@\n-        return Trxfmr.of(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-        return Trxfmr.of(funcOp).transform(ce->mapMe.contains(ce)||removeMe.contains(ce), (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(ce->mapMe.contains(ce)||removeMe.contains(ce), (blockBuilder, op) -> {\n@@ -205,1 +205,1 @@\n-            return Trxfmr.of(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+            return Trxfmr.of(this,funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        return Trxfmr.of(funcOp).transform(ce->ce instanceof JavaOp.FieldAccessOp, c->{\n+        return Trxfmr.of(this,funcOp).transform(ce->ce instanceof JavaOp.FieldAccessOp, c->{\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-        return Trxfmr.of(funcOp).transform(vectorMetaData::containsKey, (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(vectorMetaData::containsKey, (blockBuilder, op) -> {\n@@ -294,1 +294,1 @@\n-        return Trxfmr.of(funcOp).transform(_->true, (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(_->true, (blockBuilder, op) -> {\n@@ -335,1 +335,1 @@\n-        return Trxfmr.of(funcOp).transform( nodesInvolved::contains, (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform( nodesInvolved::contains, (blockBuilder, op) -> {\n@@ -374,1 +374,1 @@\n-        funcOp = Trxfmr.of(funcOp).transform(_->true, (blockBuilder, op) -> {\n+        funcOp = Trxfmr.of(this,funcOp).transform(_->true, (blockBuilder, op) -> {\n@@ -415,1 +415,1 @@\n-            funcOp = Trxfmr.of(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+            funcOp = Trxfmr.of(this,funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-        return Trxfmr.of(funcOp).transform(ceToInvokeVar::containsKey,(blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(ceToInvokeVar::containsKey,(blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-           return Trxfmr.of(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+           return Trxfmr.of(this,funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package experiments;\n+\n+\n+import hat.ComputeContext;\n+import hat.buffer.S32Array;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import optkl.Trxfmr;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+\n+\n+public class AddArbitraryBlock {\n+\n+    @Reflect\n+    static void hackMe(ComputeContext cc, S32Array s32Array){\n+        System.out.println(\"Ignore this\");\n+        System.out.printf(\"        But wrap this\\n\");\n+        System.out.println(\"Also ignore\");\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        var hackMeMethodRef= MethodRef.method(AddArbitraryBlock.class, \"hackMe\", void.class, ComputeContext.class, S32Array.class);\n+        var lookup = MethodHandles.lookup();\n+        var hackMeFuncOp = CoreOp.FuncOp.ofMethod(hackMeMethodRef.resolveToMethod(lookup)).get();\n+        MethodRef Println = MethodRef.method(IO.class, \"println\", void.class, Object.class);\n+        Trxfmr.of(lookup,hackMeFuncOp)\n+                .toJava(\"Before injecting\")\n+                .transform(\"withNewBlock\", ce -> invoke(lookup,ce) instanceof Invoke $ && $.named(\"printf\"), c -> {\n+                    var beforeString = c.builder().op(CoreOp.constant(JavaType.J_L_STRING, \"Before ....\"));\n+                    var afterString = c.builder().op(CoreOp.constant(JavaType.J_L_STRING, \"After ....\"));\n+                    c.add(JavaOp.if_(c.builder().parentBody()).if_(b -> {\n+                        b.op(CoreOp.core_yield(b.op(CoreOp.constant(JavaType.BOOLEAN, true))));\n+                    }).then(b -> {\n+                        b.op(JavaOp.invoke( JavaType.VOID, Println, beforeString));\n+                        b.op(CoreOp.core_yield());\n+                    }).else_(e->\n+                            e.op(CoreOp.core_yield()))\n+                    );\n+                    c.retain();\n+                    c.add(JavaOp.if_(c.builder().parentBody()).if_(b -> {\n+                        b.op(CoreOp.core_yield(b.op(CoreOp.constant(JavaType.BOOLEAN, true))));\n+                    }).then(b -> {\n+                        b.op(JavaOp.invoke( JavaType.VOID, Println, afterString));\n+                        b.op(CoreOp.core_yield());\n+                    }).else_(e->\n+                            e.op(CoreOp.core_yield()))\n+                    );\n+                })\n+                .toJava( \"After injecting\")\n+                .run(txfmr-> {\n+                    try {\n+                        BytecodeGenerator.generate(txfmr.lookup(), txfmr.funcOp()).invoke(null, null);\n+                    } catch (Throwable throwable) {\n+                        throw new RuntimeException(throwable);\n+                    }\n+                });\n+\n+    }\n+}\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/AddArbitraryBlock.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -169,1 +169,1 @@\n-        Trxfmr.of(rsqrtFuncOp)\n+        Trxfmr.of(lookup,rsqrtFuncOp)\n@@ -201,1 +201,1 @@\n-                    trxfmr.toJavaSource(lookup);\n+                    trxfmr.toJava();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        var newAbs =Trxfmr.of(rsqrt)\n+        var newAbs =Trxfmr.of(lookup,rsqrt)\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,0 +257,1 @@\n+\n@@ -260,0 +261,3 @@\n+            default boolean isInstanceAccessedViaVarAccess(){\n+                return instanceVarAccess()!=null;\n+            }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -38,0 +39,1 @@\n+import optkl.util.carriers.LookupCarrier;\n@@ -46,3 +48,3 @@\n-public class Trxfmr {\n-    public static Trxfmr of(CoreOp.FuncOp funcOp) {\n-        return new Trxfmr(funcOp);\n+public class Trxfmr implements LookupCarrier{\n+    @Override public MethodHandles.Lookup lookup(){\n+        return lookup;\n@@ -50,2 +52,14 @@\n-    public static Trxfmr of(CallSite callSite,CoreOp.FuncOp funcOp) {\n-        return new Trxfmr(callSite,funcOp);\n+    public static Trxfmr of(MethodHandles.Lookup lookup,CallSite callSite,CoreOp.FuncOp funcOp) {\n+        return new Trxfmr(lookup,callSite,funcOp);\n+    }\n+    \/\/public static Trxfmr of(CoreOp.FuncOp funcOp) {\n+      \/\/  return of(null,null, funcOp);\n+   \/\/ }\n+    \/\/public static Trxfmr of(CallSite callSite,CoreOp.FuncOp funcOp) {\n+      \/\/  return of(null,callSite, funcOp);\n+    \/\/}\n+    public static Trxfmr of(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n+        return of(lookup,null, funcOp);\n+    }\n+    public static Trxfmr of(LookupCarrier lookupCarrier, CoreOp.FuncOp funcOp) {\n+        return of(lookupCarrier.lookup(),null, funcOp);\n@@ -85,1 +99,1 @@\n-    public Trxfmr toJavaSource(MethodHandles.Lookup lookup,String prefix, String suffix) {\n+    public Trxfmr toJava(String prefix, String suffix) {\n@@ -99,2 +113,5 @@\n-    public Trxfmr toJavaSource(MethodHandles.Lookup lookup,String prefix) {\n-        return toJavaSource(lookup,prefix, null);\n+    public Trxfmr toJava(String prefix) {\n+        return toJava(prefix, null);\n+    }\n+    public Trxfmr toJava() {\n+        return toJava(null, null);\n@@ -102,2 +119,11 @@\n-    public Trxfmr toJavaSource(MethodHandles.Lookup lookup) {\n-        return toJavaSource(lookup,null, null);\n+\n+    public void exec( Object ... args) {\n+        try {\n+            if (args.length==0) {\n+                BytecodeGenerator.generate(lookup, funcOp()).invoke();\n+            }else{\n+                BytecodeGenerator.generate(lookup, funcOp()).invoke(args);\n+            }\n+        } catch (Throwable throwable) {\n+            throw new RuntimeException(throwable);\n+        }\n@@ -115,2 +141,0 @@\n-\n-\n@@ -294,1 +318,1 @@\n-\n+    public final MethodHandles.Lookup lookup;\n@@ -306,1 +330,2 @@\n-    public Trxfmr(CallSite callSite, CoreOp.FuncOp funcOp) {\n+    private Trxfmr(MethodHandles.Lookup lookup,CallSite callSite, CoreOp.FuncOp funcOp) {\n+        this.lookup = lookup;\n@@ -314,3 +339,0 @@\n-    private  Trxfmr(CoreOp.FuncOp funcOp) {\n-        this (null,funcOp);\n-    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":39,"deletions":17,"binary":false,"changes":56,"status":"modified"}]}