{"files":[{"patch":"@@ -30,2 +30,1 @@\n-import hat.NDRange;\n-import hat.callgraph.CallGraph;\n+import hat.KernelContext;\n@@ -41,1 +40,0 @@\n-import jdk.incubator.code.analysis.SSA;\n@@ -373,1 +371,1 @@\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n@@ -387,1 +385,1 @@\n-        compiledKernel.dispatch(ndRange,args);\n+        compiledKernel.dispatch(kernelContext, args);\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-import hat.NDRange;\n+import hat.KernelContext;\n@@ -22,1 +22,1 @@\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n@@ -33,1 +33,1 @@\n-        compiledKernel.dispatch(ndRange,args);\n+        compiledKernel.dispatch(KernelContext, args);\n","filename":"hat\/backends\/ffi\/hip\/src\/main\/java\/hat\/backend\/HIPBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import hat.NDRange;\n-import hat.callgraph.CallGraph;\n+import hat.KernelContext;\n@@ -55,1 +54,1 @@\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.NDRange;\n+import hat.KernelContext;\n@@ -54,1 +54,1 @@\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n@@ -68,1 +68,1 @@\n-        compiledKernel.dispatch(ndRange, args);\n+        compiledKernel.dispatch(kernelContext, args);\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.ComputeRange;\n+import hat.NDRange;\n@@ -31,2 +31,1 @@\n-import hat.ThreadMesh;\n-import hat.NDRange;\n+import hat.Range;\n@@ -52,1 +51,0 @@\n-import java.lang.annotation.Annotation;\n@@ -85,12 +83,5 @@\n-        private void setGlobalMesh(hat.KernelContext kc) {\n-            kernelBufferContext.gsx(kc.gsx);\n-            kernelBufferContext.gsy(kc.gsy);\n-            kernelBufferContext.gsz(kc.gsz);\n-            kernelBufferContext.dimensions(kc.getDimensions());\n-        }\n-\n-        private void setGlobalMesh(ThreadMesh threadMesh) {\n-            kernelBufferContext.gsx(threadMesh.getX());\n-            kernelBufferContext.gsy(threadMesh.getY());\n-            kernelBufferContext.gsz(threadMesh.getZ());\n-            kernelBufferContext.dimensions(threadMesh.getDims());\n+        private void setGlobalMesh(Range ndRange) {\n+            kernelBufferContext.gsx(ndRange.getX());\n+            kernelBufferContext.gsy(ndRange.getY());\n+            kernelBufferContext.gsz(ndRange.getZ());\n+            kernelBufferContext.dimensions(ndRange.getDims());\n@@ -99,4 +90,4 @@\n-        private void setLocalMesh(ThreadMesh threadMesh) {\n-            kernelBufferContext.lsx(threadMesh.getX());\n-            kernelBufferContext.lsy(threadMesh.getY());\n-            kernelBufferContext.lsz(threadMesh.getZ());\n+        private void setLocalMesh(Range NDRange) {\n+            kernelBufferContext.lsx(NDRange.getX());\n+            kernelBufferContext.lsy(NDRange.getY());\n+            kernelBufferContext.lsz(NDRange.getZ());\n@@ -111,19 +102,7 @@\n-        private void setupComputeRange(NDRange ndRange) {\n-\n-            ComputeRange computeRange = ndRange.kid.getComputeRange();\n-            boolean isComputeRangeDefined = ndRange.kid.hasComputeRange();\n-            boolean isLocalMeshDefined = ndRange.kid.hasLocalMesh();\n-\n-            ThreadMesh globalMesh = null;\n-            ThreadMesh localMesh = null;\n-            if (isComputeRangeDefined) {\n-                globalMesh = computeRange.getGlobalMesh();\n-                localMesh = computeRange.getLocalMesh();\n-            }\n-\n-            if (!isComputeRangeDefined) {\n-                setGlobalMesh(ndRange.kid);\n-            } else {\n-                setGlobalMesh(globalMesh);\n-            }\n-            if (isComputeRangeDefined && isLocalMeshDefined) {\n+        private void setupComputeRange(KernelContext kernelContext) {\n+            NDRange ndRange = kernelContext.getNdRange();\n+            boolean isLocalMeshDefined = kernelContext.hasLocalMesh();\n+            Range globalMesh = ndRange.getGlobal();\n+            Range localMesh = ndRange.getLocal();\n+            setGlobalMesh(globalMesh);\n+            if (isLocalMeshDefined) {\n@@ -134,1 +113,0 @@\n-\n@@ -137,2 +115,2 @@\n-        public void dispatch(NDRange ndRange, Object[] args) {\n-            setupComputeRange(ndRange);\n+        public void dispatch(KernelContext kernelContext, Object[] args) {\n+            setupComputeRange(kernelContext);\n@@ -140,1 +118,1 @@\n-            ArgArray.update(argArray,kernelCallGraph, args);\n+            ArgArray.update(argArray, kernelCallGraph, args);\n@@ -149,3 +127,0 @@\n-\n-\n-\n@@ -170,2 +145,0 @@\n-\n-\n@@ -186,1 +159,1 @@\n-        }else {\n+        } else {\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":22,"deletions":49,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import hat.NDRange;\n@@ -60,2 +59,2 @@\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n-        levelZero.dispatchKernel(kernelCallGraph, ndRange, args);\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n+        levelZero.dispatchKernel(kernelCallGraph, kernelContext, args);\n","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/hat\/backend\/SpirvBackend.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import hat.NDRange;\n@@ -164,1 +163,1 @@\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n@@ -173,1 +172,1 @@\n-        args[0] = ndRange.kid;\n+        args[0] = kernelContext;\n@@ -175,1 +174,1 @@\n-        int[] globalSizes = new int[] {ndRange.kid.maxX, 1, 1};\n+        int[] globalSizes = new int[] {kernelContext.gsx, 1, 1};\n","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/LevelZero.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.Accelerator;\n@@ -30,1 +29,0 @@\n-import hat.NDRange;\n@@ -33,3 +31,0 @@\n-import hat.optools.OpTk;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.java.JavaOp;\n@@ -37,1 +32,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -45,1 +39,1 @@\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n@@ -50,1 +44,1 @@\n-        instance(ndRange.accelerator).forEachInRange(ndRange, (range) -> {\n+        instance().forEachInRange(kernelContext, (kc) -> {\n@@ -53,2 +47,1 @@\n-                KernelContext c = range.kid;\n-                a[0] = c;\n+                a[0] = kc;\n@@ -67,1 +60,1 @@\n-    synchronized WorkStealer instance(Accelerator accelerator) {\n+    synchronized WorkStealer instance() {\n@@ -69,1 +62,1 @@\n-            workStealer = WorkStealer.usingAllProcessors(accelerator);\n+            workStealer = WorkStealer.usingAllProcessors();\n","filename":"hat\/backends\/java\/mt\/src\/main\/java\/hat\/backend\/java\/JavaMultiThreadedBackend.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-\n-import hat.NDRange;\n+import hat.KernelContext;\n@@ -32,3 +31,0 @@\n-import hat.optools.OpTk;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.java.JavaOp;\n@@ -36,1 +32,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -39,1 +34,0 @@\n-\n@@ -42,1 +36,1 @@\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n@@ -47,1 +41,1 @@\n-        for (ndRange.kid.gix = 0; ndRange.kid.gix < ndRange.kid.gsx; ndRange.kid.gix++) {\n+        for (kernelContext.gix = 0; kernelContext.gix < kernelContext.gsx; kernelContext.gix++) {\n@@ -49,1 +43,1 @@\n-                args[0] = ndRange.kid;\n+                args[0] = kernelContext;\n@@ -59,3 +53,0 @@\n-\n-\n-\n","filename":"hat\/backends\/java\/seq\/src\/main\/java\/hat\/backend\/java\/JavaSequentialBackend.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.NDRange;\n+import hat.KernelContext;\n@@ -69,1 +69,1 @@\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n@@ -82,1 +82,1 @@\n-        compiledKernel.dispatch(ndRange,args);\n+        compiledKernel.dispatch(kernelContext,args);\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.NDRange;\n+import hat.KernelContext;\n@@ -68,2 +68,2 @@\n-        public void dispatch(NDRange ndRange, Object[] args) {\n-            kernelContext.gsx(ndRange.kid.gsx);\n+        public void dispatch(KernelContext kernelContext, Object[] args) {\n+            this.kernelContext.gsx(kernelContext.gsx);\n@@ -71,2 +71,2 @@\n-            ArgArray.update(argArray,kernelCallGraph,  args);\n-         \/\/   c99NativeBackend.ndRange(kernelHandle, this.argArray);\n+            ArgArray.update(argArray, kernelCallGraph, args);\n+            \/\/kernelBridge.ndRange(this.argArray);\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -83,22 +83,2 @@\n-    public NDRange range(int max) {\n-        NDRange ndRange = new NDRange(this);\n-        ndRange.kid = new KernelContext(ndRange, max);\n-        return ndRange;\n-    }\n-\n-    public NDRange range(int maxX, int maxY) {\n-        NDRange ndRange = new NDRange(this);\n-        ndRange.kid = new KernelContext(ndRange, maxX, maxY);\n-        return ndRange;\n-    }\n-\n-    public NDRange range(int maxX, int maxY, int maxZ) {\n-        NDRange ndRange = new NDRange(this);\n-        ndRange.kid = new KernelContext(ndRange, maxX, maxY, maxZ);\n-        return ndRange;\n-    }\n-\n-    public NDRange range(ComputeRange computeRange) {\n-        NDRange ndRange = new NDRange(this);\n-        ndRange.kid = new KernelContext(ndRange, computeRange);\n-        return ndRange;\n+    public KernelContext range(NDRange ndRange) {\n+        return new KernelContext(ndRange);\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -43,2 +42,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -113,16 +110,2 @@\n-    \/**\n-     * Called from within compute reachable code to dispatch a kernel.\n-     *\n-     * @param range\n-     * @param quotableKernelContextConsumer\n-     *\/\n-    public void dispatchKernel(int range, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n-        dispatchKernel(range, 0, 0, 1, quotableKernelContextConsumer);\n-    }\n-\n-    public void dispatchKernel(int rangeX, int rangeY, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n-        dispatchKernel(rangeX, rangeY, 0, 2, quotableKernelContextConsumer);\n-    }\n-\n-    public void dispatchKernel(int rangeX, int rangeY, int rangeZ, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n-        dispatchKernel(rangeX, rangeY, rangeZ, 3, quotableKernelContextConsumer);\n+    public void dispatchKernel(NDRange ndRange, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+        dispatchKernelWithComputeRange(ndRange, quotableKernelContextConsumer);\n@@ -131,5 +114,0 @@\n-    public void dispatchKernel(ComputeRange computeRange, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n-        dispatchKernelWithComputeRange(computeRange, quotableKernelContextConsumer);\n-    }\n-\n-\n@@ -149,1 +127,1 @@\n-    private void dispatchKernel(int rangeX, int rangeY, int rangeZ, int dimNumber, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+    private void dispatchKernelWithComputeRange(NDRange ndRange, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n@@ -153,23 +131,3 @@\n-            NDRange ndRange;\n-            switch (dimNumber) {\n-                case 1 -> ndRange = accelerator.range(rangeX);\n-                case 2 -> ndRange = accelerator.range(rangeX, rangeY);\n-                case 3 -> ndRange = accelerator.range(rangeX, rangeY, rangeZ);\n-                default -> throw new RuntimeException(\"[Error] Unexpected dimension value: \" + dimNumber + \". Allowed dimensions <1, 2, 3>\");\n-            }\n-            args[0] = ndRange;\n-            accelerator.backend.dispatchKernel(cg.kernelCallGraph, ndRange, args);\n-        } catch (Throwable t) {\n-            System.out.print(\"what?\" + cg.methodRef + \" \" + t);\n-            t.printStackTrace();\n-            throw t;\n-        }\n-    }\n-\n-    private void dispatchKernelWithComputeRange(ComputeRange computeRange, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n-        CallGraph cg = getKernelCallGraph(quotableKernelContextConsumer);\n-        try {\n-            Object[] args = OpTk.getQuotableCapturedValues(cg.lambdaOp,cg.quoted, cg.kernelCallGraph.entrypoint.method);\n-            NDRange ndRange = accelerator.range(computeRange);\n-            args[0] = ndRange;\n-            accelerator.backend.dispatchKernel(cg.kernelCallGraph, ndRange, args);\n+            KernelContext kernelContext = accelerator.range(ndRange);\n+            args[0] = kernelContext;\n+            accelerator.backend.dispatchKernel(cg.kernelCallGraph, kernelContext, args);\n@@ -211,1 +169,0 @@\n-\n@@ -214,1 +171,0 @@\n-\n@@ -220,4 +176,1 @@\n-    public interface QuotableKernelContextConsumer extends Quotable, Consumer<KernelContext> {\n-\n-    }\n-\n+    public interface QuotableKernelContextConsumer extends Quotable, Consumer<KernelContext> { }\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":7,"deletions":54,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat;\n-\n-\/**\n- * A compute range holds the number of threads to run on an accelerator.\n- * A compute range has two main properties:\n- * - The global number of threads: this means the total number of threads to run per dimension.\n- * This is specified by instancing a new object of type {@link ThreadMesh}.\n- * - A local group size: this is specified by instancing an object of type {@link ThreadMesh}.\n- * A local group size is optional. If it is not specified, the HAT runtime may device a default\n- * value.\n- *\/\n-public class ComputeRange {\n-\n-    private final ThreadMesh globalMesh;\n-    private final ThreadMesh localMesh;\n-\n-    \/**\n-     * Total number of threads to run in 1D.\n-     * @param globalMesh {@link GlobalMesh1D}\n-     *\/\n-    public ComputeRange(GlobalMesh1D globalMesh) {\n-        this.globalMesh = globalMesh;\n-        this.localMesh = null;\n-    }\n-\n-    \/**\n-     * Total number of threads to run in 1D for global and local mesh.\n-     * @param globalMesh {@link GlobalMesh1D}\n-     * @param localMesh {@link LocalMesh1D}\n-     *\/\n-    public ComputeRange(GlobalMesh1D globalMesh, LocalMesh1D localMesh) {\n-        this.globalMesh = globalMesh;\n-        this.localMesh = localMesh;\n-    }\n-\n-\n-    \/**\n-     * Defines a compute range for a 2D mesh. The parameter specifies the\n-     * global mesh (total number of threads to run).\n-     * @param globalMesh {@link GlobalMesh2D}\n-     *\/\n-    public ComputeRange(GlobalMesh2D globalMesh) {\n-        this.globalMesh = globalMesh;\n-        this.localMesh = null;\n-    }\n-\n-    \/**\n-     * Defines a compute range for a 2D mesh. The parameters specify the\n-     * global mesh (total number of threads to run) and the local mesh.\n-     * @param globalMesh {@link GlobalMesh2D}\n-     * @param localMesh {@link LocalMesh2D}\n-     *\/\n-    public ComputeRange(GlobalMesh2D globalMesh, LocalMesh2D localMesh) {\n-        this.globalMesh = globalMesh;\n-        this.localMesh = localMesh;\n-    }\n-\n-    \/**\n-     * Defines a compute range for a 3D mesh. The parameter specifies the\n-     * global mesh (total number of threads to run).\n-     * @param globalMesh {@link GlobalMesh3D}\n-     *\/\n-    public ComputeRange(GlobalMesh3D globalMesh) {\n-        this.globalMesh = globalMesh;\n-        this.localMesh = null;\n-    }\n-\n-    \/**\n-     * Defines a compute range for a 3D mesh. The parameters specify the\n-     * global mesh (total number of threads to run) and the local mesh.\n-     * @param globalMesh {@link GlobalMesh3D}\n-     * @param localMesh {@link LocalMesh3D}\n-     *\/\n-    public ComputeRange(GlobalMesh3D globalMesh, LocalMesh3D localMesh) {\n-        this.globalMesh = globalMesh;\n-        this.localMesh = localMesh;\n-    }\n-\n-    \/**\n-     * Factory method to run a single thread on a target accelerator. Although for some accelerators this could be\n-     * beneficial (e.g., FPGAs), in general, use only for debugging purposes.\n-     *\/\n-    public static final ComputeRange SINGLE_THREADED = new ComputeRange(new GlobalMesh1D(1));\n-\n-    \/**\n-     * Obtain the total number of threads per dimension. The number of threads\n-     * per dimension is stored in a {@link ThreadMesh}\n-     * @return {@link ThreadMesh}\n-     *\/\n-    public ThreadMesh getGlobalMesh() {\n-        return globalMesh;\n-    }\n-\n-    \/**\n-     * Obtain the local group size per dimension. The group size per dimension is stored\n-     * in a {@link ThreadMesh}.\n-     * @return {@link ThreadMesh}\n-     *\/\n-    public ThreadMesh getLocalMesh() {\n-        return localMesh;\n-    }\n-\n-    public boolean isSpecificRange() {\n-        return false;\n-    }\n-}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeRange.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n-public record LocalMesh1D(int x) implements ThreadMesh {\n+public record Global1D(int x) implements Range {\n@@ -51,1 +51,1 @@\n-        return \"<1D LocalMesh: \" + getX() + \">\";\n+        return \"<Global1D: \" + getX() + \">\";\n","filename":"hat\/core\/src\/main\/java\/hat\/Global1D.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/core\/src\/main\/java\/hat\/LocalMesh1D.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-public record LocalMesh2D(int x, int y) implements ThreadMesh {\n+public record Global2D(int x, int y) implements Range {\n@@ -51,1 +51,1 @@\n-        return \"<2D LocalMesh: \" + getX() + \",\" + getY() + \">\";\n+        return \"<Global2D: \" + getX() + \",\" + getY() + \">\";\n","filename":"hat\/core\/src\/main\/java\/hat\/Global2D.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/core\/src\/main\/java\/hat\/LocalMesh2D.java","status":"renamed"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record Global3D(int x, int y, int z) implements Range {\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return y;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return z;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"<Global3D: \" + getX() + \",\" + getY() + \".\" + getZ() + \">\";\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/Global3D.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat;\n-\n-public record GlobalMesh3D(int x, int y, int z) implements ThreadMesh {\n-    @Override\n-    public int getX() {\n-        return x;\n-    }\n-\n-    @Override\n-    public int getY() {\n-        return y;\n-    }\n-\n-    @Override\n-    public int getZ() {\n-        return z;\n-    }\n-\n-    @Override\n-    public int getDims() {\n-        return 3;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/GlobalMesh3D.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -43,2 +43,0 @@\n-    public final NDRange ndRange;\n-\n@@ -71,1 +69,1 @@\n-    private ComputeRange computeRange;\n+    private NDRange ndRange;\n@@ -73,1 +71,1 @@\n-    public KernelContext(NDRange ndRange, ComputeRange computeRange) {\n+    public KernelContext(NDRange ndRange) {\n@@ -75,5 +73,4 @@\n-        this.computeRange = computeRange;\n-        this.gsx = computeRange.getGlobalMesh().getX();\n-        this.gsy = computeRange.getGlobalMesh().getY();\n-        this.gsz = computeRange.getGlobalMesh().getZ();\n-        this.dimensions = computeRange.getGlobalMesh().getDims();\n+        this.gsx = ndRange.getGlobal().getX();\n+        this.gsy = ndRange.getGlobal().getY();\n+        this.gsz = ndRange.getGlobal().getZ();\n+        this.dimensions = ndRange.getGlobal().getDims();\n@@ -84,1 +81,0 @@\n-     * @param ndRange {@link NDRange}\n@@ -87,2 +83,1 @@\n-    public KernelContext(NDRange ndRange, int maxX) {\n-        this.ndRange = ndRange;\n+    public KernelContext(int maxX) {\n@@ -97,1 +92,0 @@\n-     * @param ndRange {@link NDRange}\n@@ -101,2 +95,1 @@\n-    public KernelContext(NDRange ndRange, int maxX, int maxY) {\n-        this.ndRange = ndRange;\n+    public KernelContext(int maxX, int maxY) {\n@@ -111,1 +104,0 @@\n-     * @param ndRange {@link NDRange}\n@@ -116,2 +108,1 @@\n-    public KernelContext(NDRange ndRange, int maxX, int maxY, int maxZ) {\n-        this.ndRange = ndRange;\n+    public KernelContext(int maxX, int maxY, int maxZ) {\n@@ -129,6 +120,2 @@\n-    public ComputeRange getComputeRange() {\n-        return this.computeRange;\n-    }\n-\n-    public boolean hasComputeRange() {\n-        return this.computeRange != null;\n+    public NDRange getNdRange() {\n+        return this.ndRange;\n@@ -138,4 +125,1 @@\n-        if (hasComputeRange()) {\n-            return this.computeRange.getLocalMesh() != null;\n-        }\n-        return false;\n+        return this.ndRange.getLocal() != null;\n","filename":"hat\/core\/src\/main\/java\/hat\/KernelContext.java","additions":12,"deletions":28,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-public record GlobalMesh1D(int x) implements ThreadMesh {\n+public record Local1D(int x) implements Range {\n@@ -51,1 +51,1 @@\n-        return \"<1D GlobalMesh: \" + getX() + \">\";\n+        return \"<Local1D: \" + getX() + \">\";\n","filename":"hat\/core\/src\/main\/java\/hat\/Local1D.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/core\/src\/main\/java\/hat\/GlobalMesh1D.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-public record GlobalMesh2D(int x, int y) implements ThreadMesh {\n+public record Local2D(int x, int y) implements Range {\n@@ -51,1 +51,1 @@\n-        return \"<2D GlobalMesh: \" + getX() + \",\" + getY() + \">\";\n+        return \"<Local2D: \" + getX() + \",\" + getY() + \">\";\n","filename":"hat\/core\/src\/main\/java\/hat\/Local2D.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/core\/src\/main\/java\/hat\/GlobalMesh2D.java","status":"renamed"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record Local3D(int x, int y, int z) implements Range {\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return y;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return z;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"<Local3D: \" + getX() + \",\" + getY() + \".\" + getZ() + \">\";\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/Local3D.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat;\n-\n-public record LocalMesh3D(int x, int y, int z) implements ThreadMesh {\n-    @Override\n-    public int getX() {\n-        return x;\n-    }\n-\n-    @Override\n-    public int getY() {\n-        return y;\n-    }\n-\n-    @Override\n-    public int getZ() {\n-        return z;\n-    }\n-\n-    @Override\n-    public int getDims() {\n-        return 3;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/LocalMesh3D.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,7 @@\n- * Represents the range over a compute grid for a kernel to be applied.\n+ * A compute range holds the number of threads to run on an accelerator.\n+ * A compute range has two main properties:\n+ * - The global number of threads: this means the total number of threads to run per dimension.\n+ * This is specified by instancing a new object of type {@link Range}.\n+ * - A local group size: this is specified by instancing an object of type {@link Range}.\n+ * A local group size is optional. If it is not specified, the HAT runtime may device a default\n+ * value.\n@@ -32,1 +38,78 @@\n-    public final Accelerator accelerator;\n+    \/**\n+     * Total number of threads to run in 1D.\n+     * @param global {@link Global1D}\n+     *\/\n+    public static NDRange of(Global1D global) {\n+        return new NDRange(global);\n+    }\n+\n+    \/**\n+     * Total number of threads to run in 1D for global and local mesh.\n+     * @param global {@link Global1D}\n+     * @param local {@link Local1D}\n+     *\/\n+    public static NDRange of(Global1D global, Local1D local) {\n+        return new NDRange(global, local);\n+    }\n+\n+    \/**\n+     * Defines a compute range for a 2D mesh. The parameter specifies the\n+     * global mesh (total number of threads to run).\n+     * @param global {@link Global2D}\n+     *\/\n+    public static NDRange of(Global2D global) {\n+        return new NDRange(global);\n+    }\n+\n+    \/**\n+     * Defines a compute range for a 2D mesh. The parameters specify the\n+     * global mesh (total number of threads to run) and the local mesh.\n+     * @param global {@link Global2D}\n+     * @param local {@link Local2D}\n+     *\/\n+    public static NDRange of(Global2D global, Local2D local) {\n+        return new NDRange(global, local);\n+    }\n+\n+    \/**\n+     * Defines a compute range for a 3D mesh. The parameter specifies the\n+     * global mesh (total number of threads to run).\n+     * @param global {@link Global3D}\n+     *\/\n+    public static NDRange of(Global3D global) {\n+        return new NDRange(global);\n+    }\n+\n+    \/**\n+     * Defines a compute range for a 3D mesh. The parameters specify the\n+     * global mesh (total number of threads to run) and the local mesh.\n+     * @param global {@link Global3D}\n+     * @param local {@link Local3D}\n+     *\/\n+    public static NDRange of(Global3D global, Local3D local) {\n+        return new NDRange(global, local);\n+    }\n+\n+    \/**\n+     * Factory method to run a single thread on a target accelerator. Although for some accelerators this could be\n+     * beneficial (e.g., FPGAs), in general, use only for debugging purposes.\n+     *\/\n+    public static final NDRange SINGLE_THREADED = new NDRange(new Global1D(1));\n+\n+    \/**\n+     * Obtain the total number of threads per dimension. The number of threads\n+     * per dimension is stored in a {@link Range}\n+     * @return {@link Range}\n+     *\/\n+    public Range getGlobal() {\n+        return global;\n+    }\n+\n+    \/**\n+     * Obtain the local group size per dimension. The group size per dimension is stored\n+     * in a {@link Range}.\n+     * @return {@link Range}\n+     *\/\n+    public Range getLocal() {\n+        return local;\n+    }\n@@ -34,1 +117,49 @@\n-    public KernelContext kid;\n+    public boolean isSpecificRange() {\n+        return false;\n+    }\n+\n+    \/**\n+     * Utility method to create a 1D program with only global thread size.\n+     * @param numThreadsGlobal\n+     * @return {@link NDRange}\n+     *\/\n+    public static NDRange of(int numThreadsGlobal) {\n+        return new NDRange(new Global1D(numThreadsGlobal));\n+    }\n+\n+    \/**\n+     * Utility method to create a 1D program with global and local thread sizes.\n+     * @param numThreadsGlobal\n+     * @return {@link NDRange}\n+     *\/\n+    public static NDRange of(int numThreadsGlobal, int numThreadLocal) {\n+        return new NDRange(new Global1D(numThreadsGlobal), new Local1D(numThreadLocal));\n+    }\n+\n+    private final Range global;\n+    private final Range local;\n+\n+    private NDRange(Global1D global) {\n+        this.global = global;\n+        this.local = null;\n+    }\n+\n+    private NDRange(Global1D global, Local1D local) {\n+        this.global = global;\n+        this.local = local;\n+    }\n+\n+    private NDRange(Global2D global) {\n+        this.global = global;\n+        this.local = null;\n+    }\n+\n+    private NDRange(Global2D global, Local2D local) {\n+        this.global = global;\n+        this.local = local;\n+    }\n+\n+    private NDRange(Global3D global) {\n+        this.global = global;\n+        this.local = null;\n+    }\n@@ -36,2 +167,3 @@\n-    public NDRange(Accelerator accelerator) {\n-        this.accelerator = accelerator;\n+    private NDRange(Global3D global, Local3D local) {\n+        this.global = global;\n+        this.local = local;\n@@ -39,1 +171,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/NDRange.java","additions":139,"deletions":7,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public interface ThreadMesh {\n+public interface Range {\n","filename":"hat\/core\/src\/main\/java\/hat\/Range.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/ThreadMesh.java","status":"renamed"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.NDRange;\n+import hat.KernelContext;\n@@ -76,1 +76,1 @@\n-    public abstract void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args);\n+    public abstract void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args);\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/Backend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.NDRange;\n+import hat.KernelContext;\n@@ -59,1 +59,1 @@\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n@@ -61,1 +61,1 @@\n-        for (ndRange.kid.gix = 0; ndRange.kid.gix < ndRange.kid.gsx; ndRange.kid.gix++) {\n+        for (kernelContext.gix = 0; kernelContext.gix < kernelContext.gsx; kernelContext.gix++) {\n@@ -63,1 +63,1 @@\n-                args[0] = ndRange.kid;\n+                args[0] = kernelContext;\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/BackendAdaptor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.BufferTagger;\n@@ -30,1 +29,1 @@\n-import hat.NDRange;\n+import hat.KernelContext;\n@@ -38,2 +37,0 @@\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.analysis.SSA;\n@@ -99,1 +96,1 @@\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n@@ -105,1 +102,1 @@\n-                for (ndRange.kid.gix = 0; ndRange.kid.gix < ndRange.kid.gsx; ndRange.kid.gix++) {\n+                for (kernelContext.gix = 0; kernelContext.gix < kernelContext.gsx; kernelContext.gix++) {\n@@ -107,1 +104,1 @@\n-                        args[0] = ndRange.kid;\n+                        args[0] = kernelContext;\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.Accelerator;\n@@ -30,1 +29,0 @@\n-import hat.NDRange;\n@@ -45,1 +43,1 @@\n-    Consumer<NDRange> rangeConsumer;\n+    Consumer<KernelContext> rangeConsumer;\n@@ -50,1 +48,1 @@\n-    private NDRange[] ranges;\n+    private KernelContext[] ranges;\n@@ -52,1 +50,1 @@\n-    public WorkStealer(Accelerator accelerator, int threadCount) {\n+    public WorkStealer(int threadCount) {\n@@ -59,1 +57,1 @@\n-            this.ranges = new NDRange[threadCount];\n+            this.ranges = new KernelContext[threadCount];\n@@ -65,1 +63,1 @@\n-                ranges[fini] = new NDRange(accelerator);\n+                ranges[fini] = new KernelContext(range);\n@@ -68,1 +66,1 @@\n-                    NDRange ndRange = ranges[fini];\n+                    hat.KernelContext kernelContext = ranges[fini];\n@@ -76,2 +74,0 @@\n-                        ndRange.kid = new KernelContext(ndRange, range);\n-\n@@ -79,4 +75,2 @@\n-\n-                            for (ndRange.kid.gix = myChunk * chunkSize; ndRange.kid.gix < (myChunk + 1) * chunkSize && ndRange.kid.gix < range; ndRange.kid.gix++) {\n-\n-                                rangeConsumer.accept(ndRange);\n+                            for (kernelContext.gix = myChunk * chunkSize; kernelContext.gix < (myChunk + 1) * chunkSize && kernelContext.gix < range; kernelContext.gix++) {\n+                                rangeConsumer.accept(kernelContext);\n@@ -102,2 +96,2 @@\n-    public static WorkStealer of(Accelerator accelerator, int threads) {\n-        return new WorkStealer(accelerator, threads);\n+    public static WorkStealer of(int threads) {\n+        return new WorkStealer(threads);\n@@ -106,2 +100,2 @@\n-    public static WorkStealer usingAllProcessors(Accelerator accelerator) {\n-        return WorkStealer.of(accelerator, Runtime.getRuntime().availableProcessors());\n+    public static WorkStealer usingAllProcessors() {\n+        return WorkStealer.of(Runtime.getRuntime().availableProcessors());\n@@ -110,1 +104,1 @@\n-    public void forEachInRange(NDRange ndRange, Consumer<NDRange> rangeConsumer) {\n+    public void forEachInRange(KernelContext kernelContext, Consumer<KernelContext> rangeConsumer) {\n@@ -114,1 +108,1 @@\n-            this.range = ndRange.kid.gsx;\n+            this.range = kernelContext.gsx;\n@@ -121,2 +115,2 @@\n-            for (ndRange.kid.gix = 0; ndRange.kid.gix < range; ndRange.kid.gix++) {\n-                rangeConsumer.accept(ndRange);\n+            for (kernelContext.gix = 0; kernelContext.gix < range; kernelContext.gix++) {\n+                rangeConsumer.accept(kernelContext);\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/java\/WorkStealer.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.NDRange;\n@@ -94,1 +95,1 @@\n-        cc.dispatchKernel(call.length(),\n+        cc.dispatchKernel(NDRange.of(call.length()),\n","filename":"hat\/examples\/blackscholes\/src\/main\/java\/blackscholes\/Main.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -79,3 +80,3 @@\n-            computeContext.dispatchKernel(a.length(), (kc) -> counted(kc, a));\n-            computeContext.dispatchKernel(a.length(), (kc) -> tuple(kc, a));\n-            computeContext.dispatchKernel(a.length(), (kc) -> breakAndContinue(kc, a));\n+            computeContext.dispatchKernel(NDRange.of(a.length()), (kc) -> counted(kc, a));\n+            computeContext.dispatchKernel(NDRange.of(a.length()), (kc) -> tuple(kc, a));\n+            computeContext.dispatchKernel(NDRange.of(a.length()), (kc) -> breakAndContinue(kc, a));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ForTests.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -33,1 +33,1 @@\n-import hat.LocalMesh1D;\n+import hat.Local1D;\n@@ -88,2 +88,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(16));\n-        computeContext.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global1D(32), new Local1D(16));\n+        computeContext.dispatchKernel(ndRange,\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LocalArray.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -32,1 +32,1 @@\n-import hat.LocalMesh1D;\n+import hat.Local1D;\n@@ -68,2 +68,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(BLOCK_SIZE));\n-        cc.dispatchKernel(computeRange, kc -> assign(kc, arrayA, arrayB, arrayC));\n+        NDRange ndRange = NDRange.of(new Global1D(32), new Local1D(BLOCK_SIZE));\n+        cc.dispatchKernel(ndRange, kc -> assign(kc, arrayA, arrayB, arrayC));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LocalIds.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -30,2 +31,1 @@\n-import hat.Config;\n-import static hat.Config.*;\n+\n@@ -131,1 +131,1 @@\n-            cc.dispatchKernel(meshData.points(),\n+            cc.dispatchKernel(NDRange.of(meshData.points()),\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -38,2 +39,0 @@\n-import static hat.Config.*;\n-\n@@ -54,1 +53,1 @@\n-                cc.dispatchKernel(len, kc -> inc(kc, s32Array, len));\n+                cc.dispatchKernel(NDRange.of(len), kc -> inc(kc, s32Array, len));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/MinBufferTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -41,1 +42,0 @@\n-import javax.print.DocFlavor;\n@@ -351,1 +351,1 @@\n-        cc.dispatchKernel(data.length(), kc -> groupScan(kc, data));\n+        cc.dispatchKernel(NDRange.of(data.length()), kc -> groupScan(kc, data));\n@@ -353,1 +353,1 @@\n-        cc.dispatchKernel(GROUP_SIZE, kc -> crossGroupScan(kc, data));\n+        cc.dispatchKernel(NDRange.of(GROUP_SIZE), kc -> crossGroupScan(kc, data));\n@@ -355,1 +355,1 @@\n-        cc.dispatchKernel(GROUP_SIZE, kc -> sumKernel(kc, data));\n+        cc.dispatchKernel(NDRange.of(GROUP_SIZE), kc -> sumKernel(kc, data));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -44,1 +45,1 @@\n-        computeContext.dispatchKernel(in.length(), kc -> QuotedConstantArgs.addScalerKernel(kc, in, out, scaler));\n+        computeContext.dispatchKernel(NDRange.of(in.length()), kc -> QuotedConstantArgs.addScalerKernel(kc, in, out, scaler));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedArrayArg.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -44,1 +45,1 @@\n-        computeContext.dispatchKernel(in.length(), kc -> QuotedConstantArgs.addScalerKernel(kc, in, out, scaler));\n+        computeContext.dispatchKernel(NDRange.of(in.length()), kc -> QuotedConstantArgs.addScalerKernel(kc, in, out, scaler));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedConstantArgs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -32,1 +32,1 @@\n-import hat.LocalMesh1D;\n+import hat.Local1D;\n@@ -138,2 +138,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(16));\n-        cc.dispatchKernel(computeRange, kc -> reduceLocal(kc, input, partialSums));\n+        NDRange ndRange = NDRange.of(new Global1D(32), new Local1D(16));\n+        cc.dispatchKernel(ndRange, kc -> reduceLocal(kc, input, partialSums));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Reduction.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -110,1 +111,1 @@\n-            computeContext.dispatchKernel(size * size, kc -> MatrixMultiply.kernel(kc, a, b, c));\n+            computeContext.dispatchKernel(NDRange.of(size * size), kc -> MatrixMultiply.kernel(kc, a, b, c));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/GetBackend.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -115,1 +116,0 @@\n-\n@@ -117,1 +117,1 @@\n-                    size * size,                \/\/ range is passed as int and creation internalized\n+                    NDRange.of(size * size),                \/\/ range is passed as int and creation internalized\n@@ -119,8 +119,0 @@\n-\n-                \/* A 2D dispatch - not supported yet\n-                computeContext.dispatchKernel(\n-                        size, size,                \/\/ 2D range now can be passed as two int's and creation internalized\n-                        (kid)->kernel(kid,a,b,c)); \/\/ kid now a Kid2D now has kid.x,kid.y,kid.maxX,\n-\n-                 *\/\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/MatrixMultiply.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import hat.NDRange;\n@@ -54,1 +55,0 @@\n-import javax.swing.JTextField;\n@@ -252,1 +252,1 @@\n-        cc.dispatchKernel(searchArea.area(),\n+        cc.dispatchKernel(NDRange.of(searchArea.area()),\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Compute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -31,1 +32,0 @@\n-import hat.ifacemapper.BufferState;\n@@ -40,2 +40,0 @@\n-import java.util.List;\n-import java.util.stream.IntStream;\n@@ -43,1 +41,0 @@\n-import static hat.backend.Backend.FIRST;\n@@ -218,1 +215,1 @@\n-                cc.dispatchKernel(range, kc -> Compute.life(kc, ctrl, grid));\n+                cc.dispatchKernel(NDRange.of(range), kc -> Compute.life(kc, ctrl, grid));\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.Config;\n+import hat.NDRange;\n@@ -38,1 +38,0 @@\n-import hat.ifacemapper.SegmentMapper;\n@@ -68,1 +67,0 @@\n-\n@@ -70,1 +68,1 @@\n-                s32Array2D.width()*s32Array2D.height(), \/\/0..S32Array2D.size()\n+                NDRange.of(s32Array2D.width()*s32Array2D.height()),               \/\/0..S32Array2D.size()\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/Main.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n-import hat.GlobalMesh2D;\n+import hat.NDRange;\n+import hat.Global1D;\n+import hat.Global2D;\n@@ -33,2 +33,2 @@\n-import hat.LocalMesh1D;\n-import hat.LocalMesh2D;\n+import hat.Local1D;\n+import hat.Local2D;\n@@ -509,2 +509,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(globalSize), new LocalMesh1D(16));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global1D(globalSize), new Local1D(16));\n+        cc.dispatchKernel(ndRange,\n@@ -519,2 +519,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size), new LocalMesh1D(16));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global1D(size), new Local1D(16));\n+        cc.dispatchKernel(ndRange,\n@@ -527,2 +527,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global2D(globalSize, globalSize), new Local2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(ndRange,\n@@ -535,2 +535,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global2D(globalSize, globalSize), new Local2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(ndRange,\n@@ -543,2 +543,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global2D(globalSize, globalSize), new Local2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(ndRange,\n@@ -551,2 +551,2 @@\n-        ComputeRange cudaRange = new ComputeRange(new GlobalMesh2D(256, 256), new LocalMesh2D(16, 16));\n-        cc.dispatchKernel(cudaRange,\n+        NDRange ndRange = NDRange.of(new Global2D(256, 256), new Local2D(16, 16));\n+        cc.dispatchKernel(ndRange,\n@@ -559,2 +559,2 @@\n-        ComputeRange cudaRange = new ComputeRange(new GlobalMesh2D(256, 256), new LocalMesh2D(16, 16));\n-        cc.dispatchKernel(cudaRange,\n+        NDRange ndRange = NDRange.of(new Global2D(256, 256), new Local2D(16, 16));\n+        cc.dispatchKernel(ndRange,\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.NDRange;\n@@ -104,1 +105,1 @@\n-        cc.dispatchKernel(universe.length(), kc -> nbodyKernel(kc, universe, cmass, cdelT, cespSqr));\n+        cc.dispatchKernel(NDRange.of(universe.length()), kc -> nbodyKernel(kc, universe, cmass, cdelT, cespSqr));\n@@ -107,1 +108,0 @@\n-\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/opencl\/OpenCLNBodyGLWindow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -55,1 +56,1 @@\n-        cc.dispatchKernel(s32Array.length(),\n+        cc.dispatchKernel(NDRange.of(s32Array.length()),\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Main.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.NDRange;\n@@ -36,1 +37,0 @@\n-import java.awt.image.BufferedImage;\n@@ -317,1 +317,1 @@\n-        cc.dispatchKernel(width * height, kc -> rgbToGreyKernel(kc, s08X3RGBImage, greyImage));\n+        cc.dispatchKernel(NDRange.of(width * height), kc -> rgbToGreyKernel(kc, s08X3RGBImage, greyImage));\n@@ -322,2 +322,2 @@\n-        cc.dispatchKernel(width, kc -> integralColKernel(kc, greyImage, integralImage, integralSqImage));\n-        cc.dispatchKernel(height, kc -> integralRowKernel(kc, integralImage, integralSqImage));\n+        cc.dispatchKernel(NDRange.of(width), kc -> integralColKernel(kc, greyImage, integralImage, integralSqImage));\n+        cc.dispatchKernel(NDRange.of(height), kc -> integralRowKernel(kc, integralImage, integralSqImage));\n@@ -325,1 +325,1 @@\n-        cc.dispatchKernel(scaleTable.multiScaleAccumulativeRange(), kc ->\n+        cc.dispatchKernel(NDRange.of(scaleTable.multiScaleAccumulativeRange()), kc ->\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import hat.Global1D;\n+import hat.NDRange;\n@@ -331,2 +333,2 @@\n-            WorkStealer.usingAllProcessors(accelerator)\n-                    .forEachInRange(accelerator.range(scaleTable.multiScaleAccumulativeRange()), r -> {\n+            WorkStealer.usingAllProcessors()\n+                    .forEachInRange(accelerator.range(NDRange.of(new Global1D(scaleTable.multiScaleAccumulativeRange()))), kc -> {\n@@ -334,1 +336,1 @@\n-                                r.kid.gix,\n+                                kc.gix,\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/attic\/ViolaJones.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -57,1 +58,1 @@\n-        cc.dispatchKernel(s32Array.length(),\n+        cc.dispatchKernel(NDRange.of(s32Array.length()),\n@@ -88,1 +89,1 @@\n-        cc.dispatchKernel(s32Array2D.width() * s32Array2D.height(),\n+        cc.dispatchKernel(NDRange.of(s32Array2D.width() * s32Array2D.height()),\n@@ -235,1 +236,1 @@\n-            cc.dispatchKernel(range, kc -> Compute.life(kc, ctrl, grid));\n+            cc.dispatchKernel(NDRange.of(range), kc -> Compute.life(kc, ctrl, grid));\n@@ -354,1 +355,1 @@\n-                s32Array2D.width()*s32Array2D.height(), \/\/0..S32Array2D.size()\n+                NDRange.of(s32Array2D.width()*s32Array2D.height()), \/\/0..S32Array2D.size()\n@@ -465,1 +466,1 @@\n-        cc.dispatchKernel(call.length(),\n+        cc.dispatchKernel(NDRange.of(call.length()),\n@@ -573,1 +574,1 @@\n-        cc.dispatchKernel(s32Array.length(),\n+        cc.dispatchKernel(NDRange.of(s32Array.length()),\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrayView.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -62,2 +62,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(array.length()));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global1D(array.length()));\n+        cc.dispatchKernel(ndRange,\n@@ -79,2 +79,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(arrayA.length()));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global1D(arrayA.length()));\n+        cc.dispatchKernel(ndRange,\n@@ -97,2 +97,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(arrayA.length()));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global1D(arrayA.length()));\n+        cc.dispatchKernel(ndRange,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrays.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.NDRange;\n@@ -89,1 +90,1 @@\n-        cc.dispatchKernel(call.length(),\n+        cc.dispatchKernel(NDRange.of(call.length()),\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestBlackscholes.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -58,2 +58,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(arrayA.length()));\n-        cc.dispatchKernel(computeRange, kc -> vectorWithConstants(kc, arrayA, arrayB, arrayC));\n+        NDRange ndRange = NDRange.of(new Global1D(arrayA.length()));\n+        cc.dispatchKernel(ndRange, kc -> vectorWithConstants(kc, arrayA, arrayB, arrayC));\n@@ -108,2 +108,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(arrayA.length()));\n-        cc.dispatchKernel(computeRange, kc -> vectorWithConstants2(kc, arrayA, arrayB, arrayC));\n+        NDRange ndRange = NDRange.of(new Global1D(arrayA.length()));\n+        cc.dispatchKernel(ndRange, kc -> vectorWithConstants2(kc, arrayA, arrayB, arrayC));\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestConstants.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -120,2 +120,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.copy01(kernelContext, a, b));\n+        NDRange ndRange = NDRange.of(new Global1D(a.length()));\n+        computeContext.dispatchKernel(ndRange, kernelContext -> TestF16Type.copy01(kernelContext, a, b));\n@@ -126,2 +126,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.f16Ops_02(kernelContext, a, b, c));\n+        NDRange ndRange = NDRange.of(new Global1D(a.length()));\n+        computeContext.dispatchKernel(ndRange, kernelContext -> TestF16Type.f16Ops_02(kernelContext, a, b, c));\n@@ -132,2 +132,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.f16Ops_03(kernelContext, a, b, c));\n+        NDRange ndRange = NDRange.of(new Global1D(a.length()));\n+        computeContext.dispatchKernel(ndRange, kernelContext -> TestF16Type.f16Ops_03(kernelContext, a, b, c));\n@@ -138,2 +138,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.f16Ops_04(kernelContext, a, b, c));\n+        NDRange ndRange = NDRange.of(new Global1D(a.length()));\n+        computeContext.dispatchKernel(ndRange, kernelContext -> TestF16Type.f16Ops_04(kernelContext, a, b, c));\n@@ -144,2 +144,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.f16Ops_05(kernelContext, a));\n+        NDRange ndRange = NDRange.of(new Global1D(a.length()));\n+        computeContext.dispatchKernel(ndRange, kernelContext -> TestF16Type.f16Ops_05(kernelContext, a));\n@@ -150,2 +150,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.f16Ops_06(kernelContext, a));\n+        NDRange ndRange = NDRange.of(new Global1D(a.length()));\n+        computeContext.dispatchKernel(ndRange, kernelContext -> TestF16Type.f16Ops_06(kernelContext, a));\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestF16Type.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -32,1 +32,1 @@\n-import hat.LocalMesh1D;\n+import hat.Local1D;\n@@ -77,2 +77,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(16));\n-        computeContext.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global1D(32), new Local1D(16));\n+        computeContext.dispatchKernel(ndRange,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestLocal.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -69,2 +69,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(s32Array2D.width() & s32Array2D.height()));\n-        computeContext.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global1D(s32Array2D.width() & s32Array2D.height()));\n+        computeContext.dispatchKernel(ndRange,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMandel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n-import hat.GlobalMesh2D;\n+import hat.NDRange;\n+import hat.Global1D;\n+import hat.Global2D;\n@@ -33,2 +33,2 @@\n-import hat.LocalMesh1D;\n-import hat.LocalMesh2D;\n+import hat.Local1D;\n+import hat.Local2D;\n@@ -198,2 +198,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(globalSize), new LocalMesh1D(16));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global1D(globalSize), new Local1D(16));\n+        cc.dispatchKernel(ndRange,\n@@ -208,2 +208,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global1D(size));\n+        cc.dispatchKernel(ndRange,\n@@ -216,2 +216,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global2D(globalSize, globalSize), new Local2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(ndRange,\n@@ -224,2 +224,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global2D(globalSize, globalSize), new Local2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(ndRange,\n@@ -232,2 +232,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global2D(globalSize, globalSize), new Local2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(ndRange,\n@@ -240,2 +240,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n-        cc.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global2D(globalSize, globalSize), new Local2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(ndRange,\n@@ -743,2 +743,2 @@\n-        ComputeRange cudaRange = new ComputeRange(new GlobalMesh2D(256, 256), new LocalMesh2D(16, 16));\n-        cc.dispatchKernel(cudaRange,\n+        NDRange ndRange = NDRange.of(new Global2D(256, 256), new Local2D(16, 16));\n+        cc.dispatchKernel(ndRange,\n@@ -751,2 +751,2 @@\n-        ComputeRange cudaRange = new ComputeRange(new GlobalMesh2D(256, 256), new LocalMesh2D(16, 16));\n-        cc.dispatchKernel(cudaRange,\n+        NDRange ndRange = NDRange.of(new Global2D(256, 256), new Local2D(16, 16));\n+        cc.dispatchKernel(ndRange,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMatMul.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -109,2 +109,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(universe.length()));\n-        cc.dispatchKernel(computeRange, kernelContext -> nbodyKernel(kernelContext, universe, mass, delT, espSqr));\n+        NDRange ndRange = NDRange.of(new Global1D(universe.length()));\n+        cc.dispatchKernel(ndRange, kernelContext -> nbodyKernel(kernelContext, universe, mass, delT, espSqr));\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestNbody.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -74,2 +74,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(data.length()));\n-        cc.dispatchKernel(computeRange,kc -> compute(kc, data));\n+        NDRange ndRange = NDRange.of(new Global1D(data.length()));\n+        cc.dispatchKernel(ndRange,kc -> compute(kc, data));\n@@ -80,2 +80,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(data.length()));\n-        cc.dispatchKernel(computeRange,kc -> compute2(kc, data));\n+        NDRange ndRange = NDRange.of(new Global1D(data.length()));\n+        cc.dispatchKernel(ndRange,kc -> compute2(kc, data));\n@@ -86,2 +86,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(data.length()));\n-        cc.dispatchKernel(computeRange,kc -> compute3(kc, data));\n+        NDRange ndRange = NDRange.of(new Global1D(data.length()));\n+        cc.dispatchKernel(ndRange,kc -> compute3(kc, data));\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestParenthesis.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -76,2 +76,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32));\n-        computeContext.dispatchKernel(computeRange,\n+        NDRange ndRange = NDRange.of(new Global1D(32));\n+        computeContext.dispatchKernel(ndRange,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestPrivate.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -32,1 +32,1 @@\n-import hat.LocalMesh1D;\n+import hat.Local1D;\n@@ -130,2 +130,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(16));\n-        cc.dispatchKernel(computeRange, kc -> reduceGlobal(kc, input, partialSums));\n+        NDRange ndRange = NDRange.of(new Global1D(32), new Local1D(16));\n+        cc.dispatchKernel(ndRange, kc -> reduceGlobal(kc, input, partialSums));\n@@ -137,2 +137,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(16));\n-        cc.dispatchKernel(computeRange, kc -> reduceLocal(kc, input, partialSums));\n+        NDRange ndRange = NDRange.of(new Global1D(32), new Local1D(16));\n+        cc.dispatchKernel(ndRange, kc -> reduceLocal(kc, input, partialSums));\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestReductions.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n+import hat.NDRange;\n+import hat.Global1D;\n@@ -32,1 +32,1 @@\n-import hat.LocalMesh1D;\n+import hat.Local1D;\n@@ -269,2 +269,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4), new LocalMesh1D(128));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps01(kernelContext, a, b, c));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4), new Local1D(128));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps01(kernelContext, a, b, c));\n@@ -276,2 +276,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps02(kernelContext, a, b));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps02(kernelContext, a, b));\n@@ -283,2 +283,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps03(kernelContext, a, b));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps03(kernelContext, a, b));\n@@ -290,2 +290,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps04(kernelContext, a, b));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps04(kernelContext, a, b));\n@@ -297,2 +297,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps05(kernelContext, a, b, c));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps05(kernelContext, a, b, c));\n@@ -304,2 +304,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps06(kernelContext, a, b, c));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps06(kernelContext, a, b, c));\n@@ -312,2 +312,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps07(kernelContext, a, b, c));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps07(kernelContext, a, b, c));\n@@ -319,2 +319,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps08(kernelContext, a, b, c));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps08(kernelContext, a, b, c));\n@@ -326,2 +326,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps09(kernelContext, a, b, c));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps09(kernelContext, a, b, c));\n@@ -333,2 +333,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps10(kernelContext, a, b));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps10(kernelContext, a, b));\n@@ -340,2 +340,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps11(kernelContext, a, b));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps11(kernelContext, a, b));\n@@ -347,2 +347,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps12(kernelContext, a, b));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps12(kernelContext, a, b));\n@@ -354,2 +354,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps14(kernelContext, a));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps14(kernelContext, a));\n@@ -361,2 +361,2 @@\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps15(kernelContext, a));\n+        NDRange ndRange = NDRange.of(new Global1D(size\/4));\n+        cc.dispatchKernel(ndRange, kernelContext -> TestVectorTypes.vectorOps15(kernelContext, a));\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorTypes.java","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.NDRange;\n@@ -71,1 +72,1 @@\n-                    s32Array2D.width()*s32Array2D.height(), \/\/0..S32Array2D.size()\n+                    NDRange.of(s32Array2D.width()*s32Array2D.height()),  \/\/0..S32Array2D.size()\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/TestJavaHATCodeBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.NDRange;\n@@ -32,1 +33,0 @@\n-import hat.tools.textmodel.ui.FuncOpViewer;\n@@ -69,1 +69,1 @@\n-                    s32Array2D.width() * s32Array2D.height(), \/\/0..S32Array2D.size()\n+                    NDRange.of(s32Array2D.width() * s32Array2D.height()),         \/\/0..S32Array2D.size()\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/textmodel\/ui\/TestFuncOpViewer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}