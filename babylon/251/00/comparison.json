{"files":[{"patch":"@@ -0,0 +1,1 @@\n+thirdparty\/\n","filename":"hat\/.gitignore","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+set(CMAKE_CXX_STANDARD 14)\n@@ -4,1 +5,8 @@\n-add_custom_target(copy_libs)\n+if (\"${HAT_TARGET}EMPTY\" STREQUAL \"EMPTY\")\n+    message(\"HAT_TARGET is empty\")\n+else ()\n+    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${HAT_TARGET})\n+    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${HAT_TARGET})\n+    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${HAT_TARGET})\n+    message(\"Binaries in ${HAT_TARGET} HAT_TARGET\")\n+endif ()\n@@ -11,2 +19,0 @@\n-set(CMAKE_CXX_STANDARD 14)\n-\n","filename":"hat\/backends\/CMakeLists.txt","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -9,0 +9,1 @@\n+\n@@ -13,0 +14,1 @@\n+\n@@ -18,1 +20,0 @@\n-\n@@ -21,2 +22,2 @@\n-\t    ${SHARED_BACKEND}\/include\n-\t    ${CUDA_BACKEND}\/include\n+\t        ${SHARED_BACKEND}\/include\n+\t        ${CUDA_BACKEND}\/include\n@@ -49,7 +50,0 @@\n-    add_custom_target(cuda_natives DEPENDS cuda_info cuda_backend)\n-\n-    add_custom_target(copy_cuda_libs DEPENDS cuda_info cuda_backend\n-        COMMAND cp ${CMAKE_BINARY_DIR}\/cuda\/libcuda_backend.* ${HAT_TARGET}\n-        COMMAND cp ${CMAKE_BINARY_DIR}\/cuda\/cuda_info ${HAT_TARGET}\n-   )\n-   add_dependencies(copy_libs copy_cuda_libs)\n","filename":"hat\/backends\/cuda\/CMakeLists.txt","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -6,1 +6,2 @@\n-find_package(OpenCL)\n+#find_package(OpenCL)\n+\n@@ -11,0 +12,1 @@\n+\n@@ -41,6 +43,1 @@\n-add_custom_target(mock_natives DEPENDS mock_info mock_backend)\n-add_custom_target(copy_mock_libs DEPENDS mock_info mock_backend\n-    COMMAND cp ${CMAKE_BINARY_DIR}\/mock\/libmock_backend.* ${HAT_TARGET}\n-    COMMAND cp ${CMAKE_BINARY_DIR}\/mock\/mock_info ${HAT_TARGET}\n-)\n-add_dependencies(copy_libs copy_mock_libs)\n+\n","filename":"hat\/backends\/mock\/CMakeLists.txt","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -13,0 +13,1 @@\n+\n@@ -51,6 +52,0 @@\n-    add_custom_target(opencl_natives DEPENDS opencl_info opencl_backend)\n-    add_custom_target(copy_opencl_libs DEPENDS opencl_info opencl_backend\n-       COMMAND cp ${CMAKE_BINARY_DIR}\/opencl\/libopencl_backend.*  ${HAT_TARGET}\n-       COMMAND cp ${CMAKE_BINARY_DIR}\/opencl\/opencl_info ${HAT_TARGET}\n-    )\n-    add_dependencies(copy_libs copy_opencl_libs)\n","filename":"hat\/backends\/opencl\/CMakeLists.txt","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -85,16 +85,0 @@\n-              <execution>\n-                <id>cmake_install_copy_libs<\/id>\n-                <phase>install<\/phase>\n-                <goals>\n-                   <goal>exec<\/goal>\n-                <\/goals>\n-                <configuration>\n-                   <executable>cmake<\/executable>\n-                   <arguments>\n-                      <argument>--build<\/argument>\n-                      <argument>cmake-build-debug<\/argument>\n-                      <argument>--target<\/argument>\n-                      <argument>copy_libs<\/argument>\n-                   <\/arguments>\n-                <\/configuration>\n-             <\/execution>\n","filename":"hat\/backends\/pom.xml","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -18,1 +18,0 @@\n-\n@@ -49,1 +48,0 @@\n-    add_custom_target(ptx_natives DEPENDS ptx_info ptx_backend)\n@@ -51,5 +49,0 @@\n-    add_custom_target(copy_ptx_libs DEPENDS ptx_info ptx_backend\n-        COMMAND cp ${CMAKE_BINARY_DIR}\/ptx\/libptx_backend.* ${HAT_TARGET}\n-        COMMAND cp ${CMAKE_BINARY_DIR}\/ptx\/ptx_info ${HAT_TARGET}\n-    ) \n-    add_dependencies(copy_libs copy_ptx_libs)\n","filename":"hat\/backends\/ptx\/CMakeLists.txt","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6,1 +6,0 @@\n-find_package(OpenCL)\n@@ -11,0 +10,1 @@\n+\n@@ -32,1 +32,0 @@\n-\n@@ -41,8 +40,0 @@\n-add_custom_target(spirv_natives DEPENDS spirv_info spirv_backend)\n-\n-add_custom_target(copy_spirv_libs DEPENDS spirv_info spirv_backend\n-   COMMAND cp ${CMAKE_BINARY_DIR}\/spirv\/libspirv_backend.* ${HAT_TARGET}\n-   COMMAND cp ${CMAKE_BINARY_DIR}\/spirv\/spirv_info ${HAT_TARGET}\n-)\n-add_dependencies(copy_libs copy_spirv_libs)\n-\n","filename":"hat\/backends\/spirv\/CMakeLists.txt","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-#!\/usr\/bin\/env java --enable-preview --source 24 \n+#!\/usr\/bin\/env java --enable-preview --source 24 --class-path bldr\/classes\n@@ -28,130 +28,1 @@\n-\n-\n-static String join(List<Path> paths, char separator){\n-   StringBuilder sb = new StringBuilder();\n-   paths.forEach(path -> {\n-      if (!sb.isEmpty()) {\n-         sb.append(separator);\n-      }\n-      sb.append(path);\n-   });\n-   return sb.toString();\n-}\n-\n-static void addEntry(JarOutputStream jarStream, Path root, Path path){\n-    try{\n-       var attributes = Files.readAttributes(path, PosixFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n-       var entry = new JarEntry(root.relativize(path).toString()+(attributes.isDirectory()?\"\/\":\"\"));\n-       entry.setTime(attributes.lastModifiedTime().toMillis());\n-       jarStream.putNextEntry(entry);\n-       if (attributes.isRegularFile()){\n-          Files.newInputStream(path).transferTo(jarStream);\n-       }\n-       jarStream.closeEntry();\n-    }catch(IOException ioe){\n-      println(ioe);\n-    }\n-}\n-\n-\n-static Path javacjar(Path jar, Path classesDir, List<Path> sourcePath, List<Path> classPath, List<Path> resourcePath) throws IOException{\n-     var src = new ArrayList<Path>();\n-     sourcePath.forEach(path->{\n-         try{\n-            Files.walk(path).forEach(s->{if (s.toString().endsWith(\".java\")){src.add(s);}});\n-         }catch(IOException ioe){\n-            println(ioe);\n-         }\n-     });\n-\n-     if (Files.exists(classesDir)) {\n-       Files.walk(classesDir).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n-     }\n-     Files.createDirectories(classesDir);\n-     DiagnosticListener<JavaFileObject> dl = (diagnostic)-> System.out.println(diagnostic.getKind() + \" \" + diagnostic.getMessage(null));\n-\n-     var opts = new ArrayList<String>(List.of(\n-         \"--source\",\"24\",\n-         \"--enable-preview\",\n-         \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-         \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n-         \"-d\", classesDir.toString(),\n-         \"--source-path\", join(sourcePath,':')\n-     ));\n-     if (!classPath.isEmpty()){ \n-        opts.addAll(List.of(\n-           \"--class-path\", join(classPath,':')\n-        ));\n-     }\n-     \/\/println(opts);\n-     \n-     List<Path> pathsToJar = new ArrayList<>();\n-     JavaCompiler javac = javax.tools.ToolProvider.getSystemJavaCompiler();\n-     ((com.sun.source.util.JavacTask) javac.getTask(new PrintWriter(System.err), javac.getStandardFileManager(dl, null, null), dl, opts, null,\n-        src.stream().map(path->\n-             new SimpleJavaFileObject(path.toUri(),JavaFileObject.Kind.SOURCE){\n-                public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                   try {\n-                     return Files.readString(Path.of(toUri()));\n-                   } catch (IOException e) {\n-                      throw new RuntimeException(e);\n-                  }\n-             }\n-          }).toList()\n-     )).generate().forEach(fileObject->pathsToJar.add(Path.of(fileObject.toUri())));\n-\n-     var jarStream = new JarOutputStream(Files.newOutputStream(jar));\n-     var setOfDirs = new HashSet<Path>();\n-     pathsToJar.stream().sorted().forEach(path -> {\n-          var parentDir = path.getParent();\n-          if (!setOfDirs.contains(parentDir)){\n-             setOfDirs.add(parentDir);\n-             addEntry(jarStream, classesDir, parentDir);\n-          }\n-          addEntry(jarStream, classesDir, path);\n-     });\n-     resourcePath.stream().sorted().forEach(resourceDir->{\n-          if (Files.isDirectory(resourceDir)){\n-             \/\/println(\"Trying \"+resourceDir);\n-             try{\n-               Files.walk(resourceDir).filter(path->Files.isRegularFile(path)).forEach(path->{\n-                 var parentDir = path.getParent();\n-                 if (!setOfDirs.contains(parentDir)){\n-                    setOfDirs.add(parentDir);\n-                    addEntry(jarStream, resourceDir, parentDir);\n-                 }\n-                 addEntry(jarStream, resourceDir, path);\n-               });\n-             }catch(IOException ioe){\n-               println(ioe);\n-             } \n-          \/\/}else{\n-          \/\/ println(\"no resources \"+resourceDir);\n-          }\n-        }\n-     );\n-     jarStream.finish();\n-     jarStream.close();\n-     return jar;\n-}\n-static Path javacjar(Path jar, Path classesDir, List<Path> sourcePath, List<Path> classPath) throws IOException{\n-    return javacjar(jar, classesDir, sourcePath, classPath, List.of( \/*resources*\/));\n-}\n-static Path javacjar(Path jar, Path classesDir, List<Path> sourcePath) throws IOException{\n-    return javacjar(jar, classesDir, sourcePath, List.of( \/*classpath*\/));\n-}\n-\n-static Path path(String name){\n-   return Path.of(name);\n-}\n-\n-static List<Path> paths(Path ...paths){\n-     List<Path> selectedPaths = new ArrayList<>();\n-     Arrays.asList(paths).forEach(path->{\n-        if (Files.isDirectory(path)){\n-           selectedPaths.add(path);\n-        }\n-     });\n-     return selectedPaths;\n-}\n-\n+import static bldr.Bldr.*;\n@@ -159,34 +30,11 @@\n-     var hatDir = path(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\");\n-\n-     Set.of(\"hat\", \"examples\", \"backends\").forEach(dirName->{\n-         try{\n-            Files.walk(Paths.get(dirName)).filter(p->{\n-              var name = p.toString();\n-              return !name.contains(\"cmake-build-debug\")\n-                && !name.contains(\"rleparser\")\n-                && ( name.endsWith(\".java\") || name.endsWith(\".cpp\") || name.endsWith(\".h\"));\n-              }).forEach(path->{\n-                try{\n-                   boolean license = false;\n-                   for (String line: Files.readAllLines(path,  StandardCharsets.UTF_8)){\n-                      if (line.contains(\"\\t\")){\n-                        System.err.println(\"ERR TAB \"+path+\":\"+line);\n-                      }\n-                      if (line.endsWith(\" \")) {\n-                        System.err.println(\"ERR TRAILING WHITESPACE \"+path+\":\"+line);\n-                      }\n-                      if (Pattern.matches(\"^  *(package|import).*$\",line)) { \/\/ I saw this a few times....?\n-                        System.err.println(\"ERR WEIRD INDENT \"+path+\":\"+line);\n-                      }\n-                      if (Pattern.matches(\"^.*Copyright.*202[4-9].*Intel.*$\",line)) { \/\/ not foolproof I know\n-                        license = true;\n-                      }\n-                      if (Pattern.matches(\"^.*Copyright.*202[4-9].*Oracle.*$\",line)) { \/\/ not foolproof I know\n-                        license = true;\n-                      }\n-                   }\n-                   if (!license){\n-                      System.err.println(\"ERR MISSING LICENSE \"+path);\n-                   }\n-                } catch(IOException ioe){\n-                  System.err.println(ioe);\n+       var hatDir = Path.of(System.getProperty(\"user.dir\"));\n+        var licensePattern = Pattern.compile(\"^.*Copyright.*202[4-9].*(Intel|Oracle).*$\");\n+        var eolws = Pattern.compile(\"^.* $\");\n+        var tab = Pattern.compile(\"^.*\\\\t.*\");\n+\n+        paths(hatDir, \"hat\", \"examples\", \"backends\").forEach(dir -> {\n+            paths(dir, path -> !Pattern.matches(\"^.*(-debug|rleparser).*$\", path.toString())\n+                       && Pattern.matches(\"^.*\\\\.(java|cpp|h|hpp)$\", path.toString())\n+            ).stream().map(path -> new TextFile(path)).forEach(textFile -> {\n+                if (!textFile.grep(licensePattern)){\n+                    System.err.println(\"ERR MISSING LICENSE \" + textFile.path());\n@@ -194,0 +42,8 @@\n+                textFile.lines().forEach(line -> {\n+                    if (line.grep(tab)) {\n+                        System.err.println(\"ERR TAB \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n+                    }\n+                    if (line.grep(eolws)) {\n+                        System.err.println(\"ERR TRAILING WHITESPACE \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n+                    }\n+                });\n@@ -195,55 +51,35 @@\n-         } catch(IOException ioe){\n-           System.err.println(ioe);\n-         }\n-      });\n-\n-     \n-     var target = hatDir.resolve(\"build\");\n-\n-     var hatJar = javacjar(\n-         target.resolve(\"hat-1.0.jar\"),\n-         target.resolve(\"hat-1.0.jar.classes\"),\n-         List.of(hatDir.resolve(\"hat\/src\/main\/java\"))\n-     );\n-     println(hatJar);\n-\n-     for (var example: List.of(\"mandel\", \"squares\", \"heal\", \"violajones\", \"life\")){\n-       var exampleJar = javacjar(\n-         target.resolve(\"hat-example-\"+example+\"-1.0.jar\"),\n-         target.resolve(\"hat-example-\"+example+\"-1.0.jar.classes\"),\n-         List.of(hatDir.resolve(\"examples\/\"+example+\"\/src\/main\/java\")),\n-         List.of(hatJar),\n-         List.of(hatDir.resolve(\"examples\/\"+example+\"\/src\/main\/resources\"))\n-       );\n-       println(exampleJar);\n-     }\n-     var backendsDir = hatDir.resolve(\"backends\");\n-     for (var backend: List.of(\"opencl\")){\n-       var backendDir = backendsDir.resolve(backend);\n-       var backendJar = javacjar(\n-         target.resolve(\"hat-backend-\"+backend+\"-1.0.jar\"),\n-         target.resolve(\"hat-backend-\"+backend+\"-1.0.jar.classes\"),\n-         List.of(backendDir.resolve(\"src\/main\/java\")),\n-         List.of(hatJar),\n-         List.of(backendDir.resolve(\"src\/main\/resources\"))\n-       );\n-       println(backendJar);\n-     }\n-  \n-     var cmakeBldDebugDir = backendsDir.resolve(\"bld-debug\");\n-     Files.createDirectories(cmakeBldDebugDir);\n-     var cmakeInit  = new ProcessBuilder()\n-        .directory(backendsDir.toFile())\n-        .inheritIO()\n-        .command(\"cmake\",\"-B\", cmakeBldDebugDir.getFileName().toString(), \"-DHAT_TARGET=\"+target)\n-        .start();\n-    cmakeInit.waitFor();\n-\n-     var cmakeBuild  = new ProcessBuilder()\n-        .directory(backendsDir.toFile())\n-        .inheritIO()\n-        .command(\"cmake\",\"--build\", cmakeBldDebugDir.getFileName().toString(),\"--target\", \"copy_libs\")\n-        .start();\n-     cmakeBuild.waitFor();\n-\n-}\n+        });\n+\n+        var target = mkdir(rmdir(path(hatDir, \"build\")));\n+        var hatJavacOpts = List.of(\n+                \"--source\", \"24\",\n+                \"--enable-preview\",\n+                \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+                \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+        );\n+\n+        var hatJarResult = javacjar($ -> $\n+                .opts(hatJavacOpts)\n+                .jar(path(target, \"hat-1.0.jar\"))\n+                .source_path(path(hatDir, \"hat\/src\/main\/java\"))\n+        );\n+        println(hatJarResult.jar);\n+        for (var exampleDir : paths(path(hatDir, \"examples\"), \"mandel\", \"squares\", \"heal\", \"violajones\", \"life\")) {\n+            javacjar($ -> $\n+                    .opts(hatJavacOpts)\n+                    .jar(path(target, \"hat-example-\" + exampleDir.getFileName() + \"-1.0.jar\"))\n+                    .source_path(path(exampleDir, \"src\/main\/java\"))\n+                    .class_path(hatJarResult.jar)\n+                    .resource_path(path(exampleDir, \"src\/main\/resources\"))\n+            );\n+        }\n+        var backendsDir = path(hatDir, \"backends\");\n+        for (var backendDir : paths(backendsDir, \"opencl\", \"ptx\")) {\n+            javacjar($ -> $\n+                    .opts(hatJavacOpts)\n+                    .jar(path(target, \"hat-backend-\" + backendDir.getFileName() + \"-1.0.jar\"))\n+                    .source_path(path(backendDir, \"src\/main\/java\"))\n+                    .class_path(hatJarResult.jar)\n+                    .resource_path(path(backendDir, \"src\/main\/resources\"))\n+            );\n+        }\n@@ -251,0 +87,7 @@\n+        var cmakeBldDebugDir = backendsDir.resolve(\"bld-debug\");\n+        if (!existingDir(cmakeBldDebugDir)) {\n+            mkdir(cmakeBldDebugDir);\n+            cmake($ -> $.cwd(backendsDir)._B(cmakeBldDebugDir).opts(\"-DHAT_TARGET=\" + target));\n+        }\n+        cmake($ -> $.cwd(backendsDir).__build(cmakeBldDebugDir));\n+  } \n","filename":"hat\/bld","additions":63,"deletions":220,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+classes\n","filename":"hat\/bldr\/.gitignore","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,701 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package bldr;\n+\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpression;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.PosixFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import static java.io.IO.println;\n+\n+public class Bldr {\n+    public record OS(String arch, String name, String version) {\n+    }\n+\n+    public static OS os = new OS(System.getProperty(\"os.arch\"), System.getProperty(\"os.name\"), System.getProperty(\"os.version\"));\n+\n+    public record Java(String version, File home) {\n+    }\n+\n+    public static Java java = new Java(System.getProperty(\"java.version\"), new File(System.getProperty(\"java.home\")));\n+\n+    public record User(File home, File pwd) {\n+    }\n+\n+    public static User user = new User(new File(System.getProperty(\"user.home\")), new File(System.getProperty(\"user.dir\")));\n+\n+\n+    public static class XMLNode {\n+        org.w3c.dom.Element element;\n+        List<XMLNode> children = new ArrayList<>();\n+        Map<String, String> attrMap = new HashMap<>();\n+\n+        XMLNode(org.w3c.dom.Element element) {\n+            this.element = element;\n+            this.element.normalize();\n+            for (int i = 0; i < this.element.getChildNodes().getLength(); i++) {\n+                if (this.element.getChildNodes().item(i) instanceof org.w3c.dom.Element e) {\n+                    this.children.add(new XMLNode(e));\n+                }\n+            }\n+            for (int i = 0; i < element.getAttributes().getLength(); i++) {\n+                if (element.getAttributes().item(i) instanceof org.w3c.dom.Attr attr) {\n+                    this.attrMap.put(attr.getName(), attr.getValue());\n+                }\n+            }\n+        }\n+\n+        public boolean hasAttr(String name) {\n+            return attrMap.containsKey(name);\n+        }\n+\n+        public String attr(String name) {\n+            return attrMap.get(name);\n+        }\n+\n+        XMLNode(File file) throws Throwable {\n+            this(javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file).getDocumentElement());\n+        }\n+\n+        XMLNode(URL url) throws Throwable {\n+            this(javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(url.openStream()).getDocumentElement());\n+        }\n+\n+        void write(File file) throws Throwable {\n+            var transformer = TransformerFactory.newInstance().newTransformer();\n+            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n+            transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n+            transformer.transform(new DOMSource(element.getOwnerDocument()), new StreamResult(file));\n+        }\n+\n+        XPathExpression xpath(String expression) throws XPathExpressionException {\n+            XPath xpath = XPathFactory.newInstance().newXPath();\n+            return xpath.compile(expression);\n+        }\n+\n+        Node node(XPathExpression xPathExpression) throws XPathExpressionException {\n+            return (Node) xPathExpression.evaluate(this.element, XPathConstants.NODE);\n+        }\n+\n+        String string(XPathExpression xPathExpression) throws XPathExpressionException {\n+            return (String) xPathExpression.evaluate(this.element, XPathConstants.STRING);\n+        }\n+\n+        NodeList nodeList(XPathExpression xPathExpression) throws XPathExpressionException {\n+            return (NodeList) xPathExpression.evaluate(this.element, XPathConstants.NODESET);\n+        }\n+    }\n+\n+    static class POM {\n+\n+        static Pattern varPattern = Pattern.compile(\"\\\\$\\\\{([^}]*)\\\\}\");\n+\n+        static public String varExpand(Map<String, String> props, String value) { \/\/ recurse\n+            String result = value;\n+            if (varPattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n+                var v = matcher.group(1);\n+                result = varExpand(props, value.substring(0, matcher.start())\n+                        + (v.startsWith(\"env\")\n+                        ? System.getenv(v.substring(4))\n+                        : props.get(v))\n+                        + value.substring(matcher.end()));\n+                \/\/out.println(\"incomming ='\"+value+\"'  v= '\"+v+\"' value='\"+value+\"'->'\"+result+\"'\");\n+            }\n+            return result;\n+        }\n+\n+        POM(Path dir) throws Throwable {\n+            var topPom = new XMLNode(new File(dir.toFile(), \"pom.xml\"));\n+            var babylonDirKey = \"babylon.dir\";\n+            var spirvDirKey = \"beehive.spirv.toolkit.dir\";\n+            var hatDirKey = \"hat.dir\";\n+            var interestingKeys = Set.of(spirvDirKey, babylonDirKey, hatDirKey);\n+            var requiredDirKeys = Set.of(babylonDirKey, hatDirKey);\n+            var dirKeyToDirMap = new HashMap<String, File>();\n+            var props = new HashMap<String, String>();\n+\n+            topPom.children.stream().filter(e -> e.element.getNodeName().equals(\"properties\")).forEach(properties ->\n+                    properties.children.stream().forEach(property -> {\n+                        var key = property.element.getNodeName();\n+                        var value = varExpand(props, property.element.getTextContent());\n+                        props.put(key, value);\n+                        if (interestingKeys.contains(key)) {\n+                            var file = new File(value);\n+                            if (requiredDirKeys.contains(key) && !file.exists()) {\n+                                System.err.println(\"ERR pom.xml has property '\" + key + \"' with value '\" + value + \"' but that dir does not exists!\");\n+                                System.exit(1);\n+                            }\n+                            dirKeyToDirMap.put(key, file);\n+                        }\n+                    })\n+            );\n+            for (var key : requiredDirKeys) {\n+                if (!props.containsKey(key)) {\n+                    System.err.println(\"ERR pom.xml expected to have property '\" + key + \"' \");\n+                    System.exit(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static String pathCharSeparated(List<Path> paths) {\n+        StringBuilder sb = new StringBuilder();\n+        paths.forEach(path -> {\n+            if (!sb.isEmpty()) {\n+                sb.append(File.pathSeparatorChar);\n+            }\n+            sb.append(path);\n+        });\n+        return sb.toString();\n+    }\n+\n+    public static Path rmdir(Path path) {\n+        try {\n+            if (Files.exists(path)) {\n+                Files.walk(path).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n+            }\n+        } catch (IOException ioe) {\n+            System.out.println(ioe);\n+        }\n+        return path;\n+    }\n+\n+\n+    public static class JavaJarConfig {\n+        public Path jar;\n+        public List<String> opts = new ArrayList<>();\n+        public Path classesDir;\n+        public List<Path> sourcePath;\n+        public List<Path> classPath;\n+        public List<Path> resourcePath;\n+\n+        public JavaJarConfig jar(Path jar) {\n+            this.jar = jar;\n+            return this;\n+        }\n+\n+        public JavaJarConfig opts(List<String> opts) {\n+            this.opts.addAll(opts);\n+            return this;\n+        }\n+\n+        public JavaJarConfig opts(String... opts) {\n+            opts(Arrays.asList(opts));\n+            return this;\n+        }\n+\n+        public JavaJarConfig source_path(Path... sourcePaths) {\n+            this.sourcePath = new ArrayList<>(Arrays.asList(sourcePaths));\n+            return this;\n+        }\n+\n+        public JavaJarConfig class_path(Path... classPaths) {\n+            this.classPath = new ArrayList<>(Arrays.asList(classPaths));\n+            return this;\n+        }\n+\n+        public JavaJarConfig resource_path(Path... resourcePaths) {\n+            this.resourcePath = new ArrayList<>(Arrays.asList(resourcePaths));\n+            return this;\n+        }\n+\n+        public JavaJarConfig resourcepathIgnoreIfNon(Path... resourcePaths) {\n+            this.resourcePath = new ArrayList<>(Arrays.asList(resourcePaths));\n+            return this;\n+        }\n+    }\n+\n+    public static JavaJarConfig javacjar(Consumer<JavaJarConfig> jjb) throws IOException {\n+        JavaJarConfig builder = new JavaJarConfig();\n+        jjb.accept(builder);\n+        if (builder.classesDir == null) {\n+            builder.classesDir = builder.jar.resolveSibling(builder.jar.getFileName().toString() + \".classes\");\n+        }\n+        builder.opts.addAll(List.of(\"-d\", builder.classesDir.toString()));\n+        mkdir(rmdir(builder.classesDir));\n+\n+        if (builder.classPath != null) {\n+            builder.opts.addAll(List.of(\"--class-path\", pathCharSeparated(builder.classPath)));\n+        }\n+\n+        builder.opts.addAll(List.of(\"--source-path\", pathCharSeparated(builder.sourcePath)));\n+        var src = new ArrayList<Path>();\n+        builder.sourcePath.forEach(entry ->\n+                src.addAll(paths(entry, path -> path.toString().endsWith(\".java\")))\n+        );\n+        if (builder.resourcePath == null) {\n+            builder.resourcePath = new ArrayList<>();\n+        }\n+        DiagnosticListener<JavaFileObject> dl = (diagnostic) -> {\n+            if (!diagnostic.getKind().equals(Diagnostic.Kind.NOTE)) {\n+                System.out.println(diagnostic.getKind()\n+                        + \" \" + diagnostic.getLineNumber() + \":\" + diagnostic.getColumnNumber() + \" \" + diagnostic.getMessage(null));\n+            }\n+        };\n+\n+        \/\/ System.out.println(builder.opts);\n+        record RootAndPath(Path root, Path path) {\n+            Path relativize() {\n+                return root().relativize(path());\n+            }\n+        }\n+        List<RootAndPath> pathsToJar = new ArrayList<>();\n+        JavaCompiler javac = javax.tools.ToolProvider.getSystemJavaCompiler();\n+        ((com.sun.source.util.JavacTask) javac.getTask(new PrintWriter(System.err), javac.getStandardFileManager(dl, null, null), dl, builder.opts, null,\n+                src.stream().map(path ->\n+                        new SimpleJavaFileObject(path.toUri(), JavaFileObject.Kind.SOURCE) {\n+                            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                                try {\n+                                    return Files.readString(Path.of(toUri()));\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                            }\n+                        }).toList()\n+        )).generate().forEach(fileObject -> pathsToJar.add(new RootAndPath(builder.classesDir, Path.of(fileObject.toUri()))));\n+\n+        var jarStream = new JarOutputStream(Files.newOutputStream(builder.jar));\n+        var setOfDirs = new HashSet<Path>();\n+        builder.resourcePath.stream().sorted().forEach(resourceDir -> {\n+                    if (Files.isDirectory(resourceDir)) {\n+                        paths(resourceDir, Files::isRegularFile).forEach(path -> pathsToJar.add(new RootAndPath(resourceDir, path)));\n+                    }\n+                }\n+        );\n+\n+        pathsToJar.stream().sorted((l, r) -> l.path().compareTo(r.path)).forEach(rootAndPath -> {\n+            var parentDir = rootAndPath.path().getParent();\n+            try {\n+                if (!setOfDirs.contains(parentDir)) {\n+                    setOfDirs.add(parentDir);\n+                    PosixFileAttributes attributes = Files.readAttributes(rootAndPath.path(), PosixFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n+                    var entry = new JarEntry(rootAndPath.relativize() + \"\/\");\n+                    entry.setTime(attributes.lastModifiedTime().toMillis());\n+                    jarStream.putNextEntry(entry);\n+                    jarStream.closeEntry();\n+                }\n+                PosixFileAttributes attributes = Files.readAttributes(rootAndPath.path(), PosixFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n+                var entry = new JarEntry(rootAndPath.relativize().toString());\n+                entry.setTime(attributes.lastModifiedTime().toMillis());\n+                jarStream.putNextEntry(entry);\n+                if (attributes.isRegularFile()) {\n+                    Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n+                }\n+                jarStream.closeEntry();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        jarStream.finish();\n+        jarStream.close();\n+        return builder;\n+    }\n+\n+    public static Path path(String name) {\n+        return Path.of(name);\n+    }\n+\n+    public static Path path(Path parent, String name) {\n+        return parent.resolve(name);\n+    }\n+\n+    public static List<Path> paths(Path... paths) {\n+        List<Path> selectedPaths = new ArrayList<>();\n+        Arrays.asList(paths).forEach(path -> {\n+            if (Files.isDirectory(path)) {\n+                selectedPaths.add(path);\n+            }\n+        });\n+        return selectedPaths;\n+    }\n+\n+    public static List<Path> paths(Path parent, String... names) {\n+        List<Path> selectedPaths = new ArrayList<>();\n+        Arrays.asList(names).forEach(name -> {\n+            Path path = path(parent, name);\n+            if (Files.isDirectory(path)) {\n+                selectedPaths.add(path);\n+            }\n+        });\n+        return selectedPaths;\n+    }\n+\n+    public static List<Path> paths(Path path, Predicate<Path> predicate) {\n+        try {\n+            return Files.walk(path).filter(predicate).toList();\n+        } catch (IOException ioe) {\n+            throw new IllegalStateException(ioe);\n+        }\n+    }\n+\n+    public static class CMakeConfig {\n+        public List<String> opts = new ArrayList<>(List.of(\"cmake\"));\n+        public Path cmakeBldDebugDir;\n+        public Path cwd;\n+\n+        public CMakeConfig _B(Path cmakeBldDebugDir) {\n+            this.cmakeBldDebugDir = cmakeBldDebugDir;\n+            opts.addAll(List.of(\"-B\", cmakeBldDebugDir.getFileName().toString()));\n+            return this;\n+        }\n+\n+        public CMakeConfig __build(Path cmakeBldDebugDir) {\n+            this.cmakeBldDebugDir = cmakeBldDebugDir;\n+            opts.addAll(List.of(\"--build\", cmakeBldDebugDir.getFileName().toString()));\n+            return this;\n+        }\n+\n+        public CMakeConfig cwd(Path cwd) {\n+            this.cwd = cwd;\n+            return this;\n+        }\n+\n+        public CMakeConfig opts(String... opts) {\n+            this.opts.addAll(Arrays.asList(opts));\n+            return this;\n+        }\n+    }\n+\n+    public static void cmake(Consumer<CMakeConfig> cMakeConfigConsumer) {\n+        CMakeConfig cmakeConfig = new CMakeConfig();\n+        cMakeConfigConsumer.accept(cmakeConfig);\n+        try {\n+            Files.createDirectories(cmakeConfig.cmakeBldDebugDir);\n+            \/\/System.out.println(cmakeConfig.opts);\n+            var cmakeInit = new ProcessBuilder()\n+                    .directory(cmakeConfig.cwd.toFile())\n+                    .inheritIO()\n+                    .command(cmakeConfig.opts)\n+                    .start();\n+            cmakeInit.waitFor();\n+        } catch (InterruptedException ie) {\n+            System.out.println(ie);\n+        } catch (IOException ioe) {\n+            System.out.println(ioe);\n+        }\n+    }\n+\n+    public static boolean existingDir(Path dir) {\n+        return Files.exists(dir);\n+    }\n+\n+    public static Path mkdir(Path path) {\n+        try {\n+            return Files.createDirectories(path);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+\n+    public record TextFile(Path path) {\n+        public Stream<Line> lines() {\n+            try {\n+                int num[] = new int[]{1};\n+                return Files.readAllLines(path(), StandardCharsets.UTF_8).stream().map(line -> new Line(line, num[0]++));\n+            } catch (IOException ioe) {\n+                System.out.println(ioe);\n+                return new ArrayList<Line>().stream();\n+            }\n+        }\n+\n+        public boolean grep(Pattern pattern) {\n+            return lines().anyMatch(line -> pattern.matcher(line.line).matches());\n+        }\n+    }\n+\n+    public record Line(String line, int num) {\n+        public boolean grep(Pattern pattern) {\n+            return pattern.matcher(line()).matches();\n+        }\n+    }\n+\n+    record GroupArtifactVersion(String group, String artifact, String version) {\n+\n+    }\n+\n+    interface RepoNode {\n+        XMLNode xmlNode();\n+\n+        default GroupArtifactVersion groupArtifactVersion() {\n+            try {\n+                var groupIdXPath = xmlNode().xpath(\"groupId\/text()\");\n+                var group = xmlNode().string(groupIdXPath);\n+                var artifactIdXPath = xmlNode().xpath(\"artifactId\/text()\");\n+                var artifact = xmlNode().string(artifactIdXPath);\n+                var versionXPath = xmlNode().xpath(\"version\/text()\");\n+                var version = xmlNode().string(versionXPath);\n+                return new GroupArtifactVersion(group, artifact, version);\n+            } catch (XPathExpressionException xPathExpressionException) {\n+                throw new RuntimeException(xPathExpressionException);\n+            }\n+        }\n+\n+        default String location() {\n+            GroupArtifactVersion groupArtifactVersion = groupArtifactVersion();\n+            return \"https:\/\/repo1.maven.org\/maven2\/\" + groupArtifactVersion.group().replace('.', '\/') + \"\/\" + groupArtifactVersion().artifact() + \"\/\" + groupArtifactVersion.version();\n+        }\n+\n+        default String name(String suffix) {\n+            GroupArtifactVersion groupArtifactVersion = groupArtifactVersion();\n+            return groupArtifactVersion.artifact() + \"-\" + groupArtifactVersion.version + \".\" + suffix;\n+        }\n+\n+        default URL url(String suffix) {\n+            try {\n+                return new URI(location() + \"\/\" + name(suffix)).toURL();\n+            } catch (MalformedURLException e) {\n+                throw new RuntimeException(e);\n+            } catch (URISyntaxException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        default void downloadTo(Path thirdPartyDir, String suffix) {\n+            var thirdPartyFile = thirdPartyDir.resolve(name(suffix));\n+            try {\n+                println(\"Downloading \" + name(suffix) + \"->\" + thirdPartyDir);\n+                url(suffix).openStream().transferTo(Files.newOutputStream(thirdPartyFile));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    record Dependency(XMLNode xmlNode) implements RepoNode {\n+        public URL pomURL() {\n+            try {\n+                GroupArtifactVersion groupArtifactVersion = groupArtifactVersion();\n+                return new URI(\"https:\/\/repo1.maven.org\/maven2\/\" + groupArtifactVersion.group().replace('.', '\/') + \"\/\" + groupArtifactVersion.artifact() + \"\/\" + groupArtifactVersion.version() + \"\/\"\n+                        + groupArtifactVersion.artifact() + \"-\" + groupArtifactVersion.version() + \".pom\").toURL();\n+            } catch (MalformedURLException e) {\n+                throw new RuntimeException(e);\n+            } catch (URISyntaxException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    record RepoPom(XMLNode xmlNode) implements RepoNode {\n+        List<Dependency> dependencies() {\n+            List<Dependency> dependencies = new ArrayList<>();\n+            try {\n+                var dependenciesXPath = xmlNode().xpath(\"\/project\/dependencies\/dependency\");\n+                var nodeList = xmlNode().nodeList(dependenciesXPath);\n+                for (int i = 0; i < nodeList.getLength(); i++) {\n+                    var node = nodeList.item(i);\n+                    dependencies.add(new Dependency(new XMLNode((Element) node)));\n+                }\n+                return dependencies;\n+            } catch (XPathExpressionException xPathExpressionException) {\n+                throw new RuntimeException(xPathExpressionException);\n+            }\n+        }\n+    }\n+\n+    public static class Repo {\n+        Path dir;\n+\n+        Repo(Path dir) {\n+            this.dir = dir;\n+        }\n+\n+        Map<GroupArtifactVersion, Path> map = new HashMap<>();\n+\n+        RepoPom get(String groupId, String artifactId, String version) {\n+            try {\n+                var pom = new RepoPom(new XMLNode(new URI(\"https:\/\/repo1.maven.org\/maven2\/\" + groupId.replace('.', '\/') + \"\/\"\n+                        + artifactId + \"\/\" + version + \"\/\"\n+                        + artifactId + \"-\" + version + \".pom\").toURL()));\n+                return pom;\n+            } catch (Throwable exception) {\n+                throw new RuntimeException(exception);\n+            }\n+\n+        }\n+\n+    }\n+\n+    \/\/  https:\/\/stackoverflow.com\/questions\/23272861\/how-to-call-testng-xml-from-java-main-method\n+    public static void main(String[] args) throws Throwable {\n+\n+        var hatDir = path(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\");\n+        var repo = new Repo(mkdir(rmdir(hatDir.resolve(\"thirdparty\"))));\n+        GroupArtifactVersion g= new GroupArtifactVersion(\"org.testng\", \"testng\", \"7.1.0\");\n+        GroupArtifactVersion aparapi = new GroupArtifactVersion(\"com.aparapi\",\"aparapi\",\"3.0.2\");\n+        GroupArtifactVersion aparapi_jni = new GroupArtifactVersion(\"com.aparapi\",\"aparapi-jni\",\"1.4.3\");\n+        GroupArtifactVersion aparapi_examples = new GroupArtifactVersion(\"com.aparapi\",\"aparapi-examples\",\"3.0.0\");\n+        RepoPom testng = repo.get(\"org.testng\", \"testng\", \"7.1.0\");\n+\n+        \/\/  var url = new URI(\"https:\/\/repo1.maven.org\/maven2\/org\/testng\/testng\/7.1.0\/testng-7.1.0.pom\").toURL();\n+        \/\/  var node = new XMLNode(url);\n+        \/\/  RepoPom testng = new RepoPom(new XMLNode(new URI(\"https:\/\/repo1.maven.org\/maven2\/org\/testng\/testng\/7.1.0\/testng-7.1.0.pom\").toURL()));\n+        testng.downloadTo(repo.dir, \"jar\");\n+        \/\/ testng.dependencies().stream().forEach(dependency->println(dependency.group()));\n+        \/\/ testng.dependencies().stream().forEach(dependency->println(dependency.pomURL()));\n+\n+        \/\/ https:\/\/repo1.maven.org\/maven2\/org\/testng\/testng\/7.1.0\/testng-7.1.0.jar\n+        \/*\n+        <project>\n+          <groupId>org.testng<\/groupId>\n+          <artifactId>testng<\/artifactId>\n+          <version>7.1.0<\/version>\n+          <name>testng<\/name>\n+          <description>Testing framework for Java<\/description>\n+          <url>https:\/\/testng.org<\/url>\n+\n+          <dependencies>\n+             <dependency>\n+                <groupId>com.beust<\/groupId>\n+                <artifactId>jcommander<\/artifactId>\n+                <version>1.72<\/version>\n+                <scope>compile<\/scope>\n+             <\/dependency>\n+<dependency>\n+<groupId>com.google.inject<\/groupId>\n+<artifactId>guice<\/artifactId>\n+<version>4.1.0<\/version>\n+<classifier>no_aop<\/classifier>\n+<scope>compile<\/scope>\n+<\/dependency>\n+<dependency>\n+<groupId>org.yaml<\/groupId>\n+<artifactId>snakeyaml<\/artifactId>\n+<version>1.21<\/version>\n+<scope>compile<\/scope>\n+<\/dependency>\n+<\/dependencies>\n+<\/project>\n+         *\/\n+        \/\/ var hatDir = path(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\");\n+        var licensePattern = Pattern.compile(\"^.*Copyright.*202[4-9].*(Intel|Oracle).*$\");\n+        var eolws = Pattern.compile(\"^.* $\");\n+        var tab = Pattern.compile(\"^.*\\\\t.*\");\n+\n+        paths(hatDir, \"hat\", \"examples\", \"backends\").forEach(dir -> {\n+            paths(dir, path -> !Pattern.matches(\"^.*(-debug|rleparser).*$\", path.toString())\n+                    && Pattern.matches(\"^.*\\\\.(java|cpp|h|hpp)$\", path.toString())\n+            ).stream().map(path -> new TextFile(path)).forEach(textFile -> {\n+                if (!textFile.grep(licensePattern)) {\n+                    System.err.println(\"ERR MISSING LICENSE \" + textFile.path());\n+                }\n+                textFile.lines().forEach(line -> {\n+                    if (line.grep(tab)) {\n+                        System.err.println(\"ERR TAB \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n+                    }\n+                    if (line.grep(eolws)) {\n+                        System.err.println(\"ERR TRAILING WHITESPACE \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n+                    }\n+                });\n+            });\n+        });\n+\n+        var target = mkdir(rmdir(path(hatDir, \"build\")));\n+        var hatJavacOpts = List.of(\n+                \"--source\", \"24\",\n+                \"--enable-preview\",\n+                \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+                \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+        );\n+\n+        var hatJarResult = javacjar($ -> $\n+                .opts(hatJavacOpts)\n+                .jar(path(target, \"hat-1.0.jar\"))\n+                .source_path(path(hatDir, \"hat\/src\/main\/java\"))\n+        );\n+        println(hatJarResult.jar);\n+        for (var exampleDir : paths(path(hatDir, \"examples\"), \"mandel\", \"squares\", \"heal\", \"violajones\", \"life\")) {\n+            javacjar($ -> $\n+                    .opts(hatJavacOpts)\n+                    .jar(path(target, \"hat-example-\" + exampleDir.getFileName() + \"-1.0.jar\"))\n+                    .source_path(path(exampleDir, \"src\/main\/java\"))\n+                    .class_path(hatJarResult.jar)\n+                    .resource_path(path(exampleDir, \"src\/main\/resources\"))\n+            );\n+        }\n+        var backendsDir = path(hatDir, \"backends\");\n+        for (var backendDir : paths(backendsDir, \"opencl\", \"ptx\")) {\n+            javacjar($ -> $\n+                    .opts(hatJavacOpts)\n+                    .jar(path(target, \"hat-backend-\" + backendDir.getFileName() + \"-1.0.jar\"))\n+                    .source_path(path(backendDir, \"src\/main\/java\"))\n+                    .class_path(hatJarResult.jar)\n+                    .resource_path(path(backendDir, \"src\/main\/resources\"))\n+            );\n+        }\n+\n+        var cmakeBldDebugDir = backendsDir.resolve(\"bld-debug\");\n+        if (!existingDir(cmakeBldDebugDir)) {\n+            mkdir(cmakeBldDebugDir);\n+            cmake($ -> $.cwd(backendsDir)._B(cmakeBldDebugDir).opts(\"-DHAT_TARGET=\" + target));\n+        }\n+        cmake($ -> $.cwd(backendsDir).__build(cmakeBldDebugDir).opts(\"--target\", \"copy_libs\"));\n+    }\n+}\n","filename":"hat\/bldr\/src\/main\/java\/bldr\/Bldr.java","additions":701,"deletions":0,"binary":false,"changes":701,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-   if test -d maven-build; then \n+   if test -d maven-build; then\n@@ -37,1 +37,1 @@\n-   elif test -d build; then \n+   elif test -d build; then\n","filename":"hat\/hatrun.bash","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/bldr.iml\" filepath=\"$PROJECT_DIR$\/bldr.iml\" \/>\n","filename":"hat\/intellij\/.idea\/modules.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/bldr\/\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/bldr\/src\/main\/java\" isTestSource=\"false\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/bldr.iml","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+#!\/usr\/bin\/env java --enable-preview --source 24 \n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import module java.compiler;\n+\n+void main(String[] args) throws IOException, InterruptedException {\n+     var pwdDir = Path.of(System.getProperty(\"user.dir\"));\n+     var toolsDir = pwdDir.resolve(\"bldr\");\n+     var classesDir = toolsDir.resolve(\"classes\");\n+     var sourcePath = toolsDir.resolve(\"src\/main\/java\");\n+\n+     if (Files.exists(classesDir)) {\n+        Files.walk(classesDir).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n+     }\n+     Files.createDirectories(classesDir);\n+\n+     var src = new ArrayList<Path>();\n+     Files.walk(sourcePath).forEach(s->{if (s.toString().endsWith(\".java\")){src.add(s);}});\n+\n+     DiagnosticListener<JavaFileObject> dl = (diagnostic)-> System.out.println(diagnostic.getKind() + \" \" + diagnostic.getMessage(null));\n+  \n+     var opts = List.of(\n+           \"--source\",\"24\",\n+           \"--enable-preview\",\n+           \"-d\", classesDir.toString(),\n+           \"--source-path\", sourcePath.toString()\n+     );\n+       \n+     JavaCompiler javac = javax.tools.ToolProvider.getSystemJavaCompiler();\n+     var javacTask = javac.getTask(\n+          new PrintWriter(System.err),\n+          javac.getStandardFileManager(dl, null, null),\n+          dl,\n+          opts,\n+          null,\n+          src.stream().map(path->\n+               new SimpleJavaFileObject(path.toUri(),JavaFileObject.Kind.SOURCE){\n+                  public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                     try {\n+                       return Files.readString(Path.of(toUri()));\n+                     } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+               }\n+           }).toList()\n+     );\n+     ((com.sun.source.util.JavacTask)javacTask).generate();\n+\n+}\n+\n","filename":"hat\/mkbldr","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}