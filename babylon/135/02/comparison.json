{"files":[{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.analysis;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.MethodRef;\n+\n+\/**\n+ * StringConcatTransformer is an {@link java.lang.reflect.code.OpTransformer} that removes concatenation operations\n+ * from blocks and replaces them with equivalent {@link java.lang.StringBuilder} operations. This provides a pathway\n+ * to remove {@link java.lang.reflect.code.op.CoreOp.ConcatOp} for easier lowering to Bytecode.\n+ *\/\n+public class StringConcatTransformer implements OpTransformer {\n+\n+    private static final JavaType SBC_TYPE = JavaType.type(StringBuilder.class);\n+    private static final MethodRef SB_TO_STRING = MethodRef.method(SBC_TYPE, \"toString\", JavaType.J_L_STRING);\n+\n+    record StringAndBuilder(Value string, Value stringBuilder) { }\n+\n+    public StringConcatTransformer() {}\n+\n+    @Override\n+    public Block.Builder apply(Block.Builder builder, Op op) {\n+        if (op instanceof CoreOp.ConcatOp cz) {\n+\n+            Value left = builder.context().getValue(cz.operands().get(0));\n+            Value right = builder.context().getValue(cz.operands().get(1));\n+\n+            Value result = cz.result();\n+\n+            StringAndBuilder newRes = stringBuild(builder, left, right);\n+            builder.context().mapValue(result, newRes.string);\n+        } else {\n+            builder.op(op);\n+        }\n+        return builder;\n+    }\n+\n+    \/\/Uses StringBuilder and Immediate String Value\n+    private static StringAndBuilder stringBuild(Block.Builder builder, Value left, Value right) {\n+        var newB = stringBuilder(builder, left, right);\n+        var toStringInvoke = CoreOp.invoke(SB_TO_STRING, newB);\n+        Value newString = builder.apply(toStringInvoke);\n+        return new StringAndBuilder(newString, newB);\n+    }\n+\n+    private static Value stringBuilder(Block.Builder builder, Value left, Value right) {\n+        CoreOp.NewOp newBuilder = CoreOp._new(FunctionType.functionType(SBC_TYPE));\n+        Value sb = builder.apply(newBuilder);\n+        builder.op(append(sb, left));\n+        builder.op(append(sb, right));\n+        return sb;\n+    }\n+\n+    private static Op append(Value stringBuilder, Value arg) {\n+        MethodRef leftMethodDesc = MethodRef.method(SBC_TYPE, \"append\", SBC_TYPE, arg.type());\n+        return CoreOp.invoke(leftMethodDesc, stringBuilder, arg);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/StringConcatTransformer.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestStringConcatTransform\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.NoInjection;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.StringConcatTransformer;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TestStringConcatTransform {\n+\n+    static final String TESTSTR = \"TESTING STRING\";\n+\n+    static final Map<Class<?>, Object> valMap;\n+\n+    static {\n+        valMap = new HashMap<>();\n+        valMap.put(byte.class, (byte) 42);\n+        valMap.put(short.class, (short) 42);\n+        valMap.put(int.class, 42);\n+        valMap.put(long.class, (long) 42);\n+        valMap.put(float.class, 42f);\n+        valMap.put(double.class, 42d);\n+        valMap.put(char.class, 'z');\n+        valMap.put(boolean.class, false);\n+\n+        valMap.put(Byte.class, (byte) 42);\n+        valMap.put(Short.class, (short) 42);\n+        valMap.put(Integer.class, 42);\n+        valMap.put(Long.class, (long) 42);\n+        valMap.put(Float.class, 42f);\n+        valMap.put(Double.class, 42d);\n+        valMap.put(Character.class, 'z');\n+        valMap.put(Boolean.class, false);\n+\n+        valMap.put(Object.class, new Object() {\n+            @Override\n+            public String toString() {\n+                return \"I'm a test string.\";\n+            }\n+        });\n+        valMap.put(TestObject.class, new TestObject());\n+        valMap.put(String.class, TESTSTR);\n+    }\n+\n+    public static final class TestObject {\n+        TestObject() {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"TestObject String\";\n+        }\n+    }\n+\n+    @Test(dataProvider = \"getClassMethods\")\n+    public void testModelTransform(@NoInjection Method method) {\n+        CoreOp.FuncOp model = method.getCodeModel().orElseThrow();\n+        CoreOp.FuncOp f_transformed = model.transform(new StringConcatTransformer());\n+        Object[] args = prepArgs(method);\n+\n+        f_transformed.writeTo(System.out);\n+\n+        var interpreted = Interpreter.invoke(model, args);\n+        var transformed_interpreted = Interpreter.invoke(f_transformed, args);\n+\n+        Assert.assertEquals(interpreted, transformed_interpreted);\n+\n+    }\n+\n+    @Test(dataProvider = \"getClassMethods\")\n+    public void testSSAModelTransform(@NoInjection Method method) {\n+        CoreOp.FuncOp model = method.getCodeModel().orElseThrow();\n+        CoreOp.FuncOp transformed_model = model.transform(new StringConcatTransformer());\n+        CoreOp.FuncOp ssa_model = generateSSA(model);\n+        CoreOp.FuncOp ssa_transformed_model = ssa_model.transform(new StringConcatTransformer());\n+        Object[] args = prepArgs(method);\n+\n+        var model_interpreted = Interpreter.invoke(model, args);\n+        var transformed_model_interpreted = Interpreter.invoke(transformed_model, args);\n+        var ssa_interpreted = Interpreter.invoke(ssa_model, args);\n+        var ssa_transformed_interpreted = Interpreter.invoke(ssa_transformed_model, args);\n+        Object jvm_interpreted;\n+        try {\n+            jvm_interpreted = method.invoke(null, args);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+        Assert.assertEquals(model_interpreted, transformed_model_interpreted);\n+        Assert.assertEquals(transformed_model_interpreted, ssa_interpreted);\n+        Assert.assertEquals(ssa_interpreted, ssa_transformed_interpreted);\n+        Assert.assertEquals(ssa_transformed_interpreted, jvm_interpreted);\n+    }\n+\n+    public static Object[] prepArgs(Method m) {\n+        Class<?>[] argTypes = m.getParameterTypes();\n+        Object[] args = new Object[argTypes.length];\n+        for (int i = 0; i < argTypes.length; i++) {\n+            args[i] = valMap.get(argTypes[i]);\n+        }\n+        return args;\n+    }\n+\n+    @DataProvider(name = \"getClassMethods\")\n+    public static Object[][] getClassMethods() {\n+        return getTestMethods(TestStringConcatTransform.class);\n+    }\n+\n+    public static Object[][] getTestMethods(Class<?> clazz) {\n+        Object[][] res = Arrays.stream(clazz.getMethods())\n+                .filter((method) -> method.isAnnotationPresent(CodeReflection.class))\n+                .map(m -> new Object[]{m})\n+                .toArray(Object[][]::new);\n+        return res;\n+    }\n+\n+    static CoreOp.FuncOp generateSSA(CoreOp.FuncOp f) {\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+        return lf;\n+    }\n+\n+    @CodeReflection\n+    public static String intConcat(int i, String s) {\n+        return i + s + \"hello\" + 52;\n+    }\n+\n+\n+    @CodeReflection\n+    public static String intConcatAssignment(int i, String s) {\n+        String s1 = i + s;\n+        return s1 + \"hello\" + 52;\n+    }\n+\n+    @CodeReflection\n+    public static String intConcatExprAssignment(int i, String s) {\n+        String r;\n+        String inter = i + (r = s + \"hello\") + 52;\n+        return r + inter;\n+    }\n+\n+    @CodeReflection\n+    public static String intConcatWideExpr(int i, String s) {\n+        String s1 = i + s;\n+        return s1 + \"hello\" + 52 + \"world\" + 26 + \"!\";\n+    }\n+\n+    @CodeReflection\n+    public static String intConcatDoubVar(int i, String s) {\n+        String r;\n+        String inter = i + (r = s + \"hello\") + 52;\n+        String inter2 = i + (r = s + \"hello\") + 52 + inter;\n+        return r + inter2;\n+    }\n+\n+    @CodeReflection\n+    public static String intConcatNestedSplit(int i, String s){\n+        String q, r;\n+        String inter = i + (q = r = s + \"hello\") + 52;\n+        return q + r + inter;\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringConcatTransform.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}