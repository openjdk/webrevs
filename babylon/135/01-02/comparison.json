{"files":[{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.analysis;\n-\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.MethodRef;\n-\n-public class LinearStringContextTransformer implements OpTransformer {\n-\n-    private static final JavaType SBC_TYPE = JavaType.type(StringBuilder.class);\n-    private static final MethodRef SB_TO_STRING = MethodRef.method(SBC_TYPE, \"toString\", JavaType.J_L_STRING);\n-\n-    record StringAndBuilder(Value string, Value stringBuilder) { }\n-\n-    public LinearStringContextTransformer() {}\n-\n-    @Override\n-    public Block.Builder apply(Block.Builder builder, Op op) {\n-        if (op instanceof CoreOp.ConcatOp cz) {\n-\n-            Value left = builder.context().getValue(cz.operands().get(0));\n-            Value right = builder.context().getValue(cz.operands().get(1));\n-\n-            Value result = cz.result();\n-\n-            StringAndBuilder newRes = stringBuild(builder, left, right);\n-            builder.context().mapValue(result, newRes.string);\n-        } else {\n-            builder.op(op);\n-        }\n-        return builder;\n-    }\n-\n-    \/\/Uses StringBuilder and Immediate String Value\n-    private static StringAndBuilder stringBuild(Block.Builder builder, Value left, Value right) {\n-        var newB = stringBuilder(builder, left, right);\n-        var toStringInvoke = CoreOp.invoke(SB_TO_STRING, newB);\n-        Value newString = builder.apply(toStringInvoke);\n-        return new StringAndBuilder(newString, newB);\n-    }\n-\n-    private static Value stringBuilder(Block.Builder builder, Value left, Value right) {\n-        CoreOp.NewOp newBuilder = CoreOp._new(FunctionType.functionType(SBC_TYPE));\n-        Value sb = builder.apply(newBuilder);\n-        builder.op(append(sb, left));\n-        builder.op(append(sb, right));\n-        return sb;\n-    }\n-\n-    private static Op append(Value stringBuilder, Value arg) {\n-        MethodRef leftMethodDesc = MethodRef.method(SBC_TYPE, \"append\", SBC_TYPE, arg.type());\n-        return CoreOp.invoke(leftMethodDesc, stringBuilder, arg);\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/LinearStringContextTransformer.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.analysis;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.MethodRef;\n+\n+\/**\n+ * StringConcatTransformer is an {@link java.lang.reflect.code.OpTransformer} that removes concatenation operations\n+ * from blocks and replaces them with equivalent {@link java.lang.StringBuilder} operations. This provides a pathway\n+ * to remove {@link java.lang.reflect.code.op.CoreOp.ConcatOp} for easier lowering to Bytecode.\n+ *\/\n+public class StringConcatTransformer implements OpTransformer {\n+\n+    private static final JavaType SBC_TYPE = JavaType.type(StringBuilder.class);\n+    private static final MethodRef SB_TO_STRING = MethodRef.method(SBC_TYPE, \"toString\", JavaType.J_L_STRING);\n+\n+    record StringAndBuilder(Value string, Value stringBuilder) { }\n+\n+    public StringConcatTransformer() {}\n+\n+    @Override\n+    public Block.Builder apply(Block.Builder builder, Op op) {\n+        if (op instanceof CoreOp.ConcatOp cz) {\n+\n+            Value left = builder.context().getValue(cz.operands().get(0));\n+            Value right = builder.context().getValue(cz.operands().get(1));\n+\n+            Value result = cz.result();\n+\n+            StringAndBuilder newRes = stringBuild(builder, left, right);\n+            builder.context().mapValue(result, newRes.string);\n+        } else {\n+            builder.op(op);\n+        }\n+        return builder;\n+    }\n+\n+    \/\/Uses StringBuilder and Immediate String Value\n+    private static StringAndBuilder stringBuild(Block.Builder builder, Value left, Value right) {\n+        var newB = stringBuilder(builder, left, right);\n+        var toStringInvoke = CoreOp.invoke(SB_TO_STRING, newB);\n+        Value newString = builder.apply(toStringInvoke);\n+        return new StringAndBuilder(newString, newB);\n+    }\n+\n+    private static Value stringBuilder(Block.Builder builder, Value left, Value right) {\n+        CoreOp.NewOp newBuilder = CoreOp._new(FunctionType.functionType(SBC_TYPE));\n+        Value sb = builder.apply(newBuilder);\n+        builder.op(append(sb, left));\n+        builder.op(append(sb, right));\n+        return sb;\n+    }\n+\n+    private static Op append(Value stringBuilder, Value arg) {\n+        MethodRef leftMethodDesc = MethodRef.method(SBC_TYPE, \"append\", SBC_TYPE, arg.type());\n+        return CoreOp.invoke(leftMethodDesc, stringBuilder, arg);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/StringConcatTransformer.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -35,1 +36,1 @@\n-import java.lang.reflect.code.analysis.LinearStringContextTransformer;\n+import java.lang.reflect.code.analysis.StringConcatTransformer;\n@@ -96,1 +97,1 @@\n-        CoreOp.FuncOp f_transformed = model.transform(new LinearStringContextTransformer());\n+        CoreOp.FuncOp f_transformed = model.transform(new StringConcatTransformer());\n@@ -111,1 +112,1 @@\n-        CoreOp.FuncOp transformed_model = model.transform(new LinearStringContextTransformer());\n+        CoreOp.FuncOp transformed_model = model.transform(new StringConcatTransformer());\n@@ -113,1 +114,1 @@\n-        CoreOp.FuncOp ssa_transformed_model = ssa_model.transform(new LinearStringContextTransformer());\n+        CoreOp.FuncOp ssa_transformed_model = ssa_model.transform(new StringConcatTransformer());\n@@ -120,0 +121,1 @@\n+        Object jvm_interpreted;\n@@ -121,6 +123,2 @@\n-            var jvm_interpreted = method.invoke(null, args);\n-            Assert.assertEquals(model_interpreted, transformed_model_interpreted);\n-            Assert.assertEquals(transformed_model_interpreted, ssa_interpreted);\n-            Assert.assertEquals(ssa_interpreted, ssa_transformed_interpreted);\n-            Assert.assertEquals(ssa_transformed_interpreted, jvm_interpreted);\n-        } catch (Throwable e) {\n+            jvm_interpreted = method.invoke(null, args);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n@@ -129,0 +127,4 @@\n+        Assert.assertEquals(model_interpreted, transformed_model_interpreted);\n+        Assert.assertEquals(transformed_model_interpreted, ssa_interpreted);\n+        Assert.assertEquals(ssa_interpreted, ssa_transformed_interpreted);\n+        Assert.assertEquals(ssa_transformed_interpreted, jvm_interpreted);\n@@ -146,1 +148,1 @@\n-        List<Object[]> ars = Arrays.stream(clazz.getMethods())\n+        Object[][] res = Arrays.stream(clazz.getMethods())\n@@ -149,5 +151,1 @@\n-                .toList();\n-        Object[][] res = new Object[ars.size()][];\n-        for (int i = 0; i < ars.size(); i++) {\n-            res[i] = ars.get(i);\n-        }\n+                .toArray(Object[][]::new);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringConcatTransform.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"}]}