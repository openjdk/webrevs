{"files":[{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.transformations;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.MethodRef;\n+\n+public class LinearConcatTransform {\n+\n+    private static final JavaType SBC_TYPE = JavaType.type(StringBuilder.class);\n+\n+    record StringAndBuilder(Value string, Value stringBuilder) { }\n+\n+    public LinearConcatTransform() {}\n+\n+    public static final class ConcatTransform implements OpTransformer {\n+\n+        public ConcatTransform () {\n+\n+        }\n+\n+        @Override\n+        public Block.Builder apply(Block.Builder builder, Op op) {\n+            if (op instanceof CoreOp.ConcatOp cz) {\n+\n+                Value left = builder.context().getValue(cz.operands().get(0));\n+                Value right = builder.context().getValue(cz.operands().get(1));\n+\n+                Value result = cz.result();\n+\n+                StringAndBuilder newRes = stringBuild(builder, left, right);\n+                builder.context().mapValue(result, newRes.string);\n+            } else {\n+                builder.op(op);\n+            }\n+            return builder;\n+        }\n+\n+        \/\/Uses StringBuilder and Immediate String Value\n+        private static StringAndBuilder stringBuild(Block.Builder builder, Value left, Value right) {\n+            var newB = stringBuilder(builder, left, right);\n+            var toStringMR = MethodRef.method(SBC_TYPE, \"toString\", JavaType.J_L_STRING);\n+            var toStringInvoke = CoreOp.invoke(toStringMR, newB);\n+            Value newString = builder.apply(toStringInvoke);\n+            return new StringAndBuilder(newString, newB);\n+        }\n+\n+        private static Value stringBuilder(Block.Builder builder, Value left, Value right) {\n+            CoreOp.NewOp newBuilder = CoreOp._new(FunctionType.functionType(SBC_TYPE));\n+            Value sb;\n+\n+            sb = builder.apply(newBuilder);\n+            var leftMethodDesc = MethodRef.method(SBC_TYPE, \"append\", SBC_TYPE, left.type());\n+            var leftInvoke = CoreOp.invoke(leftMethodDesc, sb, left);\n+            var rightMethodDesc = MethodRef.method(SBC_TYPE, \"append\", SBC_TYPE, right.type());\n+            var rightInvoke = CoreOp.invoke(rightMethodDesc, sb, right);\n+            builder.op(leftInvoke);\n+            builder.op(rightInvoke);\n+            return sb;\n+\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/transformations\/LinearConcatTransform.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -101,0 +101,1 @@\n+    exports java.lang.reflect.code.transformations;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestStringConcatTransform\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.NoInjection;\n+import org.testng.annotations.Test;\n+import java.lang.reflect.code.transformations.LinearConcatTransform;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TestStringConcatTransform {\n+\n+    static final String TESTSTR = \"TESTING STRING\";\n+\n+    static final Map<Class<?>, Object> valMap;\n+\n+    static {\n+        valMap = new HashMap<>();\n+        valMap.put(byte.class, (byte) 42);\n+        valMap.put(short.class, (short) 42);\n+        valMap.put(int.class, 42);\n+        valMap.put(long.class, (long) 42);\n+        valMap.put(float.class, 42f);\n+        valMap.put(double.class, 42d);\n+        valMap.put(char.class, 'z');\n+        valMap.put(boolean.class, false);\n+\n+        valMap.put(Byte.class, (byte) 42);\n+        valMap.put(Short.class, (short) 42);\n+        valMap.put(Integer.class, 42);\n+        valMap.put(Long.class, (long) 42);\n+        valMap.put(Float.class, 42f);\n+        valMap.put(Double.class, 42d);\n+        valMap.put(Character.class, 'z');\n+        valMap.put(Boolean.class, false);\n+\n+        valMap.put(Object.class, new Object() {\n+            @Override\n+            public String toString() {\n+                return \"I'm a test string.\";\n+            }\n+        });\n+        valMap.put(TestObject.class, new TestObject());\n+        valMap.put(String.class, TESTSTR);\n+    }\n+\n+    public static final class TestObject {\n+        TestObject() {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"TestObject String\";\n+        }\n+    }\n+\n+    @Test(dataProvider = \"getClassMethods\")\n+    public void testModelTransform(@NoInjection Method method) {\n+        CoreOp.FuncOp model = method.getCodeModel().orElseThrow();\n+        CoreOp.FuncOp f_transformed = model.transform(new LinearConcatTransform.ConcatTransform());\n+        Object[] args = prepArgs(method);\n+\n+        System.out.println(\"Final Transformed\");\n+        f_transformed.writeTo(System.out);\n+\n+        var interpreted = Interpreter.invoke(model, args);\n+        var transformed_interpreted = Interpreter.invoke(f_transformed, args);\n+\n+        Assert.assertEquals(interpreted, transformed_interpreted);\n+\n+    }\n+\n+    @Test(dataProvider = \"getClassMethods\")\n+    public void testSSAModelTransform(@NoInjection Method method) {\n+        CoreOp.FuncOp model = method.getCodeModel().orElseThrow();\n+        System.out.println(\"Basic model\");\n+        model.writeTo(System.out);\n+        CoreOp.FuncOp ssa_model = generateSSA(model);\n+        System.out.println(\"Final Transformed\");\n+        CoreOp.FuncOp f_transformed = ssa_model.transform(new LinearConcatTransform.ConcatTransform());\n+        f_transformed.writeTo(System.out);\n+        Object[] args = prepArgs(method);\n+\n+        var interpreted = Interpreter.invoke(model, args);\n+        var transformed_interpreted = Interpreter.invoke(f_transformed, args);\n+        var ssa_interpreted = Interpreter.invoke(ssa_model, args);\n+        try {\n+            var jvm_interpreted = method.invoke(null, args);\n+            Assert.assertEquals(transformed_interpreted, jvm_interpreted);\n+            \/\/Assert.assertEquals(interpreted, transformed_interpreted);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+\n+    }\n+\n+\n+    \/\/@Test(dataProvider = \"getClassMethods\")\n+    public void testEqualResults(@NoInjection Method method) {\n+        CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+        CoreOp.FuncOp f_transformed = f.transform(new LinearConcatTransform.ConcatTransform());\n+        CoreOp.FuncOp f_ssa = generateSSA(f).transform(new LinearConcatTransform.ConcatTransform());\n+        MethodHandle m_bytecode = generateBytecode(f_transformed);\n+\n+\n+        Object[] args = prepArgs(method);\n+\n+        var interpreted = Interpreter.invoke(f, args);\n+        var transformed_interpreted = Interpreter.invoke(f_transformed, args);\n+        var transformed_ssa_interpreted = Interpreter.invoke(f_ssa, args);\n+        try {\n+            var jvm_executed = method.invoke(null, args);\n+            var code_model_bytecode_executed = m_bytecode.invokeWithArguments(args);\n+\n+            \/\/Assert.assertEquals(interpreted, transformed_interpreted);\n+            \/\/Assert.assertEquals(transformed_interpreted, jvm_executed);\n+            \/\/Assert.assertEquals(jvm_executed, transformed_ssa_interpreted);\n+            \/\/Assert.assertEquals(transformed_ssa_interpreted, code_model_bytecode_executed);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+    }\n+\n+    public static Object[] prepArgs(Method m) {\n+        Class<?>[] argTypes = m.getParameterTypes();\n+        Object[] args = new Object[argTypes.length];\n+        for (int i = 0; i < argTypes.length; i++) {\n+            args[i] = valMap.get(argTypes[i]);\n+        }\n+        return args;\n+    }\n+\n+    @DataProvider(name = \"getClassMethods\")\n+    public static Object[][] getClassMethods() {\n+        return getTestMethods(TestStringConcatTransform.class);\n+    }\n+\n+    public static Object[][] getTestMethods(Class<?> clazz) {\n+        List<Object[]> ars = Arrays.stream(clazz.getMethods())\n+                .filter((method) -> method.isAnnotationPresent(CodeReflection.class))\n+                .map(m -> new Object[]{m})\n+                .toList();\n+        Object[][] res = new Object[ars.size()][];\n+        for (int i = 0; i < ars.size(); i++) {\n+            res[i] = ars.get(i);\n+        }\n+\n+        return res;\n+    }\n+\n+    static CoreOp.FuncOp generateSSA(CoreOp.FuncOp f) {\n+        CoreOp.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf = SSA.transform(lf);\n+\n+        System.out.println(\"Post SSA\");\n+        lf.writeTo(System.out);\n+\n+        return lf;\n+    }\n+\n+\n+    static MethodHandle generateBytecode(CoreOp.FuncOp f) {\n+        CoreOp.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf = SSA.transform(lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+    }\n+\n+    static CoreOp.FuncOp lower(CoreOp.FuncOp f) {\n+        CoreOp.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        return lf;\n+\n+    }\n+\n+    @CodeReflection\n+    public static String intConcat(int i, String s) {\n+        return i + s + \"hello\" + 52;\n+    }\n+\n+\n+    @CodeReflection\n+    public static String intConcatAssignment(int i, String s) {\n+        String s1 = i + s;\n+        return s1 + \"hello\" + 52;\n+    }\n+\n+    @CodeReflection\n+    public static String intConcatExprAssignment(int i, String s) {\n+        String r;\n+        String inter = i + (r = s + \"hello\") + 52;\n+        return r + inter;\n+    }\n+\n+    @CodeReflection\n+    public static String intConcatWideExpr(int i, String s) {\n+        String s1 = i + s;\n+        return s1 + \"hello\" + 52 + \"world\" + 26 + \"!\";\n+    }\n+\n+    @CodeReflection\n+    public static String intConcatDoubVar(int i, String s) {\n+        String r;\n+        String inter = i + (r = s + \"hello\") + 52;\n+        String inter2 = i + (r = s + \"hello\") + 52 + inter;\n+        return r + inter2;\n+    }\n+\n+    @CodeReflection\n+    public static String intConcatNestedSplit(int i, String s){\n+        String q, r;\n+        String inter = i + (q = r = s + \"hello\") + 52;\n+        return q + r + inter;\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringConcatTransform.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"}]}