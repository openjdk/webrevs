{"files":[{"patch":"@@ -670,1 +670,1 @@\n-            int argCount = operands.size() - (invokeKind == InvokeKind.STATIC ? 0 : 1);\n+            int argCount = operands.size() - (invokeKind == InvokeKind.STATIC || invokeDescriptor.isConstructor() ? 0 : 1);\n@@ -4953,0 +4953,64 @@\n+    @OpDeclaration(ClassDecOp.NAME)\n+    public static final class ClassDecOp extends JavaOp\n+            implements Op.Nested {\n+\n+        static final String NAME = \"class.dec\";\n+        static final String ATTRIBUTE_CLASS_TYPE = NAME + \".type\";\n+\n+        private final ClassType classType;\n+        private final Body fieldsAndMethods;\n+\n+        ClassDecOp(ExternalizedOp def) {\n+            \/\/ Required attribute\n+            ClassType classType = def.extractAttributeValue(ATTRIBUTE_CLASS_TYPE,\n+                    true, v -> switch (v) {\n+                        case ClassType ct -> ct;\n+                        case null, default ->\n+                                throw new UnsupportedOperationException(\"Unsupported class type value:\" + v);\n+                    });\n+\n+            Body.Builder fieldsAndMethods = def.bodyDefinitions().get(0);\n+\n+            this(classType, fieldsAndMethods);\n+        }\n+\n+        ClassDecOp(ClassType classType, Body.Builder fieldsAndMethods) {\n+            super(List.of());\n+\n+            this.classType = classType;\n+            this.fieldsAndMethods = fieldsAndMethods.build(this);\n+        }\n+\n+        ClassDecOp(ClassDecOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.classType = that.classType;\n+            this.fieldsAndMethods = that.fieldsAndMethods.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new ClassDecOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            \/\/ @@@ for now\n+            return VOID;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(fieldsAndMethods);\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", classType);\n+        }\n+    }\n+\n+    public static ClassDecOp classDecOp(ClassType classType, Body.Builder fieldsAndMethods) {\n+        return new ClassDecOp(classType, fieldsAndMethods);\n+    }\n+\n@@ -5015,0 +5079,5 @@\n+            case \"class.dec\" -> new ClassDecOp(def);\n+            \/\/ @@@ better error reporting\n+            \/\/ instead of:\n+            \/\/Caused by: java.lang.NullPointerException: Cannot invoke \"jdk.incubator.code.Op.result()\" because \"op\" is null\n+            \/\/at jdk.incubator.code\/jdk.incubator.code.Block$Builder.op(Block.java:688)\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":70,"deletions":1,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -441,1 +441,1 @@\n-        private final Map<Symbol, List<Symbol>> localCaptures = new HashMap<>();\n+        private Map<Symbol, List<Symbol>> localCaptures = new HashMap<>();\n@@ -444,0 +444,8 @@\n+            this(tree, null);\n+        }\n+\n+        BodyScanner(JCMethodDecl md, BodyStack stack) {\n+            this(md, new LinkedHashMap<>(), stack);\n+        }\n+\n+        BodyScanner(JCMethodDecl tree, Map<Symbol, List<Symbol>> localCaptures, BodyStack parent) {\n@@ -447,0 +455,1 @@\n+            this.localCaptures = localCaptures;\n@@ -463,1 +472,1 @@\n-            this.stack = this.top = new BodyStack(null, tree.body, bodyType);\n+            this.stack = this.top = new BodyStack(parent, tree.body, bodyType);\n@@ -1012,1 +1021,9 @@\n-                            result = append(JavaOp.fieldLoad(resultType, fr, thisValue()));\n+                            \/\/ field owner sym is mapped to a value that represents the receiver\n+                            \/\/ by default, the receiver is the @CodeReflection method class instance\n+                            Value receiver;\n+                            try {\n+                                receiver = loadVar(tree.sym.owner);\n+                            } catch (NoSuchElementException e) {\n+                                receiver = thisValue();\n+                            }\n+                            result = append(JavaOp.fieldLoad(resultType, fr, receiver)); \/\/ instead look for a symbol of the same type as field ref, in stacks\n@@ -1064,1 +1081,7 @@\n-                            result = thisValue();\n+                            try {\n+                                \/\/ e.g. Foo.this\n+                                \/\/ we will load the value mapped to Foo symbol\n+                                result = loadVar(tree.selected.type.tsym);\n+                            } catch (NoSuchElementException e) {\n+                                result = thisValue();\n+                            }\n@@ -1112,1 +1135,3 @@\n-                    if (!sym.isStatic()) {\n+                    if (sym.isConstructor()) {\n+                        ik = JavaOp.InvokeOp.InvokeKind.SUPER;\n+                    } else if (!sym.isStatic()) {\n@@ -1122,0 +1147,4 @@\n+                    if (sym.isConstructor()) {\n+                        \/\/ the above mr will have return type void\n+                        mr = MethodRef.constructor(mr.refType(), mr.type().parameterTypes());\n+                    }\n@@ -1359,1 +1388,2 @@\n-            if (!outer.hasTag(TypeTag.NONE)) {\n+            \/\/ do this for inner class but not for local class\n+            if (!tree.type.tsym.isDirectlyOrIndirectlyLocal() && !outer.hasTag(TypeTag.NONE)) {\n@@ -1372,0 +1402,13 @@\n+                \/\/ for local class, add outer instance as arg if applicable\n+                Symbol ownerMethod = tree.type.tsym.owner; \/\/ the method where the local class is defined\n+                if (!ownerMethod.isStatic()) {\n+                    Symbol outerClass = ownerMethod.owner;\n+                    Value outerInstance;\n+                    try {\n+                        outerInstance = loadVar(outerClass);\n+                    } catch (NoSuchElementException e) {\n+                        outerInstance = thisValue();\n+                    }\n+                    args.add(outerInstance);\n+                    argtypes.add(outerInstance.type());\n+                }\n@@ -2439,0 +2482,62 @@\n+\n+                ListBuffer<Symbol> capturesSymbols = new ListBuffer<>();\n+                Symbol ownerMethod = tree.sym.owner;\n+                if (!ownerMethod.isStatic()) {\n+                    capturesSymbols.add(ownerMethod.owner);\n+                }\n+                capturesSymbols.addAll(localCaptures.get(tree.sym));\n+\n+                pushBody(tree, FunctionType.FUNCTION_TYPE_VOID);\n+\n+                \/\/ fields declarations\n+                List<JCTree> fieldsDec = tree.defs.stream().filter(d -> d instanceof JCVariableDecl).toList();\n+                \/\/ fields for the local class captures\n+                List<Op.Result> fieldsForCaptures = new ArrayList<>();\n+                for (Symbol capturesSymbol : capturesSymbols) {\n+                    Op.Result r = append(CoreOp.var(typeToTypeElement(capturesSymbol.type)));\n+                    fieldsForCaptures.add(r);\n+                    stack.localToOp.put(capturesSymbol, r);\n+                }\n+                \/\/ fields of the local class\n+                for (JCTree fd : fieldsDec) {\n+                    scan(fd);\n+                }\n+\n+                \/\/ methods declarations\n+                List<JCTree> methodsDec = tree.defs.stream().filter(d -> d instanceof JCMethodDecl).toList();\n+                for (JCTree md : methodsDec) {\n+                    \/\/ We pass the stack to have the mapping of captures to fields available\n+                    CoreOp.FuncOp funcOp = new BodyScanner((JCMethodDecl) md, localCaptures, stack).scanMethod();\n+                    if (!((JCMethodDecl) md).sym.isConstructor()) {\n+                        append(funcOp);\n+                        continue;\n+                    }\n+                    \/\/ for a constructor, we modify the created funcOp by adding params that represent captures,\n+                    \/\/ plus operations that assign these params to the right fields\n+                    List<TypeElement> newParamsTypes = new ArrayList<>();\n+                    \/\/ add params that represent captures\n+                    newParamsTypes.addAll(capturesSymbols.stream().map(s -> typeToTypeElement(s.type)).toList());\n+                    \/\/ add original params expect the first one that represent the local class instance\n+                    newParamsTypes.addAll(funcOp.invokableType().parameterTypes().stream().skip(1).toList());\n+                    \/\/ @@@ simple way of doing this kind of transformation ?\n+                    Body.Builder nfbody = Body.Builder.of(stack.body, CoreType.functionType(funcOp.resultType(), newParamsTypes));\n+                    Block.Builder nfblock = nfbody.entryBlock();\n+                    nfblock.body(funcOp.body(), nfblock.parameters().subList(capturesSymbols.length(), nfblock.parameters().size()),\n+                            (block, op) -> {\n+                                if (op instanceof Op.Terminating) {\n+                                    List<Block.Parameter> paramsForCaptures = nfblock.parameters().subList(0, capturesSymbols.length());\n+                                    for (int i = 0; i < paramsForCaptures.size(); i++) {\n+                                        block.op(CoreOp.varStore(fieldsForCaptures.get(i), paramsForCaptures.get(i)));\n+                                    }\n+                                }\n+                                block.op(op);\n+                                return block;\n+                            });\n+                    funcOp = CoreOp.func(funcOp.funcName(), nfbody);\n+                    append(funcOp);\n+                }\n+                append(CoreOp.core_yield());\n+                Body.Builder body = stack.body;\n+                popBody();\n+\n+                result = append(JavaOp.classDecOp((ClassType) symbolToErasedDesc(tree.sym), body));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":111,"deletions":6,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -633,0 +633,2 @@\n+        } if (o instanceof JavaOp.ClassDecOp) {\n+            return null;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @build LocalClassTest\n+ * @compile LocalClassTest.java\n@@ -45,3 +45,15 @@\n-                %1 : java.type:\"LocalClassTest::$1Foo\" = new %0 @java.ref:\"LocalClassTest::$1Foo::(LocalClassTest)\";\n-                invoke %1 @java.ref:\"LocalClassTest::$1Foo::m():void\";\n-                return;\n+                  class.dec @java.type:\"LocalClassTest::$1Foo\" ()java.type:\"void\" -> {\n+                      %1 : Var<java.type:\"LocalClassTest\"> = var;\n+                      func @\"<init>\" (%3 : java.type:\"LocalClassTest\")java.type:\"void\" -> {\n+                          invoke @java.ref:\"java.lang.Object::()\" @invoke.kind=\"SUPER\";\n+                          var.store %1 %3;\n+                          return;\n+                      };\n+                      func @\"m\" (%2 : java.type:\"LocalClassTest::$1Foo\")java.type:\"void\" -> {\n+                          return;\n+                      };\n+                      yield;\n+                  };\n+                  %4 : java.type:\"LocalClassTest::$1Foo\" = new %0 @java.ref:\"LocalClassTest::$1Foo::(LocalClassTest)\";\n+                  invoke %4 @java.ref:\"LocalClassTest::$1Foo::m():void\";\n+                  return;\n@@ -50,0 +62,3 @@\n+    \/\/ curr there is no link between newOp and classDecOp\n+    \/\/ classDescOp should have an attribute that matches the refType of the MethodRef used with NewOp\n+    \/\/ how the interpreter works ?? does it work in the first place\n@@ -60,3 +75,15 @@\n-                %1 : java.type:\"LocalClassTest::$1\" = new %0 @java.ref:\"LocalClassTest::$1::(LocalClassTest)\";\n-                invoke %1 @java.ref:\"LocalClassTest::$1::m():void\";\n-                return;\n+                  class.dec @java.type:\"LocalClassTest::$1\" ()java.type:\"void\" -> {\n+                      %1 : Var<java.type:\"LocalClassTest\"> = var;\n+                      func @\"<init>\" (%2 : java.type:\"LocalClassTest\")java.type:\"void\" -> {\n+                          invoke @java.ref:\"java.lang.Object::()\" @invoke.kind=\"SUPER\";\n+                          var.store %1 %2;\n+                          return;\n+                      };\n+                      func @\"m\" (%3 : java.type:\"LocalClassTest::$1\")java.type:\"void\" -> {\n+                          return;\n+                      };\n+                      yield;\n+                  };\n+                  %4 : java.type:\"LocalClassTest::$1\" = new %0 @java.ref:\"LocalClassTest::$1::(LocalClassTest)\";\n+                  invoke %4 @java.ref:\"LocalClassTest::$1::m():void\";\n+                  return;\n@@ -74,5 +101,20 @@\n-                %2 : Var<java.type:\"java.lang.String\"> = var %1 @\"s\";\n-                %3 : java.type:\"java.lang.String\" = var.load %2;\n-                %4 : java.type:\"LocalClassTest::$2Foo\" = new %0 %3 @java.ref:\"LocalClassTest::$2Foo::(LocalClassTest, java.lang.String)\";\n-                %5 : java.type:\"java.lang.String\" = invoke %4 @java.ref:\"LocalClassTest::$2Foo::m():java.lang.String\";\n-                return %5;\n+                  %2 : Var<java.type:\"java.lang.String\"> = var %1 @\"s\";\n+                  class.dec @java.type:\"LocalClassTest::$2Foo\" ()java.type:\"void\" -> {\n+                      %3 : Var<java.type:\"LocalClassTest\"> = var;\n+                      %4 : Var<java.type:\"java.lang.String\"> = var;\n+                      func @\"<init>\" (%5 : java.type:\"LocalClassTest\", %6 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                          invoke @java.ref:\"java.lang.Object::()\" @invoke.kind=\"SUPER\";\n+                          var.store %3 %5;\n+                          var.store %4 %6;\n+                          return;\n+                      };\n+                      func @\"m\" (%7 : java.type:\"LocalClassTest::$2Foo\")java.type:\"java.lang.String\" -> {\n+                          %8 : java.type:\"java.lang.String\" = var.load %4;\n+                          return %8;\n+                      };\n+                      yield;\n+                  };\n+                  %9 : java.type:\"java.lang.String\" = var.load %2;\n+                  %10 : java.type:\"LocalClassTest::$2Foo\" = new %0 %9 @java.ref:\"LocalClassTest::$2Foo::(LocalClassTest, java.lang.String)\";\n+                  %11 : java.type:\"java.lang.String\" = invoke %10 @java.ref:\"LocalClassTest::$2Foo::m():java.lang.String\";\n+                  return %11;\n@@ -91,6 +133,21 @@\n-                %2 : Var<java.type:\"java.lang.String\"> = var %1 @\"s\";\n-                %3 : java.type:\"java.lang.String\" = var.load %2;\n-                %4 : java.type:\"LocalClassTest::$2\" = new %0 %3 @java.ref:\"LocalClassTest::$2::(LocalClassTest, java.lang.String)\";\n-                %5 : java.type:\"java.lang.String\" = invoke %4 @java.ref:\"LocalClassTest::$2::m():java.lang.String\";\n-                return %5;\n-            };\n+                  %2 : Var<java.type:\"java.lang.String\"> = var %1 @\"s\";\n+                  class.dec @java.type:\"LocalClassTest::$2\" ()java.type:\"void\" -> {\n+                      %3 : Var<java.type:\"LocalClassTest\"> = var;\n+                      %4 : Var<java.type:\"java.lang.String\"> = var;\n+                      func @\"<init>\" (%5 : java.type:\"LocalClassTest\", %6 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                          invoke @java.ref:\"java.lang.Object::()\" @invoke.kind=\"SUPER\";\n+                          var.store %3 %5;\n+                          var.store %4 %6;\n+                          return;\n+                      };\n+                      func @\"m\" (%7 : java.type:\"LocalClassTest::$2\")java.type:\"java.lang.String\" -> {\n+                          %8 : java.type:\"java.lang.String\" = var.load %4;\n+                          return %8;\n+                      };\n+                      yield;\n+                  };\n+                  %9 : java.type:\"java.lang.String\" = var.load %2;\n+                  %10 : java.type:\"LocalClassTest::$2\" = new %0 %9 @java.ref:\"LocalClassTest::$2::(LocalClassTest, java.lang.String)\";\n+                  %11 : java.type:\"java.lang.String\" = invoke %10 @java.ref:\"LocalClassTest::$2::m():java.lang.String\";\n+                  return %11;\n+              };\n@@ -107,7 +164,29 @@\n-                %2 : Var<java.type:\"java.lang.String\"> = var %1 @\"s\";\n-                %3 : java.type:\"java.lang.String\" = constant @\"Hello!\";\n-                %4 : Var<java.type:\"java.lang.String\"> = var %3 @\"localConst\";\n-                %5 : java.type:\"java.lang.String\" = var.load %2;\n-                %6 : java.type:\"LocalClassTest::$3Foo\" = new %0 %5 @java.ref:\"LocalClassTest::$3Foo::(LocalClassTest, java.lang.String)\";\n-                %7 : java.type:\"java.lang.String\" = invoke %6 @java.ref:\"LocalClassTest::$3Foo::m():java.lang.String\";\n-                return %7;\n+                  %2 : Var<java.type:\"java.lang.String\"> = var %1 @\"s\";\n+                  %3 : java.type:\"java.lang.String\" = constant @\"Hello!\";\n+                  %4 : Var<java.type:\"java.lang.String\"> = var %3 @\"localConst\";\n+                  class.dec @java.type:\"LocalClassTest::$3Foo\" ()java.type:\"void\" -> {\n+                      %5 : Var<java.type:\"LocalClassTest\"> = var;\n+                      %6 : Var<java.type:\"java.lang.String\"> = var;\n+                      func @\"<init>\" (%7 : java.type:\"LocalClassTest\", %8 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                          invoke @java.ref:\"java.lang.Object::()\" @invoke.kind=\"SUPER\";\n+                          var.store %5 %7;\n+                          var.store %6 %8;\n+                          return;\n+                      };\n+                      func @\"m\" (%9 : java.type:\"LocalClassTest::$3Foo\")java.type:\"java.lang.String\" -> {\n+                          %10 : java.type:\"java.lang.String\" = var.load %4;\n+                          %11 : java.type:\"java.lang.String\" = var.load %6;\n+                          %12 : java.type:\"java.lang.String\" = concat %10 %11;\n+                          %13 : java.type:\"LocalClassTest\" = var.load %5;\n+                          %14 : java.type:\"java.lang.String\" = field.load %13 @java.ref:\"LocalClassTest::nonConstString:java.lang.String\";\n+                          %15 : java.type:\"java.lang.String\" = concat %12 %14;\n+                          %16 : java.type:\"java.lang.String\" = field.load @java.ref:\"LocalClassTest::CONST_STRING:java.lang.String\";\n+                          %17 : java.type:\"java.lang.String\" = concat %15 %16;\n+                          return %17;\n+                      };\n+                      yield;\n+                  };\n+                  %18 : java.type:\"java.lang.String\" = var.load %2;\n+                  %19 : java.type:\"LocalClassTest::$3Foo\" = new %0 %18 @java.ref:\"LocalClassTest::$3Foo::(LocalClassTest, java.lang.String)\";\n+                  %20 : java.type:\"java.lang.String\" = invoke %19 @java.ref:\"LocalClassTest::$3Foo::m():java.lang.String\";\n+                  return %20;\n@@ -127,7 +206,29 @@\n-                %2 : Var<java.type:\"java.lang.String\"> = var %1 @\"s\";\n-                %3 : java.type:\"java.lang.String\" = constant @\"Hello!\";\n-                %4 : Var<java.type:\"java.lang.String\"> = var %3 @\"localConst\";\n-                %5 : java.type:\"java.lang.String\" = var.load %2;\n-                %6 : java.type:\"LocalClassTest::$3\" = new %0 %5 @java.ref:\"LocalClassTest::$3::(LocalClassTest, java.lang.String)\";\n-                %7 : java.type:\"java.lang.String\" = invoke %6 @java.ref:\"LocalClassTest::$3::m():java.lang.String\";\n-                return %7;\n+                  %2 : Var<java.type:\"java.lang.String\"> = var %1 @\"s\";\n+                  %3 : java.type:\"java.lang.String\" = constant @\"Hello!\";\n+                  %4 : Var<java.type:\"java.lang.String\"> = var %3 @\"localConst\";\n+                  class.dec @java.type:\"LocalClassTest::$3\" ()java.type:\"void\" -> {\n+                      %5 : Var<java.type:\"LocalClassTest\"> = var;\n+                      %6 : Var<java.type:\"java.lang.String\"> = var;\n+                      func @\"<init>\" (%7 : java.type:\"LocalClassTest\", %8 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                          invoke @java.ref:\"java.lang.Object::()\" @invoke.kind=\"SUPER\";\n+                          var.store %5 %7;\n+                          var.store %6 %8;\n+                          return;\n+                      };\n+                      func @\"m\" (%9 : java.type:\"LocalClassTest::$3\")java.type:\"java.lang.String\" -> {\n+                          %10 : java.type:\"java.lang.String\" = var.load %4;\n+                          %11 : java.type:\"java.lang.String\" = var.load %6;\n+                          %12 : java.type:\"java.lang.String\" = concat %10 %11;\n+                          %13 : java.type:\"LocalClassTest\" = var.load %5;\n+                          %14 : java.type:\"java.lang.String\" = field.load %13 @java.ref:\"LocalClassTest::nonConstString:java.lang.String\";\n+                          %15 : java.type:\"java.lang.String\" = concat %12 %14;\n+                          %16 : java.type:\"java.lang.String\" = field.load @java.ref:\"LocalClassTest::CONST_STRING:java.lang.String\";\n+                          %17 : java.type:\"java.lang.String\" = concat %15 %16;\n+                          return %17;\n+                      };\n+                      yield;\n+                  };\n+                  %18 : java.type:\"java.lang.String\" = var.load %2;\n+                  %19 : java.type:\"LocalClassTest::$3\" = new %0 %18 @java.ref:\"LocalClassTest::$3::(LocalClassTest, java.lang.String)\";\n+                  %20 : java.type:\"java.lang.String\" = invoke %19 @java.ref:\"LocalClassTest::$3::m():java.lang.String\";\n+                  return %20;\n@@ -146,7 +247,45 @@\n-                %3 : Var<java.type:\"int\"> = var %1 @\"s\";\n-                %4 : Var<java.type:\"int\"> = var %2 @\"i\";\n-                %5 : java.type:\"int\" = var.load %3;\n-                %6 : java.type:\"int\" = var.load %4;\n-                %7 : java.type:\"LocalClassTest::$1Bar\" = new %0 %5 %6 @java.ref:\"LocalClassTest::$1Bar::(LocalClassTest, int, int)\";\n-                return;\n-            };\n+                  %3 : Var<java.type:\"int\"> = var %1 @\"s\";\n+                  %4 : Var<java.type:\"int\"> = var %2 @\"i\";\n+                  class.dec @java.type:\"LocalClassTest::$4Foo\" ()java.type:\"void\" -> {\n+                      %5 : Var<java.type:\"LocalClassTest\"> = var;\n+                      %6 : Var<java.type:\"int\"> = var;\n+                      func @\"<init>\" (%7 : java.type:\"LocalClassTest\", %8 : java.type:\"int\")java.type:\"void\" -> {\n+                          invoke @java.ref:\"java.lang.Object::()\" @invoke.kind=\"SUPER\";\n+                          var.store %5 %7;\n+                          var.store %6 %8;\n+                          return;\n+                      };\n+                      func @\"i\" (%9 : java.type:\"LocalClassTest::$4Foo\")java.type:\"int\" -> {\n+                          %10 : java.type:\"int\" = var.load %6;\n+                          return %10;\n+                      };\n+                      yield;\n+                  };\n+                  class.dec @java.type:\"LocalClassTest::$1Bar\" ()java.type:\"void\" -> {\n+                      %11 : Var<java.type:\"LocalClassTest\"> = var;\n+                      %12 : Var<java.type:\"int\"> = var;\n+                      %13 : Var<java.type:\"int\"> = var;\n+                      func @\"<init>\" (%14 : java.type:\"LocalClassTest\", %15 : java.type:\"int\", %16 : java.type:\"int\")java.type:\"void\" -> {\n+                          invoke @java.ref:\"java.lang.Object::()\" @invoke.kind=\"SUPER\";\n+                          var.store %11 %14;\n+                          var.store %12 %15;\n+                          var.store %13 %16;\n+                          return;\n+                      };\n+                      func @\"s\" (%17 : java.type:\"LocalClassTest::$1Bar\")java.type:\"int\" -> {\n+                          %18 : java.type:\"int\" = var.load %12;\n+                          return %18;\n+                      };\n+                      func @\"foo\" (%19 : java.type:\"LocalClassTest::$1Bar\")java.type:\"LocalClassTest::$4Foo\" -> {\n+                          %20 : java.type:\"LocalClassTest\" = var.load %11;\n+                          %21 : java.type:\"int\" = var.load %13;\n+                          %22 : java.type:\"LocalClassTest::$4Foo\" = new %20 %21 @java.ref:\"LocalClassTest::$4Foo::(LocalClassTest, int)\";\n+                          return %22;\n+                      };\n+                      yield;\n+                  };\n+                  %23 : java.type:\"int\" = var.load %3;\n+                  %24 : java.type:\"int\" = var.load %4;\n+                  %25 : java.type:\"LocalClassTest::$1Bar\" = new %0 %23 %24 @java.ref:\"LocalClassTest::$1Bar::(LocalClassTest, int, int)\";\n+                  return;\n+              };\n@@ -154,1 +293,1 @@\n-    void testLocalDependency(int s, int i) {\n+    void testLocalDependency(int s, int i) { \/\/ static is like defined in a top level context, record sweet spot, worth keep pushing to model top level classes\n@@ -168,7 +307,45 @@\n-                %3 : Var<java.type:\"int\"> = var %1 @\"s\";\n-                %4 : Var<java.type:\"int\"> = var %2 @\"i\";\n-                %5 : java.type:\"int\" = var.load %3;\n-                %6 : java.type:\"int\" = var.load %4;\n-                %7 : java.type:\"LocalClassTest::$4\" = new %0 %5 %6 @java.ref:\"LocalClassTest::$4::(LocalClassTest, int, int)\";\n-                return;\n-            };\n+                  %3 : Var<java.type:\"int\"> = var %1 @\"s\";\n+                  %4 : Var<java.type:\"int\"> = var %2 @\"i\";\n+                  class.dec @java.type:\"LocalClassTest::$5Foo\" ()java.type:\"void\" -> {\n+                      %5 : Var<java.type:\"LocalClassTest\"> = var;\n+                      %6 : Var<java.type:\"int\"> = var;\n+                      func @\"<init>\" (%7 : java.type:\"LocalClassTest\", %8 : java.type:\"int\")java.type:\"void\" -> {\n+                          invoke @java.ref:\"java.lang.Object::()\" @invoke.kind=\"SUPER\";\n+                          var.store %5 %7;\n+                          var.store %6 %8;\n+                          return;\n+                      };\n+                      func @\"i\" (%9 : java.type:\"LocalClassTest::$5Foo\")java.type:\"int\" -> {\n+                          %10 : java.type:\"int\" = var.load %6;\n+                          return %10;\n+                      };\n+                      yield;\n+                  };\n+                  class.dec @java.type:\"LocalClassTest::$4\" ()java.type:\"void\" -> {\n+                      %11 : Var<java.type:\"LocalClassTest\"> = var;\n+                      %12 : Var<java.type:\"int\"> = var;\n+                      %13 : Var<java.type:\"int\"> = var;\n+                      func @\"<init>\" (%14 : java.type:\"LocalClassTest\", %15 : java.type:\"int\", %16 : java.type:\"int\")java.type:\"void\" -> {\n+                          invoke @java.ref:\"java.lang.Object::()\" @invoke.kind=\"SUPER\";\n+                          var.store %11 %14;\n+                          var.store %12 %15;\n+                          var.store %13 %16;\n+                          return;\n+                      };\n+                      func @\"s\" (%17 : java.type:\"LocalClassTest::$4\")java.type:\"int\" -> {\n+                          %18 : java.type:\"int\" = var.load %12;\n+                          return %18;\n+                      };\n+                      func @\"foo\" (%19 : java.type:\"LocalClassTest::$4\")java.type:\"LocalClassTest::$5Foo\" -> {\n+                          %20 : java.type:\"LocalClassTest\" = var.load %11;\n+                          %21 : java.type:\"int\" = var.load %13;\n+                          %22 : java.type:\"LocalClassTest::$5Foo\" = new %20 %21 @java.ref:\"LocalClassTest::$5Foo::(LocalClassTest, int)\";\n+                          return %22;\n+                      };\n+                      yield;\n+                  };\n+                  %23 : java.type:\"int\" = var.load %3;\n+                  %24 : java.type:\"int\" = var.load %4;\n+                  %25 : java.type:\"LocalClassTest::$4\" = new %0 %23 %24 @java.ref:\"LocalClassTest::$4::(LocalClassTest, int, int)\";\n+                  return;\n+              };\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalClassTest.java","additions":224,"deletions":47,"binary":false,"changes":271,"status":"modified"}]}