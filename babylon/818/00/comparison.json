{"files":[{"patch":"@@ -26,0 +26,1 @@\n+\n@@ -27,1 +28,0 @@\n-import hat.dialect.HATMemoryVarOp;\n@@ -29,0 +29,2 @@\n+import hat.dialect.HATMemoryVarOp;\n+import optkl.codebuilders.BabylonOpDispatcher;\n@@ -30,0 +32,1 @@\n+import optkl.codebuilders.ScopedCodeBuilderContext;\n@@ -31,1 +34,2 @@\n-public  class C99HATCodeBuilder<T extends C99HATCodeBuilder<T>> extends C99CodeBuilder<T> {\n+public abstract class C99HATCodeBuilder<T extends C99HATCodeBuilder<T>> extends C99CodeBuilder<T>\n+        implements BabylonOpDispatcher<T, ScopedCodeBuilderContext> {\n@@ -67,0 +71,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilder.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.dialect.HATF16Op;\n-import hat.dialect.HATVectorOp;\n-import hat.types.HAType;\n-import hat.device.DeviceType;\n-import hat.dialect.HATMemoryVarOp;\n-import optkl.OpHelper;\n-import optkl.ifacemapper.MappableIface;\n-import optkl.util.Regex;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.codebuilders.BabylonOpDispatcher;\n-import optkl.codebuilders.CodeBuilder;\n-import optkl.codebuilders.ScopedCodeBuilderContext;\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n-\n-public abstract class C99HATCodeBuilderContext<T extends C99HATCodeBuilderContext<T>> extends C99HATCodeBuilder<T>\n-        implements BabylonOpDispatcher<T, ScopedCodeBuilderContext> {\n-\n-\n-    @Override\n-    public final T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n-        switch (resolve) {\n-            case CoreOp.VarOp $ -> varName($);\n-            case HATMemoryVarOp $ -> varName($);\n-            case HATVectorOp.HATVectorVarOp $ -> varName($);\n-            case HATVectorOp.HATVectorLoadOp $ -> varName($);\n-            case HATVectorOp.HATVectorBinaryOp $ -> varName($);\n-            case HATF16Op.HATF16VarOp $ -> varName($);\n-            case null, default -> {\n-            }\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public final T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp) {\n-        Op op = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n-\n-        \/\/TODO see if VarLikeOp marker interface fixes this\n-\n-        \/\/ TODO: each of these is delegating to varName().... maybe varName should be handling these types.\n-\n-        \/\/ When the op is intended to operate as VarOp, then we need to include it in the following switch.\n-        \/\/ This is because HAT has its own dialect, and some of the Ops operate on HAT Types (not included in the Java\n-        \/\/ dialect). For instance, private data structures, local data structures, vector types, etc.\n-        switch (op) {\n-            case CoreOp.VarOp varOp -> varName(varOp);\n-            case HATF16Op.HATF16VarOp hatf16VarOp -> varName(hatf16VarOp);\n-            case HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp);\n-            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp);\n-            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp);\n-            case HATVectorOp.HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp);\n-            case null, default -> throw new IllegalStateException(\"What type of varStoreOp is this?\");\n-        }\n-        equals().parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n-        return self();\n-    }\n-\n-    @Override\n-    public final  T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n-        \/\/ TODO: I think we need to work out how to handle doubles. If I remove this OpenCL on MAC complains (no FP64)\n-        if (convOp.resultType() == JavaType.DOUBLE) {\n-            paren(_ -> type(buildContext,JavaType.FLOAT)); \/\/ why double to float?\n-        } else {\n-            paren(_ -> type(buildContext,(JavaType)convOp.resultType()));\n-        }\n-        parenthesisIfNeeded(buildContext, convOp, ((Op.Result) convOp.operands().getFirst()).op());\n-        return self();\n-    }\n-\n-    public abstract  T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name);\n-\n-    static Regex atomicIncRegex = Regex.of(\"(atomic.*)Inc\");\n-\n-    @Override\n-    public final T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n-        var invoke = invokeOpHelper(buildContext.lookup,invokeOp);\n-        if ( invoke.refIs(MappableIface.class,HAType.class,DeviceType.class)) { \/\/ we need a common type\n-            if (invoke.isInstance() && invoke.operandCount() == 1 && invoke.returnsInt() && invoke.named(atomicIncRegex)) {\n-                if (invoke.operandNAsResultOrThrow(0) instanceof Op.Result instanceResult) {\n-                    atomicInc(buildContext, instanceResult,\n-                            ((Regex.Match)atomicIncRegex.is(invoke.name())).stringOf(1) \/\/ atomicXXInc -> atomicXX\n-                    );\n-                }\n-            } else if (invoke.isInstance() && invoke.operandNAsResultOrThrow(0) instanceof Op.Result instance) {\n-                parenWhen(\n-                        invoke.operandCount() > 1\n-                                && invokeOpHelper(buildContext.lookup,instance.op()) instanceof OpHelper.NamedOpHelper.Invoke invoke0\n-                                && invoke0.returnsClassType()\n-                        ,\n-                   \/\/ When we have patterns like:\n-                   \/\/\n-                   \/\/ myiFaceArray.array().value(storeAValue);\n-                   \/\/\n-                   \/\/ We need to generate extra parenthesis to make the struct pointer accessor \"->\" correct.\n-                   \/\/ This is a common pattern when we have a IFace type that contains a subtype based on\n-                   \/\/ struct or union.\n-                   \/\/ An example of this is for the type F16Array.\n-                   \/\/ The following expression checks that the current invokeOp has at least 2 operands:\n-                    \/\/ Why 2?\n-                    \/\/ - The first one is another invokeOp to load the inner struct from an IFace data structure.\n-                    \/\/   The first operand is also assignable.\n-                    \/\/ - The second one is the store value, but this depends on the semantics and definition\n-                    \/\/   of the user code.\n-                    _->{\n-                    when(invoke.returnsClassType(), _ -> ampersand());\n-                    recurse(buildContext, instance.op());\n-                });\n-\n-                \/\/ Check if the varOpLoad that could follow corresponds to a local\/private type\n-                boolean isLocalOrPrivateDS = (instance.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n-                        && buildContext.scope.resolve(varLoadOp.operands().getFirst()) instanceof HATMemoryVarOp);\n-\n-                either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n-\n-                funcName(invoke.op());\n-\n-                if (invoke.returnsVoid()) {\/\/   setter\n-                    switch (invoke.operandCount()) {\n-                        case 2 -> {\n-                            if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n-                                equals().recurse(buildContext, op);\n-                            }\n-                        }\n-                        case 3-> {\n-                            if ( invoke.opFromOperandNAsResultOrThrow(1) instanceof Op op1\n-                                 && invoke.opFromOperandNAsResultOrThrow(2) instanceof Op op2) {\n-                                 sbrace(_ -> recurse(buildContext, op1)).equals().recurse(buildContext, op2);\n-                            }\n-                        }\n-                        default -> throw new IllegalStateException(\"How \");\n-                    }\n-                } else {\n-                    if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n-                        sbrace(_ -> recurse(buildContext, op));\n-                    }else{\n-                            \/\/ this is just call.\n-                    }\n-                }\n-            }\n-        } else {\/\/ General case\n-            funcName(invoke.op()).paren(_ ->\n-                    commaSpaceSeparated(invoke.op().operands(),\n-                            op -> {if (op instanceof Op.Result result) {recurse(buildContext, result.op());}\n-                    })\n-            );\n-        }\n-        return self();\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -32,1 +32,1 @@\n-public abstract class C99HATComputeBuilder<T extends C99HATComputeBuilder<T>> extends C99HATCodeBuilderContext<T> {\n+public abstract class C99HATComputeBuilder<T extends C99HATComputeBuilder<T>> extends C99HATCodeBuilder<T> {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.device.DeviceType;\n@@ -32,0 +33,1 @@\n+import hat.types.HAType;\n@@ -39,0 +41,1 @@\n+import optkl.util.Regex;\n@@ -51,0 +54,1 @@\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -52,1 +56,1 @@\n-public abstract class C99HATKernelBuilder<T extends C99HATKernelBuilder<T>> extends C99HATCodeBuilderContext<T> implements HATOpDispatcher<T> {\n+public abstract class C99HATKernelBuilder<T extends C99HATKernelBuilder<T>> extends C99HATCodeBuilder<T> implements HATOpDispatcher<T> {\n@@ -677,0 +681,134 @@\n+\n+\n+    @Override\n+    public final T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n+        switch (resolve) {\n+            case CoreOp.VarOp $ -> varName($);\n+            case HATMemoryVarOp $ -> varName($);\n+            case HATVectorOp.HATVectorVarOp $ -> varName($);\n+            case HATVectorOp.HATVectorLoadOp $ -> varName($);\n+            case HATVectorOp.HATVectorBinaryOp $ -> varName($);\n+            case HATF16Op.HATF16VarOp $ -> varName($);\n+            case null, default -> {\n+            }\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp) {\n+        Op op = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n+\n+        \/\/TODO see if VarLikeOp marker interface fixes this\n+\n+        \/\/ TODO: each of these is delegating to varName().... maybe varName should be handling these types.\n+\n+        \/\/ When the op is intended to operate as VarOp, then we need to include it in the following switch.\n+        \/\/ This is because HAT has its own dialect, and some of the Ops operate on HAT Types (not included in the Java\n+        \/\/ dialect). For instance, private data structures, local data structures, vector types, etc.\n+        switch (op) {\n+            case CoreOp.VarOp varOp -> varName(varOp);\n+            case HATF16Op.HATF16VarOp hatf16VarOp -> varName(hatf16VarOp);\n+            case HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp);\n+            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp);\n+            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp);\n+            case HATVectorOp.HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp);\n+            case null, default -> throw new IllegalStateException(\"What type of varStoreOp is this?\");\n+        }\n+        equals().parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public final  T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n+        \/\/ TODO: I think we need to work out how to handle doubles. If I remove this OpenCL on MAC complains (no FP64)\n+        if (convOp.resultType() == JavaType.DOUBLE) {\n+            paren(_ -> type(buildContext,JavaType.FLOAT)); \/\/ why double to float?\n+        } else {\n+            paren(_ -> type(buildContext,(JavaType)convOp.resultType()));\n+        }\n+        parenthesisIfNeeded(buildContext, convOp, ((Op.Result) convOp.operands().getFirst()).op());\n+        return self();\n+    }\n+\n+    public abstract  T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name);\n+\n+    static Regex atomicIncRegex = Regex.of(\"(atomic.*)Inc\");\n+\n+    @Override\n+    public final T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n+        var invoke = invokeOpHelper(buildContext.lookup,invokeOp);\n+        if ( invoke.refIs(MappableIface.class, HAType.class, DeviceType.class)) { \/\/ we need a common type\n+            if (invoke.isInstance() && invoke.operandCount() == 1 && invoke.returnsInt() && invoke.named(atomicIncRegex)) {\n+                if (invoke.operandNAsResultOrThrow(0) instanceof Op.Result instanceResult) {\n+                    atomicInc(buildContext, instanceResult,\n+                            ((Regex.Match)atomicIncRegex.is(invoke.name())).stringOf(1) \/\/ atomicXXInc -> atomicXX\n+                    );\n+                }\n+            } else if (invoke.isInstance() && invoke.operandNAsResultOrThrow(0) instanceof Op.Result instance) {\n+                parenWhen(\n+                        invoke.operandCount() > 1\n+                                && invokeOpHelper(buildContext.lookup,instance.op()) instanceof OpHelper.NamedOpHelper.Invoke invoke0\n+                                && invoke0.returnsClassType()\n+                        ,\n+                        \/\/ When we have patterns like:\n+                        \/\/\n+                        \/\/ myiFaceArray.array().value(storeAValue);\n+                        \/\/\n+                        \/\/ We need to generate extra parenthesis to make the struct pointer accessor \"->\" correct.\n+                        \/\/ This is a common pattern when we have a IFace type that contains a subtype based on\n+                        \/\/ struct or union.\n+                        \/\/ An example of this is for the type F16Array.\n+                        \/\/ The following expression checks that the current invokeOp has at least 2 operands:\n+                        \/\/ Why 2?\n+                        \/\/ - The first one is another invokeOp to load the inner struct from an IFace data structure.\n+                        \/\/   The first operand is also assignable.\n+                        \/\/ - The second one is the store value, but this depends on the semantics and definition\n+                        \/\/   of the user code.\n+                        _->{\n+                            when(invoke.returnsClassType(), _ -> ampersand());\n+                            recurse(buildContext, instance.op());\n+                        });\n+\n+                \/\/ Check if the varOpLoad that could follow corresponds to a local\/private type\n+                boolean isLocalOrPrivateDS = (instance.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                        && buildContext.scope.resolve(varLoadOp.operands().getFirst()) instanceof HATMemoryVarOp);\n+\n+                either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n+\n+                funcName(invoke.op());\n+\n+                if (invoke.returnsVoid()) {\/\/   setter\n+                    switch (invoke.operandCount()) {\n+                        case 2 -> {\n+                            if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n+                                equals().recurse(buildContext, op);\n+                            }\n+                        }\n+                        case 3-> {\n+                            if ( invoke.opFromOperandNAsResultOrThrow(1) instanceof Op op1\n+                                    && invoke.opFromOperandNAsResultOrThrow(2) instanceof Op op2) {\n+                                sbrace(_ -> recurse(buildContext, op1)).equals().recurse(buildContext, op2);\n+                            }\n+                        }\n+                        default -> throw new IllegalStateException(\"How \");\n+                    }\n+                } else {\n+                    if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n+                        sbrace(_ -> recurse(buildContext, op));\n+                    }else{\n+                        \/\/ this is just call.\n+                    }\n+                }\n+            }\n+        } else {\/\/ General case\n+            funcName(invoke.op()).paren(_ ->\n+                    commaSpaceSeparated(invoke.op().operands(),\n+                            op -> {if (op instanceof Op.Result result) {recurse(buildContext, result.op());}\n+                            })\n+            );\n+        }\n+        return self();\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":139,"deletions":1,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.codebuilders.C99HATCodeBuilder;\n+import optkl.codebuilders.C99CodeBuilder;\n@@ -45,1 +45,1 @@\n-    private final C99HATCodeBuilder<?> representationBuilder = new C99HATCodeBuilder<>();\n+    private final C99CodeBuilder<?> representationBuilder = new C99CodeBuilder<>();\n@@ -107,1 +107,1 @@\n-    private void materialize(C99HATCodeBuilder<?> builder, Class<?> klass) {\n+    private void materialize(C99CodeBuilder<?> builder, Class<?> klass) {\n@@ -124,1 +124,1 @@\n-                            C99HATCodeBuilder<?> depsBuilder = new C99HATCodeBuilder<>();\n+                            C99CodeBuilder<?> depsBuilder = new C99CodeBuilder<>();\n","filename":"hat\/core\/src\/main\/java\/hat\/device\/DeviceSchema.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}