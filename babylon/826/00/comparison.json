{"files":[{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.OpHelper;\n+import optkl.codebuilders.JavaCodeBuilder;\n+import optkl.util.OpCodeBuilder;\n+\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+public class BlockGroup {\n+\n+    @Reflect\n+    static int m(int a, int b) {\n+        a += 2;\n+        b += 2;\n+\n+        \/\/ Group these\n+        System.out.println(a);\n+        System.out.println(b);\n+\n+        return a + b;\n+    }\n+\n+\n+    static SequencedSet<Op> findGroup(Block b) {\n+        SequencedSet<Op> ops = new TreeSet<>(Comparator.comparingInt(op -> op.parent().ops().indexOf(op)));\n+        for (Op op : b.ops()) {\n+            \/\/ Assuming System.out.println(t) :)\n+            if (op instanceof JavaOp.InvokeOp _) {\n+                Value out = op.operands().get(0);\n+                Value value = op.operands().get(1);\n+\n+                ops.add(OpHelper.asOpFromResultOrNull(out));\n+                ops.add(OpHelper.asOpFromResultOrNull(value));\n+                ops.add(op);\n+            }\n+        }\n+        return ops;\n+    }\n+\n+    static CoreOp.FuncOp group(CoreOp.FuncOp f) {\n+        SequencedSet<Op> group = findGroup(f.body().entryBlock());\n+\n+        return f.transform((block, op) -> {\n+            if (group.contains(op)) {\n+                \/\/ Drop op until we reach the last one\n+                if (group.getLast() == op) {\n+                    \/\/ Create a new body builder connected as a child\n+                    \/\/ Use a child of the code context so values can be shared\n+                    Body.Builder groupBodyBuilder = Body.Builder.of(\n+                            block.parentBody(), CoreType.FUNCTION_TYPE_VOID,\n+                            CodeContext.create(block.context()));\n+\n+                    \/\/ Add ops to the entry block\n+                    Block.Builder groupBlockBuilder = groupBodyBuilder.entryBlock();\n+                    group.forEach(groupBlockBuilder::op);\n+                    groupBlockBuilder.op(CoreOp.core_yield());\n+\n+                    \/\/ Replace all those added ops with the block op\n+                    block.op(JavaOp.block(groupBodyBuilder));\n+                }\n+            } else {\n+                block.op(op);\n+            }\n+            return block;\n+        });\n+    }\n+\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        var lookup = MethodHandles.lookup();\n+        Method m = BlockGroup.class.getDeclaredMethod(\"m\", int.class, int.class);\n+        CoreOp.FuncOp mModel = Op.ofMethod(m).orElseThrow();\n+       \/\/ System.out.println(\"From Code Model             -\\n\"+ OpCodeBuilder.toText(mModel));\n+        System.out.println(\"From Approx Jave Source ------\\n\"+JavaCodeBuilder.toText(lookup,mModel));\n+        CoreOp.FuncOp mGroupModel = group(mModel);\n+      \/\/  System.out.println(\"To Code Model               -\\n\"+ OpCodeBuilder.toText(mGroupModel));\n+        System.out.println(\"To Approx Java Source    ------\\n\"+JavaCodeBuilder.toText(lookup,mGroupModel));\n+\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/BlockGroup.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -93,0 +93,1 @@\n+    T blockOp(SB buildContext, JavaOp.BlockOp blockOp);\n@@ -124,0 +125,1 @@\n+            case JavaOp.BlockOp   $ -> blockOp(buildContext,$);\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/BabylonOpDispatcher.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+\n+\n@@ -62,0 +64,8 @@\n+\n+    public static JavaCodeBuilder of(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        return new JavaCodeBuilder(lookup,funcOp);\n+    }\n+\n+    public static String toText(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        return of(lookup,funcOp).toText();\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaCodeBuilder.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -484,0 +484,8 @@\n+\n+    @Override\n+    public T blockOp(ScopedCodeBuilderContext buildContext, JavaOp.BlockOp blockOp) {\n+      return  brace(_->blockInlineComment(\"from Java.Block\").nl().nlSeparated(OpHelper.Statement.statements(blockOp.body().entryBlock()),\n+               statement ->statement(buildContext,statement)\n+       ).nl());\n+    }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaOrC99StyleCodeBuilder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}