{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.code.CodeElement;\n@@ -38,2 +37,0 @@\n-import java.util.Set;\n-import java.util.stream.Stream;\n@@ -44,3 +41,3 @@\n-        OpHelper.Named.Var.stream(kernelCallGraph.lookup(),funcOp)\n-                .filter(varOpHelper->!varOpHelper.assignable(MappableIface.class, F16.class, BF16.class))\n-                .forEach(varOpHelper->{\n+        OpHelper.Named.Variable.stream(kernelCallGraph.lookup(),funcOp)\n+                .filter(variable ->!variable.assignable(MappableIface.class, F16.class, BF16.class))\n+                .forEach(variable ->{\n@@ -50,1 +47,1 @@\n-                    Op.Result varResult = varOpHelper.op().result();\n+                    Op.Result varResult = variable.op().result();\n@@ -59,1 +56,1 @@\n-                        finalVars.put(varResult, varOpHelper.op());\n+                        finalVars.put(varResult, variable.op());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetector.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -75,2 +75,2 @@\n-        OpHelper.Named.Var.stream(lookup(),funcOp)\n-                .forEach(varHelper->varHelper.op().operands().stream()\n+        OpHelper.Named.Variable.stream(lookup(),funcOp)\n+                .forEach(variable -> variable.op().operands().stream()\n@@ -82,1 +82,1 @@\n-                            nodesInvolved.add(varHelper.op());\n+                            nodesInvolved.add(variable.op());\n@@ -95,2 +95,2 @@\n-            } else if (OpHelper.Named.Var.var(lookup(),op) instanceof OpHelper.Named.Var varHelper && nodesInvolved.contains(varHelper.op())) {\n-                blockBuilder.context().mapValue(varHelper.op().result(), blockBuilder.context().getValue(varHelper.op().operands().getFirst()));\n+            } else if (OpHelper.Named.Variable.var(lookup(),op) instanceof OpHelper.Named.Variable variable && nodesInvolved.contains(variable.op())) {\n+                blockBuilder.context().mapValue(variable.op().result(), blockBuilder.context().getValue(variable.op().operands().getFirst()));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.HashSet;\n@@ -46,2 +47,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -54,0 +53,1 @@\n+import static optkl.OpHelper.copyLocation;\n@@ -87,42 +87,0 @@\n-    private HATVectorOp.HATVectorBinaryOp buildVectorBinaryOp(BinaryOpEnum opType, String varName, TypeElement resultType,\n-                                                              TypeElement vectorElementType, int witdh, List<Value> outputOperands) {\n-        return switch (opType) {\n-            case ADD -> new HATVectorOp.HATVectorBinaryOp.HATVectorAddOp(varName, resultType, vectorElementType, witdh, outputOperands);\n-            case SUB -> new HATVectorOp.HATVectorBinaryOp.HATVectorSubOp(varName, resultType, vectorElementType, witdh, outputOperands);\n-            case MUL -> new HATVectorOp.HATVectorBinaryOp.HATVectorMulOp(varName, resultType, vectorElementType, witdh, outputOperands);\n-            case DIV -> new HATVectorOp.HATVectorBinaryOp.HATVectorDivOp(varName, resultType, vectorElementType, witdh, outputOperands);\n-        };\n-    }\n-\n-    private void insertVectorLoadOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp, CoreOp.VarOp varOp, boolean isShared) {\n-        List<Value> inputOperandsVarOp = invokeOp.operands();\n-        List<Value> outputOperandsVarOp = blockBuilder.context().getValues(inputOperandsVarOp);\n-        VectorMetaData metaData = getVectorTypeInfo(lookup(),invokeOp);\n-        HATVectorOp memoryViewOp = new HATVectorOp.HATVectorLoadOp(varOp.varName(), varOp.resultType(), metaData.vectorTypeElement(), metaData.lanes(), isShared, outputOperandsVarOp);\n-        Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n-        memoryViewOp.setLocation(varOp.location());\n-        blockBuilder.context().mapValue(invokeOp.result(), hatLocalResult);\n-    }\n-\n-    private void insertVectorVarOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, Map<Op, VectorMetaData> vectorMetaData) {\n-        List<Value> inputOperandsVarOp = varOp.operands();\n-        List<Value> outputOperandsVarOp = blockBuilder.context().getValues(inputOperandsVarOp);\n-        VectorMetaData vmd = vectorMetaData.get(varOp);\n-        HATVectorOp memoryViewOp = new HATVectorOp.HATVectorVarOp(varOp.varName(), varOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperandsVarOp);\n-        Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n-        memoryViewOp.setLocation(varOp.location());\n-        blockBuilder.context().mapValue(varOp.result(), hatLocalResult);\n-    }\n-\n-    public void insertBinaryOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp,\n-                               Map<Op, VectorMetaData> vectorMetaData, Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation) {\n-        List<Value> inputOperands = invokeOp.operands();\n-        List<Value> outputOperands = blockBuilder.context().getValues(inputOperands);\n-        BinaryOpEnum binaryOpType = binaryOperation.get(invokeOp);\n-        VectorMetaData vmd = vectorMetaData.get(invokeOp);\n-        HATVectorOp memoryViewOp = buildVectorBinaryOp(binaryOpType, varOp.varName(),\n-                invokeOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperands);\n-        Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n-        memoryViewOp.setLocation(varOp.location());\n-        blockBuilder.context().mapValue(invokeOp.result(), hatVectorOpResult);\n-    }\n@@ -130,44 +88,9 @@\n-    private void insertVectorVarLoadOp(Block.Builder blockBuilder, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        List<Value> inputOperandsVarLoad = varLoadOp.operands();\n-        List<Value> outputOperandsVarLoad = blockBuilder.context().getValues(inputOperandsVarLoad);\n-        String varLoadName = HATPhaseUtils.findVectorVarNameOrNull(varLoadOp);\n-        int lanes = HATPhaseUtils.getVectorWidth(varLoadOp);\n-        TypeElement vectorElementType = HATPhaseUtils.findVectorTypeElement(varLoadOp);\n-        HATVectorOp memoryViewOp = new HATVectorOp.HATVectorVarLoadOp(varLoadName, varLoadOp.resultType(), vectorElementType, lanes, outputOperandsVarLoad);\n-        Op.Result hatVectorResult = blockBuilder.op(memoryViewOp);\n-        memoryViewOp.setLocation(varLoadOp.location());\n-        blockBuilder.context().mapValue(varLoadOp.result(), hatVectorResult);\n-    }\n-\n-    public void insertVectorBinaryOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp,\n-                                     Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation) {\n-        List<Value> inputOperands = invokeOp.operands();\n-        List<Value> outputOperands = blockBuilder.context().getValues(inputOperands);\n-        VectorMetaData vectorMetaData = getVectorTypeInfo(lookup(),invokeOp);\n-        HATVectorOp memoryViewOp = buildVectorBinaryOp(binaryOperation.get(invokeOp), \"null\", invokeOp.resultType(), vectorMetaData.vectorTypeElement(), vectorMetaData.lanes(), outputOperands);\n-        Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n-        memoryViewOp.setLocation(invokeOp.location());\n-        blockBuilder.context().mapValue(invokeOp.result(), hatVectorOpResult);\n-    }\n-\n-    public void insertVectorOfOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp,\n-                                 Map<Op, VectorMetaData> vectorMetaData) {\n-        List<Value> inputOperandsVarOp = invokeOp.operands();\n-        List<Value> outputOperandsVarOp = blockBuilder.context().getValues(inputOperandsVarOp);\n-        VectorMetaData vmd = vectorMetaData.get(invokeOp);\n-        HATVectorOp.HATVectorOfOp memoryViewOp = new HATVectorOp.HATVectorOfOp(invokeOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperandsVarOp);\n-        Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n-        memoryViewOp.setLocation(invokeOp.location());\n-        blockBuilder.context().mapValue(invokeOp.result(), hatLocalResult);\n-    }\n-\n-    public void insertVectorMakeOfOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp,\n-                                     Map<Op, VectorMetaData> vectorMetaData) {\n-        List<Value> inputOperandsVarOp = invokeOp.operands();\n-        List<Value> outputOperandsVarOp = blockBuilder.context().getValues(inputOperandsVarOp);\n-        String varName = HATPhaseUtils.findVectorVarNameOrNull(invokeOp.operands().getFirst());\n-        VectorMetaData vmd = vectorMetaData.get(invokeOp);\n-        HATVectorOp.HATVectorMakeOfOp makeOf = new HATVectorOp.HATVectorMakeOfOp(varName, invokeOp.resultType(), vmd.lanes(), outputOperandsVarOp);\n-        Op.Result hatLocalResult = blockBuilder.op(makeOf);\n-        makeOf.setLocation(invokeOp.location());\n-        blockBuilder.context().mapValue(invokeOp.result(), hatLocalResult);\n+    private void addVectorVarOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, VectorMetaData vectorMetaData) {\n+        HATVectorOp memoryViewOp = new HATVectorOp.HATVectorVarOp(\n+                varOp.varName(),\n+                varOp.resultType(),\n+                vectorMetaData.vectorTypeElement(),\n+                vectorMetaData.lanes(),\n+                blockBuilder.context().getValues(varOp.operands())\n+        );\n+        blockBuilder.context().mapValue(varOp.result(), blockBuilder.op(copyLocation(varOp,memoryViewOp)));\n@@ -178,12 +101,9 @@\n-        OpHelper.Named.Var.stream(lookup(),funcOp)\n-                 .forEach(var-> var.op().operands().stream()\n-                      .filter(operand->operand instanceof Op.Result result && result.op() instanceof JavaOp.InvokeOp)\n-                      .map(operand-> invoke(lookup(),((Op.Result)operand).op()))\n-                      .filter(invoke ->  invoke.returns(_V.class) && invoke.named(vectorOperation.methodName))\n-                      .forEach(invoke -> {\n-                           \/\/ Associate both ops to the vectorTypeInfo for easy access to type and lanes\n-                            VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(), invoke.op());\n-                            vectorMetaData.put(invoke.op(), vectorTypeInfo);\n-                            vectorMetaData.put(var.op(), vectorTypeInfo);\n-                      })\n-                );\n+        Map<JavaOp.InvokeOp, CoreOp.VarOp> invokeToVar = new HashMap<>();\n+        OpHelper.Named.Variable.stream(lookup(),funcOp).forEach(v ->{\n+             if (v.firstOperandAsInvoke() instanceof Invoke i && i.returns(_V.class) && i.named(vectorOperation.methodName)){\n+                 VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(), i.op());\n+                 vectorMetaData.put(i.op(), vectorTypeInfo);\n+                 vectorMetaData.put(v.op(), vectorTypeInfo);\n+                 invokeToVar.put(i.op(),v.op());\n+             }\n+        });\n@@ -193,7 +113,11 @@\n-                boolean isShared = HATPhaseUtils.isSharedOrPrivate(invoke.resultFromFirstOperandOrNull()\/*invokeOp.operands().getFirst()*\/);\n-                List<Op.Result> collect = invoke.op().result().uses().stream().toList();\n-                for (Op.Result r : collect) {\n-                    if (r.op() instanceof CoreOp.VarOp varOp) {\n-                        insertVectorLoadOp(blockBuilder, invoke.op(), varOp, isShared);\n-                    }\n-                }\n+                var varOp = invokeToVar.get(invoke.op());\n+                VectorMetaData metaData = getVectorTypeInfo(lookup(),invoke.op());\n+                HATVectorOp memoryViewOp = new HATVectorOp.HATVectorLoadOp(\n+                        varOp.varName(),\n+                        varOp.resultType(),\n+                        metaData.vectorTypeElement(),\n+                        metaData.lanes(),\n+                        HATPhaseUtils.isSharedOrPrivate(invoke.resultFromFirstOperandOrNull()),\n+                        blockBuilder.context().getValues(invoke.op().operands())\n+                );\n+                blockBuilder.context().mapValue(invoke.op().result(), blockBuilder.op(copyLocation(varOp,memoryViewOp)));\n@@ -201,1 +125,1 @@\n-                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                addVectorVarOp(blockBuilder, varOp, vectorMetaData.get(varOp));\n@@ -207,17 +131,0 @@\n-    private CoreOp.FuncOp dialectifyVectorOf(CoreOp.FuncOp funcOp) {\n-        Map<Op, VectorMetaData> vectorMetaData = new HashMap<>();\n-        Stream<CodeElement<?, ?>> vectorNodes = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (invoke(lookup(),codeElement) instanceof Invoke invoke\n-                         &&invoke.returns(_V.class) && invoke.named(vectorOperation.methodName) ) {\n-                            consumer.accept(invoke.op());\n-                            Set<Op.Result> uses = invoke.op().result().uses();\n-                            for (Op.Result result : uses) {\n-                                if (result.op() instanceof CoreOp.VarOp varOp) {\n-                                    consumer.accept(varOp);\n-                                    VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(),invoke.op());\n-                                    vectorMetaData.put(invoke.op(), vectorTypeInfo);\n-                                    vectorMetaData.put(varOp, vectorTypeInfo);\n-                                }\n-                            }\n-                        }\n@@ -225,1 +132,9 @@\n-                });\n+    private HATVectorOp.HATVectorBinaryOp buildVectorBinaryOp(BinaryOpEnum opType, String varName, TypeElement resultType,\n+                                                              TypeElement vectorElementType, int witdh, List<Value> outputOperands) {\n+        return switch (opType) {\n+            case ADD -> new HATVectorOp.HATVectorBinaryOp.HATVectorAddOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+            case SUB -> new HATVectorOp.HATVectorBinaryOp.HATVectorSubOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+            case MUL -> new HATVectorOp.HATVectorBinaryOp.HATVectorMulOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+            case DIV -> new HATVectorOp.HATVectorBinaryOp.HATVectorDivOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+        };\n+    }\n@@ -227,1 +142,11 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = vectorNodes.collect(Collectors.toSet());\n+    private CoreOp.FuncOp dialectifyVectorBinaryOps(CoreOp.FuncOp funcOp) {\n+        Map<Op, VectorMetaData> vectorMetaDataMap = new HashMap<>();\n+        Map<JavaOp.InvokeOp, CoreOp.VarOp> invokeToVar = new HashMap<>();\n+        OpHelper.Named.Variable.stream(lookup(),funcOp).forEach(v -> {\n+            if (v.firstOperandAsInvoke() instanceof Invoke i && i.named(vectorOperation.methodName) && i.returns(_V.class)) {\n+                VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(), i.op());\n+                vectorMetaDataMap.put(i.op(), vectorTypeInfo);\n+                vectorMetaDataMap.put(v.op(), vectorTypeInfo);\n+                invokeToVar.put(i.op(), v.op());\n+            }\n+        });\n@@ -229,5 +154,13 @@\n-        return Trxfmr.of(this,funcOp).transform(_->true, (blockBuilder, op) -> {\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                insertVectorOfOp(blockBuilder, invokeOp, vectorMetaData);\n+        return Trxfmr.of(this,funcOp).transform( vectorMetaDataMap::containsKey, (blockBuilder, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                var varOp = invokeToVar.get(invokeOp);\n+                var vectorMetaData = vectorMetaDataMap.get(invokeOp);\n+                HATVectorOp memoryViewOp =  buildVectorBinaryOp(\n+                        BinaryOpEnum.of(invokeOp),\n+                        varOp.varName(),\n+                        invokeOp.resultType(),\n+                        vectorMetaData.vectorTypeElement(),\n+                        vectorMetaData.lanes(),\n+                        blockBuilder.context().getValues(invokeOp.operands())\n+                );\n+                blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(copyLocation(varOp,memoryViewOp)));\n@@ -235,1 +168,1 @@\n-                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                addVectorVarOp(blockBuilder, varOp, vectorMetaDataMap.get(varOp));\n@@ -241,3 +174,1 @@\n-    private CoreOp.FuncOp dialectifyVectorBinaryOps(CoreOp.FuncOp funcOp) {\n-\n-        Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation = new HashMap<>();\n+    private  Map<Op, VectorMetaData> getVectorMetaDataMap(CoreOp.FuncOp funcOp){\n@@ -245,21 +176,6 @@\n-\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof CoreOp.VarOp varOp) {\n-                        List<Value> inputOperandsVarOp = varOp.operands();\n-                        for (Value inputOperand : inputOperandsVarOp) {\n-                            if (inputOperand instanceof Op.Result result) {\n-                                if (invoke(lookup(),result.op()) instanceof Invoke invoke ) {\n-                                    if (invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)) {\n-                                        BinaryOpEnum binaryOpType = BinaryOpEnum.of(invoke.op());\n-                                        binaryOperation.put(invoke.op(), binaryOpType);\n-                                        VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(),invoke.op());\n-                                        vectorMetaData.put(invoke.op(), vectorTypeInfo);\n-                                        vectorMetaData.put(varOp, vectorTypeInfo);\n-                                        consumer.accept(invoke.op());\n-                                        consumer.accept(varOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n+        Invoke.stream(lookup(),funcOp).\n+                filter(i -> i.returns(_V.class) && i.named(vectorOperation.methodName) && i.onlyUse() instanceof CoreOp.VarOp)\n+                .forEach(i -> {\n+                    VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(), i.op());\n+                    vectorMetaData.put(i.op(), vectorTypeInfo);\n+                    vectorMetaData.put(i.onlyUse(), vectorTypeInfo);\n@@ -267,0 +183,2 @@\n+        return vectorMetaData;\n+    }\n@@ -268,1 +186,0 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n@@ -270,1 +187,4 @@\n-        return Trxfmr.of(this,funcOp).transform( nodesInvolved::contains, (blockBuilder, op) -> {\n+    private CoreOp.FuncOp dialectifyVectorOf(CoreOp.FuncOp funcOp) {\n+        Map<Op, VectorMetaData> vectorMetaDataMap = getVectorMetaDataMap(funcOp);\n+\n+        return Trxfmr.of(this,funcOp).transform(vectorMetaDataMap::containsKey, (blockBuilder, op) -> {\n@@ -272,8 +192,8 @@\n-                Op.Result result = invokeOp.result();\n-                List<Op.Result> collect = result.uses().stream().toList();\n-                for (Op.Result r : collect) {\n-                    if (r.op() instanceof CoreOp.VarOp varOp) {\n-                        insertBinaryOp(blockBuilder, varOp, invokeOp, vectorMetaData, binaryOperation);\n-                        break;\n-                    }\n-                }\n+                var vectorMetaData = vectorMetaDataMap.get(invokeOp);\n+                HATVectorOp.HATVectorOfOp memoryViewOp = new HATVectorOp.HATVectorOfOp(\n+                        invokeOp.resultType(),\n+                        vectorMetaData.vectorTypeElement(),\n+                        vectorMetaData.lanes(),\n+                        blockBuilder.context().getValues(invokeOp.operands())\n+                );\n+                blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(copyLocation(invokeOp,memoryViewOp)));\n@@ -281,1 +201,1 @@\n-                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                addVectorVarOp(blockBuilder, varOp, vectorMetaDataMap.get(varOp));\n@@ -288,26 +208,11 @@\n-        Map<Op, VectorMetaData> vectorMetaData = new HashMap<>();\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (invoke(lookup(),codeElement) instanceof Invoke invoke) {\n-                        if (invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)) {\n-                            consumer.accept(invoke.op());\n-                            VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(),invoke.op());\n-                            vectorMetaData.put(invoke.op(), vectorTypeInfo);\n-                            Set<Op.Result> uses = invoke.op().result().uses();\n-                            for (Op.Result result : uses) {\n-                                if (result.op() instanceof CoreOp.VarOp varOp) {\n-                                    consumer.accept(varOp);\n-                                    vectorMetaData.put(varOp, vectorTypeInfo);\n-                                }\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-\n-        funcOp = Trxfmr.of(this,funcOp).transform(_->true, (blockBuilder, op) -> {\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                insertVectorMakeOfOp(blockBuilder, invokeOp, vectorMetaData);\n+        Map<Op, VectorMetaData> vectorMetaDataMap = getVectorMetaDataMap(funcOp);\n+        return Trxfmr.of(this,funcOp).transform(ce->vectorMetaDataMap.containsKey(ce), (blockBuilder, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                var vectorMetaData = vectorMetaDataMap.get(invokeOp);\n+                HATVectorOp.HATVectorMakeOfOp makeOf = new HATVectorOp.HATVectorMakeOfOp(\n+                        HATPhaseUtils.findVectorVarNameOrNull(invokeOp.operands().getFirst()),\n+                        invokeOp.resultType(),\n+                        vectorMetaData.lanes(),\n+                        blockBuilder.context().getValues(invokeOp.operands())\n+                );\n+                blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(copyLocation(invokeOp,makeOf)));\n@@ -315,1 +220,1 @@\n-                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                addVectorVarOp(blockBuilder, varOp, vectorMetaDataMap.get(varOp));\n@@ -319,1 +224,0 @@\n-        return funcOp;\n@@ -322,0 +226,2 @@\n+\n+\n@@ -323,15 +229,10 @@\n-        Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation = new HashMap<>();\n-        Stream<CodeElement<?, ?>> vectorNodes = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (invoke(lookup(),codeElement) instanceof Invoke invoke) {\n-                        if (invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)) {\n-                            List<Value> inputOperandsInvoke = invoke.op().operands();\n-                            for (Value inputOperand : inputOperandsInvoke) {\n-                                if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                    BinaryOpEnum binaryOpType = BinaryOpEnum.of(invoke.op());\n-                                    binaryOperation.put(invoke.op(), binaryOpType);\n-                                    consumer.accept(varLoadOp);\n-                                    consumer.accept(invoke.op());\n-                                }\n-                            }\n-                        }\n+        Set<CodeElement<?, ?>> nodesInvolved = new HashSet<>();\n+        funcOp.elements().forEach(codeElement->{\n+                    if (invoke(lookup(),codeElement) instanceof Invoke invoke && invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)) {\n+                            invoke.op().operands().stream()\/\/ this can't be replaced with findFirst\n+                                    .filter(operand->operand instanceof Op.Result && ((Op.Result) operand).op() instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                                    .map(operand->(CoreOp.VarAccessOp.VarLoadOp) ((Op.Result)operand).op())\n+                                    .forEach(varLoadOp -> {\n+                                        nodesInvolved.add(varLoadOp);\n+                                        nodesInvolved.add(invoke.op());\n+                                    });\n@@ -339,6 +240,4 @@\n-                        List<Value> inputOperandsInvoke = hatVectorBinaryOp.operands();\n-                        for (Value inputOperand : inputOperandsInvoke) {\n-                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                consumer.accept(varLoadOp);\n-                            }\n-                        }\n+                        hatVectorBinaryOp.operands().stream()\n+                                .filter(operand->operand instanceof Op.Result && ((Op.Result) operand).op() instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                                .map(operand->(CoreOp.VarAccessOp.VarLoadOp) ((Op.Result)operand).op())\n+                                .forEach(nodesInvolved::add);\n@@ -348,3 +247,2 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = vectorNodes.collect(Collectors.toSet());\n-        if (!nodesInvolved.isEmpty()) {\n-            funcOp = Trxfmr.of(this,funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+\n+           return Trxfmr.of(this,funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n@@ -352,1 +250,10 @@\n-                    insertVectorBinaryOp(blockBuilder, invokeOp, binaryOperation);\n+                     VectorMetaData vectorMetaData = getVectorTypeInfo(lookup(),invokeOp);\n+                     HATVectorOp memoryViewOp = buildVectorBinaryOp(\n+                             BinaryOpEnum.of(invokeOp),\n+                             \"null\", \/\/ it looks like not all of these ops have varName maybe we need another class in the dielect\n+                             invokeOp.resultType(),\n+                             vectorMetaData.vectorTypeElement(),\n+                             vectorMetaData.lanes(),\n+                             blockBuilder.context().getValues(invokeOp.operands())\n+                     );\n+                     blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(copyLocation(invokeOp,memoryViewOp)));\n@@ -354,1 +261,8 @@\n-                    insertVectorVarLoadOp(blockBuilder, varLoadOp);\n+                     HATVectorOp memoryViewOp = new HATVectorOp.HATVectorVarLoadOp(\n+                             HATPhaseUtils.findVectorVarNameOrNull(varLoadOp),\n+                             varLoadOp.resultType(),\n+                             HATPhaseUtils.findVectorTypeElement(varLoadOp),\n+                             HATPhaseUtils.getVectorWidth(varLoadOp),\n+                             blockBuilder.context().getValues(varLoadOp.operands())\n+                     );\n+                     blockBuilder.context().mapValue(varLoadOp.result(), blockBuilder.op(copyLocation(varLoadOp,memoryViewOp)));\n@@ -358,2 +272,0 @@\n-        }\n-        return funcOp;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":136,"deletions":224,"binary":false,"changes":360,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import optkl.OpHelper;\n@@ -53,1 +52,1 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Func.Statement;\n+import static optkl.OpHelper.Statement;\n@@ -57,2 +56,0 @@\n-import static optkl.OpHelper.getFuncParamOrNull;\n-import static optkl.OpHelper.methodModelOrNull;\n@@ -62,0 +59,46 @@\n+\n+    static class IfaceBufferAccessStatementSpan implements Statement.Span{\n+        enum Acc{NONE,ACCESSES,MUTATES;\n+\n+            public boolean accessesOrMutates() {\n+                return equals(ACCESSES)|equals(MUTATES);\n+            }\n+        }\n+        private final List<Op> ops;\n+        private final Set<Value> mutates = new HashSet<>();\n+        private final Set<Value> accesses = new HashSet<>();\n+        private  Value ifaceBuffer;\n+\n+        IfaceBufferAccessStatementSpan(List<Op> ops){\n+            this.ops = ops;\n+        }\n+        @Override public  List<Op> ops(){\n+            return ops;\n+        }\n+\n+        void put(Value value, boolean mutate) {\n+            if (mutate) {\n+                mutates.add(value);\n+            } else {\n+                accesses.add(value);\n+            }\n+        }\n+        boolean mutates(Value value){\n+            return IfaceBufferAccessStatementSpan.this.mutates.contains(value);\n+        }\n+        boolean accesses(Value value){\n+            return IfaceBufferAccessStatementSpan.this.accesses.contains(value);\n+        }\n+        boolean accessesOrMutates(Value value){\n+            return mutates(value)|accesses(value);\n+        }\n+        boolean accessesAndMutates(Value value){\n+            return mutates(value)&accesses(value);\n+        }\n+\n+        public String describe(Value value) {\n+            return  (mutates(value) ? \"mutates \" : \"\") + (accessesAndMutates(value) ? \"and \" : \"\") + (accesses(value) ? \"accesses \" : \"\");\n+        }\n+    }\n+\n+\n@@ -72,0 +115,1 @@\n+        int[] arr  = new int[2 * s32Array.length()];\n@@ -74,0 +118,2 @@\n+        KernelContext kcNull = null;\n+        inc(kcNull,s32Array,20);\n@@ -76,1 +122,2 @@\n-            System.out.println(i);\n+            s32Array.array(0,1);\n+            System.out.println(\"Weird \"+s32Array.array(0)+s32Array.length());\n@@ -79,2 +126,0 @@\n-\n-\n@@ -85,27 +130,5 @@\n-        record StatementSpanImpl(Set<Value> mutates, Set<Value> accesses, \/\/ Either Access or Mutate\n-                                 Mutable<Value> mutableIfaceBuffer,\n-                                 List<Op> ops) implements Statement.Span {\n-            void put(Value value, boolean mutate) {\n-                if (mutate) {\n-                    mutates.add(value);\n-                } else {\n-                    accesses.add(value);\n-                }\n-            }\n-            boolean mutates(Value value){\n-                return StatementSpanImpl.this.mutates.contains(value);\n-            }\n-            boolean accesses(Value value){\n-                return StatementSpanImpl.this.accesses.contains(value);\n-            }\n-            boolean accessesOrMutates(Value value){\n-                return mutates(value)|accesses(value);\n-            }\n-            boolean accessesAndMutates(Value value){\n-                return mutates(value)&accesses(value);\n-            }\n-\n-            public String describe(Value value) {\n-                return  (mutates(value) ? \"mutates \" : \"\") + (accessesAndMutates(value) ? \"and \" : \"\") + (accesses(value) ? \"accesses \" : \"\");\n-            }\n-        }\n+        \/\/ The resulting map, maps all ops to their enclosing statement (spans)\n+        \/\/ This will be useful later as we mark these spans with information regarding how the enclosing ops access ifacemapped buffers\n+        Map<Op, IfaceBufferAccessStatementSpan> opToStatementSpans = createOpToStatementSpanMap(func.op(),\n+                o->o instanceof JavaOp.InvokeOp, \/\/ only care if we span an invoke of some kind.\n+                IfaceBufferAccessStatementSpan::new);\n@@ -113,8 +136,1 @@\n-        \/\/ The resulting map, maps all ops to their enclosing statements but only if the statement contains an invokeOp.\n-        \/\/ Here we look for iface->set\/get and add value -> access type mappings\n-        Map<Op, StatementSpanImpl> opToStatementSpans = createOpToStatementSpanMap(func.op(),\n-                op -> op instanceof JavaOp.InvokeOp, \/\/ we only care if the statement actually contains an invoke\n-                ops -> new StatementSpanImpl(new HashSet<>(), new HashSet<>(), Mutable.of(null), ops)\n-        );\n-\n-        \/\/ This query helps locate mappedIfaceBuffer accessors or mutators\n+        \/\/ This query is useful helps locating access of mappedIfaceBuffer accessors or mutators\n@@ -123,0 +139,1 @@\n+        \/\/ We walk over each span and determine whether it has such an invoke.\n@@ -136,1 +153,0 @@\n-        \/\/ Now we have enough info to transform.  We now look like statement first and last ops and inject before or after ,\n@@ -138,3 +154,3 @@\n-\n-        enum Acc{NONE,ACCESSES,MUTATES}\n-\n+var spinCounter = Mutable.of(0);\n+        \/\/ We finally have have enough information  to transform.\n+        \/\/ We are looking at the edges of statements ,\n@@ -144,3 +160,2 @@\n-                .transform(ce -> ce instanceof Op op\n-                        && opToStatementSpans.containsKey(op)\n-                        && opToStatementSpans.get(ce).firstOrLast(op),\n+                .transform(ce -> ce instanceof Op op \/\/ only want ops the leading or trailing edge of the statement\n+                        && opToStatementSpans.containsKey(op) && opToStatementSpans.get(ce).firstOrLast(op),\n@@ -151,1 +166,1 @@\n-                    if (statementSpan.isTo(c.op())) {\n+                    if (statementSpan.isFirst(c.op())) {\n@@ -154,1 +169,1 @@\n-                    var acc = Mutable.of(Acc.NONE);\n+                    var acc = Mutable.of(IfaceBufferAccessStatementSpan.Acc.NONE);\n@@ -162,1 +177,1 @@\n-                                                    yield Acc.MUTATES;\n+                                                    yield IfaceBufferAccessStatementSpan.Acc.MUTATES;\n@@ -164,1 +179,1 @@\n-                                                    yield Acc.ACCESSES;\n+                                                    yield IfaceBufferAccessStatementSpan.Acc.ACCESSES;\n@@ -171,1 +186,1 @@\n-                                                    yield Acc.MUTATES;\n+                                                    yield IfaceBufferAccessStatementSpan.Acc.MUTATES;\n@@ -180,3 +195,8 @@\n-                            if (!acc.get().equals(Acc.NONE)) {\n-                                var msg = (statementSpan.isTo(c.op()) ? \"Prev\" : \"Next\") + \" statement \" +acc.get() + \" iface mapped buffer \";\n-                                c.add(JavaOp.invoke(JavaType.VOID, Println, c.builder().op(CoreOp.constant(JavaType.J_L_STRING, msg))));\n+                            if (acc.get().accessesOrMutates()) {\n+                                var msg = (statementSpan.isFirst(c.op()) ? \"Prev\" : \"Next\") + \" statement \" +acc.get() + \" iface mapped buffer \";\n+                                var constant= CoreOp.constant(JavaType.J_L_STRING, msg);\n+                                System.out.println(\"spin \"+msg+\" \"+spinCounter.get()+\" \"+constant.resultType());\n+                                spinCounter.set(spinCounter.get()+1);\n+                                boolean useCursorAdd = false;\n+                                var msgStringResult = useCursorAdd?c.add(constant):c.builder().op(constant);\n+                                c.add(JavaOp.invoke(JavaType.VOID, Println, msgStringResult));\n@@ -184,1 +204,1 @@\n-                    if (statementSpan.isFrom(c.op())){\n+                    if (statementSpan.isLast(c.op())){\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InjectBufferTracking.java","additions":78,"deletions":58,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+\n@@ -260,1 +262,1 @@\n-            permits Named.NamedStaticOrInstance, Named.Var, Named.VarAccess {\n+            permits Named.NamedStaticOrInstance, Named.Variable, Named.VarAccess {\n@@ -295,1 +297,1 @@\n-        sealed interface Var extends Named<CoreOp.VarOp> {\n+        sealed interface Variable extends Named<CoreOp.VarOp> {\n@@ -309,3 +311,7 @@\n-            record Impl(MethodHandles.Lookup lookup, CoreOp.VarOp op) implements Var {}\n-            static Var var(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement) {\n-                return codeElement instanceof CoreOp.VarOp varOp ? new Var.Impl(lookup, varOp) : null;\n+            default NamedStaticOrInstance.Invoke firstOperandAsInvoke(){\n+                return invoke(lookup(),opFromFirstOperandOrNull());\n+            }\n+\n+            record Impl(MethodHandles.Lookup lookup, CoreOp.VarOp op) implements Variable {}\n+            static Variable var(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement) {\n+                return codeElement instanceof CoreOp.VarOp varOp ? new Variable.Impl(lookup, varOp) : null;\n@@ -313,1 +319,1 @@\n-            static Stream<Var> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+            static Stream<Variable> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n@@ -595,0 +601,7 @@\n+                default Op onlyUse(){\n+                    if (op().result().uses().size()==1){\n+                        return op().result().uses().iterator().next().op();\n+                    }else {\n+                        return null;\n+                    }\n+                }\n@@ -633,1 +646,1 @@\n-                return isTo(op)||isFrom(op);\n+                return isFirst(op)|| isLast(op);\n@@ -635,1 +648,1 @@\n-            default boolean isTo(Op op) {\n+            default boolean isFirst(Op op) {\n@@ -638,1 +651,1 @@\n-            default boolean isFrom(Op op) {\n+            default boolean isLast(Op op) {\n@@ -668,0 +681,4 @@\n+        static <T extends Span> Map<Op,T> createOpToStatementSpanMap(CoreOp.FuncOp funcOp, Function<List<Op>,T> factory ) {\n+            return createOpToStatementSpanMap(funcOp,_->true,factory);\n+        }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-                    handled(true);\n+                    handled(true); \/\/ is this appropriate here?\n@@ -260,0 +260,1 @@\n+\n@@ -380,3 +381,3 @@\n-        var newFuncOp = funcOp().transform(name,(blockBuilder, op) -> {\n-            if (predicate.test(op)){\n-                Cursor cursor = Cursor.of(this, funcOp, blockBuilder,op);\n+        var newFuncOp = funcOp().transform(name,(blockBuilder, cursorOp) -> {\n+            if (predicate.test(cursorOp)){\n+                Cursor cursor = Cursor.of(this, funcOp, blockBuilder,cursorOp);\n@@ -385,1 +386,3 @@\n-                    biMap.add(op,blockBuilder.op(op).op());\n+                    var result = blockBuilder.op(cursorOp);\n+                    var opFromResult= result.op();\n+                    biMap.add(cursorOp,opFromResult);\n@@ -388,1 +391,14 @@\n-                biMap.add(op,blockBuilder.op(op).op());\n+                try {\n+                    if (cursorOp instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp){\n+                        \/\/System.out.println(\"Is it this one? \"+varLoadOp.varType());\n+                        if (varLoadOp.varType().valueType() instanceof PrimitiveType primitiveType){\n+                          \/\/  System.out.println(\"It seems to be this primitive \"+primitiveType);\n+                        }\n+                    }\n+                    var result = blockBuilder.op(cursorOp);\n+                    var opFromResult = result.op();\n+                    biMap.add(cursorOp, opFromResult);\n+                }catch (Throwable t){\n+                    t = t;\n+                    throw new RuntimeException(t);\n+                }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"}]}