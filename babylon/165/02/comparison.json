{"files":[{"patch":"@@ -64,1 +64,0 @@\n-import java.lang.classfile.constantpool.ClassEntry;\n@@ -68,1 +67,0 @@\n-import java.lang.reflect.code.Block.Parameter;\n@@ -72,0 +70,1 @@\n+import java.util.Arrays;\n@@ -73,0 +72,1 @@\n+import java.util.stream.Stream;\n@@ -83,1 +83,2 @@\n-    private final CodeModel codeModel;\n+    private final ClassModel classModel;\n+    private final List<ExceptionCatch> exceptionHandlers;\n@@ -107,8 +108,1 @@\n-    private TypeElement toTypeElement(ClassEntry ce) {\n-        return JavaType.type(ce.asSymbol());\n-    }\n-\n-    private BytecodeLift(Block.Builder entryBlock, MethodModel methodModel, Value... capturedValues) {\n-        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n-            throw new IllegalArgumentException(\"Unsuported lift of non-static method: \" + methodModel);\n-        }\n+    private BytecodeLift(Block.Builder entryBlock, ClassModel classModel, CodeModel codeModel, Value... capturedValues) {\n@@ -117,1 +111,2 @@\n-        this.codeModel = methodModel.code().orElseThrow();\n+        this.classModel = classModel;\n+        this.exceptionHandlers = codeModel.exceptionHandlers();\n@@ -126,12 +121,8 @@\n-        MethodTypeDesc mtd = methodModel.methodTypeSymbol();\n-        int slot = 0, i = 0;\n-        for (Value cap : capturedValues) {\n-            op(SlotOp.store(slot, cap));\n-            slot += TypeKind.from(mtd.parameterType(i++)).slotSize();\n-        }\n-        for (Parameter bp : entryBlock.parameters()) {\n-            op(SlotOp.store(slot, bp));\n-            slot += TypeKind.from(mtd.parameterType(i++)).slotSize();\n-        }\n-\n-        this.codeTracker = new LocalsTypeMapper(methodModel.parent().get().thisClass().asSymbol(), mtd, methodModel.flags().has(AccessFlag.STATIC), smta, elements);\n+        ArrayList<ClassDesc> locals = new ArrayList<>();\n+        Stream.concat(Arrays.stream(capturedValues), entryBlock.parameters().stream()).forEachOrdered(val -> {\n+            op(SlotOp.store(locals.size(), val));\n+            ClassDesc locType = BytecodeGenerator.toClassDesc(val.type());\n+            locals.add(locType);\n+            if (TypeKind.from(locType).slotSize() == 2) locals.add(null);\n+        });\n+        this.codeTracker = new LocalsTypeMapper(classModel.thisClass().asSymbol(), locals, smta, elements);\n@@ -158,1 +149,17 @@\n-        var lifted = CoreOp.func(\n+        CoreOp.FuncOp lifted = liftToSlots(methodModel);\n+        try {\n+            return SlotSSA.transform(lifted);\n+        } catch (Exception e) {\n+            System.out.println(\"lifted:\");\n+            lifted.writeTo(System.out);\n+            throw new IllegalStateException(\"SlotSSA transformation failed\");\n+        }\n+    }\n+\n+    private static CoreOp.FuncOp liftToSlots(MethodModel methodModel) {\n+        ClassModel classModel = methodModel.parent().orElseThrow();\n+        MethodTypeDesc mDesc = methodModel.methodTypeSymbol();\n+        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n+            mDesc = mDesc.insertParameterTypes(0, classModel.thisClass().asSymbol());\n+        }\n+        return CoreOp.func(\n@@ -160,3 +167,4 @@\n-                MethodRef.ofNominalDescriptor(methodModel.methodTypeSymbol())).body(entryBlock ->\n-                        new BytecodeLift(entryBlock, methodModel).lift());\n-        return SlotSSA.transform(lifted);\n+                MethodRef.ofNominalDescriptor(mDesc)).body(entryBlock ->\n+                        new BytecodeLift(entryBlock,\n+                                         classModel,\n+                                         methodModel.code().orElseThrow()).liftBody());\n@@ -196,1 +204,1 @@\n-    private void lift() {\n+    private void liftBody() {\n@@ -215,1 +223,1 @@\n-                    for (ExceptionCatch ec : codeModel.exceptionHandlers().reversed()) {\n+                    for (ExceptionCatch ec : exceptionHandlers.reversed()) {\n@@ -228,1 +236,1 @@\n-                    for (ExceptionCatch ec : codeModel.exceptionHandlers()) {\n+                    for (ExceptionCatch ec : exceptionHandlers) {\n@@ -440,2 +448,1 @@\n-                    ClassModel clm = codeModel.parent().orElseThrow().parent().orElseThrow();\n-                    if (dmhd.owner().equals(clm.thisClass().asSymbol())) {\n+                    if (dmhd.owner().equals(classModel.thisClass().asSymbol())) {\n@@ -443,5 +450,4 @@\n-                        MethodModel implMethod = clm.methods().stream().filter(m -> m.methodName().equalsString(dmhd.methodName())\n-                                                                            && m.methodTypeSymbol().equals(dmhd.invocationType())).findFirst().orElseThrow();\n-                        var captureTypes = new Value[dmhd.invocationType().parameterCount() - mtd.parameterCount()];\n-                        for (int ci = captureTypes.length - 1; ci >= 0; ci--) {\n-                            captureTypes[ci] = stack.pop();\n+                        MethodModel implMethod = classModel.methods().stream().filter(m -> m.methodName().equalsString(dmhd.methodName())).findFirst().orElseThrow();\n+                        var capturedValues = new Value[dmhd.invocationType().parameterCount() - mtd.parameterCount()];\n+                        for (int ci = capturedValues.length - 1; ci >= 0; ci--) {\n+                            capturedValues[ci] = stack.pop();\n@@ -449,1 +455,1 @@\n-                        for (int ci = captureTypes.length; ci < inst.typeSymbol().parameterCount(); ci++) {\n+                        for (int ci = capturedValues.length; ci < inst.typeSymbol().parameterCount(); ci++) {\n@@ -452,1 +458,5 @@\n-                        stack.push(op(lambda.body(eb -> new BytecodeLift(eb, implMethod, captureTypes).lift())));\n+                        stack.push(op(lambda.body(\n+                                eb -> new BytecodeLift(eb,\n+                                                       classModel,\n+                                                       implMethod.code().orElseThrow(),\n+                                                       capturedValues).liftBody())));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":50,"deletions":40,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import java.lang.constant.MethodTypeDesc;\n@@ -57,3 +56,2 @@\n-    public LocalsTypeMapper(ClassDesc thisClass,\n-                         MethodTypeDesc methodType,\n-                         boolean isStatic,\n+    LocalsTypeMapper(ClassDesc thisClass,\n+                         List<ClassDesc> initFrameLocals,\n@@ -65,6 +63,1 @@\n-        this.locals = new ArrayList<>();\n-        if (!isStatic) locals.add(thisClass);\n-        for (var pt : methodType.parameterList()) {\n-            locals.add(pt);\n-            if (pt.equals(CD_long) || pt.equals(CD_double)) locals.add(null);\n-        }\n+        this.locals = new ArrayList<>(initFrameLocals);\n@@ -77,1 +70,1 @@\n-    public ClassDesc getTypeOf(LoadInstruction li) {\n+    ClassDesc getTypeOf(LoadInstruction li) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsTypeMapper.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -47,3 +48,1 @@\n-import java.util.Arrays;\n-import java.util.IdentityHashMap;\n-import java.util.Map;\n+import java.util.*;\n@@ -414,0 +413,9 @@\n+    int instanceMethod(int i) {\n+        return -i + 13;\n+    }\n+\n+    @CodeReflection\n+    int instanceMethodHandle(int i) {\n+        return consume(i, this::instanceMethod);\n+    }\n+\n@@ -449,0 +457,9 @@\n+    int instanceField = -1;\n+\n+    @CodeReflection\n+    int instanceFieldAccess(int i) {\n+        int ret = instanceField;\n+        instanceField = i;\n+        return ret;\n+    }\n+\n@@ -541,0 +558,8 @@\n+            Object receiver1, receiver2;\n+            if (d.testMethod.accessFlags().contains(AccessFlag.STATIC)) {\n+                receiver1 = null;\n+                receiver2 = null;\n+            } else {\n+                receiver1 = new TestBytecode();\n+                receiver2 = new TestBytecode();\n+            }\n@@ -542,1 +567,1 @@\n-                Assert.assertEquals(invokeAndConvert(flift, args), d.testMethod.invoke(null, args)));\n+                Assert.assertEquals(invokeAndConvert(flift, receiver1, args), d.testMethod.invoke(receiver2, args)));\n@@ -552,2 +577,5 @@\n-    private static Object invokeAndConvert(CoreOp.FuncOp func, Object[] args) {\n-        Object ret = Interpreter.invoke(MethodHandles.lookup(), func, args);\n+    private static Object invokeAndConvert(CoreOp.FuncOp func, Object receiver, Object... args) {\n+        List argl = new ArrayList(args.length + 1);\n+        if (receiver != null) argl.add(receiver);\n+        argl.addAll(Arrays.asList(args));\n+        Object ret = Interpreter.invoke(MethodHandles.lookup(), func, argl);\n@@ -582,2 +610,14 @@\n-            permutateAllArgs(d.testMethod.getParameterTypes(), args ->\n-                    Assert.assertEquals(mh.invokeWithArguments(args), d.testMethod.invoke(null, args)));\n+            Object receiver1, receiver2;\n+            if (d.testMethod.accessFlags().contains(AccessFlag.STATIC)) {\n+                receiver1 = null;\n+                receiver2 = null;\n+            } else {\n+                receiver1 = new TestBytecode();\n+                receiver2 = new TestBytecode();\n+            }\n+            permutateAllArgs(d.testMethod.getParameterTypes(), args -> {\n+                    List argl = new ArrayList(args.length + 1);\n+                    if (receiver1 != null) argl.add(receiver1);\n+                    argl.addAll(Arrays.asList(args));\n+                    Assert.assertEquals(mh.invokeWithArguments(argl), d.testMethod.invoke(receiver2, args));\n+            });\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        Assert.assertTrue(passed > 6400, String.format(\"\"\"\n+        Assert.assertTrue(passed > 24000, String.format(\"\"\"\n@@ -105,1 +105,1 @@\n-            if (originalModel.flags().has(AccessFlag.STATIC) && originalModel.code().isPresent()) try {\n+            if (originalModel.code().isPresent()) try {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}