{"files":[{"patch":"@@ -64,1 +64,0 @@\n-import java.lang.classfile.constantpool.ClassEntry;\n@@ -68,1 +67,0 @@\n-import java.lang.reflect.code.Block.Parameter;\n@@ -72,0 +70,1 @@\n+import java.util.Arrays;\n@@ -73,0 +72,1 @@\n+import java.util.stream.Stream;\n@@ -83,1 +83,2 @@\n-    private final CodeModel codeModel;\n+    private final ClassModel classModel;\n+    private final List<ExceptionCatch> exceptionHandlers;\n@@ -107,5 +108,1 @@\n-    private TypeElement toTypeElement(ClassEntry ce) {\n-        return JavaType.type(ce.asSymbol());\n-    }\n-\n-    private BytecodeLift(Block.Builder entryBlock, MethodModel methodModel, Value... capturedValues) {\n+    private BytecodeLift(Block.Builder entryBlock, ClassModel classModel, CodeModel codeModel, Value... capturedValues) {\n@@ -114,1 +111,2 @@\n-        this.codeModel = methodModel.code().orElseThrow();\n+        this.classModel = classModel;\n+        this.exceptionHandlers = codeModel.exceptionHandlers();\n@@ -123,16 +121,8 @@\n-        MethodTypeDesc mtd = methodModel.methodTypeSymbol();\n-        ClassDesc thisClass = methodModel.parent().orElseThrow().thisClass().asSymbol();\n-        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n-            mtd = mtd.insertParameterTypes(0, thisClass);\n-        }\n-        int slot = 0, i = 0;\n-        for (Value cap : capturedValues) {\n-            op(SlotOp.store(slot, cap));\n-            slot += TypeKind.from(mtd.parameterType(i++)).slotSize();\n-        }\n-        for (Parameter bp : entryBlock.parameters()) {\n-            op(SlotOp.store(slot, bp));\n-            slot += TypeKind.from(mtd.parameterType(i++)).slotSize();\n-        }\n-\n-        this.codeTracker = new LocalsTypeMapper(thisClass, mtd, methodModel.flags().has(AccessFlag.STATIC), smta, elements);\n+        ArrayList<ClassDesc> locals = new ArrayList<>();\n+        Stream.concat(Arrays.stream(capturedValues), entryBlock.parameters().stream()).forEachOrdered(val -> {\n+            op(SlotOp.store(locals.size(), val));\n+            ClassDesc locType = BytecodeGenerator.toClassDesc(val.type());\n+            locals.add(locType);\n+            if (TypeKind.from(locType).slotSize() == 2) locals.add(null);\n+        });\n+        this.codeTracker = new LocalsTypeMapper(classModel.thisClass().asSymbol(), locals, smta, elements);\n@@ -159,8 +149,1 @@\n-        var mtd = methodModel.methodTypeSymbol();\n-        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n-            mtd = mtd.insertParameterTypes(0, methodModel.parent().orElseThrow().thisClass().asSymbol());\n-        }\n-        var lifted = CoreOp.func(\n-                methodModel.methodName().stringValue(),\n-                MethodRef.ofNominalDescriptor(mtd)).body(entryBlock ->\n-                        new BytecodeLift(entryBlock, methodModel).lift());\n+        CoreOp.FuncOp lifted = liftToSlots(methodModel);\n@@ -176,0 +159,14 @@\n+    private static CoreOp.FuncOp liftToSlots(MethodModel methodModel) {\n+        ClassModel classModel = methodModel.parent().orElseThrow();\n+        MethodTypeDesc mDesc = methodModel.methodTypeSymbol();\n+        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n+            mDesc = mDesc.insertParameterTypes(0, classModel.thisClass().asSymbol());\n+        }\n+        return CoreOp.func(\n+                methodModel.methodName().stringValue(),\n+                MethodRef.ofNominalDescriptor(mDesc)).body(entryBlock ->\n+                        new BytecodeLift(entryBlock,\n+                                         classModel,\n+                                         methodModel.code().orElseThrow()).liftBody());\n+    }\n+\n@@ -207,1 +204,1 @@\n-    private void lift() {\n+    private void liftBody() {\n@@ -226,1 +223,1 @@\n-                    for (ExceptionCatch ec : codeModel.exceptionHandlers().reversed()) {\n+                    for (ExceptionCatch ec : exceptionHandlers.reversed()) {\n@@ -239,1 +236,1 @@\n-                    for (ExceptionCatch ec : codeModel.exceptionHandlers()) {\n+                    for (ExceptionCatch ec : exceptionHandlers) {\n@@ -451,2 +448,1 @@\n-                    ClassModel clm = codeModel.parent().orElseThrow().parent().orElseThrow();\n-                    if (dmhd.owner().equals(clm.thisClass().asSymbol())) {\n+                    if (dmhd.owner().equals(classModel.thisClass().asSymbol())) {\n@@ -454,4 +450,4 @@\n-                        MethodModel implMethod = clm.methods().stream().filter(m -> m.methodName().equalsString(dmhd.methodName())).findFirst().orElseThrow();\n-                        var captureTypes = new Value[dmhd.invocationType().parameterCount() - mtd.parameterCount()];\n-                        for (int ci = captureTypes.length - 1; ci >= 0; ci--) {\n-                            captureTypes[ci] = stack.pop();\n+                        MethodModel implMethod = classModel.methods().stream().filter(m -> m.methodName().equalsString(dmhd.methodName())).findFirst().orElseThrow();\n+                        var capturedValues = new Value[dmhd.invocationType().parameterCount() - mtd.parameterCount()];\n+                        for (int ci = capturedValues.length - 1; ci >= 0; ci--) {\n+                            capturedValues[ci] = stack.pop();\n@@ -459,1 +455,1 @@\n-                        for (int ci = captureTypes.length; ci < inst.typeSymbol().parameterCount(); ci++) {\n+                        for (int ci = capturedValues.length; ci < inst.typeSymbol().parameterCount(); ci++) {\n@@ -462,1 +458,5 @@\n-                        stack.push(op(lambda.body(eb -> new BytecodeLift(eb, implMethod, captureTypes).lift())));\n+                        stack.push(op(lambda.body(\n+                                eb -> new BytecodeLift(eb,\n+                                                       classModel,\n+                                                       implMethod.code().orElseThrow(),\n+                                                       capturedValues).liftBody())));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import java.lang.constant.MethodTypeDesc;\n@@ -57,3 +56,2 @@\n-    public LocalsTypeMapper(ClassDesc thisClass,\n-                         MethodTypeDesc methodType,\n-                         boolean isStatic,\n+    LocalsTypeMapper(ClassDesc thisClass,\n+                         List<ClassDesc> initFrameLocals,\n@@ -65,6 +63,1 @@\n-        this.locals = new ArrayList<>();\n-        if (!isStatic) locals.add(thisClass);\n-        for (var pt : methodType.parameterList()) {\n-            locals.add(pt);\n-            if (pt.equals(CD_long) || pt.equals(CD_double)) locals.add(null);\n-        }\n+        this.locals = new ArrayList<>(initFrameLocals);\n@@ -77,1 +70,1 @@\n-    public ClassDesc getTypeOf(LoadInstruction li) {\n+    ClassDesc getTypeOf(LoadInstruction li) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsTypeMapper.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"}]}