{"files":[{"patch":"@@ -112,3 +112,0 @@\n-        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n-            throw new IllegalArgumentException(\"Unsuported lift of non-static method: \" + methodModel);\n-        }\n@@ -127,0 +124,4 @@\n+        ClassDesc thisClass = methodModel.parent().orElseThrow().thisClass().asSymbol();\n+        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n+            mtd = mtd.insertParameterTypes(0, thisClass);\n+        }\n@@ -137,1 +138,1 @@\n-        this.codeTracker = new LocalsTypeMapper(methodModel.parent().get().thisClass().asSymbol(), mtd, methodModel.flags().has(AccessFlag.STATIC), smta, elements);\n+        this.codeTracker = new LocalsTypeMapper(thisClass, mtd, methodModel.flags().has(AccessFlag.STATIC), smta, elements);\n@@ -158,0 +159,4 @@\n+        var mtd = methodModel.methodTypeSymbol();\n+        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n+            mtd = mtd.insertParameterTypes(0, methodModel.parent().orElseThrow().thisClass().asSymbol());\n+        }\n@@ -160,1 +165,1 @@\n-                MethodRef.ofNominalDescriptor(methodModel.methodTypeSymbol())).body(entryBlock ->\n+                MethodRef.ofNominalDescriptor(mtd)).body(entryBlock ->\n@@ -162,1 +167,7 @@\n-        return SlotSSA.transform(lifted);\n+        try {\n+            return SlotSSA.transform(lifted);\n+        } catch (Exception e) {\n+            System.out.println(\"lifted:\");\n+            lifted.writeTo(System.out);\n+            throw new IllegalStateException(\"SlotSSA transformation failed\");\n+        }\n@@ -443,2 +454,1 @@\n-                        MethodModel implMethod = clm.methods().stream().filter(m -> m.methodName().equalsString(dmhd.methodName())\n-                                                                            && m.methodTypeSymbol().equals(dmhd.invocationType())).findFirst().orElseThrow();\n+                        MethodModel implMethod = clm.methods().stream().filter(m -> m.methodName().equalsString(dmhd.methodName())).findFirst().orElseThrow();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -47,3 +48,1 @@\n-import java.util.Arrays;\n-import java.util.IdentityHashMap;\n-import java.util.Map;\n+import java.util.*;\n@@ -414,0 +413,9 @@\n+    int instanceMethod(int i) {\n+        return -i + 13;\n+    }\n+\n+    @CodeReflection\n+    int instanceMethodHandle(int i) {\n+        return consume(i, this::instanceMethod);\n+    }\n+\n@@ -449,0 +457,9 @@\n+    int instanceField = -1;\n+\n+    @CodeReflection\n+    int instanceFieldAccess(int i) {\n+        int ret = instanceField;\n+        instanceField = i;\n+        return ret;\n+    }\n+\n@@ -541,0 +558,8 @@\n+            Object receiver1, receiver2;\n+            if (d.testMethod.accessFlags().contains(AccessFlag.STATIC)) {\n+                receiver1 = null;\n+                receiver2 = null;\n+            } else {\n+                receiver1 = new TestBytecode();\n+                receiver2 = new TestBytecode();\n+            }\n@@ -542,1 +567,1 @@\n-                Assert.assertEquals(invokeAndConvert(flift, args), d.testMethod.invoke(null, args)));\n+                Assert.assertEquals(invokeAndConvert(flift, receiver1, args), d.testMethod.invoke(receiver2, args)));\n@@ -552,2 +577,5 @@\n-    private static Object invokeAndConvert(CoreOp.FuncOp func, Object[] args) {\n-        Object ret = Interpreter.invoke(MethodHandles.lookup(), func, args);\n+    private static Object invokeAndConvert(CoreOp.FuncOp func, Object receiver, Object... args) {\n+        List argl = new ArrayList(args.length + 1);\n+        if (receiver != null) argl.add(receiver);\n+        argl.addAll(Arrays.asList(args));\n+        Object ret = Interpreter.invoke(MethodHandles.lookup(), func, argl);\n@@ -582,2 +610,14 @@\n-            permutateAllArgs(d.testMethod.getParameterTypes(), args ->\n-                    Assert.assertEquals(mh.invokeWithArguments(args), d.testMethod.invoke(null, args)));\n+            Object receiver1, receiver2;\n+            if (d.testMethod.accessFlags().contains(AccessFlag.STATIC)) {\n+                receiver1 = null;\n+                receiver2 = null;\n+            } else {\n+                receiver1 = new TestBytecode();\n+                receiver2 = new TestBytecode();\n+            }\n+            permutateAllArgs(d.testMethod.getParameterTypes(), args -> {\n+                    List argl = new ArrayList(args.length + 1);\n+                    if (receiver1 != null) argl.add(receiver1);\n+                    argl.addAll(Arrays.asList(args));\n+                    Assert.assertEquals(mh.invokeWithArguments(argl), d.testMethod.invoke(receiver2, args));\n+            });\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        Assert.assertTrue(passed > 6400, String.format(\"\"\"\n+        Assert.assertTrue(passed > 24000, String.format(\"\"\"\n@@ -105,1 +105,1 @@\n-            if (originalModel.flags().has(AccessFlag.STATIC) && originalModel.code().isPresent()) try {\n+            if (originalModel.code().isPresent()) try {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}