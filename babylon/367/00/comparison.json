{"files":[{"patch":"@@ -29,2 +29,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -32,2 +30,1 @@\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n+import jdk.incubator.code.Quotable;\n@@ -83,2 +80,16 @@\n-    public static <T> List<Tensor<T>> If(Tensor<Boolean> cond, Supplier<List<Tensor<T>>> elseBody, Supplier<List<Tensor<T>>> thenBody) {\n-        return cond.data().get(ValueLayout.JAVA_BOOLEAN, 0) ? thenBody.get() : elseBody.get();\n+\n+    public interface IfBody<T> extends Quotable {\n+        T invoke();\n+    }\n+\n+    public static <T> T If(Tensor<Boolean> cond, IfBody<T> thenBody, IfBody<T> elseBody) {\n+        return booleanValue(cond) ? thenBody.invoke() : elseBody.invoke();\n+    }\n+\n+    public record LoopReturn<T>(Tensor<Boolean> cond, T output) {}\n+    public static <T> LoopReturn<T> LoopReturn(Tensor<Boolean> cond, T output) {\n+        return new LoopReturn<>(cond, output);\n+    }\n+\n+    public interface LoopBody<T> extends Quotable {\n+        LoopReturn<T> invoke(Tensor<Long> i, Tensor<Boolean> cond, T input);\n@@ -87,2 +98,1 @@\n-    public record LoopLocals<T>(Tensor<Long> i, Tensor<Boolean> cond, List<Tensor<T>> userValues) {}\n-    public static <T> List<Tensor<T>> Loop(Tensor<Long> max, Tensor<Boolean> cond, List<Tensor<T>> v_initial, Function<LoopLocals<T>, LoopLocals<T>> body) {\n+    public static <T> T Loop(Tensor<Long> max, Tensor<Boolean> cond, T values, LoopBody<T> loopBody) {\n@@ -90,4 +100,4 @@\n-        LoopLocals<T> ll = new LoopLocals<>(Tensor.ofScalar(0), cond, v_initial);\n-        while (ll.i.data().get(ValueLayout.JAVA_LONG, 0) < m && ll.cond.data().get(ValueLayout.JAVA_BOOLEAN, 0)) {\n-            ll = body.apply(ll);\n-            ll.i.data().set(ValueLayout.JAVA_LONG, 0, ll.i.data().get(ValueLayout.JAVA_LONG, 0) + 1); \/\/ i++\n+        for (var i = Tensor.ofScalar(0l); longValue(i) < m && booleanValue(cond); set(i, longValue(i) + 1)) {\n+            LoopReturn<T> ret = loopBody.invoke(i, cond, values);\n+            cond = ret.cond();\n+            values = ret.output();\n@@ -95,1 +105,15 @@\n-        return ll.userValues();\n+        return values;\n+    }\n+\n+    \/\/ @@@ move to Tensor API\n+\n+    private static boolean booleanValue(Tensor<Boolean> t) {\n+        return t.data().get(ValueLayout.JAVA_BOOLEAN, 0);\n+    }\n+\n+    private static long longValue(Tensor<Long> t) {\n+        return t.data().get(ValueLayout.JAVA_LONG, 0);\n+    }\n+\n+    private static void set(Tensor<Long> t, long value) {\n+        t.data().set(ValueLayout.JAVA_LONG, 0, value);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":37,"deletions":13,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-        var model = build(graph(indexer, block, initializers));\n+        var model = build(graph(indexer, block, initializers, 0));\n@@ -352,1 +352,1 @@\n-    static GraphProto graph(Indexer indexer, Block block, List<oracle.code.onnx.Tensor> initializers) {\n+    static GraphProto graph(Indexer indexer, Block block, List<oracle.code.onnx.Tensor> initializers, int scalarArgs) {\n@@ -359,2 +359,2 @@\n-                args.stream().map(v ->\n-                        tensorInfo(indexer.getName(v), ((OnnxType.TensorType)v.type()).eType().id())).toList(),\n+                IntStream.range(0, args.size()).mapToObj(i ->\n+                        tensorInfo(indexer.getName(args.get(i)), ((OnnxType.TensorType)args.get(i).type()).eType().id(), i < scalarArgs)).toList(),\n@@ -368,3 +368,12 @@\n-                                    java.util.Map.of( \/\/ @@@ wrong mapping of captured inputs\n-                                            \"else_branch\", graph(indexer, ifOp.elseBranch().entryBlock(), List.of()),\n-                                            \"then_branch\", graph(indexer, ifOp.thenBranch().entryBlock(), List.of()))));\n+                                    java.util.Map.of(\n+                                            \"then_branch\", graph(indexer, ifOp.thenBranch().entryBlock(), List.of(), 0),\n+                                            \"else_branch\", graph(indexer, ifOp.elseBranch().entryBlock(), List.of(), 0))));\n+                        case OnnxOps.LoopReturn _ -> {} \/\/ skip\n+                        case OnnxOps.Loop loopOp -> {\n+                            opNodes.accept(node(\n+                                    loopOp.opName(),\n+                                    loopOp.operands().stream().map(indexer::getName).toList(),\n+                                    List.of(indexer.getName(loopOp.result())),\n+                                    java.util.Map.of(\n+                                            \"body\", graph(indexer, loopOp.loopBody().entryBlock(), List.of(), 2))));\n+                        }\n@@ -397,1 +406,1 @@\n-                List.of(indexer.getName(block.terminatingOp().operands().getFirst())));\n+                block.terminatingOp().operands().stream().map(indexer::getName).toList());\n@@ -417,5 +426,1 @@\n-        return new ValueInfoProto()\n-                .name(name)\n-                .type(new TypeProto()\n-                        .tensor_type(new Tensor()\n-                                .elem_type(tensorElementType)));\n+        return tensorInfo(name, tensorElementType, false);\n@@ -424,1 +429,3 @@\n-    static ValueInfoProto scalarInfo(String name, int tensorElementType) {\n+    static ValueInfoProto tensorInfo(String name, int tensorElementType, boolean addScalarShape) {\n+        var t = new Tensor().elem_type(tensorElementType);\n+        if (addScalarShape) t.shape(new TensorShapeProto());\n@@ -427,4 +434,1 @@\n-                .type(new TypeProto()\n-                        .tensor_type(new Tensor()\n-                                .elem_type(tensorElementType)\n-                                .shape(new TensorShapeProto())));\n+                .type(new TypeProto().tensor_type(t));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-            assert o.operands().subList(0, inputs.size()).stream().noneMatch(oc::isValueDefined);\n+\/\/            assert o.operands().subList(0, inputs.size()).stream().noneMatch(oc::isValueDefined);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxPartialEvaluator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,4 +48,2 @@\n-    public OnnxTransformer(MethodHandles.Lookup lookup, CoreOp.FuncOp func) {\n-        l = lookup;\n-\n-        var inlinedFunc = func.transform((bb, op) -> {\n+    final CoreOp.FuncOp inline(CoreOp.FuncOp func) {\n+        return func.transform((bb, op) -> {\n@@ -55,1 +53,1 @@\n-                    bb.inline(inline, cc.getValues(io.operands()), (_, v) -> cc.mapValue(io.result(), v));\n+                    bb.inline(inline(inline), cc.getValues(io.operands()), (_, v) -> cc.mapValue(io.result(), v));\n@@ -61,0 +59,6 @@\n+    }\n+\n+    public OnnxTransformer(MethodHandles.Lookup lookup, CoreOp.FuncOp func) {\n+        l = lookup;\n+\n+        var inlinedFunc = inline(func);\n@@ -63,0 +67,1 @@\n+        var initMap = new HashMap<FieldRef, Block.Parameter>();\n@@ -70,1 +75,0 @@\n-                    inits.add(flo.fieldDescriptor());\n@@ -72,1 +76,4 @@\n-                    cc.mapValue(op.result(), top[0].parameter(op.resultType()));\n+                    cc.mapValue(op.result(), initMap.computeIfAbsent(flo.fieldDescriptor(), fd -> {\n+                        inits.add(fd);\n+                        return top[0].parameter(op.resultType());\n+                    }));\n@@ -93,1 +100,1 @@\n-                return (Tensor)i.resolveToHandle(l).get(receiver);\n+                return (Tensor)(i.resolveToMember(l).accessFlags().contains(AccessFlag.STATIC) ? i.resolveToHandle(l).get() : i.resolveToHandle(l).get(receiver));\n@@ -200,1 +207,2 @@\n-                                    throw new UnsupportedOperationException();\n+                                    \/\/ otherwise pass through a single value\n+                                    opArgs.add(bb.context().getValue(v));\n@@ -210,1 +218,1 @@\n-                            opArgs.add(lambda.body().transform(bb.context(), bodyTransformer(pe)));\n+                            opArgs.add(transformBodyTranslateTypes(lambda.body(), bb.context(), bodyTransformer(pe)));\n@@ -215,1 +223,1 @@\n-                        opArgs.add(lambda.body().transform(bb.context(), bodyTransformer(pe)));\n+                        opArgs.add(transformBodyTranslateTypes(lambda.body(), bb.context(), bodyTransformer(pe)));\n@@ -244,0 +252,5 @@\n+                case Op.Terminating _ -> {\n+                    try {\n+                        bb.op(op); \/\/ @@@ how to test the terminating op has been already inserted?\n+                    } catch (IllegalStateException _) {}\n+                }\n@@ -251,0 +264,19 @@\n+    \/\/ @@@ Ugly copy of Body::transform content to translate types\n+    static Body.Builder transformBodyTranslateTypes(Body body, CopyContext cc, OpTransformer ot) {\n+\/\/        return body.transform(cc, ot);\n+\n+        Body ancestorBody = body.parentOp().parentBlock() instanceof Block parentBlock ? parentBlock.parentBody() : null;\n+\n+        Block.Builder ancestorBlockBuilder = ancestorBody != null\n+                ? cc.getBlock(ancestorBody.entryBlock()) : null;\n+        Body.Builder ancestorBodyBuilder = ancestorBlockBuilder != null\n+                ? ancestorBlockBuilder.parentBody() : null;\n+\n+        Body.Builder bb = Body.Builder.of(ancestorBodyBuilder, FunctionType.functionType(type(body.yieldType())), cc, ot); \/\/ translate types\n+        for (Block.Parameter p : body.entryBlock().parameters()) {\n+            bb.entryBlock().parameter(type(p.type())); \/\/ translate types\n+        }\n+        bb.entryBlock().transformBody(body, bb.entryBlock().parameters(), cc, ot);\n+        return bb;\n+    }\n+\n@@ -333,0 +365,1 @@\n+    static final TypeElement LOOP_RETURN_RAW_CLASS = JavaType.type(ExplicitOnnxOps.LoopReturn.class);\n@@ -337,12 +370,16 @@\n-        if (type instanceof ClassType ct && ct.rawType().equals(TENSOR_RAW_CLASS)) {\n-            JavaType elementType = ct.typeArguments().getFirst();\n-            if (elementType.equals(JavaType.J_L_INTEGER)) {\n-                return OnnxType.TENSOR_INT32;\n-            } else if (elementType.equals(JavaType.J_L_FLOAT)) {\n-                return OnnxType.TENSOR_FLOAT32;\n-            } else if (elementType.equals(JavaType.J_L_LONG)) {\n-                return OnnxType.TENSOR_INT64;\n-            } else if (elementType.equals(JavaType.J_L_BYTE)) {\n-                return OnnxType.TENSOR_UINT8;\n-            } else if (elementType.equals(JavaType.J_L_BOOLEAN)) {\n-                return OnnxType.TENSOR_BOOL;\n+        if (type instanceof ClassType ct) {\n+            if (ct.rawType().equals(TENSOR_RAW_CLASS)) {\n+                JavaType elementType = ct.typeArguments().getFirst();\n+                if (elementType.equals(JavaType.J_L_INTEGER)) {\n+                    return OnnxType.TENSOR_INT32;\n+                } else if (elementType.equals(JavaType.J_L_FLOAT)) {\n+                    return OnnxType.TENSOR_FLOAT32;\n+                } else if (elementType.equals(JavaType.J_L_LONG)) {\n+                    return OnnxType.TENSOR_INT64;\n+                } else if (elementType.equals(JavaType.J_L_BYTE)) {\n+                    return OnnxType.TENSOR_UINT8;\n+                } else if (elementType.equals(JavaType.J_L_BOOLEAN)) {\n+                    return OnnxType.TENSOR_BOOL;\n+                }\n+            } else if (ct.rawType().equals(LOOP_RETURN_RAW_CLASS)) {\n+                return JavaType.VOID;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":60,"deletions":23,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        final Body elseBody, thenBody;\n+        final Body thenBody, elseBody;\n@@ -120,2 +120,2 @@\n-            this.elseBody = def.bodyDefinitions().get(0).build(this);\n-            this.thenBody = def.bodyDefinitions().get(1).build(this);\n+            this.thenBody = def.bodyDefinitions().get(0).build(this);\n+            this.elseBody = def.bodyDefinitions().get(1).build(this);\n@@ -127,1 +127,0 @@\n-            this.elseBody = that.elseBody.transform(cc, ot).build(this);\n@@ -129,0 +128,1 @@\n+            this.elseBody = that.elseBody.transform(cc, ot).build(this);\n@@ -136,1 +136,1 @@\n-        If(TypeElement resultType, Value cond, Body.Builder elseBranch, Body.Builder thenBranch) {\n+        If(TypeElement resultType, Value cond, Body.Builder thenBranch, Body.Builder elseBranch) {\n@@ -139,1 +139,0 @@\n-            this.elseBody = elseBranch.build(this);\n@@ -141,0 +140,1 @@\n+            this.elseBody = elseBranch.build(this);\n@@ -145,1 +145,1 @@\n-            return List.of(elseBody, thenBody);\n+            return List.of(thenBody, elseBody);\n@@ -171,2 +171,124 @@\n-    public static If If(TypeElement resultType, Value cond, Body.Builder elseBody, Body.Builder thenBody) {\n-        return new If(resultType, cond, elseBody, thenBody);\n+    public static If If(TypeElement resultType, Value cond, Body.Builder thenBody, Body.Builder elseBody) {\n+        return new If(resultType, cond, thenBody, elseBody);\n+    }\n+\n+    @OpFactory.OpDeclaration(LoopReturn.NAME)\n+    public static final class LoopReturn extends OnnxOp implements Op.Terminating {\n+        public static final String NAME = \"LoopReturn\";\n+\n+        \/\/ @@@ make or fake body\n+        public enum Attribute implements OnnxOp.OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxOp.OnnxTypeConstraint {\n+            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),\n+            B(new OnnxType.TypeVariable(\"B\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxOp.OnnxParameter {\n+            \/\/ @@@ Onnx spec declares the input parameters as optional, however it is causing problems\n+            cond(TypeConstraint.B.typeVariable(), OnnxOp.OnnxParameter.Quantifier.REQUIRED),\n+            values(TypeConstraint.V.typeVariable(), OnnxOp.OnnxParameter.Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final OnnxOp.OnnxParameter.Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxOp.OnnxParameter {\n+            outputs(TypeConstraint.V.typeVariable(), OnnxOp.OnnxParameter.Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final OnnxOp.OnnxParameter.Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxOp.OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LoopReturn(ExternalizableOp.ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LoopReturn(ExplicitOnnxOps.LoopReturn that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ExplicitOnnxOps.LoopReturn transform(CopyContext cc, OpTransformer ot) {\n+            return new ExplicitOnnxOps.LoopReturn(this, cc, ot);\n+        }\n+\n+        LoopReturn(TypeElement resultType, Value cond, Value v_initial) {\n+            super(SCHEMA, resultType, Set.of(), List.of(cond, v_initial), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxOp.OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxOp.OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(cond()));\n+        }\n+\n+\n+        public Value cond() {\n+            return operands().get(0);\n+        }\n+\n+        public List<Value> values() {\n+            return operands().subList(1, operands().size());\n+        }\n+    }\n+\n+    public static LoopReturn LoopReturn(TypeElement resultType, Value cond, Value values) {\n+        return new LoopReturn(resultType, cond, values);\n@@ -277,1 +399,1 @@\n-        Loop(TypeElement resultType, Value m, Value cond, List<Value> v_initial, Body.Builder body) {\n+        Loop(TypeElement resultType, Value m, Value cond, Value v_initial, Body.Builder body) {\n@@ -298,3 +420,2 @@\n-        public Optional<Value> m() {\n-            int i = optionalInputArguments.indexOf(InputParameter.M);\n-            return i != -1 ? Optional.of(operands().get(1 + i)) : Optional.empty();\n+        public Value max() {\n+            return operands().get(0);\n@@ -303,3 +424,2 @@\n-        public Optional<Value> cond() {\n-            int i = optionalInputArguments.indexOf(InputParameter.cond);\n-            return i != -1 ? Optional.of(operands().get(1 + i)) : Optional.empty();\n+        public Value cond() {\n+            return operands().get(1);\n@@ -309,1 +429,1 @@\n-            return operands().subList(1, operands().size());\n+            return operands().subList(2, operands().size());\n@@ -318,1 +438,1 @@\n-    public static Loop Loop(TypeElement resultType, Value m, Value cond, List<Value> v_initial, Body.Builder body) {\n+    public static Loop Loop(TypeElement resultType, Value m, Value cond, Value v_initial, Body.Builder body) {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/ExplicitOnnxOps.java","additions":138,"deletions":18,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                                    List.of(scalarInfo(\"i\", INT64.id), scalarInfo(\"cond_in\", BOOL.id), tensorInfo(\"a_in\", INT64.id)),\n+                                    List.of(tensorInfo(\"i\", INT64.id, true), tensorInfo(\"cond_in\", BOOL.id, true), tensorInfo(\"a_in\", INT64.id)),\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,0 +10,4 @@\n+import static java.util.Optional.empty;\n+import static oracle.code.onnx.OnnxOperators.*;\n+import static oracle.code.onnx.OnnxRuntime.execute;\n+\n@@ -14,1 +18,1 @@\n-        return OnnxOperators.Add(a, b);\n+        return Add(a, b);\n@@ -22,1 +26,1 @@\n-                OnnxRuntime.execute(() -> add(a, a)));\n+                execute(() -> add(a, a)));\n@@ -27,1 +31,1 @@\n-        return OnnxOperators.Sub(a, b);\n+        return Sub(a, b);\n@@ -36,1 +40,1 @@\n-                OnnxRuntime.execute(() -> sub(a, b)));\n+                execute(() -> sub(a, b)));\n@@ -41,1 +45,1 @@\n-        return OnnxOperators.Constant(-1f);\n+        return Constant(-1f);\n@@ -49,1 +53,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(() -> fconstant()));\n+        assertEquals(expected, execute(() -> fconstant()));\n@@ -54,1 +58,1 @@\n-        return OnnxOperators.Constant(new float[]{-1f, 0, 1, Float.MIN_VALUE, Float.MAX_VALUE});\n+        return Constant(new float[]{-1f, 0, 1, Float.MIN_VALUE, Float.MAX_VALUE});\n@@ -62,1 +66,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(() -> fconstants()));\n+        assertEquals(expected, execute(() -> fconstants()));\n@@ -67,1 +71,1 @@\n-        return OnnxOperators.Constant(-1l);\n+        return Constant(-1l);\n@@ -75,1 +79,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(() -> lconstant()));\n+        assertEquals(expected, execute(() -> lconstant()));\n@@ -80,1 +84,1 @@\n-        return OnnxOperators.Constant(new long[]{-1, 0, 1, Long.MIN_VALUE, Long.MAX_VALUE});\n+        return Constant(new long[]{-1, 0, 1, Long.MIN_VALUE, Long.MAX_VALUE});\n@@ -88,1 +92,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(() -> lconstants()));\n+        assertEquals(expected, execute(() -> lconstants()));\n@@ -93,1 +97,1 @@\n-        return OnnxOperators.Shape(OnnxOperators.Reshape(data, shape, Optional.empty()), Optional.empty(), Optional.empty());\n+        return Shape(Reshape(data, shape, empty()), empty(), empty());\n@@ -102,1 +106,1 @@\n-                OnnxRuntime.execute(() -> reshapeAndShape(data, shape)));\n+                execute(() -> reshapeAndShape(data, shape)));\n@@ -108,1 +112,1 @@\n-        return OnnxOperators.MaxPool(x, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),  new long[]{2}).Indices();\n+        return MaxPool(x, empty(), empty(), empty(), empty(), empty(), empty(),  new long[]{2}).Indices();\n@@ -116,1 +120,1 @@\n-                OnnxRuntime.execute(() -> indicesOfMaxPool(x)));\n+                execute(() -> indicesOfMaxPool(x)));\n@@ -121,1 +125,1 @@\n-        return OnnxOperators.Concat(List.of(input1, input2), axis);\n+        return Concat(List.of(input1, input2), axis);\n@@ -130,1 +134,1 @@\n-                OnnxRuntime.execute(()-> concat(input1, input2, 0)));\n+                execute(()-> concat(input1, input2, 0)));\n@@ -135,1 +139,1 @@\n-        return OnnxOperators.Split(input, Optional.of(split), Optional.empty(), Optional.empty()).get(0);\n+        return Split(input, Optional.of(split), empty(), empty()).get(0);\n@@ -144,1 +148,1 @@\n-                OnnxRuntime.execute(()-> split(input, split)));\n+                execute(()-> split(input, split)));\n@@ -149,1 +153,1 @@\n-        return OnnxOperators.If(cond, () -> List.of(OnnxOperators.Constant(-1f)), () -> List.of(OnnxOperators.Constant(1f))).get(0);\n+        return If(cond, () -> List.of(Constant(1f)), () -> List.of(Constant(-1f))).get(0);\n@@ -160,1 +164,1 @@\n-        assertEquals(expFalse, OnnxRuntime.execute(() -> ifConst(condFalse)));\n+        assertEquals(expFalse, execute(() -> ifConst(condFalse)));\n@@ -163,1 +167,1 @@\n-        assertEquals(expTrue, OnnxRuntime.execute(() -> ifConst(condTrue)));\n+        assertEquals(expTrue, execute(() -> ifConst(condTrue)));\n@@ -168,2 +172,2 @@\n-        var falseValue = OnnxOperators.Constant(-1f);\n-        return OnnxOperators.If(cond, () -> List.of(OnnxOperators.Identity(falseValue)), () -> List.of(OnnxOperators.Identity(trueValue))).get(0);\n+        var falseValue = Constant(-1f);\n+        return If(cond, () -> Identity(trueValue), () -> Identity(falseValue));\n@@ -180,1 +184,1 @@\n-        assertEquals(expFalse, OnnxRuntime.execute(() -> ifCapture(condFalse, expTrue)));\n+        assertEquals(expFalse, execute(() -> ifCapture(condFalse, expTrue)));\n@@ -183,1 +187,1 @@\n-        assertEquals(expTrue, OnnxRuntime.execute(() -> ifCapture(condTrue, expTrue)));\n+        assertEquals(expTrue, execute(() -> ifCapture(condTrue, expTrue)));\n@@ -190,1 +194,1 @@\n-        return OnnxOperators.Identity(initialized);\n+        return Identity(initialized);\n@@ -197,1 +201,1 @@\n-                     OnnxRuntime.execute(() -> initialized()));\n+                     execute(() -> initialized()));\n@@ -206,7 +210,7 @@\n-        return OnnxOperators.If(cond1,\n-                () -> OnnxOperators.If(cond2,\n-                        () -> List.of(OnnxOperators.Identity(initialized4)),\n-                        () -> List.of(OnnxOperators.Identity(initialized3))),\n-                () -> OnnxOperators.If(cond2,\n-                        () -> List.of(OnnxOperators.Identity(initialized2)),\n-                        () -> List.of(OnnxOperators.Identity(initialized)))).get(0);\n+        return If(cond1,\n+                () -> If(cond2,\n+                        () -> List.of(Identity(initialized)),\n+                        () -> List.of(Identity(initialized2))),\n+                () -> If(cond2,\n+                        () -> List.of(Identity(initialized3)),\n+                        () -> List.of(Identity(initialized4)))).get(0);\n@@ -221,1 +225,1 @@\n-        assertEquals(initialized, OnnxRuntime.execute(() -> ifInitialized(condTrue, condTrue)));\n+        assertEquals(initialized, execute(() -> ifInitialized(condTrue, condTrue)));\n@@ -223,1 +227,1 @@\n-        assertEquals(initialized2, OnnxRuntime.execute(() -> ifInitialized(condTrue, condFalse)));\n+        assertEquals(initialized2, execute(() -> ifInitialized(condTrue, condFalse)));\n@@ -225,1 +229,1 @@\n-        assertEquals(initialized3, OnnxRuntime.execute(() -> ifInitialized(condFalse, condTrue)));\n+        assertEquals(initialized3, execute(() -> ifInitialized(condFalse, condTrue)));\n@@ -227,1 +231,1 @@\n-        assertEquals(initialized4, OnnxRuntime.execute(() -> ifInitialized(condFalse, condFalse)));\n+        assertEquals(initialized4, execute(() -> ifInitialized(condFalse, condFalse)));\n@@ -231,0 +235,2 @@\n+    static final Tensor<Boolean> TRUE = Tensor.ofScalar(true);\n+\n@@ -232,6 +238,2 @@\n-    public Tensor<Float> forLoopAdd(Tensor<Float> value, Tensor<Long> max, Tensor<Boolean> condition) {\n-        return OnnxOperators.Loop(max, condition, List.of(value),\n-                l -> {\n-                    var v = l.userValues().get(0);\n-                    return new ExplicitOnnxOperators.LoopLocals<>(l.i(), l.cond(), List.of(OnnxOperators.Add(v, v)));\n-                }).get(0);\n+    public Tensor<Float> forLoopAdd(Tensor<Long> max, Tensor<Float> initialValue) {\n+        return Loop(max, TRUE, initialValue, (i, cond, v) -> LoopReturn(cond, Add(v, v)));\n@@ -245,3 +247,2 @@\n-        var cond = Tensor.ofScalar(true);\n-        assertEquals(expected, forLoopAdd(value, max, cond));\n-\/\/        assertEquals(expected, OnnxRuntime.execute(() -> forLoopAdd(value, max, cond)));\n+        assertEquals(expected, forLoopAdd(max, value));\n+        assertEquals(expected, execute(() -> forLoopAdd(max, value)));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":50,"deletions":49,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+package oracle.code.onnx;\n+\n+import java.lang.foreign.ValueLayout;\n+import java.util.List;\n+import java.util.Optional;\n+import jdk.incubator.code.CodeReflection;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.Optional.empty;\n+import static oracle.code.onnx.OnnxOperators.*;\n+import static oracle.code.onnx.OnnxRuntime.execute;\n+\n+public class WalkTheMazeTest {\n+\n+    static final Tensor<Byte> MAZE = Tensor.ofShape(new long[]{22, 48},\n+            \"\"\"\n+            ###############################################\n+            #     #     #   #     #     #       #   #     #\n+            # # # ##### # ### ##### ##### ##### ##### # ###\n+            # # #       #   #     #     # #     #         #\n+            # # ######### ### ### # ### # # ##### ### #####\n+            #   #         # # #       #   #       #       #\n+            # ########### # # # # ####### ### ### ### ##  #\n+            #   #     #   #     #       #     #     #     #\n+            ### ### # # ### ############### # ##### #######\n+            #       # #   #       #         # #        #  #\n+            # ####### ### ##### # # ##### ##### ########  #\n+            #         #   #     # # # #                   #\n+            ######### ##### ##### ### # ####### ########  #\n+            # #           #     #     # #     #   #       #\n+            # # ######### # # ### ### # # ##### # ######  #\n+            # #       #   # #   #   #       #   #         #\n+            # ##### # # ##### ### ########### ### #########\n+            #     # # #   #     #   #           #     #   #\n+            #     # # #   #     #   #           #     #   #\n+            ### # # # ### ### ##### # ####### ### ### #   #\n+            #   #       #     #     #       #         #   #\n+            ###############################################\n+            \"\"\".getBytes());\n+\n+    static final Tensor<Long> HOME_POS = Tensor.ofFlat(20l, 1); \/\/ bottom left corner\n+\n+    static final String EXPECTED_PATH =\n+            \">>^^>>vv>>>>>><<^^^^^<<<<<<^^>>>>>>>>>>vv<<vvv>>vv>>>>^^>>^<<^^>><<^^>><<<<^^>>>>^^>>vvvvvvvvv>>vv<<<<>>>>^^^<<^^>><<^^>>>>vv>>>>>><<^^>>>><<<<vv<\"\n+           +\"<^^^^>>>>>>>>vvvv<<vv<<<<<<<<vvv>>>>>><<<<<<^^>>>>>>>>vv>>>>>>>>^^^<<<<^^>>>>>>>>^^^^^^<vv<<<<<<<<<^^>>>>>>><<<^^<<^^^^>>>>vv<<>>vv>>>>^^<<<<^^>>>\"\n+           +\"><<^^>><<<<vv<<<<vv<<<<<<^^>>>>^^<<<<<<vvvv<<^^<<<<^^>>>><<<<vvvv<<^^<<<<^^>>>><<<<vvvvvv<<^^vvvv>>>>vv<<<<vvvv^^>>vvvv<<v>>vv<<<<^^^<<^^>>^^<<<<^\"\n+           +\"^^^^^<<<<>>vv<<<<^^<<^^>>^^^^>>vv>>>>>>^^<<<<>>>>vv<<<<<<^^<<<<vvvvvv>>vv<<vv>>>>>>>>vv<<<<<<vv>>>>vvvvv<<^^^<<<<^^^^vvvvv>>vv<<>\";\n+\n+    static final Tensor<Long> DIRECTION_NORTH = Tensor.ofFlat('^');\n+    static final Tensor<Long> DIRECTION_SOUTH = Tensor.ofFlat('v');\n+    static final Tensor<Long> DIRECTION_EAST = Tensor.ofFlat('>');\n+    static final Tensor<Long> DIRECTION_WEST = Tensor.ofFlat('<');\n+    static final Tensor<Boolean> TRUE = Tensor.ofScalar(true);\n+    static final Tensor<Long> ONE_ONE = Tensor.ofFlat(1l, 1);\n+    static final Tensor<Long> ZERO = Tensor.ofFlat(0l);\n+    static final Tensor<Long> TWO = Tensor.ofFlat(2l);\n+    static final Tensor<Long> THREE = Tensor.ofFlat(3l);\n+    static final Tensor<Long> MONE = Tensor.ofFlat(-1l);\n+    static final Tensor<Long> MTHREE = Tensor.ofFlat(-3l);\n+    static final Tensor<Long> MAX = Tensor.ofFlat(Long.MAX_VALUE);\n+    static final Tensor<Long> LIMIT = Tensor.ofFlat(1000l);\n+    static final Tensor<Long> STEP_SOUTH = Tensor.ofFlat(1l, 0);\n+    static final Tensor<Long> STEP_NORTH = Tensor.ofFlat(-1l, 0);\n+    static final Tensor<Long> STEP_EAST = Tensor.ofFlat(0l, 1);\n+    static final Tensor<Long> STEP_WEST = Tensor.ofFlat(0l, -1);\n+    static final Tensor<Long> SCALAR_SHAPE = Tensor.ofFlat(new long[0]);\n+    static final Tensor<Long> WALL = Tensor.ofScalar('#');\n+\n+    @CodeReflection\n+    public static Tensor<Long> turnLeft(Tensor<Long> direction) {\n+        return If(Equal(direction, DIRECTION_EAST),\n+                () -> Identity(DIRECTION_NORTH),\n+                () -> If(Equal(direction, DIRECTION_NORTH),\n+                        () -> Identity(DIRECTION_WEST),\n+                        () -> If(Equal(direction, DIRECTION_WEST),\n+                            () -> Identity(DIRECTION_SOUTH),\n+                            () -> Identity(DIRECTION_EAST))));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> turnRight(Tensor<Long> direction) {\n+        return Loop(THREE, TRUE, direction, (i, cond, d)\n+                -> LoopReturn(cond, turnLeft(d)));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Boolean> isWallAt(Tensor<Long> pos) {\n+        return Equal(CastLike(Slice(MAZE, pos, Add(pos, ONE_ONE), empty(), empty()), WALL, empty()), WALL);\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> posInFrontOfMe(Tensor<Long> myPos, Tensor<Long> myDirection) {\n+        return  If(Equal(myDirection, DIRECTION_EAST),\n+                () -> Add(myPos, STEP_EAST),\n+                () -> If(Equal(myDirection, DIRECTION_NORTH),\n+                        () -> Add(myPos, STEP_NORTH),\n+                        () -> If(Equal(myDirection, DIRECTION_WEST),\n+                            () -> Add(myPos, STEP_WEST),\n+                            () -> Add(myPos, STEP_SOUTH))));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Boolean> atHome(Tensor<Long> pos) {\n+        return ReduceMin(Equal(pos, HOME_POS), empty(), empty(), empty());\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> lastPos(Tensor<Long> pathLog) {\n+        return Slice(pathLog, MTHREE, MONE, empty(), empty());\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> lastDirection(Tensor<Long> pathLog) {\n+        return Slice(pathLog, MONE, MAX, empty(), empty());\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> addToLog(Tensor<Long> pathLog, Tensor<Long> pos, Tensor<Long> direction) {\n+        return Concat(List.of(pathLog, pos, direction), 0);\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Byte> extractDirections(Tensor<Long> pathLog) {\n+        return Cast(Slice(pathLog, TWO, MAX, Optional.of(ZERO), Optional.of(THREE)), empty(), 3);\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> turnLeftWhileWall(Tensor<Long> pos, Tensor<Long> direction) {\n+        var initialCond = Reshape(isWallAt(posInFrontOfMe(pos, direction)), SCALAR_SHAPE, empty());\n+        return Loop(LIMIT, initialCond, direction, (_, _, dir) -> {\n+                dir = turnLeft(dir);\n+                return LoopReturn(isWallAt(posInFrontOfMe(pos, dir)), dir);\n+            });\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> walkAroundTheMaze() {\n+        var start = Concat(List.of(HOME_POS, DIRECTION_EAST), 0);\n+        var pathLog = Loop(LIMIT, TRUE, start, (_, _, log) -> {\n+            var pos = lastPos(log);\n+            var direction = lastDirection(log);\n+\n+            \/\/ walk along the right wall\n+            pos = posInFrontOfMe(pos, direction);\n+            direction = turnRight(direction);\n+            direction = turnLeftWhileWall(pos, direction);\n+\n+            return LoopReturn(Not(atHome(pos)), addToLog(log, pos, direction));\n+        });\n+        return pathLog;\n+    }\n+\n+    @Test\n+    public void testWalkAroundTheMaze() throws Exception {\n+        var directions = execute(() -> extractDirections(walkAroundTheMaze()));\n+        Assertions.assertEquals(EXPECTED_PATH, new String(directions.data().toArray(ValueLayout.JAVA_BYTE)));\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/WalkTheMazeTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}