{"files":[{"patch":"@@ -3,0 +3,1 @@\n+import java.lang.foreign.Arena;\n@@ -4,0 +5,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -16,53 +18,65 @@\n-    static final Tensor<Byte> MAZE = Tensor.ofShape(new long[]{22, 48},\n-            \"\"\"\n-            ###############################################\n-            #     #     #   #     #     #       #   #     #\n-            # # # ##### # ### ##### ##### ##### ##### # ###\n-            # # #       #   #     #     # #     #         #\n-            # # ######### ### ### # ### # # ##### ### #####\n-            #   #         # # #       #   #       #       #\n-            # ########### # # # # ####### ### ### ### ##  #\n-            #   #     #   #     #       #     #     #     #\n-            ### ### # # ### ############### # ##### #######\n-            #       # #   #       #         # #        #  #\n-            # ####### ### ##### # # ##### ##### ########  #\n-            #         #   #     # # # #                   #\n-            ######### ##### ##### ### # ####### ########  #\n-            # #           #     #     # #     #   #       #\n-            # # ######### # # ### ### # # ##### # ######  #\n-            # #       #   # #   #   #       #   #         #\n-            # ##### # # ##### ### ########### ### #########\n-            #     # # #   #     #   #           #     #   #\n-            #     # # #   #     #   #           #     #   #\n-            ### # # # ### ### ##### # ####### ### ### #   #\n-            #   #       #     #     #       #         #   #\n-            ###############################################\n-            \"\"\".getBytes());\n-\n-    static final Tensor<Long> HOME_POS = Tensor.ofFlat(20l, 1); \/\/ bottom left corner\n-\n-    static final String EXPECTED_PATH =\n-            \">>^^>>vv>>>>>><<^^^^^<<<<<<^^>>>>>>>>>>vv<<vvv>>vv>>>>^^>>^<<^^>><<^^>><<<<^^>>>>^^>>vvvvvvvvv>>vv<<<<>>>>^^^<<^^>><<^^>>>>vv>>>>>><<^^>>>><<<<vv<\"\n-           +\"<^^^^>>>>>>>>vvvv<<vv<<<<<<<<vvv>>>>>><<<<<<^^>>>>>>>>vv>>>>>>>>^^^<<<<^^>>>>>>>>^^^^^^<vv<<<<<<<<<^^>>>>>>><<<^^<<^^^^>>>>vv<<>>vv>>>>^^<<<<^^>>>\"\n-           +\"><<^^>><<<<vv<<<<vv<<<<<<^^>>>>^^<<<<<<vvvv<<^^<<<<^^>>>><<<<vvvv<<^^<<<<^^>>>><<<<vvvvvv<<^^vvvv>>>>vv<<<<vvvv^^>>vvvv<<v>>vv<<<<^^^<<^^>>^^<<<<^\"\n-           +\"^^^^^<<<<>>vv<<<<^^<<^^>>^^^^>>vv>>>>>>^^<<<<>>>>vv<<<<<<^^<<<<vvvvvv>>vv<<vv>>>>>>>>vv<<<<<<vv>>>>vvvvv<<^^^<<<<^^^^vvvvv>>vv<<>\";\n-\n-    static final Tensor<Long> DIRECTION_NORTH = Tensor.ofFlat('^');\n-    static final Tensor<Long> DIRECTION_SOUTH = Tensor.ofFlat('v');\n-    static final Tensor<Long> DIRECTION_EAST = Tensor.ofFlat('>');\n-    static final Tensor<Long> DIRECTION_WEST = Tensor.ofFlat('<');\n-    static final Tensor<Boolean> TRUE = Tensor.ofScalar(true);\n-    static final Tensor<Long> ONE_ONE = Tensor.ofFlat(1l, 1);\n-    static final Tensor<Long> ZERO = Tensor.ofFlat(0l);\n-    static final Tensor<Long> TWO = Tensor.ofFlat(2l);\n-    static final Tensor<Long> THREE = Tensor.ofFlat(3l);\n-    static final Tensor<Long> MONE = Tensor.ofFlat(-1l);\n-    static final Tensor<Long> MTHREE = Tensor.ofFlat(-3l);\n-    static final Tensor<Long> MAX = Tensor.ofFlat(Long.MAX_VALUE);\n-    static final Tensor<Long> LIMIT = Tensor.ofFlat(1000l);\n-    static final Tensor<Long> STEP_SOUTH = Tensor.ofFlat(1l, 0);\n-    static final Tensor<Long> STEP_NORTH = Tensor.ofFlat(-1l, 0);\n-    static final Tensor<Long> STEP_EAST = Tensor.ofFlat(0l, 1);\n-    static final Tensor<Long> STEP_WEST = Tensor.ofFlat(0l, -1);\n-    static final Tensor<Long> SCALAR_SHAPE = Tensor.ofFlat(new long[0]);\n-    static final Tensor<Long> WALL = Tensor.ofScalar('#');\n+    final String expectedPath;\n+\n+    \/\/ initializers\n+    final Tensor<Byte> maze;\n+    final Tensor<Boolean> _true;\n+    final Tensor<Long> homePos, directionNorth, directionSouth, directionEast, directionWest,\n+                       oneOne, zero, two, three, mOne, mThree, max, limit,\n+                       stepSouth, stepNorth, stepEast, stepWest, scalarShape, wall;\n+\n+    public WalkTheMazeTest() {\n+        expectedPath = \">>^^>>vv>>>>>><<^^^^^<<<<<<^^>>>>>>>>>>vv<<vvv>>vv>>>>^^>>^<<^^>><<^^>><<<<^^>>>>^^>>vvvvvvvvv>>vv<<<<>>>>^^^<<^^>><<^^\"\n+                     + \">>>>vv>>>>>><<^^>>>><<<<vv<<^^^^>>>>>>>>vvvv<<vv<<<<<<<<vvv>>>>>><<<<<<^^>>>>>>>>vv>>>>>>>>^^^<<<<^^>>>>>>>>^^^^^^<vv<<\"\n+                     + \"<<<<<<<^^>>>>>>><<<^^<<^^^^>>>>vv<<>>vv>>>>^^<<<<^^>>>><<^^>><<<<vv<<<<vv<<<<<<^^>>>>^^<<<<<<vvvv<<^^<<<<^^>>>><<<<vvvv\"\n+                     + \"<<^^<<<<^^>>>><<<<vvvvvv<<^^vvvv>>>>vv<<<<vvvv^^>>vvvv<<v>>vv<<<<^^^<<^^>>^^<<<<^^^^^^<<<<>>vv<<<<^^<<^^>>^^^^>>vv>>>>>\"\n+                     + \">^^<<<<>>>>vv<<<<<<^^<<<<vvvvvv>>vv<<vv>>>>>>>>vv<<<<<<vv>>>>vvvvv<<^^^<<<<^^^^vvvvv>>vv<<>\";\n+\n+        var arena = Arena.ofAuto();\n+\n+        maze = Tensor.ofShape(arena, new long[]{22, 48},\n+                \"\"\"\n+                ###############################################\n+                #     #     #   #     #     #       #   #     #\n+                # # # ##### # ### ##### ##### ##### ##### # ###\n+                # # #       #   #     #     # #     #         #\n+                # # ######### ### ### # ### # # ##### ### #####\n+                #   #         # # #       #   #       #       #\n+                # ########### # # # # ####### ### ### ### ##  #\n+                #   #     #   #     #       #     #     #     #\n+                ### ### # # ### ############### # ##### #######\n+                #       # #   #       #         # #        #  #\n+                # ####### ### ##### # # ##### ##### ########  #\n+                #         #   #     # # # #                   #\n+                ######### ##### ##### ### # ####### ########  #\n+                # #           #     #     # #     #   #       #\n+                # # ######### # # ### ### # # ##### # ######  #\n+                # #       #   # #   #   #       #   #         #\n+                # ##### # # ##### ### ########### ### #########\n+                #     # # #   #     #   #           #     #   #\n+                #     # # #   #     #   #           #     #   #\n+                ### # # # ### ### ##### # ####### ### ### #   #\n+                #   #       #     #     #       #         #   #\n+                ###############################################\n+                \"\"\".getBytes());\n+\n+        _true = Tensor.ofScalar(arena, true);\n+        homePos = Tensor.ofFlat(arena, 20l, 1); \/\/ bottom left corner\n+        directionNorth = Tensor.ofFlat(arena, '^');\n+        directionSouth = Tensor.ofFlat(arena, 'v');\n+        directionEast = Tensor.ofFlat(arena, '>');\n+        directionWest = Tensor.ofFlat(arena, '<');\n+        oneOne = Tensor.ofFlat(arena, 1l, 1);\n+        zero = Tensor.ofFlat(arena, 0l);\n+        two = Tensor.ofFlat(arena, 2l);\n+        three = Tensor.ofFlat(arena, 3l);\n+        mOne = Tensor.ofFlat(arena, -1l);\n+        mThree = Tensor.ofFlat(arena, -3l);\n+        max = Tensor.ofFlat(arena, Long.MAX_VALUE);\n+        limit = Tensor.ofFlat(arena, 1000l);\n+        stepSouth = Tensor.ofFlat(arena, 1l, 0);\n+        stepNorth = Tensor.ofFlat(arena, -1l, 0);\n+        stepEast = Tensor.ofFlat(arena, 0l, 1);\n+        stepWest = Tensor.ofFlat(arena, 0l, -1);\n+        scalarShape = Tensor.ofFlat(arena, new long[0]);\n+        wall = Tensor.ofScalar(arena, '#');\n+    }\n@@ -71,8 +85,8 @@\n-    public static Tensor<Long> turnLeft(Tensor<Long> direction) {\n-        return If(Equal(direction, DIRECTION_EAST),\n-                () -> Identity(DIRECTION_NORTH),\n-                () -> If(Equal(direction, DIRECTION_NORTH),\n-                        () -> Identity(DIRECTION_WEST),\n-                        () -> If(Equal(direction, DIRECTION_WEST),\n-                            () -> Identity(DIRECTION_SOUTH),\n-                            () -> Identity(DIRECTION_EAST))));\n+    public Tensor<Long> turnLeft(Tensor<Long> direction) {\n+        return If(Equal(direction, directionEast),\n+                () -> Identity(directionNorth),\n+                () -> If(Equal(direction, directionNorth),\n+                        () -> Identity(directionWest),\n+                        () -> If(Equal(direction, directionWest),\n+                            () -> Identity(directionSouth),\n+                            () -> Identity(directionEast))));\n@@ -82,2 +96,2 @@\n-    public static Tensor<Long> turnRight(Tensor<Long> direction) {\n-        return Loop(THREE, TRUE, direction, (i, cond, d)\n+    public Tensor<Long> turnRight(Tensor<Long> direction) {\n+        return Loop(three, _true, direction, (i, cond, d)\n@@ -88,2 +102,2 @@\n-    public static Tensor<Boolean> isWallAt(Tensor<Long> pos) {\n-        return Equal(CastLike(Slice(MAZE, pos, Add(pos, ONE_ONE), empty(), empty()), WALL, empty()), WALL);\n+    public Tensor<Boolean> isWallAt(Tensor<Long> pos) {\n+        return Equal(CastLike(Slice(maze, pos, Add(pos, oneOne), empty(), empty()), wall, empty()), wall);\n@@ -93,8 +107,8 @@\n-    public static Tensor<Long> posInFrontOfMe(Tensor<Long> myPos, Tensor<Long> myDirection) {\n-        return  If(Equal(myDirection, DIRECTION_EAST),\n-                () -> Add(myPos, STEP_EAST),\n-                () -> If(Equal(myDirection, DIRECTION_NORTH),\n-                        () -> Add(myPos, STEP_NORTH),\n-                        () -> If(Equal(myDirection, DIRECTION_WEST),\n-                            () -> Add(myPos, STEP_WEST),\n-                            () -> Add(myPos, STEP_SOUTH))));\n+    public Tensor<Long> posInFrontOfMe(Tensor<Long> myPos, Tensor<Long> myDirection) {\n+        return  If(Equal(myDirection, directionEast),\n+                () -> Add(myPos, stepEast),\n+                () -> If(Equal(myDirection, directionNorth),\n+                        () -> Add(myPos, stepNorth),\n+                        () -> If(Equal(myDirection, directionWest),\n+                            () -> Add(myPos, stepWest),\n+                            () -> Add(myPos, stepSouth))));\n@@ -104,2 +118,2 @@\n-    public static Tensor<Boolean> atHome(Tensor<Long> pos) {\n-        return ReduceMin(Equal(pos, HOME_POS), empty(), empty(), empty());\n+    public Tensor<Boolean> atHome(Tensor<Long> pos) {\n+        return ReduceMin(Equal(pos, homePos), empty(), empty(), empty());\n@@ -109,2 +123,2 @@\n-    public static Tensor<Long> lastPos(Tensor<Long> pathLog) {\n-        return Slice(pathLog, MTHREE, MONE, empty(), empty());\n+    public Tensor<Long> lastPos(Tensor<Long> pathLog) {\n+        return Slice(pathLog, mThree, mOne, empty(), empty());\n@@ -114,2 +128,2 @@\n-    public static Tensor<Long> lastDirection(Tensor<Long> pathLog) {\n-        return Slice(pathLog, MONE, MAX, empty(), empty());\n+    public Tensor<Long> lastDirection(Tensor<Long> pathLog) {\n+        return Slice(pathLog, mOne, max, empty(), empty());\n@@ -119,1 +133,1 @@\n-    public static Tensor<Long> addToLog(Tensor<Long> pathLog, Tensor<Long> pos, Tensor<Long> direction) {\n+    public Tensor<Long> addToLog(Tensor<Long> pathLog, Tensor<Long> pos, Tensor<Long> direction) {\n@@ -124,2 +138,2 @@\n-    public static Tensor<Byte> extractDirections(Tensor<Long> pathLog) {\n-        return Cast(Slice(pathLog, TWO, MAX, Optional.of(ZERO), Optional.of(THREE)), empty(), 3);\n+    public Tensor<Byte> extractDirections(Tensor<Long> pathLog) {\n+        return Cast(Slice(pathLog, two, max, Optional.of(zero), Optional.of(three)), empty(), 3);\n@@ -129,3 +143,3 @@\n-    public static Tensor<Long> turnLeftWhileWall(Tensor<Long> pos, Tensor<Long> direction) {\n-        var initialCond = Reshape(isWallAt(posInFrontOfMe(pos, direction)), SCALAR_SHAPE, empty());\n-        return Loop(LIMIT, initialCond, direction, (_, _, dir) -> {\n+    public Tensor<Long> turnLeftWhileWall(Tensor<Long> pos, Tensor<Long> direction) {\n+        var initialCond = Reshape(isWallAt(posInFrontOfMe(pos, direction)), scalarShape, empty());\n+        return Loop(limit, initialCond, direction, (_, _, dir) -> {\n@@ -138,3 +152,3 @@\n-    public static Tensor<Long> walkAroundTheMaze() {\n-        var start = Concat(List.of(HOME_POS, DIRECTION_EAST), 0);\n-        var pathLog = Loop(LIMIT, TRUE, start, (_, _, log) -> {\n+    public Tensor<Long> walkAroundTheMaze() {\n+        var start = Concat(List.of(homePos, directionEast), 0);\n+        var pathLog = Loop(limit, _true, start, (_, _, log) -> {\n@@ -156,2 +170,4 @@\n-        var directions = execute(() -> extractDirections(walkAroundTheMaze()));\n-        Assertions.assertEquals(EXPECTED_PATH, new String(directions.data().toArray(ValueLayout.JAVA_BYTE)));\n+        try (var arena = Arena.ofConfined()) {\n+            var directions = execute(arena, MethodHandles.lookup(), () -> extractDirections(walkAroundTheMaze()));\n+            Assertions.assertEquals(expectedPath, new String(directions.data().toArray(ValueLayout.JAVA_BYTE)));\n+        }\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/WalkTheMazeTest.java","additions":106,"deletions":90,"binary":false,"changes":196,"status":"modified"}]}