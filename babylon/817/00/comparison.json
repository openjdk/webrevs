{"files":[{"patch":"@@ -457,2 +457,1 @@\n-                } else if (invoke.refIs(Math.class)\n-                        && mathFns.containsKey(invoke.name() + \"_\" + invoke.returnType().toString())){\n+                } else if (invoke.refIs(Math.class) && mathFns.containsKey(invoke.name() + \"_\" + invoke.returnType().toString())){\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,5 +30,0 @@\n-import hat.KernelContext;\n-import jdk.incubator.code.CodeTransformer;\n-import optkl.OpHelper;\n-import optkl.Trxfmr;\n-import optkl.ifacemapper.Buffer;\n@@ -36,2 +31,2 @@\n-import optkl.ifacemapper.MappableIface;\n-import optkl.FuncOpParams;\n+import optkl.codebuilders.JavaCodeBuilder;\n+import jdk.incubator.code.CodeTransformer;\n@@ -44,0 +39,5 @@\n+import optkl.FuncOpParams;\n+import optkl.OpHelper;\n+import optkl.Trxfmr;\n+import optkl.ifacemapper.Buffer;\n+import optkl.ifacemapper.MappableIface;\n@@ -57,2 +57,2 @@\n-    public FFIBackend(Arena arena,MethodHandles.Lookup lookup,String libName, Config config) {\n-        super(arena, lookup,libName, config);\n+    public FFIBackend(Arena arena, MethodHandles.Lookup lookup, String libName, Config config) {\n+        super(arena, lookup, libName, config);\n@@ -87,0 +87,1 @@\n+\n@@ -88,1 +89,1 @@\n-            return OpHelper.isAssignable(lookup, javaType,MappableIface.class);\n+            return OpHelper.isAssignable(lookup, javaType, MappableIface.class);\n@@ -90,1 +91,2 @@\n-        boolean ro(){\n+\n+        boolean ro() {\n@@ -92,1 +94,1 @@\n-                if (  annotation instanceof MappableIface.RO){\n+                if (annotation instanceof MappableIface.RO) {\n@@ -99,1 +101,2 @@\n-        boolean rw(){\n+\n+        boolean rw() {\n@@ -101,1 +104,1 @@\n-                if (  annotation instanceof MappableIface.RW){\n+                if (annotation instanceof MappableIface.RW) {\n@@ -108,1 +111,2 @@\n-        boolean wo(){\n+\n+        boolean wo() {\n@@ -110,1 +114,1 @@\n-                if (  annotation instanceof MappableIface.WO){\n+                if (annotation instanceof MappableIface.WO) {\n@@ -120,1 +124,0 @@\n-\n@@ -123,1 +126,2 @@\n-        CoreOp.FuncOp transformedFuncOp = computeMethod.funcOp();\n+\n+        var transformer =   Trxfmr.of(computeMethod.funcOp());\n@@ -125,4 +129,0 @@\n-            if (config().showComputeModel()) {\n-                System.out.println(\"COMPUTE entrypoint before injecting buffer tracking...\");\n-                System.out.println(transformedFuncOp.toText());\n-            }\n@@ -130,28 +130,41 @@\n-\n-            transformedFuncOp =Trxfmr.of(computeMethod.funcOp())\n-                    .transform(ce->ce instanceof JavaOp.InvokeOp ,(bldr, invokeOp) -> {\n-                var invoke = invokeOpHelper(lookup(),invokeOp);\n-                    Value cc = bldr.context().getValue(paramTable.list().getFirst().parameter);\n-                    if (invoke.isMappableIface() && invoke.returnsVoid()) {                    \/\/ iface.v(newV)\n-                        Value iface = bldr.context().getValue(invoke.op().operands().getFirst());\n-                        bldr.op(JavaOp.invoke(MUTATE.pre, cc, iface));                  \/\/ cc->preMutate(iface);\n-                        bldr.op(invoke.op());                                           \/\/ iface.v(newV);\n-                        bldr.op(JavaOp.invoke(MUTATE.post, cc, iface));                 \/\/ cc->postMutate(iface)\n-                    } else if (invoke.isMappableIface() && ( invoke.returns(Buffer.class) || invoke.returnsPrimitive())\n-                    ) {\n-                        \/\/ if this is accessing a width if an array we don't want to force the buffer back from the GPU.\n-                        Value iface = bldr.context().getValue(invoke.op().operands().getFirst());\n-                        bldr.op(JavaOp.invoke(ACCESS.pre, cc, iface));                 \/\/ cc->preAccess(iface);\n-                        bldr.op(invoke.op());                                           \/\/ iface.v();\n-                        bldr.op(JavaOp.invoke(ACCESS.post, cc, iface));                \/\/ cc->postAccess(iface)\n-                    } else if (invoke.refIs(ComputeContext.class,KernelContext.class)) { \/\/dispatchKernel\n-                        bldr.op(invoke.op());\n-                    } else {\n-                        List<Value> list = invoke.op().operands();\n-                        if (!list.isEmpty()) {\n-                            var method = invoke.resolveMethodOrThrow();\n-                            Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n-                            boolean isVirtual = list.size() > parameterAnnotations.length;\n-                            List<TypeAndAccess> typeAndAccesses = new ArrayList<>();\n-                            for (int i = isVirtual ? 1 : 0; i < list.size(); i++) {\n-                                typeAndAccesses.add(TypeAndAccess.of(parameterAnnotations[i - (isVirtual ? 1 : 0)], list.get(i)));\n+            transformer\n+                  \/\/  .when(config().showComputeModel(), trxfmr -> trxfmr.toText(\"COMPUTE before injecting buffer tracking...\"))\n+                    .when(config().showComputeModel(), trxfmr ->{\n+                     var javaCodeBuilder = new JavaCodeBuilder<>(lookup(),trxfmr.funcOp());\n+                      System.out.println(javaCodeBuilder.toText());\n+                    })\n+                    .transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n+                        var invoke = invokeOpHelper(lookup(), c.op());\n+                        if (invoke.isMappableIface() && (invoke.returns(Buffer.class) || invoke.returnsPrimitive())) {\n+                            Value computeContext = c.builder().context().getValue(paramTable.list().getFirst().parameter);\n+                            Value ifaceMappedBuffer = c.builder().context().getValue(invoke.op().operands().getFirst());\n+                            c.add(JavaOp.invoke(invoke.returnsVoid() ? MUTATE.pre : ACCESS.pre, computeContext, ifaceMappedBuffer));\n+                            c.retain();\n+                            c.add(JavaOp.invoke(invoke.returnsVoid() ? MUTATE.post : ACCESS.post, computeContext, ifaceMappedBuffer));\n+                        } else if (!invoke.refIs(ComputeContext.class) && invoke.operandCount()>0) {\n+                            \/\/List<Value> list = invoke.op().operands();\n+                            \/\/if (!list.isEmpty()) {\n+                                Annotation[][] parameterAnnotations =  invoke.resolveMethodOrThrow().getParameterAnnotations();\n+                                int firstParam =invoke.isInstance()?1:0; \/\/ if virtual\n+                                List<TypeAndAccess> typeAndAccesses = new ArrayList<>();\n+                                for (int i = firstParam; i < invoke.operandCount(); i++) {\n+                                    typeAndAccesses.add(TypeAndAccess.of(parameterAnnotations[i - firstParam], invoke.op().operands().get(i)));\n+                                }\n+                                Value computeContext = c.builder().context().getValue(paramTable.list().getFirst().parameter);\n+                                typeAndAccesses.stream()\n+                                        .filter(typeAndAccess -> typeAndAccess.isIface(lookup()))\n+                                        .forEach(typeAndAccess ->\n+                                            c.add(JavaOp.invoke(\n+                                                    typeAndAccess.ro() ? ACCESS.pre : MUTATE.pre,\n+                                                    computeContext, c.builder().context().getValue(typeAndAccess.value))\n+                                            )\n+                                        );\n+                                c.retain();\n+                                typeAndAccesses.stream()\n+                                        .filter(typeAndAccess -> OpHelper.isAssignable(lookup(), typeAndAccess.javaType, MappableIface.class))\n+                                        .forEach(typeAndAccess ->\n+                                            c.add(JavaOp.invoke(\n+                                                    typeAndAccess.ro() ? ACCESS.post : MUTATE.post,\n+                                                    computeContext, c.builder().context().getValue(typeAndAccess.value))\n+                                            )\n+                                        );\n@@ -159,34 +172,5 @@\n-                            typeAndAccesses.stream()\n-                                    .filter(typeAndAccess -> typeAndAccess.isIface(lookup()))\/\/InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, typeAndAccess.javaType))\n-                                    .forEach(typeAndAccess -> {\n-                                        if (typeAndAccess.ro()) {\n-                                            bldr.op(JavaOp.invoke(ACCESS.pre, cc, bldr.context().getValue(typeAndAccess.value)));\n-                                        } else {\n-                                            bldr.op(JavaOp.invoke(MUTATE.pre, cc, bldr.context().getValue(typeAndAccess.value)));\n-                                        }\n-                                    });\n-                            bldr.op(invoke.op());\n-                            typeAndAccesses.stream()\n-                                    .filter(typeAndAccess -> OpHelper.isAssignable(lookup(), typeAndAccess.javaType, MappableIface.class))\n-                                    .forEach(typeAndAccess -> {\n-                                        if (typeAndAccess.ro()) {\n-                                            bldr.op(JavaOp.invoke(ACCESS.post, cc, bldr.context().getValue(typeAndAccess.value)));\n-                                        } else {\n-                                            bldr.op(JavaOp.invoke(MUTATE.post, cc, bldr.context().getValue(typeAndAccess.value)));\n-                                        }\n-                                    });\n-                        } else {\n-                            bldr.op(invoke.op());\n-                        }\n-                    }\n-                    return bldr;\n-            }).funcOp();\n-            if (config().showComputeModel()) {\n-                System.out.println(\"COMPUTE entrypoint after injecting buffer tracking...\");\n-                System.out.println(transformedFuncOp.toText());\n-            }\n-        }else{\n-            if (config().showComputeModel()) {\n-                System.out.println(\"COMPUTE entrypoint (we will not be injecting buffer tracking...)...\");\n-                System.out.println(transformedFuncOp.toText());\n-            }\n+                    })\n+                    .when(config().showComputeModel(), trxfmr -> trxfmr.toText(\"COMPUTE after injecting buffer tracking...\"))\n+                    .run(trxfmr -> computeMethod.funcOp(trxfmr.funcOp()));\n+        } else {\n+            transformer.when(config().showComputeModel(),trxfmr -> trxfmr.toText(\"COMPUTE not injecting buffer tracking)\"));\n@@ -194,2 +178,1 @@\n-        computeMethod.funcOp(transformedFuncOp);\n-        return transformedFuncOp;\n+        return computeMethod.funcOp();\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":69,"deletions":86,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n@@ -50,69 +49,1 @@\n-        C99HATConfigBuilder cb = new C99HATConfigBuilder();\n-        cb.oracleCopyright();\n-        cb.blockComment(\"\"\"\n-                You probably should not edit this this file!!!\n-                It was auto generated\"\"\" + \" \" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date()) + \" by \" + FFIConfigCreator.class.getName()\n-        );\n-        cb.pragma(\"once\").nl();\n-        cb.includeSys(\"iostream\").nl();\n-        final int START_BIT_INDEX = Config.bitList.stream().filter(bit -> bit.size() == 1).findFirst().get().index();\n-\n-        cb.structKeyword().space().className().braceNlIndented((_) -> {\n-            var i = StreamMutable.of(START_BIT_INDEX);\n-            Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit -> {\n-                cb.staticConstIntShiftedOne(bit.name() + \"_BIT\", 32, i.get());\n-                i.set(i.get() + 1);\n-            });\n-            cb.constKeyword().space().staticKeyword().space().s08Type().space().asterisk().bitNamesVar().osbrace().csbrace().semicolon().space().lineComment(\"See below for initialization\");\n-            cb.constKeyword().space().staticKeyword().space().s08Type().space().asterisk().bitDescriptionsVar().osbrace().csbrace().semicolon().space().lineComment(\"See below for initialization\");\n-\n-            cb.s32Type().space().identifier(\"configBits\").semicolon().nl();\n-\n-            Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n-                    cb.identifier(\"bool\").space().camelExceptFirst(bit.name()).semicolon().nl()\n-            );\n-\n-            cb.s32Type().space().identifier(\"platform\").semicolon().nl();\n-            cb.s32Type().space().identifier(\"device\").semicolon().nl();\n-            cb.identifier(\"bool\").space().identifier(\"alwaysCopy\").semicolon().nl();\n-            \/\/Constructor\n-            cb.explicitKeyword().space().className().paren((_) -> cb.s32Type().space().configBitsVar()).colon().nl().indent((_) -> {\n-                cb.configBitsVar().paren((_) -> cb.configBitsVar()).comma().nl();\n-                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n-                        cb.camelExceptFirst(bit.name()).paren((_) -> cb.paren((_) -> cb.configBitsAndBitName(bit.name())).eq().identifier(bit.name() + \"_BIT\")).comma().nl()\n-                );\n-                cb.identifier(\"platform\").paren((_) -> cb.configBitsAnd().intHexValue(0xf)).comma().nl();\n-                cb.identifier(\"alwaysCopy\").paren(_ -> cb.pling().camelExceptFirst(\"MINIMIZE_COPIES\")).comma().nl();\n-                cb.identifier(\"device\").paren(_ ->\n-                        cb.paren(_ -> cb.configBitsAnd().intHexValue(0xf0)).space().rightShift().space().intValue(4)).braceNlIndented(_ ->\n-                        cb.ifKeyword().paren(_ -> cb.identifier(\"showDeviceInfo\")).braceNlIndented(_ -> {\n-                            cb.nlSeparated(\n-                                    Config.bitList.stream().filter(bit -> bit.size() == 1),\n-                                    bit -> cb.stdCout(\"native \" + cb.toCamelExceptFirst(bit.name()) + \" \").space().leftShift().space().camelExceptFirst(bit.name()).space().leftShift().space().stdEndl().semicolon()\n-                            );\n-                            cb.nl().stdCout(\"native platform \").space().leftShift().space().identifier(\"platform\").space().leftShift().space().stdEndl().semicolon();\n-                            cb.nl().stdCout(\"native device \").space().leftShift().space().identifier(\"device\").space().leftShift().space().stdEndl().semicolon();\n-                        })\n-                );\n-            }).nl();\n-\n-            cb.virtualKeyword().space().tilde().className().ocparen().equals().space().defaultKeyword().semicolon();\n-        }).semicolon().nl().nl();\n-\n-\n-        cb.hashIfdef(\"shared_cpp\", (_) -> {\n-            cb.constKeyword().space().s08Type().space().asterisk().className().colon().colon().bitNamesVar().ocsbrace().equals().brace((_) -> {\n-                cb.nl();\n-                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n-                        cb.dquote().identifier(bit.name() + \"_BIT\").dquote().comma().nl()\n-                );\n-            }).semicolon().nl();\n-            cb.constKeyword().space().s08Type().space().asterisk().className().colon().colon().bitDescriptionsVar().ocsbrace().equals().brace((_) -> {\n-                cb.nl();\n-                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n-                        cb.dquote().identifier(bit.description()).dquote().comma().nl()\n-                );\n-            }).semicolon().nl();\n-        });\n-\n-        Files.writeString(configDotH, cb.toString());\n+        Files.writeString(configDotH, C99HATConfigBuilder.create());\n","filename":"hat\/core\/src\/main\/java\/hat\/FFIConfigCreator.java","additions":1,"deletions":70,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.dialect.*;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.ParamVar;\n-import optkl.codebuilders.BabylonCoreOpBuilder;\n-import optkl.codebuilders.ScopedCodeBuilderContext;\n-\n-\/* this should not be too C99 specific *\/\n-public interface BabylonKernelOpBuilder<T extends HATCodeBuilder<?>> extends BabylonCoreOpBuilder<T, ScopedCodeBuilderContext> {\n-\n-    T hatBarrierOp(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp);\n-\n-    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATLocalVarOp barrierOp);\n-\n-    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATPrivateVarOp hatLocalVarOp);\n-\n-    T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp hatGlobalThreadIdOp);\n-\n-    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp hatGlobalSizeOp);\n-\n-    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp hatLocalThreadIdOp);\n-\n-    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp);\n-\n-    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp);\n-\n-    T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarOp hatVectorVarOp);\n-\n-    T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorStoreView hatFloat4StoreOp);\n-\n-    T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp);\n-\n-    T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorLoadOp hatVectorLoadOp);\n-\n-    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectLoadOp hatVSelectLoadOp);\n-\n-    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectStoreOp hatVSelectStoreOp);\n-\n-    T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarLoadOp hatVectorVarLoadOp);\n-\n-    T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarOp hatF16VarOp);\n-\n-    T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatF16BinaryOp);\n-\n-    T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarLoadOp hatF16VarLoadOp);\n-\n-    T hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ConvOp hatF16ConvOp);\n-\n-    T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorOfOp hatVectorOp);\n-\n-    T hatVectorMakeOf(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorMakeOfOp hatVectorMakeOfOp);\n-\n-    T hatF16ToFloatConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ToFloatConvOp hatF16ToFloatConvOp);\n-\n-    T hatPrivateVarInitOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp);\n-\n-    T hatMemoryLoadOp(ScopedCodeBuilderContext buildContext, HATMemoryDefOp.HATMemoryLoadOp hatMemoryLoadOp);\n-\n-    T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLoadOp hatPtrLoadOp);\n-\n-    T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrStoreOp hatPtrStoreOp);\n-\n-    T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLengthOp hatPtrLengthOp);\n-\n-    default T recurse(ScopedCodeBuilderContext buildContext, Op op) {\n-        switch (op) {\n-            case CoreOp.VarAccessOp.VarLoadOp $ -> varLoadOp(buildContext, $);\n-            case CoreOp.VarAccessOp.VarStoreOp $ -> varStoreOp(buildContext, $);\n-            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoadOp(buildContext, $);\n-            case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStoreOp(buildContext, $);\n-            case JavaOp.ConvOp $ -> convOp(buildContext, $);\n-            case CoreOp.ConstantOp $ -> constantOp(buildContext, $);\n-            case CoreOp.YieldOp $ -> yieldOp(buildContext, $);\n-            case CoreOp.FuncCallOp $ -> funcCallOp(buildContext, $);\n-            case JavaOp.InvokeOp $ -> invokeOp(buildContext, $);\n-            case JavaOp.ConditionalExpressionOp $ -> conditionalExpressionOp(buildContext, $);\n-            case CoreOp.VarOp $ when ParamVar.of($) instanceof ParamVar paramVar -> varOp(buildContext, $,paramVar);\n-            case CoreOp.VarOp $ -> varOp(buildContext, $);\n-            case JavaOp.LambdaOp $ -> lambdaOp(buildContext, $);\n-            case CoreOp.TupleOp $ -> tupleOp(buildContext, $);\n-            case JavaOp.WhileOp $ -> whileOp(buildContext, $);\n-            case JavaOp.IfOp $ -> ifOp(buildContext, $);\n-            case JavaOp.ForOp $ -> forOp(buildContext, $);\n-            case CoreOp.ReturnOp $ -> returnOp(buildContext, $);\n-            case JavaOp.LabeledOp $ -> labeledOp(buildContext, $);\n-            case JavaOp.BreakOp $ -> breakOp(buildContext, $);\n-            case JavaOp.ContinueOp $ -> continueOp(buildContext, $);\n-            case JavaOp.BinaryTestOp $ -> binaryTestOp(buildContext, $);\n-            case JavaOp.BinaryOp $ -> binaryOp(buildContext, $);\n-            case JavaOp.JavaConditionalOp $ -> conditionalOp(buildContext, $);\n-            case JavaOp.UnaryOp $ -> unaryOp(buildContext, $);\n-            case HATBarrierOp $ -> hatBarrierOp(buildContext, $);\n-            case HATMemoryVarOp.HATLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n-            case HATMemoryVarOp.HATPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n-            case HATMemoryVarOp.HATPrivateInitVarOp $ -> hatPrivateVarInitOp(buildContext, $);\n-            case HATThreadOp.HATGlobalThreadIdOp $ -> hatGlobalThreadIdOp(buildContext, $);\n-            case HATThreadOp.HATGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n-            case HATThreadOp.HATLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n-            case HATThreadOp.HATLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n-            case HATThreadOp.HATBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n-            case HATVectorOp.HATVectorVarOp $ -> hatVectorVarOp(buildContext, $);\n-            case HATVectorOp.HATVectorStoreView $ -> hatVectorStoreOp(buildContext, $);\n-            case HATVectorOp.HATVectorBinaryOp $ -> hatBinaryVectorOp(buildContext, $);\n-            case HATVectorOp.HATVectorLoadOp $ -> hatVectorLoadOp(buildContext, $);\n-            case HATVectorOp.HATVectorSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n-            case HATVectorOp.HATVectorSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n-            case HATVectorOp.HATVectorVarLoadOp $ -> hatVectorVarLoadOp(buildContext, $);\n-            case HATVectorOp.HATVectorOfOp $ -> hatVectorOfOps(buildContext, $);\n-            case HATF16Op.HATF16VarOp $ -> hatF16VarOp(buildContext, $);\n-            case HATF16Op.HATF16BinaryOp $ -> hatF16BinaryOp(buildContext, $);\n-            case HATF16Op.HATF16VarLoadOp $ -> hatF16VarLoadOp(buildContext, $);\n-            case HATF16Op.HATF16ConvOp $ -> hatF16ConvOp(buildContext, $);\n-            case HATVectorOp.HATVectorMakeOfOp $ -> hatVectorMakeOf(buildContext, $);\n-            case HATPtrOp.HATPtrLoadOp $ -> hatPtrLoadOp(buildContext, $);\n-            case HATPtrOp.HATPtrStoreOp $ -> hatPtrStoreOp(buildContext, $);\n-            case HATPtrOp.HATPtrLengthOp $ -> hatPtrLengthOp(buildContext, $);\n-            case HATF16Op.HATF16ToFloatConvOp $ -> hatF16ToFloatConvOp(buildContext, $);\n-            case HATMemoryDefOp.HATMemoryLoadOp $ -> hatMemoryLoadOp(buildContext, $);\n-            default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n-        }\n-        return (T) this;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonKernelOpBuilder.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n+import optkl.codebuilders.C99CodeBuilder;\n@@ -31,3 +31,1 @@\n-import java.util.function.Consumer;\n-\n-public  class C99HATCodeBuilder<T extends C99HATCodeBuilder<T>> extends HATCodeBuilder<T> {\n+public  class C99HATCodeBuilder<T extends C99HATCodeBuilder<T>> extends C99CodeBuilder<T> {\n@@ -69,295 +67,0 @@\n-\n-    public final T suffix_t(ClassType type){\n-        String name = type.toClassName();\n-        int dotIdx = name.lastIndexOf('.');\n-        int dollarIdx = name.lastIndexOf('$');\n-        int idx = Math.max(dotIdx, dollarIdx);\n-        if (idx > 0) {\n-            name = name.substring(idx + 1);\n-        }\n-        return suffix_t(name);\n-    }\n-\n-    public final T suffix_t(String name) {\n-        return identifier(name).identifier(\"_t\");\n-    }\n-\n-    public final T suffix_u(String name) {\n-        return identifier(name).identifier(\"_u\");\n-    }\n-\n-    public final T suffix_s(String name) {\n-        return identifier(name).identifier(\"_s\");\n-    }\n-\n-    public final T suffix_t(Class<?> klass) {\n-        return suffix_t(klass.getSimpleName());\n-    }\n-\n-    public final T suffix_u(Class<?> klass) {\n-        return suffix_u(klass.getSimpleName());\n-    }\n-\n-    public final T suffix_s(Class<?> klass) {\n-        return suffix_s(klass.getSimpleName());\n-    }\n-\n-    public final T structOrUnion(boolean isStruct) {\n-        return (isStruct ? structKeyword() : union());\n-    }\n-\n-    public final T typedefKeyword() {\n-        return keyword(\"typedef\");\n-    }\n-\n-    public final T structKeyword() {\n-        return keyword(\"struct\");\n-    }\n-\n-    public final T union() {\n-        return keyword(\"union\");\n-    }\n-\n-    public final T externC() {\n-        return externKeyword().space().dquote(\"C\");\n-    }\n-\n-    public final T hashDefineKeyword() {\n-        return hash().keyword(\"define\");\n-    }\n-\n-    public final T hashIfdefKeyword() {\n-        return hash().keyword(\"ifdef\");\n-    }\n-\n-    public final T hashIfndefKeyword() {\n-        return hash().keyword(\"ifndef\");\n-    }\n-\n-    public final T hashEndif() {\n-        return hash().keyword(\"endif\").nl();\n-    }\n-\n-    public final T hashIfdef(String value) {\n-        return hashIfdefKeyword().space().constant(value).nl();\n-    }\n-\n-    public final T hashIfndef(String value) {\n-        return hashIfndefKeyword().space().constant(value).nl();\n-    }\n-\n-    public final T hashIfdef(String value, Consumer<T> consumer) {\n-        return hashIfdef(value).accept(consumer).hashEndif();\n-    }\n-\n-    public final T hashIfndef(String value, Consumer<T> consumer) {\n-        return hashIfndef(value).accept(consumer).hashEndif();\n-    }\n-\n-    public final T pragmaKeyword() {\n-        return keyword(\"pragma\");\n-    }\n-\n-    public final T includeKeyword() {\n-        return keyword(\"include\");\n-    }\n-\n-    public final T hashDefine(String name, String... values) {\n-        hashDefineKeyword().space().identifier(name);\n-        for (String value : values) {\n-            space().constant(value);\n-        }\n-        return nl();\n-    }\n-\n-    public final T hashDefine(String name, Consumer<T> consumer) {\n-        hashDefineKeyword().space().identifier(name);\n-        space();\n-        consumer.accept(self());\n-        return nl();\n-    }\n-\n-    public final T pragma(String name, String... values) {\n-        hash().pragmaKeyword().space().identifier(name);\n-        for (String value : values) {\n-            space().constant(value);\n-        }\n-        return nl();\n-    }\n-\n-    public final T includeSys(String... values) {\n-        for (String value : values) {\n-            hash().includeKeyword().space().lt().identifier(value).gt().nl();\n-        }\n-        return self();\n-    }\n-\n-    public final T include(String... values) {\n-        for (String value : values) {\n-            hash().includeKeyword().space().dquote().identifier(value).dquote().nl();\n-        }\n-        return nl();\n-    }\n-\n-    public final T externKeyword() {\n-        return keyword(\"extern\");\n-    }\n-\n-    public final T u08Type() {\n-        return typeName(\"unsigned\").space().s08Type();\n-    }\n-\n-    public final T u08Type(String identifier) {\n-        return u08Type().space().identifier(identifier);\n-    }\n-\n-    public final T u08PtrType() {\n-        return u08Type().space().asterisk();\n-    }\n-\n-    public final T u08PtrType(String identifier) {\n-        return u08PtrType().identifier(identifier);\n-    }\n-\n-    public final T u32Type() {\n-        return typeName(\"unsigned\").space().s32Type();\n-    }\n-\n-    public final T u32Type(String identifier ) {\n-        return u32Type().space().identifier(identifier);\n-    }\n-\n-    public final T u64Type() {\n-        return typeName(\"unsigned\").space().s64Type();\n-    }\n-\n-    public final T u16Type() {\n-        return typeName(\"unsigned\").space().s16Type();\n-    }\n-\n-    public final T u16Type(String identifier) {\n-        return u16Type().space().identifier(identifier);\n-    }\n-\n-    public final T bfloat16Type(String identifier) {\n-        return suffix_t(\"BFLOAT16_UNION\").space().identifier(identifier);\n-    }\n-\n-    public final  T typedefStructOrUnion(boolean isStruct, Class<?> klass, Consumer<T> consumer) {\n-        return typedefKeyword()\n-                .space()\n-                .structOrUnion(isStruct)\n-                .space()\n-                .either(isStruct, _ -> suffix_s(klass), _ -> suffix_u(klass))\n-                .braceNlIndented(consumer)\n-                .suffix_t(klass).semicolonNl();\n-    }\n-\n-    public final T typedefStruct(String name, Consumer<T> consumer) {\n-        return typedefKeyword()\n-                .space()\n-                .structKeyword()\n-                .space()\n-                .suffix_s(name)\n-                .braceNlIndented(consumer)\n-                .suffix_t(name)\n-                .semicolonNl();\n-    }\n-\n-    public final T typedefUnion(String name, Consumer<T> consumer) {\n-        return typedefKeyword()\n-                .space()\n-                .union()\n-                .space()\n-                .suffix_s(name)\n-                .braceNlIndented(consumer)\n-                .suffix_t(name)\n-                .semicolonNl();\n-    }\n-\n-    public final T typedefStruct(Class<?>clazz, Consumer<T> consumer) {\n-        return typedefStruct(clazz.getSimpleName(), consumer);\n-    }\n-\n-    public final T typedefSingleValueStruct(String structName, String type) {\n-        return typedefStruct(structName,_-> typeName(type).space().identifier(\"value\").semicolon());\n-    }\n-\n-    public final T unionBfloat16() {\n-        return typedefUnion(\"BFLOAT16_UNION\", _ -> {\n-            typeName(\"float\").space().identifier(\"f\").semicolon().nl();\n-            u16Type(\"s\").sizeArray(2).semicolon();\n-        });\n-    }\n-\n-    public final T funcDef(Consumer<T> type, Consumer<T> name, Consumer<T> args, Consumer<T> body){\n-        type.accept(self());\n-        space();\n-        name.accept(self());\n-        paren(args);\n-        braceNlIndented(body);\n-        return nl();\n-    }\n-\n-    public final T assign(Consumer<T> lhs, Consumer<T> rhs){\n-        lhs.accept(self());\n-        space().equals().space();\n-        rhs.accept(self());\n-        return self();\n-    }\n-\n-    public final T cast(Consumer<T> type){\n-        return paren(_-> type.accept(self()));\n-    }\n-\n-    public final T returnKeyword(Consumer<T> exp){\n-        return returnKeyword().space().paren(_-> exp.accept(self())).semicolon();\n-    }\n-\n-    public final T call(Consumer<T> name,Consumer<T> ...args) {\n-        name.accept(self());\n-        return paren(_->commaSpaceSeparated(args));\n-    }\n-\n-    public final T call(String name,Consumer<T> ...args) {\n-        return call(_->identifier(name),args);\n-    }\n-\n-    public final T forLoop(Consumer<T> init, Consumer<T> test, Consumer<T>mutate, Consumer<T>body) {\n-        return  forKeyword()\n-                .paren(_->{\n-                    init.accept(self());\n-                    semicolon().space();\n-                    test.accept(self());\n-                    semicolon().space();mutate.accept(self());\n-                })\n-                .braceNlIndented(body::accept);\n-    }\n-\n-    public final T sizeof() {\n-        return emitText(\"sizeof\");\n-    }\n-\n-    public final T sizeof(String identifier) {\n-        return sizeof(_->identifier(identifier));\n-    }\n-\n-    public final T sizeof(Consumer<T> consumer) {\n-        return sizeof().paren(consumer);\n-    }\n-\n-    public final T voidPtrType() {\n-        return voidType().space().asterisk();\n-    }\n-\n-    public final T voidPtrType(String identifier) {\n-        return voidPtrType().identifier(identifier);\n-    }\n-\n-    public final T sizeType() {\n-        return typeName(\"size_t\");\n-    }\n-\n-    public final T sizeType(String identifier) {\n-        return sizeType().space().identifier(identifier);\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilder.java","additions":2,"deletions":299,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import optkl.FuncOpParams;\n@@ -34,1 +33,0 @@\n-import optkl.ParamVar;\n@@ -36,1 +34,0 @@\n-import optkl.util.ops.Precedence;\n@@ -38,1 +35,0 @@\n-import optkl.util.StreamMutable;\n@@ -43,1 +39,1 @@\n-import optkl.codebuilders.BabylonCoreOpBuilder;\n+import optkl.codebuilders.BabylonOpDispatcher;\n@@ -46,2 +42,0 @@\n-\n-import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n@@ -49,1 +43,0 @@\n-import static optkl.OpHelper.Ternary.ternaryOpHelper;\n@@ -52,1 +45,1 @@\n-        implements BabylonCoreOpBuilder<T, ScopedCodeBuilderContext> {\n+        implements BabylonOpDispatcher<T, ScopedCodeBuilderContext> {\n@@ -95,24 +88,0 @@\n-    private void varDeclarationWithInitialization(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n-        if (buildContext.isVarOpFinal(varOp)) {\n-            constKeyword().space();\n-        }\n-        type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp).space().equals().space();\n-        parenthesisIfNeeded(buildContext, varOp, ((Op.Result)varOp.operands().getFirst()).op());\n-    }\n-\n-    @Override\n-    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n-        if (varOp.isUninitialized()) {\n-            type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp);\n-        } else {\n-            varDeclarationWithInitialization(buildContext, varOp);\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, ParamVar paramVar) {\n-        varName(varOp);\n-        return self();\n-    }\n-\n@@ -120,51 +89,1 @@\n-    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp1) {\n-        if (fieldAccessOpHelper(buildContext.lookup,fieldLoadOp1) instanceof OpHelper.NamedOpHelper.FieldAccess fieldAccess\n-              &&  fieldAccess.operandCount()==0 && fieldAccess.isPrimitive() ) {\n-            Object value = fieldAccess.getStaticFinalPrimitiveValue();\n-            literal(value.toString());\n-        } else {\n-            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOp1);\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T fieldStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp) {\n-        throw new IllegalStateException(\"What is this field store ?\" + fieldStoreOp);\n-       \/\/ return self();\n-    }\n-\n-\n-    @Override\n-    public T unaryOp(ScopedCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp) {\n-        symbol(unaryOp).parenthesisIfNeeded(buildContext, unaryOp, ((Op.Result)unaryOp.operands().getFirst()).op());\n-        return self();\n-    }\n-\n-    @Override\n-    public T binaryOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp) {\n-        parenthesisIfNeeded(buildContext, binaryOp, OpHelper.lhsResult(binaryOp).op());\n-        symbol(binaryOp);\n-        parenthesisIfNeeded(buildContext, binaryOp, OpHelper.rhsResult(binaryOp).op());\n-        return self();\n-    }\n-\n-\n-    @Override\n-    public T conditionalOp(ScopedCodeBuilderContext buildContext, JavaOp.JavaConditionalOp logicalOp) {\n-        OpHelper.lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n-        space().symbol(logicalOp).space();\n-        OpHelper.rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n-        return self();\n-    }\n-\n-    @Override\n-    public T binaryTestOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp) {\n-        parenthesisIfNeeded(buildContext, binaryTestOp, OpHelper.lhsResult(binaryTestOp).op());\n-        symbol(binaryTestOp);\n-        parenthesisIfNeeded(buildContext, binaryTestOp, OpHelper.rhsResult(binaryTestOp).op());\n-        return self();\n-    }\n-\n-    @Override\n-    public T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n+    public final  T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n@@ -181,158 +100,0 @@\n-    @Override\n-    public T constantOp(ScopedCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp) {\n-        if (constantOp.value() == null) {\n-            nullConst();\n-        } else {\n-            literal(constantOp.value().toString());\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T yieldOp(ScopedCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp) {\n-        if (yieldOp.operands().getFirst() instanceof Op.Result result) {\n-            recurse(buildContext, result.op());\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp) {\n-        return comment(\"\/*LAMBDA*\/\");\n-    }\n-\n-    @Override\n-    public T tupleOp(ScopedCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp) {\n-        commaSpaceSeparated(tupleOp.operands(),operand->{\n-            if (operand instanceof Op.Result result) {\n-                recurse(buildContext, result.op());\n-            } else {\n-                comment(\"\/*nothing to tuple*\/\");\n-            }\n-        });\n-        return self();\n-    }\n-\n-    @Override\n-    public T funcCallOp(ScopedCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp) {\n-        funcName(funcCallOp);\n-        paren(_ ->\n-            commaSpaceSeparated(\n-                    funcCallOp.operands().stream().filter(e->e instanceof Op.Result ).map(e->(Op.Result)e),\n-                    result -> recurse(buildContext,result.op())\n-            )\n-        );\n-        return self();\n-    }\n-\n-    @Override\n-    public T labeledOp(ScopedCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp) {\n-        var labelNameOp = labeledOp.bodies().getFirst().entryBlock().ops().getFirst();\n-        CoreOp.ConstantOp constantOp = (CoreOp.ConstantOp) labelNameOp;\n-        literal(constantOp.value().toString()).colon().nl();\n-        var forLoopOp = labeledOp.bodies().getFirst().entryBlock().ops().get(1);\n-        recurse(buildContext,forLoopOp);\n-        return self();\n-    }\n-\n-    @Override\n-    public T breakOp(ScopedCodeBuilderContext buildContext, JavaOp.BreakOp breakOp) {\n-        breakKeyword();\n-        if (!breakOp.operands().isEmpty() && breakOp.operands().getFirst() instanceof Op.Result result) {\n-            space();\n-            if (result.op() instanceof CoreOp.ConstantOp c) {\n-                literal(c.value().toString());\n-            }\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T continueOp(ScopedCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp) {\n-        if (!continueOp.operands().isEmpty()\n-                && continueOp.operands().getFirst() instanceof Op.Result result\n-                && result.op() instanceof CoreOp.ConstantOp c\n-        ) {\n-            continueKeyword().space().literal(c.value().toString());\n-        } else if (buildContext.scope.parent instanceof ScopedCodeBuilderContext.ForScope) {\n-            \/\/ nope\n-        } else {\n-            continueKeyword();\n-        }\n-\n-        return self();\n-    }\n-\n-    @Override\n-    public T ifOp(ScopedCodeBuilderContext buildContext, JavaOp.IfOp ifOp) {\n-        buildContext.ifScope(ifOp, () -> {\n-            var lastWasBody = StreamMutable.of(false);\n-            var i = StreamMutable.of(0);\n-            \/\/ We probably should just use a regular for loop here ;)\n-            ifOp.bodies().forEach(b->{\n-                int idx = i.get();\n-                if (b.yieldType() instanceof JavaType javaType && javaType == JavaType.VOID) {\n-                    if (ifOp.bodies().size() > idx && ifOp.bodies().get(idx).entryBlock().ops().size() > 1){\n-                        if (lastWasBody.get()) {\n-                            elseKeyword();\n-                        }\n-                        braceNlIndented(_ ->\n-                                        nlSeparated(OpHelper.Statement.statements(ifOp.bodies().get(idx).entryBlock()),\n-                                        root-> statement(buildContext,root)\n-                                        ));\n-                    }\n-                    lastWasBody.set(true);\n-                } else {\n-                    if (idx>0) {\n-                        elseKeyword().space();\n-                    }\n-                    ifKeyword().paren(_ ->\n-                            ifOp.bodies().get(idx).entryBlock()            \/\/ get the entryblock if bodies[c.value]\n-                                    .ops().stream().filter(o->o instanceof CoreOp.YieldOp) \/\/ we want all the yields\n-                                    .forEach((yield) -> recurse(buildContext, yield))\n-                    );\n-                    lastWasBody.set(false);\n-                }\n-                i.set(i.get()+1);\n-            });\n-        });\n-        return self();\n-    }\n-\n-    @Override\n-    public T whileOp(ScopedCodeBuilderContext buildContext, JavaOp.WhileOp whileOp) {\n-        whileKeyword().paren(_ ->\n-                        OpHelper.entryBlockOfBodyN(whileOp, 0)\n-               \/\/ condBlock(whileOp)\n-                        .ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n-                        .forEach(o -> recurse(buildContext, o))\n-        );\n-        braceNlIndented(_ ->\n-                        nlSeparated(OpHelper.Statement.loopBodyStatements(whileOp),\n-                        statement->statement(buildContext,statement)\n-                )\n-        );\n-        return self();\n-    }\n-\n-    @Override\n-    public T forOp(ScopedCodeBuilderContext buildContext, JavaOp.ForOp forOp) {\n-        buildContext.forScope(forOp, () ->\n-                forKeyword().paren(_ -> {\n-                    forOp.init().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-                    semicolon().space();\n-                    forOp.cond().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-                    semicolon().space();\n-                    commaSpaceSeparated(\n-                            OpHelper.Statement.statements(forOp.update().entryBlock()),\n-                            op -> recurse(buildContext, op)\n-                    );\n-                }).braceNlIndented(_ ->\n-                            nlSeparated(OpHelper.Statement.loopBodyStatements(forOp),\n-                                    statement ->statement(buildContext,statement)\n-                        )\n-                )\n-        );\n-        return self();\n-    }\n-\n@@ -344,1 +105,1 @@\n-    public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n+    public final T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n@@ -346,1 +107,1 @@\n-        if ( invoke.refIs(MappableIface.class,HAType.class,DeviceType.class)) {\n+        if ( invoke.refIs(MappableIface.class,HAType.class,DeviceType.class)) { \/\/ we need a common type\n@@ -355,0 +116,4 @@\n+                        invoke.operandCount() > 1\n+                                && invokeOpHelper(buildContext.lookup,instance.op()) instanceof OpHelper.NamedOpHelper.Invoke invoke0\n+                                && invoke0.returnsClassType()\n+                        ,\n@@ -369,4 +134,1 @@\n-                    invoke.operandCount() > 1\n-                                && invokeOpHelper(buildContext.lookup,instance.op()) instanceof OpHelper.NamedOpHelper.Invoke invoke0\n-                                && invoke0.returnsClassType()\n-                        , _->{\n+                    _->{\n@@ -387,1 +149,1 @@\n-                        case 2-> {\n+                        case 2 -> {\n@@ -418,51 +180,0 @@\n-    @Override\n-    public T conditionalExpressionOp(ScopedCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp) {\n-        OpHelper.Ternary ternary = ternaryOpHelper(buildContext.lookup,ternaryOp);\n-        ternary.condBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-        questionMark();\n-        ternary.thenBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-        colon();\n-        ternary.elseBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-        return self();\n-    }\n-\n-    \/**\n-     * Wrap paren() of precedence of op is higher than parent.\n-     *\n-     * @param buildContext\n-     * @param parent\n-     * @param child\n-     *\/\n-    @Override\n-    public T parenthesisIfNeeded(ScopedCodeBuilderContext buildContext, Op parent, Op child) {\n-        return parenWhen(Precedence.needsParenthesis(parent,child), _ -> recurse(buildContext, child));\n-    }\n-\n-    @Override\n-    public T returnOp(ScopedCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp) {\n-        returnKeyword().when(!returnOp.operands().isEmpty(),\n-                        $-> $.space().parenthesisIfNeeded(buildContext, returnOp, ((Op.Result) returnOp.operands().getFirst()).op())\n-                );\n-        return self();\n-    }\n-\n-    public T statement(ScopedCodeBuilderContext buildContext,Op op) {\n-        recurse(buildContext, op);\n-        if (switch (op){\n-                case JavaOp.ForOp _ -> false;\n-                case JavaOp.WhileOp _ -> false;\n-                case JavaOp.IfOp _ -> false;\n-                case JavaOp.LabeledOp _ -> false;\n-                case JavaOp.YieldOp _ -> false;\n-                case CoreOp.TupleOp _ ->false;\n-                default -> true;\n-            }\n-        ){\n-            semicolon();\n-        }\n-        return self();\n-    }\n-\n-    public T declareParam(ScopedCodeBuilderContext buildContext, FuncOpParams.Info param){\n-        return  type(buildContext,(JavaType) param.parameter.type()).space().varName(param.varOp);\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":11,"deletions":300,"binary":false,"changes":311,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public T computeDeclaration(TypeElement typeElement, String name) {\n+    public final T computeDeclaration(TypeElement typeElement, String name) {\n@@ -38,1 +38,1 @@\n-    public T compute(ScopedCodeBuilderContext buildContext) {\n+    public final  T compute(ScopedCodeBuilderContext buildContext) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import hat.FFIConfigCreator;\n+import optkl.codebuilders.C99CodeBuilder;\n+import optkl.util.StreamMutable;\n@@ -29,1 +32,2 @@\n-public  class C99HATConfigBuilder extends C99HATCodeBuilder<C99HATConfigBuilder> {\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n@@ -31,1 +35,3 @@\n-   public  C99HATConfigBuilder staticConstInt(String name, int padWidth, int value) {\n+public  class C99HATConfigBuilder extends C99CodeBuilder<C99HATConfigBuilder> {\n+\n+   public final  C99HATConfigBuilder staticConstInt(String name, int padWidth, int value) {\n@@ -36,1 +42,1 @@\n-    public C99HATConfigBuilder staticConstIntShiftedOne(String name, int padWidth, int shift) {\n+    public final C99HATConfigBuilder staticConstIntShiftedOne(String name, int padWidth, int shift) {\n@@ -41,1 +47,1 @@\n-    public C99HATConfigBuilder className() {\n+    public final C99HATConfigBuilder className() {\n@@ -45,1 +51,1 @@\n-    public C99HATConfigBuilder bitNamesVar() {\n+    public final C99HATConfigBuilder bitNamesVar() {\n@@ -49,1 +55,1 @@\n-    public C99HATConfigBuilder bitDescriptionsVar() {\n+    public final C99HATConfigBuilder bitDescriptionsVar() {\n@@ -53,1 +59,1 @@\n-    public C99HATConfigBuilder configBitsVar() {\n+    public final C99HATConfigBuilder configBitsVar() {\n@@ -57,1 +63,1 @@\n-    public C99HATConfigBuilder configBitsAnd() {\n+    public final C99HATConfigBuilder configBitsAnd() {\n@@ -61,1 +67,1 @@\n-    public C99HATConfigBuilder configBitsAndBitName(String bitName) {\n+    public final C99HATConfigBuilder configBitsAndBitName(String bitName) {\n@@ -65,1 +71,1 @@\n-    public C99HATConfigBuilder camelExceptFirst(String s) {\n+    public final C99HATConfigBuilder camelExceptFirst(String s) {\n@@ -69,1 +75,1 @@\n-    C99HATConfigBuilder std(String s) {\n+    public final C99HATConfigBuilder std(String s) {\n@@ -73,1 +79,1 @@\n-    public C99HATConfigBuilder stdEndl() {\n+    public final C99HATConfigBuilder stdEndl() {\n@@ -77,1 +83,1 @@\n-    public C99HATConfigBuilder stdCout(String s) {\n+    public final C99HATConfigBuilder stdCout(String s) {\n@@ -81,0 +87,73 @@\n+    public static String create(){\n+\n+        C99HATConfigBuilder cb = new C99HATConfigBuilder();\n+        cb.oracleCopyright();\n+        cb.blockComment(\"\"\"\n+                You probably should not edit this this file!!!\n+                It was auto generated\"\"\" + \" \" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date()) + \" by \" + FFIConfigCreator.class.getName()\n+        );\n+        cb.pragma(\"once\").nl();\n+        cb.includeSys(\"iostream\").nl();\n+        final int START_BIT_INDEX = Config.bitList.stream().filter(bit -> bit.size() == 1).findFirst().get().index();\n+\n+        cb.structKeyword().space().className().braceNlIndented((_) -> {\n+            var i = StreamMutable.of(START_BIT_INDEX);\n+            Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit -> {\n+                cb.staticConstIntShiftedOne(bit.name() + \"_BIT\", 32, i.get());\n+                i.set(i.get() + 1);\n+            });\n+            cb.constKeyword().space().staticKeyword().space().s08Type().space().asterisk().bitNamesVar().osbrace().csbrace().semicolon().space().lineComment(\"See below for initialization\");\n+            cb.constKeyword().space().staticKeyword().space().s08Type().space().asterisk().bitDescriptionsVar().osbrace().csbrace().semicolon().space().lineComment(\"See below for initialization\");\n+\n+            cb.s32Type().space().identifier(\"configBits\").semicolon().nl();\n+\n+            Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n+                    cb.identifier(\"bool\").space().camelExceptFirst(bit.name()).semicolon().nl()\n+            );\n+\n+            cb.s32Type().space().identifier(\"platform\").semicolon().nl();\n+            cb.s32Type().space().identifier(\"device\").semicolon().nl();\n+            cb.identifier(\"bool\").space().identifier(\"alwaysCopy\").semicolon().nl();\n+            \/\/Constructor\n+            cb.explicitKeyword().space().className().paren((_) -> cb.s32Type().space().configBitsVar()).colon().nl().indent((_) -> {\n+                cb.configBitsVar().paren((_) -> cb.configBitsVar()).comma().nl();\n+                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n+                        cb.camelExceptFirst(bit.name()).paren((_) -> cb.paren((_) -> cb.configBitsAndBitName(bit.name())).eq().identifier(bit.name() + \"_BIT\")).comma().nl()\n+                );\n+                cb.identifier(\"platform\").paren((_) -> cb.configBitsAnd().intHexValue(0xf)).comma().nl();\n+                cb.identifier(\"alwaysCopy\").paren(_ -> cb.pling().camelExceptFirst(\"MINIMIZE_COPIES\")).comma().nl();\n+                cb.identifier(\"device\").paren(_ ->\n+                        cb.paren(_ -> cb.configBitsAnd().intHexValue(0xf0)).space().rightShift().space().intValue(4)).braceNlIndented(_ ->\n+                        cb.ifKeyword().paren(_ -> cb.identifier(\"showDeviceInfo\")).braceNlIndented(_ -> {\n+                            cb.nlSeparated(\n+                                    Config.bitList.stream().filter(bit -> bit.size() == 1),\n+                                    bit -> cb.stdCout(\"native \" + cb.toCamelExceptFirst(bit.name()) + \" \").space().leftShift().space().camelExceptFirst(bit.name()).space().leftShift().space().stdEndl().semicolon()\n+                            );\n+                            cb.nl().stdCout(\"native platform \").space().leftShift().space().identifier(\"platform\").space().leftShift().space().stdEndl().semicolon();\n+                            cb.nl().stdCout(\"native device \").space().leftShift().space().identifier(\"device\").space().leftShift().space().stdEndl().semicolon();\n+                        })\n+                );\n+            }).nl();\n+\n+            cb.virtualKeyword().space().tilde().className().ocparen().equals().space().defaultKeyword().semicolon();\n+        }).semicolon().nl().nl();\n+\n+\n+        cb.hashIfdef(\"shared_cpp\", (_) -> {\n+            cb.constKeyword().space().s08Type().space().asterisk().className().colon().colon().bitNamesVar().ocsbrace().equals().brace((_) -> {\n+                cb.nl();\n+                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n+                        cb.dquote().identifier(bit.name() + \"_BIT\").dquote().comma().nl()\n+                );\n+            }).semicolon().nl();\n+            cb.constKeyword().space().s08Type().space().asterisk().className().colon().colon().bitDescriptionsVar().ocsbrace().equals().brace((_) -> {\n+                cb.nl();\n+                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n+                        cb.dquote().identifier(bit.description()).dquote().comma().nl()\n+                );\n+            }).semicolon().nl();\n+        });\n+        return cb.toString();\n+\n+    }\n+\n@@ -82,1 +161,1 @@\n-        var c = Config.fromSpec(\"INFO,SHOW_CODE,HEADLESS,NO_BUFFER_TAGGING,SHOW_KERNEL_MODEL,SHOW_COMPUTE_MODEL,PLATFORM:0,DEVICE:0\");\n+        var c = Config.fromSpec(\"INFO,SHOW_CODE,HEADLESS,SHOW_KERNEL_MODEL,SHOW_COMPUTE_MODEL,PLATFORM:0,DEVICE:0\");\n@@ -84,0 +163,1 @@\n+        System.out.println(create());\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATConfigBuilder.java","additions":94,"deletions":14,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-public abstract class C99HATKernelBuilder<T extends C99HATKernelBuilder<T>> extends C99HATCodeBuilderContext<T> implements BabylonKernelOpBuilder<T>  {\n+public abstract class C99HATKernelBuilder<T extends C99HATKernelBuilder<T>> extends C99HATCodeBuilderContext<T> implements HATOpDispatcher<T> {\n@@ -54,1 +54,1 @@\n-    public T HAT_KERNEL() {\n+    public final T HAT_KERNEL() {\n@@ -58,1 +58,1 @@\n-    public T HAT_FUNC() {\n+    public final T HAT_FUNC() {\n@@ -62,1 +62,1 @@\n-    public T HAT_GLOBAL_MEM() {\n+    public final T HAT_GLOBAL_MEM() {\n@@ -66,1 +66,1 @@\n-    public T HAT_LOCAL_MEM() {\n+    public final T HAT_LOCAL_MEM() {\n@@ -70,1 +70,1 @@\n-    public T HAT_BARRIER() {\n+    public final T HAT_BARRIER() {\n@@ -74,1 +74,1 @@\n-    public T HAT_GIX(){\n+    public final T HAT_GIX(){\n@@ -78,1 +78,1 @@\n-    public T HAT_GIY(){\n+    public final T HAT_GIY(){\n@@ -82,1 +82,1 @@\n-    public T HAT_GIZ(){\n+    public final T HAT_GIZ(){\n@@ -86,1 +86,1 @@\n-    public T HAT_GSX(){\n+    public final T HAT_GSX(){\n@@ -90,1 +90,1 @@\n-    public T HAT_GSY(){\n+    public final T HAT_GSY(){\n@@ -94,1 +94,1 @@\n-    public T HAT_GSZ(){\n+    public final T HAT_GSZ(){\n@@ -98,1 +98,1 @@\n-    public T HAT_LIX(){\n+    public final T HAT_LIX(){\n@@ -102,1 +102,1 @@\n-    public T HAT_LIY(){\n+    public final T HAT_LIY(){\n@@ -106,1 +106,1 @@\n-    public T HAT_LIZ(){\n+    public final T HAT_LIZ(){\n@@ -110,1 +110,1 @@\n-    public T HAT_LSX(){\n+    public final T HAT_LSX(){\n@@ -114,1 +114,1 @@\n-    public T HAT_LSY(){\n+    public final T HAT_LSY(){\n@@ -118,1 +118,1 @@\n-    public T HAT_LSZ(){\n+    public final T HAT_LSZ(){\n@@ -123,1 +123,1 @@\n-    public T HAT_BIX(){\n+    public final T HAT_BIX(){\n@@ -127,1 +127,1 @@\n-    public T HAT_BIY(){\n+    public final T HAT_BIY(){\n@@ -131,1 +131,1 @@\n-    public T HAT_BIZ(){\n+    public final T HAT_BIZ(){\n@@ -137,1 +137,1 @@\n-    public T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp globalThreadIdOp) {\n+    public final T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp globalThreadIdOp) {\n@@ -148,1 +148,1 @@\n-    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp globalSizeOp) {\n+    public final T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp globalSizeOp) {\n@@ -159,1 +159,1 @@\n-    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp localThreadIdOp) {\n+    public final T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp localThreadIdOp) {\n@@ -170,1 +170,1 @@\n-    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp) {\n+    public final T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp) {\n@@ -180,1 +180,1 @@\n-    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp) {\n+    public final T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp) {\n@@ -189,1 +189,1 @@\n-    public T kernelDeclaration(CoreOp.FuncOp funcOp) {\n+    public final T kernelDeclaration(CoreOp.FuncOp funcOp) {\n@@ -193,1 +193,1 @@\n-    public T functionDeclaration(ScopedCodeBuilderContext codeBuilderContext, JavaType javaType, CoreOp.FuncOp funcOp) {\n+    public final  T functionDeclaration(ScopedCodeBuilderContext codeBuilderContext, JavaType javaType, CoreOp.FuncOp funcOp) {\n@@ -298,1 +298,1 @@\n-    final  T identifierWithRandomSuffix(String prefix, final int len) {\n+    public  final  T identifierWithRandomSuffix(String prefix, final int len) {\n@@ -325,1 +325,1 @@\n-    public T hatBarrierOp(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp) {\n+    public final T hatBarrierOp(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp) {\n@@ -341,1 +341,1 @@\n-    public T types() {\n+    public final  T types() {\n@@ -349,1 +349,1 @@\n-    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+    public final T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n@@ -360,1 +360,1 @@\n-    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n+    public final  T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n@@ -375,1 +375,2 @@\n-    public T kernelMethod(ScopedCodeBuilderContext buildContext,CoreOp.FuncOp funcOp) {\n+\n+    public final  T kernelMethod(ScopedCodeBuilderContext buildContext,CoreOp.FuncOp funcOp) {\n@@ -396,1 +397,1 @@\n-    public T kernelEntrypoint(ScopedCodeBuilderContext buildContext) {\n+    public final  T kernelEntrypoint(ScopedCodeBuilderContext buildContext) {\n@@ -415,1 +416,1 @@\n-    public T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarLoadOp hatVectorVarLoadOp) {\n+    public final T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarLoadOp hatVectorVarLoadOp) {\n@@ -428,1 +429,1 @@\n-    public T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarOp hatF16VarOp) {\n+    public final T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarOp hatF16VarOp) {\n@@ -455,1 +456,1 @@\n-    private T binaryOperationsForBfloat16(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatf16BinaryOp) {\n+    private final T binaryOperationsForBfloat16(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatf16BinaryOp) {\n@@ -533,1 +534,1 @@\n-    public T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarLoadOp hatF16VarLoadOp) {\n+    public final T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarLoadOp hatF16VarLoadOp) {\n@@ -538,1 +539,1 @@\n-    public T hatVectorMakeOf(ScopedCodeBuilderContext builderContext, HATVectorOp.HATVectorMakeOfOp hatVectorMakeOfOp) {\n+    public final T hatVectorMakeOf(ScopedCodeBuilderContext builderContext, HATVectorOp.HATVectorMakeOfOp hatVectorMakeOfOp) {\n@@ -545,1 +546,1 @@\n-    public T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorOfOp hatVectorOp) {\n+    public final T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorOfOp hatVectorOp) {\n@@ -554,1 +555,1 @@\n-    public T hatPrivateVarInitOp(ScopedCodeBuilderContext builderContext, HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp) {\n+    public final T hatPrivateVarInitOp(ScopedCodeBuilderContext builderContext, HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp) {\n@@ -562,1 +563,1 @@\n-    public T hatMemoryLoadOp(ScopedCodeBuilderContext builderContext, HATMemoryDefOp.HATMemoryLoadOp hatMemoryLoadOp) {\n+    public final T hatMemoryLoadOp(ScopedCodeBuilderContext builderContext, HATMemoryDefOp.HATMemoryLoadOp hatMemoryLoadOp) {\n@@ -570,1 +571,1 @@\n-    public T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLoadOp hatPtrLoadOp) {\n+    public final T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLoadOp hatPtrLoadOp) {\n@@ -576,1 +577,1 @@\n-    public T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrStoreOp hatPtrStoreOp) {\n+    public final T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrStoreOp hatPtrStoreOp) {\n@@ -582,1 +583,1 @@\n-    public T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLengthOp hatPtrLengthOp) {\n+    public final  T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLengthOp hatPtrLengthOp) {\n@@ -587,1 +588,1 @@\n-    T ptrAccess(ScopedCodeBuilderContext builderContext, HATPtrOp hatPtrOp) {\n+    public final T ptrAccess(ScopedCodeBuilderContext builderContext, HATPtrOp hatPtrOp) {\n@@ -619,1 +620,1 @@\n-    public String hatPtrName(HATPtrOp hatPtrOp) {\n+    public final String hatPtrName(HATPtrOp hatPtrOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":49,"deletions":48,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import optkl.codebuilders.CodeBuilder;\n-\n-public abstract class HATCodeBuilder<T extends HATCodeBuilder<T>> extends CodeBuilder<T> {\n-\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.codebuilders;\n+\n+import hat.dialect.*;\n+import jdk.incubator.code.Op;\n+import optkl.codebuilders.BabylonOpDispatcher;\n+import optkl.codebuilders.JavaOrC99StyleCodeBuilder;\n+import optkl.codebuilders.ScopedCodeBuilderContext;\n+\n+\/* this should not be too C99 specific but can reference HAT ops.  *\/\n+public interface HATOpDispatcher<T extends JavaOrC99StyleCodeBuilder<T>> extends BabylonOpDispatcher<T, ScopedCodeBuilderContext> {\n+\n+    T hatBarrierOp(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp);\n+\n+    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATLocalVarOp barrierOp);\n+\n+    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATPrivateVarOp hatLocalVarOp);\n+\n+    T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp hatGlobalThreadIdOp);\n+\n+    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp hatGlobalSizeOp);\n+\n+    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp hatLocalThreadIdOp);\n+\n+    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp);\n+\n+    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp);\n+\n+    T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarOp hatVectorVarOp);\n+\n+    T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorStoreView hatFloat4StoreOp);\n+\n+    T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp);\n+\n+    T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorLoadOp hatVectorLoadOp);\n+\n+    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectLoadOp hatVSelectLoadOp);\n+\n+    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectStoreOp hatVSelectStoreOp);\n+\n+    T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarLoadOp hatVectorVarLoadOp);\n+\n+    T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarOp hatF16VarOp);\n+\n+    T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatF16BinaryOp);\n+\n+    T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarLoadOp hatF16VarLoadOp);\n+\n+    T hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ConvOp hatF16ConvOp);\n+\n+    T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorOfOp hatVectorOp);\n+\n+    T hatVectorMakeOf(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorMakeOfOp hatVectorMakeOfOp);\n+\n+    T hatF16ToFloatConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ToFloatConvOp hatF16ToFloatConvOp);\n+\n+    T hatPrivateVarInitOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp);\n+\n+    T hatMemoryLoadOp(ScopedCodeBuilderContext buildContext, HATMemoryDefOp.HATMemoryLoadOp hatMemoryLoadOp);\n+\n+    T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLoadOp hatPtrLoadOp);\n+\n+    T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrStoreOp hatPtrStoreOp);\n+\n+    T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLengthOp hatPtrLengthOp);\n+\n+    @Override\n+    default T recurse(ScopedCodeBuilderContext buildContext, Op op) {\n+        if (op instanceof HATOp hatOp) {\n+            switch (hatOp) {\n+                case HATBarrierOp $ -> hatBarrierOp(buildContext, $);\n+                case HATMemoryVarOp.HATLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n+                case HATMemoryVarOp.HATPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n+                case HATMemoryVarOp.HATPrivateInitVarOp $ -> hatPrivateVarInitOp(buildContext, $);\n+                case HATThreadOp.HATGlobalThreadIdOp $ -> hatGlobalThreadIdOp(buildContext, $);\n+                case HATThreadOp.HATGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n+                case HATThreadOp.HATLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n+                case HATThreadOp.HATLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n+                case HATThreadOp.HATBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n+                case HATVectorOp.HATVectorVarOp $ -> hatVectorVarOp(buildContext, $);\n+                case HATVectorOp.HATVectorStoreView $ -> hatVectorStoreOp(buildContext, $);\n+                case HATVectorOp.HATVectorBinaryOp $ -> hatBinaryVectorOp(buildContext, $);\n+                case HATVectorOp.HATVectorLoadOp $ -> hatVectorLoadOp(buildContext, $);\n+                case HATVectorOp.HATVectorSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n+                case HATVectorOp.HATVectorSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n+                case HATVectorOp.HATVectorVarLoadOp $ -> hatVectorVarLoadOp(buildContext, $);\n+                case HATVectorOp.HATVectorOfOp $ -> hatVectorOfOps(buildContext, $);\n+                case HATF16Op.HATF16VarOp $ -> hatF16VarOp(buildContext, $);\n+                case HATF16Op.HATF16BinaryOp $ -> hatF16BinaryOp(buildContext, $);\n+                case HATF16Op.HATF16VarLoadOp $ -> hatF16VarLoadOp(buildContext, $);\n+                case HATF16Op.HATF16ConvOp $ -> hatF16ConvOp(buildContext, $);\n+                case HATVectorOp.HATVectorMakeOfOp $ -> hatVectorMakeOf(buildContext, $);\n+                case HATPtrOp.HATPtrLoadOp $ -> hatPtrLoadOp(buildContext, $);\n+                case HATPtrOp.HATPtrStoreOp $ -> hatPtrStoreOp(buildContext, $);\n+                case HATPtrOp.HATPtrLengthOp $ -> hatPtrLengthOp(buildContext, $);\n+                case HATF16Op.HATF16ToFloatConvOp $ -> hatF16ToFloatConvOp(buildContext, $);\n+                case HATMemoryDefOp.HATMemoryLoadOp $ -> hatMemoryLoadOp(buildContext, $);\n+                default -> throw new IllegalStateException(\"handle nesting of hat op \" + op);\n+            }\n+        }else{\n+            BabylonOpDispatcher.super.recurse(buildContext, op);\n+        }\n+\n+        return (T) this;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATOpDispatcher.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.KernelContext;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import optkl.OpHelper;\n-import optkl.codebuilders.BabylonCoreOpBuilder;\n-import optkl.codebuilders.ScopedCodeBuilderContext;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n-\n-public class JavaHATCodeBuilder<T extends JavaHATCodeBuilder<T>> extends C99HATCodeBuilderContext<T> implements BabylonCoreOpBuilder<T,ScopedCodeBuilderContext> {\n-\n-\n-    @Override\n-    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n-        return typeName(javaType.toString());\n-    }\n-\n-    @Override\n-    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldLoadOp);\n-        if ( fieldAccess.refType(KernelContext.class)) {\n-            identifier(\"kc\").dot().fieldName(fieldLoadOp);\n-        } else if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) { \/\/ only primitve fields\n-            var value = fieldAccess.getStaticFinalPrimitiveValue();\n-            literal(value.toString());\n-        } else {\n-            throw new IllegalStateException(\"An instance field? I guess - we dont get those in HAT \" +fieldLoadOp);\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n-        return null;\n-    }\n-\n-    @Override\n-     public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n-        if (invokeOp.invokeKind()== JavaOp.InvokeOp.InvokeKind.STATIC) {\n-            identifier(invokeOp.invokeDescriptor().refType().toString());\n-        }else{\n-            throw new IllegalStateException(\"Unexpected invokeOp ... in code builder\");\n-        }\n-        dot().identifier(invokeOp.invokeDescriptor().name());\n-        paren(_ ->\n-            commaSpaceSeparated(  invokeOp.operands(), o-> {\n-                if (o instanceof Op.Result result) {\n-                    recurse(buildContext, result.op());\n-                } else if (o instanceof jdk.incubator.code.Block.Parameter parameter) {\n-                    identifier(\"param$\"+parameter.index());\n-                }else {\n-                    throw new IllegalStateException(\"What have we here \");\n-                }\n-            })\n-        );\n-        return self();\n-    }\n-\n-    public T createJava(ScopedCodeBuilderContext buildContext) {\n-        buildContext.funcScope(buildContext.funcOp, () -> {\n-            typeName(buildContext.funcOp.resultType().toString()).space().funcName(buildContext.funcOp);\n-            parenNlIndented(_ ->\n-                    commaNlSeparated(\n-                            buildContext.paramTable.list(),\n-                            param -> declareParam(buildContext, param)\n-                    )\n-            );\n-            braceNlIndented(_ -> nlSeparated(\n-                    OpHelper.Statement.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n-                    statement -> statement(buildContext, statement)\n-                    )\n-            );\n-        });\n-        return nl();\n-    }\n-    private final ScopedCodeBuilderContext scopedCodeBuilderContext;\n-    public JavaHATCodeBuilder(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp){\n-        super();\n-        scopedCodeBuilderContext= new ScopedCodeBuilderContext(lookup,funcOp);\n-    }\n-\n-    public String toText() {\n-        return createJava(scopedCodeBuilderContext).getText();\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/JavaHATCodeBuilder.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.codebuilders.JavaHATCodeBuilder;\n+import optkl.codebuilders.JavaCodeBuilder;\n@@ -182,1 +182,1 @@\n-                        var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Then\"));\n+                        var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Then \\\"With this text\\\"\"));\n@@ -203,1 +203,1 @@\n-                    var javaCodeBuilder = new JavaHATCodeBuilder<>(lookup, trxfmr.funcOp());\n+                    var javaCodeBuilder = new JavaCodeBuilder<>(lookup, trxfmr.funcOp());\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.codebuilders.JavaHATCodeBuilder;\n+import optkl.codebuilders.JavaCodeBuilder;\n@@ -67,1 +67,1 @@\n-        var javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,rsqrt);\n+        var javaCodeBuilder = new JavaCodeBuilder<>(lookup,rsqrt);\n@@ -90,1 +90,1 @@\n-        javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,abs);\n+        javaCodeBuilder = new JavaCodeBuilder<>(lookup,abs);\n@@ -110,1 +110,1 @@\n-        javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,newAbs);\n+        javaCodeBuilder = new JavaCodeBuilder<>(lookup,newAbs);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -67,0 +68,13 @@\n+\n+    public Trxfmr toText(String prefix, String suffix) {\n+        return run(trxfmr -> {\n+                    if (prefix != null && !prefix.isEmpty()){\n+                        System.out.println(prefix);\n+                    }\n+                    System.out.println(OpCodeBuilder.toText(trxfmr.funcOp()));\n+                    if (suffix != null && !suffix.isEmpty()){\n+                        System.out.println(suffix);\n+                    }\n+                }\n+        );\n+    }\n@@ -68,1 +82,1 @@\n-         return run(trxfmr -> System.out.println(OpCodeBuilder.toText(trxfmr.funcOp())));\n+        return toText(null, null);\n@@ -70,0 +84,4 @@\n+    public Trxfmr toText(String prefix) {\n+        return toText(prefix, null);\n+    }\n+\n@@ -79,1 +97,3 @@\n-        enum Action{NONE,REMOVED,REPLACE,ADDED };\n+\n+\n+        enum Action{NONE,RETAIN,REMOVED,REPLACE,ADDED };\n@@ -94,1 +114,0 @@\n-        Op.Result add(Op op, Consumer<Mapper<?>> mapperConsumer);\n@@ -98,1 +117,5 @@\n-\n+        Op.Result retain(Consumer<Mapper<?>> mapperConsumer);\n+        default Op.Result retain(){\n+            return retain(_->{});\n+        }\n+        Op.Result add(Op op, Consumer<Mapper<?>> mapperConsumer);\n@@ -192,0 +215,6 @@\n+                public Op.Result retain( Consumer<Mapper<?>> mapperConsumer) {\n+                    handled(true);\n+                    action(Action.RETAIN);\n+                    return trxfmr.opToResultOp(op(),builder().op(op()));\n+                }\n+                @Override\n@@ -275,0 +304,6 @@\n+    public Trxfmr when(boolean c,Consumer<Trxfmr> action){\n+        if (c) {\n+            run(action);\n+        }\n+        return this;\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":39,"deletions":4,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-\/* this should not be too C99 specific *\/\n-public interface BabylonCoreOpBuilder<T extends CodeBuilder<?>, SB extends CodeBuilderContext> {\n+\/* this should not be too C99 specific also cannot reference HAT Ops. *\/\n+public interface BabylonOpDispatcher<T extends JavaOrC99StyleCodeBuilder<T>, SB extends ScopedCodeBuilderContext> {\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/BabylonOpDispatcher.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/BabylonCoreOpBuilder.java","status":"renamed"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.codebuilders;\n+import jdk.incubator.code.dialect.java.ClassType;\n+\n+import java.util.function.Consumer;\n+\n+public  class C99CodeBuilder<T extends C99CodeBuilder<T>> extends JavaOrC99StyleCodeBuilder<T> {\n+\n+    public final T suffix_t(ClassType type){\n+        String name = type.toClassName();\n+        int dotIdx = name.lastIndexOf('.');\n+        int dollarIdx = name.lastIndexOf('$');\n+        int idx = Math.max(dotIdx, dollarIdx);\n+        if (idx > 0) {\n+            name = name.substring(idx + 1);\n+        }\n+        return suffix_t(name);\n+    }\n+\n+    public final T suffix_t(String name) {\n+        return identifier(name).identifier(\"_t\");\n+    }\n+\n+    public final T suffix_u(String name) {\n+        return identifier(name).identifier(\"_u\");\n+    }\n+\n+    public final T suffix_s(String name) {\n+        return identifier(name).identifier(\"_s\");\n+    }\n+\n+    public final T suffix_t(Class<?> klass) {\n+        return suffix_t(klass.getSimpleName());\n+    }\n+\n+    public final T suffix_u(Class<?> klass) {\n+        return suffix_u(klass.getSimpleName());\n+    }\n+\n+    public final T suffix_s(Class<?> klass) {\n+        return suffix_s(klass.getSimpleName());\n+    }\n+\n+    public final T structOrUnion(boolean isStruct) {\n+        return (isStruct ? structKeyword() : union());\n+    }\n+\n+    public final T typedefKeyword() {\n+        return keyword(\"typedef\");\n+    }\n+\n+    public final T structKeyword() {\n+        return keyword(\"struct\");\n+    }\n+\n+    public final T union() {\n+        return keyword(\"union\");\n+    }\n+\n+    public final T externC() {\n+        return externKeyword().space().dquote(\"C\");\n+    }\n+\n+    public final T hashDefineKeyword() {\n+        return hash().keyword(\"define\");\n+    }\n+\n+    public final T hashIfdefKeyword() {\n+        return hash().keyword(\"ifdef\");\n+    }\n+\n+    public final T hashIfndefKeyword() {\n+        return hash().keyword(\"ifndef\");\n+    }\n+\n+    public final T hashEndif() {\n+        return hash().keyword(\"endif\").nl();\n+    }\n+\n+    public final T hashIfdef(String value) {\n+        return hashIfdefKeyword().space().constant(value).nl();\n+    }\n+\n+    public final T hashIfndef(String value) {\n+        return hashIfndefKeyword().space().constant(value).nl();\n+    }\n+\n+    public final T hashIfdef(String value, Consumer<T> consumer) {\n+        return hashIfdef(value).accept(consumer).hashEndif();\n+    }\n+\n+    public final T hashIfndef(String value, Consumer<T> consumer) {\n+        return hashIfndef(value).accept(consumer).hashEndif();\n+    }\n+\n+    public final T pragmaKeyword() {\n+        return keyword(\"pragma\");\n+    }\n+\n+    public final T includeKeyword() {\n+        return keyword(\"include\");\n+    }\n+\n+    public final T hashDefine(String name, String... values) {\n+        hashDefineKeyword().space().identifier(name);\n+        for (String value : values) {\n+            space().constant(value);\n+        }\n+        return nl();\n+    }\n+\n+    public final T hashDefine(String name, Consumer<T> consumer) {\n+        hashDefineKeyword().space().identifier(name);\n+        space();\n+        consumer.accept(self());\n+        return nl();\n+    }\n+\n+    public final T pragma(String name, String... values) {\n+        hash().pragmaKeyword().space().identifier(name);\n+        for (String value : values) {\n+            space().constant(value);\n+        }\n+        return nl();\n+    }\n+\n+    public final T includeSys(String... values) {\n+        for (String value : values) {\n+            hash().includeKeyword().space().lt().identifier(value).gt().nl();\n+        }\n+        return self();\n+    }\n+\n+    public final T include(String... values) {\n+        for (String value : values) {\n+            hash().includeKeyword().space().dquote().identifier(value).dquote().nl();\n+        }\n+        return nl();\n+    }\n+\n+    public final T externKeyword() {\n+        return keyword(\"extern\");\n+    }\n+\n+    public final T u08Type() {\n+        return typeName(\"unsigned\").space().s08Type();\n+    }\n+\n+    public final T u08Type(String identifier) {\n+        return u08Type().space().identifier(identifier);\n+    }\n+\n+    public final T u08PtrType() {\n+        return u08Type().space().asterisk();\n+    }\n+\n+    public final T u08PtrType(String identifier) {\n+        return u08PtrType().identifier(identifier);\n+    }\n+\n+    public final T u32Type() {\n+        return typeName(\"unsigned\").space().s32Type();\n+    }\n+\n+    public final T u32Type(String identifier ) {\n+        return u32Type().space().identifier(identifier);\n+    }\n+\n+    public final T u64Type() {\n+        return typeName(\"unsigned\").space().s64Type();\n+    }\n+\n+    public final T u16Type() {\n+        return typeName(\"unsigned\").space().s16Type();\n+    }\n+\n+    public final T u16Type(String identifier) {\n+        return u16Type().space().identifier(identifier);\n+    }\n+\n+    public final T bfloat16Type(String identifier) {\n+        return suffix_t(\"BFLOAT16_UNION\").space().identifier(identifier);\n+    }\n+\n+    public final  T typedefStructOrUnion(boolean isStruct, Class<?> klass, Consumer<T> consumer) {\n+        return typedefKeyword()\n+                .space()\n+                .structOrUnion(isStruct)\n+                .space()\n+                .either(isStruct, _ -> suffix_s(klass), _ -> suffix_u(klass))\n+                .braceNlIndented(consumer)\n+                .suffix_t(klass).semicolonNl();\n+    }\n+\n+    public final T typedefStruct(String name, Consumer<T> consumer) {\n+        return typedefKeyword()\n+                .space()\n+                .structKeyword()\n+                .space()\n+                .suffix_s(name)\n+                .braceNlIndented(consumer)\n+                .suffix_t(name)\n+                .semicolonNl();\n+    }\n+\n+    public final T typedefUnion(String name, Consumer<T> consumer) {\n+        return typedefKeyword()\n+                .space()\n+                .union()\n+                .space()\n+                .suffix_s(name)\n+                .braceNlIndented(consumer)\n+                .suffix_t(name)\n+                .semicolonNl();\n+    }\n+\n+    public final T typedefStruct(Class<?>clazz, Consumer<T> consumer) {\n+        return typedefStruct(clazz.getSimpleName(), consumer);\n+    }\n+\n+    public final T typedefSingleValueStruct(String structName, String type) {\n+        return typedefStruct(structName,_-> typeName(type).space().identifier(\"value\").semicolon());\n+    }\n+\n+    public final T unionBfloat16() {\n+        return typedefUnion(\"BFLOAT16_UNION\", _ -> {\n+            typeName(\"float\").space().identifier(\"f\").semicolon().nl();\n+            u16Type(\"s\").sizeArray(2).semicolon();\n+        });\n+    }\n+\n+    public final T funcDef(Consumer<T> type, Consumer<T> name, Consumer<T> args, Consumer<T> body){\n+        type.accept(self());\n+        space();\n+        name.accept(self());\n+        paren(args);\n+        braceNlIndented(body);\n+        return nl();\n+    }\n+\n+\n+    public final T call(Consumer<T> name,Consumer<T> ...args) {\n+        name.accept(self());\n+        return paren(_->commaSpaceSeparated(args));\n+    }\n+\n+    public final T call(String name,Consumer<T> ...args) {\n+        return call(_->identifier(name),args);\n+    }\n+\n+\n+    public final T sizeof() {\n+        return emitText(\"sizeof\");\n+    }\n+\n+    public final T sizeof(String identifier) {\n+        return sizeof(_->identifier(identifier));\n+    }\n+\n+    public final T sizeof(Consumer<T> consumer) {\n+        return sizeof().paren(consumer);\n+    }\n+\n+    public final T voidPtrType() {\n+        return voidType().space().asterisk();\n+    }\n+\n+    public final T voidPtrType(String identifier) {\n+        return voidPtrType().identifier(identifier);\n+    }\n+\n+    public final T sizeType() {\n+        return typeName(\"size_t\");\n+    }\n+\n+    public final T sizeType(String identifier) {\n+        return sizeType().space().identifier(identifier);\n+    }\n+\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/C99CodeBuilder.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.codebuilders;\n+\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import optkl.OpHelper;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public class JavaCodeBuilder<T extends JavaCodeBuilder<T>> extends JavaOrC99StyleCodeBuilder<T> implements BabylonOpDispatcher<T,ScopedCodeBuilderContext> {\n+    public T createJava(ScopedCodeBuilderContext buildContext) {\n+        buildContext.funcScope(buildContext.funcOp, () -> {\n+            typeName(buildContext.funcOp.resultType().toString()).space().funcName(buildContext.funcOp);\n+            parenNlIndented(_ ->\n+                    commaNlSeparated(\n+                            buildContext.paramTable.list(),\n+                            param -> declareParam(buildContext, param)\n+                    )\n+            );\n+            braceNlIndented(_ -> nlSeparated(\n+                    OpHelper.Statement.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                    statement -> statement(buildContext, statement)\n+                    )\n+            );\n+        });\n+        return nl();\n+    }\n+    MethodHandles.Lookup lookup;\n+    CoreOp.FuncOp funcOp;\n+    public JavaCodeBuilder(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp){\n+        super();\n+        this.lookup=lookup;\n+        this.funcOp = funcOp;\n+    }\n+\n+    public String toText() {\n+        ScopedCodeBuilderContext scopedCodeBuilderContext= new ScopedCodeBuilderContext(lookup,funcOp);\n+        return createJava(scopedCodeBuilderContext).getText();\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaCodeBuilder.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,412 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.codebuilders;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.FuncOpParams;\n+import optkl.OpHelper;\n+import optkl.ParamVar;\n+import optkl.util.Regex;\n+import optkl.util.StreamMutable;\n+import optkl.util.ops.Precedence;\n+\n+import java.util.function.Consumer;\n+\n+import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Ternary.ternaryOpHelper;\n+\n+public class JavaOrC99StyleCodeBuilder<T extends JavaOrC99StyleCodeBuilder<T>> extends CodeBuilder<T>  implements BabylonOpDispatcher<T,ScopedCodeBuilderContext>{\n+\n+    public final T assign(Consumer<T> lhs, Consumer<T> rhs){\n+        lhs.accept(self());\n+        space().equals().space();\n+        rhs.accept(self());\n+        return self();\n+    }\n+\n+    public final T cast(Consumer<T> type){\n+        return paren(_-> type.accept(self()));\n+    }\n+\n+    public final T returnKeyword(Consumer<T> exp){\n+        return returnKeyword().space().paren(_-> exp.accept(self())).semicolon();\n+    }\n+    public final T forLoop(Consumer<T> init, Consumer<T> test, Consumer<T>mutate, Consumer<T>body) {\n+        return  forKeyword()\n+                .paren(_->{\n+                    init.accept(self());\n+                    semicolon().space();\n+                    test.accept(self());\n+                    semicolon().space();mutate.accept(self());\n+                })\n+                .braceNlIndented(body::accept);\n+    }\n+\n+    public final T literal(TypeElement typeElement, String string){\n+        if (typeElement.toString().equals(\"java.lang.String\")){\n+            dquote().escaped(string).dquote();\n+        }else{\n+            literal(string);\n+        }\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n+        return typeName(javaType.toString());\n+    }\n+\n+    \/\/\/ \/\n+\n+\n+    @Override\n+    public T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n+        varName((CoreOp.VarOp)resolve);\n+        return self();\n+    }\n+\n+    @Override\n+    public T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp) {\n+        Op op = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n+        varName((CoreOp.VarOp) op);\n+        equals().parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public final T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n+        if (varOp.isUninitialized()) {\n+            type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp);\n+        } else {\n+            if (buildContext.isVarOpFinal(varOp)) {\n+                constKeyword().space();\n+            }\n+            type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp).space().equals().space();\n+            parenthesisIfNeeded(buildContext, varOp, ((Op.Result)varOp.operands().getFirst()).op());\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, ParamVar paramVar) {\n+        varName(varOp);\n+        return self();\n+    }\n+\n+    @Override\n+    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldLoadOp);\n+        if (fieldAccess.operandCount()==0 && fieldAccess.isPrimitive() ) {\n+            literal(fieldAccess.getStaticFinalPrimitiveValue().toString());\n+        } else {\n+            literal(fieldAccess.getStaticFinalPrimitiveValue().toString());\n+            blockInlineComment(\"Non HAT friendly field load?\"+fieldAccess.name());\n+            \/\/throw new IllegalStateException(\"Where did this field come from ?\" + fieldLoadOp1);\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final T fieldStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp) {\n+        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldStoreOp);\n+        \/\/  throw new IllegalStateException(\"What is this field store ?\" + fieldStoreOp);\n+        blockInlineComment(\"Non HAT friendly field load? \"+fieldAccess.name());\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public final  T unaryOp(ScopedCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp) {\n+        symbol(unaryOp).parenthesisIfNeeded(buildContext, unaryOp, ((Op.Result)unaryOp.operands().getFirst()).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public final  T binaryOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp) {\n+        parenthesisIfNeeded(buildContext, binaryOp, OpHelper.lhsResult(binaryOp).op());\n+        symbol(binaryOp);\n+        parenthesisIfNeeded(buildContext, binaryOp, OpHelper.rhsResult(binaryOp).op());\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public final T conditionalOp(ScopedCodeBuilderContext buildContext, JavaOp.JavaConditionalOp logicalOp) {\n+        OpHelper.lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n+        space().symbol(logicalOp).space();\n+        OpHelper.rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n+        return self();\n+    }\n+\n+    @Override\n+    public final T binaryTestOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp) {\n+        parenthesisIfNeeded(buildContext, binaryTestOp, OpHelper.lhsResult(binaryTestOp).op());\n+        symbol(binaryTestOp);\n+        parenthesisIfNeeded(buildContext, binaryTestOp, OpHelper.rhsResult(binaryTestOp).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n+        \/\/ TODO: I think we need to work out how to handle doubles. If I remove this OpenCL on MAC complains (no FP64)\n+        if (convOp.resultType() == JavaType.DOUBLE) {\n+            paren(_ -> type(buildContext,JavaType.FLOAT)); \/\/ why double to float?\n+        } else {\n+            paren(_ -> type(buildContext,(JavaType)convOp.resultType()));\n+        }\n+        parenthesisIfNeeded(buildContext, convOp, ((Op.Result) convOp.operands().getFirst()).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public final T constantOp(ScopedCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp) {\n+        if (constantOp.value() == null) {\n+            nullConst();\n+        } else {\n+            literal(constantOp.resultType(),constantOp.value().toString());\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final  T yieldOp(ScopedCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp) {\n+        if (yieldOp.operands().getFirst() instanceof Op.Result result) {\n+            recurse(buildContext, result.op());\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp) {\n+\n+        return comment(\"\/* how to generate LAMBDA code! \/\");\n+    }\n+\n+    @Override\n+    public final  T tupleOp(ScopedCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp) {\n+        commaSpaceSeparated(tupleOp.operands(),operand->{\n+            if (operand instanceof Op.Result result) {\n+                recurse(buildContext, result.op());\n+            } else {\n+                throw new IllegalStateException(\"handle tuple\");\n+                \/\/comment(\"\/* nothing to tuple *\/\");\n+            }\n+        });\n+        return self();\n+    }\n+\n+    @Override\n+    public final T funcCallOp(ScopedCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp) {\n+        funcName(funcCallOp);\n+        paren(_ ->\n+                commaSpaceSeparated(\n+                        funcCallOp.operands().stream().filter(e->e instanceof Op.Result ).map(e->(Op.Result)e),\n+                        result -> recurse(buildContext,result.op())\n+                )\n+        );\n+        return self();\n+    }\n+\n+    @Override\n+    public final T labeledOp(ScopedCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp) {\n+        var labelNameOp = labeledOp.bodies().getFirst().entryBlock().ops().getFirst();\n+        CoreOp.ConstantOp constantOp = (CoreOp.ConstantOp) labelNameOp;\n+        literal(constantOp.value().toString()).colon().nl();\n+        var forLoopOp = labeledOp.bodies().getFirst().entryBlock().ops().get(1);\n+        recurse(buildContext,forLoopOp);\n+        return self();\n+    }\n+\n+    @Override\n+    public final T breakOp(ScopedCodeBuilderContext buildContext, JavaOp.BreakOp breakOp) {\n+        breakKeyword();\n+        if (!breakOp.operands().isEmpty() && breakOp.operands().getFirst() instanceof Op.Result result) {\n+            space();\n+            if (result.op() instanceof CoreOp.ConstantOp c) {\n+                literal(c.value().toString());\n+            }\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final T continueOp(ScopedCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp) {\n+        if (!continueOp.operands().isEmpty()\n+                && continueOp.operands().getFirst() instanceof Op.Result result\n+                && result.op() instanceof CoreOp.ConstantOp c\n+        ) {\n+            continueKeyword().space().literal(c.value().toString());\n+        } else if (buildContext.scope.parent instanceof ScopedCodeBuilderContext.ForScope) {\n+            \/\/ nope\n+        } else {\n+            continueKeyword();\n+        }\n+\n+        return self();\n+    }\n+\n+    @Override\n+    public final T ifOp(ScopedCodeBuilderContext buildContext, JavaOp.IfOp ifOp) {\n+        buildContext.ifScope(ifOp, () -> {\n+            var lastWasBody = StreamMutable.of(false);\n+            var i = StreamMutable.of(0);\n+            \/\/ We probably should just use a regular for loop here ;)\n+            ifOp.bodies().forEach(b->{\n+                int idx = i.get();\n+                if (b.yieldType() instanceof JavaType javaType && javaType == JavaType.VOID) {\n+                    if (ifOp.bodies().size() > idx && ifOp.bodies().get(idx).entryBlock().ops().size() > 1){\n+                        if (lastWasBody.get()) {\n+                            elseKeyword();\n+                        }\n+                        braceNlIndented(_ ->\n+                                nlSeparated(OpHelper.Statement.statements(ifOp.bodies().get(idx).entryBlock()),\n+                                        root-> statement(buildContext,root)\n+                                ));\n+                    }\n+                    lastWasBody.set(true);\n+                } else {\n+                    when(idx>0,_-> elseKeyword().space());\n+                    ifKeyword().paren(_ ->\n+                            ifOp.bodies().get(idx).entryBlock()            \/\/ get the entryblock if bodies[c.value]\n+                                    .ops().stream().filter(o->o instanceof CoreOp.YieldOp) \/\/ we want all the yields\n+                                    .forEach((yield) -> recurse(buildContext, yield))\n+                    );\n+                    lastWasBody.set(false);\n+                }\n+                i.set(i.get()+1);\n+            });\n+        });\n+        return self();\n+    }\n+\n+    @Override\n+    public final T whileOp(ScopedCodeBuilderContext buildContext, JavaOp.WhileOp whileOp) {\n+        whileKeyword().paren(_ ->\n+                OpHelper.entryBlockOfBodyN(whileOp, 0)\n+                        .ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n+                        .forEach(o -> recurse(buildContext, o))\n+        );\n+        braceNlIndented(_ ->\n+                nlSeparated(OpHelper.Statement.loopBodyStatements(whileOp),\n+                        statement->statement(buildContext,statement)\n+                )\n+        );\n+        return self();\n+    }\n+\n+    @Override\n+    public final T forOp(ScopedCodeBuilderContext buildContext, JavaOp.ForOp forOp) {\n+        buildContext.forScope(forOp, () ->\n+                forKeyword().paren(_ -> {\n+                    forOp.init().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+                    semicolon().space();\n+                    forOp.cond().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+                    semicolon().space();\n+                    commaSpaceSeparated(\n+                            OpHelper.Statement.statements(forOp.update().entryBlock()),\n+                            op -> recurse(buildContext, op)\n+                    );\n+                }).braceNlIndented(_ ->\n+                        nlSeparated(OpHelper.Statement.loopBodyStatements(forOp),\n+                                statement ->statement(buildContext,statement)\n+                        )\n+                )\n+        );\n+        return self();\n+    }\n+\n+    @Override\n+    public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n+        var invoke = invokeOpHelper(buildContext.lookup,invokeOp);\n+\n+            funcName(invoke.op()).paren(_ ->\n+                    commaSpaceSeparated(invoke.op().operands(),\n+                            op -> {if (op instanceof Op.Result result) {recurse(buildContext, result.op());}\n+                            })\n+            );\n+\n+        return self();\n+    }\n+\n+    @Override\n+    public final T conditionalExpressionOp(ScopedCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp) {\n+        OpHelper.Ternary ternary = ternaryOpHelper(buildContext.lookup,ternaryOp);\n+        ternary.condBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        questionMark();\n+        ternary.thenBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        colon();\n+        ternary.elseBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        return self();\n+    }\n+\n+    \/**\n+     * Wrap paren() of precedence of op is higher than parent.\n+     *\n+     * @param buildContext\n+     * @param parent\n+     * @param child\n+     *\/\n+    @Override\n+    public final  T parenthesisIfNeeded(ScopedCodeBuilderContext buildContext, Op parent, Op child) {\n+        return parenWhen(Precedence.needsParenthesis(parent,child), _ -> recurse(buildContext, child));\n+    }\n+\n+    @Override\n+    public final  T returnOp(ScopedCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp) {\n+        returnKeyword().when(!returnOp.operands().isEmpty(),\n+                $-> $.space().parenthesisIfNeeded(buildContext, returnOp, ((Op.Result) returnOp.operands().getFirst()).op())\n+        );\n+        return self();\n+    }\n+\n+    public final  T statement(ScopedCodeBuilderContext buildContext,Op op) {\n+        recurse(buildContext, op);\n+        if (switch (op){\n+            case JavaOp.ForOp _ -> false;\n+            case JavaOp.WhileOp _ -> false;\n+            case JavaOp.IfOp _ -> false;\n+            case JavaOp.LabeledOp _ -> false;\n+            case JavaOp.YieldOp _ -> false;\n+            case CoreOp.TupleOp _ ->false;\n+            default -> true;\n+        }\n+        ){\n+            semicolon();\n+        }\n+        return self();\n+    }\n+\n+    public final  T declareParam(ScopedCodeBuilderContext buildContext, FuncOpParams.Info param){\n+        return  type(buildContext,(JavaType) param.parameter.type()).space().varName(param.varOp);\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaOrC99StyleCodeBuilder.java","additions":412,"deletions":0,"binary":false,"changes":412,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.codebuilders.JavaHATCodeBuilder;\n+import optkl.codebuilders.JavaCodeBuilder;\n@@ -84,1 +84,1 @@\n-       var builder=  new JavaHATCodeBuilder(MethodHandles.lookup(),mandel);\n+       var builder=  new JavaCodeBuilder(MethodHandles.lookup(),mandel);\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/TestJavaHATCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}