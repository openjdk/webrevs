{"files":[{"patch":"@@ -481,1 +481,1 @@\n-                interpretBody(l, lambdaOp.body(), oc, List.of());\n+                interpretEntryBlock(l, lambdaOp.body().entryBlock(), oc, new HashMap<>());\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxPartialEvaluator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -212,0 +212,4 @@\n+                    } else if (opClass == ExplicitOnnxOps.Loop.class) {\n+                        \/\/ Explicit transformation of nested body\n+                        var lambda = (CoreOp.LambdaOp)(((Op.Result)op.operands().get(3)).op());\n+                        opArgs.add(lambda.body().transform(bb.context(), bodyTransformer(pe)));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,2 +204,3 @@\n-            M(TypeConstraint.I.typeVariable(), OnnxOp.OnnxParameter.Quantifier.OPTIONAL),\n-            cond(TypeConstraint.B.typeVariable(), OnnxOp.OnnxParameter.Quantifier.OPTIONAL),\n+            \/\/ @@@ Onnx spec declares the input parameters as optional, however it is causing problems\n+            M(TypeConstraint.I.typeVariable(), OnnxOp.OnnxParameter.Quantifier.REQUIRED),\n+            cond(TypeConstraint.B.typeVariable(), OnnxOp.OnnxParameter.Quantifier.REQUIRED),\n@@ -276,1 +277,1 @@\n-        Loop(TypeElement resultType, Optional<Value> m, Optional<Value> cond, List<Value> v_initial, Body.Builder body) {\n+        Loop(TypeElement resultType, Value m, Value cond, List<Value> v_initial, Body.Builder body) {\n@@ -317,1 +318,1 @@\n-    public static Loop OnnxLoop(TypeElement resultType, Optional<Value> m, Optional<Value> cond, List<Value> v_initial, Body.Builder body) {\n+    public static Loop Loop(TypeElement resultType, Value m, Value cond, List<Value> v_initial, Body.Builder body) {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/ExplicitOnnxOps.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -232,2 +232,2 @@\n-    public Tensor<Float> forLoopAdd(Tensor<Float> value, Tensor<Long> max) {\n-        return OnnxOperators.Loop(max, Tensor.ofScalar(true), List.of(value),\n+    public Tensor<Float> forLoopAdd(Tensor<Float> value, Tensor<Long> max, Tensor<Boolean> condition) {\n+        return OnnxOperators.Loop(max, condition, List.of(value),\n@@ -245,2 +245,3 @@\n-        assertEquals(expected, forLoopAdd(value, max));\n-\/\/        assertEquals(expected, OnnxRuntime.execute(() -> forLoopAdd(value, max)));\n+        var cond = Tensor.ofScalar(true);\n+        assertEquals(expected, forLoopAdd(value, max, cond));\n+\/\/        assertEquals(expected, OnnxRuntime.execute(() -> forLoopAdd(value, max, cond)));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}