{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.util.List;\n@@ -80,1 +81,1 @@\n-    public static <T> Tensor<T> If(Tensor<Boolean> cond, Supplier<Tensor<T>> elseBody, Supplier<Tensor<T>> thenBody) {\n+    public static <T> List<Tensor<T>> If(Tensor<Boolean> cond, Supplier<List<Tensor<T>>> elseBody, Supplier<List<Tensor<T>>> thenBody) {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,182 +0,0 @@\n-package oracle.code.onnx;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.Predicate;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.VarType;\n-import oracle.code.onnx.compiler.OnnxTransformer;\n-\n-public record LambdaToFunc(OnnxTransformer.OnnxFuncOp func, int[] operandsMapping) {\n-\n-    static final boolean DEBUG = Boolean.getBoolean(\"oracle.code.onnx.OnnxRuntime.DEBUG\");\n-\n-    public static LambdaToFunc fromLambda(MethodHandles.Lookup l, CoreOp.LambdaOp lambda, Map<Value, Object> evaluatedValues) {\n-        evaluatedValues = new HashMap<>(evaluatedValues);\n-        \/\/ Shortcut for lambda expressions that call just one method\n-        if (singleMethodInvocation(lambda) instanceof\n-                SingleMethod(CoreOp.InvokeOp iop, Map<Value, Value> valueMapping)) {\n-            Method m;\n-            try {\n-                m = iop.invokeDescriptor().resolveToMethod(l, iop.invokeKind());\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-\n-            var fOpt = Op.ofMethod(m);\n-            if (fOpt.isPresent()) {\n-                CoreOp.FuncOp f = Op.ofMethod(m).orElseThrow();\n-                var operands = iop.operands();\n-                var captured = lambda.capturedValues();\n-                var operandsMapping = new int[iop.operands().size()];\n-                var fParams = f.parameters();\n-                for (int i = 0; i < operandsMapping.length; i++) {\n-                    var opValue = valueMapping.get(operands.get(i));\n-                    operandsMapping[i] = captured.indexOf(opValue);\n-                    if (i == 0) {\n-                        var value = evaluatedValues.get(opValue);\n-                        if (value instanceof CoreOp.Var v) {\n-                            value = v.value();\n-                        }\n-                        if (value != null && !(value instanceof Tensor)) {\n-                            \/\/ @@@ probably a receiver\n-                            evaluatedValues.put(fParams.get(i), value);\n-                        }\n-                    }\n-                }\n-                if (DEBUG) {\n-                    System.out.println(f.toText());\n-                }\n-                OnnxTransformer.OnnxFuncOp onnxFunc = OnnxTransformer.transform(l, evaluatedValues, f);\n-                return new LambdaToFunc(onnxFunc, operandsMapping);\n-            }\n-        }\n-        var capturedValues = lambda.capturedValues();\n-        var functionType = FunctionType.functionType(lambda.invokableType().returnType(),\n-                capturedValues.stream().map(Value::type)\n-                        .map(t -> t instanceof VarType vt ? vt.valueType() : t).toList());\n-        CoreOp.FuncOp f = CoreOp.func(\"onnxCode\", functionType)\n-                .body(bb -> {\n-                    bb.context().mapValues(capturedValues, bb.parameters());\n-                    for (Op op : lambda.body().entryBlock().ops()) {\n-                        int i;\n-                        if (op instanceof CoreOp.VarAccessOp.VarLoadOp load &&\n-                                (i = capturedValues.indexOf(load.varOp().result())) >= 0) {\n-                            bb.context().mapValue(op.result(), bb.parameters().get(i)); \/\/ remap var load result to block param\n-                        } else {\n-                            bb.apply(op);\n-                        }\n-                    }\n-                });\n-        if (DEBUG) {\n-            System.out.println(f.toText());\n-        }\n-        OnnxTransformer.OnnxFuncOp onnxFunc = OnnxTransformer.transform(l, evaluatedValues, f);\n-\n-        var operandsMapping = new int[capturedValues.size()];\n-        for (int i = 0; i < operandsMapping.length; i++) {\n-            operandsMapping[i] = i;\n-        }\n-        return new LambdaToFunc(onnxFunc, operandsMapping);\n-    }\n-\n-    record SingleMethod(CoreOp.InvokeOp iop, Map<Value, Value> valueMapping) {}\n-    static SingleMethod singleMethodInvocation(CoreOp.LambdaOp lop) {\n-        \/\/ Single block\n-        if (lop.body().blocks().size() > 1) {\n-            return null;\n-        }\n-\n-        Map<Value, Value> valueMapping = new HashMap<>();\n-        CoreOp.InvokeOp methodRefInvokeOp = extractMethodInvoke(valueMapping, lop.body().entryBlock().ops());\n-        if (methodRefInvokeOp == null) {\n-            return null;\n-        }\n-\n-        return new SingleMethod(methodRefInvokeOp, valueMapping);\n-    }\n-\n-    static CoreOp.InvokeOp extractMethodInvoke(Map<Value, Value> valueMapping, List<Op> ops) {\n-        CoreOp.InvokeOp methodRefInvokeOp = null;\n-        for (Op op : ops) {\n-            switch (op) {\n-                case CoreOp.VarOp varOp -> {\n-                    if (isValueUsedWithOp(varOp.result(), o -> o instanceof CoreOp.VarAccessOp.VarStoreOp)) {\n-                        return null;\n-                    }\n-                }\n-                case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> {\n-                    Value v = varLoadOp.varOp().result();\n-                    valueMapping.put(varLoadOp.result(), valueMapping.getOrDefault(v, v));\n-                }\n-                case CoreOp.InvokeOp iop when isBoxOrUnboxInvocation(iop) -> {\n-                    Value v = iop.operands().getFirst();\n-                    valueMapping.put(iop.result(), valueMapping.getOrDefault(v, v));\n-                }\n-                case CoreOp.InvokeOp iop -> {\n-                    if (methodRefInvokeOp != null) {\n-                        return null;\n-                    }\n-\n-                    for (Value o : iop.operands()) {\n-                        valueMapping.put(o, valueMapping.getOrDefault(o, o));\n-                    }\n-                    methodRefInvokeOp = iop;\n-                }\n-                case CoreOp.ReturnOp rop -> {\n-                    if (methodRefInvokeOp == null) {\n-                        return null;\n-                    }\n-                    Value r = rop.returnValue();\n-                    if (!(valueMapping.getOrDefault(r, r) instanceof Op.Result invokeResult)) {\n-                        return null;\n-                    }\n-                    if (invokeResult.op() != methodRefInvokeOp) {\n-                        return null;\n-                    }\n-                    assert methodRefInvokeOp.result().uses().size() == 1;\n-                }\n-                default -> {\n-                    return null;\n-                }\n-            }\n-        }\n-\n-        return methodRefInvokeOp;\n-    }\n-\n-    private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n-        for (Op.Result user : value.uses()) {\n-            if (opPredicate.test(user.op())) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/\/ @@@ Move to functionality on JavaType(s)\n-    static final Set<String> UNBOX_NAMES = Set.of(\n-            \"byteValue\",\n-            \"shortValue\",\n-            \"charValue\",\n-            \"intValue\",\n-            \"longValue\",\n-            \"floatValue\",\n-            \"doubleValue\",\n-            \"booleanValue\");\n-\n-    private static boolean isBoxOrUnboxInvocation(CoreOp.InvokeOp iop) {\n-        MethodRef mr = iop.invokeDescriptor();\n-        return mr.refType() instanceof ClassType ct && ct.unbox().isPresent() &&\n-                (UNBOX_NAMES.contains(mr.name()) || mr.name().equals(\"valueOf\"));\n-    }\n-}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/LambdaToFunc.java","additions":0,"deletions":182,"binary":false,"changes":182,"status":"deleted"},{"patch":"@@ -57,2 +57,10 @@\n-                              .map(i -> (Tensor)(i instanceof Optional o ? o.get() : i))\n-                              .toList(),\n+                            .map(i -> i instanceof Optional o ? o.get() : i)\n+                            .mapMulti((i, ic) -> {\n+                                if (i instanceof List li) {\n+                                    li.forEach(ic);\n+                                } else {\n+                                    ic.accept(i);\n+                                }\n+                            })\n+                            .map(Tensor.class::cast)\n+                            .toList(),\n@@ -61,2 +69,7 @@\n-            if (outTensors.size() == 1) {\n-                return outTensors.getFirst();\n+            var outputs = schema.outputs();\n+            if (outputs.size() == 1) {\n+                if (outputs.getLast().quantifier() == OnnxOp.OnnxParameter.Quantifier.VARIADIC) {\n+                    return outTensors; \/\/ single variadic\n+                } else {\n+                    return outTensors.getFirst(); \/\/ single tensor\n+                }\n@@ -64,1 +77,11 @@\n-                return outTensors.toArray();\n+                \/\/ @@@ assuming only tail can be variadic\n+                if (outputs.getLast().quantifier() == OnnxOp.OnnxParameter.Quantifier.VARIADIC) {\n+                    var outArray = new Object[schema.outputs().size()];\n+                    for (int i = 0; i < outArray.length - 1; i++) {\n+                        outArray[i] = outputs.get(i);\n+                    }\n+                    outArray[outArray.length - 1] = outputs.subList(outArray.length - 1, outputs.size());\n+                    return outArray; \/\/ multiple tensors with variadic tail\n+                } else {\n+                    return outTensors.toArray(); \/\/ multiple tensors\n+                }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -11,0 +11,1 @@\n+import jdk.incubator.code.Op;\n@@ -13,0 +14,1 @@\n+import jdk.incubator.code.type.JavaType;\n@@ -353,2 +355,2 @@\n-        int first = params.size() - initializers.size();\n-        var args = params.isEmpty() || params.getFirst().type() instanceof OnnxType.TensorType ? params : params.subList(1, params.size());\n+        int firstInitializer = params.size() - initializers.size();\n+        var args = params.subList(params.isEmpty() || params.getFirst().type() instanceof OnnxType.TensorType ? 0 : 1, firstInitializer);\n@@ -356,1 +358,1 @@\n-                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.getName(params.get(i + first)), initializers.get(i))).toList(),\n+                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.getName(params.get(i + firstInitializer)), initializers.get(i))).toList(),\n@@ -375,1 +377,1 @@\n-                        case CoreOp.ReturnOp _ -> { \/\/ skip\n+                        case CoreOp.ReturnOp _, CoreOp.ConstantOp _ -> { \/\/ skip\n@@ -379,1 +381,12 @@\n-                        default ->\n+                        case CoreOp.InvokeOp io when io.invokeDescriptor().refType().equals(JavaType.type(List.class)) -> {\n+                            if (io.invokeDescriptor().name().equals(\"get\") && io.operands().getLast() instanceof Op.Result or && or.op() instanceof CoreOp.ConstantOp co && co.value() instanceof Integer i) {\n+                                indexer.put(io.result(), indexer.getName(io.operands().getFirst(), i));\n+                            } else if (io.invokeDescriptor().name().equals(\"of\")) {\n+                                for (int i = 0; i < io.operands().size(); i++) {\n+                                    indexer.put(io.result(),  indexer.getName(io.operands().get(i), i));\n+                                }\n+                            } else {\n+                                throw new UnsupportedOperationException(op.toText());\n+                            }\n+                        }\n+                        default -> {\n@@ -381,0 +394,1 @@\n+                        }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+import oracle.code.onnx.compiler.OnnxTransformer;\n@@ -53,3 +54,1 @@\n-    record CachedSession(Session session, int[] operandsMapping) {}\n-\n-    static class CachedSessionClassValue extends ClassValue<CachedSession> {\n+    static class CachedSessionClassValue extends ClassValue<Session> {\n@@ -60,1 +59,1 @@\n-        CachedSession computeIfAbsent(Class<?> lambdaClass, MethodHandles.Lookup l,  Quoted q) {\n+        Session computeIfAbsent(Class<?> lambdaClass, MethodHandles.Lookup l,  Quoted q) {\n@@ -72,3 +71,7 @@\n-        @Override\n-        protected CachedSession computeValue(Class<?> type) {\n-            var mf = LambdaToFunc.fromLambda(l, (CoreOp.LambdaOp)q.op(), q.capturedValues());\n+        \/\/ @@@ heuristic assumption the first non-tensor and non-varbox captured value is receiver\n+        private static Object getReceiver(SequencedCollection<Object> values) {\n+            for (var v : values) {\n+                if (!(v instanceof Tensor || v instanceof CoreOp.Var)) return v;\n+            }\n+            return null;\n+        }\n@@ -76,2 +79,5 @@\n-            List<Tensor> initializers = mf.func().initializers().stream().map(val -> (Tensor) val).toList();\n-            byte[] protobufModel = OnnxProtoBuilder.build(mf.func().func().body().entryBlock(), initializers);\n+        @Override\n+        protected Session computeValue(Class<?> type) {\n+            var trans = OnnxTransformer.ofLambda(l, (CoreOp.LambdaOp)q.op());\n+            var func = trans.transform();\n+            byte[] protobufModel = OnnxProtoBuilder.build(func.body().entryBlock(), trans.initializers(getReceiver(q.capturedValues().sequencedValues())));\n@@ -80,1 +86,1 @@\n-                System.out.println(mf.func().func().toText());\n+                System.out.println(func.toText());\n@@ -88,1 +94,1 @@\n-            return new CachedSession(getInstance().createSession(\n+            return getInstance().createSession(\n@@ -90,1 +96,2 @@\n-                    protobufModel), mf.operandsMapping());\n+                    protobufModel);\n+\n@@ -96,0 +103,4 @@\n+    public static <T> Tensor<T> execute(OnnxFunction<Tensor<T>> codeLambda) {\n+        return execute(MethodHandles.lookup(), codeLambda);\n+    }\n+\n@@ -106,3 +117,1 @@\n-        var captured = q.capturedValues().sequencedValues().toArray();\n-        List<Tensor> arguments = IntStream.of(model.operandsMapping())\n-                .mapToObj(i -> captured[i])\n+        List<Tensor> arguments = q.capturedValues().sequencedValues().stream()\n@@ -116,2 +125,1 @@\n-\n-        return model.session.run(arena, arguments).getFirst();\n+        return model.run(arena, arguments).getFirst();\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import oracle.code.onnx.Tensor;\n@@ -46,1 +45,1 @@\n-    static final TypeElement TENSOR_RAW_CLASS = JavaType.type(Tensor.class);\n+    static final JavaType LIST_CLASS = JavaType.type(List.class);\n@@ -49,1 +48,1 @@\n-    Map<CoreOp.InvokeOp, List<Object>> evaluatedAttributes;\n+    final Map<CoreOp.InvokeOp, List<Object>> evaluatedAttributes;\n@@ -53,3 +52,1 @@\n-    Set<Op> unevaluatedOperations;\n-\n-    List<Object> initializers;\n+    final Set<Op> unevaluatedOperations;\n@@ -60,1 +57,0 @@\n-        this.initializers = new ArrayList<>();\n@@ -64,2 +60,2 @@\n-    void evaluate(MethodHandles.Lookup l, T op, Map<Value, Object> evaluatedValues) {\n-        var ev = new HashMap(evaluatedValues);\n+    void evaluate(MethodHandles.Lookup l, T op) {\n+        var ev = new HashMap();\n@@ -209,2 +205,2 @@\n-        assert yieldContext == null ||\n-                yieldContext.b().parentBody() == entry.parentBody().parentOp().ancestorBody();\n+\/\/        assert yieldContext == null ||\n+\/\/                yieldContext.b().parentBody() == entry.parentBody().parentOp().ancestorBody();\n@@ -310,1 +306,1 @@\n-\/\/            assert o.operands().subList(0, inputs.size()).stream().noneMatch(oc::isValueDefined);\n+            assert o.operands().subList(0, inputs.size()).stream().noneMatch(oc::isValueDefined);\n@@ -324,6 +320,0 @@\n-            } else if (opClass == ExplicitOnnxOps.If.class) {\n-                \/\/ @@@ hard-coded 2 extra undeclared attributes\n-                List<Object> attrs = o.operands().subList(inputs.size(), inputs.size() + 2).stream()\n-                        .map(oc::getValue)\n-                        .toList();\n-                evaluatedAttributes.put(io, attrs);\n@@ -342,10 +332,2 @@\n-        } else if (o instanceof CoreOp.FieldAccessOp.FieldLoadOp fo && fo.fieldDescriptor().type() instanceof ClassType ct && ct.rawType().equals(TENSOR_RAW_CLASS)) {\n-            try {\n-                if (fo.operands().isEmpty()) {\n-                    initializers.add(fo.fieldDescriptor().resolveToHandle(l).get());\n-                } else {\n-                    initializers.add(fo.fieldDescriptor().resolveToHandle(l).get(oc.getValue(fo.operands().getFirst())));\n-                }\n-            } catch (ReflectiveOperationException ex) {\n-                throw interpreterException(ex);\n-            }\n+        } else if (o instanceof CoreOp.InvokeOp io && io.invokeDescriptor().refType().equals(LIST_CLASS) && io.invokeDescriptor().name().equals(\"get\")) {\n+            evaluatedAttributes.put(io, List.of(oc.getValue(io.operands().getLast())));\n@@ -499,1 +481,3 @@\n-                return lambdaOp;\n+                interpretBody(l, lambdaOp.body(), oc, List.of());\n+                unevaluatedOperations.add(o);\n+                return null;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxPartialEvaluator.java","additions":13,"deletions":29,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -3,3 +3,6 @@\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.incubator.code.*;\n@@ -10,1 +13,0 @@\n-import oracle.code.onnx.OnnxRuntime;\n@@ -15,8 +17,0 @@\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.*;\n-import java.util.*;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import jdk.incubator.code.*;\n-import oracle.code.onnx.LambdaToFunc;\n@@ -30,1 +24,54 @@\n-    private OnnxTransformer() {\n+\n+    static final JavaType TENSOR_CLASS = JavaType.type(Tensor.class);\n+    static final JavaType LIST_CLASS = JavaType.type(List.class);\n+\n+    private final MethodHandles.Lookup l;\n+    private final CoreOp.FuncOp inputFunc;\n+    private final List<FieldRef> inits;\n+\n+    public static OnnxTransformer ofLambda(MethodHandles.Lookup lookup, CoreOp.LambdaOp lambda) {\n+        var lambdaFunc = (CoreOp.FuncOp)lambda.ancestorBody().parentOp().ancestorBody().parentOp();\n+        var flatLambdaFunc = lambdaFunc.transform((bb, op) -> {\n+            switch (op) {\n+                case CoreOp.QuotedOp qo -> {\n+                    bb.context().mapValues(lambdaFunc.parameters(), bb.parameters());\n+                    bb.transformBody(lambda.body(), List.of(), OpTransformer.COPYING_TRANSFORMER);\n+                }\n+                case CoreOp.ReturnOp _ -> {}\n+                default -> bb.op(op);\n+            }\n+            return bb;\n+        });\n+        return new OnnxTransformer(lookup, flatLambdaFunc);\n+    }\n+\n+    public OnnxTransformer(MethodHandles.Lookup lookup, CoreOp.FuncOp func) {\n+        l = lookup;\n+\n+        var inlinedFunc = func.transform((bb, op) -> {\n+            var cc  = bb.context();\n+            switch (op) {\n+                case CoreOp.InvokeOp io when resolve(io) instanceof CoreOp.FuncOp inline ->\n+                    bb.inline(inline, cc.getValues(io.operands()), (_, v) -> cc.mapValue(io.result(), v));\n+                default ->\n+                    bb.apply(op);\n+            }\n+            return bb;\n+        });\n+\n+        inits = new ArrayList<>();\n+        var top = new Block.Builder[1];\n+        \/\/ turning field loads into additiona arguments\n+        inputFunc = inlinedFunc.transform((bb, op) -> {\n+            if (top[0] == null) top[0] = bb;\n+            var cc  = bb.context();\n+            switch (op) {\n+                case CoreOp.FieldAccessOp.FieldLoadOp flo when op.resultType() instanceof ClassType ct && ct.rawType().equals(TENSOR_CLASS) -> {\n+                    inits.add(flo.fieldDescriptor());\n+                    \/\/ initializers turn into top block parameters\n+                    cc.mapValue(op.result(), top[0].parameter(op.resultType()));\n+                }\n+                default -> bb.apply(op);\n+            }\n+            return bb;\n+        });\n@@ -33,1 +80,21 @@\n-    public record OnnxFuncOp(CoreOp.FuncOp func, List<Object> initializers) {}\n+    CoreOp.FuncOp resolve(CoreOp.InvokeOp io) {\n+        try {\n+            var res = Op.ofMethod(io.invokeDescriptor().resolveToDirectMethod(l));\n+            if (res.isPresent()) {\n+                return SSA.transform(res.get());\n+            }\n+        } catch (ReflectiveOperationException _) {}\n+        return null;\n+    }\n+\n+    public List<Tensor> initializers(Object receiver) {\n+        return inits.stream().map(i -> {\n+            try {\n+                return (Tensor)i.resolveToHandle(l).get(receiver);\n+            } catch (ReflectiveOperationException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }).toList();\n+    }\n+\n+    public CoreOp.FuncOp transform() {\n@@ -35,1 +102,0 @@\n-    public static OnnxFuncOp transform(MethodHandles.Lookup l, Map<Value, Object> evaluatedValues, CoreOp.FuncOp in) {\n@@ -37,1 +103,1 @@\n-        pe.evaluate(l, in, evaluatedValues);\n+        pe.evaluate(l, inputFunc);\n@@ -39,3 +105,2 @@\n-        FunctionType ft = FunctionType.functionType(\n-                type(in.invokableType().returnType()),\n-                in.invokableType().parameterTypes().stream().map(OnnxTransformer::type).toList()\n+        FunctionType ft = FunctionType.functionType(type(inputFunc.invokableType().returnType()),\n+                inputFunc.invokableType().parameterTypes().stream().map(OnnxTransformer::type).toList()\n@@ -43,30 +108,3 @@\n-        CoreOp.FuncOp onnxModel = CoreOp.func(in.funcName(), ft).body(b -> {\n-            b.transformBody(in.body(), b.parameters(), (bb, op) -> {\n-                if (!pe.unevaluatedOperations.contains(op)) {\n-                    return bb;\n-                }\n-                switch (op) {\n-                    \/\/ Transform invocation to ONNX operator to operation modeling the operator\n-                    case CoreOp.InvokeOp io when io.invokeDescriptor().refType().equals(ONNX_OPERATORS_CLASS) -> {\n-                        String operatorName = io.invokeDescriptor().name();\n-                        Class<? extends OnnxOp> opClass = onnxOpClassFromName(operatorName);\n-                        OnnxOp.OnnxSchema schema = schemaFromOnnxOpClass(opClass);\n-\n-                        List<Object> attributes = pe.evaluatedAttributes.get(io);\n-\n-                        Method opMethod = Stream.of(OnnxOps.class.getMethods())\n-                                .filter(m -> m.getName().equals(operatorName))\n-                                .findFirst().orElseThrow();\n-\n-                        List<Object> opArgs = new ArrayList<>();\n-\n-                        \/\/ @@@ Operator API currently requires all optional output parameters are required\n-                        if (schema.outputs().stream().anyMatch(p -> p.quantifier().isOptional())) {\n-                            opArgs.add(recordTypeToTupleType(l, (ClassType) op.resultType()));\n-                            Set<? extends OnnxOp.OnnxParameter> optionalOutputs = schema.outputs().stream()\n-                                    .filter(p -> p.quantifier().isOptional())\n-                                    .collect(Collectors.toSet());\n-                            opArgs.add(optionalOutputs);\n-                        } else {\n-                            opArgs.add(type(op.resultType()));\n-                        }\n+        CoreOp.FuncOp onnxModel = CoreOp.func(inputFunc.funcName(), ft).body(b -> {\n+            b.transformBody(inputFunc.body(), b.parameters(), bodyTransformer(pe));\n+        });\n@@ -74,3 +112,1 @@\n-                        for (int i = 0; i < schema.inputs().size(); i++) {\n-                            OnnxOp.OnnxParameter p = schema.inputs().get(i);\n-                            Value v = io.operands().get(i);\n+        var paramTypes = onnxModel.invokableType().parameterTypes();\n@@ -78,16 +114,68 @@\n-                            switch (p.quantifier()) {\n-                                case REQUIRED -> {\n-                                    opArgs.add(bb.context().getValue(v));\n-                                }\n-                                case OPTIONAL -> {\n-                                    \/\/ Evaluation of expressions Optional.empty and Optional.of() with symbolic values\n-                                    if (v instanceof Op.Result r && r.op() instanceof CoreOp.InvokeOp optionalInvoke\n-                                            && optionalInvoke.invokeDescriptor().refType().equals(JavaType.type(Optional.class))) {\n-                                        switch (optionalInvoke.invokeDescriptor().name()) {\n-                                            case \"of\" -> {\n-                                                opArgs.add(Optional.of(bb.context().getValue(optionalInvoke.operands().getFirst())));\n-                                            }\n-                                            case \"empty\" -> {\n-                                                opArgs.add(Optional.empty());\n-                                            }\n-                                            default -> throw new UnsupportedOperationException();\n+        CoreOp.FuncOp cutModel = onnxModel;\n+        if (!paramTypes.isEmpty() && !(paramTypes.getFirst() instanceof OnnxType.TensorType)) {\n+            \/\/ drop receiver\n+            var funcType = FunctionType.functionType(onnxModel.invokableType().returnType(), paramTypes.subList(1, paramTypes.size()));\n+            cutModel = CoreOp.func(onnxModel.funcName(), funcType).body(bb -> {\n+                bb.context().mapValues(onnxModel.parameters().subList(1, paramTypes.size()), bb.parameters());\n+                bb.transformBody(onnxModel.body(), List.of(), OpTransformer.COPYING_TRANSFORMER);\n+            });\n+        }\n+\n+        return SSA.transform(cutModel).transform((b, op) -> {\n+            \/\/ Drop any non-terminating operation whose result is not used\n+            if (op instanceof Op.Terminating || !op.result().uses().isEmpty()) {\n+                b.op(op);\n+            }\n+            return b;\n+        });\n+    }\n+\n+    OpTransformer bodyTransformer(OnnxPartialEvaluator pe) {\n+        return (bb, op) -> {\n+            if (!pe.unevaluatedOperations.contains(op)) {\n+                return bb;\n+            }\n+            switch (op) {\n+                \/\/ Transform invocation to ONNX operator to operation modeling the operator\n+                case CoreOp.InvokeOp io when io.invokeDescriptor().refType().equals(ONNX_OPERATORS_CLASS) -> {\n+                    String operatorName = io.invokeDescriptor().name();\n+                    Class<? extends OnnxOp> opClass = onnxOpClassFromName(operatorName);\n+                    OnnxOp.OnnxSchema schema = schemaFromOnnxOpClass(opClass);\n+\n+                    List<Object> attributes = pe.evaluatedAttributes.get(io);\n+\n+                    Method opMethod = Stream.of(OnnxOps.class.getMethods())\n+                            .filter(m -> m.getName().equals(operatorName))\n+                            .findFirst().orElseThrow();\n+\n+                    List<Object> opArgs = new ArrayList<>();\n+\n+                    \/\/ @@@ Operator API currently requires all optional output parameters are required\n+                    if (schema.outputs().stream().anyMatch(p -> p.quantifier().isOptional())) {\n+                        opArgs.add(recordTypeToTupleType(l, (ClassType) op.resultType()));\n+                        Set<? extends OnnxOp.OnnxParameter> optionalOutputs = schema.outputs().stream()\n+                                .filter(p -> p.quantifier().isOptional())\n+                                .collect(Collectors.toSet());\n+                        opArgs.add(optionalOutputs);\n+                    } else {\n+                        opArgs.add(type(op.resultType()));\n+                    }\n+\n+                    for (int i = 0; i < schema.inputs().size(); i++) {\n+                        OnnxOp.OnnxParameter p = schema.inputs().get(i);\n+                        Value v = io.operands().get(i);\n+\n+                        switch (p.quantifier()) {\n+                            case REQUIRED -> {\n+                                opArgs.add(bb.context().getValue(v));\n+                            }\n+                            case OPTIONAL -> {\n+                                \/\/ Evaluation of expressions Optional.empty and Optional.of() with symbolic values\n+                                if (v instanceof Op.Result r && r.op() instanceof CoreOp.InvokeOp optionalInvoke\n+                                        && optionalInvoke.invokeDescriptor().refType().equals(JavaType.type(Optional.class))) {\n+                                    switch (optionalInvoke.invokeDescriptor().name()) {\n+                                        case \"of\" -> {\n+                                            opArgs.add(Optional.of(bb.context().getValue(optionalInvoke.operands().getFirst())));\n+                                        }\n+                                        case \"empty\" -> {\n+                                            opArgs.add(Optional.empty());\n@@ -95,2 +183,1 @@\n-                                    } else {\n-                                        throw new UnsupportedOperationException();\n+                                        default -> throw new UnsupportedOperationException();\n@@ -98,2 +185,1 @@\n-                                }\n-                                case VARIADIC -> {\n+                                } else {\n@@ -103,12 +189,12 @@\n-                        }\n-                        opArgs.addAll(attributes.stream().map(a -> {\n-                            if (a instanceof CoreOp.LambdaOp lo) {\n-                                var ltf = LambdaToFunc.fromLambda(l, lo, evaluatedValues);\n-                                var cc = bb.context();\n-                                var lbb = Body.Builder.of(bb.parentBody(), lo.invokableType(), cc);\n-                                var eb = lbb.entryBlock();\n-                                var params = ltf.func().func().body().entryBlock().parameters();\n-                                var captured = lo.capturedValues();\n-                                for (int i = 0; i < params.size(); i++) {\n-                                    var param = params.get(i);\n-                                    cc.mapValue(param, eb.op(OnnxOps.Identity(param.type(), cc.getValue(traverseUp(captured.get(i))))));\n+                            case VARIADIC -> {\n+                                \/\/ Evaluation of expressions List.of() with symbolic values\n+                                if (v instanceof Op.Result r && r.op() instanceof CoreOp.InvokeOp listInvoke\n+                                        && listInvoke.invokeDescriptor().refType().equals(JavaType.type(List.class))) {\n+                                    switch (listInvoke.invokeDescriptor().name()) {\n+                                        case \"of\" -> {\n+                                            opArgs.add(listInvoke.operands().stream().map(o -> bb.context().getValue(o)).toList());\n+                                        }\n+                                        default -> throw new UnsupportedOperationException();\n+                                    }\n+                                } else {\n+                                    throw new UnsupportedOperationException();\n@@ -116,2 +202,0 @@\n-                                ltf.func().func().body().entryBlock().ops().forEach(eb::apply);\n-                                return lbb;\n@@ -119,8 +203,0 @@\n-                            return a;\n-                        }).toList());\n-\n-                        OnnxOp onnxOp;\n-                        try {\n-                            onnxOp = (OnnxOp) opMethod.invoke(null, opArgs.toArray());\n-                        } catch (ReflectiveOperationException | RuntimeException e) {\n-                            throw new RuntimeException(e);\n@@ -128,2 +204,0 @@\n-                        Op.Result result = bb.op(onnxOp);\n-                        bb.context().mapValue(io.result(), result);\n@@ -131,5 +205,7 @@\n-                    \/\/ Transform access to the result of an operator that is a record access\n-                    case CoreOp.InvokeOp io when\n-                            recordComponentAccessToTupleIndex(l, io.invokeDescriptor()) instanceof Integer index -> {\n-                        Op.Result result = bb.op(CoreOp.tupleLoad(bb.context().getValue(io.operands().getFirst()), index));\n-                        bb.context().mapValue(io.result(), result);\n+                    opArgs.addAll(attributes);\n+                    if (opClass == ExplicitOnnxOps.If.class) {\n+                        \/\/ Explicit transformation of nested bodies\n+                        for (int i = 1; i < 3; i++) {\n+                            var lambda = (CoreOp.LambdaOp)(((Op.Result)op.operands().get(i)).op());\n+                            opArgs.add(lambda.body().transform(bb.context(), bodyTransformer(pe)));\n+                        }\n@@ -137,2 +213,5 @@\n-                    case CoreOp.FieldAccessOp.FieldLoadOp fo when fo.fieldDescriptor().type() instanceof ClassType ct && ct.rawType().equals(TENSOR_RAW_CLASS) -> {\n-                        bb.context().mapValue(fo.result(), b.parameter(type(fo.resultType())));\n+                    OnnxOp onnxOp;\n+                    try {\n+                        onnxOp = (OnnxOp) opMethod.invoke(null, opArgs.toArray());\n+                    } catch (ReflectiveOperationException | RuntimeException e) {\n+                        throw new RuntimeException(e);\n@@ -140,2 +219,2 @@\n-                    \/\/ Copy remaining operations, which may be removed later transformations\n-                    default -> bb.op(op);\n+                    Op.Result result = bb.op(onnxOp);\n+                    bb.context().mapValue(io.result(), result);\n@@ -143,8 +222,20 @@\n-                return bb;\n-            });\n-        });\n-\n-        return new OnnxFuncOp(SSA.transform(onnxModel).transform((b, op) -> {\n-            \/\/ Drop any non-terminating operation whose result is not used\n-            if (op instanceof Op.Terminating || !op.result().uses().isEmpty()) {\n-                b.op(op);\n+                \/\/ Transform access to the result of an operator that is a record access\n+                case CoreOp.InvokeOp io when\n+                        recordComponentAccessToTupleIndex(l, io.invokeDescriptor()) instanceof Integer index -> {\n+                    Op.Result result = bb.op(CoreOp.tupleLoad(bb.context().getValue(io.operands().getFirst()), index));\n+                    bb.context().mapValue(io.result(), result);\n+                }\n+                \/\/ Transform access to the result of an operator that is a list access\n+                \/\/ @@@ raw use of List::get with constant argument\n+                case CoreOp.InvokeOp io when io.invokeDescriptor().refType().equals(LIST_CLASS) && io.invokeDescriptor().name().equals(\"get\") -> {\n+                    Op.Result result = bb.op(CoreOp.invoke(\n+                            io.invokeDescriptor(),\n+                            bb.context().getValue(io.operands().getFirst()),\n+                            bb.op(CoreOp.constant(JavaType.INT, pe.evaluatedAttributes.get(io).getLast()))));\n+                    bb.context().mapValue(io.result(), result);\n+                }\n+                \/\/ Skip nested lambdas\n+                case CoreOp.LambdaOp _ -> {\n+                }\n+                \/\/ Copy remaining operations, which may be removed later transformations\n+                default -> bb.op(op);\n@@ -152,7 +243,2 @@\n-            return b;\n-        }), pe.initializers);\n-    }\n-\n-    static Value traverseUp(Value v) {\n-        \/\/ @@@ when captured value is a VaroOp\n-        return v instanceof Op.Result or && or.op() instanceof CoreOp.VarOp vo && !vo.isUninitialized()? vo.initOperand() : v;\n+            return bb;\n+        };\n@@ -163,1 +249,0 @@\n-        Class<? extends OnnxOp> opClass;\n@@ -265,1 +350,0 @@\n-\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":206,"deletions":122,"binary":false,"changes":328,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import oracle.code.onnx.compiler.OnnxTransformer;\n@@ -49,1 +48,0 @@\n-import java.util.HashMap;\n@@ -51,0 +49,1 @@\n+import oracle.code.onnx.compiler.OnnxTransformer;\n@@ -326,2 +325,2 @@\n-            var onnxModel = OnnxTransformer.transform(MethodHandles.lookup(), new HashMap<>(), f);\n-            System.out.println(onnxModel.func().toText());\n+            var onnxModel = new OnnxTransformer(MethodHandles.lookup(), f).transform();\n+            System.out.println(onnxModel.toText());\n@@ -332,1 +331,1 @@\n-            Assertions.assertEquals(serialize(expectedOnnxModel), serialize(onnxModel.func()));\n+            Assertions.assertEquals(serialize(expectedOnnxModel), serialize(onnxModel));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-import java.lang.invoke.MethodHandles;\n+import java.util.List;\n@@ -22,1 +22,1 @@\n-                OnnxRuntime.execute(MethodHandles.lookup(), () -> add(a, a)));\n+                OnnxRuntime.execute(() -> add(a, a)));\n@@ -36,1 +36,1 @@\n-                OnnxRuntime.execute(MethodHandles.lookup(), () -> sub(a, b)));\n+                OnnxRuntime.execute(() -> sub(a, b)));\n@@ -49,1 +49,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(MethodHandles.lookup(), () -> fconstant()));\n+        assertEquals(expected, OnnxRuntime.execute(() -> fconstant()));\n@@ -62,1 +62,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(MethodHandles.lookup(), () -> fconstants()));\n+        assertEquals(expected, OnnxRuntime.execute(() -> fconstants()));\n@@ -75,1 +75,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(MethodHandles.lookup(), () -> lconstant()));\n+        assertEquals(expected, OnnxRuntime.execute(() -> lconstant()));\n@@ -88,1 +88,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(MethodHandles.lookup(), () -> lconstants()));\n+        assertEquals(expected, OnnxRuntime.execute(() -> lconstants()));\n@@ -102,1 +102,1 @@\n-                OnnxRuntime.execute(MethodHandles.lookup(), () -> reshapeAndShape(data, shape)));\n+                OnnxRuntime.execute(() -> reshapeAndShape(data, shape)));\n@@ -116,1 +116,29 @@\n-                OnnxRuntime.execute(MethodHandles.lookup(), () -> indicesOfMaxPool(x)));\n+                OnnxRuntime.execute(() -> indicesOfMaxPool(x)));\n+    }\n+\n+    @CodeReflection\n+    public Tensor<Float> concat(Tensor<Float> input1, Tensor<Float> input2, long axis) {\n+        return OnnxOperators.Concat(List.of(input1, input2), axis);\n+    }\n+\n+    @Test\n+    public void testConcat() throws Exception {\n+        var input1 = Tensor.ofFlat(1f, 2, 3);\n+        var input2 = Tensor.ofFlat(4f, 5);\n+        assertEquals(\n+                concat(input1, input2, 0),\n+                OnnxRuntime.execute(()-> concat(input1, input2, 0)));\n+    }\n+\n+    @CodeReflection\n+    public Tensor<Float> split(Tensor<Float> input, Tensor<Long> split) {\n+        return OnnxOperators.Split(input, Optional.of(split), Optional.empty(), Optional.empty()).get(0);\n+    }\n+\n+    @Test\n+    public void testSplit() throws Exception {\n+        var input = Tensor.ofFlat(1f, 2, 3, 4, 5);\n+        var split = Tensor.ofFlat(5l);\n+        assertEquals(\n+                split(input, split),\n+                OnnxRuntime.execute(()-> split(input, split)));\n@@ -121,1 +149,1 @@\n-        return OnnxOperators.If(cond, () -> OnnxOperators.Constant(-1f), () -> OnnxOperators.Constant(1f));\n+        return OnnxOperators.If(cond, () -> List.of(OnnxOperators.Constant(-1f)), () -> List.of(OnnxOperators.Constant(1f))).get(0);\n@@ -132,1 +160,1 @@\n-        assertEquals(expFalse, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifConst(condFalse)));\n+        assertEquals(expFalse, OnnxRuntime.execute(() -> ifConst(condFalse)));\n@@ -135,1 +163,1 @@\n-        assertEquals(expTrue, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifConst(condTrue)));\n+        assertEquals(expTrue, OnnxRuntime.execute(() -> ifConst(condTrue)));\n@@ -141,1 +169,1 @@\n-        return OnnxOperators.If(cond, () -> OnnxOperators.Identity(falseValue), () -> trueValue);\n+        return OnnxOperators.If(cond, () -> List.of(OnnxOperators.Identity(falseValue)), () -> List.of(OnnxOperators.Identity(trueValue))).get(0);\n@@ -152,1 +180,1 @@\n-        assertEquals(expFalse, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifCapture(condFalse, expTrue)));\n+        assertEquals(expFalse, OnnxRuntime.execute(() -> ifCapture(condFalse, expTrue)));\n@@ -155,1 +183,1 @@\n-        assertEquals(expTrue, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifCapture(condTrue, expTrue)));\n+        assertEquals(expTrue, OnnxRuntime.execute(() -> ifCapture(condTrue, expTrue)));\n@@ -169,1 +197,32 @@\n-                     OnnxRuntime.execute(MethodHandles.lookup(), () -> initialized()));\n+                     OnnxRuntime.execute(() -> initialized()));\n+    }\n+\n+    final Tensor<Float> initialized2 = Tensor.ofFlat(33f);\n+    final Tensor<Float> initialized3 = Tensor.ofFlat(-1f);\n+    final Tensor<Float> initialized4 = Tensor.ofFlat(-99f);\n+\n+    @CodeReflection\n+    public Tensor<Float> ifInitialized(Tensor<Boolean> cond1, Tensor<Boolean> cond2) {\n+        return OnnxOperators.If(cond1,\n+                () -> OnnxOperators.If(cond2,\n+                        () -> List.of(OnnxOperators.Identity(initialized4)),\n+                        () -> List.of(OnnxOperators.Identity(initialized3))),\n+                () -> OnnxOperators.If(cond2,\n+                        () -> List.of(OnnxOperators.Identity(initialized2)),\n+                        () -> List.of(OnnxOperators.Identity(initialized)))).get(0);\n+    }\n+\n+    @Test\n+    public void testIfInitialized() throws Exception {\n+        var condFalse = Tensor.ofScalar(false);\n+        var condTrue = Tensor.ofScalar(true);\n+\n+        assertEquals(initialized, ifInitialized(condTrue, condTrue));\n+        assertEquals(initialized, OnnxRuntime.execute(() -> ifInitialized(condTrue, condTrue)));\n+        assertEquals(initialized2, ifInitialized(condTrue, condFalse));\n+        assertEquals(initialized2, OnnxRuntime.execute(() -> ifInitialized(condTrue, condFalse)));\n+        assertEquals(initialized3, ifInitialized(condFalse, condTrue));\n+        assertEquals(initialized3, OnnxRuntime.execute(() -> ifInitialized(condFalse, condTrue)));\n+        assertEquals(initialized4, ifInitialized(condFalse, condFalse));\n+        assertEquals(initialized4, OnnxRuntime.execute(() -> ifInitialized(condFalse, condFalse)));\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":75,"deletions":16,"binary":false,"changes":91,"status":"modified"}]}