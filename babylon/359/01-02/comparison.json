{"files":[{"patch":"@@ -69,2 +69,7 @@\n-            if (outTensors.size() == 1) {\n-                return outTensors.getFirst();\n+            var outputs = schema.outputs();\n+            if (outputs.size() == 1) {\n+                if (outputs.getLast().quantifier() == OnnxOp.OnnxParameter.Quantifier.VARIADIC) {\n+                    return outTensors; \/\/ single variadic\n+                } else {\n+                    return outTensors.getFirst(); \/\/ single tensor\n+                }\n@@ -72,1 +77,11 @@\n-                return outTensors.toArray();\n+                \/\/ @@@ assuming only tail can be variadic\n+                if (outputs.getLast().quantifier() == OnnxOp.OnnxParameter.Quantifier.VARIADIC) {\n+                    var outArray = new Object[schema.outputs().size()];\n+                    for (int i = 0; i < outArray.length - 1; i++) {\n+                        outArray[i] = outputs.get(i);\n+                    }\n+                    outArray[outArray.length - 1] = outputs.subList(outArray.length - 1, outputs.size());\n+                    return outArray; \/\/ multiple tensors with variadic tail\n+                } else {\n+                    return outTensors.toArray(); \/\/ multiple tensors\n+                }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -11,0 +11,1 @@\n+import jdk.incubator.code.Op;\n@@ -13,0 +14,1 @@\n+import jdk.incubator.code.type.JavaType;\n@@ -375,1 +377,1 @@\n-                        case CoreOp.ReturnOp _ -> { \/\/ skip\n+                        case CoreOp.ReturnOp _, CoreOp.ConstantOp _ -> { \/\/ skip\n@@ -379,1 +381,8 @@\n-                        default ->\n+                        case CoreOp.InvokeOp io when io.invokeDescriptor().refType().equals(JavaType.type(List.class))\n+                                                  && io.invokeDescriptor().name().equals(\"get\")\n+                                                  && io.operands().getLast() instanceof Op.Result or\n+                                                  && or.op() instanceof CoreOp.ConstantOp co\n+                                                  && co.value() instanceof Integer i ->\n+                            indexer.put(io.result(), indexer.getName(io.operands().getFirst(), i));\n+                        default -> {\n+                            System.out.println(op.parent().parent().parent().toText());\n@@ -381,0 +390,1 @@\n+                        }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+    static final JavaType LIST_CLASS = JavaType.type(List.class);\n@@ -329,0 +330,4 @@\n+            unevaluatedOperations.add(o);\n+            return null;\n+        } else if (o instanceof CoreOp.InvokeOp io && io.invokeDescriptor().refType().equals(LIST_CLASS) && io.invokeDescriptor().name().equals(\"get\")) {\n+            evaluatedAttributes.put(io, List.of(oc.getValue(io.operands().getLast())));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxPartialEvaluator.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+    static final JavaType LIST_CLASS = JavaType.type(List.class);\n@@ -227,0 +228,9 @@\n+                \/\/ Transform access to the result of an operator that is a list access\n+                \/\/ @@@ raw use of List::get with constant argument\n+                case CoreOp.InvokeOp io when io.invokeDescriptor().refType().equals(LIST_CLASS) && io.invokeDescriptor().name().equals(\"get\") -> {\n+                    Op.Result result = bb.op(CoreOp.invoke(\n+                            io.invokeDescriptor(),\n+                            bb.context().getValue(io.operands().getFirst()),\n+                            bb.op(CoreOp.constant(JavaType.INT, pe.evaluatedAttributes.get(io).getLast()))));\n+                    bb.context().mapValue(io.result(), result);\n+                }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -133,0 +133,14 @@\n+    @CodeReflection\n+    public Tensor<Float> split(Tensor<Float> input, Tensor<Long> split) {\n+        return OnnxOperators.Split(input, Optional.of(split), Optional.empty(), Optional.empty()).get(0);\n+    }\n+\n+    @Test\n+    public void testSplit() throws Exception {\n+        var input = Tensor.ofFlat(1f, 2, 3, 4, 5);\n+        var split = Tensor.ofFlat(5l);\n+        assertEquals(\n+                split(input, split),\n+                OnnxRuntime.execute(()-> split(input, split)));\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}