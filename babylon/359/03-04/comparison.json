{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.util.ArrayList;\n@@ -31,0 +32,1 @@\n+import java.util.function.Function;\n@@ -84,0 +86,11 @@\n+\n+    public record LoopLocals<T>(Tensor<Long> i, Tensor<Boolean> cond, List<Tensor<T>> userValues) {}\n+    public static <T> List<Tensor<T>> Loop(Tensor<Long> max, Tensor<Boolean> cond, List<Tensor<T>> v_initial, Function<LoopLocals<T>, LoopLocals<T>> body) {\n+        long m = max.data().get(ValueLayout.JAVA_LONG, 0);\n+        LoopLocals<T> ll = new LoopLocals<>(Tensor.ofScalar(0), cond, v_initial);\n+        while (ll.i.data().get(ValueLayout.JAVA_LONG, 0) < m && ll.cond.data().get(ValueLayout.JAVA_BOOLEAN, 0)) {\n+            ll = body.apply(ll);\n+            ll.i.data().set(ValueLayout.JAVA_LONG, 0, ll.i.data().get(ValueLayout.JAVA_LONG, 0) + 1); \/\/ i++\n+        }\n+        return ll.userValues();\n+    }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,4 +28,1 @@\n-import java.util.List;\n-import java.util.SequencedMap;\n-import java.util.SequencedSet;\n-import java.util.Set;\n+import java.util.*;\n@@ -177,0 +174,146 @@\n+\n+    @OpFactory.OpDeclaration(Loop.NAME)\n+    public static final class Loop extends OnnxOp implements Op.Loop {\n+        public static final String NAME = \"Loop\";\n+\n+        final Body body;\n+\n+        \/\/ @@@ make or fake body\n+        public enum Attribute implements OnnxOp.OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxOp.OnnxTypeConstraint {\n+            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),\n+            I(new OnnxType.TypeVariable(\"I\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            B(new OnnxType.TypeVariable(\"B\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxOp.OnnxParameter {\n+            M(TypeConstraint.I.typeVariable(), OnnxOp.OnnxParameter.Quantifier.OPTIONAL),\n+            cond(TypeConstraint.B.typeVariable(), OnnxOp.OnnxParameter.Quantifier.OPTIONAL),\n+            v_initial(TypeConstraint.V.typeVariable(), OnnxOp.OnnxParameter.Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final OnnxOp.OnnxParameter.Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxOp.OnnxParameter {\n+            v_final_and_scan_outputs(TypeConstraint.V.typeVariable(), OnnxOp.OnnxParameter.Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final OnnxOp.OnnxParameter.Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxOp.OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Loop(ExternalizableOp.ExternalizedOp def) {\n+            super(SCHEMA, def);\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        Loop(ExplicitOnnxOps.Loop that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public ExplicitOnnxOps.Loop transform(CopyContext cc, OpTransformer ot) {\n+            return new ExplicitOnnxOps.Loop(this, cc, ot);\n+        }\n+\n+        Loop(TypeElement resultType, Optional<Value> m, Optional<Value> cond, List<Value> v_initial, Body.Builder body) {\n+            super(SCHEMA, resultType, Set.of(), List.of(m, cond, v_initial), List.of());\n+\n+            this.body = body.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxOp.OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxOp.OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(cond()));\n+        }\n+\n+        public Optional<Value> m() {\n+            int i = optionalInputArguments.indexOf(InputParameter.M);\n+            return i != -1 ? Optional.of(operands().get(1 + i)) : Optional.empty();\n+        }\n+\n+        public Optional<Value> cond() {\n+            int i = optionalInputArguments.indexOf(InputParameter.cond);\n+            return i != -1 ? Optional.of(operands().get(1 + i)) : Optional.empty();\n+        }\n+\n+        public List<Value> v_initial() {\n+            return operands().subList(1, operands().size());\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return body;\n+        }\n+    }\n+\n+    public static Loop OnnxLoop(TypeElement resultType, Optional<Value> m, Optional<Value> cond, List<Value> v_initial, Body.Builder body) {\n+        return new Loop(resultType, m, cond, v_initial, body);\n+    }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/ExplicitOnnxOps.java","additions":147,"deletions":4,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -231,0 +231,18 @@\n+    @CodeReflection\n+    public Tensor<Float> forLoopAdd(Tensor<Float> value, Tensor<Long> max) {\n+        return OnnxOperators.Loop(max, Tensor.ofScalar(true), List.of(value),\n+                l -> {\n+                    var v = l.userValues().get(0);\n+                    return new ExplicitOnnxOperators.LoopLocals<>(l.i(), l.cond(), List.of(OnnxOperators.Add(v, v)));\n+                }).get(0);\n+    }\n+\n+    @Test\n+    public void testForLoopAdd() throws Exception {\n+        var expected = Tensor.ofFlat(0f, 8, 16, 24);\n+        var value = Tensor.ofFlat(0f, 1, 2, 3);\n+        var max = Tensor.ofScalar(3l);\n+        assertEquals(expected, forLoopAdd(value, max));\n+\/\/        assertEquals(expected, OnnxRuntime.execute(() -> forLoopAdd(value, max)));\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}