{"files":[{"patch":"@@ -57,2 +57,10 @@\n-                              .map(i -> (Tensor)(i instanceof Optional o ? o.get() : i))\n-                              .toList(),\n+                            .map(i -> i instanceof Optional o ? o.get() : i)\n+                            .mapMulti((i, ic) -> {\n+                                if (i instanceof List li) {\n+                                    li.forEach(ic);\n+                                } else {\n+                                    ic.accept(i);\n+                                }\n+                            })\n+                            .map(Tensor.class::cast)\n+                            .toList(),\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -189,1 +189,12 @@\n-                                throw new UnsupportedOperationException();\n+                                \/\/ Evaluation of expressions List.of() with symbolic values\n+                                if (v instanceof Op.Result r && r.op() instanceof CoreOp.InvokeOp listInvoke\n+                                        && listInvoke.invokeDescriptor().refType().equals(JavaType.type(List.class))) {\n+                                    switch (listInvoke.invokeDescriptor().name()) {\n+                                        case \"of\" -> {\n+                                            opArgs.add(listInvoke.operands().stream().map(o -> bb.context().getValue(o)).toList());\n+                                        }\n+                                        default -> throw new UnsupportedOperationException();\n+                                    }\n+                                } else {\n+                                    throw new UnsupportedOperationException();\n+                                }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.util.List;\n@@ -118,0 +119,14 @@\n+    @CodeReflection\n+    public Tensor<Float> concat(Tensor<Float> input1, Tensor<Float> input2, long axis) {\n+        return OnnxOperators.Concat(List.of(input1, input2), axis);\n+    }\n+\n+    @Test\n+    public void testConcat() throws Exception {\n+        var input1 = Tensor.ofFlat(1f, 2, 3);\n+        var input2 = Tensor.ofFlat(4f, 5);\n+        assertEquals(\n+                concat(input1, input2, 0),\n+                OnnxRuntime.execute(()-> concat(input1, input2, 0)));\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}