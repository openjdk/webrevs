{"files":[{"patch":"@@ -740,2 +740,2 @@\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            throw new UnsupportedOperationException();\n+        public TypeElement resultType() {\n+            return resultType;\n@@ -745,2 +745,90 @@\n-        public TypeElement resultType() {\n-            return resultType;\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            \/\/ what's the lowered form ?\n+            \/\/ an exit block with result as parameter\n+            \/\/ branch to label with target as param\n+            \/\/ do the check\n+            \/\/ if true branch to expression, else branch to next label\n+            \/\/ default label branch unconditionaly to its expression\n+            \/\/ an expression branch to the exit block\n+            \/\/ yield in a label body will be converted to cbranch\n+            \/\/ yield in a expression body will be converted to branch to the exit block with yield value that represent the result\n+\n+            \/\/ input: the switch expression op, block builder (b)\n+            \/\/ output: the exit block\n+\n+            \/\/ create block for every label body, these blocks will have param of the type of the target\n+            \/\/ create block for every expression body\n+\n+            \/\/ in b branch to the first block, passing the target\n+            \/\/ for every body of the switch expression op\n+            \/\/ if it's a label body\n+            \/\/      inline it, convert yield to cbranch %p ^block_i+1 ^block_i+2 %block_i_param\n+            \/\/      for default we just branch to the next\n+            \/\/ if it's an expression body\n+            \/\/      inline it, convert yield to branch ^exit %yield_val\n+\n+            Value target = b.context().getValue(operands().get(0));\n+\n+            List<Block.Builder> blocks = new ArrayList<>();\n+            for (int i = 0; i < bodies().size(); i++) {\n+                Block.Builder bb;\n+                boolean isLabelBody = i % 2 == 0;\n+                if (isLabelBody) {\n+                    bb = b.block(target.type());\n+                } else {\n+                    bb = b.block();\n+                }\n+                if (i == 0) {\n+                    b.op(branch(bb.successor(target)));\n+                }\n+                blocks.add(bb);\n+            }\n+\n+            Block.Builder exit;\n+            if (bodies().isEmpty()) {\n+                exit = b;\n+            } else {\n+                exit = b.block(resultType());\n+                exit.context().mapValue(result(), exit.parameters().get(0));\n+            }\n+\n+            for (int i = 0; i < bodies().size(); i++) {\n+                boolean isLabelBody = i % 2 == 0;\n+                Block.Builder curr = blocks.get(i);\n+                if (isLabelBody) {\n+                    Block.Builder expression = blocks.get(i + 1);\n+                    boolean isDefaultLabel = i == blocks.size() - 2;\n+                    Block.Builder nextLabel = isDefaultLabel ? null : blocks.get(i + 2);\n+                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp yop) {\n+                            if (isDefaultLabel) {\n+                                block.op(branch(expression.successor()));\n+                            } else {\n+                                block.op(conditionalBranch(\n+                                        block.context().getValue(yop.yieldValue()),\n+                                        expression.successor(),\n+                                        nextLabel.successor(curr.parameters())\n+                                ));\n+                            }\n+                        } else if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                } else {\n+                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp yop) {\n+                            block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                        } else if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                }\n+            }\n+\n+            return exit;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":92,"deletions":4,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestSwitchExpressionOp\n+ *\/\n+public class TestSwitchExpressionOp {\n+\n+    @CodeReflection\n+    public static Object f(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"FOO\";\n+            case \"BAR\" -> \"FOO\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @Test\n+    public void test() throws InvocationTargetException, IllegalAccessException {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAZ\"), f(\"BAZ\"));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"}]}