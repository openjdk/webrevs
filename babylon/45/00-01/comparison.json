{"files":[{"patch":"@@ -191,1 +191,1 @@\n-     * The break operation, that can model Java language continue statements with label identifiers.\n+     * The continue operation, that can model Java language continue statements with label identifiers.\n@@ -246,1 +246,1 @@\n-    public static final class JavaYieldOp extends OpWithDefinition implements Op.BodyTerminating {\n+    public static final class JavaYieldOp extends OpWithDefinition implements Op.BodyTerminating, Op.Lowerable {\n@@ -284,0 +284,34 @@\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            \/\/ for now, we will use breakBlock field to indicate java.yield target block\n+            return lower(b, BranchTarget::breakBlock);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            Op opt = target();\n+            BranchTarget t = getBranchTarget(b.context(), opt);\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor(b.context().getValue(yieldValue()))));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + opt);\n+            }\n+            return b;\n+        }\n+\n+        Op target() {\n+            return innerMostEnclosingTarget();\n+        }\n+\n+        Op innerMostEnclosingTarget() {\n+            Op op = this;\n+            Body b;\n+            do {\n+                b = op.ancestorBody();\n+                op = b.parentOp();\n+                if (op == null) {\n+                    throw new IllegalStateException(\"No enclosing switch\");\n+                }\n+            } while (!(op instanceof JavaSwitchExpressionOp));\n+            return op;\n+        }\n@@ -770,1 +804,1 @@\n-            Value target = b.context().getValue(operands().get(0));\n+            Value swTarget = b.context().getValue(operands().get(0));\n@@ -777,1 +811,1 @@\n-                    bb = b.block(target.type());\n+                    bb = b.block(swTarget.type());\n@@ -782,1 +816,1 @@\n-                    b.op(branch(bb.successor(target)));\n+                    b.op(branch(bb.successor(swTarget)));\n@@ -795,0 +829,2 @@\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n@@ -820,1 +856,2 @@\n-                } else {\n+                } else { \/\/ expression body\n+                    Block.Builder nextExpression = i < blocks.size() - 2 ? blocks.get(i + 2) : null;\n@@ -822,6 +859,6 @@\n-                        if (op instanceof YieldOp yop) {\n-                            block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n-                        } else if (op instanceof Lowerable lop) {\n-                            block = lop.lower(block);\n-                        } else {\n-                            block.op(op);\n+                        switch (op) {\n+                            case YieldOp yop -> block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                            case JavaSwitchFallthroughOp jsftop -> block.op(branch(nextExpression.successor()));\n+\/\/                            case JavaYieldOp jyop -> block.op(branch(exit.successor(block.context().getValue(jyop.yieldValue()))));\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":49,"deletions":12,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -20,1 +20,1 @@\n-    public static Object f(String r) {\n+    public static Object f1(String r) {\n@@ -30,2 +30,2 @@\n-    public void test() throws InvocationTargetException, IllegalAccessException {\n-        CoreOps.FuncOp f = getFuncOp(\"f\");\n+    public void test1() throws InvocationTargetException, IllegalAccessException {\n+        CoreOps.FuncOp f = getFuncOp(\"f1\");\n@@ -46,1 +46,41 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAZ\"), f(\"BAZ\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f1(\"FOO\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f1(\"BAR\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAZ\"), f1(\"BAZ\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f1(\"ELSE\"));\n+    }\n+\n+    @CodeReflection\n+    \/\/ fallthrough case\n+    public static Object f2(String r) {\n+        return switch (r) {\n+            case \"FOO\" : {\n+            }\n+            case \"BAR\" : {\n+                yield \"2\";\n+            }\n+            default : yield \"\";\n+        };\n+    }\n+\n+    @Test\n+    public void test2() throws InvocationTargetException, IllegalAccessException {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        System.out.println(\"f2(\\\"FOO\\\"): \" + f2(\"FOO\"));\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f2(\"FOO\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f2(\"BAR\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f2(\"ELSE\"));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":44,"deletions":4,"binary":false,"changes":48,"status":"modified"}]}