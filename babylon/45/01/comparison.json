{"files":[{"patch":"@@ -191,1 +191,1 @@\n-     * The break operation, that can model Java language continue statements with label identifiers.\n+     * The continue operation, that can model Java language continue statements with label identifiers.\n@@ -246,1 +246,1 @@\n-    public static final class JavaYieldOp extends OpWithDefinition implements Op.BodyTerminating {\n+    public static final class JavaYieldOp extends OpWithDefinition implements Op.BodyTerminating, Op.Lowerable {\n@@ -284,0 +284,34 @@\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            \/\/ for now, we will use breakBlock field to indicate java.yield target block\n+            return lower(b, BranchTarget::breakBlock);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            Op opt = target();\n+            BranchTarget t = getBranchTarget(b.context(), opt);\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor(b.context().getValue(yieldValue()))));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + opt);\n+            }\n+            return b;\n+        }\n+\n+        Op target() {\n+            return innerMostEnclosingTarget();\n+        }\n+\n+        Op innerMostEnclosingTarget() {\n+            Op op = this;\n+            Body b;\n+            do {\n+                b = op.ancestorBody();\n+                op = b.parentOp();\n+                if (op == null) {\n+                    throw new IllegalStateException(\"No enclosing switch\");\n+                }\n+            } while (!(op instanceof JavaSwitchExpressionOp));\n+            return op;\n+        }\n@@ -740,2 +774,2 @@\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            throw new UnsupportedOperationException();\n+        public TypeElement resultType() {\n+            return resultType;\n@@ -745,2 +779,93 @@\n-        public TypeElement resultType() {\n-            return resultType;\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            \/\/ what's the lowered form ?\n+            \/\/ an exit block with result as parameter\n+            \/\/ branch to label with target as param\n+            \/\/ do the check\n+            \/\/ if true branch to expression, else branch to next label\n+            \/\/ default label branch unconditionaly to its expression\n+            \/\/ an expression branch to the exit block\n+            \/\/ yield in a label body will be converted to cbranch\n+            \/\/ yield in a expression body will be converted to branch to the exit block with yield value that represent the result\n+\n+            \/\/ input: the switch expression op, block builder (b)\n+            \/\/ output: the exit block\n+\n+            \/\/ create block for every label body, these blocks will have param of the type of the target\n+            \/\/ create block for every expression body\n+\n+            \/\/ in b branch to the first block, passing the target\n+            \/\/ for every body of the switch expression op\n+            \/\/ if it's a label body\n+            \/\/      inline it, convert yield to cbranch %p ^block_i+1 ^block_i+2 %block_i_param\n+            \/\/      for default we just branch to the next\n+            \/\/ if it's an expression body\n+            \/\/      inline it, convert yield to branch ^exit %yield_val\n+\n+            Value swTarget = b.context().getValue(operands().get(0));\n+\n+            List<Block.Builder> blocks = new ArrayList<>();\n+            for (int i = 0; i < bodies().size(); i++) {\n+                Block.Builder bb;\n+                boolean isLabelBody = i % 2 == 0;\n+                if (isLabelBody) {\n+                    bb = b.block(swTarget.type());\n+                } else {\n+                    bb = b.block();\n+                }\n+                if (i == 0) {\n+                    b.op(branch(bb.successor(swTarget)));\n+                }\n+                blocks.add(bb);\n+            }\n+\n+            Block.Builder exit;\n+            if (bodies().isEmpty()) {\n+                exit = b;\n+            } else {\n+                exit = b.block(resultType());\n+                exit.context().mapValue(result(), exit.parameters().get(0));\n+            }\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            for (int i = 0; i < bodies().size(); i++) {\n+                boolean isLabelBody = i % 2 == 0;\n+                Block.Builder curr = blocks.get(i);\n+                if (isLabelBody) {\n+                    Block.Builder expression = blocks.get(i + 1);\n+                    boolean isDefaultLabel = i == blocks.size() - 2;\n+                    Block.Builder nextLabel = isDefaultLabel ? null : blocks.get(i + 2);\n+                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp yop) {\n+                            if (isDefaultLabel) {\n+                                block.op(branch(expression.successor()));\n+                            } else {\n+                                block.op(conditionalBranch(\n+                                        block.context().getValue(yop.yieldValue()),\n+                                        expression.successor(),\n+                                        nextLabel.successor(curr.parameters())\n+                                ));\n+                            }\n+                        } else if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                } else { \/\/ expression body\n+                    Block.Builder nextExpression = i < blocks.size() - 2 ? blocks.get(i + 2) : null;\n+                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n+                        switch (op) {\n+                            case YieldOp yop -> block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                            case JavaSwitchFallthroughOp jsftop -> block.op(branch(nextExpression.successor()));\n+\/\/                            case JavaYieldOp jyop -> block.op(branch(exit.successor(block.context().getValue(jyop.yieldValue()))));\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                }\n+            }\n+\n+            return exit;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":131,"deletions":6,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestSwitchExpressionOp\n+ *\/\n+public class TestSwitchExpressionOp {\n+\n+    @CodeReflection\n+    public static Object f1(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"FOO\";\n+            case \"BAR\" -> \"FOO\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @Test\n+    public void test1() throws InvocationTargetException, IllegalAccessException {\n+        CoreOps.FuncOp f = getFuncOp(\"f1\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f1(\"FOO\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f1(\"BAR\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAZ\"), f1(\"BAZ\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f1(\"ELSE\"));\n+    }\n+\n+    @CodeReflection\n+    \/\/ fallthrough case\n+    public static Object f2(String r) {\n+        return switch (r) {\n+            case \"FOO\" : {\n+            }\n+            case \"BAR\" : {\n+                yield \"2\";\n+            }\n+            default : yield \"\";\n+        };\n+    }\n+\n+    @Test\n+    public void test2() throws InvocationTargetException, IllegalAccessException {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        System.out.println(\"f2(\\\"FOO\\\"): \" + f2(\"FOO\"));\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f2(\"FOO\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f2(\"BAR\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f2(\"ELSE\"));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}