{"files":[{"patch":"@@ -794,0 +794,27 @@\n+        private boolean haveNullCase() {\n+            \/*\n+            case null is modeled like this:\n+            (%4 : T)boolean -> {\n+                %5 : java.lang.Object = constant @null;\n+                %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                yield %6;\n+            }\n+            * *\/\n+            for (int i = 0; i < bodies().size() - 2; i+=2) {\n+                Body labelBody = bodies().get(i);\n+                if (labelBody.blocks().size() != 1) {\n+                    continue; \/\/ we skip, for now\n+                }\n+                Op terminatingOp = bodies().get(i).entryBlock().terminatingOp();\n+                \/\/@@@ when op pattern matching is ready, we can use it\n+                if (terminatingOp instanceof YieldOp yieldOp &&\n+                        yieldOp.yieldValue() instanceof Op.Result opr &&\n+                        opr.op() instanceof InvokeOp invokeOp &&\n+                        invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class)) &&\n+                        invokeOp.operands().stream().anyMatch(o -> o instanceof Op.Result r && r.op() instanceof ConstantOp cop && cop.value() == null)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n@@ -797,1 +824,16 @@\n-            Value swTarget = b.context().getValue(operands().get(0));\n+            Value selectorExpression = b.context().getValue(operands().get(0));\n+\n+            if (!haveNullCase()) {\n+                Block.Builder throwBlock = b.block();\n+                throwBlock.op(_throw(\n+                        throwBlock.op(_new(FunctionType.functionType(JavaType.type(NullPointerException.class))))\n+                ));\n+\n+                Block.Builder continueBlock = b.block();\n+\n+                Result p = b.op(invoke(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                        selectorExpression, b.op(constant(J_L_OBJECT, null))));\n+                b.op(conditionalBranch(p, throwBlock.successor(), continueBlock.successor()));\n+\n+                b = continueBlock;\n+            }\n@@ -803,1 +845,1 @@\n-                    b.op(branch(bb.successor()));\n+                    bb = b;\n@@ -830,10 +872,12 @@\n-                    curr.transformBody(bodies().get(i), List.of(swTarget), opT.andThen((block, op) -> {\n-                        if (op instanceof YieldOp yop) {\n-                            if (isDefaultLabel) {\n-                                block.op(branch(expression.successor()));\n-                            } else {\n-                                block.op(conditionalBranch(\n-                                        block.context().getValue(yop.yieldValue()),\n-                                        expression.successor(),\n-                                        nextLabel.successor()\n-                                ));\n+                    curr.transformBody(bodies().get(i), List.of(selectorExpression), opT.andThen((block, op) -> {\n+                        switch (op) {\n+                            case YieldOp yop -> {\n+                                if (isDefaultLabel) {\n+                                    block.op(branch(expression.successor()));\n+                                } else {\n+                                    block.op(conditionalBranch(\n+                                            block.context().getValue(yop.yieldValue()),\n+                                            expression.successor(),\n+                                            nextLabel.successor()\n+                                    ));\n+                                }\n@@ -841,4 +885,2 @@\n-                        } else if (op instanceof Lowerable lop) {\n-                            block = lop.lower(block);\n-                        } else {\n-                            block.op(op);\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":58,"deletions":16,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -7,1 +7,0 @@\n-import java.lang.reflect.code.op.CoreOps;\n@@ -12,0 +11,2 @@\n+import static java.lang.reflect.code.op.CoreOps.*;\n+\n@@ -18,0 +19,3 @@\n+    \/\/ TODO more testing\n+    \/\/  cover cases where MatchException will be thrown\n+\n@@ -30,14 +34,1 @@\n-        CoreOps.FuncOp f = getFuncOp(\"f1\");\n-\n-        f.writeTo(System.out);\n-\n-        CoreOps.FuncOp lf = f.transform((block, op) -> {\n-            if (op instanceof Op.Lowerable lop) {\n-                return lop.lower(block);\n-            } else {\n-                block.op(op);\n-                return block;\n-            }\n-        });\n-\n-        lf.writeTo(System.out);\n+        FuncOp lf = lower(\"f1\");\n@@ -52,2 +43,1 @@\n-    \/\/ fallthrough case\n-    public static Object f2(String r) {\n+    public static Object f2(String r) { \/\/ switch expr with fallthrough\n@@ -66,1 +56,23 @@\n-        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+        FuncOp lf = lower(\"f2\");\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f2(\"FOO\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f2(\"BAR\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f2(\"ELSE\"));\n+    }\n+\n+    @CodeReflection\n+    \/\/ null is handled, when selector expr is null the switch will complete normally\n+    private static String f3(String s) {\n+        return switch (s) {\n+            case null -> \"null\";\n+            default -> \"default\";\n+        };\n+    }\n+\n+    @Test\n+    public void test3() {\n+        FuncOp lf = lower(\"f3\");\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, new Object[]{null}), f3(null));\n+    }\n@@ -68,0 +80,30 @@\n+    @CodeReflection\n+    \/\/ null not handled, when selector expr is null it will throw NPE\n+    private static String f4(String s) {\n+        return switch (s) {\n+            default -> \"default\";\n+        };\n+    }\n+\n+    @Test\n+    public void test4() {\n+        FuncOp lf = lower(\"f4\");\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n+        Assert.assertThrows(NullPointerException.class, () -> f4(null));\n+        Assert.assertThrows(NullPointerException.class, () -> Interpreter.invoke(lf, new Object[]{null}));\n+    }\n+\n+    static FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n+\n+    private static FuncOp lower(String methodName) {\n+        return lower(getFuncOp(methodName));\n+    }\n+\n+    private static FuncOp lower(FuncOp f) {\n@@ -70,1 +112,1 @@\n-        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+        FuncOp lf = f.transform((block, op) -> {\n@@ -81,11 +123,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f2(\"FOO\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f2(\"BAR\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f2(\"ELSE\"));\n-    }\n-\n-    static CoreOps.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        return om.get().getCodeModel().get();\n+        return lf;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":62,"deletions":30,"binary":false,"changes":92,"status":"modified"}]}