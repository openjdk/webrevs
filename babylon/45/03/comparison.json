{"files":[{"patch":"@@ -191,1 +191,1 @@\n-     * The break operation, that can model Java language continue statements with label identifiers.\n+     * The continue operation, that can model Java language continue statements with label identifiers.\n@@ -235,0 +235,9 @@\n+    static BranchTarget getBranchTarget(CopyContext cc, CodeElement<?, ?> codeElement) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<CodeElement<?, ?>, BranchTarget> m = (Map<CodeElement<?, ?>, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n+        if (m != null) {\n+            return m.get(codeElement);\n+        }\n+        return null;\n+    }\n+\n@@ -242,0 +251,7 @@\n+    static void setBranchTarget(CopyContext cc, CodeElement<?, ?> codeElement, BranchTarget t) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<CodeElement<?, ?>, BranchTarget> x = (Map<CodeElement<?, ?>, BranchTarget>) cc.computePropertyIfAbsent(\n+                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n+        x.put(codeElement, t);\n+    }\n+\n@@ -246,1 +262,1 @@\n-    public static final class JavaYieldOp extends OpWithDefinition implements Op.BodyTerminating {\n+    public static final class JavaYieldOp extends OpWithDefinition implements Op.BodyTerminating, Op.Lowerable {\n@@ -284,0 +300,34 @@\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            \/\/ for now, we will use breakBlock field to indicate java.yield target block\n+            return lower(b, BranchTarget::breakBlock);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            Op opt = target();\n+            BranchTarget t = getBranchTarget(b.context(), opt);\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor(b.context().getValue(yieldValue()))));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + opt);\n+            }\n+            return b;\n+        }\n+\n+        Op target() {\n+            return innerMostEnclosingTarget();\n+        }\n+\n+        Op innerMostEnclosingTarget() {\n+            Op op = this;\n+            Body b;\n+            do {\n+                b = op.ancestorBody();\n+                op = b.parentOp();\n+                if (op == null) {\n+                    throw new IllegalStateException(\"No enclosing switch\");\n+                }\n+            } while (!(op instanceof JavaSwitchExpressionOp));\n+            return op;\n+        }\n@@ -740,2 +790,29 @@\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            throw new UnsupportedOperationException();\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+\n+        private boolean haveNullCase() {\n+            \/*\n+            case null is modeled like this:\n+            (%4 : T)boolean -> {\n+                %5 : java.lang.Object = constant @null;\n+                %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                yield %6;\n+            }\n+            * *\/\n+            for (int i = 0; i < bodies().size() - 2; i+=2) {\n+                Body labelBody = bodies().get(i);\n+                if (labelBody.blocks().size() != 1) {\n+                    continue; \/\/ we skip, for now\n+                }\n+                Op terminatingOp = bodies().get(i).entryBlock().terminatingOp();\n+                \/\/@@@ when op pattern matching is ready, we can use it\n+                if (terminatingOp instanceof YieldOp yieldOp &&\n+                        yieldOp.yieldValue() instanceof Op.Result opr &&\n+                        opr.op() instanceof InvokeOp invokeOp &&\n+                        invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class)) &&\n+                        invokeOp.operands().stream().anyMatch(o -> o instanceof Op.Result r && r.op() instanceof ConstantOp cop && cop.value() == null)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n@@ -745,2 +822,81 @@\n-        public TypeElement resultType() {\n-            return resultType;\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+\n+            Value selectorExpression = b.context().getValue(operands().get(0));\n+\n+            if (!haveNullCase()) {\n+                Block.Builder throwBlock = b.block();\n+                throwBlock.op(_throw(\n+                        throwBlock.op(_new(FunctionType.functionType(JavaType.type(NullPointerException.class))))\n+                ));\n+\n+                Block.Builder continueBlock = b.block();\n+\n+                Result p = b.op(invoke(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                        selectorExpression, b.op(constant(J_L_OBJECT, null))));\n+                b.op(conditionalBranch(p, throwBlock.successor(), continueBlock.successor()));\n+\n+                b = continueBlock;\n+            }\n+\n+            List<Block.Builder> blocks = new ArrayList<>();\n+            for (int i = 0; i < bodies().size(); i++) {\n+                Block.Builder bb = b.block();\n+                if (i == 0) {\n+                    bb = b;\n+                }\n+                blocks.add(bb);\n+            }\n+\n+            Block.Builder exit;\n+            if (bodies().isEmpty()) {\n+                exit = b;\n+            } else {\n+                exit = b.block(resultType());\n+                exit.context().mapValue(result(), exit.parameters().get(0));\n+            }\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            \/\/ map expr body to nextExprBlock\n+            \/\/ this mapping will be used for lowering SwitchFallThroughOp\n+            for (int i = 1; i < bodies().size() - 2; i+=2) {\n+                setBranchTarget(b.context(), bodies().get(i), new BranchTarget(null, blocks.get(i + 2)));\n+            }\n+\n+            for (int i = 0; i < bodies().size(); i++) {\n+                boolean isLabelBody = i % 2 == 0;\n+                Block.Builder curr = blocks.get(i);\n+                if (isLabelBody) {\n+                    Block.Builder expression = blocks.get(i + 1);\n+                    boolean isDefaultLabel = i == blocks.size() - 2;\n+                    Block.Builder nextLabel = isDefaultLabel ? null : blocks.get(i + 2);\n+                    curr.transformBody(bodies().get(i), List.of(selectorExpression), opT.andThen((block, op) -> {\n+                        switch (op) {\n+                            case YieldOp yop -> {\n+                                if (isDefaultLabel) {\n+                                    block.op(branch(expression.successor()));\n+                                } else {\n+                                    block.op(conditionalBranch(\n+                                            block.context().getValue(yop.yieldValue()),\n+                                            expression.successor(),\n+                                            nextLabel.successor()\n+                                    ));\n+                                }\n+                            }\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                } else { \/\/ expression body\n+                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n+                        switch (op) {\n+                            case YieldOp yop -> block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                }\n+            }\n+\n+            return exit;\n@@ -755,1 +911,1 @@\n-    public static final class JavaSwitchFallthroughOp extends OpWithDefinition implements Op.BodyTerminating {\n+    public static final class JavaSwitchFallthroughOp extends OpWithDefinition implements Op.BodyTerminating, Op.Lowerable {\n@@ -779,0 +935,15 @@\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::continueBlock);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            BranchTarget t = getBranchTarget(b.context(), parentBlock().parentBody());\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor()));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + this);\n+            }\n+            return b;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":178,"deletions":7,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+\n+\/*\n+ * @test\n+ * @run testng TestSwitchExpressionOp\n+ *\/\n+public class TestSwitchExpressionOp {\n+\n+    \/\/ TODO more testing\n+    \/\/  cover cases where MatchException will be thrown\n+\n+    @CodeReflection\n+    public static Object f1(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"FOO\";\n+            case \"BAR\" -> \"FOO\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @Test\n+    public void test1() {\n+        FuncOp lf = lower(\"f1\");\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f1(\"FOO\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f1(\"BAR\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAZ\"), f1(\"BAZ\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f1(\"ELSE\"));\n+    }\n+\n+    @CodeReflection\n+    public static Object f2(String r) { \/\/ switch expr with fallthrough\n+        return switch (r) {\n+            case \"FOO\" : {\n+            }\n+            case \"BAR\" : {\n+                yield \"2\";\n+            }\n+            default : yield \"\";\n+        };\n+    }\n+\n+    @Test\n+    public void test2() {\n+        FuncOp lf = lower(\"f2\");\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f2(\"FOO\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f2(\"BAR\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f2(\"ELSE\"));\n+    }\n+\n+    @CodeReflection\n+    \/\/ null is handled, when selector expr is null the switch will complete normally\n+    private static String f3(String s) {\n+        return switch (s) {\n+            case null -> \"null\";\n+            default -> \"default\";\n+        };\n+    }\n+\n+    @Test\n+    public void test3() {\n+        FuncOp lf = lower(\"f3\");\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, new Object[]{null}), f3(null));\n+    }\n+\n+    @CodeReflection\n+    \/\/ null not handled, when selector expr is null it will throw NPE\n+    private static String f4(String s) {\n+        return switch (s) {\n+            default -> \"default\";\n+        };\n+    }\n+\n+    @Test\n+    public void test4() {\n+        FuncOp lf = lower(\"f4\");\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n+        Assert.assertThrows(NullPointerException.class, () -> f4(null));\n+        Assert.assertThrows(NullPointerException.class, () -> Interpreter.invoke(lf, new Object[]{null}));\n+    }\n+\n+    static FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n+\n+    private static FuncOp lower(String methodName) {\n+        return lower(getFuncOp(methodName));\n+    }\n+\n+    private static FuncOp lower(FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        return lf;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"}]}