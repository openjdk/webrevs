{"files":[{"patch":"@@ -191,1 +191,1 @@\n-     * The break operation, that can model Java language continue statements with label identifiers.\n+     * The continue operation, that can model Java language continue statements with label identifiers.\n@@ -235,0 +235,9 @@\n+    static BranchTarget getBranchTarget(CopyContext cc, CodeElement<?, ?> codeElement) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<CodeElement<?, ?>, BranchTarget> m = (Map<CodeElement<?, ?>, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n+        if (m != null) {\n+            return m.get(codeElement);\n+        }\n+        return null;\n+    }\n+\n@@ -242,0 +251,7 @@\n+    static void setBranchTarget(CopyContext cc, CodeElement<?, ?> codeElement, BranchTarget t) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<CodeElement<?, ?>, BranchTarget> x = (Map<CodeElement<?, ?>, BranchTarget>) cc.computePropertyIfAbsent(\n+                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n+        x.put(codeElement, t);\n+    }\n+\n@@ -246,1 +262,1 @@\n-    public static final class JavaYieldOp extends OpWithDefinition implements Op.BodyTerminating {\n+    public static final class JavaYieldOp extends OpWithDefinition implements Op.BodyTerminating, Op.Lowerable {\n@@ -284,0 +300,34 @@\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            \/\/ for now, we will use breakBlock field to indicate java.yield target block\n+            return lower(b, BranchTarget::breakBlock);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            Op opt = target();\n+            BranchTarget t = getBranchTarget(b.context(), opt);\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor(b.context().getValue(yieldValue()))));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + opt);\n+            }\n+            return b;\n+        }\n+\n+        Op target() {\n+            return innerMostEnclosingTarget();\n+        }\n+\n+        Op innerMostEnclosingTarget() {\n+            Op op = this;\n+            Body b;\n+            do {\n+                b = op.ancestorBody();\n+                op = b.parentOp();\n+                if (op == null) {\n+                    throw new IllegalStateException(\"No enclosing switch\");\n+                }\n+            } while (!(op instanceof JavaSwitchExpressionOp));\n+            return op;\n+        }\n@@ -740,2 +790,2 @@\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            throw new UnsupportedOperationException();\n+        public TypeElement resultType() {\n+            return resultType;\n@@ -745,2 +795,66 @@\n-        public TypeElement resultType() {\n-            return resultType;\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+\n+            Value swTarget = b.context().getValue(operands().get(0));\n+\n+            List<Block.Builder> blocks = new ArrayList<>();\n+            for (int i = 0; i < bodies().size(); i++) {\n+                Block.Builder bb = b.block();\n+                if (i == 0) {\n+                    b.op(branch(bb.successor()));\n+                }\n+                blocks.add(bb);\n+            }\n+\n+            Block.Builder exit;\n+            if (bodies().isEmpty()) {\n+                exit = b;\n+            } else {\n+                exit = b.block(resultType());\n+                exit.context().mapValue(result(), exit.parameters().get(0));\n+            }\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            \/\/ map expr body to nextExprBlock\n+            \/\/ this mapping will be used for lowering SwitchFallThroughOp\n+            for (int i = 1; i < bodies().size() - 2; i+=2) {\n+                setBranchTarget(b.context(), bodies().get(i), new BranchTarget(null, blocks.get(i + 2)));\n+            }\n+\n+            for (int i = 0; i < bodies().size(); i++) {\n+                boolean isLabelBody = i % 2 == 0;\n+                Block.Builder curr = blocks.get(i);\n+                if (isLabelBody) {\n+                    Block.Builder expression = blocks.get(i + 1);\n+                    boolean isDefaultLabel = i == blocks.size() - 2;\n+                    Block.Builder nextLabel = isDefaultLabel ? null : blocks.get(i + 2);\n+                    curr.transformBody(bodies().get(i), List.of(swTarget), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp yop) {\n+                            if (isDefaultLabel) {\n+                                block.op(branch(expression.successor()));\n+                            } else {\n+                                block.op(conditionalBranch(\n+                                        block.context().getValue(yop.yieldValue()),\n+                                        expression.successor(),\n+                                        nextLabel.successor()\n+                                ));\n+                            }\n+                        } else if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                } else { \/\/ expression body\n+                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n+                        switch (op) {\n+                            case YieldOp yop -> block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                }\n+            }\n+\n+            return exit;\n@@ -755,1 +869,1 @@\n-    public static final class JavaSwitchFallthroughOp extends OpWithDefinition implements Op.BodyTerminating {\n+    public static final class JavaSwitchFallthroughOp extends OpWithDefinition implements Op.BodyTerminating, Op.Lowerable {\n@@ -779,0 +893,15 @@\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::continueBlock);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            BranchTarget t = getBranchTarget(b.context(), parentBlock().parentBody());\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor()));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + this);\n+            }\n+            return b;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":136,"deletions":7,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestSwitchExpressionOp\n+ *\/\n+public class TestSwitchExpressionOp {\n+\n+    @CodeReflection\n+    public static Object f1(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"FOO\";\n+            case \"BAR\" -> \"FOO\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @Test\n+    public void test1() {\n+        CoreOps.FuncOp f = getFuncOp(\"f1\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f1(\"FOO\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f1(\"BAR\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAZ\"), f1(\"BAZ\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f1(\"ELSE\"));\n+    }\n+\n+    @CodeReflection\n+    \/\/ fallthrough case\n+    public static Object f2(String r) {\n+        return switch (r) {\n+            case \"FOO\" : {\n+            }\n+            case \"BAR\" : {\n+                yield \"2\";\n+            }\n+            default : yield \"\";\n+        };\n+    }\n+\n+    @Test\n+    public void test2() {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f2(\"FOO\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f2(\"BAR\"));\n+        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f2(\"ELSE\"));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}