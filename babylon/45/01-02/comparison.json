{"files":[{"patch":"@@ -235,0 +235,9 @@\n+    static BranchTarget getBranchTarget(CopyContext cc, CodeElement<?, ?> codeElement) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<CodeElement<?, ?>, BranchTarget> m = (Map<CodeElement<?, ?>, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n+        if (m != null) {\n+            return m.get(codeElement);\n+        }\n+        return null;\n+    }\n+\n@@ -242,0 +251,7 @@\n+    static void setBranchTarget(CopyContext cc, CodeElement<?, ?> codeElement, BranchTarget t) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<CodeElement<?, ?>, BranchTarget> x = (Map<CodeElement<?, ?>, BranchTarget>) cc.computePropertyIfAbsent(\n+                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n+        x.put(codeElement, t);\n+    }\n+\n@@ -780,23 +796,0 @@\n-            \/\/ what's the lowered form ?\n-            \/\/ an exit block with result as parameter\n-            \/\/ branch to label with target as param\n-            \/\/ do the check\n-            \/\/ if true branch to expression, else branch to next label\n-            \/\/ default label branch unconditionaly to its expression\n-            \/\/ an expression branch to the exit block\n-            \/\/ yield in a label body will be converted to cbranch\n-            \/\/ yield in a expression body will be converted to branch to the exit block with yield value that represent the result\n-\n-            \/\/ input: the switch expression op, block builder (b)\n-            \/\/ output: the exit block\n-\n-            \/\/ create block for every label body, these blocks will have param of the type of the target\n-            \/\/ create block for every expression body\n-\n-            \/\/ in b branch to the first block, passing the target\n-            \/\/ for every body of the switch expression op\n-            \/\/ if it's a label body\n-            \/\/      inline it, convert yield to cbranch %p ^block_i+1 ^block_i+2 %block_i_param\n-            \/\/      for default we just branch to the next\n-            \/\/ if it's an expression body\n-            \/\/      inline it, convert yield to branch ^exit %yield_val\n@@ -808,7 +801,1 @@\n-                Block.Builder bb;\n-                boolean isLabelBody = i % 2 == 0;\n-                if (isLabelBody) {\n-                    bb = b.block(swTarget.type());\n-                } else {\n-                    bb = b.block();\n-                }\n+                Block.Builder bb = b.block();\n@@ -816,1 +803,1 @@\n-                    b.op(branch(bb.successor(swTarget)));\n+                    b.op(branch(bb.successor()));\n@@ -830,0 +817,5 @@\n+            \/\/ map expr body to nextExprBlock\n+            \/\/ this mapping will be used for lowering SwitchFallThroughOp\n+            for (int i = 1; i < bodies().size() - 2; i+=2) {\n+                setBranchTarget(b.context(), bodies().get(i), new BranchTarget(null, blocks.get(i + 2)));\n+            }\n@@ -838,1 +830,1 @@\n-                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n+                    curr.transformBody(bodies().get(i), List.of(swTarget), opT.andThen((block, op) -> {\n@@ -846,1 +838,1 @@\n-                                        nextLabel.successor(curr.parameters())\n+                                        nextLabel.successor()\n@@ -857,1 +849,0 @@\n-                    Block.Builder nextExpression = i < blocks.size() - 2 ? blocks.get(i + 2) : null;\n@@ -861,2 +852,0 @@\n-                            case JavaSwitchFallthroughOp jsftop -> block.op(branch(nextExpression.successor()));\n-\/\/                            case JavaYieldOp jyop -> block.op(branch(exit.successor(block.context().getValue(jyop.yieldValue()))));\n@@ -880,1 +869,1 @@\n-    public static final class JavaSwitchFallthroughOp extends OpWithDefinition implements Op.BodyTerminating {\n+    public static final class JavaSwitchFallthroughOp extends OpWithDefinition implements Op.BodyTerminating, Op.Lowerable {\n@@ -904,0 +893,15 @@\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::continueBlock);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            BranchTarget t = getBranchTarget(b.context(), parentBlock().parentBody());\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor()));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + this);\n+            }\n+            return b;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":41,"deletions":37,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -30,1 +29,1 @@\n-    public void test1() throws InvocationTargetException, IllegalAccessException {\n+    public void test1() {\n@@ -66,1 +65,1 @@\n-    public void test2() throws InvocationTargetException, IllegalAccessException {\n+    public void test2() {\n@@ -82,2 +81,0 @@\n-        System.out.println(\"f2(\\\"FOO\\\"): \" + f2(\"FOO\"));\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}