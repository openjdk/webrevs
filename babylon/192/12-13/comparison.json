{"files":[{"patch":"@@ -76,0 +76,1 @@\n+import java.util.BitSet;\n@@ -119,4 +120,2 @@\n-        \/\/ Filter out exception handlers overlapping with try blocks\n-        this.exceptionHandlers = codeModel.exceptionHandlers().stream().filter(\n-                eh -> codeAttribtue.labelToBci(eh.handler()) >= codeAttribtue.labelToBci(eh.tryEnd())\n-                   || codeAttribtue.labelToBci(eh.handler()) < codeAttribtue.labelToBci(eh.tryStart())).toList();\n+        var smta = codeModel.findAttribute(Attributes.stackMapTable());\n+        this.exceptionHandlers = extractExceptionHandlers(codeAttribtue);\n@@ -125,1 +124,0 @@\n-        var smta = codeModel.findAttribute(Attributes.stackMapTable());\n@@ -142,0 +140,64 @@\n+    private static List<ExceptionCatch> extractExceptionHandlers(CodeAttribute codeAttribute) {\n+        record JumpTarget(int targetBci, Label target, List<Integer> sourceBcis) {}\n+        BitSet targetBcis = new BitSet(codeAttribute.codeLength());\n+        var jumpMap = new HashMap<Integer, JumpTarget>() {\n+            void add(Label target, int sourceBci) {\n+                computeIfAbsent(codeAttribute.labelToBci(target), targetBci -> {\n+                    targetBcis.set(targetBci);\n+                    return new JumpTarget(targetBci, target, new ArrayList<>());\n+                }).sourceBcis.add(sourceBci);\n+            }\n+        };\n+\n+        int bci = 0;\n+        \/\/ First collect jump map\n+        for (CodeElement ce : codeAttribute) {\n+            switch (ce) {\n+                case BranchInstruction bi -> {\n+                    jumpMap.add(bi.target(), bci);\n+                }\n+                case TableSwitchInstruction tsi -> {\n+                    jumpMap.add(tsi.defaultTarget(), bci);\n+                    for (var c : tsi.cases()) {\n+                        jumpMap.add(c.target(), bci);\n+                    }\n+                }\n+                case LookupSwitchInstruction lsi -> {\n+                    jumpMap.add(lsi.defaultTarget(), bci);\n+                    for (var c : lsi.cases()) {\n+                        jumpMap.add(c.target(), bci);\n+                    }\n+                }\n+                default -> {}\n+            }\n+            if (ce instanceof Instruction i) {\n+                bci += i.sizeInBytes();\n+            }\n+        }\n+\n+        \/\/ Filter and split exception handlers\n+        var exceptionHandlers = new ArrayList<ExceptionCatch>();\n+        for (var eh : codeAttribute.exceptionHandlers()) {\n+            final int tryStart = codeAttribute.labelToBci(eh.tryStart());\n+            final int tryEnd = codeAttribute.labelToBci(eh.tryEnd());\n+            final int handler = codeAttribute.labelToBci(eh.handler());\n+            \/\/ Filter out exception handlers overlapping with try blocks\n+            if (handler >= tryEnd || handler < tryStart) {\n+                Label startLabel = eh.tryStart();\n+                int breakIndex = tryStart;\n+                \/\/ Detect additional exception region entries\n+                while ((breakIndex = targetBcis.nextSetBit(breakIndex + 1)) >= 0 &&  breakIndex < tryEnd) {\n+                    JumpTarget jt = jumpMap.get(breakIndex);\n+                    \/\/ Split the exception region by each external entry (jump from outside of the region)\n+                    if (jt.sourceBcis.stream().anyMatch(sourceBci -> sourceBci < tryStart || sourceBci > tryEnd)) {\n+                        Label breakLabel = jt.target();\n+                        exceptionHandlers.add(ExceptionCatch.of(eh.handler(), startLabel, breakLabel, eh.catchType()));\n+                        startLabel = breakLabel;\n+                    }\n+                }\n+                exceptionHandlers.add(ExceptionCatch.of(eh.handler(), startLabel, eh.tryEnd(), eh.catchType()));\n+            }\n+        }\n+        return exceptionHandlers;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":67,"deletions":5,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -524,0 +524,14 @@\n+    @CodeReflection\n+    static boolean finallyWithLoop(boolean b) {\n+        try {\n+            while (b) {\n+                if (b)\n+                    return false;\n+                b = !b;\n+            }\n+            return true;\n+        } finally {\n+            b = false;\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-        Assert.assertTrue(passed > 33730, String.format(\"\"\"\n+        Assert.assertTrue(passed > 33700, String.format(\"\"\"\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}