{"files":[{"patch":"@@ -177,17 +177,23 @@\n-        var exceptionHandlers = new ArrayList<ExceptionCatch>();\n-        for (var eh : codeAttribute.exceptionHandlers()) {\n-            final int tryStart = codeAttribute.labelToBci(eh.tryStart());\n-            final int tryEnd = codeAttribute.labelToBci(eh.tryEnd());\n-            final int handler = codeAttribute.labelToBci(eh.handler());\n-            \/\/ Filter out exception handlers overlapping with try blocks\n-            if (handler >= tryEnd || handler < tryStart) {\n-                Label startLabel = eh.tryStart();\n-                int breakIndex = tryStart;\n-                \/\/ Detect additional exception region entries\n-                while ((breakIndex = targetBcis.nextSetBit(breakIndex + 1)) >= 0 &&  breakIndex < tryEnd) {\n-                    JumpTarget jt = jumpMap.get(breakIndex);\n-                    \/\/ Split the exception region by each external entry (jump from outside of the region)\n-                    if (jt.sourceBcis.stream().anyMatch(sourceBci -> sourceBci < tryStart || sourceBci > tryEnd)) {\n-                        Label breakLabel = jt.target();\n-                        exceptionHandlers.add(ExceptionCatch.of(eh.handler(), startLabel, breakLabel, eh.catchType()));\n-                        startLabel = breakLabel;\n+        var handlers = codeAttribute.exceptionHandlers();\n+        boolean split;\n+        do {\n+            split = false;\n+            var newHandlers = new ArrayList<ExceptionCatch>();\n+            for (var eh : handlers) {\n+                final int tryStart = codeAttribute.labelToBci(eh.tryStart());\n+                final int tryEnd = codeAttribute.labelToBci(eh.tryEnd());\n+                final int handler = codeAttribute.labelToBci(eh.handler());\n+                \/\/ Filter out exception handlers overlapping with try blocks\n+                if (handler >= tryEnd || handler < tryStart) {\n+                    Label startLabel = eh.tryStart();\n+                    int breakIndex = tryStart;\n+                    \/\/ Detect additional exception region entries\n+                    while ((breakIndex = targetBcis.nextSetBit(breakIndex + 1)) >= 0 &&  breakIndex < tryEnd) {\n+                        JumpTarget jt = jumpMap.get(breakIndex);\n+                        \/\/ Split the exception region by each external entry (jump from outside of the region)\n+                        if (jt.sourceBcis.stream().anyMatch(sourceBci -> sourceBci < tryStart || sourceBci > tryEnd)) {\n+                            Label breakLabel = jt.target();\n+                            newHandlers.add(ExceptionCatch.of(eh.handler(), startLabel, breakLabel, eh.catchType()));\n+                            startLabel = breakLabel;\n+                            split = true;\n+                        }\n@@ -195,0 +201,1 @@\n+                    newHandlers.add(ExceptionCatch.of(eh.handler(), startLabel, eh.tryEnd(), eh.catchType()));\n@@ -196,1 +203,0 @@\n-                exceptionHandlers.add(ExceptionCatch.of(eh.handler(), startLabel, eh.tryEnd(), eh.catchType()));\n@@ -198,2 +204,3 @@\n-        }\n-        return exceptionHandlers;\n+            handlers = newHandlers;\n+        } while (split); \/\/ Each new split may change branch status to an external entry and imply more splits\n+        return handlers;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"}]}