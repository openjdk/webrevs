{"files":[{"patch":"@@ -555,2 +555,1 @@\n-                        TypeKind tk = toTypeKind(first.type());\n-                        if (tk != rvt) conversion(cob, tk, rvt);\n+                        cob.conversion(toTypeKind(first.type()), rvt);\n@@ -874,1 +873,3 @@\n-                        cob.invokedynamic(DynamicCallSiteDesc.of(DMHD_STRING_CONCAT, MethodTypeDesc.of(CD_String, CD_String, CD_String)));\n+                        cob.invokedynamic(DynamicCallSiteDesc.of(DMHD_STRING_CONCAT, MethodTypeDesc.of(CD_String,\n+                                toClassDesc(op.operands().get(0).type()),\n+                                toClassDesc(op.operands().get(1).type()))));\n@@ -923,60 +924,0 @@\n-    \/\/ @@@ this method will apperar in CodeBuilder with next merge\/update from master\n-    static CodeBuilder conversion(CodeBuilder cob, TypeKind fromType, TypeKind toType) {\n-        return switch (fromType) {\n-            case IntType, ByteType, CharType, ShortType, BooleanType ->\n-                    switch (toType) {\n-                        case IntType -> cob;\n-                        case LongType -> cob.i2l();\n-                        case DoubleType -> cob.i2d();\n-                        case FloatType -> cob.i2f();\n-                        case ByteType -> cob.i2b();\n-                        case CharType -> cob.i2c();\n-                        case ShortType -> cob.i2s();\n-                        case BooleanType -> cob.iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case LongType ->\n-                    switch (toType) {\n-                        case IntType -> cob.l2i();\n-                        case LongType -> cob;\n-                        case DoubleType -> cob.l2d();\n-                        case FloatType -> cob.l2f();\n-                        case ByteType -> cob.l2i().i2b();\n-                        case CharType -> cob.l2i().i2c();\n-                        case ShortType -> cob.l2i().i2s();\n-                        case BooleanType -> cob.l2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case DoubleType ->\n-                    switch (toType) {\n-                        case IntType -> cob.d2i();\n-                        case LongType -> cob.d2l();\n-                        case DoubleType -> cob;\n-                        case FloatType -> cob.d2f();\n-                        case ByteType -> cob.d2i().i2b();\n-                        case CharType -> cob.d2i().i2c();\n-                        case ShortType -> cob.d2i().i2s();\n-                        case BooleanType -> cob.d2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case FloatType ->\n-                    switch (toType) {\n-                        case IntType -> cob.f2i();\n-                        case LongType -> cob.f2l();\n-                        case DoubleType -> cob.f2d();\n-                        case FloatType -> cob;\n-                        case ByteType -> cob.f2i().i2b();\n-                        case CharType -> cob.f2i().i2c();\n-                        case ShortType -> cob.f2i().i2s();\n-                        case BooleanType -> cob.f2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case VoidType, ReferenceType ->\n-                throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-        };\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":4,"deletions":63,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+    private static final ClassDesc CD_StringConcatFactory = ClassDesc.ofDescriptor(\"Ljava\/lang\/invoke\/StringConcatFactory;\");\n@@ -121,0 +122,8 @@\n+        ArrayList<ClassDesc> locals = new ArrayList<>();\n+        Stream.concat(Arrays.stream(capturedValues), entryBlock.parameters().stream()).forEachOrdered(val -> {\n+            op(SlotOp.store(locals.size(), val));\n+            ClassDesc locType = BytecodeGenerator.toClassDesc(val.type());\n+            locals.add(locType);\n+            if (TypeKind.from(locType).slotSize() == 2) locals.add(null);\n+        });\n+        this.codeTracker = new LocalsTypeMapper(classModel.thisClass().asSymbol(), locals, smta, elements);\n@@ -133,2 +142,2 @@\n-                            case StackMapFrameInfo.UninitializedVerificationTypeInfo _ ->\n-                                    JavaType.J_L_OBJECT;\n+                            case StackMapFrameInfo.UninitializedVerificationTypeInfo uvti ->\n+                                    JavaType.type(codeTracker.getUninitTypeOf(uvti.newTarget()));\n@@ -137,1 +146,1 @@\n-                        }).toList())))).orElse(Map.of());\n+                        }).toList().reversed())))).orElse(Map.of());\n@@ -139,8 +148,0 @@\n-        ArrayList<ClassDesc> locals = new ArrayList<>();\n-        Stream.concat(Arrays.stream(capturedValues), entryBlock.parameters().stream()).forEachOrdered(val -> {\n-            op(SlotOp.store(locals.size(), val));\n-            ClassDesc locType = BytecodeGenerator.toClassDesc(val.type());\n-            locals.add(locType);\n-            if (TypeKind.from(locType).slotSize() == 2) locals.add(null);\n-        });\n-        this.codeTracker = new LocalsTypeMapper(classModel.thisClass().asSymbol(), locals, smta, elements);\n@@ -311,1 +312,1 @@\n-                    stack.push(op(SlotOp.load(inst.slot(), JavaType.type(codeTracker.getTypeOf(inst)))));\n+                    stack.push(op(SlotOp.load(inst.slot(), JavaType.type(codeTracker.getTypeOf(i)))));\n@@ -444,1 +445,3 @@\n-                    if (inst.bootstrapMethod().owner().equals(CD_LambdaMetafactory)\n+                    DirectMethodHandleDesc bsm = inst.bootstrapMethod();\n+                    ClassDesc bsmOwner = bsm.owner();\n+                    if (bsmOwner.equals(CD_LambdaMetafactory)\n@@ -448,3 +451,0 @@\n-                        LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n-                                FunctionType.functionType(JavaType.type(mtd.returnType()), mtd.parameterList().stream().map(JavaType::type).toList()),\n-                                JavaType.type(inst.typeSymbol().returnType()));\n@@ -458,0 +458,9 @@\n+                        MethodTypeDesc mt = dmhd.invocationType();\n+                        if (capturedValues.length > 0) {\n+                            mt = mt.dropParameterTypes(0, capturedValues.length);\n+                        }\n+                        FunctionType lambdaFunc = FunctionType.functionType(JavaType.type(mt.returnType()),\n+                                                                            mt.parameterList().stream().map(JavaType::type).toList());\n+                        LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n+                                                                lambdaFunc,\n+                                                                JavaType.type(inst.typeSymbol().returnType()));\n@@ -469,4 +478,0 @@\n-                                MethodTypeDesc mt = dmhd.invocationType();\n-                                if (capturedValues.length > 0) {\n-                                    mt = mt.dropParameterTypes(0, capturedValues.length);\n-                                }\n@@ -474,5 +479,4 @@\n-                                        MethodRef.method(\n-                                                JavaType.type(dmhd.owner()),\n-                                                dmhd.methodName(),\n-                                                JavaType.type(mt.returnType()),\n-                                                mt.parameterList().stream().map(JavaType::type).toList()),\n+                                        MethodRef.method(JavaType.type(dmhd.owner()),\n+                                                         dmhd.methodName(),\n+                                                         lambdaFunc.returnType(),\n+                                                         lambdaFunc.parameterTypes()),\n@@ -482,0 +486,31 @@\n+                    } else if (bsmOwner.equals(CD_StringConcatFactory)) {\n+                        int argsCount = inst.typeSymbol().parameterCount();\n+                        Deque<Value> args = new ArrayDeque<>(argsCount);\n+                        for (int ai = 0; ai < argsCount; ai++) {\n+                            args.push(stack.pop());\n+                        }\n+                        Value res = null;\n+                        if (bsm.methodName().equals(\"makeConcat\")) {\n+                            for (Value argVal : args) {\n+                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                            }\n+                        } else {\n+                            assert bsm.methodName().equals(\"makeConcatWithConstants\");\n+                            var bsmArgs = inst.bootstrapArgs();\n+                            String recipe = (String)(bsmArgs.getFirst());\n+                            int bsmArg = 1;\n+                            for (int ri = 0; ri < recipe.length(); ri++) {\n+                                Value argVal = switch (recipe.charAt(ri)) {\n+                                    case '\\u0001' -> args.pop();\n+                                    case '\\u0002' -> liftConstant(bsmArgs.get(bsmArg++));\n+                                    default -> {\n+                                        char c;\n+                                        int start = ri;\n+                                        while (ri < recipe.length() && (c = recipe.charAt(ri)) != '\\u0001' && c != '\\u0002') ri++;\n+                                        yield liftConstant(recipe.substring(start, ri--));\n+                                    }\n+                                };\n+                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                            }\n+                        }\n+                        if (res != null) stack.push(res);\n@@ -493,1 +528,0 @@\n-                        DirectMethodHandleDesc bsm = inst.bootstrapMethod();\n@@ -495,1 +529,1 @@\n-                        MethodRef bsmRef = MethodRef.method(JavaType.type(bsm.owner()),\n+                        MethodRef bsmRef = MethodRef.method(JavaType.type(bsmOwner),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":61,"deletions":27,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.Instruction;\n@@ -32,1 +33,1 @@\n-import java.lang.classfile.attribute.StackMapFrameInfo.ObjectVerificationTypeInfo;\n+import java.lang.classfile.attribute.StackMapFrameInfo.*;\n@@ -47,1 +48,1 @@\n-import java.util.IdentityHashMap;\n+import java.util.HashMap;\n@@ -51,1 +52,1 @@\n-    private final Map<LoadInstruction, ClassDesc> insMap;\n+    private final Map<Integer, ClassDesc> insMap;\n@@ -55,0 +56,1 @@\n+    private final Map<Label, ClassDesc> newMap;\n@@ -60,1 +62,1 @@\n-        this.insMap = new IdentityHashMap<>();\n+        this.insMap = new HashMap<>();\n@@ -67,1 +69,4 @@\n-        codeElements.forEach(this::accept);\n+        this.newMap = computeNewMap(codeElements);\n+        for (int i = 0; i < codeElements.size(); i++) {\n+            accept(i, codeElements.get(i));\n+        }\n@@ -70,1 +75,19 @@\n-    ClassDesc getTypeOf(LoadInstruction li) {\n+    private static Map<Label, ClassDesc> computeNewMap(List<CodeElement> codeElements) {\n+        Map<Label, ClassDesc> newMap = new HashMap<>();\n+        Label lastLabel = null;\n+        for (int i = 0; i < codeElements.size(); i++) {\n+            switch (codeElements.get(i)) {\n+                case LabelTarget lt -> lastLabel = lt.label();\n+                case NewObjectInstruction newI -> {\n+                    if (lastLabel != null) {\n+                        newMap.put(lastLabel, newI.className().asSymbol());\n+                    }\n+                }\n+                case Instruction _ -> lastLabel = null; \/\/invalidate label\n+                default -> {} \/\/skip\n+            }\n+        }\n+        return newMap;\n+    }\n+\n+    ClassDesc getTypeOf(int li) {\n@@ -74,0 +97,4 @@\n+    ClassDesc getUninitTypeOf(Label newLabel) {\n+        return newMap.get(newLabel);\n+    }\n+\n@@ -81,0 +108,1 @@\n+            case ITEM_NULL -> CD_Object;\n@@ -82,1 +110,5 @@\n-            default -> null;\n+            case UninitializedVerificationTypeInfo uvti ->\n+                newMap.computeIfAbsent(uvti.newTarget(), l -> {\n+                    throw new IllegalArgumentException(\"Unitialized type does not point to a new instruction\");\n+                });\n+            case ITEM_TOP -> null;\n@@ -131,1 +163,1 @@\n-    private void accept(CodeElement el) {\n+    private void accept(int elIndex, CodeElement el) {\n@@ -163,1 +195,1 @@\n-                insMap.put(i, locals.get(i.slot()));\n+                insMap.put(elIndex, locals.get(i.slot()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsTypeMapper.java","additions":41,"deletions":9,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -252,0 +252,7 @@\n+    static final int[] MAP = {0, 1, 2, 3, 4};\n+\n+    @CodeReflection\n+    static int deepStackBranches(int a, int b) {\n+        return MAP[a > 2 ? MAP[b > 2 ? 1 : 2] : MAP[b > 2 ? 3 : 4]];\n+    }\n+\n@@ -468,1 +475,6 @@\n-        return a + b;\n+        return \"a\"+ a +\"\\u0001\" + a + \"b\\u0002c\" + b + \"\\u0001\\u0002\" + b + \"dd\";\n+    }\n+\n+    @CodeReflection\n+    static String multiTypeConcat(int i, Boolean b, char c, Short s, float f, Double d) {\n+        return \"i:\"+ i +\" b:\" + b + \" c:\" + c + \" f:\" + f + \" d:\" + d;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.constant.DynamicCallSiteDesc;\n@@ -34,0 +35,1 @@\n+import java.lang.invoke.StringConcatFactory;\n@@ -37,0 +39,1 @@\n+import java.lang.runtime.CodeReflection;\n@@ -70,0 +73,15 @@\n+    @Test\n+    public void testDeepStackJump() throws Throwable {\n+        CoreOp.FuncOp f = getFuncOp(ClassFile.of().build(ClassDesc.of(\"DeepStackJump\"), clb ->\n+                clb.withMethodBody(\"deepStackJump\", MethodTypeDesc.of(ConstantDescs.CD_long), ClassFile.ACC_STATIC, cob -> {\n+                    Label l = cob.newLabel();\n+                    cob.lconst_1().iconst_1().iconst_2()\n+                       .goto_(l)\n+                       .labelBinding(l)\n+                       .iadd().i2l().ladd()\n+                       .lreturn();\n+                })), \"deepStackJump\");\n+\n+        Assert.assertEquals((long) Interpreter.invoke(f), 4);\n+    }\n+\n@@ -108,0 +126,16 @@\n+    @Test\n+    public void testStringMakeConcat() throws Throwable {\n+        byte[] testStringMakeConcat = ClassFile.of().build(ClassDesc.of(\"TestStringMakeConcat\"), clb ->\n+                clb.withMethodBody(\"concatMethod\", MethodTypeDesc.of(ConstantDescs.CD_String), ClassFile.ACC_STATIC, cob ->\n+                        cob.ldc(\"A\").ldc(\"B\").ldc(\"C\")\n+                           .invokedynamic(DynamicCallSiteDesc.of(\n+                                ConstantDescs.ofCallsiteBootstrap(StringConcatFactory.class.describeConstable().get(), \"makeConcat\", ConstantDescs.CD_CallSite),\n+                                MethodTypeDesc.of(ConstantDescs.CD_String, ConstantDescs.CD_String, ConstantDescs.CD_String, ConstantDescs.CD_String)))\n+                           .areturn()));\n+\n+        CoreOp.FuncOp concatMethod = getFuncOp(testStringMakeConcat, \"concatMethod\");\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Assert.assertEquals((String)Interpreter.invoke(lookup, concatMethod), \"ABC\");\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"}]}