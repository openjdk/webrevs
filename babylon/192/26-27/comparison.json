{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.classfile.components.ClassPrinter;\n@@ -33,0 +34,1 @@\n+import java.lang.reflect.code.Block;\n@@ -65,1 +67,1 @@\n-        } catch (Exception e) {\n+        } catch (ReflectiveOperationException e) {\n@@ -95,1 +97,1 @@\n-        Assert.assertTrue(passed > 33890, String.format(\"\"\"\n+        Assert.assertTrue(passed > 33880, String.format(\"\"\"\n@@ -116,1 +118,16 @@\n-                    try {\n+                    boolean vError = false;\n+                    for (var e : ClassFile.of().verify(firstModel.parent().get())) {\n+                        if (!e.getMessage().contains(\"Illegal call to internal method\")) {\n+                            if (!vError) System.out.println(\"--------------------------------------\");\n+                            System.out.println(e);\n+                            vError = true;\n+                        }\n+                    }\n+                    if (vError) {\n+                        System.out.println(path);\n+                        ClassPrinter.toYaml(originalModel, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+                        firstLift.writeTo(System.out);\n+                        ClassPrinter.toYaml(firstModel, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+                        System.out.println(\"--------------------------------------\");\n+                        error(\"first verify\", path.toString());\n+                    } else try {\n@@ -120,10 +137,14 @@\n-\n-                            \/\/ testing only methods passing through\n-                            var firstNormalized = normalize(firstModel);\n-                            var secondNormalized = normalize(secondModel);\n-                            if (!firstNormalized.equals(secondNormalized)) {\n-                                notMatching++;\n-                                System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n-                                printInColumns(firstLift, secondLift);\n-                                printInColumns(firstNormalized, secondNormalized);\n-                                System.out.println();\n+                            for (var e : ClassFile.of().verify(secondModel.parent().get())) {\n+                                if (!e.getMessage().contains(\"Illegal call to internal method\")) {\n+                                    if (!vError) System.out.println(\"--------------------------------------\");\n+                                    System.out.println(e);\n+                                    vError = true;\n+                                }\n+                            }\n+                            if (vError) {\n+\/\/                                System.out.println(path);\n+\/\/                                ClassPrinter.toYaml(firstModel, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+\/\/                                secondLift.writeTo(System.out);\n+\/\/                                ClassPrinter.toYaml(secondModel, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+\/\/                                System.out.println(\"--------------------------------------\");\n+                                error(\"second verify\", path.toString());\n@@ -131,1 +152,12 @@\n-                                passed++;\n+                                \/\/ testing only methods passing through\n+                                var firstNormalized = normalize(firstModel);\n+                                var secondNormalized = normalize(secondModel);\n+                                if (!firstNormalized.equals(secondNormalized)) {\n+                                    notMatching++;\n+\/\/                                    System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n+\/\/                                    printInColumns(firstLift, secondLift);\n+\/\/                                    printInColumns(firstNormalized, secondNormalized);\n+\/\/                                    System.out.println();\n+                                } else {\n+                                    passed++;\n+                                }\n@@ -147,0 +179,15 @@\n+\n+\/\/    private static void printBlockGraph(CoreOp.FuncOp func) {\n+\/\/        for (Block b : func.body().blocks()) {\n+\/\/            System.out.println(b.index() + \": \" + switch (b.terminatingOp()) {\n+\/\/                case CoreOp.ReturnOp _ -> \"return\";\n+\/\/                case CoreOp.ThrowOp _ -> \"throw\";\n+\/\/                case CoreOp.BranchOp br -> \"-> \" + br.branch().targetBlock().index();\n+\/\/                case CoreOp.ConditionalBranchOp br -> \"-> \" + br.trueBranch().targetBlock().index() + \", \" + br.falseBranch().targetBlock().index();\n+\/\/                case CoreOp.ExceptionRegionEnter er -> \"try \" + er.start().targetBlock().index() + \" catch \" + er.catchBlocks().stream().map(r -> String.valueOf(r.targetBlock().index())).collect(Collectors.joining(\", \"));\n+\/\/                case CoreOp.ExceptionRegionExit er -> \" -> exit \" + er.regionStart().parentBlock().index() + \" -> \" + er.end().targetBlock().index();\n+\/\/                default -> b.terminatingOp().opName();\n+\/\/            });\n+\/\/        }\n+\/\/    }\n+\n@@ -253,0 +300,4 @@\n+        error(category, sw.toString());\n+    }\n+\n+    private void error(String category, String msg) {\n@@ -254,1 +305,1 @@\n-                  .compute(sw.toString(), (_, i) -> i == null ? 1 : i + 1);\n+                  .compute(msg, (_, i) -> i == null ? 1 : i + 1);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":66,"deletions":15,"binary":false,"changes":81,"status":"modified"}]}