{"files":[{"patch":"@@ -555,2 +555,1 @@\n-                        TypeKind tk = toTypeKind(first.type());\n-                        if (tk != rvt) conversion(cob, tk, rvt);\n+                        cob.conversion(toTypeKind(first.type()), rvt);\n@@ -874,1 +873,3 @@\n-                        cob.invokedynamic(DynamicCallSiteDesc.of(DMHD_STRING_CONCAT, MethodTypeDesc.of(CD_String, CD_String, CD_String)));\n+                        cob.invokedynamic(DynamicCallSiteDesc.of(DMHD_STRING_CONCAT, MethodTypeDesc.of(CD_String,\n+                                toClassDesc(op.operands().get(0).type()),\n+                                toClassDesc(op.operands().get(1).type()))));\n@@ -923,60 +924,0 @@\n-    \/\/ @@@ this method will apperar in CodeBuilder with next merge\/update from master\n-    static CodeBuilder conversion(CodeBuilder cob, TypeKind fromType, TypeKind toType) {\n-        return switch (fromType) {\n-            case IntType, ByteType, CharType, ShortType, BooleanType ->\n-                    switch (toType) {\n-                        case IntType -> cob;\n-                        case LongType -> cob.i2l();\n-                        case DoubleType -> cob.i2d();\n-                        case FloatType -> cob.i2f();\n-                        case ByteType -> cob.i2b();\n-                        case CharType -> cob.i2c();\n-                        case ShortType -> cob.i2s();\n-                        case BooleanType -> cob.iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case LongType ->\n-                    switch (toType) {\n-                        case IntType -> cob.l2i();\n-                        case LongType -> cob;\n-                        case DoubleType -> cob.l2d();\n-                        case FloatType -> cob.l2f();\n-                        case ByteType -> cob.l2i().i2b();\n-                        case CharType -> cob.l2i().i2c();\n-                        case ShortType -> cob.l2i().i2s();\n-                        case BooleanType -> cob.l2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case DoubleType ->\n-                    switch (toType) {\n-                        case IntType -> cob.d2i();\n-                        case LongType -> cob.d2l();\n-                        case DoubleType -> cob;\n-                        case FloatType -> cob.d2f();\n-                        case ByteType -> cob.d2i().i2b();\n-                        case CharType -> cob.d2i().i2c();\n-                        case ShortType -> cob.d2i().i2s();\n-                        case BooleanType -> cob.d2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case FloatType ->\n-                    switch (toType) {\n-                        case IntType -> cob.f2i();\n-                        case LongType -> cob.f2l();\n-                        case DoubleType -> cob.f2d();\n-                        case FloatType -> cob;\n-                        case ByteType -> cob.f2i().i2b();\n-                        case CharType -> cob.f2i().i2c();\n-                        case ShortType -> cob.f2i().i2s();\n-                        case BooleanType -> cob.f2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case VoidType, ReferenceType ->\n-                throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-        };\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":4,"deletions":63,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+    private static final ClassDesc CD_StringConcatFactory = ClassDesc.ofDescriptor(\"Ljava\/lang\/invoke\/StringConcatFactory;\");\n@@ -121,0 +122,8 @@\n+        ArrayList<ClassDesc> locals = new ArrayList<>();\n+        Stream.concat(Arrays.stream(capturedValues), entryBlock.parameters().stream()).forEachOrdered(val -> {\n+            op(SlotOp.store(locals.size(), val));\n+            ClassDesc locType = BytecodeGenerator.toClassDesc(val.type());\n+            locals.add(locType);\n+            if (TypeKind.from(locType).slotSize() == 2) locals.add(null);\n+        });\n+        this.codeTracker = new LocalsTypeMapper(classModel.thisClass().asSymbol(), locals, smta, elements);\n@@ -133,2 +142,2 @@\n-                            case StackMapFrameInfo.UninitializedVerificationTypeInfo _ ->\n-                                    JavaType.J_L_OBJECT;\n+                            case StackMapFrameInfo.UninitializedVerificationTypeInfo uvti ->\n+                                    JavaType.type(codeTracker.getUninitTypeOf(uvti.newTarget()));\n@@ -137,1 +146,1 @@\n-                        }).toList())))).orElse(Map.of());\n+                        }).toList().reversed())))).orElse(Map.of());\n@@ -139,8 +148,0 @@\n-        ArrayList<ClassDesc> locals = new ArrayList<>();\n-        Stream.concat(Arrays.stream(capturedValues), entryBlock.parameters().stream()).forEachOrdered(val -> {\n-            op(SlotOp.store(locals.size(), val));\n-            ClassDesc locType = BytecodeGenerator.toClassDesc(val.type());\n-            locals.add(locType);\n-            if (TypeKind.from(locType).slotSize() == 2) locals.add(null);\n-        });\n-        this.codeTracker = new LocalsTypeMapper(classModel.thisClass().asSymbol(), locals, smta, elements);\n@@ -311,1 +312,1 @@\n-                    stack.push(op(SlotOp.load(inst.slot(), JavaType.type(codeTracker.getTypeOf(inst)))));\n+                    stack.push(op(SlotOp.load(inst.slot(), JavaType.type(codeTracker.getTypeOf(i)))));\n@@ -444,1 +445,3 @@\n-                    if (inst.bootstrapMethod().owner().equals(CD_LambdaMetafactory)\n+                    DirectMethodHandleDesc bsm = inst.bootstrapMethod();\n+                    ClassDesc bsmOwner = bsm.owner();\n+                    if (bsmOwner.equals(CD_LambdaMetafactory)\n@@ -448,3 +451,0 @@\n-                        LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n-                                FunctionType.functionType(JavaType.type(mtd.returnType()), mtd.parameterList().stream().map(JavaType::type).toList()),\n-                                JavaType.type(inst.typeSymbol().returnType()));\n@@ -458,0 +458,9 @@\n+                        MethodTypeDesc mt = dmhd.invocationType();\n+                        if (capturedValues.length > 0) {\n+                            mt = mt.dropParameterTypes(0, capturedValues.length);\n+                        }\n+                        FunctionType lambdaFunc = FunctionType.functionType(JavaType.type(mt.returnType()),\n+                                                                            mt.parameterList().stream().map(JavaType::type).toList());\n+                        LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n+                                                                lambdaFunc,\n+                                                                JavaType.type(inst.typeSymbol().returnType()));\n@@ -469,4 +478,0 @@\n-                                MethodTypeDesc mt = dmhd.invocationType();\n-                                if (capturedValues.length > 0) {\n-                                    mt = mt.dropParameterTypes(0, capturedValues.length);\n-                                }\n@@ -474,5 +479,4 @@\n-                                        MethodRef.method(\n-                                                JavaType.type(dmhd.owner()),\n-                                                dmhd.methodName(),\n-                                                JavaType.type(mt.returnType()),\n-                                                mt.parameterList().stream().map(JavaType::type).toList()),\n+                                        MethodRef.method(JavaType.type(dmhd.owner()),\n+                                                         dmhd.methodName(),\n+                                                         lambdaFunc.returnType(),\n+                                                         lambdaFunc.parameterTypes()),\n@@ -482,0 +486,31 @@\n+                    } else if (bsmOwner.equals(CD_StringConcatFactory)) {\n+                        int argsCount = inst.typeSymbol().parameterCount();\n+                        Deque<Value> args = new ArrayDeque<>(argsCount);\n+                        for (int ai = 0; ai < argsCount; ai++) {\n+                            args.push(stack.pop());\n+                        }\n+                        Value res = null;\n+                        if (bsm.methodName().equals(\"makeConcat\")) {\n+                            for (Value argVal : args) {\n+                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                            }\n+                        } else {\n+                            assert bsm.methodName().equals(\"makeConcatWithConstants\");\n+                            var bsmArgs = inst.bootstrapArgs();\n+                            String recipe = (String)(bsmArgs.getFirst());\n+                            int bsmArg = 1;\n+                            for (int ri = 0; ri < recipe.length(); ri++) {\n+                                Value argVal = switch (recipe.charAt(ri)) {\n+                                    case '\\u0001' -> args.pop();\n+                                    case '\\u0002' -> liftConstant(bsmArgs.get(bsmArg++));\n+                                    default -> {\n+                                        char c;\n+                                        int start = ri;\n+                                        while (ri < recipe.length() && (c = recipe.charAt(ri)) != '\\u0001' && c != '\\u0002') ri++;\n+                                        yield liftConstant(recipe.substring(start, ri--));\n+                                    }\n+                                };\n+                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                            }\n+                        }\n+                        if (res != null) stack.push(res);\n@@ -493,1 +528,0 @@\n-                        DirectMethodHandleDesc bsm = inst.bootstrapMethod();\n@@ -495,1 +529,1 @@\n-                        MethodRef bsmRef = MethodRef.method(JavaType.type(bsm.owner()),\n+                        MethodRef bsmRef = MethodRef.method(JavaType.type(bsmOwner),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":61,"deletions":27,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.Instruction;\n@@ -32,1 +33,1 @@\n-import java.lang.classfile.attribute.StackMapFrameInfo.ObjectVerificationTypeInfo;\n+import java.lang.classfile.attribute.StackMapFrameInfo.*;\n@@ -41,1 +42,0 @@\n-import java.util.function.Function;\n@@ -47,1 +47,1 @@\n-import java.util.IdentityHashMap;\n+import java.util.HashMap;\n@@ -51,1 +51,3 @@\n-    private final Map<LoadInstruction, ClassDesc> insMap;\n+    record Frame(List<ClassDesc> stack, List<ClassDesc> locals) {}\n+\n+    private final Map<Integer, ClassDesc> insMap;\n@@ -54,1 +56,3 @@\n-    private final Map<Label, StackMapFrameInfo> stackMap;\n+    private final Map<Label, Frame> stackMap;\n+    private final Map<Label, ClassDesc> newMap;\n+    private boolean frameDirty;\n@@ -60,1 +64,1 @@\n-        this.insMap = new IdentityHashMap<>();\n+        this.insMap = new HashMap<>();\n@@ -63,1 +67,2 @@\n-        this.locals = new ArrayList<>(initFrameLocals);\n+        this.locals = new ArrayList<>(initFrameLocals.size());\n+        this.newMap = computeNewMap(codeElements);\n@@ -66,2 +71,24 @@\n-                Function.identity()))).orElse(Map.of());\n-        codeElements.forEach(this::accept);\n+                this::toFrame))).orElse(Map.of());\n+        do {\n+            this.locals.addAll(initFrameLocals);\n+            this.frameDirty = false;\n+            for (int i = 0; i < codeElements.size(); i++) {\n+                accept(i, codeElements.get(i));\n+            }\n+            endOfFlow();\n+        } while (this.frameDirty);\n+    }\n+\n+    private Frame toFrame(StackMapFrameInfo smfi) {\n+        List<ClassDesc> fstack = new ArrayList<>(smfi.stack().size());\n+        List<ClassDesc> flocals = new ArrayList<>(smfi.locals().size() * 2);\n+        for (var vti : smfi.stack().reversed()) {\n+            fstack.add(vtiToStackType(vti));\n+        }\n+        for (var vti : smfi.locals()) {\n+            flocals.add(vtiToStackType(vti));\n+            if (vti == ITEM_DOUBLE || vti == ITEM_LONG) {\n+                flocals.add(null);\n+            }\n+        }\n+        return new Frame(fstack, flocals);\n@@ -70,1 +97,19 @@\n-    ClassDesc getTypeOf(LoadInstruction li) {\n+    private static Map<Label, ClassDesc> computeNewMap(List<CodeElement> codeElements) {\n+        Map<Label, ClassDesc> newMap = new HashMap<>();\n+        Label lastLabel = null;\n+        for (int i = 0; i < codeElements.size(); i++) {\n+            switch (codeElements.get(i)) {\n+                case LabelTarget lt -> lastLabel = lt.label();\n+                case NewObjectInstruction newI -> {\n+                    if (lastLabel != null) {\n+                        newMap.put(lastLabel, newI.className().asSymbol());\n+                    }\n+                }\n+                case Instruction _ -> lastLabel = null; \/\/invalidate label\n+                default -> {} \/\/skip\n+            }\n+        }\n+        return newMap;\n+    }\n+\n+    ClassDesc getTypeOf(int li) {\n@@ -74,0 +119,4 @@\n+    ClassDesc getUninitTypeOf(Label newLabel) {\n+        return newMap.get(newLabel);\n+    }\n+\n@@ -81,0 +130,1 @@\n+            case ITEM_NULL -> CD_Object;\n@@ -82,1 +132,5 @@\n-            default -> null;\n+            case UninitializedVerificationTypeInfo uvti ->\n+                newMap.computeIfAbsent(uvti.newTarget(), l -> {\n+                    throw new IllegalArgumentException(\"Unitialized type does not point to a new instruction\");\n+                });\n+            case ITEM_TOP -> null;\n@@ -131,1 +185,1 @@\n-    private void accept(CodeElement el) {\n+    private void accept(int elIndex, CodeElement el) {\n@@ -137,2 +191,16 @@\n-            case BranchInstruction i when !i.opcode().isUnconditionalBranch() ->\n-                pop(1);\n+            case BranchInstruction i -> {\n+                switch (i.opcode()) {\n+                    case IFEQ, IFGE, IFGT, IFLE, IFLT, IFNE, IFNONNULL, IFNULL -> {\n+                        pop();\n+                        mergeToTargetFrame(i.target());\n+                    }\n+                    case IF_ACMPEQ, IF_ACMPNE, IF_ICMPEQ, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ICMPLT, IF_ICMPNE -> {\n+                        pop(2);\n+                        mergeToTargetFrame(i.target());\n+                    }\n+                    case GOTO, GOTO_W -> {\n+                        mergeToTargetFrame(i.target());\n+                        endOfFlow();\n+                    }\n+                }\n+            }\n@@ -163,1 +231,1 @@\n-                insMap.put(i, locals.get(i.slot()));\n+                insMap.put(elIndex, locals.get(i.slot()));\n@@ -216,11 +284,5 @@\n-                var smfi = stackMap.get(lt.label());\n-                if (smfi != null) {\n-                    stack.clear();\n-                    for (var vti : smfi.stack()) {\n-                        push(vtiToStackType(vti));\n-                    }\n-                    locals.clear();\n-                    int slot = 0;\n-                    for (var vti : smfi.locals()) {\n-                        store(slot, vtiToStackType(vti));\n-                        slot += (vti == ITEM_DOUBLE || vti == ITEM_LONG) ? 2 : 1;\n+                var frame = stackMap.get(lt.label());\n+                if (frame != null) {\n+                    if (!stack.isEmpty() || !locals.isEmpty()) {\n+                        mergeToTargetFrame(lt.label());\n+                        endOfFlow();\n@@ -228,0 +290,20 @@\n+                    stack.addAll(frame.stack());\n+                    locals.addAll(frame.locals());\n+                }\n+            }\n+            case ReturnInstruction _ , ThrowInstruction _ -> {\n+                endOfFlow();\n+            }\n+            case TableSwitchInstruction tsi -> {\n+                pop();\n+                mergeToTargetFrame(tsi.defaultTarget());\n+                for (var c : tsi.cases()) {\n+                    mergeToTargetFrame(c.target());\n+                }\n+                endOfFlow();\n+            }\n+            case LookupSwitchInstruction lsi -> {\n+                pop();\n+                mergeToTargetFrame(lsi.defaultTarget());\n+                for (var c : lsi.cases()) {\n+                    mergeToTargetFrame(c.target());\n@@ -229,0 +311,1 @@\n+                endOfFlow();\n@@ -233,0 +316,29 @@\n+\n+    private void endOfFlow() {\n+        stack.clear();\n+        locals.clear();\n+    }\n+\n+    private void mergeToTargetFrame(Label target) {\n+        Frame targetFrame = stackMap.get(target);\n+        \/\/ Merge stack\n+        assert stack.size() == targetFrame.stack.size();\n+        for (int i = 0; i < targetFrame.stack.size(); i++) {\n+            ClassDesc se = stack.get(i);\n+            ClassDesc fe = targetFrame.stack.get(i);\n+            if (!se.equals(fe) && se.isPrimitive() && CD_int.equals(fe)) {\n+                targetFrame.stack.set(i, se);\n+                this.frameDirty = true;\n+            }\n+        }\n+        \/\/ Merge locals\n+        int lSize = Math.min(locals.size(), targetFrame.locals.size());\n+        for (int i = 0; i < lSize; i++) {\n+            ClassDesc le = locals.get(i);\n+            ClassDesc fe = targetFrame.locals.get(i);\n+            if (le != null && !le.equals(fe) && le.isPrimitive() && CD_int.equals(fe)) {\n+                targetFrame.locals.set(i, le);\n+                this.frameDirty = true;\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsTypeMapper.java","additions":138,"deletions":26,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -252,0 +252,7 @@\n+    static final int[] MAP = {0, 1, 2, 3, 4};\n+\n+    @CodeReflection\n+    static int deepStackBranches(boolean a, boolean b) {\n+        return MAP[a ? MAP[b ? 1 : 2] : MAP[b ? 3 : 4]];\n+    }\n+\n@@ -468,1 +475,6 @@\n-        return a + b;\n+        return \"a\"+ a +\"\\u0001\" + a + \"b\\u0002c\" + b + \"\\u0001\\u0002\" + b + \"dd\";\n+    }\n+\n+    @CodeReflection\n+    static String multiTypeConcat(int i, Boolean b, char c, Short s, float f, Double d) {\n+        return \"i:\"+ i +\" b:\" + b + \" c:\" + c + \" f:\" + f + \" d:\" + d;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.constant.DynamicCallSiteDesc;\n@@ -34,0 +35,1 @@\n+import java.lang.invoke.StringConcatFactory;\n@@ -37,0 +39,1 @@\n+import java.lang.runtime.CodeReflection;\n@@ -70,0 +73,15 @@\n+    @Test\n+    public void testDeepStackJump() throws Throwable {\n+        CoreOp.FuncOp f = getFuncOp(ClassFile.of().build(ClassDesc.of(\"DeepStackJump\"), clb ->\n+                clb.withMethodBody(\"deepStackJump\", MethodTypeDesc.of(ConstantDescs.CD_long), ClassFile.ACC_STATIC, cob -> {\n+                    Label l = cob.newLabel();\n+                    cob.lconst_1().iconst_1().iconst_2()\n+                       .goto_(l)\n+                       .labelBinding(l)\n+                       .iadd().i2l().ladd()\n+                       .lreturn();\n+                })), \"deepStackJump\");\n+\n+        Assert.assertEquals((long) Interpreter.invoke(f), 4);\n+    }\n+\n@@ -108,0 +126,16 @@\n+    @Test\n+    public void testStringMakeConcat() throws Throwable {\n+        byte[] testStringMakeConcat = ClassFile.of().build(ClassDesc.of(\"TestStringMakeConcat\"), clb ->\n+                clb.withMethodBody(\"concatMethod\", MethodTypeDesc.of(ConstantDescs.CD_String), ClassFile.ACC_STATIC, cob ->\n+                        cob.ldc(\"A\").ldc(\"B\").ldc(\"C\")\n+                           .invokedynamic(DynamicCallSiteDesc.of(\n+                                ConstantDescs.ofCallsiteBootstrap(StringConcatFactory.class.describeConstable().get(), \"makeConcat\", ConstantDescs.CD_CallSite),\n+                                MethodTypeDesc.of(ConstantDescs.CD_String, ConstantDescs.CD_String, ConstantDescs.CD_String, ConstantDescs.CD_String)))\n+                           .areturn()));\n+\n+        CoreOp.FuncOp concatMethod = getFuncOp(testStringMakeConcat, \"concatMethod\");\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Assert.assertEquals((String)Interpreter.invoke(lookup, concatMethod), \"ABC\");\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.lang.reflect.AccessFlag;\n-import java.lang.reflect.code.Op;\n@@ -88,1 +86,1 @@\n-        Assert.assertTrue(passed > 29000, String.format(\"\"\"\n+        Assert.assertTrue(passed > 29300, String.format(\"\"\"\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}