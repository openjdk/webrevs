{"files":[{"patch":"@@ -182,1 +182,1 @@\n-                    new BytecodeGenerator(lookup, className, capturedValues, new Liveness(iop),\n+                    new BytecodeGenerator(lookup, className, capturedValues, TypeKind.from(mtd.returnType()), new Liveness(iop),\n@@ -192,0 +192,1 @@\n+    private final TypeKind returnType;\n@@ -206,0 +207,1 @@\n+                              TypeKind returnType,\n@@ -214,0 +216,1 @@\n+        this.returnType = returnType;\n@@ -243,0 +246,3 @@\n+        if (blockIndex == blockLabels.length) {\n+            return cob.endLabel();\n+        }\n@@ -465,9 +471,12 @@\n-                Label startLabel = getLabel(start);\n-                Label endLabel = getLabel(end);\n-                for (Block.Reference cbr : erNode.ere.catchBlocks()) {\n-                    List<Block.Parameter> params = cbr.targetBlock().parameters();\n-                    if (!params.isEmpty()) {\n-                        JavaType jt = (JavaType) params.get(0).type();\n-                        cob.exceptionCatch(startLabel, endLabel, getLabel(cbr), jt.toNominalDescriptor());\n-                    } else {\n-                        cob.exceptionCatchAll(startLabel, endLabel, getLabel(cbr));\n+                \/\/ Avoid declaration of empty exception regions\n+                if (!(blocks.get(start).firstOp() instanceof ExceptionRegionExit erEx) || erEx.end().targetBlock().index() != end) {\n+                    Label startLabel = getLabel(start);\n+                    Label endLabel = getLabel(end);\n+                    for (Block.Reference cbr : erNode.ere.catchBlocks()) {\n+                        List<Block.Parameter> params = cbr.targetBlock().parameters();\n+                        if (!params.isEmpty()) {\n+                            JavaType jt = (JavaType) params.get(0).type();\n+                            cob.exceptionCatch(startLabel, endLabel, getLabel(cbr), jt.toNominalDescriptor());\n+                        } else {\n+                            cob.exceptionCatchAll(startLabel, endLabel, getLabel(cbr));\n+                        }\n@@ -555,2 +564,1 @@\n-                        TypeKind tk = toTypeKind(first.type());\n-                        if (tk != rvt) conversion(cob, tk, rvt);\n+                        cob.conversion(toTypeKind(first.type()), rvt);\n@@ -874,1 +882,3 @@\n-                        cob.invokedynamic(DynamicCallSiteDesc.of(DMHD_STRING_CONCAT, MethodTypeDesc.of(CD_String, CD_String, CD_String)));\n+                        cob.invokedynamic(DynamicCallSiteDesc.of(DMHD_STRING_CONCAT, MethodTypeDesc.of(CD_String,\n+                                toClassDesc(op.operands().get(0).type()),\n+                                toClassDesc(op.operands().get(1).type()))));\n@@ -884,4 +894,1 @@\n-                    Value a = op.returnValue();\n-                    if (a == null) {\n-                        cob.return_();\n-                    } else {\n+                    if (returnType != TypeKind.VoidType) {\n@@ -889,1 +896,1 @@\n-                        cob.return_(toTypeKind(a.type()));\n+                        \/\/ @@@ box, unbox, cast here ?\n@@ -891,0 +898,1 @@\n+                    cob.return_(returnType);\n@@ -923,60 +931,0 @@\n-    \/\/ @@@ this method will apperar in CodeBuilder with next merge\/update from master\n-    static CodeBuilder conversion(CodeBuilder cob, TypeKind fromType, TypeKind toType) {\n-        return switch (fromType) {\n-            case IntType, ByteType, CharType, ShortType, BooleanType ->\n-                    switch (toType) {\n-                        case IntType -> cob;\n-                        case LongType -> cob.i2l();\n-                        case DoubleType -> cob.i2d();\n-                        case FloatType -> cob.i2f();\n-                        case ByteType -> cob.i2b();\n-                        case CharType -> cob.i2c();\n-                        case ShortType -> cob.i2s();\n-                        case BooleanType -> cob.iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case LongType ->\n-                    switch (toType) {\n-                        case IntType -> cob.l2i();\n-                        case LongType -> cob;\n-                        case DoubleType -> cob.l2d();\n-                        case FloatType -> cob.l2f();\n-                        case ByteType -> cob.l2i().i2b();\n-                        case CharType -> cob.l2i().i2c();\n-                        case ShortType -> cob.l2i().i2s();\n-                        case BooleanType -> cob.l2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case DoubleType ->\n-                    switch (toType) {\n-                        case IntType -> cob.d2i();\n-                        case LongType -> cob.d2l();\n-                        case DoubleType -> cob;\n-                        case FloatType -> cob.d2f();\n-                        case ByteType -> cob.d2i().i2b();\n-                        case CharType -> cob.d2i().i2c();\n-                        case ShortType -> cob.d2i().i2s();\n-                        case BooleanType -> cob.d2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case FloatType ->\n-                    switch (toType) {\n-                        case IntType -> cob.f2i();\n-                        case LongType -> cob.f2l();\n-                        case DoubleType -> cob.f2d();\n-                        case FloatType -> cob;\n-                        case ByteType -> cob.f2i().i2b();\n-                        case CharType -> cob.f2i().i2c();\n-                        case ShortType -> cob.f2i().i2s();\n-                        case BooleanType -> cob.f2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case VoidType, ReferenceType ->\n-                throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-        };\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":26,"deletions":78,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -42,0 +43,1 @@\n+import java.lang.constant.ConstantDesc;\n@@ -43,0 +45,5 @@\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n@@ -44,1 +51,0 @@\n-\n@@ -51,1 +57,0 @@\n-import java.lang.reflect.code.type.MethodRef;\n@@ -54,0 +59,3 @@\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.reflect.code.type.VarType;\n@@ -56,0 +64,1 @@\n+import java.util.Arrays;\n@@ -61,0 +70,1 @@\n+import java.util.function.BiFunction;\n@@ -63,13 +73,0 @@\n-import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n-import java.lang.constant.ConstantDesc;\n-import static java.lang.constant.ConstantDescs.CD_void;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.reflect.code.op.CoreOp.LambdaOp;\n-import java.lang.reflect.code.type.PrimitiveType;\n-import java.lang.reflect.code.type.VarType;\n-import java.util.Arrays;\n-import java.util.function.BiFunction;\n@@ -78,0 +75,1 @@\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n@@ -82,0 +80,1 @@\n+    private static final ClassDesc CD_StringConcatFactory = ClassDesc.ofDescriptor(\"Ljava\/lang\/invoke\/StringConcatFactory;\");\n@@ -105,0 +104,1 @@\n+    private final CodeAttribute codeAttribtue;\n@@ -111,0 +111,1 @@\n+    private final ArrayDeque<ExceptionRegion> exceptionRegionStack;\n@@ -117,1 +118,5 @@\n-        this.exceptionHandlers = codeModel.exceptionHandlers();\n+        this.codeAttribtue = (CodeAttribute)codeModel;\n+        \/\/ Filter out exception handlers overlapping with try blocks\n+        this.exceptionHandlers = codeModel.exceptionHandlers().stream().filter(\n+                eh -> codeAttribtue.labelToBci(eh.handler()) >= codeAttribtue.labelToBci(eh.tryEnd())\n+                   || codeAttribtue.labelToBci(eh.handler()) < codeAttribtue.labelToBci(eh.tryStart())).toList();\n@@ -121,18 +126,0 @@\n-        this.blockMap = smta.map(sma ->\n-                sma.entries().stream().collect(Collectors.toUnmodifiableMap(\n-                        StackMapFrameInfo::target,\n-                        smfi -> entryBlock.block(smfi.stack().stream().map(vti -> (TypeElement)switch (vti) {\n-                            case ITEM_INTEGER -> JavaType.INT;\n-                            case ITEM_FLOAT -> JavaType.FLOAT;\n-                            case ITEM_DOUBLE -> JavaType.DOUBLE;\n-                            case ITEM_LONG -> JavaType.LONG;\n-                            case ITEM_NULL -> JavaType.J_L_OBJECT;\n-                            case ITEM_UNINITIALIZED_THIS -> JavaType.type(classModel.thisClass().asSymbol());\n-                            case StackMapFrameInfo.ObjectVerificationTypeInfo ovti ->\n-                                    JavaType.type(ovti.classSymbol());\n-                            case StackMapFrameInfo.UninitializedVerificationTypeInfo _ ->\n-                                    JavaType.J_L_OBJECT;\n-                            default ->\n-                                throw new IllegalArgumentException(\"Unexpected VTI: \" + vti);\n-                        }).toList())))).orElse(Map.of());\n-\n@@ -147,0 +134,4 @@\n+        this.blockMap = smta.map(sma ->\n+                sma.entries().stream().collect(Collectors.toUnmodifiableMap(\n+                        StackMapFrameInfo::target,\n+                        smfi -> entryBlock.block(toBlockParams(smfi.stack()))))).orElseGet(Map::of);\n@@ -148,0 +139,26 @@\n+        this.exceptionRegionStack = new ArrayDeque<>();\n+    }\n+\n+    private List<TypeElement> toBlockParams(List<StackMapFrameInfo.VerificationTypeInfo> vtis) {\n+        ArrayList<TypeElement> params = new ArrayList<>(vtis.size());\n+        for (int i = vtis.size() - 1; i >= 0; i--) {\n+            var vti = vtis.get(i);\n+            switch (vti) {\n+                case ITEM_INTEGER -> params.add(JavaType.INT);\n+                case ITEM_FLOAT -> params.add(JavaType.FLOAT);\n+                case ITEM_DOUBLE -> params.add(JavaType.DOUBLE);\n+                case ITEM_LONG -> params.add(JavaType.LONG);\n+                case ITEM_NULL -> params.add(JavaType.J_L_OBJECT);\n+                case ITEM_UNINITIALIZED_THIS ->\n+                    params.add(JavaType.type(classModel.thisClass().asSymbol()));\n+                case StackMapFrameInfo.ObjectVerificationTypeInfo ovti ->\n+                    params.add(JavaType.type(ovti.classSymbol()));\n+\n+                    \/\/ Unitialized entry (a new object before its constructor is called)\n+                    \/\/ must be skipped from block parameters because they do not exist in code reflection model\n+                case StackMapFrameInfo.UninitializedVerificationTypeInfo _ -> {}\n+                default ->\n+                    throw new IllegalArgumentException(\"Unexpected VTI: \" + vti);\n+            }\n+        }\n+        return params;\n@@ -186,12 +203,0 @@\n-    private Block.Builder getBlock(Label l) {\n-        Block.Builder bb = blockMap.get(l);\n-        if (bb == null) {\n-            if (currentBlock == null) {\n-                throw new IllegalArgumentException(\"Block without an stack frame detected.\");\n-            } else {\n-                return newBlock();\n-            }\n-        }\n-        return bb;\n-    }\n-\n@@ -202,0 +207,4 @@\n+    private Block.Builder newBlock(List<Block.Parameter> otherBlockParams) {\n+        return entryBlock.block(otherBlockParams.stream().map(Block.Parameter::type).toList());\n+    }\n+\n@@ -219,0 +228,18 @@\n+    record ExceptionRegion(Op.Result enter, Label startLabel, Label endLabel) {}\n+\n+    private Block.Builder insertExceptionRegionExits(Label targetLabel) {\n+        Block.Builder targetBlock = blockMap.get(targetLabel);\n+        for (ExceptionRegion er : exceptionRegionStack) {\n+            int targetBci = codeAttribtue.labelToBci(targetLabel);\n+            if (targetBci < codeAttribtue.labelToBci(er.startLabel()) || targetBci > codeAttribtue.labelToBci(er.endLabel())) {\n+                \/\/ Branching out of the exception region, need to insert a block with ExceptionRegionExit\n+                Block.Builder next = newBlock(targetBlock.parameters());\n+                next.op(CoreOp.exceptionRegionExit(er.enter(), successor(targetBlock)));\n+                targetBlock = next;\n+            } else {\n+                return targetBlock;\n+            }\n+        }\n+        return targetBlock;\n+    }\n+\n@@ -220,1 +247,0 @@\n-        final Map<ExceptionCatch, Op.Result> exceptionRegionsMap = new HashMap<>();\n@@ -227,0 +253,10 @@\n+                    \/\/ Insert relevant tryEnd blocks\n+                    while (!exceptionRegionStack.isEmpty() && lt.label() == exceptionRegionStack.peek().endLabel()) {\n+                        \/\/ Create exit block with parameters constructed from the stack\n+                        ExceptionRegion er = exceptionRegionStack.pop();\n+                        if (currentBlock != null) {\n+                            Block.Builder next = newBlock();\n+                            op(CoreOp.exceptionRegionExit(er.enter(), successor(next)));\n+                            moveTo(next);\n+                        }\n+                    }\n@@ -228,0 +264,1 @@\n+\n@@ -233,1 +270,1 @@\n-                            op(CoreOp.branch(next.successor(List.copyOf(stack))));\n+                            op(CoreOp.branch(successor(next)));\n@@ -237,0 +274,1 @@\n+\n@@ -239,2 +277,2 @@\n-                        if (lt.label() == ec.tryStart()) {\n-                            Block.Builder handler = getBlock(ec.handler());\n+                        if (lt.label() == ec.tryStart() && ec.tryStart() != ec.tryEnd()) {\n+                            Block.Builder handler = blockMap.get(ec.handler());\n@@ -243,1 +281,1 @@\n-                            Op ere = CoreOp.exceptionRegionEnter(next.successor(List.copyOf(stack)), handler.successor(List.copyOf(stack)));\n+                            Op ere = CoreOp.exceptionRegionEnter(successor(next), handler.successor());\n@@ -245,11 +283,2 @@\n-                            \/\/ Store ERE into map for exit\n-                            exceptionRegionsMap.put(ec, ere.result());\n-                            moveTo(next);\n-                        }\n-                    }\n-                    \/\/ Insert relevant tryEnd blocks in normal order\n-                    for (ExceptionCatch ec : exceptionHandlers) {\n-                        if (lt.label() == ec.tryEnd()) {\n-                            \/\/ Create exit block with parameters constructed from the stack\n-                            next = newBlock();\n-                            op(CoreOp.exceptionRegionExit(exceptionRegionsMap.get(ec), next.successor(List.copyOf(stack))));\n+                            \/\/ Push ExceptionRegion on stack\n+                            exceptionRegionStack.push(new ExceptionRegion(ere.result(), ec.tryStart(), ec.tryEnd()));\n@@ -261,1 +290,1 @@\n-                    op(CoreOp.branch(getBlock(inst.target()).successor(List.copyOf(stack))));\n+                    op(CoreOp.branch(successor(insertExceptionRegionExits(inst.target()))));\n@@ -282,2 +311,2 @@\n-                        case IF_ACMPEQ -> unifyOperands(CoreOp::neq, stack.pop(), operand, TypeKind.IntType);\n-                        case IF_ACMPNE -> unifyOperands(CoreOp::eq, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ACMPEQ -> CoreOp.neq(stack.pop(), operand);\n+                        case IF_ACMPNE -> CoreOp.eq(stack.pop(), operand);\n@@ -286,1 +315,2 @@\n-                    Block.Builder next = newBlock();\n+                    Block.Builder branch = insertExceptionRegionExits(inst.target());\n+                    Block.Builder next = newBlock(branch.parameters());\n@@ -288,2 +318,2 @@\n-                            next.successor(List.copyOf(stack)),\n-                            getBlock(inst.target()).successor(List.copyOf(stack))));\n+                            successor(next),\n+                            successor(branch)));\n@@ -311,1 +341,1 @@\n-                    stack.push(op(SlotOp.load(inst.slot(), JavaType.type(codeTracker.getTypeOf(inst)))));\n+                    stack.push(op(SlotOp.load(inst.slot(), JavaType.type(codeTracker.getTypeOf(i)))));\n@@ -444,1 +474,3 @@\n-                    if (inst.bootstrapMethod().owner().equals(CD_LambdaMetafactory)\n+                    DirectMethodHandleDesc bsm = inst.bootstrapMethod();\n+                    ClassDesc bsmOwner = bsm.owner();\n+                    if (bsmOwner.equals(CD_LambdaMetafactory)\n@@ -448,3 +480,0 @@\n-                        LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n-                                FunctionType.functionType(JavaType.type(mtd.returnType()), mtd.parameterList().stream().map(JavaType::type).toList()),\n-                                JavaType.type(inst.typeSymbol().returnType()));\n@@ -458,0 +487,9 @@\n+                        MethodTypeDesc mt = dmhd.invocationType();\n+                        if (capturedValues.length > 0) {\n+                            mt = mt.dropParameterTypes(0, capturedValues.length);\n+                        }\n+                        FunctionType lambdaFunc = FunctionType.functionType(JavaType.type(mt.returnType()),\n+                                                                            mt.parameterList().stream().map(JavaType::type).toList());\n+                        CoreOp.LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n+                                                                       lambdaFunc,\n+                                                                       JavaType.type(inst.typeSymbol().returnType()));\n@@ -469,11 +507,7 @@\n-                                MethodTypeDesc mt = dmhd.invocationType();\n-                                if (capturedValues.length > 0) {\n-                                    mt = mt.dropParameterTypes(0, capturedValues.length);\n-                                }\n-                                eb.op(CoreOp._return(eb.op(CoreOp.invoke(\n-                                        MethodRef.method(\n-                                                JavaType.type(dmhd.owner()),\n-                                                dmhd.methodName(),\n-                                                JavaType.type(mt.returnType()),\n-                                                mt.parameterList().stream().map(JavaType::type).toList()),\n-                                        Stream.concat(Arrays.stream(capturedValues), eb.parameters().stream()).toArray(Value[]::new)))));\n+                                Op.Result ret = eb.op(CoreOp.invoke(\n+                                        MethodRef.method(JavaType.type(dmhd.owner()),\n+                                                         dmhd.methodName(),\n+                                                         lambdaFunc.returnType(),\n+                                                         lambdaFunc.parameterTypes()),\n+                                        Stream.concat(Arrays.stream(capturedValues), eb.parameters().stream()).toArray(Value[]::new)));\n+                                eb.op(ret.type().equals(JavaType.VOID) ? CoreOp._return() : CoreOp._return(ret));\n@@ -482,0 +516,31 @@\n+                    } else if (bsmOwner.equals(CD_StringConcatFactory)) {\n+                        int argsCount = inst.typeSymbol().parameterCount();\n+                        Deque<Value> args = new ArrayDeque<>(argsCount);\n+                        for (int ai = 0; ai < argsCount; ai++) {\n+                            args.push(stack.pop());\n+                        }\n+                        Value res = null;\n+                        if (bsm.methodName().equals(\"makeConcat\")) {\n+                            for (Value argVal : args) {\n+                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                            }\n+                        } else {\n+                            assert bsm.methodName().equals(\"makeConcatWithConstants\");\n+                            var bsmArgs = inst.bootstrapArgs();\n+                            String recipe = (String)(bsmArgs.getFirst());\n+                            int bsmArg = 1;\n+                            for (int ri = 0; ri < recipe.length(); ri++) {\n+                                Value argVal = switch (recipe.charAt(ri)) {\n+                                    case '\\u0001' -> args.pop();\n+                                    case '\\u0002' -> liftConstant(bsmArgs.get(bsmArg++));\n+                                    default -> {\n+                                        char c;\n+                                        int start = ri;\n+                                        while (ri < recipe.length() && (c = recipe.charAt(ri)) != '\\u0001' && c != '\\u0002') ri++;\n+                                        yield liftConstant(recipe.substring(start, ri--));\n+                                    }\n+                                };\n+                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                            }\n+                        }\n+                        if (res != null) stack.push(res);\n@@ -493,1 +558,0 @@\n-                        DirectMethodHandleDesc bsm = inst.bootstrapMethod();\n@@ -495,1 +559,1 @@\n-                        MethodRef bsmRef = MethodRef.method(JavaType.type(bsm.owner()),\n+                        MethodRef bsmRef = MethodRef.method(JavaType.type(bsmOwner),\n@@ -697,1 +761,1 @@\n-                            CoreOp.invoke(FIND_CONSTRUCTOR, lookup, owner, liftConstant(invDesc.changeReturnType(CD_void)));\n+                            CoreOp.invoke(FIND_CONSTRUCTOR, lookup, owner, liftConstant(invDesc.changeReturnType(ConstantDescs.CD_Void)));\n@@ -749,0 +813,1 @@\n+        Block.Builder def = insertExceptionRegionExits(defaultTarget);\n@@ -750,1 +815,1 @@\n-            Block.Builder next = sc == last ? blockMap.get(defaultTarget) : newBlock();\n+            Block.Builder next = sc == last ? def : newBlock(def.parameters());\n@@ -753,2 +818,2 @@\n-                    blockMap.get(sc.target()).successor(List.copyOf(stack)),\n-                    next.successor(List.copyOf(stack))));\n+                    successor(insertExceptionRegionExits(sc.target())),\n+                    successor(next)));\n@@ -760,0 +825,4 @@\n+    Block.Reference successor(Block.Builder next) {\n+        return next.successor(stack.stream().limit(next.parameters().size()).toList());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":159,"deletions":90,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.Instruction;\n@@ -30,1 +31,0 @@\n-import java.lang.classfile.TypeKind;\n@@ -32,1 +32,1 @@\n-import java.lang.classfile.attribute.StackMapFrameInfo.ObjectVerificationTypeInfo;\n+import java.lang.classfile.attribute.StackMapFrameInfo.*;\n@@ -36,0 +36,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -38,0 +39,1 @@\n+import java.util.HashMap;\n@@ -41,1 +43,0 @@\n-import java.util.function.Function;\n@@ -45,1 +46,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -47,1 +47,3 @@\n-import java.util.IdentityHashMap;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -51,1 +53,3 @@\n-    private final Map<LoadInstruction, ClassDesc> insMap;\n+    record Frame(List<ClassDesc> stack, List<ClassDesc> locals) {}\n+\n+    private final Map<Integer, ClassDesc> insMap;\n@@ -54,1 +58,3 @@\n-    private final Map<Label, StackMapFrameInfo> stackMap;\n+    final Map<Label, Frame> stackMap;\n+    private final Map<Label, ClassDesc> newMap;\n+    private boolean frameDirty;\n@@ -60,1 +66,1 @@\n-        this.insMap = new IdentityHashMap<>();\n+        this.insMap = new HashMap<>();\n@@ -63,1 +69,2 @@\n-        this.locals = new ArrayList<>(initFrameLocals);\n+        this.locals = new ArrayList<>(initFrameLocals.size());\n+        this.newMap = computeNewMap(codeElements);\n@@ -66,2 +73,42 @@\n-                Function.identity()))).orElse(Map.of());\n-        codeElements.forEach(this::accept);\n+                this::toFrame))).orElse(Map.of());\n+        do {\n+            this.locals.addAll(initFrameLocals);\n+            this.frameDirty = false;\n+            for (int i = 0; i < codeElements.size(); i++) {\n+                accept(i, codeElements.get(i));\n+            }\n+            endOfFlow();\n+        } while (this.frameDirty);\n+    }\n+\n+    private Frame toFrame(StackMapFrameInfo smfi) {\n+        List<ClassDesc> fstack = new ArrayList<>(smfi.stack().size());\n+        List<ClassDesc> flocals = new ArrayList<>(smfi.locals().size() * 2);\n+        for (var vti : smfi.stack().reversed()) {\n+            fstack.add(vtiToStackType(vti));\n+        }\n+        for (var vti : smfi.locals()) {\n+            flocals.add(vtiToStackType(vti));\n+            if (vti == ITEM_DOUBLE || vti == ITEM_LONG) {\n+                flocals.add(null);\n+            }\n+        }\n+        return new Frame(fstack, flocals);\n+    }\n+\n+    private static Map<Label, ClassDesc> computeNewMap(List<CodeElement> codeElements) {\n+        Map<Label, ClassDesc> newMap = new HashMap<>();\n+        Label lastLabel = null;\n+        for (int i = 0; i < codeElements.size(); i++) {\n+            switch (codeElements.get(i)) {\n+                case LabelTarget lt -> lastLabel = lt.label();\n+                case NewObjectInstruction newI -> {\n+                    if (lastLabel != null) {\n+                        newMap.put(lastLabel, newI.className().asSymbol());\n+                    }\n+                }\n+                case Instruction _ -> lastLabel = null; \/\/invalidate label\n+                default -> {} \/\/skip\n+            }\n+        }\n+        return newMap;\n@@ -70,1 +117,1 @@\n-    ClassDesc getTypeOf(LoadInstruction li) {\n+    ClassDesc getTypeOf(int li) {\n@@ -74,0 +121,4 @@\n+    ClassDesc getUninitTypeOf(Label newLabel) {\n+        return newMap.get(newLabel);\n+    }\n+\n@@ -81,0 +132,1 @@\n+            case ITEM_NULL -> CD_Object;\n@@ -82,1 +134,5 @@\n-            default -> null;\n+            case UninitializedVerificationTypeInfo uvti ->\n+                newMap.computeIfAbsent(uvti.newTarget(), l -> {\n+                    throw new IllegalArgumentException(\"Unitialized type does not point to a new instruction\");\n+                });\n+            case ITEM_TOP -> null;\n@@ -131,1 +187,1 @@\n-    private void accept(CodeElement el) {\n+    private void accept(int elIndex, CodeElement el) {\n@@ -137,2 +193,16 @@\n-            case BranchInstruction i when !i.opcode().isUnconditionalBranch() ->\n-                pop(1);\n+            case BranchInstruction i -> {\n+                switch (i.opcode()) {\n+                    case IFEQ, IFGE, IFGT, IFLE, IFLT, IFNE, IFNONNULL, IFNULL -> {\n+                        pop();\n+                        mergeToTargetFrame(i.target());\n+                    }\n+                    case IF_ACMPEQ, IF_ACMPNE, IF_ICMPEQ, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ICMPLT, IF_ICMPNE -> {\n+                        pop(2);\n+                        mergeToTargetFrame(i.target());\n+                    }\n+                    case GOTO, GOTO_W -> {\n+                        mergeToTargetFrame(i.target());\n+                        endOfFlow();\n+                    }\n+                }\n+            }\n@@ -140,2 +210,12 @@\n-                push(ClassDesc.ofDescriptor(i.typeKind() == TypeKind.ReferenceType ?\n-                        i.constantValue().getClass().descriptorString() : i.typeKind().descriptor()));\n+                push(switch (i.constantValue()) {\n+                    case null -> CD_Object;\n+                    case ClassDesc _ -> CD_Class;\n+                    case Double _ -> CD_double;\n+                    case Float _ -> CD_float;\n+                    case Integer _ -> CD_int;\n+                    case Long _ -> CD_long;\n+                    case String _ -> CD_String;\n+                    case DynamicConstantDesc<?> cd -> cd.constantType();\n+                    case DirectMethodHandleDesc _ -> CD_MethodHandle;\n+                    case MethodTypeDesc _ -> CD_MethodType;\n+                });\n@@ -163,1 +243,1 @@\n-                insMap.put(i, locals.get(i.slot()));\n+                insMap.put(elIndex, locals.get(i.slot()));\n@@ -216,11 +296,5 @@\n-                var smfi = stackMap.get(lt.label());\n-                if (smfi != null) {\n-                    stack.clear();\n-                    for (var vti : smfi.stack()) {\n-                        push(vtiToStackType(vti));\n-                    }\n-                    locals.clear();\n-                    int slot = 0;\n-                    for (var vti : smfi.locals()) {\n-                        store(slot, vtiToStackType(vti));\n-                        slot += (vti == ITEM_DOUBLE || vti == ITEM_LONG) ? 2 : 1;\n+                var frame = stackMap.get(lt.label());\n+                if (frame != null) {\n+                    if (!stack.isEmpty() || !locals.isEmpty()) {\n+                        mergeToTargetFrame(lt.label());\n+                        endOfFlow();\n@@ -228,0 +302,2 @@\n+                    stack.addAll(frame.stack());\n+                    locals.addAll(frame.locals());\n@@ -230,0 +306,19 @@\n+            case ReturnInstruction _ , ThrowInstruction _ -> {\n+                endOfFlow();\n+            }\n+            case TableSwitchInstruction tsi -> {\n+                pop();\n+                mergeToTargetFrame(tsi.defaultTarget());\n+                for (var c : tsi.cases()) {\n+                    mergeToTargetFrame(c.target());\n+                }\n+                endOfFlow();\n+            }\n+            case LookupSwitchInstruction lsi -> {\n+                pop();\n+                mergeToTargetFrame(lsi.defaultTarget());\n+                for (var c : lsi.cases()) {\n+                    mergeToTargetFrame(c.target());\n+                }\n+                endOfFlow();\n+            }\n@@ -233,0 +328,29 @@\n+\n+    private void endOfFlow() {\n+        stack.clear();\n+        locals.clear();\n+    }\n+\n+    private void mergeToTargetFrame(Label target) {\n+        Frame targetFrame = stackMap.get(target);\n+        \/\/ Merge stack\n+        assert stack.size() == targetFrame.stack.size();\n+        for (int i = 0; i < targetFrame.stack.size(); i++) {\n+            ClassDesc se = stack.get(i);\n+            ClassDesc fe = targetFrame.stack.get(i);\n+            if (!se.equals(fe) && se.isPrimitive() && CD_int.equals(fe)) {\n+                targetFrame.stack.set(i, se);\n+                this.frameDirty = true;\n+            }\n+        }\n+        \/\/ Merge locals\n+        int lSize = Math.min(locals.size(), targetFrame.locals.size());\n+        for (int i = 0; i < lSize; i++) {\n+            ClassDesc le = locals.get(i);\n+            ClassDesc fe = targetFrame.locals.get(i);\n+            if (le != null && !le.equals(fe) && le.isPrimitive() && CD_int.equals(fe)) {\n+                targetFrame.locals.set(i, le);\n+                this.frameDirty = true;\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsTypeMapper.java","additions":154,"deletions":30,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.code.type.PrimitiveType;\n@@ -80,1 +81,1 @@\n-                    if (vl.resultType().equals(v.type())) {\n+                    if (vl.resultType().equals(v.type()) || v.type() instanceof PrimitiveType) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotSSA.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.function.Consumer;\n@@ -242,0 +243,8 @@\n+    @CodeReflection\n+    static int objectsCompare(Boolean b1, Boolean b2, Boolean b3) {\n+        Object a = b1;\n+        Object b = b2;\n+        Object c = b3;\n+        return a == b ? (a != c ? 1 : 2) : (b != c ? 3 : 4);\n+    }\n+\n@@ -252,0 +261,7 @@\n+    static final int[] MAP = {0, 1, 2, 3, 4};\n+\n+    @CodeReflection\n+    static int deepStackBranches(boolean a, boolean b) {\n+        return MAP[a ? MAP[b ? 1 : 2] : MAP[b ? 3 : 4]];\n+    }\n+\n@@ -422,0 +438,15 @@\n+    static void consume(boolean b, Consumer<Object> requireNonNull) {\n+        if (b) {\n+            requireNonNull.accept(new Object());\n+        } else try {\n+            requireNonNull.accept(null);\n+            throw new AssertionError(\"Expectend NPE\");\n+        } catch (NullPointerException expected) {\n+        }\n+    }\n+\n+    @CodeReflection\n+    static void nullReturningMethodHandle(boolean b) {\n+        consume(b, Objects::requireNonNull);\n+    }\n+\n@@ -468,1 +499,6 @@\n-        return a + b;\n+        return \"a\"+ a +\"\\u0001\" + a + \"b\\u0002c\" + b + \"\\u0001\\u0002\" + b + \"dd\";\n+    }\n+\n+    @CodeReflection\n+    static String multiTypeConcat(int i, Boolean b, char c, Short s, float f, Double d) {\n+        return \"i:\"+ i +\" b:\" + b + \" c:\" + c + \" f:\" + f + \" d:\" + d;\n@@ -479,0 +515,9 @@\n+    @CodeReflection\n+    static int excHandlerFollowingSplitTable(boolean b) {\n+        try {\n+            if (b) return 1;\n+            else throw new Exception();\n+        } catch (Exception ex) {}\n+        return 2;\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.constant.DynamicCallSiteDesc;\n@@ -34,0 +35,1 @@\n+import java.lang.invoke.StringConcatFactory;\n@@ -37,0 +39,1 @@\n+import java.lang.runtime.CodeReflection;\n@@ -70,0 +73,15 @@\n+    @Test\n+    public void testDeepStackJump() throws Throwable {\n+        CoreOp.FuncOp f = getFuncOp(ClassFile.of().build(ClassDesc.of(\"DeepStackJump\"), clb ->\n+                clb.withMethodBody(\"deepStackJump\", MethodTypeDesc.of(ConstantDescs.CD_long), ClassFile.ACC_STATIC, cob -> {\n+                    Label l = cob.newLabel();\n+                    cob.lconst_1().iconst_1().iconst_2()\n+                       .goto_(l)\n+                       .labelBinding(l)\n+                       .iadd().i2l().ladd()\n+                       .lreturn();\n+                })), \"deepStackJump\");\n+\n+        Assert.assertEquals((long) Interpreter.invoke(f), 4);\n+    }\n+\n@@ -108,0 +126,16 @@\n+    @Test\n+    public void testStringMakeConcat() throws Throwable {\n+        byte[] testStringMakeConcat = ClassFile.of().build(ClassDesc.of(\"TestStringMakeConcat\"), clb ->\n+                clb.withMethodBody(\"concatMethod\", MethodTypeDesc.of(ConstantDescs.CD_String), ClassFile.ACC_STATIC, cob ->\n+                        cob.ldc(\"A\").ldc(\"B\").ldc(\"C\")\n+                           .invokedynamic(DynamicCallSiteDesc.of(\n+                                ConstantDescs.ofCallsiteBootstrap(StringConcatFactory.class.describeConstable().get(), \"makeConcat\", ConstantDescs.CD_CallSite),\n+                                MethodTypeDesc.of(ConstantDescs.CD_String, ConstantDescs.CD_String, ConstantDescs.CD_String, ConstantDescs.CD_String)))\n+                           .areturn()));\n+\n+        CoreOp.FuncOp concatMethod = getFuncOp(testStringMakeConcat, \"concatMethod\");\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Assert.assertEquals((String)Interpreter.invoke(lookup, concatMethod), \"ABC\");\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.lang.reflect.AccessFlag;\n-import java.lang.reflect.code.Op;\n@@ -55,0 +53,1 @@\n+ * @modules java.base\/java.lang.invoke:open\n@@ -62,0 +61,10 @@\n+    private static final MethodHandles.Lookup TRUSTED_LOOKUP;\n+    static {\n+        try {\n+            var lf = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n+            lf.setAccessible(true);\n+            TRUSTED_LOOKUP = (MethodHandles.Lookup)lf.get(null);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n@@ -88,1 +97,1 @@\n-        Assert.assertTrue(passed > 29000, String.format(\"\"\"\n+        Assert.assertTrue(passed > 33730, String.format(\"\"\"\n@@ -178,1 +187,1 @@\n-                MethodHandles.lookup(),\n+                TRUSTED_LOOKUP,\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"}]}