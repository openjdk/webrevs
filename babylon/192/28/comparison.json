{"files":[{"patch":"@@ -182,1 +182,1 @@\n-                    new BytecodeGenerator(lookup, className, capturedValues, new Liveness(iop),\n+                    new BytecodeGenerator(lookup, className, capturedValues, TypeKind.from(mtd.returnType()), new Liveness(iop),\n@@ -192,0 +192,1 @@\n+    private final TypeKind returnType;\n@@ -206,0 +207,1 @@\n+                              TypeKind returnType,\n@@ -214,0 +216,1 @@\n+        this.returnType = returnType;\n@@ -243,0 +246,3 @@\n+        if (blockIndex == blockLabels.length) {\n+            return cob.endLabel();\n+        }\n@@ -465,9 +471,12 @@\n-                Label startLabel = getLabel(start);\n-                Label endLabel = getLabel(end);\n-                for (Block.Reference cbr : erNode.ere.catchBlocks()) {\n-                    List<Block.Parameter> params = cbr.targetBlock().parameters();\n-                    if (!params.isEmpty()) {\n-                        JavaType jt = (JavaType) params.get(0).type();\n-                        cob.exceptionCatch(startLabel, endLabel, getLabel(cbr), jt.toNominalDescriptor());\n-                    } else {\n-                        cob.exceptionCatchAll(startLabel, endLabel, getLabel(cbr));\n+                \/\/ Avoid declaration of empty exception regions\n+                if (!(blocks.get(start).firstOp() instanceof ExceptionRegionExit erEx) || erEx.end().targetBlock().index() != end) {\n+                    Label startLabel = getLabel(start);\n+                    Label endLabel = getLabel(end);\n+                    for (Block.Reference cbr : erNode.ere.catchBlocks()) {\n+                        List<Block.Parameter> params = cbr.targetBlock().parameters();\n+                        if (!params.isEmpty()) {\n+                            JavaType jt = (JavaType) params.get(0).type();\n+                            cob.exceptionCatch(startLabel, endLabel, getLabel(cbr), jt.toNominalDescriptor());\n+                        } else {\n+                            cob.exceptionCatchAll(startLabel, endLabel, getLabel(cbr));\n+                        }\n@@ -555,2 +564,1 @@\n-                        TypeKind tk = toTypeKind(first.type());\n-                        if (tk != rvt) conversion(cob, tk, rvt);\n+                        cob.conversion(toTypeKind(first.type()), rvt);\n@@ -661,1 +669,1 @@\n-                            case IntType -> cob.ishl();\n+                            case ByteType, CharType, IntType, ShortType -> cob.ishl();\n@@ -694,1 +702,1 @@\n-                        cob.arrayStore(toTypeKind(op.operands().get(2).type()));\n+                        cob.arrayStore(toTypeKind(((ArrayType)op.operands().getFirst().type()).componentType()));\n@@ -760,0 +768,1 @@\n+                        MethodTypeDesc mDesc = MethodRef.toNominalDescriptor(md.type());\n@@ -772,1 +781,1 @@\n-                                MethodRef.toNominalDescriptor(md.type()),\n+                                mDesc,\n@@ -777,1 +786,5 @@\n-\n+                        ClassDesc ret = toClassDesc(op.resultType());\n+                        if (ret.isClassOrInterface() && !ret.equals(mDesc.returnType())) {\n+                            \/\/ Explicit cast if method return type differs\n+                            cob.checkcast(ret);\n+                        }\n@@ -874,1 +887,3 @@\n-                        cob.invokedynamic(DynamicCallSiteDesc.of(DMHD_STRING_CONCAT, MethodTypeDesc.of(CD_String, CD_String, CD_String)));\n+                        cob.invokedynamic(DynamicCallSiteDesc.of(DMHD_STRING_CONCAT, MethodTypeDesc.of(CD_String,\n+                                toClassDesc(op.operands().get(0).type()),\n+                                toClassDesc(op.operands().get(1).type()))));\n@@ -884,4 +899,1 @@\n-                    Value a = op.returnValue();\n-                    if (a == null) {\n-                        cob.return_();\n-                    } else {\n+                    if (returnType != TypeKind.VoidType) {\n@@ -889,1 +901,1 @@\n-                        cob.return_(toTypeKind(a.type()));\n+                        \/\/ @@@ box, unbox, cast here ?\n@@ -891,0 +903,1 @@\n+                    cob.return_(returnType);\n@@ -923,61 +936,1 @@\n-    \/\/ @@@ this method will apperar in CodeBuilder with next merge\/update from master\n-    static CodeBuilder conversion(CodeBuilder cob, TypeKind fromType, TypeKind toType) {\n-        return switch (fromType) {\n-            case IntType, ByteType, CharType, ShortType, BooleanType ->\n-                    switch (toType) {\n-                        case IntType -> cob;\n-                        case LongType -> cob.i2l();\n-                        case DoubleType -> cob.i2d();\n-                        case FloatType -> cob.i2f();\n-                        case ByteType -> cob.i2b();\n-                        case CharType -> cob.i2c();\n-                        case ShortType -> cob.i2s();\n-                        case BooleanType -> cob.iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case LongType ->\n-                    switch (toType) {\n-                        case IntType -> cob.l2i();\n-                        case LongType -> cob;\n-                        case DoubleType -> cob.l2d();\n-                        case FloatType -> cob.l2f();\n-                        case ByteType -> cob.l2i().i2b();\n-                        case CharType -> cob.l2i().i2c();\n-                        case ShortType -> cob.l2i().i2s();\n-                        case BooleanType -> cob.l2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case DoubleType ->\n-                    switch (toType) {\n-                        case IntType -> cob.d2i();\n-                        case LongType -> cob.d2l();\n-                        case DoubleType -> cob;\n-                        case FloatType -> cob.d2f();\n-                        case ByteType -> cob.d2i().i2b();\n-                        case CharType -> cob.d2i().i2c();\n-                        case ShortType -> cob.d2i().i2s();\n-                        case BooleanType -> cob.d2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case FloatType ->\n-                    switch (toType) {\n-                        case IntType -> cob.f2i();\n-                        case LongType -> cob.f2l();\n-                        case DoubleType -> cob.f2d();\n-                        case FloatType -> cob;\n-                        case ByteType -> cob.f2i().i2b();\n-                        case CharType -> cob.f2i().i2c();\n-                        case ShortType -> cob.f2i().i2s();\n-                        case BooleanType -> cob.f2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case VoidType, ReferenceType ->\n-                throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-        };\n-    }\n-\n-    private boolean inBlockArgs(Op.Result res) {\n+    private static boolean inBlockArgs(Op.Result res) {\n@@ -993,0 +946,7 @@\n+    private static boolean moreThanOneUse(Op.Result res) {\n+        Set<Op.Result> uses = res.uses();\n+        return uses.size() > 1\n+            || uses.size() == 1 && uses.iterator().next().op().operands().stream().filter(o -> o == res).count() > 1\n+            || inBlockArgs(res);\n+    }\n+\n@@ -997,1 +957,1 @@\n-            if (res.uses().size() > 1 || inBlockArgs(res)) {\n+            if (moreThanOneUse(res)) {\n@@ -1160,0 +1120,1 @@\n+        boolean jumpingToCatchBlock = catchingBlocks.get(ref.targetBlock().index());\n@@ -1169,1 +1130,3 @@\n-                storeIfUsed(barg);\n+                if (!jumpingToCatchBlock) { \/\/ Catch block expects the exception parameter on stack\n+                    storeIfUsed(barg);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":48,"deletions":85,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -42,0 +43,1 @@\n+import java.lang.constant.ConstantDesc;\n@@ -43,0 +45,5 @@\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n@@ -44,1 +51,0 @@\n-\n@@ -51,1 +57,0 @@\n-import java.lang.reflect.code.type.MethodRef;\n@@ -54,0 +59,3 @@\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.reflect.code.type.VarType;\n@@ -56,0 +64,1 @@\n+import java.util.Arrays;\n@@ -61,0 +70,1 @@\n+import java.util.function.BiFunction;\n@@ -63,13 +73,0 @@\n-import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n-import java.lang.constant.ConstantDesc;\n-import static java.lang.constant.ConstantDescs.CD_void;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.reflect.code.op.CoreOp.LambdaOp;\n-import java.lang.reflect.code.type.PrimitiveType;\n-import java.lang.reflect.code.type.VarType;\n-import java.util.Arrays;\n-import java.util.function.BiFunction;\n@@ -78,0 +75,2 @@\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n+import java.util.BitSet;\n@@ -81,0 +80,3 @@\n+    private record ExceptionRegion(Label startLabel, Label endLabel, Label handlerLabel) {}\n+    private record ExceptionRegionEntry(Op.Result enter, Block.Builder startBlock, ExceptionRegion region) {}\n+\n@@ -82,0 +84,1 @@\n+    private static final ClassDesc CD_StringConcatFactory = ClassDesc.ofDescriptor(\"Ljava\/lang\/invoke\/StringConcatFactory;\");\n@@ -85,2 +88,1 @@\n-    private static final JavaType ARRAYLIST = JavaType.type(ArrayList.class.describeConstable().get());\n-    private static final FunctionType ARRAYLIST_INIT = FunctionType.functionType(ARRAYLIST);\n+    private static final JavaType CLASS_ARRAY = JavaType.array(JavaType.J_L_CLASS);\n@@ -91,1 +93,0 @@\n-    private static final MethodRef ARRAYLIST_ADD = MethodRef.method(ARRAYLIST, \"add\", JavaType.BOOLEAN, JavaType.J_L_OBJECT);\n@@ -101,1 +102,1 @@\n-    private static final MethodRef METHOD_TYPE_L = MethodRef.method(MT, \"methodType\", MT, JavaType.J_L_CLASS, JavaType.J_U_LIST);\n+    private static final MethodRef METHOD_TYPE_L = MethodRef.method(MT, \"methodType\", MT, JavaType.J_L_CLASS, CLASS_ARRAY);\n@@ -105,1 +106,2 @@\n-    private final List<ExceptionCatch> exceptionHandlers;\n+    private final CodeAttribute codeAttribtue;\n+    private final List<ExceptionRegion> exceptionRegions;\n@@ -111,0 +113,1 @@\n+    private final ArrayDeque<ExceptionRegionEntry> exceptionRegionStack;\n@@ -117,1 +120,3 @@\n-        this.exceptionHandlers = codeModel.exceptionHandlers();\n+        this.codeAttribtue = (CodeAttribute)codeModel;\n+        var smta = codeModel.findAttribute(Attributes.stackMapTable());\n+        this.exceptionRegions = extractExceptionRegions(codeAttribtue);\n@@ -120,19 +125,0 @@\n-        var smta = codeModel.findAttribute(Attributes.stackMapTable());\n-        this.blockMap = smta.map(sma ->\n-                sma.entries().stream().collect(Collectors.toUnmodifiableMap(\n-                        StackMapFrameInfo::target,\n-                        smfi -> entryBlock.block(smfi.stack().stream().map(vti -> (TypeElement)switch (vti) {\n-                            case ITEM_INTEGER -> JavaType.INT;\n-                            case ITEM_FLOAT -> JavaType.FLOAT;\n-                            case ITEM_DOUBLE -> JavaType.DOUBLE;\n-                            case ITEM_LONG -> JavaType.LONG;\n-                            case ITEM_NULL -> JavaType.J_L_OBJECT;\n-                            case ITEM_UNINITIALIZED_THIS -> JavaType.type(classModel.thisClass().asSymbol());\n-                            case StackMapFrameInfo.ObjectVerificationTypeInfo ovti ->\n-                                    JavaType.type(ovti.classSymbol());\n-                            case StackMapFrameInfo.UninitializedVerificationTypeInfo _ ->\n-                                    JavaType.J_L_OBJECT;\n-                            default ->\n-                                throw new IllegalArgumentException(\"Unexpected VTI: \" + vti);\n-                        }).toList())))).orElse(Map.of());\n-\n@@ -147,0 +133,4 @@\n+        this.blockMap = smta.map(sma ->\n+                sma.entries().stream().collect(Collectors.toUnmodifiableMap(\n+                        StackMapFrameInfo::target,\n+                        smfi -> entryBlock.block(toBlockParams(smfi.stack()))))).orElseGet(Map::of);\n@@ -148,0 +138,106 @@\n+        this.exceptionRegionStack = new ArrayDeque<>();\n+    }\n+\n+    private static List<ExceptionRegion> extractExceptionRegions(CodeAttribute codeAttribute) {\n+        record JumpTarget(int targetBci, Label target, List<Integer> sourceBcis) {}\n+        BitSet targetBcis = new BitSet(codeAttribute.codeLength());\n+        var jumpMap = new HashMap<Integer, JumpTarget>() {\n+            void add(Label target, int sourceBci) {\n+                computeIfAbsent(codeAttribute.labelToBci(target), targetBci -> {\n+                    targetBcis.set(targetBci);\n+                    return new JumpTarget(targetBci, target, new ArrayList<>());\n+                }).sourceBcis.add(sourceBci);\n+            }\n+        };\n+\n+        int bci = 0;\n+        \/\/ First collect jump map\n+        for (CodeElement ce : codeAttribute) {\n+            switch (ce) {\n+                case BranchInstruction bi -> {\n+                    jumpMap.add(bi.target(), bci);\n+                }\n+                case TableSwitchInstruction tsi -> {\n+                    jumpMap.add(tsi.defaultTarget(), bci);\n+                    for (var c : tsi.cases()) {\n+                        jumpMap.add(c.target(), bci);\n+                    }\n+                }\n+                case LookupSwitchInstruction lsi -> {\n+                    jumpMap.add(lsi.defaultTarget(), bci);\n+                    for (var c : lsi.cases()) {\n+                        jumpMap.add(c.target(), bci);\n+                    }\n+                }\n+                default -> {}\n+            }\n+            if (ce instanceof Instruction i) {\n+                bci += i.sizeInBytes();\n+            }\n+        }\n+\n+        \/\/ Filter and split exception regions\n+        List<ExceptionRegion> regions = codeAttribute.exceptionHandlers().stream()\n+                .filter(ec -> ec.tryStart() != ec.tryEnd() && ec.tryStart() != ec.handler())\n+                .map(ec -> new ExceptionRegion(ec.tryStart(), ec.tryEnd(), ec.handler())).distinct().toList();\n+\n+        \/\/ Exception handlers also represent jump targets\n+        \/\/ @@@ not listed all source bcis\n+        for (ExceptionRegion er : regions) {\n+            jumpMap.add(er.handlerLabel, codeAttribute.labelToBci(er.startLabel));\n+        }\n+\n+        boolean split;\n+        do {\n+            split = false;\n+            var newRegions = new ArrayList<ExceptionRegion>();\n+            for (var reg : regions) {\n+                final int startBci = codeAttribute.labelToBci(reg.startLabel());\n+                final int endBci = codeAttribute.labelToBci(reg.endLabel());\n+                final int handlerBci = codeAttribute.labelToBci(reg.handlerLabel());\n+                \/\/ Filter out exception handlers overlapping with try blocks\n+                if (handlerBci >= endBci || handlerBci < startBci) {\n+                    Label startLabel = reg.startLabel();\n+                    int breakIndex = startBci;\n+                    \/\/ Detect additional exception region entries\n+                    while ((breakIndex = targetBcis.nextSetBit(breakIndex + 1)) >= 0 &&  breakIndex < endBci) {\n+                        JumpTarget jt = jumpMap.get(breakIndex);\n+                        \/\/ Split the exception region by each external entry (jump from outside of the region)\n+                        if (jt.sourceBcis.stream().anyMatch(sourceBci -> sourceBci < startBci || sourceBci > endBci)) {\n+                            Label breakLabel = jt.target();\n+                            newRegions.add(new ExceptionRegion(startLabel, breakLabel, reg.handlerLabel()));\n+                            startLabel = breakLabel;\n+                            split = true;\n+                        }\n+                    }\n+                    newRegions.add(new ExceptionRegion(startLabel, reg.endLabel(), reg.handlerLabel()));\n+                }\n+            }\n+            regions = newRegions;\n+        } while (split); \/\/ Each new split may change branch status to an external entry and imply more splits\n+        return regions;\n+    }\n+\n+    private List<TypeElement> toBlockParams(List<StackMapFrameInfo.VerificationTypeInfo> vtis) {\n+        ArrayList<TypeElement> params = new ArrayList<>(vtis.size());\n+        for (int i = vtis.size() - 1; i >= 0; i--) {\n+            var vti = vtis.get(i);\n+            switch (vti) {\n+                case ITEM_INTEGER -> params.add(JavaType.INT);\n+                case ITEM_FLOAT -> params.add(JavaType.FLOAT);\n+                case ITEM_DOUBLE -> params.add(JavaType.DOUBLE);\n+                case ITEM_LONG -> params.add(JavaType.LONG);\n+                case ITEM_NULL -> params.add(JavaType.J_L_OBJECT);\n+                case ITEM_UNINITIALIZED_THIS ->\n+                    params.add(JavaType.type(classModel.thisClass().asSymbol()));\n+                case StackMapFrameInfo.ObjectVerificationTypeInfo ovti ->\n+                    params.add(JavaType.type(ovti.classSymbol()));\n+\n+                    \/\/ Unitialized entry (a new object before its constructor is called)\n+                    \/\/ must be skipped from block parameters because they do not exist in code reflection model\n+                case StackMapFrameInfo.UninitializedVerificationTypeInfo _ -> {}\n+                default ->\n+                    throw new IllegalArgumentException(\"Unexpected VTI: \" + vti);\n+            }\n+        }\n+        return params;\n@@ -186,12 +282,0 @@\n-    private Block.Builder getBlock(Label l) {\n-        Block.Builder bb = blockMap.get(l);\n-        if (bb == null) {\n-            if (currentBlock == null) {\n-                throw new IllegalArgumentException(\"Block without an stack frame detected.\");\n-            } else {\n-                return newBlock();\n-            }\n-        }\n-        return bb;\n-    }\n-\n@@ -202,0 +286,4 @@\n+    private Block.Builder newBlock(List<Block.Parameter> otherBlockParams) {\n+        return entryBlock.block(otherBlockParams.stream().map(Block.Parameter::type).toList());\n+    }\n+\n@@ -219,0 +307,17 @@\n+    private Block.Builder findTargetBlock(Label targetLabel) {\n+        Block.Builder targetBlock = blockMap.get(targetLabel);\n+        int targetBci = codeAttribtue.labelToBci(targetLabel);\n+        for (ExceptionRegionEntry ee : exceptionRegionStack.reversed()) {\n+            if (ee.region.startLabel == targetLabel) {\n+                \/\/ Avoid region re-entry\n+                targetBlock = ee.startBlock;\n+            } else if (targetBci < codeAttribtue.labelToBci(ee.region.startLabel) || targetBci >= codeAttribtue.labelToBci(ee.region.endLabel)) {\n+                \/\/ Leaving the exception region, need to insert ExceptionRegionExit\n+                Block.Builder next = newBlock(targetBlock.parameters());\n+                next.op(CoreOp.exceptionRegionExit(ee.enter(), targetBlock.successor(next.parameters())));\n+                targetBlock = next;\n+            }\n+        }\n+        return targetBlock;\n+    }\n+\n@@ -220,1 +325,0 @@\n-        final Map<ExceptionCatch, Op.Result> exceptionRegionsMap = new HashMap<>();\n@@ -227,0 +331,10 @@\n+                    \/\/ Insert relevant tryEnd blocks\n+                    while (!exceptionRegionStack.isEmpty() && lt.label() == exceptionRegionStack.peek().region.endLabel) {\n+                        \/\/ Create exit block with parameters constructed from the stack\n+                        ExceptionRegionEntry er = exceptionRegionStack.pop();\n+                        if (currentBlock != null) {\n+                            Block.Builder next = newBlock();\n+                            op(CoreOp.exceptionRegionExit(er.enter(), successor(next)));\n+                            moveTo(next);\n+                        }\n+                    }\n@@ -228,0 +342,1 @@\n+\n@@ -233,1 +348,1 @@\n-                            op(CoreOp.branch(next.successor(List.copyOf(stack))));\n+                            op(CoreOp.branch(successor(next)));\n@@ -237,0 +352,1 @@\n+\n@@ -238,3 +354,2 @@\n-                    for (ExceptionCatch ec : exceptionHandlers.reversed()) {\n-                        if (lt.label() == ec.tryStart()) {\n-                            Block.Builder handler = getBlock(ec.handler());\n+                    for (ExceptionRegion reg : exceptionRegions.reversed()) {\n+                        if (lt.label() == reg.startLabel()) {\n@@ -243,1 +358,1 @@\n-                            Op ere = CoreOp.exceptionRegionEnter(next.successor(List.copyOf(stack)), handler.successor(List.copyOf(stack)));\n+                            Op ere = CoreOp.exceptionRegionEnter(successor(next), findTargetBlock(reg.handlerLabel()).successor());\n@@ -245,11 +360,2 @@\n-                            \/\/ Store ERE into map for exit\n-                            exceptionRegionsMap.put(ec, ere.result());\n-                            moveTo(next);\n-                        }\n-                    }\n-                    \/\/ Insert relevant tryEnd blocks in normal order\n-                    for (ExceptionCatch ec : exceptionHandlers) {\n-                        if (lt.label() == ec.tryEnd()) {\n-                            \/\/ Create exit block with parameters constructed from the stack\n-                            next = newBlock();\n-                            op(CoreOp.exceptionRegionExit(exceptionRegionsMap.get(ec), next.successor(List.copyOf(stack))));\n+                            \/\/ Push ExceptionRegionEntry on stack\n+                            exceptionRegionStack.push(new ExceptionRegionEntry(ere.result(), next, reg));\n@@ -261,1 +367,1 @@\n-                    op(CoreOp.branch(getBlock(inst.target()).successor(List.copyOf(stack))));\n+                    op(CoreOp.branch(successor(findTargetBlock(inst.target()))));\n@@ -282,2 +388,2 @@\n-                        case IF_ACMPEQ -> unifyOperands(CoreOp::neq, stack.pop(), operand, TypeKind.IntType);\n-                        case IF_ACMPNE -> unifyOperands(CoreOp::eq, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ACMPEQ -> CoreOp.neq(stack.pop(), operand);\n+                        case IF_ACMPNE -> CoreOp.eq(stack.pop(), operand);\n@@ -286,1 +392,2 @@\n-                    Block.Builder next = newBlock();\n+                    Block.Builder branch = findTargetBlock(inst.target());\n+                    Block.Builder next = newBlock(branch.parameters());\n@@ -288,2 +395,2 @@\n-                            next.successor(List.copyOf(stack)),\n-                            getBlock(inst.target()).successor(List.copyOf(stack))));\n+                            successor(next),\n+                            successor(branch)));\n@@ -311,1 +418,1 @@\n-                    stack.push(op(SlotOp.load(inst.slot(), JavaType.type(codeTracker.getTypeOf(inst)))));\n+                    stack.push(op(SlotOp.load(inst.slot(), JavaType.type(codeTracker.getTypeOf(i)))));\n@@ -444,1 +551,3 @@\n-                    if (inst.bootstrapMethod().owner().equals(CD_LambdaMetafactory)\n+                    DirectMethodHandleDesc bsm = inst.bootstrapMethod();\n+                    ClassDesc bsmOwner = bsm.owner();\n+                    if (bsmOwner.equals(CD_LambdaMetafactory)\n@@ -448,3 +557,0 @@\n-                        LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n-                                FunctionType.functionType(JavaType.type(mtd.returnType()), mtd.parameterList().stream().map(JavaType::type).toList()),\n-                                JavaType.type(inst.typeSymbol().returnType()));\n@@ -458,0 +564,9 @@\n+                        MethodTypeDesc mt = dmhd.invocationType();\n+                        if (capturedValues.length > 0) {\n+                            mt = mt.dropParameterTypes(0, capturedValues.length);\n+                        }\n+                        FunctionType lambdaFunc = FunctionType.functionType(JavaType.type(mt.returnType()),\n+                                                                            mt.parameterList().stream().map(JavaType::type).toList());\n+                        CoreOp.LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n+                                                                       lambdaFunc,\n+                                                                       JavaType.type(inst.typeSymbol().returnType()));\n@@ -469,11 +584,7 @@\n-                                MethodTypeDesc mt = dmhd.invocationType();\n-                                if (capturedValues.length > 0) {\n-                                    mt = mt.dropParameterTypes(0, capturedValues.length);\n-                                }\n-                                eb.op(CoreOp._return(eb.op(CoreOp.invoke(\n-                                        MethodRef.method(\n-                                                JavaType.type(dmhd.owner()),\n-                                                dmhd.methodName(),\n-                                                JavaType.type(mt.returnType()),\n-                                                mt.parameterList().stream().map(JavaType::type).toList()),\n-                                        Stream.concat(Arrays.stream(capturedValues), eb.parameters().stream()).toArray(Value[]::new)))));\n+                                Op.Result ret = eb.op(CoreOp.invoke(\n+                                        MethodRef.method(JavaType.type(dmhd.owner()),\n+                                                         dmhd.methodName(),\n+                                                         lambdaFunc.returnType(),\n+                                                         lambdaFunc.parameterTypes()),\n+                                        Stream.concat(Arrays.stream(capturedValues), eb.parameters().stream()).toArray(Value[]::new)));\n+                                eb.op(ret.type().equals(JavaType.VOID) ? CoreOp._return() : CoreOp._return(ret));\n@@ -482,0 +593,31 @@\n+                    } else if (bsmOwner.equals(CD_StringConcatFactory)) {\n+                        int argsCount = inst.typeSymbol().parameterCount();\n+                        Deque<Value> args = new ArrayDeque<>(argsCount);\n+                        for (int ai = 0; ai < argsCount; ai++) {\n+                            args.push(stack.pop());\n+                        }\n+                        Value res = null;\n+                        if (bsm.methodName().equals(\"makeConcat\")) {\n+                            for (Value argVal : args) {\n+                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                            }\n+                        } else {\n+                            assert bsm.methodName().equals(\"makeConcatWithConstants\");\n+                            var bsmArgs = inst.bootstrapArgs();\n+                            String recipe = (String)(bsmArgs.getFirst());\n+                            int bsmArg = 1;\n+                            for (int ri = 0; ri < recipe.length(); ri++) {\n+                                Value argVal = switch (recipe.charAt(ri)) {\n+                                    case '\\u0001' -> args.pop();\n+                                    case '\\u0002' -> liftConstant(bsmArgs.get(bsmArg++));\n+                                    default -> {\n+                                        char c;\n+                                        int start = ri;\n+                                        while (ri < recipe.length() && (c = recipe.charAt(ri)) != '\\u0001' && c != '\\u0002') ri++;\n+                                        yield liftConstant(recipe.substring(start, ri--));\n+                                    }\n+                                };\n+                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                            }\n+                        }\n+                        if (res != null) stack.push(res);\n@@ -486,8 +628,0 @@\n-                        List<Value> bootstrapArgs = new ArrayList<>();\n-                        bootstrapArgs.add(lookup());\n-                        bootstrapArgs.add(liftConstant(inst.name().toString()));\n-                        bootstrapArgs.add(liftConstant(mtd));\n-                        for (ConstantDesc barg : inst.bootstrapArgs()) {\n-                            bootstrapArgs.add(liftConstant(barg));\n-                        }\n-                        DirectMethodHandleDesc bsm = inst.bootstrapMethod();\n@@ -495,1 +629,1 @@\n-                        MethodRef bsmRef = MethodRef.method(JavaType.type(bsm.owner()),\n+                        MethodRef bsmRef = MethodRef.method(JavaType.type(bsmOwner),\n@@ -499,0 +633,2 @@\n+\n+                        Value[] bootstrapArgs = liftBootstrapArgs(bsmDesc, inst.name().toString(), mtd, inst.bootstrapArgs());\n@@ -672,0 +808,8 @@\n+    private Op.Result liftConstantsIntoArray(TypeElement arrayType, Object... constants) {\n+        Op.Result array = op(CoreOp.newArray(arrayType, liftConstant(constants.length)));\n+        for (int i = 0; i < constants.length; i++) {\n+            op(CoreOp.arrayStoreOp(array, liftConstant(i), liftConstant(constants[i])));\n+        }\n+        return array;\n+    }\n+\n@@ -697,1 +841,1 @@\n-                            CoreOp.invoke(FIND_CONSTRUCTOR, lookup, owner, liftConstant(invDesc.changeReturnType(CD_void)));\n+                            CoreOp.invoke(FIND_CONSTRUCTOR, lookup, owner, liftConstant(invDesc.changeReturnType(ConstantDescs.CD_Void)));\n@@ -711,7 +855,1 @@\n-                    default -> {\n-                        Op.Result list = op(CoreOp._new(ARRAYLIST_INIT));\n-                        for (ClassDesc p : mt.parameterList()) {\n-                            op(CoreOp.invoke(ARRAYLIST_ADD, list, liftConstant(p)));\n-                        }\n-                        yield CoreOp.invoke(METHOD_TYPE_L, liftConstant(mt.returnType()), list);\n-                    }\n+                    default -> CoreOp.invoke(METHOD_TYPE_L, liftConstant(mt.returnType()), liftConstantsIntoArray(CLASS_ARRAY, (Object[])mt.parameterArray()));\n@@ -723,7 +861,0 @@\n-                    List<Value> bootstrapArgs = new ArrayList<>();\n-                    bootstrapArgs.add(lookup());\n-                    bootstrapArgs.add(liftConstant(dcd.constantName()));\n-                    bootstrapArgs.add(liftConstant(dcd.constantType()));\n-                    for (ConstantDesc barg : dcd.bootstrapArgs()) {\n-                        bootstrapArgs.add(liftConstant(barg));\n-                    }\n@@ -732,0 +863,1 @@\n+                    Value[] bootstrapArgs = liftBootstrapArgs(bsmDesc, dcd.constantName(), dcd.constantType(), dcd.bootstrapArgsList());\n@@ -746,0 +878,22 @@\n+    private Value[] liftBootstrapArgs(MethodTypeDesc bsmDesc, String name, ConstantDesc desc, List<ConstantDesc> bsmArgs) {\n+        Value[] bootstrapArgs = new Value[bsmDesc.parameterCount()];\n+        bootstrapArgs[0] = lookup();\n+        bootstrapArgs[1] = liftConstant(name);\n+        bootstrapArgs[2] = liftConstant(desc);\n+        ClassDesc lastArgType = bsmDesc.parameterType(bsmDesc.parameterCount() - 1);\n+        if (lastArgType.isArray()) {\n+            for (int ai = 0; ai < bootstrapArgs.length - 4; ai++) {\n+                bootstrapArgs[ai + 3] = liftConstant(bsmArgs.get(ai));\n+            }\n+            \/\/ Vararg tail of the bootstrap method parameters\n+            bootstrapArgs[bootstrapArgs.length - 1] =\n+                    liftConstantsIntoArray(JavaType.type(lastArgType),\n+                                           bsmArgs.subList(bootstrapArgs.length - 4, bsmArgs.size()).toArray());\n+        } else {\n+            for (int ai = 0; ai < bootstrapArgs.length - 3; ai++) {\n+                bootstrapArgs[ai + 3] = liftConstant(bsmArgs.get(ai));\n+            }\n+        }\n+        return bootstrapArgs;\n+    }\n+\n@@ -749,0 +903,1 @@\n+        Block.Builder def = findTargetBlock(defaultTarget);\n@@ -750,1 +905,1 @@\n-            Block.Builder next = sc == last ? blockMap.get(defaultTarget) : newBlock();\n+            Block.Builder next = sc == last ? def : newBlock(def.parameters());\n@@ -753,2 +908,2 @@\n-                    blockMap.get(sc.target()).successor(List.copyOf(stack)),\n-                    next.successor(List.copyOf(stack))));\n+                    successor(findTargetBlock(sc.target())),\n+                    successor(next)));\n@@ -760,0 +915,4 @@\n+    Block.Reference successor(Block.Builder next) {\n+        return next.successor(stack.stream().limit(next.parameters().size()).toList());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":277,"deletions":118,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.Instruction;\n@@ -30,1 +31,0 @@\n-import java.lang.classfile.TypeKind;\n@@ -32,1 +32,1 @@\n-import java.lang.classfile.attribute.StackMapFrameInfo.ObjectVerificationTypeInfo;\n+import java.lang.classfile.attribute.StackMapFrameInfo.*;\n@@ -36,0 +36,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -38,0 +39,1 @@\n+import java.util.HashMap;\n@@ -41,1 +43,0 @@\n-import java.util.function.Function;\n@@ -45,1 +46,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -47,1 +47,3 @@\n-import java.util.IdentityHashMap;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -51,1 +53,3 @@\n-    private final Map<LoadInstruction, ClassDesc> insMap;\n+    record Frame(List<ClassDesc> stack, List<ClassDesc> locals) {}\n+\n+    private final Map<Integer, ClassDesc> insMap;\n@@ -54,1 +58,3 @@\n-    private final Map<Label, StackMapFrameInfo> stackMap;\n+    final Map<Label, Frame> stackMap;\n+    private final Map<Label, ClassDesc> newMap;\n+    private boolean frameDirty;\n@@ -60,1 +66,1 @@\n-        this.insMap = new IdentityHashMap<>();\n+        this.insMap = new HashMap<>();\n@@ -63,1 +69,2 @@\n-        this.locals = new ArrayList<>(initFrameLocals);\n+        this.locals = new ArrayList<>(initFrameLocals.size());\n+        this.newMap = computeNewMap(codeElements);\n@@ -66,2 +73,42 @@\n-                Function.identity()))).orElse(Map.of());\n-        codeElements.forEach(this::accept);\n+                this::toFrame))).orElse(Map.of());\n+        do {\n+            this.locals.addAll(initFrameLocals);\n+            this.frameDirty = false;\n+            for (int i = 0; i < codeElements.size(); i++) {\n+                accept(i, codeElements.get(i));\n+            }\n+            endOfFlow();\n+        } while (this.frameDirty);\n+    }\n+\n+    private Frame toFrame(StackMapFrameInfo smfi) {\n+        List<ClassDesc> fstack = new ArrayList<>(smfi.stack().size());\n+        List<ClassDesc> flocals = new ArrayList<>(smfi.locals().size() * 2);\n+        for (var vti : smfi.stack()) {\n+            fstack.add(vtiToStackType(vti));\n+        }\n+        for (var vti : smfi.locals()) {\n+            flocals.add(vtiToStackType(vti));\n+            if (vti == ITEM_DOUBLE || vti == ITEM_LONG) {\n+                flocals.add(null);\n+            }\n+        }\n+        return new Frame(fstack, flocals);\n+    }\n+\n+    private static Map<Label, ClassDesc> computeNewMap(List<CodeElement> codeElements) {\n+        Map<Label, ClassDesc> newMap = new HashMap<>();\n+        Label lastLabel = null;\n+        for (int i = 0; i < codeElements.size(); i++) {\n+            switch (codeElements.get(i)) {\n+                case LabelTarget lt -> lastLabel = lt.label();\n+                case NewObjectInstruction newI -> {\n+                    if (lastLabel != null) {\n+                        newMap.put(lastLabel, newI.className().asSymbol());\n+                    }\n+                }\n+                case Instruction _ -> lastLabel = null; \/\/invalidate label\n+                default -> {} \/\/skip\n+            }\n+        }\n+        return newMap;\n@@ -70,1 +117,1 @@\n-    ClassDesc getTypeOf(LoadInstruction li) {\n+    ClassDesc getTypeOf(int li) {\n@@ -74,0 +121,4 @@\n+    ClassDesc getUninitTypeOf(Label newLabel) {\n+        return newMap.get(newLabel);\n+    }\n+\n@@ -81,0 +132,1 @@\n+            case ITEM_NULL -> CD_Object;\n@@ -82,1 +134,5 @@\n-            default -> null;\n+            case UninitializedVerificationTypeInfo uvti ->\n+                newMap.computeIfAbsent(uvti.newTarget(), l -> {\n+                    throw new IllegalArgumentException(\"Unitialized type does not point to a new instruction\");\n+                });\n+            case ITEM_TOP -> null;\n@@ -87,1 +143,1 @@\n-        if (!ConstantDescs.CD_void.equals(type)) stack.addLast(type);\n+        if (!ConstantDescs.CD_void.equals(type)) stack.add(type);\n@@ -131,1 +187,1 @@\n-    private void accept(CodeElement el) {\n+    private void accept(int elIndex, CodeElement el) {\n@@ -137,2 +193,16 @@\n-            case BranchInstruction i when !i.opcode().isUnconditionalBranch() ->\n-                pop(1);\n+            case BranchInstruction i -> {\n+                switch (i.opcode()) {\n+                    case IFEQ, IFGE, IFGT, IFLE, IFLT, IFNE, IFNONNULL, IFNULL -> {\n+                        pop();\n+                        mergeToTargetFrame(i.target());\n+                    }\n+                    case IF_ACMPEQ, IF_ACMPNE, IF_ICMPEQ, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ICMPLT, IF_ICMPNE -> {\n+                        pop(2);\n+                        mergeToTargetFrame(i.target());\n+                    }\n+                    case GOTO, GOTO_W -> {\n+                        mergeToTargetFrame(i.target());\n+                        endOfFlow();\n+                    }\n+                }\n+            }\n@@ -140,2 +210,12 @@\n-                push(ClassDesc.ofDescriptor(i.typeKind() == TypeKind.ReferenceType ?\n-                        i.constantValue().getClass().descriptorString() : i.typeKind().descriptor()));\n+                push(switch (i.constantValue()) {\n+                    case null -> CD_Object;\n+                    case ClassDesc _ -> CD_Class;\n+                    case Double _ -> CD_double;\n+                    case Float _ -> CD_float;\n+                    case Integer _ -> CD_int;\n+                    case Long _ -> CD_long;\n+                    case String _ -> CD_String;\n+                    case DynamicConstantDesc<?> cd -> cd.constantType();\n+                    case DirectMethodHandleDesc _ -> CD_MethodHandle;\n+                    case MethodTypeDesc _ -> CD_MethodType;\n+                });\n@@ -163,1 +243,1 @@\n-                insMap.put(i, locals.get(i.slot()));\n+                insMap.put(elIndex, locals.get(i.slot()));\n@@ -216,11 +296,5 @@\n-                var smfi = stackMap.get(lt.label());\n-                if (smfi != null) {\n-                    stack.clear();\n-                    for (var vti : smfi.stack()) {\n-                        push(vtiToStackType(vti));\n-                    }\n-                    locals.clear();\n-                    int slot = 0;\n-                    for (var vti : smfi.locals()) {\n-                        store(slot, vtiToStackType(vti));\n-                        slot += (vti == ITEM_DOUBLE || vti == ITEM_LONG) ? 2 : 1;\n+                var frame = stackMap.get(lt.label());\n+                if (frame != null) {\n+                    if (!stack.isEmpty() || !locals.isEmpty()) {\n+                        mergeToTargetFrame(lt.label());\n+                        endOfFlow();\n@@ -228,0 +302,2 @@\n+                    stack.addAll(frame.stack());\n+                    locals.addAll(frame.locals());\n@@ -230,0 +306,19 @@\n+            case ReturnInstruction _ , ThrowInstruction _ -> {\n+                endOfFlow();\n+            }\n+            case TableSwitchInstruction tsi -> {\n+                pop();\n+                mergeToTargetFrame(tsi.defaultTarget());\n+                for (var c : tsi.cases()) {\n+                    mergeToTargetFrame(c.target());\n+                }\n+                endOfFlow();\n+            }\n+            case LookupSwitchInstruction lsi -> {\n+                pop();\n+                mergeToTargetFrame(lsi.defaultTarget());\n+                for (var c : lsi.cases()) {\n+                    mergeToTargetFrame(c.target());\n+                }\n+                endOfFlow();\n+            }\n@@ -233,0 +328,29 @@\n+\n+    private void endOfFlow() {\n+        stack.clear();\n+        locals.clear();\n+    }\n+\n+    private void mergeToTargetFrame(Label target) {\n+        Frame targetFrame = stackMap.get(target);\n+        \/\/ Merge stack\n+        assert stack.size() == targetFrame.stack.size();\n+        for (int i = 0; i < targetFrame.stack.size(); i++) {\n+            ClassDesc se = stack.get(i);\n+            ClassDesc fe = targetFrame.stack.get(i);\n+            if (!se.equals(fe) && se.isPrimitive() && CD_int.equals(fe)) {\n+                targetFrame.stack.set(i, se);\n+                this.frameDirty = true;\n+            }\n+        }\n+        \/\/ Merge locals\n+        int lSize = Math.min(locals.size(), targetFrame.locals.size());\n+        for (int i = 0; i < lSize; i++) {\n+            ClassDesc le = locals.get(i);\n+            ClassDesc fe = targetFrame.locals.get(i);\n+            if (le != null && !le.equals(fe) && le.isPrimitive() && CD_int.equals(fe)) {\n+                targetFrame.locals.set(i, le);\n+                this.frameDirty = true;\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsTypeMapper.java","additions":155,"deletions":31,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.code.type.PrimitiveType;\n@@ -80,1 +81,1 @@\n-                    if (vl.resultType().equals(v.type())) {\n+                    if (vl.resultType().equals(v.type()) || v.type() instanceof PrimitiveType) {\n@@ -258,0 +259,8 @@\n+\n+        \/\/ @@@ Remove all catch blocks from dominance frontier to avoid adding block parameters to them\n+        for (Block b : body.blocks()) {\n+            if (b.terminatingOp() instanceof CoreOp.ExceptionRegionEnter ere) {\n+                df.values().forEach(dfs -> dfs.removeAll(ere.catchBlocks().stream().map(Block.Reference::targetBlock).toList()));\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotSSA.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.function.Consumer;\n@@ -242,0 +243,8 @@\n+    @CodeReflection\n+    static int objectsCompare(Boolean b1, Boolean b2, Boolean b3) {\n+        Object a = b1;\n+        Object b = b2;\n+        Object c = b3;\n+        return a == b ? (a != c ? 1 : 2) : (b != c ? 3 : 4);\n+    }\n+\n@@ -252,0 +261,7 @@\n+    static final int[] MAP = {0, 1, 2, 3, 4};\n+\n+    @CodeReflection\n+    static int deepStackBranches(boolean a, boolean b) {\n+        return MAP[a ? MAP[b ? 1 : 2] : MAP[b ? 3 : 4]];\n+    }\n+\n@@ -422,0 +438,15 @@\n+    static void consume(boolean b, Consumer<Object> requireNonNull) {\n+        if (b) {\n+            requireNonNull.accept(new Object());\n+        } else try {\n+            requireNonNull.accept(null);\n+            throw new AssertionError(\"Expectend NPE\");\n+        } catch (NullPointerException expected) {\n+        }\n+    }\n+\n+    @CodeReflection\n+    static void nullReturningMethodHandle(boolean b) {\n+        consume(b, Objects::requireNonNull);\n+    }\n+\n@@ -468,1 +499,6 @@\n-        return a + b;\n+        return \"a\"+ a +\"\\u0001\" + a + \"b\\u0002c\" + b + \"\\u0001\\u0002\" + b + \"dd\";\n+    }\n+\n+    @CodeReflection\n+    static String multiTypeConcat(int i, Boolean b, char c, Short s, float f, Double d) {\n+        return \"i:\"+ i +\" b:\" + b + \" c:\" + c + \" f:\" + f + \" d:\" + d;\n@@ -479,0 +515,29 @@\n+    @CodeReflection\n+    static int excHandlerFollowingSplitTable(boolean b) {\n+        try {\n+            if (b) return 1;\n+            else throw new Exception();\n+        } catch (Exception ex) {}\n+        return 2;\n+    }\n+\n+    @CodeReflection\n+    static boolean finallyWithLoop(boolean b) {\n+        try {\n+            while (b) {\n+                if (b)\n+                    return false;\n+                b = !b;\n+            }\n+            return true;\n+        } finally {\n+            b = false;\n+        }\n+    }\n+\n+    @CodeReflection\n+    static long doubleUseOfOperand(int x) {\n+        long piece = x;\n+        return piece * piece;\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":66,"deletions":1,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.constant.DynamicCallSiteDesc;\n@@ -34,0 +35,1 @@\n+import java.lang.invoke.StringConcatFactory;\n@@ -37,0 +39,1 @@\n+import java.lang.runtime.CodeReflection;\n@@ -70,0 +73,15 @@\n+    @Test\n+    public void testDeepStackJump() throws Throwable {\n+        CoreOp.FuncOp f = getFuncOp(ClassFile.of().build(ClassDesc.of(\"DeepStackJump\"), clb ->\n+                clb.withMethodBody(\"deepStackJump\", MethodTypeDesc.of(ConstantDescs.CD_long), ClassFile.ACC_STATIC, cob -> {\n+                    Label l = cob.newLabel();\n+                    cob.lconst_1().iconst_1().iconst_2()\n+                       .goto_(l)\n+                       .labelBinding(l)\n+                       .iadd().i2l().ladd()\n+                       .lreturn();\n+                })), \"deepStackJump\");\n+\n+        Assert.assertEquals((long) Interpreter.invoke(f), 4);\n+    }\n+\n@@ -108,0 +126,16 @@\n+    @Test\n+    public void testStringMakeConcat() throws Throwable {\n+        byte[] testStringMakeConcat = ClassFile.of().build(ClassDesc.of(\"TestStringMakeConcat\"), clb ->\n+                clb.withMethodBody(\"concatMethod\", MethodTypeDesc.of(ConstantDescs.CD_String), ClassFile.ACC_STATIC, cob ->\n+                        cob.ldc(\"A\").ldc(\"B\").ldc(\"C\")\n+                           .invokedynamic(DynamicCallSiteDesc.of(\n+                                ConstantDescs.ofCallsiteBootstrap(StringConcatFactory.class.describeConstable().get(), \"makeConcat\", ConstantDescs.CD_CallSite),\n+                                MethodTypeDesc.of(ConstantDescs.CD_String, ConstantDescs.CD_String, ConstantDescs.CD_String, ConstantDescs.CD_String)))\n+                           .areturn()));\n+\n+        CoreOp.FuncOp concatMethod = getFuncOp(testStringMakeConcat, \"concatMethod\");\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Assert.assertEquals((String)Interpreter.invoke(lookup, concatMethod), \"ABC\");\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.classfile.components.ClassPrinter;\n@@ -33,4 +34,1 @@\n-import java.lang.reflect.AccessFlag;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.Block;\n@@ -55,0 +53,1 @@\n+ * @modules java.base\/java.lang.invoke:open\n@@ -62,0 +61,10 @@\n+    private static final MethodHandles.Lookup TRUSTED_LOOKUP;\n+    static {\n+        try {\n+            var lf = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n+            lf.setAccessible(true);\n+            TRUSTED_LOOKUP = (MethodHandles.Lookup)lf.get(null);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n@@ -88,1 +97,1 @@\n-        Assert.assertTrue(passed > 29000, String.format(\"\"\"\n+        Assert.assertTrue(passed > 33890, String.format(\"\"\"\n@@ -108,3 +117,18 @@\n-                    CoreOp.FuncOp firstTransform = transform(firstLift);\n-                    try {\n-                        MethodModel firstModel = lower(firstTransform);\n+                    MethodModel firstModel = lower(firstLift);\n+                    boolean vError = false;\n+                    for (var e : ClassFile.of().verify(firstModel.parent().get())) {\n+                        if (!e.getMessage().contains(\"Illegal call to internal method\")) {\n+                            if (!vError) System.out.println(\"--------------------------------------\");\n+                            System.out.println(e);\n+                            vError = true;\n+                        }\n+                    }\n+                    if (vError) {\n+                        System.out.println(path);\n+                        ClassPrinter.toYaml(originalModel, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+                        firstLift.writeTo(System.out);\n+                        ClassPrinter.toYaml(firstModel, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+                        System.out.println(\"--------------------------------------\");\n+                        error(\"first verify\", path.toString());\n+                    } else try {\n+                        CoreOp.FuncOp secondLift = lift(firstModel);\n@@ -112,21 +136,27 @@\n-                            CoreOp.FuncOp secondLift = lift(firstModel);\n-                            try {\n-                                CoreOp.FuncOp secondTransform = transform(secondLift);\n-                                try {\n-                                    MethodModel secondModel = lower(secondTransform);\n-\n-                                    \/\/ testing only methods passing through\n-                                    var firstNormalized = normalize(firstModel);\n-                                    var secondNormalized = normalize(secondModel);\n-                                    if (!firstNormalized.equals(secondNormalized)) {\n-                                        notMatching++;\n-                                        System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n-                                        printInColumns(firstLift, secondLift);\n-                                        printInColumns(firstTransform, secondTransform);\n-                                        printInColumns(firstNormalized, secondNormalized);\n-                                        System.out.println();\n-                                    } else {\n-                                        passed++;\n-                                    }\n-                                } catch (Exception e) {\n-                                    error(\"second lower\", e);\n+                            MethodModel secondModel = lower(secondLift);\n+                            for (var e : ClassFile.of().verify(secondModel.parent().get())) {\n+                                if (!e.getMessage().contains(\"Illegal call to internal method\")) {\n+                                    if (!vError) System.out.println(\"--------------------------------------\");\n+                                    System.out.println(e);\n+                                    vError = true;\n+                                }\n+                            }\n+                            if (vError) {\n+\/\/                                System.out.println(path);\n+\/\/                                ClassPrinter.toYaml(firstModel, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+\/\/                                secondLift.writeTo(System.out);\n+\/\/                                ClassPrinter.toYaml(secondModel, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+\/\/                                System.out.println(\"--------------------------------------\");\n+                                error(\"second verify\", path.toString());\n+                            } else {\n+                                \/\/ testing only methods passing through\n+                                var firstNormalized = normalize(firstModel);\n+                                var secondNormalized = normalize(secondModel);\n+                                if (!firstNormalized.equals(secondNormalized)) {\n+                                    notMatching++;\n+\/\/                                    System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n+\/\/                                    printInColumns(firstLift, secondLift);\n+\/\/                                    printInColumns(firstNormalized, secondNormalized);\n+\/\/                                    System.out.println();\n+                                } else {\n+                                    passed++;\n@@ -134,2 +164,0 @@\n-                            } catch (Exception e) {\n-                                error(\"second transform\", e);\n@@ -137,2 +165,2 @@\n-                        } catch (Exception e) {\n-                            error(\"second lift\", e);\n+                        } catch (Throwable t) {\n+                            error(\"second lower\", t);\n@@ -140,2 +168,2 @@\n-                    } catch (Exception e) {\n-                        error(\"first lower\", e);\n+                    } catch (Throwable t) {\n+                        error(\"second lift\", t);\n@@ -143,2 +171,2 @@\n-                } catch (Exception e) {\n-                    error(\"first transform\", e);\n+                } catch (Throwable t) {\n+                    error(\"first lower\", t);\n@@ -146,2 +174,2 @@\n-            } catch (Exception e) {\n-                error(\"first lift\", e);\n+            } catch (Throwable t) {\n+                error(\"first lift\", t);\n@@ -151,0 +179,15 @@\n+\n+\/\/    private static void printBlockGraph(CoreOp.FuncOp func) {\n+\/\/        for (Block b : func.body().blocks()) {\n+\/\/            System.out.println(b.index() + \": \" + switch (b.terminatingOp()) {\n+\/\/                case CoreOp.ReturnOp _ -> \"return\";\n+\/\/                case CoreOp.ThrowOp _ -> \"throw\";\n+\/\/                case CoreOp.BranchOp br -> \"-> \" + br.branch().targetBlock().index();\n+\/\/                case CoreOp.ConditionalBranchOp br -> \"-> \" + br.trueBranch().targetBlock().index() + \", \" + br.falseBranch().targetBlock().index();\n+\/\/                case CoreOp.ExceptionRegionEnter er -> \"try \" + er.start().targetBlock().index() + \" catch \" + er.catchBlocks().stream().map(r -> String.valueOf(r.targetBlock().index())).collect(Collectors.joining(\", \"));\n+\/\/                case CoreOp.ExceptionRegionExit er -> \" -> exit \" + er.regionStart().parentBlock().index() + \" -> \" + er.end().targetBlock().index();\n+\/\/                default -> b.terminatingOp().opName();\n+\/\/            });\n+\/\/        }\n+\/\/    }\n+\n@@ -172,4 +215,0 @@\n-    private static CoreOp.FuncOp transform(CoreOp.FuncOp func) {\n-        return SSA.transform(func.transform(OpTransformer.LOWERING_TRANSFORMER));\n-    }\n-\n@@ -178,1 +217,1 @@\n-                MethodHandles.lookup(),\n+                TRUSTED_LOOKUP,\n@@ -258,1 +297,1 @@\n-    private void error(String category, Exception e) {\n+    private void error(String category, Throwable t) {\n@@ -260,1 +299,5 @@\n-        e.printStackTrace(new PrintWriter(sw));\n+        t.printStackTrace(new PrintWriter(sw));\n+        error(category, sw.toString());\n+    }\n+\n+    private void error(String category, String msg) {\n@@ -262,1 +305,1 @@\n-                  .compute(sw.toString(), (_, i) -> i == null ? 1 : i + 1);\n+                  .compute(msg, (_, i) -> i == null ? 1 : i + 1);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":90,"deletions":47,"binary":false,"changes":137,"status":"modified"}]}