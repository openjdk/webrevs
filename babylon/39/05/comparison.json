{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import static java.lang.reflect.code.type.JavaType.*;\n@@ -155,1 +156,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -281,1 +282,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -322,1 +323,1 @@\n-            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!body.bodyType().returnType().equals(VOID)) {\n@@ -363,1 +364,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -402,1 +403,1 @@\n-            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!body.bodyType().returnType().equals(VOID)) {\n@@ -454,1 +455,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -464,1 +465,1 @@\n-        static final FunctionType PREDICATE_TYPE = FunctionType.functionType(JavaType.BOOLEAN);\n+        static final FunctionType PREDICATE_TYPE = FunctionType.functionType(BOOLEAN);\n@@ -600,1 +601,1 @@\n-                    if (!fromPred.bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+                    if (!fromPred.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n@@ -679,1 +680,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -776,1 +777,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -820,1 +821,1 @@\n-                        FunctionType.functionType(JavaType.BOOLEAN, initTypes));\n+                        FunctionType.functionType(BOOLEAN, initTypes));\n@@ -844,1 +845,1 @@\n-                        FunctionType.functionType(JavaType.VOID, initTypes));\n+                        FunctionType.functionType(VOID, initTypes));\n@@ -871,1 +872,1 @@\n-                        FunctionType.functionType(JavaType.VOID, initTypes));\n+                        FunctionType.functionType(VOID, initTypes));\n@@ -923,1 +924,1 @@\n-            if (!update.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!update.bodyType().returnType().equals(VOID)) {\n@@ -928,1 +929,1 @@\n-            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!body.bodyType().returnType().equals(VOID)) {\n@@ -1035,1 +1036,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -1107,1 +1108,1 @@\n-                        FunctionType.functionType(JavaType.VOID, elementType));\n+                        FunctionType.functionType(VOID, elementType));\n@@ -1149,1 +1150,1 @@\n-            if (expression.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (expression.bodyType().returnType().equals(VOID)) {\n@@ -1157,1 +1158,1 @@\n-            if (init.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (init.bodyType().returnType().equals(VOID)) {\n@@ -1165,1 +1166,1 @@\n-            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!body.bodyType().returnType().equals(VOID)) {\n@@ -1201,1 +1202,1 @@\n-            Block.Builder header = b.block(isArray ? List.of(JavaType.INT) : List.of());\n+            Block.Builder header = b.block(isArray ? List.of(INT) : List.of());\n@@ -1220,1 +1221,1 @@\n-                Value i = preHeader.op(constant(JavaType.INT, 0));\n+                Value i = preHeader.op(constant(INT, 0));\n@@ -1254,1 +1255,1 @@\n-                i = update.op(add(i, update.op(constant(JavaType.INT, 1))));\n+                i = update.op(add(i, update.op(constant(INT, 1))));\n@@ -1257,1 +1258,1 @@\n-                JavaType iterable = JavaType.type(JavaType.type(Iterator.class), elementType);\n+                JavaType iterable = type(type(Iterator.class), elementType);\n@@ -1295,1 +1296,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -1313,1 +1314,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n@@ -1363,1 +1364,1 @@\n-            if (!bodies.get(0).bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+            if (!bodies.get(0).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n@@ -1365,1 +1366,1 @@\n-                        \"Predicate body descriptor should be \" + FunctionType.functionType(JavaType.BOOLEAN) +\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n@@ -1370,1 +1371,1 @@\n-                        \"Body descriptor should be \" + FunctionType.functionType(JavaType.VOID) +\n+                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n@@ -1439,1 +1440,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -1460,1 +1461,1 @@\n-                Body.Builder predicate = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n+                Body.Builder predicate = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n@@ -1509,1 +1510,1 @@\n-                        \"Body descriptor should be \" + FunctionType.functionType(JavaType.VOID) +\n+                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n@@ -1512,1 +1513,1 @@\n-            if (!bodies.get(1).bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+            if (!bodies.get(1).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n@@ -1514,1 +1515,1 @@\n-                        \"Predicate body descriptor should be \" + FunctionType.functionType(JavaType.BOOLEAN) +\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n@@ -1583,1 +1584,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -1621,1 +1622,1 @@\n-                if (!b.bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+                if (!b.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n@@ -1695,1 +1696,1 @@\n-            return JavaType.BOOLEAN;\n+            return BOOLEAN;\n@@ -1717,1 +1718,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n@@ -1772,1 +1773,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n@@ -1860,1 +1861,1 @@\n-            if (!cond.bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+            if (!cond.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n@@ -1933,1 +1934,1 @@\n-                        FunctionType.functionType(JavaType.VOID, resourceTypes));\n+                        FunctionType.functionType(VOID, resourceTypes));\n@@ -1956,1 +1957,1 @@\n-                        FunctionType.functionType(JavaType.VOID, exceptionType));\n+                        FunctionType.functionType(VOID, exceptionType));\n@@ -1991,1 +1992,1 @@\n-            if (first.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (first.bodyType().returnType().equals(VOID)) {\n@@ -2042,1 +2043,1 @@\n-                if (resources.bodyType().returnType().equals(JavaType.VOID)) {\n+                if (resources.bodyType().returnType().equals(VOID)) {\n@@ -2053,1 +2054,1 @@\n-            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!body.bodyType().returnType().equals(VOID)) {\n@@ -2059,1 +2060,1 @@\n-                if (!_catch.bodyType().returnType().equals(JavaType.VOID)) {\n+                if (!_catch.bodyType().returnType().equals(VOID)) {\n@@ -2069,1 +2070,1 @@\n-                if (!finalizer.bodyType().returnType().equals(JavaType.VOID)) {\n+                if (!finalizer.bodyType().returnType().equals(VOID)) {\n@@ -2293,1 +2294,1 @@\n-                Block.Parameter t = catcherFinally.parameter(JavaType.type(Throwable.class));\n+                Block.Parameter t = catcherFinally.parameter(type(Throwable.class));\n@@ -2353,1 +2354,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -2398,1 +2399,1 @@\n-            return JavaType.type(PATTERN_BINDING_TYPE, (JavaType) t);\n+            return type(PATTERN_BINDING_TYPE, (JavaType) t);\n@@ -2402,1 +2403,1 @@\n-            return JavaType.type(PATTERN_RECORD_TYPE, (JavaType) t);\n+            return type(PATTERN_RECORD_TYPE, (JavaType) t);\n@@ -2648,1 +2649,1 @@\n-                        endNoMatchBlock.op(constant(JavaType.BOOLEAN, false)))));\n+                        endNoMatchBlock.op(constant(BOOLEAN, false)))));\n@@ -2655,1 +2656,1 @@\n-                                block.op(constant(JavaType.BOOLEAN, true)))));\n+                                block.op(constant(BOOLEAN, true)))));\n@@ -2729,1 +2730,1 @@\n-                return JavaType.BOOLEAN;\n+                return BOOLEAN;\n@@ -2735,1 +2736,1 @@\n-    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested {\n+    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n@@ -2794,0 +2795,71 @@\n+\n+        public List<Body> expressions() {\n+            return expressions;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            \/\/ Creates a block for each expression and a last block\n+            \/\/ to continue building from. An expression block branches\n+            \/\/ to the next expression block or the last block\n+            List<Block.Builder> builders = new ArrayList<>();\n+            for (int i = 0; i < expressions().size(); i++) {\n+                Block.Builder bb = b.block();\n+                if (i == 0) {\n+                    b.op(branch(bb.successor()));\n+                }\n+                builders.add(bb);\n+            }\n+            Block.Builder last = expressions().isEmpty() ? b : b.block();\n+            builders.add(last);\n+\n+            List<Value> expressions = new ArrayList<>();\n+            for (int i = 0; i < expressions().size(); i++) {\n+                Block.Builder current = builders.get(i);\n+                Block.Builder next = builders.get(i + 1);\n+                current.transformBody(expressions().get(i), List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        expressions.add(block.context().getValue(yop.yieldValue()));\n+                        block.op(branch(next.successor()));\n+                    } else if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            MethodRef listOfArray = MethodRef.method(J_U_LIST, \"of\", J_U_LIST, J_L_OBJECT_ARRAY);\n+\n+            Op.Result fragmentsList = last.op(invoke(listOfArray,\n+                    buildArrayObject(last, last.context().getValues(fragments()))));\n+\n+            Op.Result expressionsList = last.op(invoke(listOfArray, buildArrayObject(last, expressions)));\n+\n+            MethodRef stOf = MethodRef.method(J_L_STRING_TEMPLATE, \"of\", J_L_STRING_TEMPLATE,\n+                    J_U_LIST, J_U_LIST);\n+            Op.Result st = last.op(invoke(stOf, fragmentsList, expressionsList));\n+\n+            MethodRef stpProcess = MethodRef.method(J_L_STRING_TEMPLATE_PROCESSOR, \"process\",\n+                    J_L_OBJECT, J_L_STRING_TEMPLATE);\n+            Op.Result res = last.op(invoke(resultType(), stpProcess, last.context().getValue(processor()), st));\n+\n+            last.context().mapValue(result(), res);\n+\n+            return last;\n+        }\n+\n+        private static Value buildArrayObject(Block.Builder builder, List<Value> elements) {\n+            Value array = builder.op(newArray(J_L_OBJECT_ARRAY, builder.op(constant(INT, elements.size()))));\n+            for (int i = 0; i < elements.size(); i++) {\n+                Value ele = elements.get(i);\n+                if (isPrimitive(ele.type())) {\n+                    TypeElement wt = getWrapperType(ele.type());\n+                    MethodRef valueOf = MethodRef.method(wt, \"valueOf\", wt, ele.type());\n+                    ele = builder.op(invoke(valueOf, ele));\n+                }\n+                builder.op(arrayStoreOp(array, builder.op(constant(INT, i)), ele));\n+            }\n+            return array;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":127,"deletions":55,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Map;\n@@ -103,0 +104,2 @@\n+    JavaType J_U_LIST = new JavaTypeImpl(\"java.util.List\");\n+\n@@ -105,0 +108,19 @@\n+    Map<TypeElement, TypeElement> primitiveToWrapper = Map.of(\n+            BYTE, J_L_BYTE,\n+            SHORT, J_L_SHORT,\n+            INT, J_L_INTEGER,\n+            LONG, J_L_LONG,\n+            FLOAT, J_L_FLOAT,\n+            DOUBLE, J_L_DOUBLE,\n+            CHAR, J_L_CHARACTER,\n+            BOOLEAN, J_L_BOOLEAN\n+    );\n+\n+    static boolean isPrimitive(TypeElement te) {\n+        return primitiveToWrapper.containsKey(te);\n+    }\n+\n+    static TypeElement getWrapperType(TypeElement te) {\n+        return primitiveToWrapper.get(te);\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestStringTemplateOp\n+ *\/\n+\n+public class TestStringTemplateOp {\n+\n+    @CodeReflection\n+    static String f(int x, int y) {\n+        return STR.\"x = \\{x}, y = \\{y}, x + y = \\{x + y}\" ;\n+    }\n+\n+    @CodeReflection\n+    static String f2(int a, int b) {\n+        return STR.\"\\{a > b ? STR.\"\\{a} greater than \\{b}\" : STR.\"\\{b} greater than or equal \\{a}\"}\";\n+    }\n+\n+    @CodeReflection\n+    static String f3() {\n+        return STR.\"\\{(byte) 1} \\{(short) 2} \\{3} \\{4L} \\{5f} \\{6d} \\{'c'} \\{true} \\{List.of()}\";\n+    }\n+\n+    @CodeReflection\n+    static String f4() {\n+        \/\/ test with a number of expressions that is greater than the List.of parameter threshold where varargs is used\n+        return STR.\"\\{(byte) 1} \\{(short) 2} \\{3} \\{4L} \\{5f} \\{6d} \\{'c'} \\{true} \\{List.of()}, \\{!true}, \\{System.out}\";\n+    }\n+    @DataProvider\n+    public Object[][] cases() {\n+        return new Object[][] {\n+                {\"f\", new Object[] {2, 42}},\n+                {\"f2\", new Object[] {13, 7}},\n+                {\"f3\", new Object[] {}},\n+                {\"f4\", new Object[] {}}\n+        };\n+    }\n+    @Test(dataProvider = \"cases\")\n+    public void test(String caseName, Object[] args) throws InvocationTargetException, IllegalAccessException {\n+        CoreOps.FuncOp f = getFuncOp(caseName);\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, args), getMethod(caseName).invoke(null, args));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Method m = getMethod(name);\n+        return m.getCodeModel().get();\n+    }\n+\n+    static Method getMethod(String name) {\n+        Optional<Method> om = Stream.of(TestStringTemplateOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringTemplateOp.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}