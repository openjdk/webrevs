{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import static java.lang.reflect.code.type.JavaType.*;\n@@ -2821,3 +2822,1 @@\n-            Op.Result fragmentsList = builder.op(invoke(\n-                    MethodRef.method(JavaType.J_L_LIST, \"of\", JavaType.J_L_LIST, JavaType.J_L_OBJECT_ARRAY),\n-                    builder.context().getValues(fragments())));\n+            MethodRef listOfArray = MethodRef.method(JavaType.J_L_LIST, \"of\", JavaType.J_L_LIST, J_L_OBJECT_ARRAY);\n@@ -2825,3 +2824,2 @@\n-            Op.Result expressionsList = builder.op(invoke(\n-                    MethodRef.method(JavaType.J_L_LIST, \"of\", JavaType.J_L_LIST, JavaType.J_L_OBJECT_ARRAY),\n-                    expressions));\n+            Op.Result fragmentsList = builder.op(invoke(listOfArray,\n+                    buildArrayObject(builder, builder.context().getValues(fragments()))));\n@@ -2829,3 +2827,1 @@\n-            Op.Result st = builder.op(invoke(\n-                    MethodRef.method(JavaType.J_L_STRING_TEMPLATE, \"of\", JavaType.J_L_STRING_TEMPLATE, JavaType.J_L_LIST, JavaType.J_L_LIST),\n-                    fragmentsList, expressionsList));\n+            Op.Result expressionsList = builder.op(invoke(listOfArray, buildArrayObject(builder, expressions)));\n@@ -2833,3 +2829,7 @@\n-            Op.Result res = builder.op(invoke(resultType(), MethodRef.method(JavaType.J_L_STRING_TEMPLATE_PROCESSOR, \"process\",\n-                            JavaType.J_L_OBJECT, JavaType.J_L_STRING_TEMPLATE),\n-                    builder.context().getValue(processor()), st));\n+            MethodRef stOf = MethodRef.method(JavaType.J_L_STRING_TEMPLATE, \"of\", JavaType.J_L_STRING_TEMPLATE,\n+                    JavaType.J_L_LIST, JavaType.J_L_LIST);\n+            Op.Result st = builder.op(invoke(stOf, fragmentsList, expressionsList));\n+\n+            MethodRef stpProcess = MethodRef.method(JavaType.J_L_STRING_TEMPLATE_PROCESSOR, \"process\",\n+                    JavaType.J_L_OBJECT, JavaType.J_L_STRING_TEMPLATE);\n+            Op.Result res = builder.op(invoke(resultType(), stpProcess, builder.context().getValue(processor()), st));\n@@ -2841,0 +2841,35 @@\n+\n+        private static Value buildArrayObject(Block.Builder builder, List<Value> elements) {\n+            Value array = builder.op(newArray(J_L_OBJECT_ARRAY, builder.op(constant(JavaType.INT, elements.size()))));\n+            for (int i = 0; i < elements.size(); i++) {\n+                Value ele = elements.get(i);\n+                if (isPrimitive(ele.type())) {\n+                    TypeElement wt = getWrapperType(ele.type());\n+                    MethodRef valueOf = MethodRef.method(wt, \"valueOf\", wt, ele.type());\n+                    ele = builder.op(invoke(valueOf, ele));\n+                }\n+                builder.op(arrayStoreOp(array, builder.op(constant(JavaType.INT, i)), ele));\n+            }\n+            return array;\n+        }\n+\n+        private static boolean isPrimitive(TypeElement te) {\n+            return primitiveToWrapper().containsKey(te);\n+        }\n+\n+        private static TypeElement getWrapperType(TypeElement te) {\n+            return primitiveToWrapper().get(te);\n+        };\n+\n+        private static Map<TypeElement, TypeElement> primitiveToWrapper() {\n+            return Map.of(\n+                    BYTE, J_L_BYTE,\n+                    SHORT, J_L_SHORT,\n+                    JavaType.INT, J_L_INTEGER,\n+                    LONG, J_L_LONG,\n+                    FLOAT, J_L_FLOAT,\n+                    DOUBLE, J_L_DOUBLE,\n+                    CHAR, J_L_CHARACTER,\n+                    BOOLEAN, J_L_BOOLEAN\n+            );\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":47,"deletions":12,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -4,0 +5,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -23,2 +25,1 @@\n-        String s = STR.\"x = \\{x}, y = \\{y}, x + y = \\{x + y}\";\n-        return s;\n+        return STR.\"x = \\{x}, y = \\{y}, x + y = \\{x + y}\" ;\n@@ -27,3 +28,27 @@\n-    @Test\n-    public void testf() {\n-        CoreOps.FuncOp f = getFuncOp(\"f\");\n+    @CodeReflection\n+    static String f2(int a, int b) {\n+        return STR.\"\\{a > b ? STR.\"\\{a} greater than \\{b}\" : STR.\"\\{b} greater than or equal \\{a}\"}\";\n+    }\n+\n+    @CodeReflection\n+    static String f3() {\n+        return STR.\"\\{(byte) 1} \\{(short) 2} \\{3} \\{4L} \\{5f} \\{6d} \\{'c'} \\{true} \\{List.of()}\";\n+    }\n+\n+    @CodeReflection\n+    static String f4() {\n+        \/\/ test with a number of expressions that is greater than the List.of parameter threshold where varargs is used\n+        return STR.\"\\{(byte) 1} \\{(short) 2} \\{3} \\{4L} \\{5f} \\{6d} \\{'c'} \\{true} \\{List.of()}, \\{!true}, \\{System.out}\";\n+    }\n+    @DataProvider\n+    public Object[][] cases() {\n+        return new Object[][] {\n+                {\"f\", new Object[] {2, 42}},\n+                {\"f2\", new Object[] {13, 7}},\n+                {\"f3\", new Object[] {}},\n+                {\"f4\", new Object[] {}}\n+        };\n+    }\n+    @Test(dataProvider = \"cases\")\n+    public void test(String caseName, Object[] args) throws InvocationTargetException, IllegalAccessException {\n+        CoreOps.FuncOp f = getFuncOp(caseName);\n@@ -44,1 +69,1 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, 1, 2), f(1, 2));\n+        Assert.assertEquals(Interpreter.invoke(lf, args), getMethod(caseName).invoke(null, args));\n@@ -47,1 +72,0 @@\n-\n@@ -49,0 +73,5 @@\n+        Method m = getMethod(name);\n+        return m.getCodeModel().get();\n+    }\n+\n+    static Method getMethod(String name) {\n@@ -54,1 +83,1 @@\n-        return m.getCodeModel().get();\n+        return m;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringTemplateOp.java","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"}]}