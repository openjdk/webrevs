{"files":[{"patch":"@@ -156,1 +156,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -282,1 +282,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -323,1 +323,1 @@\n-            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!body.bodyType().returnType().equals(VOID)) {\n@@ -364,1 +364,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -403,1 +403,1 @@\n-            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!body.bodyType().returnType().equals(VOID)) {\n@@ -455,1 +455,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -465,1 +465,1 @@\n-        static final FunctionType PREDICATE_TYPE = FunctionType.functionType(JavaType.BOOLEAN);\n+        static final FunctionType PREDICATE_TYPE = FunctionType.functionType(BOOLEAN);\n@@ -601,1 +601,1 @@\n-                    if (!fromPred.bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+                    if (!fromPred.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n@@ -680,1 +680,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -777,1 +777,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -821,1 +821,1 @@\n-                        FunctionType.functionType(JavaType.BOOLEAN, initTypes));\n+                        FunctionType.functionType(BOOLEAN, initTypes));\n@@ -845,1 +845,1 @@\n-                        FunctionType.functionType(JavaType.VOID, initTypes));\n+                        FunctionType.functionType(VOID, initTypes));\n@@ -872,1 +872,1 @@\n-                        FunctionType.functionType(JavaType.VOID, initTypes));\n+                        FunctionType.functionType(VOID, initTypes));\n@@ -924,1 +924,1 @@\n-            if (!update.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!update.bodyType().returnType().equals(VOID)) {\n@@ -929,1 +929,1 @@\n-            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!body.bodyType().returnType().equals(VOID)) {\n@@ -1036,1 +1036,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -1108,1 +1108,1 @@\n-                        FunctionType.functionType(JavaType.VOID, elementType));\n+                        FunctionType.functionType(VOID, elementType));\n@@ -1150,1 +1150,1 @@\n-            if (expression.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (expression.bodyType().returnType().equals(VOID)) {\n@@ -1158,1 +1158,1 @@\n-            if (init.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (init.bodyType().returnType().equals(VOID)) {\n@@ -1166,1 +1166,1 @@\n-            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!body.bodyType().returnType().equals(VOID)) {\n@@ -1202,1 +1202,1 @@\n-            Block.Builder header = b.block(isArray ? List.of(JavaType.INT) : List.of());\n+            Block.Builder header = b.block(isArray ? List.of(INT) : List.of());\n@@ -1221,1 +1221,1 @@\n-                Value i = preHeader.op(constant(JavaType.INT, 0));\n+                Value i = preHeader.op(constant(INT, 0));\n@@ -1255,1 +1255,1 @@\n-                i = update.op(add(i, update.op(constant(JavaType.INT, 1))));\n+                i = update.op(add(i, update.op(constant(INT, 1))));\n@@ -1258,1 +1258,1 @@\n-                JavaType iterable = JavaType.type(JavaType.type(Iterator.class), elementType);\n+                JavaType iterable = type(type(Iterator.class), elementType);\n@@ -1296,1 +1296,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -1314,1 +1314,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n@@ -1364,1 +1364,1 @@\n-            if (!bodies.get(0).bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+            if (!bodies.get(0).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n@@ -1366,1 +1366,1 @@\n-                        \"Predicate body descriptor should be \" + FunctionType.functionType(JavaType.BOOLEAN) +\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n@@ -1371,1 +1371,1 @@\n-                        \"Body descriptor should be \" + FunctionType.functionType(JavaType.VOID) +\n+                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n@@ -1440,1 +1440,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -1461,1 +1461,1 @@\n-                Body.Builder predicate = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n+                Body.Builder predicate = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n@@ -1510,1 +1510,1 @@\n-                        \"Body descriptor should be \" + FunctionType.functionType(JavaType.VOID) +\n+                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n@@ -1513,1 +1513,1 @@\n-            if (!bodies.get(1).bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+            if (!bodies.get(1).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n@@ -1515,1 +1515,1 @@\n-                        \"Predicate body descriptor should be \" + FunctionType.functionType(JavaType.BOOLEAN) +\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n@@ -1584,1 +1584,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -1622,1 +1622,1 @@\n-                if (!b.bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+                if (!b.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n@@ -1696,1 +1696,1 @@\n-            return JavaType.BOOLEAN;\n+            return BOOLEAN;\n@@ -1718,1 +1718,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n@@ -1773,1 +1773,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n@@ -1861,1 +1861,1 @@\n-            if (!cond.bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+            if (!cond.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n@@ -1934,1 +1934,1 @@\n-                        FunctionType.functionType(JavaType.VOID, resourceTypes));\n+                        FunctionType.functionType(VOID, resourceTypes));\n@@ -1957,1 +1957,1 @@\n-                        FunctionType.functionType(JavaType.VOID, exceptionType));\n+                        FunctionType.functionType(VOID, exceptionType));\n@@ -1992,1 +1992,1 @@\n-            if (first.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (first.bodyType().returnType().equals(VOID)) {\n@@ -2043,1 +2043,1 @@\n-                if (resources.bodyType().returnType().equals(JavaType.VOID)) {\n+                if (resources.bodyType().returnType().equals(VOID)) {\n@@ -2054,1 +2054,1 @@\n-            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+            if (!body.bodyType().returnType().equals(VOID)) {\n@@ -2060,1 +2060,1 @@\n-                if (!_catch.bodyType().returnType().equals(JavaType.VOID)) {\n+                if (!_catch.bodyType().returnType().equals(VOID)) {\n@@ -2070,1 +2070,1 @@\n-                if (!finalizer.bodyType().returnType().equals(JavaType.VOID)) {\n+                if (!finalizer.bodyType().returnType().equals(VOID)) {\n@@ -2294,1 +2294,1 @@\n-                Block.Parameter t = catcherFinally.parameter(JavaType.type(Throwable.class));\n+                Block.Parameter t = catcherFinally.parameter(type(Throwable.class));\n@@ -2354,1 +2354,1 @@\n-            return JavaType.VOID;\n+            return VOID;\n@@ -2399,1 +2399,1 @@\n-            return JavaType.type(PATTERN_BINDING_TYPE, (JavaType) t);\n+            return type(PATTERN_BINDING_TYPE, (JavaType) t);\n@@ -2403,1 +2403,1 @@\n-            return JavaType.type(PATTERN_RECORD_TYPE, (JavaType) t);\n+            return type(PATTERN_RECORD_TYPE, (JavaType) t);\n@@ -2649,1 +2649,1 @@\n-                        endNoMatchBlock.op(constant(JavaType.BOOLEAN, false)))));\n+                        endNoMatchBlock.op(constant(BOOLEAN, false)))));\n@@ -2656,1 +2656,1 @@\n-                                block.op(constant(JavaType.BOOLEAN, true)))));\n+                                block.op(constant(BOOLEAN, true)))));\n@@ -2730,1 +2730,1 @@\n-                return JavaType.BOOLEAN;\n+                return BOOLEAN;\n@@ -2802,6 +2802,3 @@\n-            \/*\n-            create block for every expression body\n-            when yield branch to the next block\n-            also create a block for after expressions\n-            *\n-            * *\/\n+            \/\/ Creates a block for each expression and a last block\n+            \/\/ to continue building from. An expression block branches\n+            \/\/ to the next expression block or the last block\n@@ -2809,7 +2806,6 @@\n-            for (Body expression : expressions()) {\n-                builders.add(b.block());\n-            }\n-            if (expressions().isEmpty()) {\n-                builders.add(b);\n-            } else {\n-                builders.add(b.block());\n+            for (int i = 0; i < expressions().size(); i++) {\n+                Block.Builder bb = b.block();\n+                if (i == 0) {\n+                    b.op(branch(bb.successor()));\n+                }\n+                builders.add(bb);\n@@ -2817,1 +2813,2 @@\n-            \/\/ if no expression, we should work with b\n+            Block.Builder last = expressions().isEmpty() ? b : b.block();\n+            builders.add(last);\n@@ -2819,1 +2816,0 @@\n-            \/\/ for the first expression body, branch to its block\n@@ -2821,7 +2817,4 @@\n-            for (Body expression : expressions()) {\n-                int exprIndex = expressions().indexOf(expression);\n-                Block.Builder bb = builders.get(exprIndex);\n-                if (exprIndex == 0) {\n-                    b.op(branch(bb.successor()));\n-                }\n-                bb.transformBody(expression, List.of(), opT.andThen((block, op) -> {\n+            for (int i = 0; i < expressions().size(); i++) {\n+                Block.Builder bb = builders.get(i);\n+                int ci = i;\n+                bb.transformBody(expressions().get(i), List.of(), opT.andThen((block, op) -> {\n@@ -2830,1 +2823,1 @@\n-                        block.op(branch(builders.get(exprIndex + 1).successor()));\n+                        block.op(branch(builders.get(ci + 1).successor()));\n@@ -2840,3 +2833,1 @@\n-            Block.Builder builder = builders.getLast();\n-\n-            MethodRef listOfArray = MethodRef.method(JavaType.J_U_LIST, \"of\", JavaType.J_U_LIST, J_L_OBJECT_ARRAY);\n+            MethodRef listOfArray = MethodRef.method(J_U_LIST, \"of\", J_U_LIST, J_L_OBJECT_ARRAY);\n@@ -2844,2 +2835,2 @@\n-            Op.Result fragmentsList = builder.op(invoke(listOfArray,\n-                    buildArrayObject(builder, builder.context().getValues(fragments()))));\n+            Op.Result fragmentsList = last.op(invoke(listOfArray,\n+                    buildArrayObject(last, last.context().getValues(fragments()))));\n@@ -2847,1 +2838,1 @@\n-            Op.Result expressionsList = builder.op(invoke(listOfArray, buildArrayObject(builder, expressions)));\n+            Op.Result expressionsList = last.op(invoke(listOfArray, buildArrayObject(last, expressions)));\n@@ -2849,3 +2840,3 @@\n-            MethodRef stOf = MethodRef.method(JavaType.J_L_STRING_TEMPLATE, \"of\", JavaType.J_L_STRING_TEMPLATE,\n-                    JavaType.J_U_LIST, JavaType.J_U_LIST);\n-            Op.Result st = builder.op(invoke(stOf, fragmentsList, expressionsList));\n+            MethodRef stOf = MethodRef.method(J_L_STRING_TEMPLATE, \"of\", J_L_STRING_TEMPLATE,\n+                    J_U_LIST, J_U_LIST);\n+            Op.Result st = last.op(invoke(stOf, fragmentsList, expressionsList));\n@@ -2853,3 +2844,3 @@\n-            MethodRef stpProcess = MethodRef.method(JavaType.J_L_STRING_TEMPLATE_PROCESSOR, \"process\",\n-                    JavaType.J_L_OBJECT, JavaType.J_L_STRING_TEMPLATE);\n-            Op.Result res = builder.op(invoke(resultType(), stpProcess, builder.context().getValue(processor()), st));\n+            MethodRef stpProcess = MethodRef.method(J_L_STRING_TEMPLATE_PROCESSOR, \"process\",\n+                    J_L_OBJECT, J_L_STRING_TEMPLATE);\n+            Op.Result res = last.op(invoke(resultType(), stpProcess, last.context().getValue(processor()), st));\n@@ -2857,1 +2848,1 @@\n-            builder.context().mapValue(result(), res);\n+            last.context().mapValue(result(), res);\n@@ -2859,1 +2850,1 @@\n-            return builder;\n+            return last;\n@@ -2863,1 +2854,1 @@\n-            Value array = builder.op(newArray(J_L_OBJECT_ARRAY, builder.op(constant(JavaType.INT, elements.size()))));\n+            Value array = builder.op(newArray(J_L_OBJECT_ARRAY, builder.op(constant(INT, elements.size()))));\n@@ -2871,1 +2862,1 @@\n-                builder.op(arrayStoreOp(array, builder.op(constant(JavaType.INT, i)), ele));\n+                builder.op(arrayStoreOp(array, builder.op(constant(INT, i)), ele));\n@@ -2875,21 +2866,0 @@\n-\n-        private static boolean isPrimitive(TypeElement te) {\n-            return primitiveToWrapper().containsKey(te);\n-        }\n-\n-        private static TypeElement getWrapperType(TypeElement te) {\n-            return primitiveToWrapper().get(te);\n-        };\n-\n-        private static Map<TypeElement, TypeElement> primitiveToWrapper() {\n-            return Map.of(\n-                    BYTE, J_L_BYTE,\n-                    SHORT, J_L_SHORT,\n-                    JavaType.INT, J_L_INTEGER,\n-                    LONG, J_L_LONG,\n-                    FLOAT, J_L_FLOAT,\n-                    DOUBLE, J_L_DOUBLE,\n-                    CHAR, J_L_CHARACTER,\n-                    BOOLEAN, J_L_BOOLEAN\n-            );\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":84,"deletions":114,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Map;\n@@ -107,0 +108,19 @@\n+    Map<TypeElement, TypeElement> primitiveToWrapper = Map.of(\n+            BYTE, J_L_BYTE,\n+            SHORT, J_L_SHORT,\n+            INT, J_L_INTEGER,\n+            LONG, J_L_LONG,\n+            FLOAT, J_L_FLOAT,\n+            DOUBLE, J_L_DOUBLE,\n+            CHAR, J_L_CHARACTER,\n+            BOOLEAN, J_L_BOOLEAN\n+    );\n+\n+    static boolean isPrimitive(TypeElement te) {\n+        return primitiveToWrapper.containsKey(te);\n+    }\n+\n+    static TypeElement getWrapperType(TypeElement te) {\n+        return primitiveToWrapper.get(te);\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}