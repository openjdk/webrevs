{"files":[{"patch":"@@ -2735,1 +2735,1 @@\n-    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested {\n+    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n@@ -2794,0 +2794,47 @@\n+\n+        public List<Body> expressions() {\n+            return expressions;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+\n+            Block.Builder[] builders = new Block.Builder[1];\n+            builders[0] = b;\n+            List<Value> expressions = new ArrayList<>();\n+            for (Body expression : expressions()) {\n+                builders[0].transformBody(expression, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        expressions.add(block.context().getValue(yop.yieldValue()));\n+                        builders[0] = block;\n+                    } else if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            Block.Builder builder = builders[0];\n+\n+            Op.Result fragmentsList = builder.op(invoke(\n+                    MethodRef.method(JavaType.J_L_LIST, \"of\", JavaType.J_L_LIST, JavaType.J_L_OBJECT_ARRAY),\n+                    builder.context().getValues(fragments())));\n+\n+            Op.Result expressionsList = builder.op(invoke(\n+                    MethodRef.method(JavaType.J_L_LIST, \"of\", JavaType.J_L_LIST, JavaType.J_L_OBJECT_ARRAY),\n+                    expressions));\n+\n+            Op.Result st = builder.op(invoke(\n+                    MethodRef.method(JavaType.J_L_STRING_TEMPLATE, \"of\", JavaType.J_L_STRING_TEMPLATE, JavaType.J_L_LIST, JavaType.J_L_LIST),\n+                    fragmentsList, expressionsList));\n+\n+            Op.Result res = builder.op(invoke(resultType(), MethodRef.method(JavaType.J_L_STRING_TEMPLATE_PROCESSOR, \"process\",\n+                            JavaType.J_L_OBJECT, JavaType.J_L_STRING_TEMPLATE),\n+                    builder.context().getValue(processor()), st));\n+\n+            builder.context().mapValue(result(), res);\n+\n+            return builder;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -103,0 +103,2 @@\n+    JavaType J_L_LIST = new JavaTypeImpl(\"java.util.List\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestStringTemplateOp\n+ *\/\n+\n+public class TestStringTemplateOp {\n+\n+    @CodeReflection\n+    static String f(int x, int y) {\n+        String s = STR.\"x = \\{x}, y = \\{y}, x + y = \\{x + y}\";\n+        return s;\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, 1, 2), f(1, 2));\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestStringTemplateOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringTemplateOp.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"}]}