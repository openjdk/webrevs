{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import static java.lang.reflect.code.type.JavaType.*;\n@@ -2735,1 +2736,1 @@\n-    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested {\n+    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n@@ -2794,0 +2795,81 @@\n+\n+        public List<Body> expressions() {\n+            return expressions;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+\n+            Block.Builder[] builders = new Block.Builder[1];\n+            builders[0] = b;\n+            List<Value> expressions = new ArrayList<>();\n+            for (Body expression : expressions()) {\n+                builders[0].transformBody(expression, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        expressions.add(block.context().getValue(yop.yieldValue()));\n+                        builders[0] = block;\n+                    } else if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            Block.Builder builder = builders[0];\n+\n+            MethodRef listOfArray = MethodRef.method(JavaType.J_L_LIST, \"of\", JavaType.J_L_LIST, J_L_OBJECT_ARRAY);\n+\n+            Op.Result fragmentsList = builder.op(invoke(listOfArray,\n+                    buildArrayObject(builder, builder.context().getValues(fragments()))));\n+\n+            Op.Result expressionsList = builder.op(invoke(listOfArray, buildArrayObject(builder, expressions)));\n+\n+            MethodRef stOf = MethodRef.method(JavaType.J_L_STRING_TEMPLATE, \"of\", JavaType.J_L_STRING_TEMPLATE,\n+                    JavaType.J_L_LIST, JavaType.J_L_LIST);\n+            Op.Result st = builder.op(invoke(stOf, fragmentsList, expressionsList));\n+\n+            MethodRef stpProcess = MethodRef.method(JavaType.J_L_STRING_TEMPLATE_PROCESSOR, \"process\",\n+                    JavaType.J_L_OBJECT, JavaType.J_L_STRING_TEMPLATE);\n+            Op.Result res = builder.op(invoke(resultType(), stpProcess, builder.context().getValue(processor()), st));\n+\n+            builder.context().mapValue(result(), res);\n+\n+            return builder;\n+        }\n+\n+        private static Value buildArrayObject(Block.Builder builder, List<Value> elements) {\n+            Value array = builder.op(newArray(J_L_OBJECT_ARRAY, builder.op(constant(JavaType.INT, elements.size()))));\n+            for (int i = 0; i < elements.size(); i++) {\n+                Value ele = elements.get(i);\n+                if (isPrimitive(ele.type())) {\n+                    TypeElement wt = getWrapperType(ele.type());\n+                    MethodRef valueOf = MethodRef.method(wt, \"valueOf\", wt, ele.type());\n+                    ele = builder.op(invoke(valueOf, ele));\n+                }\n+                builder.op(arrayStoreOp(array, builder.op(constant(JavaType.INT, i)), ele));\n+            }\n+            return array;\n+        }\n+\n+        private static boolean isPrimitive(TypeElement te) {\n+            return primitiveToWrapper().containsKey(te);\n+        }\n+\n+        private static TypeElement getWrapperType(TypeElement te) {\n+            return primitiveToWrapper().get(te);\n+        };\n+\n+        private static Map<TypeElement, TypeElement> primitiveToWrapper() {\n+            return Map.of(\n+                    BYTE, J_L_BYTE,\n+                    SHORT, J_L_SHORT,\n+                    JavaType.INT, J_L_INTEGER,\n+                    LONG, J_L_LONG,\n+                    FLOAT, J_L_FLOAT,\n+                    DOUBLE, J_L_DOUBLE,\n+                    CHAR, J_L_CHARACTER,\n+                    BOOLEAN, J_L_BOOLEAN\n+            );\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":83,"deletions":1,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -103,0 +103,2 @@\n+    JavaType J_L_LIST = new JavaTypeImpl(\"java.util.List\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestStringTemplateOp\n+ *\/\n+\n+public class TestStringTemplateOp {\n+\n+    @CodeReflection\n+    static String f(int x, int y) {\n+        return STR.\"x = \\{x}, y = \\{y}, x + y = \\{x + y}\" ;\n+    }\n+\n+    @CodeReflection\n+    static String f2(int a, int b) {\n+        return STR.\"\\{a > b ? STR.\"\\{a} greater than \\{b}\" : STR.\"\\{b} greater than or equal \\{a}\"}\";\n+    }\n+\n+    @CodeReflection\n+    static String f3() {\n+        return STR.\"\\{(byte) 1} \\{(short) 2} \\{3} \\{4L} \\{5f} \\{6d} \\{'c'} \\{true} \\{List.of()}\";\n+    }\n+\n+    @CodeReflection\n+    static String f4() {\n+        \/\/ test with a number of expressions that is greater than the List.of parameter threshold where varargs is used\n+        return STR.\"\\{(byte) 1} \\{(short) 2} \\{3} \\{4L} \\{5f} \\{6d} \\{'c'} \\{true} \\{List.of()}, \\{!true}, \\{System.out}\";\n+    }\n+    @DataProvider\n+    public Object[][] cases() {\n+        return new Object[][] {\n+                {\"f\", new Object[] {2, 42}},\n+                {\"f2\", new Object[] {13, 7}},\n+                {\"f3\", new Object[] {}},\n+                {\"f4\", new Object[] {}}\n+        };\n+    }\n+    @Test(dataProvider = \"cases\")\n+    public void test(String caseName, Object[] args) throws InvocationTargetException, IllegalAccessException {\n+        CoreOps.FuncOp f = getFuncOp(caseName);\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, args), getMethod(caseName).invoke(null, args));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Method m = getMethod(name);\n+        return m.getCodeModel().get();\n+    }\n+\n+    static Method getMethod(String name) {\n+        Optional<Method> om = Stream.of(TestStringTemplateOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringTemplateOp.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}