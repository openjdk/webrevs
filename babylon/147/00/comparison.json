{"files":[{"patch":"@@ -30,4 +30,2 @@\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n+import hat.buffer.Buffer;\n+\n@@ -36,1 +34,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -38,0 +35,1 @@\n+import java.lang.reflect.Field;\n@@ -53,9 +51,13 @@\n-    \/*\n-    struct {\n-      StructTwo struct;\n-      int i;\n-    }\n-     *\/\n-    @Struct\n-    public interface StructOne {\n-        StructTwo struct();\n+    public static class Schema {\n+        private static final Map<Class<?>, MemoryLayout> typeToLayout = new HashMap<>();\n+\n+        static {\n+            typeToLayout.put(Integer.TYPE, ValueLayout.JAVA_INT);\n+            typeToLayout.put(Float.TYPE, ValueLayout.JAVA_FLOAT);\n+            typeToLayout.put(Long.TYPE, ValueLayout.JAVA_LONG);\n+            typeToLayout.put(Double.TYPE, ValueLayout.JAVA_DOUBLE);\n+            typeToLayout.put(Character.TYPE, ValueLayout.JAVA_CHAR);\n+            typeToLayout.put(Short.TYPE, ValueLayout.JAVA_SHORT);\n+            typeToLayout.put(Byte.TYPE, ValueLayout.JAVA_BYTE);\n+            typeToLayout.put(Boolean.TYPE, ValueLayout.JAVA_BOOLEAN);\n+        }\n@@ -63,1 +65,1 @@\n-        int i();\n+        private GroupLayout layout;\n@@ -65,1 +67,3 @@\n-        void i(int v);\n+        Schema(GroupLayout layout) {\n+            this.layout = layout;\n+        }\n@@ -67,2 +71,2 @@\n-        static MemoryLayout layout() {\n-            return LAYOUT;\n+        public GroupLayout layout() {\n+            return layout;\n@@ -71,7 +75,23 @@\n-        MemoryLayout LAYOUT = MemoryLayout.structLayout(\n-                        StructTwo.layout().withName(StructTwo.layout().name().orElseThrow() + \"::struct\"),\n-                        ValueLayout.JAVA_INT.withName(\"i\"))\n-                \/\/ Symbolic reference to interface\n-                \/\/ @@@ Use externalized type element form?\n-                .withName(\"layouts.LayoutExample$StructOne\");\n-    }\n+        private static MemoryLayout typeToLayout(Class<?> clazz) {\n+            if (typeToLayout.containsKey(clazz)) {\n+                return typeToLayout.get(clazz);\n+            } else if (clazz.isInterface()) {\n+                if (clazz.isAnnotationPresent(Buffer.Struct.class) || clazz.isAnnotationPresent(Buffer.Union.class)) {\n+                    try {\n+                        if (clazz.getDeclaredField(\"schema\") instanceof Field field) {\n+                            return ((Schema) field.get(null)).layout();\n+                        } else {\n+                            throw new RuntimeException(\"no Schema field found\");\n+                        }\n+                    } catch (NoSuchFieldException e) {\n+                        throw new RuntimeException(e);\n+                    } catch (IllegalAccessException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                } else {\n+                    throw new IllegalStateException(\"no Struct or Union found for \" + clazz);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"wtft\");\n+            }\n+        }\n@@ -79,4 +99,42 @@\n-    \/*\n-    struct {\n-      int i;\n-      float f;\n+        private static Schema _layoutOf(Class bufferClass, String... order) {\n+            List<MemoryLayout> memoryLayouts = new ArrayList<>();\n+            Map<String, Integer> orderMap = new LinkedHashMap<>();\n+            Arrays.stream(order).forEach(s -> orderMap.put(s, orderMap.size())); \/\/ order[0] -> 0, order[1] -> r\n+            Set<String> done = new HashSet<>();\n+            Arrays.stream(bufferClass.getDeclaredMethods())\n+                    .filter(m -> orderMap.containsKey(m.getName()))                        \/\/only methods named in array\n+                    .sorted(Comparator.comparingInt(lhs -> orderMap.get(lhs.getName()))) \/\/ sort by order in the array\n+                    .forEach(m -> {\n+                        String name = m.getName();\n+                        if (!done.contains(name)) {\n+                            MemoryLayout layout = null;\n+                            var rt = m.getReturnType();\n+                            if (rt == Void.TYPE) {\n+                                if (m.getParameterCount() == 1) {\n+                                    layout = typeToLayout(m.getParameterTypes()[0]);\n+                                } else if (m.getParameterCount() == 2) {\n+                                    throw new IllegalStateException(\"never\");\n+                                }\n+                            } else {\n+                                layout = typeToLayout(rt);\n+                            }\n+                            if (layout instanceof ValueLayout) {\n+                                memoryLayouts.add(layout.withName(name));\n+                            } else if (layout instanceof StructLayout) {\n+                                memoryLayouts.add(layout.withName(name + \"::struct\"));\n+                            }\n+                            done.add(name);\n+                        }\n+\n+                    });\n+\n+            return new Schema(MemoryLayout.structLayout(memoryLayouts.toArray(new MemoryLayout[0])).withName(bufferClass.getName()));\n+        }\n+\n+        public static <T extends Buffer> Schema layoutOf(Class<T> clazz, String... order) {\n+            return _layoutOf(clazz, order);\n+        }\n+\n+        public static <T extends Buffer.Child> Schema childLayoutOf(Class<T> clazz, String... order) {\n+            return _layoutOf(clazz, order);\n+        }\n@@ -84,0 +142,5 @@\n+    \/*\n+       struct {\n+          StructTwo struct;\n+          int i;\n+       }\n@@ -85,3 +148,20 @@\n-    @Struct\n-    public interface StructTwo {\n-        int i();\n+     @Buffer.Struct\n+        public interface StructOne extends Buffer {\n+        \/*\n+         struct {\n+             int i;\n+             float f;\n+         }\n+        *\/\n+        @Buffer.Struct\n+            interface StructTwo extends Buffer.StructChild {\n+                int i();\n+\n+                void i(int v);\n+\n+                float f();\n+\n+                void f(float v);\n+\n+                Schema schema = Schema.childLayoutOf(StructTwo.class, \"i\", \"f\");\n+            }\n@@ -89,1 +169,1 @@\n-        void i(int v);\n+            StructTwo struct();\n@@ -91,1 +171,1 @@\n-        float f();\n+            int i();\n@@ -93,1 +173,1 @@\n-        void f(float v);\n+            void i(int v);\n@@ -95,2 +175,1 @@\n-        static MemoryLayout layout() {\n-            return LAYOUT;\n+            Schema schema = Schema.layoutOf(StructOne.class, \"struct\", \"i\");\n@@ -99,7 +178,0 @@\n-        MemoryLayout LAYOUT = MemoryLayout.structLayout(\n-                        ValueLayout.JAVA_INT.withName(\"i\"),\n-                        ValueLayout.JAVA_FLOAT.withName(\"f\"))\n-                \/\/ Symbolic reference to interface\n-                \/\/ @@@ Use externalized type element form?\n-                .withName(\"layouts.LayoutExample$StructTwo\");\n-    }\n@@ -113,1 +185,1 @@\n-        StructTwo s2 = s1.struct();\n+        StructOne.StructTwo s2 = s1.struct();\n@@ -142,4 +214,0 @@\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @Target(ElementType.TYPE)\n-    public @interface Struct {\n-    }\n@@ -198,3 +266,2 @@\n-    static MemoryLayout structClassLayout(MethodHandles.Lookup l,\n-                                          Class<?> c) {\n-        if (!c.isAnnotationPresent(Struct.class)) {\n+    static MemoryLayout structClassLayout(MethodHandles.Lookup l, Class<?> c) {\n+        if (!c.isAnnotationPresent(Buffer.Struct.class)) {\n@@ -203,8 +270,1 @@\n-\n-        Method layoutMethod;\n-        try {\n-            layoutMethod = c.getMethod(\"layout\");\n-        } catch (NoSuchMethodException e) {\n-            throw new RuntimeException(e);\n-        }\n-        MethodHandle layoutHandle;\n+        Field schemaField;\n@@ -212,7 +272,3 @@\n-            layoutHandle = l.unreflect(layoutMethod);\n-        } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-        try {\n-            return (MemoryLayout) layoutHandle.invoke();\n-        } catch (Throwable e) {\n+            schemaField = c.getField(\"schema\");\n+           return  ((Schema)schemaField.get(null)).layout();\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n@@ -234,2 +290,1 @@\n-\n-        return c.isInterface() && c.isAnnotationPresent(Struct.class) ? c : null;\n+        return c.isInterface() && c.isAnnotationPresent(hat.buffer.Buffer.Struct.class) ? c : null;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":124,"deletions":69,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -27,3 +27,4 @@\n-import hat.util.StreamCounter;\n-\n-import java.lang.foreign.GroupLayout;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n@@ -32,5 +33,0 @@\n-import java.lang.foreign.PaddingLayout;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.UnionLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -45,1 +41,22 @@\n-    static <T extends Buffer>MemorySegment getMemorySegment(T buffer){\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.TYPE)\n+    public @interface Struct {\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.TYPE)\n+    public @interface Union {\n+    }\n+\n+    interface Child {\n+    }\n+\n+    @Union\n+    interface UnionChild extends Child {\n+    }\n+\n+    @Struct\n+    interface StructChild extends Child {\n+    }\n+\n+    static <T extends Buffer> MemorySegment getMemorySegment(T buffer) {\n@@ -53,7 +70,7 @@\n-   static <T extends Buffer>MemoryLayout getLayout(T buffer){\n-       try {\n-           return (MemoryLayout) buffer.getClass().getDeclaredMethod(SECRET_LAYOUT_METHOD_NAME).invoke(buffer);\n-       } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n-           throw new RuntimeException(e);\n-       }\n-   }\n+    static <T extends Buffer> MemoryLayout getLayout(T buffer) {\n+        try {\n+            return (MemoryLayout) buffer.getClass().getDeclaredMethod(SECRET_LAYOUT_METHOD_NAME).invoke(buffer);\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n@@ -61,1 +78,1 @@\n-    static <T extends Buffer>long getOffset(T buffer){\n+    static <T extends Buffer> long getOffset(T buffer) {\n@@ -69,1 +86,1 @@\n-    static <T extends Buffer> T setLength(T buffer, int length){\n+    static <T extends Buffer> T setLength(T buffer, int length) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":35,"deletions":18,"binary":false,"changes":53,"status":"modified"}]}