{"files":[{"patch":"@@ -35,1 +35,1 @@\n-import hat.optools.FuncOpParams;\n+import optkl.FuncOpParams;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.codebuilders.CodeBuilder;\n+import optkl.codebuilders.CodeBuilder;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,3 @@\n-import hat.codebuilders.CodeBuilder;\n+import optkl.FuncOpParams;\n+import optkl.ParamVar;\n+import optkl.codebuilders.CodeBuilder;\n@@ -218,1 +220,1 @@\n-            case CoreOp.VarOp $ when OpTk.paramVar($) != null -> varFuncDeclaration($);\n+            case CoreOp.VarOp $ when ParamVar.of($) != null -> varFuncDeclaration($);\n@@ -286,2 +288,3 @@\n-\n-    PTXHATKernelBuilder symbol(Op op) {\n+    \/\/ this might be duplication of CodeBuilder symbol....\n+@Override public\n+PTXHATKernelBuilder symbol(Op op) {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.codebuilders.CodeBuilder;\n+import optkl.codebuilders.CodeBuilder;\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import hat.optools.FuncOpParams;\n+import optkl.FuncOpParams;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.codebuilders.CodeBuilder;\n+import optkl.codebuilders.CodeBuilder;\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLJExtractedHATKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import hat.optools.FuncOpParams;\n+import optkl.FuncOpParams;\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.util.StreamMutable;\n+import optkl.StreamMutable;\n","filename":"hat\/core\/src\/main\/java\/hat\/FFIConfigCreator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.optools.FuncOpParams;\n+import optkl.FuncOpParams;\n@@ -34,1 +34,1 @@\n-import hat.util.StreamMutable;\n+import optkl.StreamMutable;\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.dialect.HATBarrierOp;\n-import hat.dialect.HATBlockThreadIdOp;\n-import hat.dialect.HATF16BinaryOp;\n-import hat.dialect.HATF16ConvOp;\n-import hat.dialect.HATF16ToFloatConvOp;\n-import hat.dialect.HATF16VarLoadOp;\n-import hat.dialect.HATF16VarOp;\n-import hat.dialect.HATGlobalSizeOp;\n-import hat.dialect.HATGlobalThreadIdOp;\n-import hat.dialect.HATLocalSizeOp;\n-import hat.dialect.HATLocalThreadIdOp;\n-import hat.dialect.HATLocalVarOp;\n-import hat.dialect.HATMemoryLoadOp;\n-import hat.dialect.HATPrivateInitVarOp;\n-import hat.dialect.HATPrivateVarOp;\n-import hat.dialect.HATVectorBinaryOp;\n-import hat.dialect.HATVectorLoadOp;\n-import hat.dialect.HATVectorMakeOfOp;\n-import hat.dialect.HATVectorOfOp;\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorSelectStoreOp;\n-import hat.dialect.HATVectorStoreView;\n-import hat.dialect.HATVectorVarLoadOp;\n-import hat.dialect.HATVectorVarOp;\n-import hat.optools.OpTk;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-\/* this should not be too C99 specific *\/\n-public interface BabylonCoreOpBuilder<T extends C99HATCodeBuilder<?>> {\n-    T type(ScopedCodeBuilderContext buildContext, JavaType javaType);\n-\n-    T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp);\n-\n-    T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp);\n-\n-    T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp);\n-\n-    T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, OpTk.ParamVar paramVar );\n-\n-    T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp);\n-\n-    T fieldStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp);\n-\n-    T unaryOp(ScopedCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp);\n-\n-    T binaryOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp);\n-\n-    T conditionalOp(ScopedCodeBuilderContext buildContext, JavaOp.JavaConditionalOp conditionalOp);\n-\n-    T binaryTestOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp);\n-\n-    T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp);\n-\n-    T constantOp(ScopedCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp);\n-\n-    T yieldOp(ScopedCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp);\n-\n-    T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp);\n-\n-    T tupleOp(ScopedCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp);\n-\n-    T funcCallOp(ScopedCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp);\n-\n-    T ifOp(ScopedCodeBuilderContext buildContext, JavaOp.IfOp ifOp);\n-\n-    T whileOp(ScopedCodeBuilderContext buildContext, JavaOp.WhileOp whileOp);\n-\n-    T labeledOp(ScopedCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp);\n-\n-    T continueOp(ScopedCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp);\n-\n-    T breakOp(ScopedCodeBuilderContext buildContext, JavaOp.BreakOp breakOp);\n-\n-    T forOp(ScopedCodeBuilderContext buildContext, JavaOp.ForOp forOp);\n-\n-    T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp);\n-\n-    T conditionalExpressionOp(ScopedCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp);\n-\n-    T parenthesisIfNeeded(ScopedCodeBuilderContext buildContext, Op parent, Op child);\n-\n-    T returnOp(ScopedCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp);\n-\n-    default T recurse(ScopedCodeBuilderContext buildContext, Op op) {\n-        switch (op) {\n-            case CoreOp.VarAccessOp.VarLoadOp $ -> varLoadOp(buildContext, $);\n-            case CoreOp.VarAccessOp.VarStoreOp $ -> varStoreOp(buildContext, $);\n-            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoadOp(buildContext, $);\n-            case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStoreOp(buildContext, $);\n-            case JavaOp.ConvOp $ -> convOp(buildContext, $);\n-            case CoreOp.ConstantOp $ -> constantOp(buildContext, $);\n-            case CoreOp.YieldOp $ -> yieldOp(buildContext, $);\n-            case CoreOp.FuncCallOp $ -> funcCallOp(buildContext, $);\n-            case JavaOp.InvokeOp $ -> invokeOp(buildContext, $);\n-            case JavaOp.ConditionalExpressionOp $ -> conditionalExpressionOp(buildContext, $);\n-            case CoreOp.VarOp $ when OpTk.paramVar($) instanceof OpTk.ParamVar paramVar -> varOp(buildContext, $,paramVar);\n-            case CoreOp.VarOp $ -> varOp(buildContext, $);\n-            case JavaOp.LambdaOp $ -> lambdaOp(buildContext, $);\n-            case CoreOp.TupleOp $ -> tupleOp(buildContext, $);\n-            case JavaOp.WhileOp $ -> whileOp(buildContext, $);\n-            case JavaOp.IfOp $ -> ifOp(buildContext, $);\n-            case JavaOp.ForOp $ -> forOp(buildContext, $);\n-            case CoreOp.ReturnOp $ -> returnOp(buildContext, $);\n-            case JavaOp.LabeledOp $ -> labeledOp(buildContext, $);\n-            case JavaOp.BreakOp $ -> breakOp(buildContext, $);\n-            case JavaOp.ContinueOp $ -> continueOp(buildContext, $);\n-            case JavaOp.BinaryTestOp $ -> binaryTestOp(buildContext, $);\n-            case JavaOp.BinaryOp $ -> binaryOp(buildContext, $);\n-            case JavaOp.JavaConditionalOp $ -> conditionalOp(buildContext, $);\n-            case JavaOp.UnaryOp $ -> unaryOp(buildContext, $);\n-\n-            default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n-        }\n-        return (T) this;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonCoreOpBuilder.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -51,1 +51,0 @@\n-import hat.optools.OpTk;\n@@ -55,1 +54,2 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.ParamVar;\n+import optkl.codebuilders.BabylonCoreOpBuilder;\n@@ -58,1 +58,1 @@\n-public interface BabylonKernelOpBuilder<T extends C99HATCodeBuilder<?>> extends BabylonCoreOpBuilder<T> {\n+public interface BabylonKernelOpBuilder<T extends HATCodeBuilder<?>> extends BabylonCoreOpBuilder<T,ScopedCodeBuilderContext> {\n@@ -120,1 +120,1 @@\n-            case CoreOp.VarOp $ when OpTk.paramVar($) instanceof OpTk.ParamVar paramVar -> varOp(buildContext, $,paramVar);\n+            case CoreOp.VarOp $ when ParamVar.of($) instanceof ParamVar paramVar -> varOp(buildContext, $,paramVar);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonKernelOpBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,7 @@\n+import hat.dialect.HATF16VarOp;\n+import hat.dialect.HATMemoryOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATVectorVarLoadOp;\n+import hat.dialect.HATVectorVarOp;\n@@ -31,0 +38,34 @@\n+    public final T varName(HATMemoryOp hatLocalVarOp) {\n+        identifier(hatLocalVarOp.varName());\n+        return self();\n+    }\n+\n+    public final T varName(HATVectorVarOp hatVectorVarOp) {\n+        identifier(hatVectorVarOp.varName());\n+        return self();\n+    }\n+\n+    public final T varName(HATVectorLoadOp vectorLoadOp) {\n+        identifier(vectorLoadOp.varName());\n+        return self();\n+    }\n+\n+    public final T varName(HATVectorStoreView hatVectorStoreView) {\n+        identifier(hatVectorStoreView.varName());\n+        return self();\n+    }\n+\n+    public final T varName(HATVectorBinaryOp hatVectorBinaryOp) {\n+        identifier(hatVectorBinaryOp.varName());\n+        return self();\n+    }\n+\n+    public final T varName(HATVectorVarLoadOp hatVectorVarLoadOp) {\n+        identifier(hatVectorVarLoadOp.varName());\n+        return self();\n+    }\n+\n+    public final T varName(HATF16VarOp hatF16VarOp) {\n+        identifier(hatF16VarOp.varName());\n+        return self();\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilder.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -37,2 +37,1 @@\n-import hat.ifacemapper.MappableIface;\n-import hat.optools.FuncOpParams;\n+import optkl.FuncOpParams;\n@@ -40,1 +39,2 @@\n-import hat.util.StreamMutable;\n+import optkl.ParamVar;\n+import optkl.StreamMutable;\n@@ -47,0 +47,2 @@\n+import optkl.codebuilders.BabylonCoreOpBuilder;\n+import optkl.codebuilders.CodeBuilder;\n@@ -51,1 +53,2 @@\n-public abstract class C99HATCodeBuilderContext<T extends C99HATCodeBuilderContext<T>> extends C99HATCodeBuilder<T> implements BabylonCoreOpBuilder<T> {\n+public abstract class C99HATCodeBuilderContext<T extends C99HATCodeBuilderContext<T>> extends C99HATCodeBuilder<T>\n+        implements BabylonCoreOpBuilder<T,ScopedCodeBuilderContext> {\n@@ -121,1 +124,1 @@\n-    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, OpTk.ParamVar paramVar) {\n+    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, ParamVar paramVar) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-import hat.optools.FuncOpParams;\n+import optkl.FuncOpParams;\n@@ -55,2 +55,1 @@\n-import hat.util.StreamMutable;\n-import jdk.incubator.code.Op;\n+import optkl.StreamMutable;\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,693 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.util.StreamMutable;\n-\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n-\n-\/**\n- * Extends the base TextBuilder to add common constructs\/keywords for generating C99\/Java style code.\n- *\n- * @author Gary Frost\n- *\/\n-public abstract class CodeBuilder<T extends CodeBuilder<T>> extends TextBuilder<T> implements CodeRenderer<T> {\n-\n-    public T semicolon() {\n-        return symbol(\";\");\n-    }\n-\n-    public T semicolonNl() {\n-        return semicolon().nl();\n-    }\n-\n-    public T comma() {\n-        return symbol(\",\");\n-    }\n-\n-    final public T commaSpace() {\n-        return comma().space();\n-    }\n-\n-    public T tilde() {\n-        return symbol(\"~\");\n-    }\n-\n-    public T dot() {\n-        return symbol(\".\");\n-    }\n-\n-    public T leftShift() {\n-        return symbol(\"<<\");\n-    }\n-\n-    public T rightShift() {\n-        return symbol(\">>\");\n-    }\n-\n-    public T rightShift(int v) {\n-        return rightShift().intValue(v);\n-    }\n-\n-    public T leftShift(int v) {\n-        return leftShift().intValue(v);\n-    }\n-\n-    public T equals() {\n-        return symbol(\"=\");\n-    }\n-\n-    public T assign() {\n-        return space().equals().space();\n-    }\n-\n-    public T dollar() {\n-        return symbol(\"$\");\n-    }\n-\n-    public T plusplus() {\n-        return symbol(\"++\");\n-    }\n-\n-\n-    public T minusminus() {\n-        return symbol(\"--\");\n-    }\n-\n-    public T lineComment(String line) {\n-        return comment(\"\/\/\").space().comment(line).nl();\n-    }\n-\n-    @Override\n-    public T constant(String text) {\n-        return emitText(text);\n-    }\n-\n-\n-    public T blockComment(String block) {\n-        return comment(\"\/*\").nl().comment(block).nl().symbol(\"*\/\").nl();\n-    }\n-\n-    public T blockInlineComment(String block) {\n-        return comment(\"\/*\").space().comment(block).space().comment(\"*\/\");\n-    }\n-\n-    public T newKeyword() {\n-        return keyword(\"new\");\n-    }\n-\n-\n-    public T staticKeyword() {\n-        return keyword(\"static\");\n-    }\n-\n-    public T constexprKeyword() {\n-        return keyword(\"constexpr\");\n-    }\n-\n-    public T constKeyword() {\n-        return keyword(\"const\");\n-    }\n-\n-    public T explicitKeyword() {\n-        return keyword(\"explicit\");\n-    }\n-\n-    public T virtualKeyword() {\n-        return keyword(\"virtual\");\n-    }\n-\n-    public T ifKeyword() {\n-        return keyword(\"if\");\n-    }\n-\n-    public T whileKeyword() {\n-        return keyword(\"while\");\n-    }\n-\n-\n-    public T breakKeyword() {\n-        return keyword(\"break\");\n-    }\n-\n-    public T gotoKeyword() {\n-        return keyword(\"goto\");\n-    }\n-\n-    public T continueKeyword() {\n-        return keyword(\"continue\");\n-    }\n-\n-\n-    public T colon() {\n-        return symbol(\":\");\n-    }\n-\n-\n-    public T nullConst() {\n-        return symbol(\"NULL\");\n-    }\n-\n-\n-    public T elseKeyword() {\n-        return keyword(\"else\");\n-    }\n-\n-\n-    public T returnKeyword() {\n-        return keyword(\"return\");\n-    }\n-\n-    public T returnKeyword(String identifier) {\n-        return returnKeyword().space().identifier(identifier);\n-    }\n-\n-    public T switchKeyword() {\n-        return keyword(\"switch\");\n-    }\n-\n-\n-    public T caseKeyword() {\n-        return keyword(\"case\");\n-    }\n-\n-\n-    public T defaultKeyword() {\n-        return keyword(\"default\");\n-    }\n-\n-    public T doKeyword() {\n-        return keyword(\"do\");\n-    }\n-\n-    public T forKeyword() {\n-        return keyword(\"for\");\n-    }\n-\n-    public T ampersand() {\n-        return symbol(\"&\");\n-    }\n-\n-    public T addressOf(String identifier) {\n-        return ampersand().identifier(identifier);\n-    }\n-\n-    public T asterisk() {\n-        return symbol(\"*\");\n-    }\n-\n-    public T dereference(String identifier) {\n-        return asterisk().identifier(identifier);\n-    }\n-\n-    public T mul() {\n-        return asterisk();\n-    }\n-\n-    public T percent() {\n-        return symbol(\"%\");\n-    }\n-\n-    public T mod() {\n-        return percent();\n-    }\n-\n-    public T slash() {\n-        return symbol(\"\/\");\n-    }\n-\n-    public T div() {\n-        return slash();\n-    }\n-\n-    public T plus() {\n-        return symbol(\"+\");\n-    }\n-\n-    public T add() {\n-        return plus();\n-    }\n-\n-    public T minus() {\n-        return symbol(\"-\");\n-    }\n-\n-    public T sub() {\n-        return minus();\n-    }\n-\n-    public T lt() {\n-        return symbol(\"<\");\n-    }\n-\n-    public T eq() {\n-        return equals().equals();\n-    }\n-\n-    public T lte() {\n-        return lt().equals();\n-    }\n-\n-    public T gte() {\n-        return gt().equals();\n-    }\n-\n-    public T pling() {\n-        return symbol(\"!\");\n-    }\n-\n-    public T gt() {\n-        return symbol(\">\");\n-    }\n-\n-    public T condAnd() {\n-        return symbol(\"&&\");\n-    }\n-\n-    public T condOr() {\n-        return symbol(\"||\");\n-    }\n-\n-    public T oparen() {\n-        return symbol(\"(\");\n-    }\n-\n-    public final T paren(Consumer<T> consumer) {\n-        return oparen().accept(consumer).cparen();\n-    }\n-\n-    public T ocparen() {\n-        return oparen().cparen();\n-    }\n-\n-    public T parenWhen(boolean value, Consumer<T> consumer) {\n-        if (value) {\n-            oparen().accept(consumer).cparen();\n-        } else {\n-            accept(consumer);\n-        }\n-        return self();\n-    }\n-\n-    public T semicolonTerminated(Consumer<T> consumer) {\n-        return accept(consumer).semicolon();\n-    }\n-\n-    public T semicolonNlTerminated(Consumer<T> consumer) {\n-        return semicolonTerminated(consumer).nl();\n-    }\n-\n-    public T obrace() {\n-        return symbol(\"{\");\n-    }\n-\n-    public T indent(Consumer<T> ct) {\n-        return in().accept(ct).out();\n-    }\n-\n-    public T nlIndentNl(Consumer<T> ct) {\n-        return nl().indent(ct).nl();\n-    }\n-\n-    public T braceNlIndented(Consumer<T> ct) {\n-        return obrace().nlIndentNl(ct).cbrace();\n-    }\n-\n-    public T parenNlIndented(Consumer<T> ct) {\n-        return oparen().nlIndentNl(ct).cparen();\n-    }\n-\n-    public T brace(Consumer<T> ct) {\n-        return obrace().indent(ct).cbrace();\n-    }\n-\n-    public T ocsbrace() {\n-        return osbrace().csbrace();\n-    }\n-\n-    public T ocbrace() {\n-        return obrace().cbrace();\n-    }\n-\n-    public T sbrace(Consumer<T> ct) {\n-        return osbrace().accept(ct).csbrace();\n-    }\n-\n-    public T accept(Consumer<T> ct) {\n-        ct.accept(self());\n-        return self();\n-    }\n-\n-\n-    public T ochevron() {\n-        return rawochevron();\n-    }\n-\n-    final public T rawochevron() {\n-        return emitText(\"<\");\n-    }\n-\n-    public T bar() {\n-        return symbol(\"|\");\n-    }\n-\n-    public T cchevron() {\n-        return rawcchevron();\n-    }\n-\n-    public T chevron(Consumer<T> ct) {\n-        return rawochevron().indent(ct).rawcchevron();\n-    }\n-\n-    final public T rawcchevron() {\n-        return emitText(\">\");\n-    }\n-\n-    public T osbrace() {\n-        return symbol(\"[\");\n-    }\n-\n-    public T cparen() {\n-        return symbol(\")\");\n-    }\n-\n-    public T cbrace() {\n-        return symbol(\"}\");\n-    }\n-\n-\n-    public T csbrace() {\n-        return symbol(\"]\");\n-    }\n-\n-    public T underscore() {\n-        return symbol(\"_\");\n-    }\n-\n-    public T dquote() {\n-        return symbol(\"\\\"\");\n-    }\n-\n-    public T odquote() {\n-        return dquote();\n-    }\n-\n-    public T cdquote() {\n-        return dquote();\n-    }\n-\n-    public T squote() {\n-        return symbol(\"'\");\n-    }\n-\n-    public T osquote() {\n-        return squote();\n-    }\n-\n-    public T csquote() {\n-        return squote();\n-    }\n-\n-    public T dquote(String string) {\n-        return odquote().escaped(string).cdquote();\n-    }\n-\n-    public T at() {\n-        return symbol(\"@\");\n-    }\n-\n-    public T hat() {\n-        return symbol(\"^\");\n-    }\n-\n-    public T squote(String txt) {\n-        return osquote().escaped(txt).csquote();\n-    }\n-\n-    public T rarrow() {\n-        return symbol(\"->\");\n-    }\n-\n-    public T larrow() {\n-        return symbol(\"<-\");\n-    }\n-\n-\n-    public T questionMark() {\n-        return symbol(\"?\");\n-    }\n-\n-    public T hash() {\n-        return symbol(\"#\");\n-    }\n-\n-    public T when(boolean c, Consumer<T> consumer) {\n-        if (c) {\n-            accept(consumer);\n-        }\n-        return self();\n-    }\n-\n-    public T either(boolean c, Consumer<T> lhs, Consumer<T> rhs) {\n-        if (c) {\n-            accept(lhs);\n-        } else {\n-            accept(rhs);\n-        }\n-        return self();\n-    }\n-\n-    public <I> T separated(Iterable<I> iterable, Consumer<T> separator, Consumer<I> consumer) {\n-        var first = StreamMutable.of(true);\n-        iterable.forEach(t -> {\n-            if (first.get()) {\n-                first.set(false);\n-            } else {\n-                separator.accept(self());\n-            }\n-            consumer.accept(t);\n-        });\n-        return self();\n-    }\n-\n-    public <I> T commaSpaceSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n-        return separated(iterable, _ -> commaSpace(), consumer);\n-    }\n-\n-    public T commaSpaceSeparated(Consumer<T>... consumers) {\n-        for (int i = 0; i < consumers.length; i++) {\n-            if (i > 0) {\n-                commaSpace();\n-            }\n-            consumers[i].accept(self());\n-        }\n-        return self();\n-    }\n-\n-    public T args(Consumer<T>... consumers) {\n-        return commaSpaceSeparated(consumers);\n-    }\n-\n-    public <I> T commaSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n-        return separated(iterable, _ -> comma(), consumer);\n-    }\n-\n-    public <I> T commaNlSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n-        return separated(iterable, _ -> comma().nl(), consumer);\n-    }\n-\n-    public <I> T barSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n-        return separated(iterable, _ -> bar(), consumer);\n-    }\n-\n-    public <I> T semicolonNlSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n-        return separated(iterable, _ -> semicolonNl(), consumer);\n-    }\n-\n-    public <I> T nlSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n-        return separated(iterable, _ -> nl(), consumer);\n-    }\n-\n-    public <I> T separated(Stream<I> stream, Consumer<T> separator, Consumer<I> consumer) {\n-        var first = StreamMutable.of(true);\n-        stream.forEach(t -> {\n-            if (first.get()) {\n-                first.set(false);\n-            } else {\n-                separator.accept(self());\n-            }\n-            consumer.accept(t);\n-        });\n-        return self();\n-    }\n-\n-    public <I> T commaSpaceSeparated(Stream<I> stream, Consumer<I> consumer) {\n-        return separated(stream, _ -> commaSpace(), consumer);\n-    }\n-\n-    public <I> T commaSeparated(Stream<I> stream, Consumer<I> consumer) {\n-        return separated(stream, _ -> comma(), consumer);\n-    }\n-\n-    public <I> T nlSeparated(Stream<I> stream, Consumer<I> consumer) {\n-        return separated(stream, _ -> nl(), consumer);\n-    }\n-\n-    public final T s32Type() {\n-        return typeName(\"int\");\n-    }\n-\n-    public final T s32Type(String identifier) {\n-        return s32Type().space().identifier(identifier);\n-    }\n-\n-    public final T intConstZero() {\n-        return constant(\"0\");\n-    }\n-\n-    public final T intConstOne() {\n-        return constant(\"1\");\n-    }\n-\n-    public final T intConstTwo() {\n-        return constant(\"2\");\n-    }\n-\n-    public final T voidType() {\n-        return typeName(\"void\");\n-    }\n-\n-    public final T s08Type() {\n-        return typeName(\"char\");\n-    }\n-\n-    public final T s08Type(String name) {\n-        return s08Type().space().identifier(name);\n-    }\n-\n-    public final T f32Type() {\n-        return typeName(\"float\");\n-    }\n-\n-    public final T f32Type(String identifier) {\n-        return f32Type().space().identifier(identifier);\n-    }\n-\n-    public final T s64Type() {\n-        return typeName(\"long\");\n-    }\n-\n-    public final T f64Type() {\n-        return typeName(\"double\");\n-    }\n-\n-    public final T boolType() {\n-        return typeName(\"char\");\n-    }\n-\n-    public final T s16Type() {\n-        return typeName(\"short\");\n-    }\n-\n-    public final T s16Type(String identifier) {\n-        return s16Type().space().identifier(identifier);\n-    }\n-\n-\n-    @Override\n-    public final T comment(String text) {\n-        return emitText(text);\n-    }\n-\n-    @Override\n-    public T identifier(String text) {\n-        return emitText(text);\n-    }\n-\n-    @Override\n-    public T reserved(String text) {\n-        return emitText(text);\n-    }\n-\n-    @Override\n-    public T label(String text) {\n-        return emitText(text);\n-    }\n-\n-    @Override\n-    public final T symbol(String text) {\n-        return emitText(text);\n-    }\n-\n-    @Override\n-    public final T typeName(String text) {\n-        return emitText(text);\n-    }\n-\n-    @Override\n-    public final T keyword(String text) {\n-        return emitText(text);\n-    }\n-\n-    @Override\n-    public final T literal(String text) {\n-        return emitText(text);\n-    }\n-\n-    @Override\n-    public T nl() {\n-        return super.nl();\n-    }\n-\n-    @Override\n-    public T space() {\n-        return emitText(\" \");\n-    }\n-\n-    public T builtin(String text) {\n-        return emitText(text);\n-    }\n-\n-    public T composeIdentifier(String preffix, String postfix) {\n-        return identifier(preffix + postfix);\n-    }\n-\n-    public String toCamelExceptFirst(String s) {\n-        String[] parts = s.split(\"_\");\n-        StringBuilder camelCaseString = new StringBuilder();\n-        for (String part : parts) {\n-            camelCaseString.append(camelCaseString.isEmpty()\n-                    ? part.toLowerCase()\n-                    : part.substring(0, 1).toUpperCase() + part.substring(1).toLowerCase());\n-        }\n-        return camelCaseString.toString();\n-    }\n-\n-    public final T sizeArray(int size) {\n-        return sbrace( _ -> constant(Integer.toString(size)));\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilder.java","additions":0,"deletions":693,"binary":false,"changes":693,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.optools.FuncOpParams;\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-public class CodeBuilderContext {\n-\n-    final public MethodHandles.Lookup lookup;\n-    final public CoreOp.FuncOp funcOp;\n-    final public FuncOpParams paramTable;\n-\n-    public CodeBuilderContext(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-        this.lookup = lookup;\n-        this.funcOp = funcOp;\n-        this.paramTable = new FuncOpParams(funcOp);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilderContext.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -27,6 +27,1 @@\n-\n-import hat.dialect.*;\n-import hat.optools.OpTk;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.codebuilders.CodeBuilder;\n@@ -36,117 +31,0 @@\n-    public final T oracleCopyright(){\n-        return blockComment(\"\"\"\n-                * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n-                * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-                *\n-                * This code is free software; you can redistribute it and\/or modify it\n-                * under the terms of the GNU General Public License version 2 only, as\n-                * published by the Free Software Foundation.  Oracle designates this\n-                * particular file as subject to the \"Classpath\" exception as provided\n-                * by Oracle in the LICENSE file that accompanied this code.\n-                *\n-                * This code is distributed in the hope that it will be useful, but WITHOUT\n-                * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-                * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-                * version 2 for more details (a copy is included in the LICENSE file that\n-                * accompanied this code).\n-                *\n-                * You should have received a copy of the GNU General Public License version\n-                * 2 along with this work; if not, write to the Free Software Foundation,\n-                * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-                *\n-                * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-                * or visit www.oracle.com if you need additional information or have any\n-                * questions.\"\"\"\n-      );\n-    }\n-\n-\n-    \/\/public final T s32Declaration(String name) {\n-      \/\/  return s32Type(name);\n-   \/\/ }\n-\n-    public final T varName(CoreOp.VarOp varOp) {\n-        return identifier(varOp.varName());\n-    }\n-    public final  T funcName(CoreOp.FuncCallOp funcCallOp){\n-        return identifier(funcCallOp.funcName());\n-    }\n-    public final T funcName(CoreOp.FuncOp funcOp) {\n-        return identifier(funcOp.funcName());\n-    }\n-    public final T fieldName(JavaOp.FieldAccessOp fieldAccessOp) {\n-        return identifier(OpTk.fieldName(fieldAccessOp));\n-    }\n-    public final T funcName(JavaOp.InvokeOp invokeOp){\n-        return identifier(OpTk.funcName(invokeOp));\n-    }\n-\n-    public final T varName(HATMemoryOp hatLocalVarOp) {\n-        identifier(hatLocalVarOp.varName());\n-        return self();\n-    }\n-\n-    public final T varName(HATVectorVarOp hatVectorVarOp) {\n-        identifier(hatVectorVarOp.varName());\n-        return self();\n-    }\n-\n-    public final T varName(HATVectorLoadOp vectorLoadOp) {\n-        identifier(vectorLoadOp.varName());\n-        return self();\n-    }\n-\n-    public final T varName(HATVectorStoreView hatVectorStoreView) {\n-        identifier(hatVectorStoreView.varName());\n-        return self();\n-    }\n-\n-    public final T varName(HATVectorBinaryOp hatVectorBinaryOp) {\n-        identifier(hatVectorBinaryOp.varName());\n-        return self();\n-    }\n-\n-    public final T varName(HATVectorVarLoadOp hatVectorVarLoadOp) {\n-        identifier(hatVectorVarLoadOp.varName());\n-        return self();\n-    }\n-\n-    public final T varName(HATF16VarOp hatF16VarOp) {\n-        identifier(hatF16VarOp.varName());\n-        return self();\n-    }\n-\n-    protected final T camel(String value) {\n-        return identifier(Character.toString(Character.toLowerCase(value.charAt(0)))).identifier(value.substring(1));\n-    }\n-\n-    public final T camelJoin(String prefix, String suffix) {\n-        return camel(prefix).identifier(Character.toString(Character.toUpperCase(suffix.charAt(0)))).identifier(suffix.substring(1));\n-    }\n-\n-    T symbol(Op op) {\n-        return switch (op) {\n-            case JavaOp.ModOp o -> percent();\n-            case JavaOp.MulOp o -> mul();\n-            case JavaOp.DivOp o -> div();\n-            case JavaOp.AddOp o -> plus();\n-            case JavaOp.SubOp o -> minus();\n-            case JavaOp.LtOp o -> lt();\n-            case JavaOp.GtOp o -> gt();\n-            case JavaOp.LeOp o -> lte();\n-            case JavaOp.GeOp o -> gte();\n-            case JavaOp.AshrOp o -> cchevron().cchevron();\n-            case JavaOp.LshlOp o -> ochevron().ochevron();\n-            case JavaOp.LshrOp o -> cchevron().cchevron();\n-            case JavaOp.NeqOp o -> pling().equals();\n-            case JavaOp.NegOp o -> minus();\n-            case JavaOp.EqOp o -> equals().equals();\n-            case JavaOp.NotOp o -> pling();\n-            case JavaOp.AndOp o -> ampersand();\n-            case JavaOp.OrOp o -> bar();\n-            case JavaOp.XorOp o -> hat();\n-            case JavaOp.ConditionalAndOp o -> condAnd();\n-            case JavaOp.ConditionalOrOp o -> condOr();\n-            default -> throw new IllegalStateException(\"Unexpected value: \" + op);\n-        };\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":1,"deletions":123,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.optools.FuncOpParams;\n+import optkl.FuncOpParams;\n@@ -36,0 +36,1 @@\n+import optkl.codebuilders.CodeBuilderContext;\n@@ -42,0 +43,1 @@\n+    final public FuncOpParams paramTable;\n@@ -86,2 +88,2 @@\n-                if (paramTable.parameterVarOpMap.containsKey(blockParameter)) {\n-                    return paramTable.parameterVarOpMap.get(blockParameter);\n+                if (paramTable.parameterVarOpMap.containsFrom(blockParameter)) {\n+                    return paramTable.parameterVarOpMap.getTo(blockParameter);\n@@ -240,0 +242,1 @@\n+        this.paramTable = new FuncOpParams(funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/ScopedCodeBuilderContext.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.util.StreamMutable;\n+import optkl.StreamMutable;\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/MapperUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.codebuilders.CodeBuilder;\n+import optkl.codebuilders.CodeBuilder;\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/SchemaBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import optkl.ParamVar;\n@@ -73,2 +74,0 @@\n-\n-\n@@ -307,1 +306,1 @@\n-        && !(op instanceof CoreOp.VarOp varOp && paramVar(varOp) != null)\n+        && !(op instanceof CoreOp.VarOp varOp && ParamVar.of(varOp) != null)\n@@ -773,8 +772,0 @@\n-     record ParamVar(CoreOp.VarOp varOp, Block.Parameter parameter, CoreOp.FuncOp funcOp) {\n-    }\n-\n-    static ParamVar paramVar(CoreOp.VarOp varOp) {\n-        return !varOp.isUninitialized()\n-                && varOp.operands().getFirst() instanceof Block.Parameter parameter\n-                && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp ? new ParamVar(varOp, parameter, funcOp) : null;\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,58 +0,0 @@\n-\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.util;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-\n-public class BiMap<T1 extends Block.Parameter, T2 extends Op> {\n-    public Map<T1, T2> t1ToT2 = new LinkedHashMap<>();\n-    public Map<T2, T1> t2ToT1 = new LinkedHashMap<>();\n-\n-    public void add(T1 t1, T2 t2) {\n-        t1ToT2.put(t1, t2);\n-        t2ToT1.put(t2, t1);\n-    }\n-\n-    public T1 get(T2 t2) {\n-        return t2ToT1.get(t2);\n-    }\n-\n-    public T2 get(T1 t1) {\n-        return t1ToT2.get(t1);\n-    }\n-\n-    public boolean containsKey(T1 t1) {\n-        return t1ToT2.containsKey(t1);\n-    }\n-\n-    public boolean containsKey(T2 t2) {\n-        return t2ToT1.containsKey(t2);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/util\/BiMap.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -35,1 +35,1 @@\n-import hat.util.StreamMutable;\n+import optkl.StreamMutable;\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/EliteMeshParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.util.StreamMutable;\n+import optkl.StreamMutable;\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Mesh3D.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,2 +6,0 @@\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/cuda\/cpp\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/cuda\/include\" \/>\n@@ -10,0 +8,2 @@\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/cuda\/cpp\" \/>\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/cuda\/include\" \/>\n@@ -15,0 +15,1 @@\n+    <orderEntry type=\"module\" module-name=\"optkl\" \/>\n@@ -16,1 +17,1 @@\n-<\/module>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/backend_ffi_cuda.iml","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6,2 +6,0 @@\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/opencl\/cpp\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/opencl\/include\" \/>\n@@ -10,0 +8,2 @@\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/opencl\/cpp\" \/>\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/opencl\/include\" \/>\n@@ -15,0 +15,1 @@\n+    <orderEntry type=\"module\" module-name=\"optkl\" \/>\n@@ -16,1 +17,1 @@\n-<\/module>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/backend_ffi_opencl.iml","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6,2 +6,0 @@\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/shared\/cpp\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/shared\/include\" \/>\n@@ -10,0 +8,2 @@\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/shared\/cpp\" \/>\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/shared\/include\" \/>\n@@ -14,0 +14,1 @@\n+    <orderEntry type=\"module\" module-name=\"optkl\" \/>\n@@ -15,1 +16,1 @@\n-<\/module>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/backend_ffi_shared.iml","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+    <orderEntry type=\"module\" module-name=\"optkl\" \/>\n","filename":"hat\/intellij\/backend_jextracted_opencl.iml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -12,0 +12,1 @@\n+    <orderEntry type=\"module\" module-name=\"optkl\" \/>\n@@ -13,1 +14,1 @@\n-<\/module>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/backend_jextracted_shared.iml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -11,0 +11,1 @@\n+    <orderEntry type=\"module\" module-name=\"optkl\" \/>\n","filename":"hat\/intellij\/example_experiments.iml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+public class BiMap<From, To> {\n+    public Map<From, To> fromTo = new LinkedHashMap<>();\n+    public Map<To, From> toFrom = new LinkedHashMap<>();\n+\n+    public void add(From from, To to) {\n+        fromTo.put(from, to);\n+        toFrom.put(to, from);\n+    }\n+\n+    public From getFrom(To to) {\n+        return toFrom.get(to);\n+    }\n+\n+    public To getTo(From from) {\n+        return fromTo.get(from);\n+    }\n+\n+    public boolean containsFrom(From from) {\n+        return fromTo.containsKey(from);\n+    }\n+\n+    public boolean containsTo(To to) {\n+        return toFrom.containsKey(to);\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/BiMap.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.optools;\n+package optkl;\n@@ -27,1 +27,0 @@\n-import hat.util.BiMap;\n@@ -35,1 +34,0 @@\n-import java.lang.foreign.GroupLayout;\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/FuncOpParams.java","additions":1,"deletions":3,"binary":false,"changes":4,"previous_filename":"hat\/core\/src\/main\/java\/hat\/optools\/FuncOpParams.java","status":"renamed"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+public record ParamVar(CoreOp.VarOp varOp, Block.Parameter parameter, CoreOp.FuncOp funcOp) {\n+       public static ParamVar of(CoreOp.VarOp varOp) {\n+        return !varOp.isUninitialized()\n+                && varOp.operands().getFirst() instanceof Block.Parameter parameter\n+                && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp ? new ParamVar(varOp, parameter, funcOp) : null;\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/ParamVar.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.util;\n+package optkl;\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/StreamMutable.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/util\/StreamMutable.java","status":"renamed"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.codebuilders;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.ParamVar;\n+\n+\/* this should not be too C99 specific *\/\n+public interface BabylonCoreOpBuilder<T extends CodeBuilder<?>, SB extends CodeBuilderContext> {\n+    T type(SB buildContext, JavaType javaType);\n+\n+    T varLoadOp(SB buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp);\n+\n+    T varStoreOp(SB buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp);\n+\n+    T varOp(SB buildContext, CoreOp.VarOp varOp);\n+\n+    T varOp(SB buildContext, CoreOp.VarOp varOp, ParamVar paramVar );\n+\n+    T fieldLoadOp(SB buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp);\n+\n+    T fieldStoreOp(SB buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp);\n+\n+    T unaryOp(SB buildContext, JavaOp.UnaryOp unaryOp);\n+\n+    T binaryOp(SB buildContext, JavaOp.BinaryOp binaryOp);\n+\n+    T conditionalOp(SB buildContext, JavaOp.JavaConditionalOp conditionalOp);\n+\n+    T binaryTestOp(SB buildContext, JavaOp.BinaryTestOp binaryTestOp);\n+\n+    T convOp(SB buildContext, JavaOp.ConvOp convOp);\n+\n+    T constantOp(SB buildContext, CoreOp.ConstantOp constantOp);\n+\n+    T yieldOp(SB buildContext, CoreOp.YieldOp yieldOp);\n+\n+    T lambdaOp(SB buildContext, JavaOp.LambdaOp lambdaOp);\n+\n+    T tupleOp(SB buildContext, CoreOp.TupleOp tupleOp);\n+\n+    T funcCallOp(SB buildContext, CoreOp.FuncCallOp funcCallOp);\n+\n+    T ifOp(SB buildContext, JavaOp.IfOp ifOp);\n+\n+    T whileOp(SB buildContext, JavaOp.WhileOp whileOp);\n+\n+    T labeledOp(SB buildContext, JavaOp.LabeledOp labeledOp);\n+\n+    T continueOp(SB buildContext, JavaOp.ContinueOp continueOp);\n+\n+    T breakOp(SB buildContext, JavaOp.BreakOp breakOp);\n+\n+    T forOp(SB buildContext, JavaOp.ForOp forOp);\n+\n+    T invokeOp(SB buildContext, JavaOp.InvokeOp invokeOp);\n+\n+    T conditionalExpressionOp(SB buildContext, JavaOp.ConditionalExpressionOp ternaryOp);\n+\n+    T parenthesisIfNeeded(SB buildContext, Op parent, Op child);\n+\n+    T returnOp(SB buildContext, CoreOp.ReturnOp returnOp);\n+\n+    default T recurse(SB buildContext, Op op) {\n+        switch (op) {\n+            case CoreOp.VarAccessOp.VarLoadOp $ -> varLoadOp(buildContext, $);\n+            case CoreOp.VarAccessOp.VarStoreOp $ -> varStoreOp(buildContext, $);\n+            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoadOp(buildContext, $);\n+            case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStoreOp(buildContext, $);\n+            case JavaOp.ConvOp $ -> convOp(buildContext, $);\n+            case CoreOp.ConstantOp $ -> constantOp(buildContext, $);\n+            case CoreOp.YieldOp $ -> yieldOp(buildContext, $);\n+            case CoreOp.FuncCallOp $ -> funcCallOp(buildContext, $);\n+            case JavaOp.InvokeOp $ -> invokeOp(buildContext, $);\n+            case JavaOp.ConditionalExpressionOp $ -> conditionalExpressionOp(buildContext, $);\n+            case CoreOp.VarOp $ when ParamVar.of($) instanceof ParamVar paramVar -> varOp(buildContext, $,paramVar);\n+            case CoreOp.VarOp $ -> varOp(buildContext, $);\n+            case JavaOp.LambdaOp $ -> lambdaOp(buildContext, $);\n+            case CoreOp.TupleOp $ -> tupleOp(buildContext, $);\n+            case JavaOp.WhileOp $ -> whileOp(buildContext, $);\n+            case JavaOp.IfOp $ -> ifOp(buildContext, $);\n+            case JavaOp.ForOp $ -> forOp(buildContext, $);\n+            case CoreOp.ReturnOp $ -> returnOp(buildContext, $);\n+            case JavaOp.LabeledOp $ -> labeledOp(buildContext, $);\n+            case JavaOp.BreakOp $ -> breakOp(buildContext, $);\n+            case JavaOp.ContinueOp $ -> continueOp(buildContext, $);\n+            case JavaOp.BinaryTestOp $ -> binaryTestOp(buildContext, $);\n+            case JavaOp.BinaryOp $ -> binaryOp(buildContext, $);\n+            case JavaOp.JavaConditionalOp $ -> conditionalOp(buildContext, $);\n+            case JavaOp.UnaryOp $ -> unaryOp(buildContext, $);\n+\n+            default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n+        }\n+        return (T) this;\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/BabylonCoreOpBuilder.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,775 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.codebuilders;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.StreamMutable;\n+\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Extends the base TextBuilder to add common constructs\/keywords for generating C99\/Java style code.\n+ *\n+ * @author Gary Frost\n+ *\/\n+public abstract class CodeBuilder<T extends CodeBuilder<T>> extends TextBuilder<T> implements CodeRenderer<T> {\n+\n+    public T semicolon() {\n+        return symbol(\";\");\n+    }\n+\n+    public T semicolonNl() {\n+        return semicolon().nl();\n+    }\n+\n+    public T comma() {\n+        return symbol(\",\");\n+    }\n+\n+    final public T commaSpace() {\n+        return comma().space();\n+    }\n+\n+    public T tilde() {\n+        return symbol(\"~\");\n+    }\n+\n+    public T dot() {\n+        return symbol(\".\");\n+    }\n+\n+    public T leftShift() {\n+        return symbol(\"<<\");\n+    }\n+\n+    public T rightShift() {\n+        return symbol(\">>\");\n+    }\n+\n+    public T rightShift(int v) {\n+        return rightShift().intValue(v);\n+    }\n+\n+    public T leftShift(int v) {\n+        return leftShift().intValue(v);\n+    }\n+\n+    public T equals() {\n+        return symbol(\"=\");\n+    }\n+\n+    public T assign() {\n+        return space().equals().space();\n+    }\n+\n+    public T dollar() {\n+        return symbol(\"$\");\n+    }\n+\n+    public T plusplus() {\n+        return symbol(\"++\");\n+    }\n+\n+\n+    public T minusminus() {\n+        return symbol(\"--\");\n+    }\n+\n+    public T lineComment(String line) {\n+        return comment(\"\/\/\").space().comment(line).nl();\n+    }\n+\n+    @Override\n+    public T constant(String text) {\n+        return emitText(text);\n+    }\n+\n+\n+    public T blockComment(String block) {\n+        return comment(\"\/*\").nl().comment(block).nl().symbol(\"*\/\").nl();\n+    }\n+\n+    public T blockInlineComment(String block) {\n+        return comment(\"\/*\").space().comment(block).space().comment(\"*\/\");\n+    }\n+\n+    public T newKeyword() {\n+        return keyword(\"new\");\n+    }\n+\n+\n+    public T staticKeyword() {\n+        return keyword(\"static\");\n+    }\n+\n+    public T constexprKeyword() {\n+        return keyword(\"constexpr\");\n+    }\n+\n+    public T constKeyword() {\n+        return keyword(\"const\");\n+    }\n+\n+    public T explicitKeyword() {\n+        return keyword(\"explicit\");\n+    }\n+\n+    public T virtualKeyword() {\n+        return keyword(\"virtual\");\n+    }\n+\n+    public T ifKeyword() {\n+        return keyword(\"if\");\n+    }\n+\n+    public T whileKeyword() {\n+        return keyword(\"while\");\n+    }\n+\n+\n+    public T breakKeyword() {\n+        return keyword(\"break\");\n+    }\n+\n+    public T gotoKeyword() {\n+        return keyword(\"goto\");\n+    }\n+\n+    public T continueKeyword() {\n+        return keyword(\"continue\");\n+    }\n+\n+\n+    public T colon() {\n+        return symbol(\":\");\n+    }\n+\n+\n+    public T nullConst() {\n+        return symbol(\"NULL\");\n+    }\n+\n+\n+    public T elseKeyword() {\n+        return keyword(\"else\");\n+    }\n+\n+\n+    public T returnKeyword() {\n+        return keyword(\"return\");\n+    }\n+\n+    public T returnKeyword(String identifier) {\n+        return returnKeyword().space().identifier(identifier);\n+    }\n+\n+    public T switchKeyword() {\n+        return keyword(\"switch\");\n+    }\n+\n+\n+    public T caseKeyword() {\n+        return keyword(\"case\");\n+    }\n+\n+\n+    public T defaultKeyword() {\n+        return keyword(\"default\");\n+    }\n+\n+    public T doKeyword() {\n+        return keyword(\"do\");\n+    }\n+\n+    public T forKeyword() {\n+        return keyword(\"for\");\n+    }\n+\n+    public T ampersand() {\n+        return symbol(\"&\");\n+    }\n+\n+    public T addressOf(String identifier) {\n+        return ampersand().identifier(identifier);\n+    }\n+\n+    public T asterisk() {\n+        return symbol(\"*\");\n+    }\n+\n+    public T dereference(String identifier) {\n+        return asterisk().identifier(identifier);\n+    }\n+\n+    public T mul() {\n+        return asterisk();\n+    }\n+\n+    public T percent() {\n+        return symbol(\"%\");\n+    }\n+\n+    public T mod() {\n+        return percent();\n+    }\n+\n+    public T slash() {\n+        return symbol(\"\/\");\n+    }\n+\n+    public T div() {\n+        return slash();\n+    }\n+\n+    public T plus() {\n+        return symbol(\"+\");\n+    }\n+\n+    public T add() {\n+        return plus();\n+    }\n+\n+    public T minus() {\n+        return symbol(\"-\");\n+    }\n+\n+    public T sub() {\n+        return minus();\n+    }\n+\n+    public T lt() {\n+        return symbol(\"<\");\n+    }\n+\n+    public T eq() {\n+        return equals().equals();\n+    }\n+\n+    public T lte() {\n+        return lt().equals();\n+    }\n+\n+    public T gte() {\n+        return gt().equals();\n+    }\n+\n+    public T pling() {\n+        return symbol(\"!\");\n+    }\n+\n+    public T gt() {\n+        return symbol(\">\");\n+    }\n+\n+    public T condAnd() {\n+        return symbol(\"&&\");\n+    }\n+\n+    public T condOr() {\n+        return symbol(\"||\");\n+    }\n+\n+    public T oparen() {\n+        return symbol(\"(\");\n+    }\n+\n+    public final T paren(Consumer<T> consumer) {\n+        return oparen().accept(consumer).cparen();\n+    }\n+\n+    public T ocparen() {\n+        return oparen().cparen();\n+    }\n+\n+    public T parenWhen(boolean value, Consumer<T> consumer) {\n+        if (value) {\n+            oparen().accept(consumer).cparen();\n+        } else {\n+            accept(consumer);\n+        }\n+        return self();\n+    }\n+\n+    public T semicolonTerminated(Consumer<T> consumer) {\n+        return accept(consumer).semicolon();\n+    }\n+\n+    public T semicolonNlTerminated(Consumer<T> consumer) {\n+        return semicolonTerminated(consumer).nl();\n+    }\n+\n+    public T obrace() {\n+        return symbol(\"{\");\n+    }\n+\n+    public T indent(Consumer<T> ct) {\n+        return in().accept(ct).out();\n+    }\n+\n+    public T nlIndentNl(Consumer<T> ct) {\n+        return nl().indent(ct).nl();\n+    }\n+\n+    public T braceNlIndented(Consumer<T> ct) {\n+        return obrace().nlIndentNl(ct).cbrace();\n+    }\n+\n+    public T parenNlIndented(Consumer<T> ct) {\n+        return oparen().nlIndentNl(ct).cparen();\n+    }\n+\n+    public T brace(Consumer<T> ct) {\n+        return obrace().indent(ct).cbrace();\n+    }\n+\n+    public T ocsbrace() {\n+        return osbrace().csbrace();\n+    }\n+\n+    public T ocbrace() {\n+        return obrace().cbrace();\n+    }\n+\n+    public T sbrace(Consumer<T> ct) {\n+        return osbrace().accept(ct).csbrace();\n+    }\n+\n+    public T accept(Consumer<T> ct) {\n+        ct.accept(self());\n+        return self();\n+    }\n+\n+\n+    public T ochevron() {\n+        return rawochevron();\n+    }\n+\n+    final public T rawochevron() {\n+        return emitText(\"<\");\n+    }\n+\n+    public T bar() {\n+        return symbol(\"|\");\n+    }\n+\n+    public T cchevron() {\n+        return rawcchevron();\n+    }\n+\n+    public T chevron(Consumer<T> ct) {\n+        return rawochevron().indent(ct).rawcchevron();\n+    }\n+\n+    final public T rawcchevron() {\n+        return emitText(\">\");\n+    }\n+\n+    public T osbrace() {\n+        return symbol(\"[\");\n+    }\n+\n+    public T cparen() {\n+        return symbol(\")\");\n+    }\n+\n+    public T cbrace() {\n+        return symbol(\"}\");\n+    }\n+\n+\n+    public T csbrace() {\n+        return symbol(\"]\");\n+    }\n+\n+    public T underscore() {\n+        return symbol(\"_\");\n+    }\n+\n+    public T dquote() {\n+        return symbol(\"\\\"\");\n+    }\n+\n+    public T odquote() {\n+        return dquote();\n+    }\n+\n+    public T cdquote() {\n+        return dquote();\n+    }\n+\n+    public T squote() {\n+        return symbol(\"'\");\n+    }\n+\n+    public T osquote() {\n+        return squote();\n+    }\n+\n+    public T csquote() {\n+        return squote();\n+    }\n+\n+    public T dquote(String string) {\n+        return odquote().escaped(string).cdquote();\n+    }\n+\n+    public T at() {\n+        return symbol(\"@\");\n+    }\n+\n+    public T hat() {\n+        return symbol(\"^\");\n+    }\n+\n+    public T squote(String txt) {\n+        return osquote().escaped(txt).csquote();\n+    }\n+\n+    public T rarrow() {\n+        return symbol(\"->\");\n+    }\n+\n+    public T larrow() {\n+        return symbol(\"<-\");\n+    }\n+\n+\n+    public T questionMark() {\n+        return symbol(\"?\");\n+    }\n+\n+    public T hash() {\n+        return symbol(\"#\");\n+    }\n+\n+    public T when(boolean c, Consumer<T> consumer) {\n+        if (c) {\n+            accept(consumer);\n+        }\n+        return self();\n+    }\n+\n+    public T either(boolean c, Consumer<T> lhs, Consumer<T> rhs) {\n+        if (c) {\n+            accept(lhs);\n+        } else {\n+            accept(rhs);\n+        }\n+        return self();\n+    }\n+\n+    public <I> T separated(Iterable<I> iterable, Consumer<T> separator, Consumer<I> consumer) {\n+        var first = StreamMutable.of(true);\n+        iterable.forEach(t -> {\n+            if (first.get()) {\n+                first.set(false);\n+            } else {\n+                separator.accept(self());\n+            }\n+            consumer.accept(t);\n+        });\n+        return self();\n+    }\n+\n+    public <I> T commaSpaceSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n+        return separated(iterable, _ -> commaSpace(), consumer);\n+    }\n+\n+    public T commaSpaceSeparated(Consumer<T>... consumers) {\n+        for (int i = 0; i < consumers.length; i++) {\n+            if (i > 0) {\n+                commaSpace();\n+            }\n+            consumers[i].accept(self());\n+        }\n+        return self();\n+    }\n+\n+    public T args(Consumer<T>... consumers) {\n+        return commaSpaceSeparated(consumers);\n+    }\n+\n+    public <I> T commaSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n+        return separated(iterable, _ -> comma(), consumer);\n+    }\n+\n+    public <I> T commaNlSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n+        return separated(iterable, _ -> comma().nl(), consumer);\n+    }\n+\n+    public <I> T barSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n+        return separated(iterable, _ -> bar(), consumer);\n+    }\n+\n+    public <I> T semicolonNlSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n+        return separated(iterable, _ -> semicolonNl(), consumer);\n+    }\n+\n+    public <I> T nlSeparated(Iterable<I> iterable, Consumer<I> consumer) {\n+        return separated(iterable, _ -> nl(), consumer);\n+    }\n+\n+    public <I> T separated(Stream<I> stream, Consumer<T> separator, Consumer<I> consumer) {\n+        var first = StreamMutable.of(true);\n+        stream.forEach(t -> {\n+            if (first.get()) {\n+                first.set(false);\n+            } else {\n+                separator.accept(self());\n+            }\n+            consumer.accept(t);\n+        });\n+        return self();\n+    }\n+\n+    public <I> T commaSpaceSeparated(Stream<I> stream, Consumer<I> consumer) {\n+        return separated(stream, _ -> commaSpace(), consumer);\n+    }\n+\n+    public <I> T commaSeparated(Stream<I> stream, Consumer<I> consumer) {\n+        return separated(stream, _ -> comma(), consumer);\n+    }\n+\n+    public <I> T nlSeparated(Stream<I> stream, Consumer<I> consumer) {\n+        return separated(stream, _ -> nl(), consumer);\n+    }\n+\n+    public final T s32Type() {\n+        return typeName(\"int\");\n+    }\n+\n+    public final T s32Type(String identifier) {\n+        return s32Type().space().identifier(identifier);\n+    }\n+\n+    public final T intConstZero() {\n+        return constant(\"0\");\n+    }\n+\n+    public final T intConstOne() {\n+        return constant(\"1\");\n+    }\n+\n+    public final T intConstTwo() {\n+        return constant(\"2\");\n+    }\n+\n+    public final T voidType() {\n+        return typeName(\"void\");\n+    }\n+\n+    public final T s08Type() {\n+        return typeName(\"char\");\n+    }\n+\n+    public final T s08Type(String name) {\n+        return s08Type().space().identifier(name);\n+    }\n+\n+    public final T f32Type() {\n+        return typeName(\"float\");\n+    }\n+\n+    public final T f32Type(String identifier) {\n+        return f32Type().space().identifier(identifier);\n+    }\n+\n+    public final T s64Type() {\n+        return typeName(\"long\");\n+    }\n+\n+    public final T f64Type() {\n+        return typeName(\"double\");\n+    }\n+\n+    public final T boolType() {\n+        return typeName(\"char\");\n+    }\n+\n+    public final T s16Type() {\n+        return typeName(\"short\");\n+    }\n+\n+    public final T s16Type(String identifier) {\n+        return s16Type().space().identifier(identifier);\n+    }\n+\n+\n+    @Override\n+    public final T comment(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public T identifier(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public T reserved(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public T label(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public final T symbol(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public final T typeName(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public final T keyword(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public final T literal(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public T nl() {\n+        return super.nl();\n+    }\n+\n+    @Override\n+    public T space() {\n+        return emitText(\" \");\n+    }\n+\n+    public T builtin(String text) {\n+        return emitText(text);\n+    }\n+\n+    public T composeIdentifier(String preffix, String postfix) {\n+        return identifier(preffix + postfix);\n+    }\n+\n+    public String toCamelExceptFirst(String s) {\n+        String[] parts = s.split(\"_\");\n+        StringBuilder camelCaseString = new StringBuilder();\n+        for (String part : parts) {\n+            camelCaseString.append(camelCaseString.isEmpty()\n+                    ? part.toLowerCase()\n+                    : part.substring(0, 1).toUpperCase() + part.substring(1).toLowerCase());\n+        }\n+        return camelCaseString.toString();\n+    }\n+\n+    public final T sizeArray(int size) {\n+        return sbrace( _ -> constant(Integer.toString(size)));\n+    }\n+\n+    public final T oracleCopyright(){\n+        return blockComment(\"\"\"\n+                * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+                * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+                *\n+                * This code is free software; you can redistribute it and\/or modify it\n+                * under the terms of the GNU General Public License version 2 only, as\n+                * published by the Free Software Foundation.  Oracle designates this\n+                * particular file as subject to the \"Classpath\" exception as provided\n+                * by Oracle in the LICENSE file that accompanied this code.\n+                *\n+                * This code is distributed in the hope that it will be useful, but WITHOUT\n+                * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+                * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+                * version 2 for more details (a copy is included in the LICENSE file that\n+                * accompanied this code).\n+                *\n+                * You should have received a copy of the GNU General Public License version\n+                * 2 along with this work; if not, write to the Free Software Foundation,\n+                * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+                *\n+                * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+                * or visit www.oracle.com if you need additional information or have any\n+                * questions.\"\"\"\n+        );\n+    }\n+\n+\n+    public final T varName(CoreOp.VarOp varOp) {\n+        return identifier(varOp.varName());\n+    }\n+    public final  T funcName(CoreOp.FuncCallOp funcCallOp){\n+        return identifier(funcCallOp.funcName());\n+    }\n+    public final T funcName(CoreOp.FuncOp funcOp) {\n+        return identifier(funcOp.funcName());\n+    }\n+    public final T fieldName(JavaOp.FieldAccessOp fieldAccessOp) {\n+        return identifier(fieldAccessOp.fieldDescriptor().name());\n+    }\n+    public final T funcName(JavaOp.InvokeOp invokeOp){\n+        return identifier(invokeOp.invokeDescriptor().name());\n+    }\n+\n+\n+    protected final T camel(String value) {\n+        return identifier(Character.toString(Character.toLowerCase(value.charAt(0)))).identifier(value.substring(1));\n+    }\n+\n+    public final T camelJoin(String prefix, String suffix) {\n+        return camel(prefix).identifier(Character.toString(Character.toUpperCase(suffix.charAt(0)))).identifier(suffix.substring(1));\n+    }\n+\n+    public T symbol(Op op) {\n+        return switch (op) {\n+            case JavaOp.ModOp o -> percent();\n+            case JavaOp.MulOp o -> mul();\n+            case JavaOp.DivOp o -> div();\n+            case JavaOp.AddOp o -> add();\n+            case JavaOp.SubOp o -> sub();\n+            case JavaOp.LtOp o -> lt();\n+            case JavaOp.GtOp o -> gt();\n+            case JavaOp.LeOp o -> lte();\n+            case JavaOp.GeOp o -> gte();\n+            case JavaOp.AshrOp o -> cchevron().cchevron();\n+            case JavaOp.LshlOp o -> ochevron().ochevron();\n+            case JavaOp.LshrOp o -> cchevron().cchevron();\n+            case JavaOp.NeqOp o -> pling().equals();\n+            case JavaOp.NegOp o -> minus();\n+            case JavaOp.EqOp o -> equals().equals();\n+            case JavaOp.NotOp o -> pling();\n+            case JavaOp.AndOp o -> ampersand();\n+            case JavaOp.OrOp o -> bar();\n+            case JavaOp.XorOp o -> hat();\n+            case JavaOp.ConditionalAndOp o -> condAnd();\n+            case JavaOp.ConditionalOrOp o -> condOr();\n+            default -> throw new IllegalStateException(\"Unexpected value: \" + op);\n+        };\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/CodeBuilder.java","additions":775,"deletions":0,"binary":false,"changes":775,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.codebuilders;\n+\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public class CodeBuilderContext {\n+    final public MethodHandles.Lookup lookup;\n+    final public CoreOp.FuncOp funcOp;\n+    public CodeBuilderContext(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        this.lookup = lookup;\n+        this.funcOp = funcOp;\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/CodeBuilderContext.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.codebuilders;\n+package optkl.codebuilders;\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/CodeRenderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeRenderer.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.codebuilders;\n+package optkl.codebuilders;\n@@ -132,1 +132,1 @@\n-     T emitText(String text) {\n+     protected T emitText(String text) {\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/TextBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/TextBuilder.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.codebuilders.BabylonCoreOpBuilder;\n+import optkl.codebuilders.BabylonCoreOpBuilder;\n@@ -37,1 +37,1 @@\n-public class JavaHATCodeBuilder<T extends JavaHATCodeBuilder<T>> extends C99HATCodeBuilderContext<T> implements BabylonCoreOpBuilder<T> {\n+public class JavaHATCodeBuilder<T extends JavaHATCodeBuilder<T>> extends C99HATCodeBuilderContext<T> implements BabylonCoreOpBuilder<T,ScopedCodeBuilderContext> {\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}