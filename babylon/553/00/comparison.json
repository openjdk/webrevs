{"files":[{"patch":"@@ -29,1 +29,1 @@\n-import hat.codebuilders.HATCodeBuilderContext;\n+import hat.codebuilders.ScopedCodeBuilderContext;\n@@ -93,1 +93,1 @@\n-    public CudaHATKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType javaType, CoreOp.FuncOp funcOp) {\n+    public CudaHATKernelBuilder functionDeclaration(ScopedCodeBuilderContext codeBuilderContext, JavaType javaType, CoreOp.FuncOp funcOp) {\n@@ -109,1 +109,1 @@\n-    public CudaHATKernelBuilder atomicInc(HATCodeBuilderContext buildContext, Op.Result instanceResult, String name){\n+    public CudaHATKernelBuilder atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name){\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-        paren(_ -> nl().commaNlSeparated(infoList, (info) -> {\n+        paren(_ ->\n+                nl().separated(infoList,(t)->t.comma().nl(), (info) -> {\n@@ -211,1 +212,1 @@\n-            default -> {\n+            default -> { \/\/ Why are  these switch ops not just inlined above?\n@@ -509,1 +510,4 @@\n-                paren(_ -> commaSeparated(op.operands(), _ -> param().intVal(counter[0]++))).ptxNl();\n+                paren(_ ->\n+                        separated(op.operands(),(_)->commaSpace(),\n+                        \/\/commaSeparated(op.operands(),\n+                                _ -> param().intVal(counter[0]++))).ptxNl();\n@@ -732,3 +736,0 @@\n-    public PTXHATKernelBuilder commaSpace() {\n-        return comma().space();\n-    }\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.codebuilders.HATCodeBuilderContext;\n+import hat.codebuilders.ScopedCodeBuilderContext;\n@@ -91,1 +91,1 @@\n-    public OpenCLHATKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType type, CoreOp.FuncOp funcOp) {\n+    public OpenCLHATKernelBuilder functionDeclaration(ScopedCodeBuilderContext codeBuilderContext, JavaType type, CoreOp.FuncOp funcOp) {\n@@ -106,1 +106,1 @@\n-    public OpenCLHATKernelBuilder atomicInc(HATCodeBuilderContext buildContext, Op.Result instanceResult, String name){\n+    public OpenCLHATKernelBuilder atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name){\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.codebuilders.HATCodeBuilderContext;\n+import hat.codebuilders.ScopedCodeBuilderContext;\n@@ -90,1 +90,1 @@\n-    public OpenCLHatKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType type, CoreOp.FuncOp funcOp) {\n+    public OpenCLHatKernelBuilder functionDeclaration(ScopedCodeBuilderContext codeBuilderContext, JavaType type, CoreOp.FuncOp funcOp) {\n@@ -100,1 +100,1 @@\n-    public OpenCLHatKernelBuilder atomicInc(HATCodeBuilderContext buildContext, Op.Result instanceResult, String name){\n+    public OpenCLHatKernelBuilder atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name){\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.util.StreamCounter;\n@@ -38,1 +37,1 @@\n-    SchemaBuilder layout(MemoryLayout layout, SequenceLayout tailSequenceLayout) {\n+    SchemaBuilder layout(MemoryLayout layout) {\n@@ -41,21 +40,5 @@\n-            case StructLayout structLayout -> {\n-                brace((_) -> {\n-                    StreamCounter.of(structLayout.memberLayouts().stream(), (c, l) -> {\n-                        if (c.isNotFirst()) {\n-                            comma();\n-                        }\n-                        layout(l, tailSequenceLayout);\n-                    });\n-                });\n-            }\n-            case UnionLayout unionLayout -> {\n-                chevron((_) -> {\n-                    StreamCounter.of(unionLayout.memberLayouts().stream(), (c, l) -> {\n-                        if (c.isNotFirst()) {\n-                            bar();\n-                        }\n-                        layout(l, tailSequenceLayout);\n-                    });\n-                });\n-            }\n-            case ValueLayout valueLayout -> {\n+            case StructLayout structLayout ->\n+                brace((_) -> separated(structLayout.memberLayouts(),(_)->comma(), this::layout));\n+            case UnionLayout unionLayout ->\n+                chevron((_) -> separated(unionLayout.memberLayouts(),(_)->bar(), this::layout));\n+            case ValueLayout valueLayout ->\n@@ -63,2 +46,1 @@\n-            }\n-            case PaddingLayout paddingLayout -> {\n+            case PaddingLayout paddingLayout ->\n@@ -66,12 +48,2 @@\n-            }\n-            case SequenceLayout sequenceLayout -> {\n-                sbrace((_) -> {\n-                   \/\/ if (sequenceLayout.equals(tailSequenceLayout) && incomplete) {\n-                     \/\/   asterisk();\n-                    \/\/} else {\n-                        literal(sequenceLayout.elementCount());\n-                   \/\/ }\n-                    colon();\n-                    layout(sequenceLayout.elementLayout(), tailSequenceLayout);\n-                });\n-            }\n+            case SequenceLayout sequenceLayout ->\n+                sbrace((_) -> literal(sequenceLayout.elementCount()).colon().layout(sequenceLayout.elementLayout()));\n@@ -83,24 +55,2 @@\n-       \/\/ if (complete) {\n-            return new SchemaBuilder()\n-                    .literal(Buffer.getMemorySegment(buffer).byteSize())\n-                    .hash()\n-                    .layout(Buffer.getLayout(buffer), null)\n-                    .toString();\n-    \/*    }else{\n-            MemoryLayout memoryLayout = Buffer.getLayout(buffer);\n-            if (memoryLayout instanceof StructLayout structLayout) {\n-                var memberLayouts = structLayout.memberLayouts();\n-                if (memberLayouts.getLast() instanceof SequenceLayout tailSequenceLayout) {\n-                    return new SchemaBuilder()\n-                            .literal(memoryLayout.byteOffset(\n-                                    MemoryLayout.PathElement.groupElement(memberLayouts.size() - 1)))\n-                            .plus()\n-                            .layout(Buffer.getLayout(buffer),tailSequenceLayout,true)\n-                            .toString();\n-                } else {\n-                    throw new IllegalStateException(\"IncompleteBuffer last layout is not SequenceLayout!\");\n-                }\n-            } else {\n-                throw new IllegalStateException(\"IncompleteBuffer must be a StructLayout\");\n-            }\n-        }*\/\n+            return new SchemaBuilder().literal(Buffer.getMemorySegment(buffer).byteSize())\n+                    .hash().layout(Buffer.getLayout(buffer)).toString();\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/SchemaBuilder.java","additions":11,"deletions":61,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.codebuilders;\n+\n+import hat.optools.OpTk;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+\/* this should not be too C99 specific *\/\n+public interface BabylonOpBuilder<T extends HATCodeBuilderWithContext<?>> {\n+\n+    T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp);\n+\n+    T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp);\n+\n+    T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp);\n+\n+    T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, OpTk.ParamVar paramVar );\n+\n+    T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp);\n+\n+    T fieldStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp);\n+\n+    T unaryOp(ScopedCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp);\n+\n+    T binaryOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp);\n+\n+    T conditionalOp(ScopedCodeBuilderContext buildContext, JavaOp.JavaConditionalOp conditionalOp);\n+\n+    T binaryTestOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp);\n+\n+    T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp);\n+\n+    T constantOp(ScopedCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp);\n+\n+    T yieldOp(ScopedCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp);\n+\n+    T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp);\n+\n+    T tupleOp(ScopedCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp);\n+\n+    T funcCallOp(ScopedCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp);\n+\n+    T ifOp(ScopedCodeBuilderContext buildContext, JavaOp.IfOp ifOp);\n+\n+    T whileOp(ScopedCodeBuilderContext buildContext, JavaOp.WhileOp whileOp);\n+\n+    T labeledOp(ScopedCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp);\n+\n+    T continueOp(ScopedCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp);\n+\n+    T breakOp(ScopedCodeBuilderContext buildContext, JavaOp.BreakOp breakOp);\n+\n+    T forOp(ScopedCodeBuilderContext buildContext, JavaOp.ForOp forOp);\n+\n+    T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp);\n+\n+    T conditionalExpressionOp(ScopedCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp);\n+\n+    T parenthesisIfNeeded(ScopedCodeBuilderContext buildContext, Op parent, Op child);\n+\n+    T returnOp(ScopedCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp);\n+\n+    default T recurse(ScopedCodeBuilderContext buildContext, Op op) {\n+        switch (op) {\n+            case CoreOp.VarAccessOp.VarLoadOp $ -> varLoadOp(buildContext, $);\n+            case CoreOp.VarAccessOp.VarStoreOp $ -> varStoreOp(buildContext, $);\n+            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoadOp(buildContext, $);\n+            case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStoreOp(buildContext, $);\n+            case JavaOp.ConvOp $ -> convOp(buildContext, $);\n+            case CoreOp.ConstantOp $ -> constantOp(buildContext, $);\n+            case CoreOp.YieldOp $ -> yieldOp(buildContext, $);\n+            case CoreOp.FuncCallOp $ -> funcCallOp(buildContext, $);\n+            case JavaOp.InvokeOp $ -> invokeOp(buildContext, $);\n+            case JavaOp.ConditionalExpressionOp $ -> conditionalExpressionOp(buildContext, $);\n+            case CoreOp.VarOp $ when OpTk.paramVar($) instanceof OpTk.ParamVar paramVar -> varOp(buildContext, $,paramVar);\n+            case CoreOp.VarOp $ -> varOp(buildContext, $);\n+            case JavaOp.LambdaOp $ -> lambdaOp(buildContext, $);\n+            case CoreOp.TupleOp $ -> tupleOp(buildContext, $);\n+            case JavaOp.WhileOp $ -> whileOp(buildContext, $);\n+            case JavaOp.IfOp $ -> ifOp(buildContext, $);\n+            case JavaOp.ForOp $ -> forOp(buildContext, $);\n+            case CoreOp.ReturnOp $ -> returnOp(buildContext, $);\n+            case JavaOp.LabeledOp $ -> labeledOp(buildContext, $);\n+            case JavaOp.BreakOp $ -> breakOp(buildContext, $);\n+            case JavaOp.ContinueOp $ -> continueOp(buildContext, $);\n+            case JavaOp.BinaryTestOp $ -> binaryTestOp(buildContext, $);\n+            case JavaOp.BinaryOp $ -> binaryOp(buildContext, $);\n+            case JavaOp.JavaConditionalOp $ -> conditionalOp(buildContext, $);\n+            case JavaOp.UnaryOp $ -> unaryOp(buildContext, $);\n+            default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n+        }\n+        return (T) this;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonOpBuilder.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(lookup,funcOp);\n+        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(lookup,funcOp);\n@@ -46,1 +46,2 @@\n-                commaSeparated(buildContext.paramTable.list(), (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n+                separated(buildContext.paramTable.list(), (_)->comma().space()\n+                        , (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n@@ -49,5 +50,3 @@\n-        braceNlIndented(_ ->\n-                OpTk.rootOpStream(funcOp)\n-                        .forEach(root ->\n-                                recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root)).nl()\n-                        )\n+        braceNlIndented(_ -> OpTk.rootOpStream(funcOp).forEach(root ->\n+                        recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root)).nl()\n+                )\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import hat.util.StreamCounter;\n@@ -41,2 +40,0 @@\n-import java.lang.foreign.GroupLayout;\n-\n@@ -162,1 +159,1 @@\n-    public T type(HATCodeBuilderContext buildContext, JavaType javaType) {\n+    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n@@ -190,1 +187,1 @@\n-        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup\n+        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup\n@@ -192,1 +189,1 @@\n-        buildContext.scope(buildContext.funcOp, () -> {\n+        buildContext.funcScope(buildContext.funcOp, () -> {\n@@ -198,1 +195,7 @@\n-                    commaSeparated(list, (info) -> type(buildContext,info.javaType).space().varName(info.varOp))\n+                    separated(list,(_)->comma().nl(), info ->\n+                            type(buildContext,info.javaType).space().varName(info.varOp))\n+            );\n+            braceNlIndented(_ ->\n+                separated(OpTk.rootOpStream(buildContext.funcOp),(_)->nl(),root ->\n+                        recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n+                )\n@@ -200,6 +203,0 @@\n-\n-            braceNlIndented(_ -> {\n-                StreamCounter.of(OpTk.rootOpStream(buildContext.funcOp), (c, root) ->\n-                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n-                );\n-            });\n@@ -211,2 +208,2 @@\n-        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(lookup,funcOp);\n-        buildContext.scope(buildContext.funcOp, () -> {\n+        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(lookup,funcOp);\n+        buildContext.funcScope(buildContext.funcOp, () -> {\n@@ -219,1 +216,2 @@\n-                    commaSeparated(list, (info) -> type(buildContext,info.javaType).space().varName(info.varOp))\n+                    separated(list,(_)->comma().nl(), info ->\n+                            type(buildContext,info.javaType).space().varName(info.varOp))\n@@ -222,5 +220,5 @@\n-            braceNlIndented(_ -> {\n-                StreamCounter.of(OpTk.rootOpStream(buildContext.funcOp), (c, root) ->\n-                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n-                );\n-            });\n+            braceNlIndented(_ ->\n+                separated(OpTk.rootOpStream(buildContext.funcOp),(_)->nl(),root->\n+                       recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n+                )\n+            );\n@@ -233,2 +231,2 @@\n-        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(kernelEntrypoint.callGraph.computeContext.accelerator.lookup,kernelEntrypoint.funcOp());\n-        buildContext.scope(buildContext.funcOp, () -> {\n+        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(kernelEntrypoint.callGraph.computeContext.accelerator.lookup,kernelEntrypoint.funcOp());\n+        buildContext.funcScope(buildContext.funcOp, () -> {\n@@ -254,2 +252,2 @@\n-                StreamCounter.of(OpTk.rootOpStream(buildContext.funcOp), (c, root) ->\n-                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n+                separated(OpTk.rootOpStream(buildContext.funcOp), (_)->nl(), root ->\n+                        recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n@@ -269,1 +267,1 @@\n-    public abstract T functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType javaType, CoreOp.FuncOp funcOp);\n+    public abstract T functionDeclaration(ScopedCodeBuilderContext codeBuilderContext, JavaType javaType, CoreOp.FuncOp funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":24,"deletions":26,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-\n-import hat.util.StreamCounter;\n@@ -31,1 +29,0 @@\n-import java.util.Collection;\n@@ -33,0 +30,1 @@\n+import java.util.stream.Stream;\n@@ -84,0 +82,3 @@\n+    final public T commaSpace() {\n+        return comma().space();\n+    }\n@@ -294,22 +295,0 @@\n-    public T dqattr(String name, String value) {\n-        return append(name).equals().dquote(value);\n-\n-    }\n-\n-    public T sqattr(String name, String value) {\n-        return append(name).equals().squote(value);\n-\n-    }\n-\n-    public T attr(String name, String value) {\n-        return append(name).equals().append(value);\n-    }\n-\n-    public T attr(String name, Integer value) {\n-        return append(name).equals().append(value.toString());\n-    }\n-\n-    public T attr(String name, Float value) {\n-        return append(name).equals().append(value.toString());\n-    }\n-\n@@ -335,9 +314,1 @@\n-    public T line(Consumer<T> consumer) {\n-        return accept(consumer).nl();\n-    }\n-\n-    public T semicolonTerminatedLine(Consumer<T> consumer) {\n-        return semicolonTerminatedLineNoNl(consumer).nl();\n-    }\n-\n-    public T semicolonTerminatedLineNoNl(Consumer<T> consumer) {\n+    public T semicolonTerminated(Consumer<T> consumer) {\n@@ -346,0 +317,3 @@\n+    public T semicolonNlTerminated(Consumer<T> consumer) {\n+        return semicolonTerminated(consumer).nl();\n+    }\n@@ -351,2 +325,5 @@\n-    public T obracket() {\n-        return symbol(\"[\");\n+    public T indent(Consumer<T> ct) {\n+        return in().accept(ct).out();\n+    }\n+    public T nlIndentNl(Consumer<T> ct) {\n+        return nl().indent(ct).nl();\n@@ -354,1 +331,0 @@\n-\n@@ -356,1 +332,1 @@\n-        return obrace().nl().indent(ct).nl().cbrace();\n+        return obrace().nlIndentNl(ct).cbrace();\n@@ -360,1 +336,1 @@\n-        return oparen().nl().indent(ct).nl().cparen();\n+        return oparen().nlIndentNl(ct).cparen();\n@@ -376,3 +352,0 @@\n-    public T indent(Consumer<T> ct) {\n-        return in().accept(ct).out();\n-    }\n@@ -406,1 +379,0 @@\n-\n@@ -411,4 +383,0 @@\n-    public T cbracket() {\n-        return symbol(\"]\");\n-    }\n-\n@@ -537,27 +505,7 @@\n-\n-    public <I> T zeroOrOneOrMore(Collection<I> collection, Consumer<T> zero, Consumer<I> one, Consumer<Iterable<I>> more) {\n-        if (collection == null || collection.isEmpty()) {\n-            zero.accept(self());\n-        } else if (collection.size() == 1) {\n-            one.accept(collection.iterator().next());\n-        } else {\n-            more.accept(collection);\n-        }\n-        return self();\n-    }\n-\n-\n-    public <I> T commaSeparated(Iterable<I> iterable, Consumer<I> c) {\n-\n-        StreamCounter.of(iterable, (counter, t) -> {\n-            if (counter.isNotFirst()) {\n-                comma().space();\n-            }\n-            c.accept(t);\n-        });\n-        return self();\n-    }\n-    public <I> T commaNlSeparated(Iterable<I> iterable, Consumer<I> c) {\n-        StreamCounter.of(iterable, (counter, t) -> {\n-            if (counter.isNotFirst()) {\n-                comma().nl();\n+    public <I> T separated(Iterable<I> iterable, Consumer<T> separator, Consumer<I> consumer) {\n+        var first  =StreamMutable.of(true);\n+        iterable.forEach(  t -> {\n+            if (first.get()){\n+                first.set(false);\n+            }else{\n+                separator.accept(self());\n@@ -565,1 +513,1 @@\n-            c.accept(t);\n+            consumer.accept(t);\n@@ -569,5 +517,7 @@\n-\n-    public <I> T nlSeparated(Iterable<I> iterable, Consumer<I> c) {\n-        StreamCounter.of(iterable, (countStream, t) -> {\n-            if (countStream.isNotFirst()) {\n-                nl();\n+    public <I> T separated(Stream<I> stream, Consumer<T> separator, Consumer<I> consumer) {\n+        var first  =StreamMutable.of(true);\n+        stream.forEach(  t -> {\n+            if (first.get()){\n+                first.set(false);\n+            }else{\n+                separator.accept(self());\n@@ -575,1 +525,1 @@\n-            c.accept(t);\n+            consumer.accept(t);\n@@ -579,8 +529,0 @@\n-\n-    public static class ConcreteCodeBuilder extends CodeBuilder<ConcreteCodeBuilder> {\n-    }\n-\n-    public static ConcreteCodeBuilder concreteCodeBuilder() {\n-        return new ConcreteCodeBuilder();\n-    }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilder.java","additions":31,"deletions":89,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.codebuilders;\n+\n+import hat.optools.FuncOpParams;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class CodeBuilderContext {\n+    final public MethodHandles.Lookup lookup;\n+    final public CoreOp.FuncOp funcOp;\n+    final public FuncOpParams paramTable;\n+    public CodeBuilderContext(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        this.lookup = lookup;\n+        this.funcOp = funcOp;\n+        this.paramTable = new FuncOpParams(funcOp);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilderContext.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-\/\/import hat.optools.UnaryArithmeticOrLogicOpWrapper;\n@@ -103,1 +102,1 @@\n-    T hashDefineKeyword() {\n+    public T hashDefineKeyword() {\n@@ -107,1 +106,1 @@\n-    T hashIfdefKeyword() {\n+    public T hashIfdefKeyword() {\n@@ -111,1 +110,1 @@\n-    T hashIfndefKeyword() {\n+    public T hashIfndefKeyword() {\n@@ -134,5 +133,5 @@\n-  public T varName(CoreOp.VarOp varOp) {\n-      identifier(varOp.varName());\n-      return self();\n-  }\n-    T pragmaKeyword() {\n+    public T varName(CoreOp.VarOp varOp) {\n+        identifier(varOp.varName());\n+        return self();\n+    }\n+    public T pragmaKeyword() {\n@@ -142,1 +141,1 @@\n-    T includeKeyword() {\n+    public T includeKeyword() {\n@@ -174,1 +173,1 @@\n-    T externKeyword() {\n+    public T externKeyword() {\n@@ -182,1 +181,1 @@\n-    T camelJoin(String prefix, String suffix) {\n+    public T camelJoin(String prefix, String suffix) {\n@@ -241,1 +240,1 @@\n-        return semicolonTerminatedLine(_ -> typedefKeyword().space().accept(lhs).space().accept(rhs));\n+        return semicolonNlTerminated(_ -> typedefKeyword().space().accept(lhs).space().accept(rhs));\n@@ -256,0 +255,1 @@\n+    \/\/Unused?\n@@ -278,1 +278,1 @@\n-        return identifier(invokeOp.invokeDescriptor().name());\n+        return identifier(OpTk.funcName(invokeOp));\n@@ -281,103 +281,0 @@\n-    \/* this should not be too C99 specific *\/\n-    public  interface CodeBuilderInterface<T extends HATCodeBuilderWithContext<?>> {\n-\n-\n-         T varLoad(HATCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp);\n-\n-         T varStore(HATCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp);\n-\n-\n-         T varDeclaration(HATCodeBuilderContext buildContext, CoreOp.VarOp varOp);\n-\n-         T varFuncDeclaration(HATCodeBuilderContext buildContext, CoreOp.VarOp varOp);\n-\n-         T fieldLoad(HATCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp);\n-\n-         T fieldStore(HATCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp);\n-\n-        T unaryOperation(HATCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp);\n-\n-\n-        T binaryOperation(HATCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp);\n-\n-        T logical(HATCodeBuilderContext buildContext, JavaOp.JavaConditionalOp logicalOp);\n-\n-        T binaryTest(HATCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp);\n-\n-        T conv(HATCodeBuilderContext buildContext, JavaOp.ConvOp convOp);\n-\n-\n-        T constant(HATCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp);\n-\n-        T javaYield(HATCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp);\n-\n-        T lambda(HATCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp);\n-\n-        T tuple(HATCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp);\n-\n-        T funcCall(HATCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp);\n-\n-        T javaIf(HATCodeBuilderContext buildContext, JavaOp.IfOp ifOp);\n-\n-        T javaWhile(HATCodeBuilderContext buildContext, JavaOp.WhileOp whileOp);\n-\n-        T javaLabeled(HATCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp);\n-\n-        T javaContinue(HATCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp);\n-\n-        T javaBreak(HATCodeBuilderContext buildContext, JavaOp.BreakOp breakOp);\n-\n-        T javaFor(HATCodeBuilderContext buildContext, JavaOp.ForOp forOp);\n-\n-\n-         T methodCall(HATCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp);\n-\n-         T ternary(HATCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp);\n-\n-         T parenthesisIfNeeded(HATCodeBuilderContext buildContext, Op parent, Op child);\n-\n-       \/\/  T parencedence(HATCodeBuilderContext buildContext, OpWrapper<?> parent, OpWrapper<?> child);\n-\n-        \/\/ T parencedence(HATCodeBuilderContext buildContext, Op parent, Op child);\n-\n-        \/\/ T parencedence(HATCodeBuilderContext buildContext, Op parent, Op child);\n-\n-         T ret(HATCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp);\n-\n-        default T recurse(HATCodeBuilderContext buildContext, Op op) {\n-            switch (op) {\n-                case CoreOp.VarAccessOp.VarLoadOp $ -> varLoad(buildContext, $);\n-                case CoreOp.VarAccessOp.VarStoreOp $ -> varStore(buildContext, $);\n-                case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoad(buildContext, $);\n-                case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStore(buildContext, $);\n-\n-\n-\n-                case JavaOp.ConvOp $ -> conv(buildContext, $);\n-                case CoreOp.ConstantOp $ -> constant(buildContext, $);\n-                case CoreOp.YieldOp $ -> javaYield(buildContext, $);\n-                case CoreOp.FuncCallOp $ -> funcCall(buildContext, $);\n-                case JavaOp.InvokeOp $ -> methodCall(buildContext, $);\n-                case JavaOp.ConditionalExpressionOp $ -> ternary(buildContext, $);\n-                case CoreOp.VarOp $ when OpTk.paramVar($) != null -> varFuncDeclaration(buildContext, $);\n-                case CoreOp.VarOp $ -> varDeclaration(buildContext, $);\n-                case JavaOp.LambdaOp $ -> lambda(buildContext, $);\n-                case CoreOp.TupleOp $ -> tuple(buildContext, $);\n-                case JavaOp.WhileOp $ -> javaWhile(buildContext, $);\n-                case JavaOp.IfOp $ -> javaIf(buildContext, $);\n-                case JavaOp.ForOp $ -> javaFor(buildContext, $);\n-                case CoreOp.ReturnOp $ -> ret(buildContext, $);\n-                case JavaOp.LabeledOp $ -> javaLabeled(buildContext, $);\n-                case JavaOp.BreakOp $ -> javaBreak(buildContext, $);\n-                case JavaOp.ContinueOp $ -> javaContinue(buildContext, $);\n-                case JavaOp.BinaryTestOp $ -> binaryTest(buildContext, $);\n-                case JavaOp.BinaryOp $ -> binaryOperation(buildContext, $);\n-                case JavaOp.JavaConditionalOp $ -> logical(buildContext, $);\n-                case JavaOp.UnaryOp $ -> unaryOperation(buildContext, $);\n-                default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n-            }\n-            return (T) this;\n-        }\n-\n-\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":14,"deletions":117,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -1,245 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.optools.FuncOpParams;\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-public class HATCodeBuilderContext {\n-    public static class Scope<O extends Op> {\n-        final Scope<?> parent;\n-        final O op;\n-\n-        public Scope(Scope<?> parent, O op) {\n-            this.parent = parent;\n-            this.op = op;\n-        }\n-\n-        public CoreOp.VarOp resolve(Value value) {\n-            if (value instanceof Op.Result result && result.op() instanceof CoreOp.VarOp varOp) {\n-                return varOp;\n-            }\n-            if (parent != null) {\n-                return parent.resolve(value);\n-            }\n-            throw new IllegalStateException(\"failed to resolve VarOp for value \" + value);\n-        }\n-    }\n-\n-    public static class FuncScope extends Scope<CoreOp.FuncOp> {\n-        final FuncOpParams paramTable;\n-        FuncScope(Scope<?> parent, CoreOp.FuncOp funcOp) {\n-            super(parent, funcOp);\n-            paramTable = new FuncOpParams(funcOp);\n-        }\n-\n-        @Override\n-        public CoreOp.VarOp resolve(Value value) {\n-            if (value instanceof Block.Parameter blockParameter) {\n-                if (paramTable.parameterVarOpMap.containsKey(blockParameter)) {\n-                    return paramTable.parameterVarOpMap.get(blockParameter);\n-                } else {\n-                    throw new IllegalStateException(\"what ?\");\n-                }\n-            } else {\n-                return super.resolve(value);\n-            }\n-        }\n-    }\n-\n-    public static abstract class LoopScope<T extends Op> extends Scope<T> {\n-\n-        public LoopScope(Scope<?> parent, T opWrapper) {\n-            super(parent, opWrapper);\n-        }\n-    }\n-\n-\n-    public static class ForScope extends LoopScope<JavaOp.ForOp> {\n-        Map<Block.Parameter, CoreOp.VarOp> blockParamToVarOpMap = new HashMap<>();\n-        ForScope(Scope<?> parent, JavaOp.ForOp forOp) {\n-            super(parent, forOp);\n-            var loopParams = forOp.loopBody().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-            var updateParams = forOp.update().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-            var condParams = forOp.cond().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-            var lastInitOp = forOp.init().entryBlock().ops().getLast();\n-            var lastInitOpOperand0Result = (Op.Result) lastInitOp.operands().getFirst();\n-            var lastInitOpOperand0ResultOp = lastInitOpOperand0Result.op();\n-            CoreOp.VarOp varOps[];\n-            if (lastInitOpOperand0ResultOp instanceof CoreOp.TupleOp tupleOp) {\n-                 \/*\n-                 for (int j = 1, i=2, k=3; j < size; k+=1,i+=2,j+=3) {\n-                    float sum = k+i+j;\n-                 }\n-                 java.for\n-                 ()Tuple<Var<int>, Var<int>, Var<int>> -> {\n-                     %0 : int = constant @\"1\";\n-                     %1 : Var<int> = var %0 @\"j\";\n-                     %2 : int = constant @\"2\";\n-                     %3 : Var<int> = var %2 @\"i\";\n-                     %4 : int = constant @\"3\";\n-                     %5 : Var<int> = var %4 @\"k\";\n-                     %6 : Tuple<Var<int>, Var<int>, Var<int>> = tuple %1 %3 %5;\n-                     yield %6;\n-                 }\n-                 (%7 : Var<int>, %8 : Var<int>, %9 : Var<int>)boolean -> {\n-                     %10 : int = var.load %7;\n-                     %11 : int = var.load %12;\n-                     %13 : boolean = lt %10 %11;\n-                     yield %13;\n-                 }\n-                 (%14 : Var<int>, %15 : Var<int>, %16 : Var<int>)void -> {\n-                     %17 : int = var.load %16;\n-                     %18 : int = constant @\"1\";\n-                     %19 : int = add %17 %18;\n-                     var.store %16 %19;\n-                     %20 : int = var.load %15;\n-                     %21 : int = constant @\"2\";\n-                     %22 : int = add %20 %21;\n-                     var.store %15 %22;\n-                     %23 : int = var.load %14;\n-                     %24 : int = constant @\"3\";\n-                     %25 : int = add %23 %24;\n-                     var.store %14 %25;\n-                     yield;\n-                 }\n-                 (%26 : Var<int>, %27 : Var<int>, %28 : Var<int>)void -> {\n-                     %29 : int = var.load %28;\n-                     %30 : int = var.load %27;\n-                     %31 : int = add %29 %30;\n-                     %32 : int = var.load %26;\n-                     %33 : int = add %31 %32;\n-                     %34 : float = conv %33;\n-                     %35 : Var<float> = var %34 @\"sum\";\n-                     java.continue;\n-                 };\n-                 *\/\n-                varOps = tupleOp.operands().stream().map(operand -> (CoreOp.VarOp) (((Op.Result) operand).op())).toList().toArray(new CoreOp.VarOp[0]);\n-            } else {\n-                 \/*\n-                 for (int j = 0; j < size; j+=1) {\n-                    float sum = j;\n-                 }\n-                 java.for\n-                    ()Var<int> -> {\n-                        %0 : int = constant @\"0\";\n-                        %1 : Var<int> = var %0 @\"j\";\n-                        yield %1;\n-                    }\n-                    (%2 : Var<int>)boolean -> {\n-                        %3 : int = var.load %2;\n-                        %4 : int = var.load %5;\n-                        %6 : boolean = lt %3 %4;\n-                        yield %6;\n-                    }\n-                    (%7 : Var<int>)void -> {\n-                        %8 : int = var.load %7;\n-                        %9 : int = constant @\"1\";\n-                        %10 : int = add %8 %9;\n-                        var.store %7 %10;\n-                        yield;\n-                    }\n-                    (%11 : Var<int>)void -> {\n-                        %12 : int = var.load %11;\n-                        %13 : float = conv %12;\n-                        %14 : Var<float> = var %13 @\"sum\";\n-                        java.continue;\n-                    };\n-\n-                 *\/\n-                varOps = new CoreOp.VarOp[]{(CoreOp.VarOp) lastInitOpOperand0ResultOp};\n-            }\n-            for (int i = 0; i < varOps.length; i++) {\n-                blockParamToVarOpMap.put(condParams[i], varOps[i]);\n-                blockParamToVarOpMap.put(updateParams[i], varOps[i]);\n-                blockParamToVarOpMap.put(loopParams[i], varOps[i]);\n-            }\n-        }\n-\n-\n-        @Override\n-        public CoreOp.VarOp resolve(Value value) {\n-            if (value instanceof Block.Parameter blockParameter) {\n-                CoreOp.VarOp varOp = this.blockParamToVarOpMap.get(blockParameter);\n-                if (varOp != null) {\n-                    return varOp;\n-                }\n-            }\n-            return super.resolve(value);\n-        }\n-    }\n-\n-    public static class IfScope extends Scope<JavaOp.IfOp> {\n-        IfScope(Scope<?> parent, JavaOp.IfOp op) {\n-            super(parent, op);\n-        }\n-    }\n-\n-    public static class WhileScope extends LoopScope<JavaOp.WhileOp> {\n-        WhileScope(Scope<?> parent, JavaOp.WhileOp op) {\n-            super(parent, op);\n-        }\n-\n-    }\n-\n-    public Scope<?> scope = null;\n-    final public MethodHandles.Lookup lookup;\n-    final public CoreOp.FuncOp funcOp;\n-    final public FuncOpParams paramTable;\n-\n-    private void popScope() {\n-        scope = scope.parent;\n-    }\n-\n-    private void pushScope(Op op) {\n-        scope = switch (op) {\n-            case CoreOp.FuncOp $ -> new FuncScope(scope, $);\n-            case JavaOp.ForOp $ -> new ForScope(scope, $);\n-            case JavaOp.IfOp $ -> new IfScope(scope, $);\n-            case JavaOp.WhileOp $ -> new WhileScope(scope, $);\n-            default -> new Scope<>(scope, op);\n-        };\n-    }\n-\n-    public void scope(Op op, Runnable r) {\n-        pushScope(op);\n-        r.run();\n-        popScope();\n-    }\n-\n-    public HATCodeBuilderContext(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-        this.lookup = lookup;\n-        this.funcOp = funcOp;\n-        this.paramTable = new FuncOpParams(funcOp);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderContext.java","additions":0,"deletions":245,"binary":false,"changes":245,"status":"deleted"},{"patch":"@@ -34,4 +34,0 @@\n-import hat.util.StreamCounter;\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n@@ -53,10 +49,1 @@\n-public abstract class HATCodeBuilderWithContext<T extends HATCodeBuilderWithContext<T>> extends HATCodeBuilder<T> implements HATCodeBuilder.CodeBuilderInterface<T> {\n-\n-    public T typedefStructOrUnion(MemoryLayout memoryLayout, String name) {\n-        return typedefKeyword().space().structOrUnion(memoryLayout).space().suffix_s(name);\n-    }\n-\n-    T structOrUnion(MemoryLayout memoryLayout) {\n-        return structOrUnion(memoryLayout instanceof StructLayout);\n-    }\n-\n+public abstract class HATCodeBuilderWithContext<T extends HATCodeBuilderWithContext<T>> extends HATCodeBuilder<T> implements BabylonOpBuilder<T> {\n@@ -64,1 +51,1 @@\n-    public T type(HATCodeBuilderContext buildContext, JavaType javaType) {\n+    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n@@ -82,1 +69,1 @@\n-    public T varLoad(HATCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+    public T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n@@ -89,1 +76,1 @@\n-    public T varStore(HATCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp) {\n+    public T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp) {\n@@ -113,1 +100,1 @@\n-    private boolean isMappableIFace(HATCodeBuilderContext buildContext, JavaType javaType) {\n+    private boolean isMappableIFace(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n@@ -118,1 +105,0 @@\n-\n@@ -122,1 +108,1 @@\n-    private void varDeclarationWithInitialization(HATCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n+    private void varDeclarationWithInitialization(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n@@ -131,1 +117,1 @@\n-    public T varDeclaration(HATCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n+    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n@@ -141,1 +127,1 @@\n-    public T varFuncDeclaration(HATCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n+    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, OpTk.ParamVar paramVar) {\n@@ -146,1 +132,1 @@\n-    public T fieldLoad(HATCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n@@ -159,1 +145,1 @@\n-    public T fieldStore(HATCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp) {\n+    public T fieldStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp) {\n@@ -166,1 +152,1 @@\n-    public T unaryOperation(HATCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp) {\n+    public T unaryOp(ScopedCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp) {\n@@ -172,1 +158,1 @@\n-    public T binaryOperation(HATCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp) {\n+    public T binaryOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp) {\n@@ -180,9 +166,0 @@\n-    public static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx){\n-        return javaConditionalOp.bodies().get(idx).entryBlock().ops();\n-    }\n-    public static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n-        return ops(javaConditionalOp,0);\n-    }\n-    public static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n-        return ops(javaConditionalOp,1);\n-    }\n@@ -190,2 +167,2 @@\n-    public T logical(HATCodeBuilderContext buildContext, JavaOp.JavaConditionalOp logicalOp) {\n-        lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n+    public T conditionalOp(ScopedCodeBuilderContext buildContext, JavaOp.JavaConditionalOp logicalOp) {\n+        OpTk.lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n@@ -193,1 +170,1 @@\n-        rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n+        OpTk.rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n@@ -196,9 +173,1 @@\n-    public static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx){\n-        return (Op.Result)binaryTestOp.operands().get(idx);\n-    }\n-    public static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp){\n-        return result(binaryTestOp,0);\n-    }\n-    public static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp){\n-        return result(binaryTestOp,1);\n-    }\n+\n@@ -206,2 +175,2 @@\n-    public T binaryTest(HATCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp) {\n-        parenthesisIfNeeded(buildContext, binaryTestOp, lhsResult(binaryTestOp).op());\n+    public T binaryTestOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp) {\n+        parenthesisIfNeeded(buildContext, binaryTestOp, OpTk.lhsResult(binaryTestOp).op());\n@@ -209,1 +178,1 @@\n-        parenthesisIfNeeded(buildContext, binaryTestOp, rhsResult(binaryTestOp).op());\n+        parenthesisIfNeeded(buildContext, binaryTestOp, OpTk.rhsResult(binaryTestOp).op());\n@@ -212,3 +181,1 @@\n-    public static Op.Result result(JavaOp.ConvOp convOp){\n-        return (Op.Result)convOp.operands().getFirst();\n-    }\n+\n@@ -216,1 +183,1 @@\n-    public T conv(HATCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n+    public T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n@@ -222,1 +189,1 @@\n-        parenthesisIfNeeded(buildContext, convOp, result(convOp).op());\n+        parenthesisIfNeeded(buildContext, convOp, OpTk.result(convOp).op());\n@@ -227,1 +194,1 @@\n-    public T constant(HATCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp) {\n+    public T constantOp(ScopedCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp) {\n@@ -237,1 +204,1 @@\n-    public T javaYield(HATCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp) {\n+    public T yieldOp(ScopedCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp) {\n@@ -245,1 +212,1 @@\n-    public T lambda(HATCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp) {\n+    public T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp) {\n@@ -250,5 +217,2 @@\n-    public T tuple(HATCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp) {\n-        StreamCounter.of(tupleOp.operands(), (c, operand) -> {\n-            if (c.isNotFirst()) {\n-                comma().space();\n-            }\n+    public T tupleOp(ScopedCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp) {\n+        separated(tupleOp.operands(),(_)->commaSpace(),operand->{\n@@ -267,1 +231,1 @@\n-    public T funcCall(HATCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp) {\n+    public T funcCallOp(ScopedCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp) {\n@@ -270,7 +234,4 @@\n-            commaSeparated(funcCallOp.operands(), (e) -> {\n-                if (e instanceof Op.Result result) {\n-                    parenthesisIfNeeded(buildContext, funcCallOp, result.op());\n-                } else {\n-                    throw new IllegalStateException(\"Value?\");\n-                }\n-            })\n+            separated(funcCallOp.operands().stream()\n+                    .filter(e->e instanceof Op.Result ).map(e->(Op.Result)e),(_)->commaSpace(), result ->\n+                     recurse(buildContext,result.op())\n+            )\n@@ -282,1 +243,1 @@\n-    public T javaLabeled(HATCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp) {\n+    public T labeledOp(ScopedCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp) {\n@@ -291,1 +252,1 @@\n-    public T javaBreak(HATCodeBuilderContext buildContext, JavaOp.BreakOp breakOp) {\n+    public T breakOp(ScopedCodeBuilderContext buildContext, JavaOp.BreakOp breakOp) {\n@@ -302,1 +263,1 @@\n-    public T javaContinue(HATCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp) {\n+    public T continueOp(ScopedCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp) {\n@@ -308,1 +269,1 @@\n-        } else if (buildContext.scope.parent instanceof HATCodeBuilderContext.LoopScope<?>) {\n+        } else if (buildContext.scope.parent instanceof ScopedCodeBuilderContext.ForScope) {\n@@ -318,2 +279,2 @@\n-    public T javaIf(HATCodeBuilderContext buildContext, JavaOp.IfOp ifOp) {\n-        buildContext.scope(ifOp, () -> {\n+    public T ifOp(ScopedCodeBuilderContext buildContext, JavaOp.IfOp ifOp) {\n+        buildContext.ifScope(ifOp, () -> {\n@@ -321,1 +282,4 @@\n-            StreamCounter.of(ifOp.bodies(), (c, b) -> {\n+            var i = StreamMutable.of(0);\n+            \/\/ We probably should just use a regular for loop here ;)\n+            ifOp.bodies().forEach(b->{\n+                int idx = i.get();\n@@ -323,1 +287,0 @@\n-                    int idx = c.value();\n@@ -329,2 +292,2 @@\n-                                StreamCounter.of(OpTk.rootsExcludingVarFuncDeclarationsAndYields(ifOp.bodies().get(c.value()).entryBlock()), (innerc, root) ->\n-                                        nlIf(innerc.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n+                                separated(OpTk.rootsExcludingVarFuncDeclarationsAndYields(ifOp.bodies().get(idx).entryBlock()),(_)->nl(),root->\n+                                       recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n@@ -336,1 +299,1 @@\n-                    if (c.isNotFirst()) {\n+                    if (idx>0) {\n@@ -339,1 +302,0 @@\n-\n@@ -341,1 +303,1 @@\n-                            ifOp.bodies().get(c.value()).entryBlock()            \/\/ get the entryblock if bodies[c.value]\n+                            ifOp.bodies().get(idx).entryBlock()            \/\/ get the entryblock if bodies[c.value]\n@@ -347,0 +309,1 @@\n+                i.set(i.get()+1);\n@@ -352,0 +315,3 @@\n+\n+\n+\n@@ -353,1 +319,1 @@\n-    public T javaWhile(HATCodeBuilderContext buildContext, JavaOp.WhileOp whileOp) {\n+    public T whileOp(ScopedCodeBuilderContext buildContext, JavaOp.WhileOp whileOp) {\n@@ -355,2 +321,1 @@\n-                whileOp.bodies().getFirst().entryBlock().ops().stream() \/\/ cond\n-                        .filter(o -> o instanceof CoreOp.YieldOp)\n+                OpTk.condBlock(whileOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n@@ -358,3 +323,4 @@\n-        ).braceNlIndented(_ ->\n-                StreamCounter.of(OpTk.loopRootOpStream(whileOp), (c, root) ->\n-                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n+        );\n+        braceNlIndented(_ ->\n+                separated(OpTk.loopRootOpStream(whileOp),(_)->nl(),root->\n+                        recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n@@ -367,2 +333,2 @@\n-    public T javaFor(HATCodeBuilderContext buildContext, JavaOp.ForOp forOp) {\n-        buildContext.scope(forOp, () ->\n+    public T forOp(ScopedCodeBuilderContext buildContext, JavaOp.ForOp forOp) {\n+        buildContext.forScope(forOp, () ->\n@@ -370,3 +336,1 @@\n-                    forOp.init().entryBlock().ops().stream()\n-                            .filter(o -> o instanceof CoreOp.YieldOp)\n-                            .forEach(o -> recurse(buildContext, o));\n+                    OpTk.initBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -374,3 +338,1 @@\n-                    forOp.cond().entryBlock().ops().stream()\n-                            .filter(o -> o instanceof CoreOp.YieldOp)\n-                            .forEach(o -> recurse(buildContext, o));\n+                    OpTk.condBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -378,3 +340,2 @@\n-                    StreamCounter.of(\n-                            OpTk.rootsExcludingVarFuncDeclarationsAndYields( forOp.bodies().get(2).entryBlock()) \/\/mutate block\n-                            , (c, op) -> commaSpaceIf(c.isNotFirst()).recurse(buildContext, op)\n+                    separated(OpTk.rootsExcludingVarFuncDeclarationsAndYields(OpTk.mutateBlock(forOp)), (_)->commaSpace(),\n+                            op -> recurse(buildContext, op)\n@@ -383,2 +344,2 @@\n-                        StreamCounter.of(OpTk.loopRootOpStream(forOp), (c, root) ->\n-                                nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n+                        separated(OpTk.loopRootOpStream(forOp), (_)->nl(),\n+                                root-> recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n@@ -396,3 +357,3 @@\n-                    StreamCounter.of(ifaceType.fields, (c, field) -> {\n-                        nlIf(c.isNotFirst());\n-                        boolean isLast = c.value() == fieldCount - 1;\n+                    var fieldIdx = StreamMutable.of(0);\n+                    separated(ifaceType.fields,(_)->nl(), field->{\n+                        boolean isLast =fieldIdx.get() == fieldCount - 1;\n@@ -462,2 +423,0 @@\n-\n-\n@@ -465,0 +424,1 @@\n+                        fieldIdx.set(fieldIdx.get()+1);\n@@ -470,1 +430,1 @@\n-    public T atomicInc(HATCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n+    public T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n@@ -475,1 +435,1 @@\n-    public T methodCall(HATCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n+    public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n@@ -477,4 +437,5 @@\n-          \/\/  var returnType = OpTk.javaReturnType(invokeOp);\n-\n-            if (invokeOp.operands().size() == 1 && invokeOp.invokeDescriptor().name().startsWith(\"atomic\") && invokeOp.invokeDescriptor().name().endsWith(\"Inc\")\n-                    && OpTk.javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.equals(JavaType.INT)) {\n+            if (invokeOp.operands().size() == 1\n+                    && OpTk.funcName(invokeOp) instanceof String funcName\n+                    && funcName.startsWith(\"atomic\")\n+                    && funcName.endsWith(\"Inc\")\n+                    && OpTk.javaReturnType(invokeOp).equals(JavaType.INT)) {\n@@ -483,1 +444,1 @@\n-                    atomicInc(buildContext, instanceResult, invokeOp.invokeDescriptor().name().substring(0, invokeOp.invokeDescriptor().name().length() - 3));\n+                    atomicInc(buildContext, instanceResult, funcName.substring(0, funcName.length() - \"Inc\".length()));\n@@ -488,1 +449,1 @@\n-                if (invokeOp.invokeDescriptor().name().equals(\"create\")) { \/\/ TODO:  only on iface buffers\n+                if (OpTk.funcName(invokeOp).equals(\"create\")) { \/\/ TODO:  only on iface buffers\n@@ -519,1 +480,1 @@\n-                } else if (invokeOp.invokeDescriptor().name().equals(\"createLocal\")) { \/\/ TODO:  only on kernel iface buffers\n+                } else if (OpTk.funcName(invokeOp).equals(\"createLocal\")) { \/\/ TODO:  only on kernel iface buffers\n@@ -560,1 +521,1 @@\n-                    if (OpTk.javaReturnType(invokeOp) instanceof ClassType) {\n+                    if (OpTk.javaReturnType(invokeOp) instanceof ClassType) { \/\/ isAssignable?\n@@ -584,1 +545,1 @@\n-                    if (OpTk.javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.isVoid()) {\n+                    if (OpTk.javaReturnTypeIsVoid(invokeOp)) {\n@@ -610,1 +571,1 @@\n-                        if (invokeOp.operands().size() > 1 && invokeOp.operands().get(1) instanceof Op.Result result1) {\n+                        if (OpTk.resultOrNull(invokeOp,1) instanceof Op.Result result1) {\n@@ -622,2 +583,3 @@\n-            if (invokeOp.invokeDescriptor().name().equals(\"barrier\")) { \/\/ TODO:  only on kernel context?\n-                List<Value> operands = invokeOp.operands();\n+\n+            if (OpTk.funcName(invokeOp).equals(\"barrier\")) { \/\/ TODO:  only on kernel context?\n+                List<Value> operands = invokeOp.operands(); \/\/ map to Result and use stream filter and  find\n@@ -629,1 +591,1 @@\n-                        if (functionType.returnType().toString().equals(\"hat.KernelContext\")) {\n+                        if (functionType.returnType().toString().equals(\"hat.KernelContext\")) {  \/\/ OpTk.isAssignable?\n@@ -637,1 +599,1 @@\n-                        commaSeparated(invokeOp.operands(), (op) -> {\n+                        separated(invokeOp.operands(), ($)->$.comma().space(), (op) -> {\n@@ -656,2 +618,0 @@\n-\n-\n@@ -659,4 +619,2 @@\n-    public T ternary(HATCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp) {\n-        ternaryOp.bodies().get(0).entryBlock().ops().stream()\n-                .filter(o -> o instanceof CoreOp.YieldOp) \/\/ cond\n-                .forEach(o -> recurse(buildContext, o));\n+    public T conditionalExpressionOp(ScopedCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp) {\n+        OpTk.condBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -664,3 +622,1 @@\n-        ternaryOp.bodies().get(1).entryBlock().ops().stream()\n-                .filter(o -> o instanceof CoreOp.YieldOp) \/\/ iff yield\n-                .forEach(o -> recurse(buildContext, o));\n+        OpTk.thenBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -668,3 +624,1 @@\n-        ternaryOp.bodies().get(2).entryBlock().ops().stream()\n-                 .filter(o -> o instanceof CoreOp.YieldOp) \/\/ else yield\n-                 .forEach(o -> recurse(buildContext, o));\n+        OpTk.elseBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -682,1 +636,1 @@\n-    public T parenthesisIfNeeded(HATCodeBuilderContext buildContext, Op parent, Op child) {\n+    public T parenthesisIfNeeded(ScopedCodeBuilderContext buildContext, Op parent, Op child) {\n@@ -686,4 +640,0 @@\n-    public static Op.Result result( CoreOp.ReturnOp returnOp){\n-       return (Op.Result)returnOp.operands().getFirst();\n-    }\n-\n@@ -691,1 +641,1 @@\n-    public T ret(HATCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp) {\n+    public T returnOp(ScopedCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp) {\n@@ -693,1 +643,1 @@\n-                        $-> $.space().parenthesisIfNeeded(buildContext, returnOp, result(returnOp).op())\n+                        $-> $.space().parenthesisIfNeeded(buildContext, returnOp, OpTk.result(returnOp).op())\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":93,"deletions":143,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.codebuilders;\n+\n+import hat.optools.FuncOpParams;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ScopedCodeBuilderContext extends CodeBuilderContext {\n+    public static class Scope<O extends Op> {\n+        final Scope<?> parent;\n+        final O op;\n+\n+        public Scope(Scope<?> parent, O op) {\n+            this.parent = parent;\n+            this.op = op;\n+        }\n+\n+        public CoreOp.VarOp resolve(Value value) {\n+            if (value instanceof Op.Result result && result.op() instanceof CoreOp.VarOp varOp) {\n+                return varOp;\n+            }\n+            if (parent != null) {\n+                return parent.resolve(value);\n+            }\n+            throw new IllegalStateException(\"failed to resolve VarOp for value \" + value);\n+        }\n+    }\n+\n+    public static class FuncScope extends Scope<CoreOp.FuncOp> {\n+        final FuncOpParams paramTable;\n+        FuncScope(Scope<?> parent, CoreOp.FuncOp funcOp) {\n+            super(parent, funcOp);\n+            paramTable = new FuncOpParams(funcOp);\n+        }\n+\n+        @Override\n+        public CoreOp.VarOp resolve(Value value) {\n+            if (value instanceof Block.Parameter blockParameter) {\n+                if (paramTable.parameterVarOpMap.containsKey(blockParameter)) {\n+                    return paramTable.parameterVarOpMap.get(blockParameter);\n+                } else {\n+                    throw new IllegalStateException(\"what ?\");\n+                }\n+            } else {\n+                return super.resolve(value);\n+            }\n+        }\n+    }\n+\n+    public static class ForScope extends Scope<JavaOp.ForOp> {\n+        Map<Block.Parameter, CoreOp.VarOp> blockParamToVarOpMap = new HashMap<>();\n+        ForScope(Scope<?> parent, JavaOp.ForOp forOp) {\n+            super(parent, forOp);\n+            var loopParams = forOp.loopBody().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+            var updateParams = forOp.update().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+            var condParams = forOp.cond().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+            var lastInitOp = forOp.init().entryBlock().ops().getLast();\n+            var lastInitOpOperand0Result = (Op.Result) lastInitOp.operands().getFirst();\n+            var lastInitOpOperand0ResultOp = lastInitOpOperand0Result.op();\n+            CoreOp.VarOp[] varOps;\n+            if (lastInitOpOperand0ResultOp instanceof CoreOp.TupleOp tupleOp) {\n+                 \/*\n+                 for (int j = 1, i=2, k=3; j < size; k+=1,i+=2,j+=3) {\n+                    float sum = k+i+j;\n+                 }\n+                 java.for\n+                 ()Tuple<Var<int>, Var<int>, Var<int>> -> {\n+                     %0 : int = constant @\"1\";\n+                     %1 : Var<int> = var %0 @\"j\";\n+                     %2 : int = constant @\"2\";\n+                     %3 : Var<int> = var %2 @\"i\";\n+                     %4 : int = constant @\"3\";\n+                     %5 : Var<int> = var %4 @\"k\";\n+                     %6 : Tuple<Var<int>, Var<int>, Var<int>> = tuple %1 %3 %5;\n+                     yield %6;\n+                 }\n+                 (%7 : Var<int>, %8 : Var<int>, %9 : Var<int>)boolean -> {\n+                     %10 : int = var.load %7;\n+                     %11 : int = var.load %12;\n+                     %13 : boolean = lt %10 %11;\n+                     yield %13;\n+                 }\n+                 (%14 : Var<int>, %15 : Var<int>, %16 : Var<int>)void -> {\n+                     %17 : int = var.load %16;\n+                     %18 : int = constant @\"1\";\n+                     %19 : int = add %17 %18;\n+                     var.store %16 %19;\n+                     %20 : int = var.load %15;\n+                     %21 : int = constant @\"2\";\n+                     %22 : int = add %20 %21;\n+                     var.store %15 %22;\n+                     %23 : int = var.load %14;\n+                     %24 : int = constant @\"3\";\n+                     %25 : int = add %23 %24;\n+                     var.store %14 %25;\n+                     yield;\n+                 }\n+                 (%26 : Var<int>, %27 : Var<int>, %28 : Var<int>)void -> {\n+                     %29 : int = var.load %28;\n+                     %30 : int = var.load %27;\n+                     %31 : int = add %29 %30;\n+                     %32 : int = var.load %26;\n+                     %33 : int = add %31 %32;\n+                     %34 : float = conv %33;\n+                     %35 : Var<float> = var %34 @\"sum\";\n+                     java.continue;\n+                 };\n+                 *\/\n+                varOps = tupleOp.operands().stream().map(operand -> (CoreOp.VarOp) (((Op.Result) operand).op())).toList().toArray(new CoreOp.VarOp[0]);\n+            } else {\n+                 \/*\n+                 for (int j = 0; j < size; j+=1) {\n+                    float sum = j;\n+                 }\n+                 java.for\n+                    ()Var<int> -> {\n+                        %0 : int = constant @\"0\";\n+                        %1 : Var<int> = var %0 @\"j\";\n+                        yield %1;\n+                    }\n+                    (%2 : Var<int>)boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = var.load %5;\n+                        %6 : boolean = lt %3 %4;\n+                        yield %6;\n+                    }\n+                    (%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    (%11 : Var<int>)void -> {\n+                        %12 : int = var.load %11;\n+                        %13 : float = conv %12;\n+                        %14 : Var<float> = var %13 @\"sum\";\n+                        java.continue;\n+                    };\n+\n+                 *\/\n+                varOps = new CoreOp.VarOp[]{(CoreOp.VarOp) lastInitOpOperand0ResultOp};\n+            }\n+            for (int i = 0; i < varOps.length; i++) {\n+                blockParamToVarOpMap.put(condParams[i], varOps[i]);\n+                blockParamToVarOpMap.put(updateParams[i], varOps[i]);\n+                blockParamToVarOpMap.put(loopParams[i], varOps[i]);\n+            }\n+        }\n+\n+\n+        @Override\n+        public CoreOp.VarOp resolve(Value value) {\n+            if (value instanceof Block.Parameter blockParameter) {\n+                CoreOp.VarOp varOp = this.blockParamToVarOpMap.get(blockParameter);\n+                if (varOp != null) {\n+                    return varOp;\n+                }\n+            }\n+            return super.resolve(value);\n+        }\n+    }\n+\n+    public static class IfScope extends Scope<JavaOp.IfOp> {\n+        IfScope(Scope<?> parent, JavaOp.IfOp op) {\n+            super(parent, op);\n+        }\n+    }\n+\n+    private void popScope() {\n+        scope = scope.parent;\n+    }\n+\n+    public  void ifScope(JavaOp.IfOp ifOp, Runnable r) {\n+        scope = new IfScope(scope, ifOp);\n+        r.run();\n+        popScope();\n+    }\n+    public  void funcScope(CoreOp.FuncOp funcOp, Runnable r) {\n+       scope = new FuncScope(scope,funcOp);\n+        r.run();\n+        popScope();\n+    }\n+    public  void forScope(JavaOp.ForOp forOp, Runnable r) {\n+        scope = new ForScope(scope,forOp);\n+        r.run();\n+        popScope();\n+    }\n+\n+    public Scope<?> scope = null;\n+    public ScopedCodeBuilderContext(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        super(lookup,funcOp);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/ScopedCodeBuilderContext.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -255,2 +255,5 @@\n-    public static JavaType javaReturnType(JavaOp.InvokeOp op) {\n-        return (JavaType) op.invokeDescriptor().type().returnType();\n+    public static JavaType javaReturnType(JavaOp.InvokeOp invokeOp) {\n+        return (JavaType) invokeOp.invokeDescriptor().type().returnType();\n+    }\n+    public static boolean javaReturnTypeIsVoid(JavaOp.InvokeOp invokeOp) {\n+        return javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.isVoid();\n@@ -362,0 +365,94 @@\n+    public static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx){\n+        return javaConditionalOp.bodies().get(idx).entryBlock().ops();\n+    }\n+\n+    public static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n+        return ops(javaConditionalOp,0);\n+    }\n+\n+    public static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n+        return ops(javaConditionalOp,1);\n+    }\n+\n+    public static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx){\n+        return (Op.Result)binaryTestOp.operands().get(idx);\n+    }\n+\n+    public static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp){\n+        return result(binaryTestOp,0);\n+    }\n+\n+    public static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp){\n+        return result(binaryTestOp,1);\n+    }\n+\n+    public static Op.Result result(JavaOp.ConvOp convOp){\n+        return (Op.Result)convOp.operands().getFirst();\n+    }\n+\n+    public static Op.Result result(CoreOp.ReturnOp returnOp){\n+       return (Op.Result)returnOp.operands().getFirst();\n+    }\n+\n+    public static Block block(JavaOp.ConditionalExpressionOp ternaryOp, int idx){\n+        return ternaryOp.bodies().get(idx).entryBlock();\n+    }\n+\n+    public static Block condBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n+        return block(ternaryOp,0);\n+    }\n+\n+    public static Block thenBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n+        return block(ternaryOp,1);\n+    }\n+\n+    public static Block elseBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n+        return block(ternaryOp,2);\n+    }\n+\n+    public static String funcName(JavaOp.InvokeOp invokeOp) {\n+        return invokeOp.invokeDescriptor().name();\n+    }\n+    public static Value operandOrNull(Op op, int idx) {\n+        return op.operands().size() > idx?op.operands().get(idx):null;\n+    }\n+    public static Op.Result resultOrNull(Op op, int idx) {\n+        return (operandOrNull(op,idx) instanceof Op.Result result)?result:null;\n+    }\n+\n+    public static Block block(JavaOp.ForOp forOp, int idx){\n+        return forOp.bodies().get(idx).entryBlock();\n+    }\n+\n+    public static Block mutateBlock(JavaOp.ForOp forOp){\n+        return block(forOp,2);\n+    }\n+\n+    public static Block loopBlock(JavaOp.ForOp forOp){\n+        return block(forOp,3);\n+    }\n+\n+    public static Block condBlock(JavaOp.ForOp forOp){\n+        return  forOp.cond().entryBlock();\n+    }\n+\n+    public static Block initBlock(JavaOp.ForOp forOp){\n+        return  forOp.init().entryBlock();\n+    }\n+\n+    public static Block block(JavaOp.WhileOp whileOp, int idx){\n+        return  whileOp.bodies().get(idx).entryBlock();\n+    }\n+\n+    public static Block condBlock(JavaOp.WhileOp whileOp){\n+        return  block(whileOp,0);\n+    }\n+\n+    public static Block loopBlock(JavaOp.WhileOp whileOp){\n+        return  block(whileOp,1);\n+    }\n+\n+    public static Block blockOrNull(JavaOp.IfOp ifOp, int idx ){\n+        return ifOp.bodies().size() > idx?ifOp.bodies().get(idx).entryBlock():null;\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":99,"deletions":2,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.util;\n-\n-\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n-\n-public class StreamCounter<E> {\n-    private int value;\n-\n-    public static <E> void of(Iterable<E> iterable, BiConsumer<StreamCounter<E>, E> counterConsumer) {\n-        StreamCounter<E> sc = new StreamCounter<>();\n-        iterable.forEach((e) -> {\n-            sc.convey = e;\n-            counterConsumer.accept(sc, e);\n-            sc.inc();\n-        });\n-\n-    }\n-\n-    E convey;\n-\n-    public static <E> void of(Stream<E> stream, BiConsumer<StreamCounter<E>, E> counterConsumer) {\n-        StreamCounter<E> sc = new StreamCounter<>();\n-        stream.forEach((e) -> {\n-            sc.convey = e;\n-            counterConsumer.accept(sc, e);\n-            sc.inc();\n-        });\n-\n-    }\n-\n-    public static void of(Consumer<StreamCounter> counterConsumer) {\n-        counterConsumer.accept(new StreamCounter());\n-    }\n-\n-    public int value() {\n-        return value;\n-    }\n-\n-    public boolean isFirst() {\n-        return value == 0;\n-    }\n-\n-    public boolean isNotFirst() {\n-        return value != 0;\n-    }\n-\n-    public boolean onFirst(Consumer<E> consumer) {\n-        if (isFirst()) {\n-            consumer.accept(convey);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    public boolean onNotFirst(Consumer<E> consumer) {\n-        if (!isFirst()) {\n-            consumer.accept(convey);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    public void inc() {\n-        value++;\n-    }\n-\n-    public StreamCounter() {\n-        this.value = 0;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/util\/StreamCounter.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.codebuilders.HATCodeBuilderContext;\n+import hat.codebuilders.ScopedCodeBuilderContext;\n@@ -40,1 +40,1 @@\n-    public T type(HATCodeBuilderContext buildContext, JavaType javaType) {\n+    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n@@ -51,1 +51,1 @@\n-    public T fieldLoad(HATCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n@@ -64,1 +64,1 @@\n-    public T methodCall(HATCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n+    public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n@@ -71,1 +71,1 @@\n-            commaSeparated(  invokeOp.operands().subList(0,invokeOp.operands().size()-1), o->\n+            separated(  invokeOp.operands().subList(0,invokeOp.operands().size()-1), (_)->commaSpace(),o->\n@@ -97,1 +97,1 @@\n-        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(lookup,funcOp);\n+        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(lookup,funcOp);\n@@ -100,1 +100,1 @@\n-                commaSeparated(buildContext.paramTable.list(), (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n+                separated(buildContext.paramTable.list(),(_)->commaSpace(), (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}