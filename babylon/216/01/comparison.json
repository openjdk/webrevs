{"files":[{"patch":"@@ -579,0 +579,16 @@\n+                        }\n+                        push(op.result());\n+                    }\n+                    case ComplOp op -> {\n+                        \/\/ Lower to x ^ -1\n+                        processFirstOperand(op);\n+                        switch (rvt) {\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> {\n+                                cob.iconst_m1();\n+                                cob.ixor();\n+                            }\n+                            case LongType -> {\n+                                cob.ldc(-1L);\n+                                cob.lxor();\n+                            }\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -54,0 +54,4 @@\n+    public static int compl(int l) {\n+        return ~l;\n+    }\n+\n@@ -140,0 +144,4 @@\n+    public static byte compl(byte l) {\n+        return (byte) ~l;\n+    }\n+\n@@ -198,0 +206,4 @@\n+    public static short compl(short l) {\n+        return (short) ~l;\n+    }\n+\n@@ -260,0 +272,4 @@\n+    public static char compl(char l) {\n+        return (char) ~l;\n+    }\n+\n@@ -322,0 +338,4 @@\n+    public static long compl(long l) {\n+        return ~l;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2996,0 +2996,25 @@\n+    \/**\n+     * The bitwise complement operation, that can model the Java language unary {@code ~} operator for integral types\n+     *\/\n+    @OpFactory.OpDeclaration(ComplOp.NAME)\n+    public static final class ComplOp extends UnaryOp {\n+        public static final String NAME = \"compl\";\n+\n+        public ComplOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        ComplOp(ComplOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ComplOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ComplOp(this, cc);\n+        }\n+\n+        ComplOp(Value v) {\n+            super(NAME, v);\n+        }\n+    }\n+\n@@ -3985,0 +4010,10 @@\n+    \/**\n+     * Creates a bitwise complement operation.\n+     *\n+     * @param v the operand\n+     * @return the bitwise complement operation\n+     *\/\n+    public static UnaryOp compl(Value v) {\n+        return new ComplOp(v);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -453,2 +453,0 @@\n-                \/\/ operators\n-                Tag.COMPL,\n@@ -466,0 +464,2 @@\n+                \/\/ classes, ignore local class definitions (allows access to but does not model the definition)\n+                \/\/ Tag.CLASSDEF,\n@@ -2128,0 +2128,4 @@\n+                case COMPL -> {\n+                    Value rhs = toValue(tree.arg, tree.type);\n+                    result = append(CoreOp.compl(rhs));\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,0 +56,28 @@\n+    @CodeReflection\n+    public static int neg(int a) {\n+        return -a;\n+    }\n+\n+    @Test\n+    public void testNeg() {\n+        CoreOp.FuncOp f = getFuncOp(\"neg\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 42), neg(42));\n+    }\n+\n+    @CodeReflection\n+    public static int compl(int a) {\n+        return ~a;\n+    }\n+\n+    @Test\n+    public void testCompl() {\n+        CoreOp.FuncOp f = getFuncOp(\"compl\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 42), compl(42));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBinops.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-        return i & j | k ^ j;\n+        return ~(i & j | k ^ j);\n@@ -125,1 +125,1 @@\n-        return (byte) (i & j | k ^ j);\n+        return (byte) ~(i & j | k ^ j);\n@@ -130,1 +130,1 @@\n-        return (short) (i & j | k ^ j);\n+        return (short) ~(i & j | k ^ j);\n@@ -135,1 +135,1 @@\n-        return (char) (i & j | k ^ j);\n+        return (char) ~(i & j | k ^ j);\n@@ -140,1 +140,1 @@\n-        return i & j | k ^ j;\n+        return ~(i & j | k ^ j);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -88,0 +88,13 @@\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : int)int -> {\n+                %1 : Var<int> = var %0 @\"v\" ;\n+                %2 : int = var.load %1 ;\n+                %3 : int = compl %2 ;\n+                return %3 ;\n+            };\n+            \"\"\")\n+    static int test5(int v) {\n+        return ~v;\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/UnaryopTest.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}