{"files":[{"patch":"@@ -898,0 +898,1 @@\n+\n@@ -901,1 +902,1 @@\n-            if (oprToTransform != null) {\n+            if (op.isFrozen() || oprToTransform != null) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Block.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -175,0 +175,6 @@\n+\n+        \/**\n+         * If assigned to an operation result, it indicates the operation is frozen\n+        *\/\n+        private static final Result ROOT = new Result();\n+\n@@ -177,0 +183,5 @@\n+        private Result() {\n+            super(null, null);\n+            this.op = null;\n+        }\n+\n@@ -317,1 +328,1 @@\n-        if (result == null) {\n+        if (isFrozen() || result == null) {\n@@ -347,1 +358,1 @@\n-        return result;\n+        return result == Result.ROOT ? null : result;\n@@ -610,0 +621,11 @@\n+\n+    public void freeze() {\n+        if (result != null && result != Result.ROOT) {\n+            throw new IllegalStateException(\"Can't freeze a bound operation\");\n+        }\n+        result = Result.ROOT;\n+    }\n+\n+    public boolean isFrozen() {\n+        return result == Result.ROOT;\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -178,0 +178,2 @@\n+        \/\/ freeze op\n+        builder.op(invoke(MethodRef.method(Op.class, \"freeze\", void.class), result));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2728,0 +2728,1 @@\n+        private static final MethodRef M_OP_FREEZE = MethodRef.method(Op.class, \"freeze\", void.class);\n@@ -2777,1 +2778,2 @@\n-                            || invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_PARAM) -> true;\n+                            || invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_PARAM)\n+                            || invokeOp.invokeDescriptor().equals(M_OP_FREEZE) -> true;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.IntSupplier;\n+import java.util.function.IntUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestFreezeOp\n+ *\/\n+public class TestFreezeOp {\n+\n+    @CodeReflection\n+    static List<Integer> f(int i) {\n+        return new ArrayList<>(i);\n+    }\n+\n+    @Test\n+    void test0() throws NoSuchMethodException {\n+        Method m = this.getClass().getDeclaredMethod(\"f\", int.class);\n+        CoreOp.FuncOp f = Op.ofMethod(m).get();\n+        assertOpIsCopiedWhenAddedToBlock(f);\n+    }\n+\n+    @Test\n+    void test1() {\n+        Quotable q = (IntUnaryOperator & Quotable) i -> i \/ 2;\n+        Quoted quoted = Op.ofQuotable(q).get();\n+        CoreOp.QuotedOp quotedOp = (CoreOp.QuotedOp) quoted.op().ancestorBody().parentOp();\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) quotedOp.ancestorBody().parentOp();\n+        assertOpIsCopiedWhenAddedToBlock(funcOp);\n+    }\n+\n+    @Test\n+    void test2() {\n+        CoreOp.ConstantOp constant = CoreOp.constant(JavaType.INT, 7);\n+        constant.freeze();\n+        assertOpIsCopiedWhenAddedToBlock(constant);\n+    }\n+\n+    @Test\n+    void test3() {\n+        CoreOp.FuncOp funcOp = CoreOp.func(\"f\", FunctionType.FUNCTION_TYPE_VOID).body(b -> {\n+            b.op(CoreOp._return());\n+        });\n+        funcOp.freeze();\n+        funcOp.freeze();\n+    }\n+\n+    @Test\n+    void test4() {\n+        Quoted q = (int a, int b) -> {\n+            return a + b;\n+        };\n+        CoreOp.QuotedOp quotedOp = (CoreOp.QuotedOp) q.op().ancestorBody().parentOp();\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) quotedOp.ancestorBody().parentOp();\n+        Assert.assertTrue(funcOp.isFrozen());\n+        assertOpIsCopiedWhenAddedToBlock(funcOp);\n+    }\n+\n+    @Test\n+    void test5() { \/\/ freezing an already bound op should throw\n+        Body.Builder body = Body.Builder.of(null, FunctionType.FUNCTION_TYPE_VOID);\n+        Op.Result r = body.entryBlock().op(CoreOp.constant(JavaType.DOUBLE, 1d));\n+        Assert.assertThrows(() -> r.op().freeze());\n+    }\n+\n+    void assertOpIsCopiedWhenAddedToBlock(Op op) {\n+        Body.Builder body = Body.Builder.of(null, FunctionType.FUNCTION_TYPE_VOID);\n+        body.entryBlock().op(op);\n+        body.entryBlock().op(CoreOp._return());\n+        CoreOp.FuncOp funcOp = CoreOp.func(\"t\", body);\n+        boolean b = funcOp.body().entryBlock().ops().stream().allMatch(o -> o != op);\n+        Assert.assertTrue(b);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestFreezeOp.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}