{"files":[{"patch":"@@ -687,0 +687,1 @@\n+\n@@ -690,2 +691,2 @@\n-            if (oprToTransform != null) {\n-                \/\/ If operation is assigned to block, then copy it and transform its contents\n+            if (op.isSealed() || oprToTransform != null) {\n+                \/\/ If operation is assigned to block, or it's sealed, then copy it and transform its contents\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Block.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -227,0 +227,6 @@\n+\n+        \/**\n+         * If assigned to an operation result, it indicates the operation is sealed\n+        *\/\n+        private static final Result SEALED_RESULT = new Result();\n+\n@@ -229,0 +235,5 @@\n+        private Result() {\n+            super(null, null);\n+            this.op = null;\n+        }\n+\n@@ -335,1 +346,1 @@\n-     * @throws IllegalStateException if this operation is bound\n+     * @throws IllegalStateException if this operation is bound or sealed\n@@ -339,1 +350,1 @@\n-        if (result != null && result.block.isBound()) {\n+        if (isSealed() || (result != null && result.block.isBound())) {\n@@ -354,1 +365,1 @@\n-     * Returns this operation's parent block, otherwise {@code null} if the operation is not assigned to a block.\n+     * Returns this operation's parent block, otherwise {@code null} if the operation is unbound or sealed.\n@@ -356,1 +367,1 @@\n-     * @return operation's parent block, or {@code null} if the operation is not assigned to a block.\n+     * @return operation's parent block, or {@code null} if the operation is unbound or sealed.\n@@ -360,1 +371,1 @@\n-        if (result == null) {\n+        if (isSealed() || result == null) {\n@@ -385,1 +396,1 @@\n-     * Returns the operation's result, otherwise {@code null} if the operation is not assigned to a block.\n+     * Returns the operation's result, otherwise {@code null} if the operation is unbound or sealed.\n@@ -387,1 +398,1 @@\n-     * @return the operation's result, or {@code null} if not assigned to a block.\n+     * @return the operation's result, or {@code null} if unbound or sealed.\n@@ -390,1 +401,1 @@\n-        return result;\n+        return result == Result.SEALED_RESULT ? null : result;\n@@ -592,0 +603,29 @@\n+\n+    \/**\n+     * Seals this operation. After this operation is sealed its {@link #result result} and {@link #parent parent} are guaranteed to always be {@code null}.\n+     * <p>\n+     * If a sealed operation is {@link Block.Builder#op appended} to a {@link Block.Builder} then it is\n+     * treated as if the operation is bound, and therefore the sealed operation will be transformed.\n+     * <p>\n+     * Sealing is idempotent if the operation is already sealed.\n+     *\n+     * @throws IllegalStateException if this operation is bound.\n+     *\/\n+    public void seal() {\n+        if (result == Result.SEALED_RESULT) {\n+            return;\n+        }\n+        if (result != null) {\n+            throw new IllegalStateException(\"Operation cannot be sealed since it bound to a parent block\");\n+        }\n+        result = Result.SEALED_RESULT;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this operation is sealed.\n+     * @return {@code true} if this operation is sealed.\n+     * @see #seal()\n+    * *\/\n+    public boolean isSealed() {\n+        return result == Result.SEALED_RESULT;\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -178,0 +178,2 @@\n+        \/\/ seal op\n+        builder.op(invoke(MethodRef.method(Op.class, \"seal\", void.class), result));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2732,0 +2732,1 @@\n+        private static final MethodRef M_OP_SEAL = MethodRef.method(Op.class, \"seal\", void.class);\n@@ -2774,0 +2775,1 @@\n+        private static final Set<MethodRef> mRefs = Set.of(M_BLOCK_BUILDER_OP, M_BLOCK_BUILDER_PARAM, M_OP_SEAL);\n@@ -2780,2 +2782,1 @@\n-                    case JavaOp.InvokeOp invokeOp when invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_OP)\n-                            || invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_PARAM) -> true;\n+                    case JavaOp.InvokeOp invokeOp when mRefs.contains(invokeOp.invokeDescriptor()) -> true;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestSealOp\n+ *\/\n+public class TestSealOp {\n+\n+    @CodeReflection\n+    static List<Integer> f(int i) {\n+        return new ArrayList<>(i);\n+    }\n+\n+    @Test\n+    void test0() throws NoSuchMethodException {\n+        Method m = this.getClass().getDeclaredMethod(\"f\", int.class);\n+        CoreOp.FuncOp f = Op.ofMethod(m).get();\n+        assertOpIsCopiedWhenAddedToBlock(f);\n+    }\n+\n+    @Test\n+    void test1() {\n+        Quotable q = (IntUnaryOperator & Quotable) i -> i \/ 2;\n+        Quoted quoted = Op.ofQuotable(q).get();\n+        CoreOp.QuotedOp quotedOp = (CoreOp.QuotedOp) quoted.op().ancestorBody().ancestorOp();\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) quotedOp.ancestorBody().ancestorOp();\n+        assertOpIsCopiedWhenAddedToBlock(funcOp);\n+    }\n+\n+    @Test\n+    void test2() {\n+        CoreOp.ConstantOp constant = CoreOp.constant(JavaType.INT, 7);\n+        constant.seal();\n+        assertOpIsCopiedWhenAddedToBlock(constant);\n+    }\n+\n+    @Test\n+    void test3() {\n+        CoreOp.FuncOp funcOp = CoreOp.func(\"f\", FunctionType.FUNCTION_TYPE_VOID).body(b -> {\n+            b.op(CoreOp.return_());\n+        });\n+        funcOp.seal();\n+        funcOp.seal();\n+    }\n+\n+    @Test\n+    void test4() {\n+        Quoted q = (int a, int b) -> {\n+            return a + b;\n+        };\n+        CoreOp.QuotedOp quotedOp = (CoreOp.QuotedOp) q.op().ancestorBody().ancestorOp();\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) quotedOp.ancestorBody().ancestorOp();\n+        Assert.assertTrue(funcOp.isSealed());\n+        assertOpIsCopiedWhenAddedToBlock(funcOp);\n+    }\n+\n+    @Test\n+    void test5() { \/\/ freezing an already bound op should throw\n+        Body.Builder body = Body.Builder.of(null, FunctionType.FUNCTION_TYPE_VOID);\n+        Op.Result r = body.entryBlock().op(CoreOp.constant(JavaType.DOUBLE, 1d));\n+        Assert.assertThrows(() -> r.op().seal());\n+    }\n+\n+    @Test\n+    void test6() {\n+        CoreOp.ConstantOp cop = CoreOp.constant(JavaType.LONG, 1L);\n+        cop.setLocation(Location.NO_LOCATION);\n+        cop.seal();\n+        Assert.assertThrows(() -> cop.setLocation(Location.NO_LOCATION));\n+    }\n+\n+    void assertOpIsCopiedWhenAddedToBlock(Op op) {\n+        Body.Builder body = Body.Builder.of(null, FunctionType.FUNCTION_TYPE_VOID);\n+        body.entryBlock().op(op);\n+        body.entryBlock().op(CoreOp.return_());\n+        CoreOp.FuncOp funcOp = CoreOp.func(\"t\", body);\n+        boolean b = funcOp.body().entryBlock().ops().stream().allMatch(o -> o != op);\n+        Assert.assertTrue(b);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSealOp.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}