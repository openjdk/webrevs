{"files":[{"patch":"@@ -434,0 +434,2 @@\n+                    cob.dup();\n+                    cob.invokevirtual(CodeReflectionSupport.OP_CLASS.describeConstable().get(), \"freeze\", MTD_void);\n@@ -504,0 +506,1 @@\n+        static final Class<?> OP_CLASS;\n@@ -514,0 +517,1 @@\n+                OP_CLASS = cl.loadClass(\"jdk.incubator.code.Op\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -898,3 +898,0 @@\n-            if (op instanceof Op.Root) {\n-               throw new IllegalStateException(\"Operation %s is root and can't be inserted in a block\".formatted(op.getClass().getSimpleName()));\n-            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Block.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -181,0 +181,6 @@\n+\n+        \/**\n+         * If assigned to an operation result, it indicates the operation is frozen\n+        *\/\n+        private static final Result ROOT = new Result();\n+\n@@ -183,0 +189,5 @@\n+        private Result() {\n+            super(null, null);\n+            this.op = null;\n+        }\n+\n@@ -560,0 +571,1 @@\n+            funcOp.freeze();\n@@ -604,0 +616,7 @@\n+\n+    public void freeze() {\n+        if (result != null && result != Result.ROOT) {\n+            throw new IllegalStateException(\"Can't freeze a bound operation\");\n+        }\n+        result = Result.ROOT;\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.IntSupplier;\n+import java.util.function.IntUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestFreezeOp\n+ *\/\n+public class TestFreezeOp {\n+\n+    @CodeReflection\n+    static List<Integer> f(int i) {\n+        return new ArrayList<>(i);\n+    }\n+\n+    @Test\n+    void test0() throws NoSuchMethodException {\n+        Method m = this.getClass().getDeclaredMethod(\"f\", int.class);\n+        CoreOp.FuncOp f = Op.ofMethod(m).get();\n+        assertOpIsCopiedWhenAddedToBlock(f);\n+    }\n+\n+    @Test\n+    void test1() {\n+        Quotable q = (IntUnaryOperator & Quotable) i -> i \/ 2;\n+        Quoted quoted = Op.ofQuotable(q).get();\n+        CoreOp.QuotedOp quotedOp = (CoreOp.QuotedOp) quoted.op().ancestorBody().parentOp();\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) quotedOp.ancestorBody().parentOp();\n+        assertOpIsCopiedWhenAddedToBlock(funcOp);\n+    }\n+\n+    @Test\n+    void test2() {\n+        CoreOp.ConstantOp constant = CoreOp.constant(JavaType.INT, 7);\n+        constant.freeze();\n+        assertOpIsCopiedWhenAddedToBlock(constant);\n+    }\n+\n+    @Test\n+    void test3() {\n+        CoreOp.FuncOp funcOp = CoreOp.func(\"f\", FunctionType.FUNCTION_TYPE_VOID).body(b -> {\n+            b.op(CoreOp._return());\n+        });\n+        funcOp.freeze();\n+        funcOp.freeze();\n+    }\n+\n+    void assertOpIsCopiedWhenAddedToBlock(Op op) {\n+        Body.Builder body = Body.Builder.of(null, FunctionType.FUNCTION_TYPE_VOID);\n+        body.entryBlock().op(op);\n+        body.entryBlock().op(CoreOp._return());\n+        CoreOp.FuncOp funcOp = CoreOp.func(\"t\", body);\n+        boolean b = funcOp.body().entryBlock().ops().stream().allMatch(o -> o != op);\n+        Assert.assertTrue(b);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestFreezeOp.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -1,31 +0,0 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Body;\n-import jdk.incubator.code.CodeReflection;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.FunctionType;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.Method;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run testng RootOpInsertionTest\n- *\/\n-public class RootOpInsertionTest {\n-\n-    @CodeReflection\n-    static void f() {}\n-\n-    @Test\n-    void test() throws NoSuchMethodException {\n-        Method mf = this.getClass().getDeclaredMethod(\"f\");\n-        CoreOp.FuncOp funcOp = Op.ofMethod(mf).orElseThrow();\n-\n-        Body.Builder bodyBuilder = Body.Builder.of(null, FunctionType.VOID);\n-        Block.Builder entryBlock = bodyBuilder.entryBlock();\n-        Assert.assertThrows(IllegalStateException.class, () -> entryBlock.op(funcOp));\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/RootOpInsertionTest.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"}]}