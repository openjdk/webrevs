{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -29,0 +30,1 @@\n+import java.util.function.Supplier;\n@@ -77,0 +79,4 @@\n+\n+    public static <T> Tensor<T> If(Tensor<Boolean> cond, Supplier<Tensor<T>> elseBody, Supplier<Tensor<T>> thenBody) {\n+        return cond.data().get(ValueLayout.JAVA_BOOLEAN, 0) ? thenBody.get() : elseBody.get();\n+    }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+package oracle.code.onnx;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.VarType;\n+import oracle.code.onnx.compiler.OnnxTransformer;\n+\n+public record LambdaToFunc(CoreOp.FuncOp func, int[] operandsMapping) {\n+\n+    public static LambdaToFunc fromLambda(MethodHandles.Lookup l, CoreOp.LambdaOp lambda) {\n+        \/\/ Shortcut for lambda expressions that call just one method\n+        if (singleMethodInvocation(lambda) instanceof\n+                SingleMethod(CoreOp.InvokeOp iop, Map<Value, Value> valueMapping)) {\n+            Method m;\n+            try {\n+                m = iop.invokeDescriptor().resolveToMethod(l, iop.invokeKind());\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            var fOpt = Op.ofMethod(m);\n+            if (fOpt.isPresent()) {\n+                CoreOp.FuncOp f = Op.ofMethod(m).orElseThrow();\n+                CoreOp.FuncOp onnxFunc = OnnxTransformer.transform(l, f);\n+\n+                var operands = iop.operands();\n+                var captured = lambda.capturedValues();\n+                var operandsMapping = new int[iop.operands().size()];\n+                for (int i = 0; i < operandsMapping.length; i++) {\n+                    operandsMapping[i] = captured.indexOf(valueMapping.get(operands.get(i)));\n+                }\n+                return new LambdaToFunc(onnxFunc, operandsMapping);\n+            }\n+        }\n+        var capturedValues = lambda.capturedValues();\n+        var functionType = FunctionType.functionType(lambda.invokableType().returnType(),\n+                capturedValues.stream().map(Value::type)\n+                        .map(t -> t instanceof VarType vt ? vt.valueType() : t).toList());\n+        CoreOp.FuncOp onnxFunc = OnnxTransformer.transform(l, CoreOp.func(\"onnxCode\", functionType)\n+                .body(bb -> {\n+                    bb.context().mapValues(capturedValues, bb.parameters());\n+                    for (Op op : lambda.body().entryBlock().ops()) {\n+                        int i;\n+                        if (op instanceof CoreOp.VarAccessOp.VarLoadOp load &&\n+                                (i = capturedValues.indexOf(load.varOp().result())) >= 0) {\n+                            bb.context().mapValue(op.result(), bb.parameters().get(i)); \/\/ remap var load result to block param\n+                        } else {\n+                            bb.apply(op);\n+                        }\n+                    }\n+                }));\n+\n+        var operandsMapping = new int[capturedValues.size()];\n+        for (int i = 0; i < operandsMapping.length; i++) {\n+            operandsMapping[i] = i;\n+        }\n+        return new LambdaToFunc(onnxFunc, operandsMapping);\n+    }\n+\n+    record SingleMethod(CoreOp.InvokeOp iop, Map<Value, Value> valueMapping) {}\n+    static SingleMethod singleMethodInvocation(CoreOp.LambdaOp lop) {\n+        \/\/ Single block\n+        if (lop.body().blocks().size() > 1) {\n+            return null;\n+        }\n+\n+        Map<Value, Value> valueMapping = new HashMap<>();\n+        CoreOp.InvokeOp methodRefInvokeOp = extractMethodInvoke(valueMapping, lop.body().entryBlock().ops());\n+        if (methodRefInvokeOp == null) {\n+            return null;\n+        }\n+\n+        return new SingleMethod(methodRefInvokeOp, valueMapping);\n+    }\n+\n+    static CoreOp.InvokeOp extractMethodInvoke(Map<Value, Value> valueMapping, List<Op> ops) {\n+        CoreOp.InvokeOp methodRefInvokeOp = null;\n+        for (Op op : ops) {\n+            switch (op) {\n+                case CoreOp.VarOp varOp -> {\n+                    if (isValueUsedWithOp(varOp.result(), o -> o instanceof CoreOp.VarAccessOp.VarStoreOp)) {\n+                        return null;\n+                    }\n+                }\n+                case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> {\n+                    Value v = varLoadOp.varOp().result();\n+                    valueMapping.put(varLoadOp.result(), valueMapping.getOrDefault(v, v));\n+                }\n+                case CoreOp.InvokeOp iop when isBoxOrUnboxInvocation(iop) -> {\n+                    Value v = iop.operands().getFirst();\n+                    valueMapping.put(iop.result(), valueMapping.getOrDefault(v, v));\n+                }\n+                case CoreOp.InvokeOp iop -> {\n+                    if (methodRefInvokeOp != null) {\n+                        return null;\n+                    }\n+\n+                    for (Value o : iop.operands()) {\n+                        valueMapping.put(o, valueMapping.getOrDefault(o, o));\n+                    }\n+                    methodRefInvokeOp = iop;\n+                }\n+                case CoreOp.ReturnOp rop -> {\n+                    if (methodRefInvokeOp == null) {\n+                        return null;\n+                    }\n+                    Value r = rop.returnValue();\n+                    if (!(valueMapping.getOrDefault(r, r) instanceof Op.Result invokeResult)) {\n+                        return null;\n+                    }\n+                    if (invokeResult.op() != methodRefInvokeOp) {\n+                        return null;\n+                    }\n+                    assert methodRefInvokeOp.result().uses().size() == 1;\n+                }\n+                default -> {\n+                    return null;\n+                }\n+            }\n+        }\n+\n+        return methodRefInvokeOp;\n+    }\n+\n+    private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n+        for (Op.Result user : value.uses()) {\n+            if (opPredicate.test(user.op())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ @@@ Move to functionality on JavaType(s)\n+    static final Set<String> UNBOX_NAMES = Set.of(\n+            \"byteValue\",\n+            \"shortValue\",\n+            \"charValue\",\n+            \"intValue\",\n+            \"longValue\",\n+            \"floatValue\",\n+            \"doubleValue\",\n+            \"booleanValue\");\n+\n+    private static boolean isBoxOrUnboxInvocation(CoreOp.InvokeOp iop) {\n+        MethodRef mr = iop.invokeDescriptor();\n+        return mr.refType() instanceof ClassType ct && ct.unbox().isPresent() &&\n+                (UNBOX_NAMES.contains(mr.name()) || mr.name().equals(\"valueOf\"));\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/LambdaToFunc.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -4,0 +4,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -5,1 +6,1 @@\n-import java.util.IdentityHashMap;\n+import java.util.HashMap;\n@@ -9,0 +10,1 @@\n+import java.util.stream.LongStream;\n@@ -13,0 +15,1 @@\n+import oracle.code.onnx.ir.OnnxOps;\n@@ -263,0 +266,11 @@\n+    private static final class Indexer extends HashMap<Value, String> {\n+        String getName(Value v) {\n+            return computeIfAbsent(v, _ -> \"#\" + size());\n+        }\n+        String getName(Value v, int subIndex) {\n+            var name = getName(v);\n+            if (subIndex != 0) name += \".\" + subIndex;\n+            return name;\n+        }\n+    }\n+\n@@ -267,13 +281,25 @@\n-    static byte[] build(Block block) {\n-        var indexer = new IdentityHashMap<Value, String>() {\n-            String getName(Value v) {\n-                return computeIfAbsent(v, _ -> \"#\" + size());\n-            }\n-            String getName(Value v, int subIndex) {\n-                var name = getName(v);\n-                if (subIndex != 0) name += \".\" + subIndex;\n-                return name;\n-            }\n-        };\n-        return build(\n-                block.parameters().stream().map(v -> tensorInfo(indexer.getName(v), ((OnnxType.TensorType)v.type()).eType().id())).toList(),\n+    static byte[] build(Block block, List<oracle.code.onnx.Tensor> initializers) {\n+        var indexer = new Indexer();\n+        var model = build(graph(indexer, block, initializers));\n+\/\/        OnnxProtoPrinter.printModel(model);\n+        return model;\n+    }\n+\n+    static byte[] build(List<TensorProto> initializers, List<ValueInfoProto> inputs, List<NodeProto> ops, List<String> outputNames) {\n+        return build(graph(initializers, inputs, ops, outputNames));\n+    }\n+\n+    static byte[] build(GraphProto graph) {\n+        return new ModelProto()\n+                .ir_version(IR_VERSION)\n+                .graph(graph)\n+                .opset_import(new OperatorSetIdProto().version(OPSET_VERSION))\n+                .buf.toByteArray();\n+    }\n+\n+    static GraphProto graph(Indexer indexer, Block block, List<oracle.code.onnx.Tensor> initializers) {\n+        var params = block.parameters();\n+        return graph(\n+                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.getName(params.get(i)), initializers.get(i))).toList(),\n+                params.subList(initializers.size(), params.size()).stream().map(v ->\n+                        tensorInfo(indexer.getName(v), ((OnnxType.TensorType)v.type()).eType().id())).toList(),\n@@ -282,0 +308,8 @@\n+                        case OnnxOps.If ifOp ->\n+                            opNodes.accept(node(\n+                                    ifOp.opName(),\n+                                    List.of(indexer.getName(ifOp.operands().getFirst())),\n+                                    List.of(indexer.getName(ifOp.result())),\n+                                    java.util.Map.of( \/\/ @@@ wrong mapping of captured inputs\n+                                            \"else_branch\", graph(indexer, ifOp.elseBranch().entryBlock(), List.of()),\n+                                            \"then_branch\", graph(indexer, ifOp.thenBranch().entryBlock(), List.of()))));\n@@ -299,9 +333,1 @@\n-    static byte[] build(List<ValueInfoProto> inputs, List<NodeProto> ops, List<String> outputNames) {\n-        return new ModelProto()\n-                .ir_version(IR_VERSION)\n-                .graph(graph(inputs, ops, outputNames))\n-                .opset_import(new OperatorSetIdProto().version(OPSET_VERSION))\n-                .buf.toByteArray();\n-    }\n-\n-    static GraphProto graph(List<ValueInfoProto> inputs, List<NodeProto> ops, List<String> outputNames) {\n+    static GraphProto graph(List<TensorProto> initializers, List<ValueInfoProto> inputs, List<NodeProto> ops, List<String> outputNames) {\n@@ -309,0 +335,1 @@\n+                .forEach(initializers, (g, i) -> g.initializer(i))\n@@ -339,0 +366,8 @@\n+    static TensorProto tensorProto(String name, oracle.code.onnx.Tensor tensor) {\n+        return new TensorProto()\n+                .forEach(LongStream.of(tensor.shape()).boxed().toList(), (tp, d) -> tp.dims(d))\n+                .data_type(tensor.elementType().id)\n+                .raw_data(tensor.data().toArray(ValueLayout.JAVA_BYTE))\n+                .name(name);\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":58,"deletions":23,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -7,1 +7,0 @@\n-import java.lang.reflect.Method;\n@@ -12,1 +11,0 @@\n-import java.util.function.Predicate;\n@@ -18,5 +16,0 @@\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.VarType;\n-import oracle.code.onnx.compiler.OnnxTransformer;\n@@ -64,0 +57,1 @@\n+        private int in;\n@@ -65,1 +59,1 @@\n-        CachedSession computeIfAbsent(Class<?> lambdaClass, MethodHandles.Lookup l,  Quoted q) {\n+        CachedSession computeIfAbsent(Class<?> lambdaClass, MethodHandles.Lookup l,  Quoted q, int initializers) {\n@@ -69,0 +63,1 @@\n+                this.in = initializers;\n@@ -74,0 +69,1 @@\n+                this.in = 0;\n@@ -79,49 +75,10 @@\n-            var lambda = (CoreOp.LambdaOp) q.op();\n-\n-            CoreOp.FuncOp onnxFunc;\n-            int[] operandsMapping;\n-\n-            \/\/ Shortcut for lambda expressions that call just one method\n-            if (singleMethodInvocation(lambda) instanceof\n-                    SingleMethod(CoreOp.InvokeOp iop, Map<Value, Value> valueMapping)) {\n-                Method m;\n-                try {\n-                    m = iop.invokeDescriptor().resolveToMethod(l, iop.invokeKind());\n-                } catch (ReflectiveOperationException e) {\n-                    throw new RuntimeException(e);\n-                }\n-\n-                CoreOp.FuncOp f = Op.ofMethod(m).orElseThrow();\n-                onnxFunc = OnnxTransformer.transform(l, f);\n-\n-                var operands = iop.operands();\n-                var captured = q.capturedValues().sequencedKeySet().stream().toList();\n-                operandsMapping = new int[iop.operands().size()];\n-                for (int i = 0; i < operandsMapping.length; i++) {\n-                    operandsMapping[i] = captured.indexOf(valueMapping.get(operands.get(i)));\n-                }\n-\n-            } else {\n-                var capturedValues = lambda.capturedValues();\n-                var functionType = FunctionType.functionType(lambda.invokableType().returnType(),\n-                        capturedValues.stream().map(Value::type)\n-                                .map(t -> t instanceof VarType vt ? vt.valueType() : t).toList());\n-                onnxFunc = OnnxTransformer.transform(l, CoreOp.func(\"onnxCode\", functionType)\n-                        .body(bb -> {\n-                            bb.context().mapValues(capturedValues, bb.parameters());\n-                            for (Op op : lambda.body().entryBlock().ops()) {\n-                                int i;\n-                                if (op instanceof CoreOp.VarAccessOp.VarLoadOp load &&\n-                                        (i = capturedValues.indexOf(load.varOp().result())) >= 0) {\n-                                    bb.context().mapValue(op.result(), bb.parameters().get(i)); \/\/ remap var load result to block param\n-                                } else {\n-                                    bb.apply(op);\n-                                }\n-                            }\n-                        }));\n-\n-                operandsMapping = new int[capturedValues.size()];\n-                for (int i = 0; i < operandsMapping.length; i++) {\n-                    operandsMapping[i] = i;\n-                }\n-            }\n+            var mf = LambdaToFunc.fromLambda(l, (CoreOp.LambdaOp)q.op());\n+\n+            var captured = q.capturedValues().sequencedValues().toArray();\n+            List<Tensor> initializers = IntStream.range(0, in)\n+                    .map(i -> mf.operandsMapping()[i])\n+                    .mapToObj(i -> captured[i])\n+                    .map(val -> val instanceof CoreOp.Var<?> v ? v.value() : val)\n+                    .map(val -> (Tensor) val)\n+                    .toList();\n+\n@@ -130,1 +87,1 @@\n-                    OnnxProtoBuilder.build(onnxFunc.body().entryBlock())), operandsMapping);\n+                    OnnxProtoBuilder.build(mf.func().body().entryBlock(), initializers)), mf.operandsMapping());\n@@ -136,2 +93,2 @@\n-    public static <T> Tensor<T> execute(MethodHandles.Lookup lookup, OnnxFunction<Tensor<T>> codeLambda) {\n-        return execute(Arena.ofAuto(), lookup, codeLambda);\n+    public static <T> Tensor<T> execute(MethodHandles.Lookup l, OnnxFunction<Tensor<T>> codeLambda) {\n+        return execute(l, 0, codeLambda);\n@@ -140,1 +97,5 @@\n-    public static <T> Tensor<T> execute(Arena arena, MethodHandles.Lookup lookup, OnnxFunction<Tensor<T>> codeLambda) {\n+    public static <T> Tensor<T> execute(MethodHandles.Lookup l, int initializers, OnnxFunction<Tensor<T>> codeLambda) {\n+        return execute(Arena.ofAuto(), l, initializers, codeLambda);\n+    }\n+\n+    public static <T> Tensor<T> execute(Arena arena, MethodHandles.Lookup l, int initializers, OnnxFunction<Tensor<T>> codeLambda) {\n@@ -143,1 +104,1 @@\n-        var model = SESSION_CACHE.computeIfAbsent(codeLambda.getClass(), lookup, q);\n+        var model = SESSION_CACHE.computeIfAbsent(codeLambda.getClass(), l, q, initializers);\n@@ -146,2 +107,3 @@\n-        List<Tensor> arguments = IntStream.of(model.operandsMapping())\n-                .mapToObj(i -> captured[i])\n+        var mapping = model.operandsMapping();\n+        List<Tensor> arguments = IntStream.range(initializers, mapping.length)\n+                .mapToObj(i -> captured[mapping[i]])\n@@ -155,91 +117,0 @@\n-    record SingleMethod(CoreOp.InvokeOp iop, Map<Value, Value> valueMapping) {}\n-    static SingleMethod singleMethodInvocation(CoreOp.LambdaOp lop) {\n-        \/\/ Single block\n-        if (lop.body().blocks().size() > 1) {\n-            return null;\n-        }\n-\n-        Map<Value, Value> valueMapping = new HashMap<>();\n-        CoreOp.InvokeOp methodRefInvokeOp = extractMethodInvoke(valueMapping, lop.body().entryBlock().ops());\n-        if (methodRefInvokeOp == null) {\n-            return null;\n-        }\n-\n-        return new SingleMethod(methodRefInvokeOp, valueMapping);\n-    }\n-\n-    static CoreOp.InvokeOp extractMethodInvoke(Map<Value, Value> valueMapping, List<Op> ops) {\n-        CoreOp.InvokeOp methodRefInvokeOp = null;\n-        for (Op op : ops) {\n-            switch (op) {\n-                case CoreOp.VarOp varOp -> {\n-                    if (isValueUsedWithOp(varOp.result(), o -> o instanceof CoreOp.VarAccessOp.VarStoreOp)) {\n-                        return null;\n-                    }\n-                }\n-                case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> {\n-                    Value v = varLoadOp.varOp().result();\n-                    valueMapping.put(varLoadOp.result(), valueMapping.getOrDefault(v, v));\n-                }\n-                case CoreOp.InvokeOp iop when isBoxOrUnboxInvocation(iop) -> {\n-                    Value v = iop.operands().getFirst();\n-                    valueMapping.put(iop.result(), valueMapping.getOrDefault(v, v));\n-                }\n-                case CoreOp.InvokeOp iop -> {\n-                    if (methodRefInvokeOp != null) {\n-                        return null;\n-                    }\n-\n-                    for (Value o : iop.operands()) {\n-                        valueMapping.put(o, valueMapping.getOrDefault(o, o));\n-                    }\n-                    methodRefInvokeOp = iop;\n-                }\n-                case CoreOp.ReturnOp rop -> {\n-                    if (methodRefInvokeOp == null) {\n-                        return null;\n-                    }\n-                    Value r = rop.returnValue();\n-                    if (!(valueMapping.getOrDefault(r, r) instanceof Op.Result invokeResult)) {\n-                        return null;\n-                    }\n-                    if (invokeResult.op() != methodRefInvokeOp) {\n-                        return null;\n-                    }\n-                    assert methodRefInvokeOp.result().uses().size() == 1;\n-                }\n-                default -> {\n-                    return null;\n-                }\n-            }\n-        }\n-\n-        return methodRefInvokeOp;\n-    }\n-\n-    private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n-        for (Op.Result user : value.uses()) {\n-            if (opPredicate.test(user.op())) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/\/ @@@ Move to functionality on JavaType(s)\n-    static final Set<String> UNBOX_NAMES = Set.of(\n-            \"byteValue\",\n-            \"shortValue\",\n-            \"charValue\",\n-            \"intValue\",\n-            \"longValue\",\n-            \"floatValue\",\n-            \"doubleValue\",\n-            \"booleanValue\");\n-\n-    private static boolean isBoxOrUnboxInvocation(CoreOp.InvokeOp iop) {\n-        MethodRef mr = iop.invokeDescriptor();\n-        return mr.refType() instanceof ClassType ct && ct.unbox().isPresent() &&\n-                (UNBOX_NAMES.contains(mr.name()) || mr.name().equals(\"valueOf\"));\n-    }\n-\n@@ -274,0 +145,1 @@\n+                List.of(),\n@@ -285,2 +157,2 @@\n-    public List<Tensor> run(Arena arena, Block block, List<Tensor> inputValues) {\n-        var protoModel = OnnxProtoBuilder.build(block);\n+    public List<Tensor> run(Arena arena, Block block, List<Tensor> inputValues, int initializers) {\n+        var protoModel = OnnxProtoBuilder.build(block, inputValues.subList(0, initializers));\n@@ -288,1 +160,1 @@\n-                .run(arena, inputValues);\n+                .run(arena, inputValues.subList(initializers, inputValues.size()));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":30,"deletions":158,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import oracle.code.onnx.LambdaToFunc;\n+import oracle.code.onnx.ir.ExplicitOnnxOps;\n@@ -62,3 +64,3 @@\n-        evaluatedAttributes.forEach((invokeOp, objects) -> {\n-            System.out.println(invokeOp.invokeDescriptor().name() + \" -> \" + objects);\n-        });\n+\/\/        evaluatedAttributes.forEach((invokeOp, objects) -> {\n+\/\/            System.out.println(invokeOp.invokeDescriptor().name() + \" -> \" + objects);\n+\/\/        });\n@@ -276,0 +278,3 @@\n+            try {\n+                return (Class) Class.forName(ExplicitOnnxOps.class.getName() + \"$\" + operatorName);\n+            } catch (ClassNotFoundException _) {}\n@@ -314,0 +319,6 @@\n+            } else if (opClass == ExplicitOnnxOps.If.class) {\n+                \/\/ @@@ hard-coded 2 extra undeclared attributes\n+                List<Object> attrs = o.operands().subList(inputs.size(), inputs.size() + 2).stream()\n+                        .map(oc::getValue)\n+                        .toList();\n+                evaluatedAttributes.put(io, attrs);\n@@ -470,0 +481,3 @@\n+            case CoreOp.LambdaOp lambdaOp -> {\n+                return lambdaOp;\n+            }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxPartialEvaluator.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -20,0 +20,3 @@\n+import jdk.incubator.code.*;\n+import oracle.code.onnx.LambdaToFunc;\n+import oracle.code.onnx.ir.ExplicitOnnxOps;\n@@ -37,1 +40,0 @@\n-\n@@ -99,1 +101,17 @@\n-                        opArgs.addAll(attributes);\n+                        opArgs.addAll(attributes.stream().map(a -> {\n+                            if (a instanceof CoreOp.LambdaOp lo) {\n+                                var ltf = LambdaToFunc.fromLambda(l, lo);\n+                                var cc = bb.context();\n+                                var lbb = Body.Builder.of(bb.parentBody(), lo.invokableType(), cc);\n+                                var eb = lbb.entryBlock();\n+                                var params = ltf.func().body().entryBlock().parameters();\n+                                var captured = lo.capturedValues();\n+                                for (int i = 0; i < params.size(); i++) {\n+                                    var param = params.get(i);\n+                                    cc.mapValue(param, eb.op(OnnxOps.Identity(param.type(), cc.getValue(traverseUp(captured.get(i))))));\n+                                }\n+                                ltf.func().body().entryBlock().ops().forEach(eb::apply);\n+                                return lbb;\n+                            }\n+                            return a;\n+                        }).toList());\n@@ -132,0 +150,5 @@\n+    static Value traverseUp(Value v) {\n+        \/\/ @@@ when captured value is a VaroOp\n+        return v instanceof Op.Result or && or.op() instanceof CoreOp.VarOp vo && !vo.isUninitialized()? vo.initOperand() : v;\n+    }\n+\n@@ -138,0 +161,3 @@\n+            try {\n+                return (Class) Class.forName(ExplicitOnnxOps.class.getName() + \"$\" + operatorName);\n+            } catch (ClassNotFoundException _) {}\n@@ -226,0 +252,2 @@\n+            } else if (elementType.equals(JavaType.J_L_BOOLEAN)) {\n+                return OnnxType.TENSOR_BOOL;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx.ir;\n+\n+import java.util.List;\n+import java.util.SequencedMap;\n+import java.util.SequencedSet;\n+import java.util.Set;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.Op.Nested;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.op.OpFactory;\n+\n+public sealed class ExplicitOnnxOps permits OnnxOps {\n+\n+    @OpFactory.OpDeclaration(If.NAME)\n+    public static final class If extends OnnxOp implements Nested {\n+        public static final String NAME = \"If\";\n+\n+        final Body elseBody, thenBody;\n+\n+        \/\/ @@@ make or fake elseBody as \"else_branch\" attribute and thenBody as \"then_branch\" attribute\n+        public enum Attribute implements OnnxOp.OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxOp.OnnxTypeConstraint {\n+            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),\n+            B(new OnnxType.TypeVariable(\"B\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxOp.OnnxParameter {\n+            cond(TypeConstraint.B.typeVariable(), OnnxOp.OnnxParameter.Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final OnnxOp.OnnxParameter.Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxOp.OnnxParameter {\n+            output(TypeConstraint.V.typeVariable(), OnnxOp.OnnxParameter.Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final OnnxOp.OnnxParameter.Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxOp.OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public If(ExternalizableOp.ExternalizedOp def) {\n+            super(SCHEMA, def);\n+\n+            this.elseBody = def.bodyDefinitions().get(0).build(this);\n+            this.thenBody = def.bodyDefinitions().get(1).build(this);\n+        }\n+\n+        If(If that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.elseBody = that.elseBody.transform(cc, ot).build(this);\n+            this.thenBody = that.thenBody.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public If transform(CopyContext cc, OpTransformer ot) {\n+            return new If(this, cc, ot);\n+        }\n+\n+        If(TypeElement resultType, Value cond, Body.Builder elseBranch, Body.Builder thenBranch) {\n+            super(SCHEMA, resultType, Set.of(), List.of(cond), List.of());\n+\n+            this.elseBody = elseBranch.build(this);\n+            this.thenBody = thenBranch.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(elseBody, thenBody);\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxOp.OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxOp.OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(cond()));\n+        }\n+\n+        public Value cond() {\n+            return operands().get(0);\n+        }\n+\n+        public Body elseBranch() {\n+            return elseBody;\n+        }\n+\n+        public Body thenBranch() {\n+            return thenBody;\n+        }\n+    }\n+\n+    public static If If(TypeElement resultType, Value cond, Body.Builder elseBody, Body.Builder thenBody) {\n+        return new If(resultType, cond, elseBody, thenBody);\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/ExplicitOnnxOps.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n-public final class OnnxOps {\n+public final class OnnxOps extends ExplicitOnnxOps {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import static oracle.code.onnx.OnnxOperators.Reshape;\n@@ -112,3 +111,0 @@\n-        var shape = Constant(new long[]{-1, NUM_CHANNELS, IMAGE_SIZE, IMAGE_SIZE});\n-        var inputReshaped = Reshape(inputImage, shape, empty());\n-\n@@ -117,1 +113,1 @@\n-        var scaledInput = Div(inputReshaped, scalingFactor);\n+        var scaledInput = Div(inputImage, scalingFactor);\n@@ -194,12 +190,0 @@\n-            var shape = b.op(OnnxOps.Constant(OnnxType.TENSOR_INT64,\n-                    empty(),\n-                    empty(),\n-                    empty(),\n-                    empty(),\n-                    empty(),\n-                    of(new long[]{-1, NUM_CHANNELS, IMAGE_SIZE, IMAGE_SIZE}),\n-                    empty(),\n-                    empty()));\n-            var inputReshaped = b.op(OnnxOps.Reshape(inputImage.type(),\n-                    inputImage, shape, empty()));\n-\n@@ -216,1 +200,1 @@\n-            var scaledInput = b.op(OnnxOps.Div(inputReshaped.type(), inputReshaped, scalingFactor));\n+            var scaledInput = b.op(OnnxOps.Div(inputImage.type(), inputImage, scalingFactor));\n@@ -386,1 +370,1 @@\n-            test(arena, inputImage -> OnnxRuntime.execute(arena, MethodHandles.lookup(), () ->\n+            test(arena, inputImage -> OnnxRuntime.execute(arena, MethodHandles.lookup(), 10, () ->\n@@ -400,1 +384,2 @@\n-            Tensor<Byte> inputImage = new Tensor(arena, imagesIn, Tensor.ElementType.UINT8, new long[]{imagesF.length() - IMAGES_HEADER_SIZE});\n+            long size = imagesF.length() - IMAGES_HEADER_SIZE;\n+            Tensor<Byte> inputImage = new Tensor(arena, imagesIn, Tensor.ElementType.UINT8, new long[]{size \/ (28 * 28), 1, 28, 28});\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -20,0 +20,1 @@\n+                    List.of(),\n@@ -24,4 +25,5 @@\n-             var addOp = ort.createSession(arena, build(\n-                     List.of(tensorInfo(\"a\", FLOAT.id), tensorInfo(\"b\", FLOAT.id)),\n-                     List.of(node(\"Add\", List.of(\"a\", \"b\"), List.of(\"y\"), Map.of())),\n-                     List.of(\"y\")));\n+            var addOp = ort.createSession(arena, build(\n+                    List.of(),\n+                    List.of(tensorInfo(\"a\", FLOAT.id), tensorInfo(\"b\", FLOAT.id)),\n+                    List.of(node(\"Add\", List.of(\"a\", \"b\"), List.of(\"y\"), Map.of())),\n+                    List.of(\"y\")));\n@@ -64,0 +66,1 @@\n+                    List.of(),\n@@ -67,0 +70,1 @@\n+                                    List.of(),\n@@ -71,0 +75,1 @@\n+                                    List.of(),\n@@ -88,0 +93,1 @@\n+                    List.of(),\n@@ -91,0 +97,1 @@\n+                                    List.of(),\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -119,0 +119,49 @@\n+    @CodeReflection\n+    public static Tensor<Float> ifConst(Tensor<Boolean> cond) {\n+        return OnnxOperators.If(cond, () -> OnnxOperators.Constant(-1f), () -> OnnxOperators.Constant(1f));\n+    }\n+\n+    @Test\n+    public void testIfConst() throws Exception {\n+        var condFalse = Tensor.ofScalar(false);\n+        var expFalse = Tensor.ofScalar(-1f);\n+        var condTrue = Tensor.ofScalar(true);\n+        var expTrue = Tensor.ofScalar(1f);\n+\n+        assertEquals(expFalse, ifConst(condFalse));\n+        assertEquals(expFalse, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifConst(condFalse)));\n+\n+        assertEquals(expTrue, ifConst(condTrue));\n+        assertEquals(expTrue, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifConst(condTrue)));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Float> ifCapture(Tensor<Boolean> cond, Tensor<Float> trueValue) {\n+        var falseValue = OnnxOperators.Constant(-1f);\n+        return OnnxOperators.If(cond, () -> OnnxOperators.Identity(falseValue), () -> trueValue);\n+    }\n+\n+    @Test\n+    public void testIfCapture() throws Exception {\n+        var condFalse = Tensor.ofScalar(false);\n+        var expFalse = Tensor.ofScalar(-1f);\n+        var condTrue = Tensor.ofScalar(true);\n+        var expTrue = Tensor.ofScalar(1f);\n+\n+        assertEquals(expFalse, ifCapture(condFalse, expTrue));\n+        assertEquals(expFalse, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifCapture(condFalse, expTrue)));\n+\n+        assertEquals(expTrue, ifCapture(condTrue, expTrue));\n+        assertEquals(expTrue, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifCapture(condTrue, expTrue)));\n+    }\n+\n+    @Test\n+    public void testInitializer() throws Exception {\n+        var a = Tensor.ofFlat(1f, 2, 3, 4);\n+        var b = Tensor.ofFlat(5f, 6, 7, 8);\n+        var c = Tensor.ofFlat(6f, 8, 10, 12);\n+        assertEquals(c, OnnxRuntime.execute(MethodHandles.lookup(), 0, () -> add(a, b)));\n+        assertEquals(c, OnnxRuntime.execute(MethodHandles.lookup(), 1, () -> add(a, b)));\n+        assertEquals(c, OnnxRuntime.execute(MethodHandles.lookup(), 2, () -> add(a, b)));\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -45,9 +45,0 @@\n-    public static float[] loadConstant(String resource) {\n-        try (var in = MNISTDemo.class.getResourceAsStream(resource)) {\n-            return MemorySegment.ofArray(in.readAllBytes())\n-                    .toArray(ValueLayout.JAVA_FLOAT_UNALIGNED);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n@@ -55,1 +46,6 @@\n-    public static Tensor<Float> cnn(Tensor<Float> inputImage) {\n+    public static Tensor<Float> cnn(Tensor<Float> conv1Weights, Tensor<Float> conv1Biases,\n+                                    Tensor<Float> conv2Weights, Tensor<Float> conv2Biases,\n+                                    Tensor<Float> fc1Weights, Tensor<Float> fc1Biases,\n+                                    Tensor<Float> fc2Weights, Tensor<Float> fc2Biases,\n+                                    Tensor<Float> fc3Weights, Tensor<Float> fc3Biases,\n+                                    Tensor<Float> inputImage) {\n@@ -60,2 +56,0 @@\n-        var conv1Weights = Reshape(Constant(loadConstant(\"conv1-weight-float-le\")), Constant(new long[]{6, 1, 5, 5}), empty());\n-        var conv1Biases = Reshape(Constant(loadConstant(\"conv1-bias-float-le\")), Constant(new long[]{6}), empty());\n@@ -72,2 +66,0 @@\n-        var conv2Weights = Reshape(Constant(loadConstant(\"conv2-weight-float-le\")), Constant(new long[]{16, 6, 5, 5}), empty());\n-        var conv2Biases = Reshape(Constant(loadConstant(\"conv2-bias-float-le\")), Constant(new long[]{16}), empty());\n@@ -87,2 +79,0 @@\n-        var fc1Weights = Reshape(Constant(loadConstant(\"fc1-weight-float-le\")), Constant(new long[]{120, 256}), empty());\n-        var fc1Biases = Reshape(Constant(loadConstant(\"fc1-bias-float-le\")), Constant(new long[]{120}), empty());\n@@ -93,2 +83,0 @@\n-        var fc2Weights = Reshape(Constant(loadConstant(\"fc2-weight-float-le\")), Constant(new long[]{84, 120}), empty());\n-        var fc2Biases = Reshape(Constant(loadConstant(\"fc2-bias-float-le\")), Constant(new long[]{84}), empty());\n@@ -99,2 +87,0 @@\n-        var fc3Weights = Reshape(Constant(loadConstant(\"fc3-weight-float-le\")), Constant(new long[]{10, 84}), empty());\n-        var fc3Biases = Reshape(Constant(loadConstant(\"fc3-bias-float-le\")), Constant(new long[]{10}), empty());\n@@ -107,3 +93,45 @@\n-    public static float[] classify(float[] imageData) {\n-        try (Arena arena = Arena.ofConfined()) {\n-            var imageTensor = Tensor.ofShape(arena, IMAGE_SHAPE, imageData);\n+    private static Tensor<Float> initialize(String resource, long... shape) {\n+        try (var in = MNISTDemo.class.getResourceAsStream(resource)) {\n+            return Tensor.ofShape(shape, MemorySegment.ofArray(in.readAllBytes()).toArray(ValueLayout.JAVA_FLOAT_UNALIGNED));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private final Tensor<Float> conv1Weights, conv1Biases,\n+                                conv2Weights, conv2Biases,\n+                                fc1Weights, fc1Biases,\n+                                fc2Weights, fc2Biases,\n+                                fc3Weights, fc3Biases;\n+\n+    public MNISTDemo() {\n+        conv1Weights = initialize(\"conv1-weight-float-le\", 6, 1, 5, 5);\n+        conv1Biases = initialize(\"conv1-bias-float-le\", 6);\n+        conv2Weights = initialize(\"conv2-weight-float-le\", 16, 6, 5, 5);\n+        conv2Biases = initialize(\"conv2-bias-float-le\", 16);\n+        fc1Weights = initialize(\"fc1-weight-float-le\", 120, 256);\n+        fc1Biases = initialize(\"fc1-bias-float-le\", 120);\n+        fc2Weights = initialize(\"fc2-weight-float-le\", 84, 120);\n+        fc2Biases = initialize(\"fc2-bias-float-le\", 84);\n+        fc3Weights = initialize(\"fc3-weight-float-le\", 10, 84);\n+        fc3Biases = initialize(\"fc3-bias-float-le\", 10);\n+    }\n+\n+    public float[] classify(float[] imageData) {\n+\n+        return classify(conv1Weights, conv1Biases,\n+                        conv2Weights, conv2Biases,\n+                        fc1Weights, fc1Biases,\n+                        fc2Weights, fc2Biases,\n+                        fc3Weights, fc3Biases,\n+                        imageData);\n+    }\n+\n+    float[] classify(Tensor<Float> conv1Weights, Tensor<Float> conv1Biases,\n+                     Tensor<Float> conv2Weights, Tensor<Float> conv2Biases,\n+                     Tensor<Float> fc1Weights, Tensor<Float> fc1Biases,\n+                     Tensor<Float> fc2Weights, Tensor<Float> fc2Biases,\n+                     Tensor<Float> fc3Weights, Tensor<Float> fc3Biases,\n+                     float[] imageData) {\n+\n+        try (var arena = Arena.ofConfined()) {\n@@ -111,2 +139,1 @@\n-            var predictionTensor = OnnxRuntime.execute(arena, MethodHandles.lookup(),\n-                    () -> cnn(imageTensor));\n+            Tensor<Float> imageTensor = Tensor.ofShape(arena, IMAGE_SHAPE, imageData);\n@@ -114,1 +141,7 @@\n-            return predictionTensor.data().toArray(ValueLayout.JAVA_FLOAT);\n+            return OnnxRuntime.execute(arena, MethodHandles.lookup(), 10,\n+                    () -> cnn(conv1Weights, conv1Biases,\n+                              conv2Weights, conv2Biases,\n+                              fc1Weights, fc1Biases,\n+                              fc2Weights, fc2Biases,\n+                              fc3Weights, fc3Biases,\n+                              imageTensor)).data().toArray(ValueLayout.JAVA_FLOAT);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/mnist\/MNISTDemo.java","additions":59,"deletions":26,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+        var mnist = new MNISTDemo();\n@@ -80,1 +81,1 @@\n-                    var results = MNISTDemo.classify(imageData);\n+                    var results = mnist.classify(imageData);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/mnist\/MNISTDemoUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}