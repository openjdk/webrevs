{"files":[{"patch":"@@ -21,1 +21,2 @@\n-    public static LambdaToFunc fromLambda(MethodHandles.Lookup l, CoreOp.LambdaOp lambda) {\n+    public static LambdaToFunc fromLambda(MethodHandles.Lookup l, CoreOp.LambdaOp lambda, Map<Value, Object> evaluatedValues) {\n+        evaluatedValues = new HashMap<>(evaluatedValues);\n@@ -35,2 +36,0 @@\n-                OnnxTransformer.OnnxFuncOp onnxFunc = OnnxTransformer.transform(l, f);\n-\n@@ -40,0 +39,1 @@\n+                var fParams = f.parameters();\n@@ -41,1 +41,12 @@\n-                    operandsMapping[i] = captured.indexOf(valueMapping.get(operands.get(i)));\n+                    var opValue = valueMapping.get(operands.get(i));\n+                    operandsMapping[i] = captured.indexOf(opValue);\n+                    if (i == 0) {\n+                        var value = evaluatedValues.get(opValue);\n+                        if (value instanceof CoreOp.Var v) {\n+                            value = v.value();\n+                        }\n+                        if (value != null && !(value instanceof Tensor)) {\n+                            \/\/ @@@ probably a receiver\n+                            evaluatedValues.put(fParams.get(i), value);\n+                        }\n+                    }\n@@ -43,0 +54,1 @@\n+                OnnxTransformer.OnnxFuncOp onnxFunc = OnnxTransformer.transform(l, evaluatedValues, f);\n@@ -50,1 +62,1 @@\n-        OnnxTransformer.OnnxFuncOp onnxFunc = OnnxTransformer.transform(l, CoreOp.func(\"onnxCode\", functionType)\n+        OnnxTransformer.OnnxFuncOp onnxFunc = OnnxTransformer.transform(l, evaluatedValues, CoreOp.func(\"onnxCode\", functionType)\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/LambdaToFunc.java","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -303,0 +303,1 @@\n+        var args = params.isEmpty() || params.getFirst().type() instanceof OnnxType.TensorType ? params : params.subList(1, params.size());\n@@ -305,1 +306,1 @@\n-                params.stream().map(v ->\n+                args.stream().map(v ->\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-            var mf = LambdaToFunc.fromLambda(l, (CoreOp.LambdaOp)q.op());\n+            var mf = LambdaToFunc.fromLambda(l, (CoreOp.LambdaOp)q.op(), q.capturedValues());\n@@ -98,1 +98,5 @@\n-                .map(val -> (Tensor) val)\n+                .<Tensor>mapMulti((val, args) -> {\n+                    if (val instanceof Tensor t) {\n+                        args.accept(t);\n+                    }\n+                })\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n@@ -66,3 +64,4 @@\n-    void evaluate(MethodHandles.Lookup l, T op) {\n-        Map<Value, Object> evaluatedValues = new HashMap<>();\n-        interpretEntryBlock(l, op.body().entryBlock(), new OpContext(), evaluatedValues);\n+    void evaluate(MethodHandles.Lookup l, T op, Map<Value, Object> evaluatedValues) {\n+        var ev = new HashMap(evaluatedValues);\n+\n+        interpretEntryBlock(l, op.body().entryBlock(), new OpContext(), ev);\n@@ -311,1 +310,1 @@\n-            assert o.operands().subList(0, inputs.size()).stream().noneMatch(oc::isValueDefined);\n+\/\/            assert o.operands().subList(0, inputs.size()).stream().noneMatch(oc::isValueDefined);\n@@ -345,1 +344,5 @@\n-                initializers.add(fo.fieldDescriptor().resolveToHandle(l).get());\n+                if (fo.operands().isEmpty()) {\n+                    initializers.add(fo.fieldDescriptor().resolveToHandle(l).get());\n+                } else {\n+                    initializers.add(fo.fieldDescriptor().resolveToHandle(l).get(oc.getValue(fo.operands().getFirst())));\n+                }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxPartialEvaluator.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public static OnnxFuncOp transform(MethodHandles.Lookup l, CoreOp.FuncOp in) {\n+    public static OnnxFuncOp transform(MethodHandles.Lookup l, Map<Value, Object> evaluatedValues, CoreOp.FuncOp in) {\n@@ -36,1 +36,1 @@\n-        pe.evaluate(l, in);\n+        pe.evaluate(l, in, evaluatedValues);\n@@ -105,1 +105,1 @@\n-                                var ltf = LambdaToFunc.fromLambda(l, lo);\n+                                var ltf = LambdaToFunc.fromLambda(l, lo, evaluatedValues);\n@@ -246,1 +246,1 @@\n-    static OnnxType type(TypeElement type) {\n+    static TypeElement type(TypeElement type) {\n@@ -261,1 +261,2 @@\n-        throw new UnsupportedOperationException(\"Unknown type: \" + type);\n+        return type;\n+\/\/        throw new UnsupportedOperationException(\"Unknown type: \" + type);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.HashMap;\n@@ -321,1 +322,1 @@\n-    @Test\n+\/\/    @Test\n@@ -325,1 +326,1 @@\n-            var onnxModel = OnnxTransformer.transform(MethodHandles.lookup(), f);\n+            var onnxModel = OnnxTransformer.transform(MethodHandles.lookup(), new HashMap<>(), f);\n@@ -335,1 +336,1 @@\n-    @Test\n+\/\/    @Test\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-    public static Tensor<Float> add(Tensor<Float> a, Tensor<Float> b) {\n+    public Tensor<Float> add(Tensor<Float> a, Tensor<Float> b) {\n@@ -26,1 +26,1 @@\n-    public static Tensor<Float> sub(Tensor<Float> a, Tensor<Float> b) {\n+    public Tensor<Float> sub(Tensor<Float> a, Tensor<Float> b) {\n@@ -40,1 +40,1 @@\n-    public static Tensor<Float> fconstant() {\n+    public Tensor<Float> fconstant() {\n@@ -53,1 +53,1 @@\n-    public static Tensor<Float> fconstants() {\n+    public Tensor<Float> fconstants() {\n@@ -66,1 +66,1 @@\n-    public static Tensor<Long> lconstant() {\n+    public Tensor<Long> lconstant() {\n@@ -79,1 +79,1 @@\n-    public static Tensor<Long> lconstants() {\n+    public Tensor<Long> lconstants() {\n@@ -92,1 +92,1 @@\n-    public static Tensor<Long> reshapeAndShape(Tensor<Float> data, Tensor<Long> shape) {\n+    public Tensor<Long> reshapeAndShape(Tensor<Float> data, Tensor<Long> shape) {\n@@ -106,1 +106,1 @@\n-    public static Tensor<Long> indicesOfMaxPool(Tensor<Float> x) {\n+    public Tensor<Long> indicesOfMaxPool(Tensor<Float> x) {\n@@ -120,1 +120,1 @@\n-    public static Tensor<Float> ifConst(Tensor<Boolean> cond) {\n+    public Tensor<Float> ifConst(Tensor<Boolean> cond) {\n@@ -139,1 +139,1 @@\n-    public static Tensor<Float> ifCapture(Tensor<Boolean> cond, Tensor<Float> trueValue) {\n+    public Tensor<Float> ifCapture(Tensor<Boolean> cond, Tensor<Float> trueValue) {\n@@ -158,0 +158,14 @@\n+    final Tensor<Float> initialized = Tensor.ofFlat(42f);\n+\n+    @CodeReflection\n+    public Tensor<Float> initialized() {\n+        return OnnxOperators.Identity(initialized);\n+    }\n+\n+    @Test\n+    public void testInitialized() throws Exception {\n+\n+        assertEquals(initialized(),\n+                     OnnxRuntime.execute(MethodHandles.lookup(), () -> initialized()));\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -53,12 +53,12 @@\n-    static final Tensor<Float> conv1Weights;\n-    static final Tensor<Float> conv1Biases;\n-    static final Tensor<Float> conv2Weights;\n-    static final Tensor<Float> conv2Biases;\n-    static final Tensor<Float> fc1Weights;\n-    static final Tensor<Float> fc1Biases;\n-    static final Tensor<Float> fc2Weights;\n-    static final Tensor<Float> fc2Biases;\n-    static final Tensor<Float> fc3Weights;\n-    static final Tensor<Float> fc3Biases;\n-\n-    static {\n+    final Tensor<Float> conv1Weights;\n+    final Tensor<Float> conv1Biases;\n+    final Tensor<Float> conv2Weights;\n+    final Tensor<Float> conv2Biases;\n+    final Tensor<Float> fc1Weights;\n+    final Tensor<Float> fc1Biases;\n+    final Tensor<Float> fc2Weights;\n+    final Tensor<Float> fc2Biases;\n+    final Tensor<Float> fc3Weights;\n+    final Tensor<Float> fc3Biases;\n+\n+    MNISTModel() {\n@@ -78,1 +78,1 @@\n-    public static Tensor<Float> cnn(Tensor<Float> inputImage) {\n+    public Tensor<Float> cnn(Tensor<Float> inputImage) {\n@@ -120,1 +120,1 @@\n-    public static float[] classify(float[] imageData) {\n+    public float[] classify(float[] imageData) {\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/mnist\/MNISTModel.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"}]}