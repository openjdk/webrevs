{"files":[{"patch":"@@ -2554,3 +2554,2 @@\n-                    if (op instanceof CoreOp.ReturnOp) {\n-                        return inlineFinalizer(block, tryExceptionRegion, opT);\n-                    } else if (op instanceof ExtendedOp.JavaLabelOp lop && ifExitFromTry(lop)) {\n+                    if (op instanceof CoreOp.ReturnOp ||\n+                            (op instanceof ExtendedOp.JavaLabelOp lop && ifExitFromTry(lop))) {\n@@ -2564,3 +2563,2 @@\n-                    \/\/ @@@ break and continue\n-                    \/\/ when target break\/continue is enclosing the try\n-                    if (op instanceof CoreOp.ReturnOp) {\n+                    if (op instanceof CoreOp.ReturnOp ||\n+                            (op instanceof ExtendedOp.JavaLabelOp lop && ifExitFromTry(lop))) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,347 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestTryFinallyNested\n- *\/\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.lang.runtime.CodeReflection;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-\n-public class TestTryFinallyNested {\n-    @CodeReflection\n-    public static void tryCatchFinally(IntConsumer c, int i) {\n-        try {\n-            try {\n-                if (i == 0) {\n-                    return;\n-                }\n-                c.accept(0);\n-            } catch (IllegalStateException e) {\n-                if (i == 1) {\n-                    return;\n-                }\n-                c.accept(1);\n-            } finally {\n-                if (i == 2) {\n-                    return;\n-                }\n-                c.accept(2);\n-            }\n-            if (i == 3) {\n-                return;\n-            }\n-            c.accept(3);\n-        } catch (IllegalStateException e) {\n-            if (i == 4) {\n-                return;\n-            }\n-            c.accept(4);\n-        } finally {\n-            if (i == 5) {\n-                return;\n-            }\n-            c.accept(5);\n-        }\n-        c.accept(6);\n-    }\n-\n-    @Test\n-    public void testCatchFinally() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryCatchFinally\");\n-\n-        f.writeTo(System.out);\n-\n-        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n-\n-        lf.writeTo(System.out);\n-\n-        for (int ra = -1; ra < 6; ra++) {\n-            int fra = ra;\n-\n-            Consumer<IntConsumer> test = testConsumer(\n-                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n-                    c -> tryCatchFinally(c, fra)\n-            );\n-\n-            test.accept(i -> {});\n-            for (int ea = 0; ea < 6; ea++) {\n-                int fea = ea;\n-                test.accept(i -> {\n-                    if (i == fea) throw new IllegalStateException();\n-                });\n-                test.accept(i -> {\n-                    if (i == fea) throw new RuntimeException();\n-                });\n-            }\n-        }\n-    }\n-\n-\n-    @CodeReflection\n-    public static void tryCatchFinallyBreak(IntConsumer c, int i) {\n-        a: try {\n-            try {\n-                if (i == 0) {\n-                    break a;\n-                }\n-                c.accept(0);\n-            } catch (IllegalStateException e) {\n-                if (i == 1) {\n-                    break a;\n-                }\n-                c.accept(1);\n-            } finally {\n-                if (i == 2) {\n-                    break a;\n-                }\n-                c.accept(2);\n-            }\n-            if (i == 3) {\n-                break a;\n-            }\n-            c.accept(3);\n-        } catch (IllegalStateException e) {\n-            if (i == 4) {\n-                break a;\n-            }\n-            c.accept(4);\n-        } finally {\n-            if (i == 5) {\n-                break a;\n-            }\n-            c.accept(5);\n-        }\n-        c.accept(6);\n-    }\n-\n-    @Test\n-    public void testCatchFinallyBreak() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryCatchFinallyBreak\");\n-\n-        f.writeTo(System.out);\n-\n-        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n-\n-        lf.writeTo(System.out);\n-\n-        for (int ra = -1; ra < 6; ra++) {\n-            int fra = ra;\n-\n-            Consumer<IntConsumer> test = testConsumer(\n-                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n-                    c -> tryCatchFinallyBreak(c, fra)\n-            );\n-\n-            test.accept(i -> {});\n-            for (int ea = 0; ea < 6; ea++) {\n-                int fea = ea;\n-                test.accept(i -> {\n-                    if (i == fea) throw new IllegalStateException();\n-                });\n-                test.accept(i -> {\n-                    if (i == fea) throw new RuntimeException();\n-                });\n-            }\n-        }\n-    }\n-\n-\n-    @CodeReflection\n-    public static void tryForLoop(IntConsumer c) {\n-        for (int i = 0; i < 8; i++) {\n-            c.accept(0);\n-            try {\n-                if (i == 4) {\n-                    continue;\n-                } else if (i == 5) {\n-                    break;\n-                }\n-                c.accept(1);\n-            } finally {\n-                c.accept(2);\n-            }\n-            c.accept(3);\n-        }\n-        c.accept(4);\n-    }\n-\n-    @Test\n-    public void testTryForLoop() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryForLoop\");\n-\n-        f.writeTo(System.out);\n-\n-        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n-\n-        lf.writeTo(System.out);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n-                TestTryFinallyNested::tryForLoop\n-        );\n-\n-        test.accept(i -> { });\n-    }\n-\n-\n-    @CodeReflection\n-    public static void tryLabeledForLoop(IntConsumer c) {\n-        a: for (int i = 0; i < 8; i++) {\n-            c.accept(0);\n-            b: {\n-                try {\n-                    if (i == 4) {\n-                        continue a;\n-                    } else if (i == 5) {\n-                        break b;\n-                    } else if (i == 6) {\n-                        break a;\n-                    }\n-                    c.accept(1);\n-                } finally {\n-                    c.accept(2);\n-                }\n-                c.accept(3);\n-            }\n-            c.accept(4);\n-        }\n-        c.accept(5);\n-    }\n-\n-    @Test\n-    public void testTryLabeledForLoop() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryLabeledForLoop\");\n-\n-        f.writeTo(System.out);\n-\n-        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n-\n-        lf.writeTo(System.out);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n-                TestTryFinallyNested::tryLabeledForLoop\n-        );\n-\n-        test.accept(i -> { });\n-    }\n-\n-\n-    @CodeReflection\n-    public static void tryLambda(IntConsumer c, int i) {\n-        try {\n-            c.accept(0);\n-            Runnable r = () -> {\n-                if (i == 0) {\n-                    c.accept(1);\n-                    return;\n-                } else {\n-                    c.accept(2);\n-                }\n-                c.accept(3);\n-            };\n-            r.run();\n-            c.accept(4);\n-        } finally {\n-            c.accept(5);\n-        }\n-    }\n-\n-    @Test\n-    public void testTryLambda() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryLambda\");\n-\n-        f.writeTo(System.out);\n-\n-        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n-\n-        lf.writeTo(System.out);\n-\n-        for (int ra = 0; ra < 2; ra++) {\n-            final int fra = ra;\n-            Consumer<IntConsumer> test = testConsumer(\n-                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n-                    c -> tryLambda(c, fra)\n-            );\n-            test.accept(i -> { });\n-        }\n-    }\n-\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestTryFinallyNested.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return m.getCodeModel().get();\n-    }\n-\n-    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n-        return c -> {\n-            List<Integer> actual = new ArrayList<>();\n-            IntConsumer actualC = actual::add;\n-            Throwable actualT = null;\n-            try {\n-                actualR.accept(actualC.andThen(c));\n-            } catch (Interpreter.InterpreterException e) {\n-                throw e;\n-            } catch (Throwable t) {\n-                actualT = t;\n-                if (t instanceof AssertionError) {\n-                    t.printStackTrace();\n-                }\n-            }\n-\n-            List<Integer> expected = new ArrayList<>();\n-            IntConsumer expectedC = expected::add;\n-            Throwable expectedT = null;\n-            try {\n-                expectedR.accept(expectedC.andThen(c));\n-            } catch (Throwable t) {\n-                expectedT = t;\n-            }\n-\n-            Assert.assertEquals(\n-                    actualT != null ? actualT.getClass() : null,\n-                    expectedT != null ? expectedT.getClass() : null);\n-            Assert.assertEquals(actual, expected);\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryFinallyNested.java","additions":0,"deletions":347,"binary":false,"changes":347,"status":"deleted"},{"patch":"@@ -0,0 +1,459 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestTryNested\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+public class TestTryNested {\n+    @CodeReflection\n+    public static void tryCatchFinally(IntConsumer c, int i) {\n+        try {\n+            try {\n+                if (i == 0) {\n+                    return;\n+                }\n+                c.accept(0);\n+            } catch (IllegalStateException e) {\n+                if (i == 1) {\n+                    return;\n+                }\n+                c.accept(1);\n+            } finally {\n+                if (i == 2) {\n+                    return;\n+                }\n+                c.accept(2);\n+            }\n+            if (i == 3) {\n+                return;\n+            }\n+            c.accept(3);\n+        } catch (IllegalStateException e) {\n+            if (i == 4) {\n+                return;\n+            }\n+            c.accept(4);\n+        } finally {\n+            if (i == 5) {\n+                return;\n+            }\n+            c.accept(5);\n+        }\n+        c.accept(6);\n+    }\n+\n+    @Test\n+    public void testCatchFinally() {\n+        CoreOp.FuncOp f = getFuncOp(\"tryCatchFinally\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        lf.writeTo(System.out);\n+\n+        for (int ra = -1; ra < 6; ra++) {\n+            int fra = ra;\n+\n+            Consumer<IntConsumer> test = testConsumer(\n+                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n+                    c -> tryCatchFinally(c, fra)\n+            );\n+\n+            test.accept(i -> {});\n+            for (int ea = 0; ea < 6; ea++) {\n+                int fea = ea;\n+                test.accept(i -> {\n+                    if (i == fea) throw new IllegalStateException();\n+                });\n+                test.accept(i -> {\n+                    if (i == fea) throw new RuntimeException();\n+                });\n+            }\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryCatchBreak(IntConsumer c, int i) {\n+        a: try {\n+            try {\n+                if (i == 0) {\n+                    break a;\n+                }\n+                c.accept(0);\n+            } catch (IllegalStateException e) {\n+                if (i == 1) {\n+                    break a;\n+                }\n+                c.accept(1);\n+            }\n+            if (i == 2) {\n+                break a;\n+            }\n+            c.accept(2);\n+        } catch (IllegalStateException e) {\n+            if (i == 3) {\n+                break a;\n+            }\n+            c.accept(3);\n+        }\n+        c.accept(4);\n+    }\n+\n+    @Test\n+    public void testCatchBreak() {\n+        CoreOp.FuncOp f = getFuncOp(\"tryCatchBreak\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        lf.writeTo(System.out);\n+\n+        for (int ra = -1; ra < 4; ra++) {\n+            int fra = ra;\n+\n+            Consumer<IntConsumer> test = testConsumer(\n+                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n+                    c -> tryCatchBreak(c, fra)\n+            );\n+\n+            test.accept(i -> {});\n+            for (int ea = 0; ea <= 4; ea++) {\n+                int fea = ea;\n+                test.accept(i -> {\n+                    if (i == fea) throw new IllegalStateException();\n+                });\n+                test.accept(i -> {\n+                    if (i == fea) throw new RuntimeException();\n+                });\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void tryCatchFinallyBreak(IntConsumer c, int i) {\n+        a: try {\n+            try {\n+                if (i == 0) {\n+                    break a;\n+                }\n+                c.accept(0);\n+            } catch (IllegalStateException e) {\n+                if (i == 1) {\n+                    break a;\n+                }\n+                c.accept(1);\n+            } finally {\n+                if (i == 2) {\n+                    break a;\n+                }\n+                c.accept(2);\n+            }\n+            if (i == 3) {\n+                break a;\n+            }\n+            c.accept(3);\n+        } catch (IllegalStateException e) {\n+            if (i == 4) {\n+                break a;\n+            }\n+            c.accept(4);\n+        } finally {\n+            if (i == 5) {\n+                break a;\n+            }\n+            c.accept(5);\n+        }\n+        c.accept(6);\n+    }\n+\n+    @Test\n+    public void testCatchFinallyBreak() {\n+        CoreOp.FuncOp f = getFuncOp(\"tryCatchFinallyBreak\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        lf.writeTo(System.out);\n+\n+        for (int ra = -1; ra < 6; ra++) {\n+            int fra = ra;\n+\n+            Consumer<IntConsumer> test = testConsumer(\n+                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n+                    c -> tryCatchFinallyBreak(c, fra)\n+            );\n+\n+            test.accept(i -> {});\n+            for (int ea = 0; ea <= 6; ea++) {\n+                int fea = ea;\n+                test.accept(i -> {\n+                    if (i == fea) throw new IllegalStateException();\n+                });\n+                test.accept(i -> {\n+                    if (i == fea) throw new RuntimeException();\n+                });\n+            }\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryForLoop(IntConsumer c) {\n+        for (int i = 0; i < 8; i++) {\n+            c.accept(0);\n+            try {\n+                if (i == 4) {\n+                    continue;\n+                } else if (i == 5) {\n+                    break;\n+                }\n+                c.accept(1);\n+            } catch (IllegalStateException e) {\n+                c.accept(2);\n+            }\n+            c.accept(3);\n+        }\n+        c.accept(4);\n+    }\n+\n+    @Test\n+    public void testTryForLoop() {\n+        CoreOp.FuncOp f = getFuncOp(\"tryForLoop\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryNested::tryForLoop\n+        );\n+\n+        test.accept(i -> { });\n+        for (int ea = 0; ea <= 4; ea++) {\n+            int fea = ea;\n+            test.accept(i -> {\n+                if (i == fea) throw new IllegalStateException();\n+            });\n+            test.accept(i -> {\n+                if (i == fea) throw new RuntimeException();\n+            });\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void tryForLoopFinally(IntConsumer c) {\n+        for (int i = 0; i < 8; i++) {\n+            c.accept(0);\n+            try {\n+                if (i == 4) {\n+                    continue;\n+                } else if (i == 5) {\n+                    break;\n+                }\n+                c.accept(1);\n+            } finally {\n+                c.accept(2);\n+            }\n+            c.accept(3);\n+        }\n+        c.accept(4);\n+    }\n+\n+    @Test\n+    public void testTryForLoopFinally() {\n+        CoreOp.FuncOp f = getFuncOp(\"tryForLoopFinally\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryNested::tryForLoopFinally\n+        );\n+\n+        test.accept(i -> { });\n+        for (int ea = 0; ea <= 4; ea++) {\n+            int fea = ea;\n+            test.accept(i -> {\n+                if (i == fea) throw new IllegalStateException();\n+            });\n+            test.accept(i -> {\n+                if (i == fea) throw new RuntimeException();\n+            });\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryLabeledForLoop(IntConsumer c) {\n+        a: for (int i = 0; i < 8; i++) {\n+            c.accept(0);\n+            b: {\n+                try {\n+                    if (i == 4) {\n+                        continue a;\n+                    } else if (i == 5) {\n+                        break b;\n+                    } else if (i == 6) {\n+                        break a;\n+                    }\n+                    c.accept(1);\n+                } finally {\n+                    c.accept(2);\n+                }\n+                c.accept(3);\n+            }\n+            c.accept(4);\n+        }\n+        c.accept(5);\n+    }\n+\n+    @Test\n+    public void testTryLabeledForLoop() {\n+        CoreOp.FuncOp f = getFuncOp(\"tryLabeledForLoop\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryNested::tryLabeledForLoop\n+        );\n+\n+        test.accept(i -> { });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryLambda(IntConsumer c, int i) {\n+        try {\n+            c.accept(0);\n+            Runnable r = () -> {\n+                if (i == 0) {\n+                    c.accept(1);\n+                    return;\n+                } else {\n+                    c.accept(2);\n+                }\n+                c.accept(3);\n+            };\n+            r.run();\n+            c.accept(4);\n+        } finally {\n+            c.accept(5);\n+        }\n+    }\n+\n+    @Test\n+    public void testTryLambda() {\n+        CoreOp.FuncOp f = getFuncOp(\"tryLambda\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        lf.writeTo(System.out);\n+\n+        for (int ra = 0; ra < 2; ra++) {\n+            final int fra = ra;\n+            Consumer<IntConsumer> test = testConsumer(\n+                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n+                    c -> tryLambda(c, fra)\n+            );\n+            test.accept(i -> { });\n+        }\n+    }\n+\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTryNested.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryNested.java","additions":459,"deletions":0,"binary":false,"changes":459,"status":"added"}]}