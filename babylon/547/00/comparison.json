{"files":[{"patch":"@@ -40,0 +40,1 @@\n+import jdk.incubator.code.dialect.java.ClassType;\n@@ -42,0 +43,1 @@\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -54,1 +56,0 @@\n-\n@@ -57,1 +58,0 @@\n-\n@@ -73,2 +73,0 @@\n-        boolean interpret = false;\n-     \/\/   long ns = System.nanoTime();\n@@ -90,1 +88,0 @@\n-       \/\/ System.out.println(\"compute \"+ ((System.nanoTime() - ns)\/1000)+\" us\");\n@@ -132,1 +129,1 @@\n-\n+    \/\/ This code should be common with jextracted-shared probably should be pushed down into another lib?\n@@ -134,3 +131,2 @@\n-        CoreOp.FuncOp prevFO = computeMethod.funcOp();\n-        CoreOp.FuncOp returnFO = prevFO;\n-        if (config.isSHOW_COMPUTE_MODEL()) {\n+        CoreOp.FuncOp transformedFuncOp = computeMethod.funcOp();\n+        if (config.isMINIMIZE_COPIES()) {\n@@ -139,1 +135,1 @@\n-                System.out.println(returnFO.toText());\n+                System.out.println(transformedFuncOp.toText());\n@@ -142,18 +138,25 @@\n-            var paramTable = new FuncOpParams(prevFO);\n-            returnFO = prevFO.transform((bldr, op) -> {\n-                if (op instanceof JavaOp.InvokeOp invokeO) {\n-                    CopyContext bldrCntxt = bldr.context();\n-                    \/\/Map compute method's first param (computeContext) value to transformed model\n-                    Value cc = bldrCntxt.getValue(paramTable.list().getFirst().parameter);\n-                    if (OpTk.isIfaceBufferMethod(lookup, invokeO)) {                    \/\/ iface.v(newV)\n-                        Value iface = bldrCntxt.getValue(invokeO.operands().getFirst());\n-                        bldr.op(JavaOp.invoke(MUTATE.pre, cc, iface));  \/\/ cc->preMutate(iface);\n-                        bldr.op(invokeO);                         \/\/ iface.v(newV);\n-                        bldr.op(JavaOp.invoke(MUTATE.post, cc, iface)); \/\/ cc->postMutate(iface)\n-                    } else if (OpTk.isIfaceBufferMethod(lookup, invokeO)) {            \/\/ iface.v()\n-                        Value iface = bldrCntxt.getValue(invokeO.operands().getFirst());\n-                        bldr.op(JavaOp.invoke(ACCESS.pre, cc, iface));  \/\/ cc->preAccess(iface);\n-                        bldr.op(invokeO);                         \/\/ iface.v();\n-                        bldr.op(JavaOp.invoke(ACCESS.post, cc, iface)); \/\/ cc->postAccess(iface) } else {\n-                    } else if (OpTk.isComputeContextMethod(lookup,invokeO) || OpTk.isKernelContextMethod(lookup,invokeO)) { \/\/dispatchKernel\n-                        bldr.op(invokeO);\n+            var paramTable = new FuncOpParams(computeMethod.funcOp());\n+            transformedFuncOp = computeMethod.funcOp().transform((bldr, op) -> {\n+                if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                    Value cc = bldr.context().getValue(paramTable.list().getFirst().parameter);\n+                    if (OpTk.isIfaceBufferMethod(lookup, invokeOp)&& OpTk.javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n+                        Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n+                        bldr.op(JavaOp.invoke(MUTATE.pre, cc, iface));                  \/\/ cc->preMutate(iface);\n+                        bldr.op(invokeOp);                                              \/\/ iface.v(newV);\n+                        bldr.op(JavaOp.invoke(MUTATE.post, cc, iface));                 \/\/ cc->postMutate(iface)\n+                    } else if (OpTk.isIfaceBufferMethod(lookup, invokeOp)\n+                            && (\n+                                    (OpTk.javaReturnType(invokeOp) instanceof ClassType returnClassType)\n+                                            && OpTk.classTypeToTypeOrThrow(lookup, returnClassType) instanceof Class<?> type\n+                                            && Buffer.class.isAssignableFrom(type)\n+                                ||\n+                                            (OpTk.javaReturnType(invokeOp) instanceof PrimitiveType primitiveType)\n+                               )\n+                    ) {\n+                        \/\/ if this is accessing a width if an array we don't want to force the buffer back from the GPU.\n+                        Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n+                        bldr.op(JavaOp.invoke(ACCESS.pre, cc, iface));                 \/\/ cc->preAccess(iface);\n+                        bldr.op(invokeOp);                                             \/\/ iface.v();\n+                        bldr.op(JavaOp.invoke(ACCESS.post, cc, iface));                \/\/ cc->postAccess(iface)\n+                    } else if (OpTk.isComputeContextMethod(lookup,invokeOp) || OpTk.isKernelContextMethod(lookup,invokeOp)) { \/\/dispatchKernel\n+                        bldr.op(invokeOp);\n@@ -161,2 +164,1 @@\n-                        List<Value> list = invokeO.operands();\n-                        \/\/   System.out.println(\"args \"+list.size());\n+                        List<Value> list = invokeOp.operands();\n@@ -164,2 +166,3 @@\n-                            \/\/ System.out.println(\"method \"+invokeOW.method());\n-                            Annotation[][] parameterAnnotations = OpTk.methodOrThrow(lookup, invokeO).getParameterAnnotations();\n+                            System.out.println(\"Escape! with args \" +invokeOp.toText());\n+                            \/\/ We need to check\n+                            Annotation[][] parameterAnnotations = OpTk.methodOrThrow(lookup, invokeOp).getParameterAnnotations();\n@@ -167,1 +170,0 @@\n-                            \/\/   System.out.println(\"params length\"+parameterAnnotations.length);\n@@ -169,1 +171,0 @@\n-\n@@ -179,1 +180,1 @@\n-                                            bldr.op(JavaOp.invoke(ACCESS.pre, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                            bldr.op(JavaOp.invoke(ACCESS.pre, cc, bldr.context().getValue(typeAndAccess.value)));\n@@ -181,1 +182,1 @@\n-                                            bldr.op(JavaOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                            bldr.op(JavaOp.invoke(MUTATE.pre, cc, bldr.context().getValue(typeAndAccess.value)));\n@@ -184,1 +185,1 @@\n-                            bldr.op(invokeO);\n+                            bldr.op(invokeOp);\n@@ -189,1 +190,1 @@\n-                                            bldr.op(JavaOp.invoke(ACCESS.post, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                            bldr.op(JavaOp.invoke(ACCESS.post, cc, bldr.context().getValue(typeAndAccess.value)));\n@@ -191,1 +192,1 @@\n-                                            bldr.op(JavaOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                            bldr.op(JavaOp.invoke(MUTATE.post, cc, bldr.context().getValue(typeAndAccess.value)));\n@@ -195,1 +196,1 @@\n-                            bldr.op(invokeO);\n+                            bldr.op(invokeOp);\n@@ -206,1 +207,1 @@\n-                System.out.println(returnFO.toText());\n+                System.out.println(transformedFuncOp.toText());\n@@ -211,1 +212,1 @@\n-                System.out.println(returnFO.toText());\n+                System.out.println(transformedFuncOp.toText());\n@@ -214,2 +215,2 @@\n-        computeMethod.funcOp(returnFO);\n-        return returnFO;\n+        computeMethod.funcOp(transformedFuncOp);\n+        return transformedFuncOp;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":45,"deletions":44,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.incubator.code.Op;\n@@ -51,1 +50,0 @@\n-\n@@ -54,1 +52,0 @@\n-\n@@ -89,1 +86,0 @@\n-        var paramTable = new FuncOpParams(computeMethod.funcOp());\n@@ -91,0 +87,1 @@\n+        var paramTable = new FuncOpParams(computeMethod.funcOp());\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import hat.Accelerator;\n-import hat.ifacemapper.Schema;\n-\n-import java.lang.foreign.MemorySegment;\n-\n-public interface ChessState extends Buffer {\n-\n-    byte array(long idx);\n-    void array(long idx, byte i);\n-\n-    boolean wCanCastle();\n-    void wCanCastle(boolean value);\n-\n-    boolean bCanCastle();\n-    void bCanCastle(boolean value);\n-\n-    boolean wCheck();\n-    void wCheck(boolean value);\n-\n-    boolean bCheck();\n-    void bCheck(boolean value);\n-\n-    int score();\n-    void score(int value);\n-\n-    int turn();\n-    void turn(int value);\n-\n-    Schema<ChessState> schema = Schema.of(ChessState.class, s->s\n-            .array(\"array\", 64).fields(\"wCanCastle\", \"bCanCastle\", \"wCheck\", \"bCheck\", \"score\", \"turn\"));\n-\n-    static ChessState create(Accelerator accelerator, int length){\n-        return schema.allocate(accelerator, length);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ChessState.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,455 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package experiments;\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.backend.Backend;\n-import hat.buffer.ChessState;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.Scanner;\n-import jdk.incubator.code.CodeReflection;\n-import java.util.*;\n-\n-public class Chess {\n-\n-    \/*\n-        referencing PeSTO (https:\/\/www.chessprogramming.org\/PeSTO%27s_Evaluation_Function)\n-        and progszach piece-square tables (https:\/\/www.chessprogramming.org\/Simplified_Evaluation_Function)\n-        and rustic (https:\/\/rustic-chess.org\/search\/ordering\/how.html)\n-\n-        no en passant or moving pawns by 2 spaces for now\n-        move by entering the piece you want to move, the starting position, and the ending position\n-        e.g. pe2e3 or ng1f3\n-\n-        Chess board layout (idx):\n-        8 |  0,  1,  2,  3,  4,  5,  6,  7,\n-        7 |  8,  9, 10, 11, 12, 13, 14, 15,\n-        6 | 16, 17, 18, 19, 20, 21, 22, 23,\n-        5 | 24, 25, 26, 27, 28, 29, 30, 31,\n-        4 | 32, 33, 34, 35, 36, 37, 38, 39,\n-        3 | 40, 41, 42, 43, 44, 45, 46, 47,\n-        2 | 48, 49, 50, 51, 52, 53, 54, 55,\n-        1 | 56, 57, 58, 59, 60, 61, 62, 63\n-            A   B   C   D   E   F   G   H\n-     *\/\n-\n-    static final int N = -8;\n-    static final int S = 8;\n-    static final int E = 1;\n-    static final int W = -1;\n-    static final int NE = -7;\n-    static final int NW = -9;\n-    static final int SE = 9;\n-    static final int SW = 7;\n-\n-    \/\/ moveset for each piece\n-    static int [] pMoves = {N};\n-    static int [] nMoves = {N + NE, N + NW, S + SE, S + SW, E + NE, E + SE, W + NW, W + SW};\n-    static int [] bMoves = {NE, NW, SE, SW};\n-    static int [] rMoves = {N, E, S, W};\n-    static int [] qMoves = {N, E, S, W, NE, NW, SE, SW};\n-    static int [] kMoves = {N, E, S, W, NE, NW, SE, SW};\n-\n-    \/\/ piece squares tables for finding best position for each piece\n-    static int [] pEval = {\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        50, 50, 50, 50, 50, 50, 50, 50,\n-        10, 10, 20, 30, 30, 20, 10, 10,\n-        5, 5, 10, 25, 25, 10, 5, 5,\n-        0, 0, 0, 20, 20, 0, 0, 0,\n-        5, -5, -10, 0, 0, -10, -5, 5,\n-        5, 10, 10, -20, -20, 10, 10, 5,\n-        0, 0, 0, 0, 0, 0, 0, 0\n-    };\n-\n-    static final int [] nEval = {\n-        -50, -40, -30, -30, -30, -30, -40, -50,\n-        -40, -20, 0, 0, 0, 0, -20, -40,\n-        -30, 0, 10, 15, 15, 10, 0, -30,\n-        -30, 5, 15, 20, 20, 15, 5, -30,\n-        -30, 0, 15, 20, 20, 15, 0, -30,\n-        -30, 5, 10, 15, 15, 10, 5, -30,\n-        -40, -20, 0, 5, 5, 0, -20, -40,\n-        -50, -40, -30, -30, -30, -30, -40, -50\n-    };\n-\n-    static final int [] bEval = {\n-        -20, -10, -10, -10, -10, -10, -10, -20,\n-        -10, 0, 0, 0, 0, 0, 0, -10,\n-        -10, 0, 5, 10, 10, 5, 0, -10,\n-        -10, 5, 5, 10, 10, 5, 5, -10,\n-        -10, 0, 10, 10, 10, 10, 0, -10,\n-        -10, 10, 10, 10, 10, 10, 10, -10,\n-        -10, 5, 0, 0, 0, 0, 5, -10,\n-        -20, -10, -10, -10, -10, -10, -10, -20\n-    };\n-\n-    static final int [] rEval = {\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        5, 10, 10, 10, 10, 10, 10, 5,\n-        -5, 0, 0, 0, 0, 0, 0, -5,\n-        -5, 0, 0, 0, 0, 0, 0, -5,\n-        -5, 0, 0, 0, 0, 0, 0, -5,\n-        -5, 0, 0, 0, 0, 0, 0, -5,\n-        -5, 0, 0, 0, 0, 0, 0, -5,\n-        0, 0, 0, 5, 5, 0, 0, 0\n-    };\n-\n-    static final int [] qEval = {\n-        -20, -10, -10, -5, -5, -10, -10, -20,\n-        -10, 0, 0, 0, 0, 0, 0, -10,\n-        -10, 0, 5, 5, 5, 5, 0, -10,\n-        -5, 0, 5, 5, 5, 5, 0, -5,\n-        0, 0, 5, 5, 5, 5, 0, -5,\n-        -10, 5, 5, 5, 5, 5, 0, -10,\n-        -10, 0, 5, 0, 0, 0, 0, -10,\n-        -20, -10, -10, -5, -5, -10, -10, -20\n-    };\n-\n-    static final int [] kMidEval = {\n-        -30, -40, -40, -50, -50, -40, -40, -30,\n-        -30, -40, -40, -50, -50, -40, -40, -30,\n-        -30, -40, -40, -50, -50, -40, -40, -30,\n-        -30, -40, -40, -50, -50, -40, -40, -30,\n-        -20, -30, -30, -40, -40, -30, -30, -20,\n-        -10, -20, -20, -20, -20, -20, -20, -10,\n-        20, 20, 0, 0, 0, 0, 20, 20,\n-        20, 30, 10, 0, 0, 10, 30, 20\n-    };\n-\n-    \/\/ was going to implement later; piece square table for endgame king movement\n-    static final int [] kEndEval = {\n-        -50, -40, -30, -20, -20, -30, -40, -50,\n-        -30, -20, -10, 0, 0, -10, -20, -30,\n-        -30, -10, 20, 30, 30, 20, -10, -30,\n-        -30, -10, 30, 40, 40, 30, -10, -30,\n-        -30, -10, 30, 40, 40, 30, -10, -30,\n-        -30, -10, 20, 30, 30, 20, -10, -30,\n-        -30, -30, 0, 0, 0, 0, -30, -30,\n-        -50, -30, -30, -30, -30, -30, -30, -50\n-    };\n-\n-    static int [][] moves = {new int[0], pMoves, nMoves, bMoves, rMoves, qMoves, kMoves};\n-    static int [][] psqt = {new int[0], pEval, nEval, bEval, rEval, qEval, kMidEval};\n-    static List<Character> pieces = new ArrayList<>(Arrays.asList(' ', 'p', 'n', 'b', 'r', 'q', 'k'));\n-\n-    public static int boardIdx(int idx, boolean white) {\n-        return (white) ? idx : 8 * (7 - (idx \/ 8)) + (idx % 8);\n-    }\n-\n-    \/\/ score the board using the piece squares tables\n-    public static int evalBoard(ChessState board) {\n-        int blk = 0;\n-        int wht = 0;\n-        for (int i = 0; i < 64; i++) {\n-            int piece = board.array(i);\n-            if (piece == 0) continue;\n-            boolean white = piece > 0;\n-            piece = Math.abs(piece);\n-            if (white) {\n-                wht += psqt[piece][boardIdx(i, white)];\n-            } else {\n-                blk += psqt[piece][boardIdx(i, white)];\n-            }\n-        }\n-        return wht - blk;\n-    }\n-\n-    \/\/ score the board only based on the current move (no iterating through the board)\n-    public static int evalMove(ChessState board, int piece, int start, int end) {\n-        int score = board.score();\n-        boolean white = piece > 0;\n-        piece = Math.abs(piece);\n-        score += psqt[piece][boardIdx(end, white)] - psqt[piece][boardIdx(start, white)];\n-\n-        int nextSpace = Math.abs(board.array(end));\n-        if (nextSpace > 0) {\n-            score += psqt[nextSpace][boardIdx(end, white)];\n-        }\n-        return score;\n-    }\n-\n-    \/\/ check if movement goes off the board\n-    public static boolean inBounds(int start, int end) {\n-        return (end >= 0 && end <= 63\n-                && (start % 8) + (end % 8) > 0 && (start % 8) + (end % 8) < 8\n-                && (start \/ 8) + (end \/ 8) > 0 && (start \/ 8) + (end \/ 8) < 8);\n-    }\n-\n-    \/\/ is the current player in check?\n-    public static boolean inCheck(ChessState board) {\n-        int king = 0;\n-\n-        \/\/ determines whose turn it is\n-        boolean white = board.turn() % 2 == 0;\n-\n-        \/\/ locate the king\n-        for (int i = 0; i < 64; i++) {\n-            if (board.array(i) == ((white) ? 6 : -6)) {\n-                king = i;\n-                break;\n-            }\n-        }\n-\n-        \/\/ scan all rays from king\n-        for (int dir : moves[5]) {\n-            int nextSquare = king;\n-            while (inBounds(king, nextSquare + dir)) {\n-                \/\/ if king is reachable by opponent's piece, return true\n-                if ((white && board.array(nextSquare + dir) < 0) || (!white && board.array(nextSquare + dir) > 0)) {\n-                    int opponentPiece = Math.abs(board.array(nextSquare + dir));\n-                    if (opponentPiece == 5\n-                            || (opponentPiece == 3 && (Math.abs(dir) == 1 || Math.abs(dir) == 8))\n-                            || (opponentPiece == 4 && (Math.abs(dir) == 7 || Math.abs(dir) == 9))\n-                            || (opponentPiece == 1 && ((white && king - nextSquare == 8) || (!white && king - nextSquare == -8)))) {\n-                        return true;\n-                    }\n-                }\n-                if (board.array(nextSquare + dir) == 0) {\n-                    nextSquare += dir;\n-                } else {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        for (int dir : moves[2]) {\n-            if (inBounds(king, king + dir)\n-                    && ((white && board.array(king + dir) < 0) || (!white && board.array(king + dir) > 0))\n-                    && Math.abs(board.array(king + dir)) == 2) return true;\n-        }\n-        return false;\n-    }\n-\n-    \/\/ get the next move that doesn't put us in check\n-    public static int[] getNextMove(ChessState board) {\n-        int[] nextMove = new int[2];\n-        \/\/ stores previous location\n-        nextMove[0] = -1;\n-        \/\/ stores next location\n-        nextMove[1] = -1;\n-        int maxScore = board.score();\n-        boolean white = board.turn() % 2 == 0;\n-        for (int i = 0; i < 64; i++) {\n-            int piece = board.array(i);\n-\n-            \/\/ if we run into an ally piece, move on\n-            if ((white && piece <= 0) || (!white && piece >= 0)) continue;\n-\n-            \/\/ go through all rays of movement\n-            for (int dir : moves[Math.abs(piece)]) {\n-                if (!white) dir = -dir;\n-                int nextSquare = i + dir;\n-                int replacedVal;\n-                while (inBounds(i, nextSquare)\n-                        && ((white && board.array(nextSquare) <= 0) || (!white && board.array(nextSquare) >= 0))) {\n-                    replacedVal = board.array(nextSquare);\n-                    \/\/ do the move\n-                    board.array(i, (byte) 0);\n-                    board.array(nextSquare, (byte) piece);\n-                    if (!inCheck(board)) {\n-                        int score = evalMove(board, piece, i, nextSquare);\n-                        if (score > maxScore || nextMove[0] == -1) {\n-                            maxScore = score;\n-                            nextMove[0] = i;\n-                            nextMove[1] = nextSquare;\n-                        }\n-                    }\n-                    \/\/ undo move\n-                    board.array(i, (byte) piece);\n-                    board.array(nextSquare, (byte) replacedVal);\n-                    if (Math.abs(piece) < 3 || Math.abs(piece) > 5 || board.array(nextSquare) != 0) break;\n-                    nextSquare += dir;\n-                }\n-            }\n-        }\n-        return nextMove;\n-    }\n-\n-    public static void move(ChessState board, int start, int end) {\n-        int piece = board.array(start);\n-        board.array(start, (byte) 0);\n-        board.array(end, (byte) piece);\n-    }\n-\n-    @CodeReflection\n-    \/\/ was supposed to be an alpha beta tree\n-    public static void alphaBeta(KernelContext kc, hat.buffer.ChessState board) {\n-        if (kc.x<kc.maxX){\n-            int[] nextMove = getNextMove(board);\n-            if (nextMove[0] < 0) {\n-                System.out.println(\"white wins!\");\n-            } else {\n-                move(board, nextMove[0], nextMove[1]);\n-                board.turn(board.turn() + 1);\n-            }\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void compute(ComputeContext cc, hat.buffer.ChessState board) {\n-        cc.dispatchKernel(1,\n-                kc -> alphaBeta(kc, board)\n-        );\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n-        var board = initBoard(accelerator);\n-        printBoard(board);\n-\n-        Scanner scanner = new Scanner(System.in);\n-        String str = \"\";\n-        int piece = 0;\n-        int start = -1;\n-        int end = -1;\n-        boolean validInput = false;\n-        boolean checkmate = false;\n-\n-        while (!checkmate) {\n-            while (!validInput) {\n-                do {\n-                    System.out.println(\"Your move : [pnbrqk][a-h][1-8][a-h][1-8]\");\n-                    str = scanner.nextLine().toLowerCase();\n-                }while(str.isEmpty());\n-                if (!(\"pnbrqk\".contains(String.valueOf(str.charAt(0)))\n-                      \/\/  && Character.isLetter(str.charAt(1))\n-                        && str.charAt(1) >='a'\n-                        && str.charAt(1) <='h'\n-                        \/\/&& Character.isDigit(str.charAt(2))\n-                        && str.charAt(2) >= '1'\n-                        && str.charAt(2) <= '8'\n-                     \/\/   && Character.isLetter(str.charAt(3))\n-                        && str.charAt(3) >='a'\n-                        && str.charAt(3) <='h'\n-                       \/\/ && Character.isDigit(str.charAt(4))\n-                        && str.charAt(4) >= '1'\n-                        && str.charAt(4) <= '8')) {\n-                    System.out.println(\"Invalid input!\");\n-                } else {\n-                    piece = pieces.indexOf(str.charAt(0));\n-                    start = ((str.charAt(1) - 97) + (7 - (str.charAt(2) - 49)) * 8);\n-                    if (Math.abs(board.array(start)) != piece) {\n-                        System.out.println(\"Invalid input!\");\n-                        continue;\n-                    }\n-                    end = ((str.charAt(3) - 97) + (7 - (str.charAt(4) - 49)) * 8);\n-                    for (int i : moves[piece]) {\n-                        if (i == end - start || (piece >= 3 && piece <= 5 && ((end - start) & i) == 0)) {\n-                            validInput = true;\n-                            break;\n-                        }\n-                    }\n-                    if (!validInput) System.out.println(\"Invalid input!\");\n-                }\n-            }\n-\n-            board.score(evalMove(board, piece, start, end));\n-            move(board, start, end);\n-\n-            if (inCheck(board) && getNextMove(board)[0] < 0) {\n-                System.out.println(\"black wins!\");\n-                checkmate = true;\n-            } else {\n-                board.turn(board.turn() + 1);\n-                printBoard(board);\n-                accelerator.compute(\n-                        cc -> Chess.compute(cc, board)  \/\/QuotableComputeContextConsumer\n-                );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n-                System.out.println();\n-                printBoard(board);\n-                validInput = false;\n-            }\n-        }\n-        System.out.println(\"game over\");\n-    }\n-\n-    private static ChessState initBoard(Accelerator accelerator) {\n-        var board = ChessState.create(accelerator, 64);\n-        for (int i = 0; i < 64; i++) {\n-            int row = i \/ 8;\n-            int col = i % 8;\n-            if (row == 0) {\n-                if (col == 4) {\n-                    board.array(i, (byte) -6);\n-                } else if (col == 3) {\n-                    board.array(i, (byte) -5);\n-                } else if (col == 2 || col == 5) {\n-                    board.array(i, (byte) -3);\n-                } else if (col == 1 || col == 6) {\n-                    board.array(i, (byte) -2);\n-                } else {\n-                    board.array(i, (byte) -4);\n-                }\n-            } else if (row == 7){\n-                if (col == 4) {\n-                    board.array(i, (byte) 6);\n-                } else if (col == 3) {\n-                    board.array(i, (byte) 5);\n-                } else if (col == 2 || col == 5) {\n-                    board.array(i, (byte) 3);\n-                } else if (col == 1 || col == 6) {\n-                    board.array(i, (byte) 2);\n-                } else {\n-                    board.array(i, (byte) 4);\n-                }\n-            } else if (row == 1) {\n-                board.array(i, (byte) -1);\n-            } else if (row == 6) {\n-                board.array(i, (byte) 1);\n-            }else {\n-                board.array(i, (byte) 0);\n-            }\n-        }\n-        board.bCanCastle(true);\n-        board.wCanCastle(true);\n-        board.score(evalBoard(board));\n-        return board;\n-    }\n-\n-    public static void printBoard(ChessState board) {\n-        char[] whtPieces = new char []{' ', '♙', '♘', '♗', '♖', '♕', '♔'};\n-        char[] blkPieces = new char []{' ', '♟', '♞', '♝', '♜', '♛', '♚'};\n-        for (int i = 0; i < 64; i++) {\n-            if (i % 8 == 0) System.out.print((71 - i) \/ 8 + \" \");\n-            if (board.array(i) < 0) {\n-                System.out.print(blkPieces[-board.array(i)]);\n-            } else {\n-                System.out.print(whtPieces[board.array(i)]);\n-            }\n-            if (i % 8 == 7) {\n-                System.out.println();\n-            } else {\n-                System.out.print(\" \");\n-            }\n-        }\n-        System.out.println(\"  A B C D E F G H\");\n-    }\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Chess.java","additions":0,"deletions":455,"binary":false,"changes":455,"status":"deleted"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.ArrayList;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DNA.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import hat.optools.OpTk;\n-\n-import java.lang.reflect.Method;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.CodeReflection;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-public class DependencyTree {\n-\n-\/*\n-\n-    record NodePrev<T extends Value>(T node, List<Node<T>> children) {\n-        <U extends Value> Node<U> transform(Function<T, U> f) {\n-            List<Node<U>> children = new ArrayList<>();\n-            for (Node<T> child : children()) {\n-                children.add(child.transform(f));\n-            }\n-            return new Node<>(f.apply(node()), children);\n-        }\n-    }\n-\n-    static Map<Op, Node<Value>> dependencyTrees(CoreOps.FuncOp f) {\n-        Map<Op, Node<Value>> trees = new LinkedHashMap<>();\n-        Map<Value, Node<Value>> params = new HashMap<>();\n-        f.body().traverse(null, (_, ce) -> {\n-            if (ce instanceof Op op) {\n-                List<Node<Value>> children = new ArrayList<>();\n-                for (Value operand : op.operands()) {\n-                    if (operand instanceof Op.Result opr) {\n-                        children.add(trees.get(opr.op()));\n-                    } else {\n-                        \/\/ Block parameter\n-                        children.add(params.computeIfAbsent(operand, _ -> new Node<>(operand, List.of())));\n-                    }\n-                }\n-                trees.put(op, new Node<>(op.result(), children));\n-            }\n-            return null;\n-        });\n-        return trees;\n-    }\n-*\/\n-\n-    \/*\n-    static void printDependencyTrees(CoreOps.FuncOp f) {\n-        Map<Op, Node<Value>> trees = dependencyTrees(f);\n-        Map<CodeItem, String> names = OpWriter.computeGlobalNames(f);\n-        trees.forEach((op, valueNode) -> {\n-            if (op instanceof CoreOps.VarAccessOp.VarStoreOp) {\n-                Value value = op.operands().get(1);\n-                if (value.uses().size() > 1) {\n-                    System.out.println(\"Expression store: \" + op);\n-                } else {\n-                    System.out.println(\"Root: \" + op);\n-                }\n-                System.out.println(\"      \" + valueNode.transform(names::get));\n-            }\n-            else if (op instanceof CoreOps.VarOp || op.result().uses().isEmpty()) {\n-                System.out.println(\"Root: \" + op);\n-                System.out.println(\"      \" + valueNode.transform(names::get));\n-            }\n-        });\n-    } *\/\n-\/*\n-    static Set<Op> rootSet(CoreOps.FuncOp f) {\n-        Set<Op> roots = new LinkedHashSet<>();\n-        Map<Op, Node<Value>> trees = dependencyTrees(f);\n-     \/\/   Map<CodeItem, String> names = OpWriter.computeGlobalNames(f);\n-        trees.forEach((op, valueNode) -> {\n-            if (op instanceof CoreOps.VarAccessOp.VarStoreOp) {\n-                Value value = op.operands().get(1);\n-                if (value.uses().size() > 1) {\n-                    \/\/System.out.println(\"Expression store: \" + op);\n-                } else {\n-                    roots.add(op);\n-                }\n-               \/\/ System.out.println(\"      \" + valueNode.transform(names::get));\n-            }\n-            else if (op instanceof CoreOps.VarOp || op.result().uses().isEmpty()) {\n-                roots.add(op);\n-               \/\/ System.out.println(\"Root: \" + op);\n-               \/\/ System.out.println(\"      \" + valueNode.transform(names::get));\n-            }\n-        });\n-        return roots;\n-    }\n-*\/\n-\n-    \/*\n-        static void printDependencyTree(CoreOps.FuncOp f) {\n-            Map<CodeItem, String> names = OpWriter.computeGlobalNames(f);\n-\n-            f.traverse(null, (o, ce) -> {\n-                if (ce instanceof CoreOps.VarOp vop) {\n-                    Node<String> tree = dependencyTree(vop.result()).transform(names::get);\n-                    System.out.printf(\"Var def %s depends on %s\\n\",\n-                            vop.varName(), tree);\n-                } else if (ce instanceof CoreOps.VarAccessOp.VarStoreOp vsop) {\n-                    Node<String> tree = dependencyTree(vsop.result()).transform(names::get);\n-                    System.out.printf(\"Var store to %s depends on %s\\n\",\n-                            vsop.varOp().varName(), tree);\n-                } else if (ce instanceof CoreOps.ReturnOp rop) {\n-                    Node<String> tree = dependencyTree(rop.result()).transform(names::get);\n-                    System.out.printf(\"Return depends on %s\\n\",\n-                            tree);\n-                }\n-                return null;\n-            });\n-        }\n-    *\/\n-    static int g(int i) {\n-        return i;\n-    }\n-\n-    @CodeReflection\n-    static void f() {\n-        int x = 0;\n-        x = 1;\n-        g(x);\n-        int y = g(x) + (x = 2);\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(DependencyTree.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-\n-\n-    public static void main(String[] args) {\n-        CoreOp.FuncOp f = getFuncOp(\"f\");\n-        System.out.println(f.toText());\n-        OpTk.rootsExcludingVarFuncDeclarationsAndYields(f.body().entryBlock()).forEach(op -> {\n-            System.out.println(op.toText());\n-        });\n-\n-\n-    }\n-\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DependencyTree.java","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import hat.Accelerator;\n-import hat.backend.Backend;\n-import hat.buffer.S32Array;\n-\n-import java.lang.invoke.MethodHandles;\n-\/*\n-https:\/\/github.com\/openjdk\/babylon\/tree\/code-reflection\/test\/jdk\/java\/lang\/reflect\/code\n-*\/\n-\n-public class LambdaTest {\n-    public static void main(String[] args) {\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-\n-        \/\/ TODO: create a test case for these **\/\n-        S32Array s32Array = S32Array.create(accelerator, 10);\n-    }\n-\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LambdaTest.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -74,1 +74,1 @@\n-        \/\/ Quite an expensive way of adding 20 to each array alement\n+        \/\/ Quite an expensive way of adding 20 to each array element\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/MinBufferTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import javax.xml.transform.OutputKeys;\n-import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.dom.DOMSource;\n-import javax.xml.transform.stream.StreamResult;\n-import java.io.File;\n-import java.util.*;\n-import java.util.regex.*;\n-public class PomChecker {\n-\/\/ XML facade to offer modern access to org.w3x.dom artifacts\n-\n-    public static class XMLNode {\n-        org.w3c.dom.Element element;\n-        List<XMLNode> children = new ArrayList<>();\n-        Map<String, String> attrMap =  new HashMap<>();\n-\n-        XMLNode(org.w3c.dom.Element element) {\n-            this.element = element;\n-            this.element.normalize();\n-            for (int i = 0; i < this.element.getChildNodes().getLength(); i++) {\n-                if (this.element.getChildNodes().item(i) instanceof org.w3c.dom.Element e){\n-                    this.children.add(new XMLNode(e));\n-                }\n-            }\n-            for (int i = 0; i < element.getAttributes().getLength(); i++) {\n-                if (element.getAttributes().item(i) instanceof org.w3c.dom.Attr attr){\n-                    this.attrMap.put(attr.getName(),attr.getValue());\n-                }\n-            }\n-        }\n-        public boolean hasAttr(String name) { return attrMap.containsKey(name); }\n-        public String attr(String name) { return attrMap.get(name); }\n-        XMLNode(File file) throws Throwable {\n-           this(javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file).getDocumentElement());\n-        }\n-        void write(File file) throws Throwable {\n-            var  transformer = TransformerFactory.newInstance().newTransformer();\n-            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n-            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n-            transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n-            transformer.transform(new DOMSource(element.getOwnerDocument()), new StreamResult(file));\n-        }\n-    }\n-\n-\n-\n-\n-\n-    static Pattern varPattern=Pattern.compile(\"\\\\$\\\\{([^}]*)\\\\}\");\n-\n-    static String varExpand(Map<String,String> props, String value){ \/\/ recurse\n-        String result = value;\n-        if (varPattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n-            var v = matcher.group(1);\n-            result = varExpand(props,value.substring(0, matcher.start())\n-                    +(v.startsWith(\"env\")\n-                    ?System.getenv(v.substring(4))\n-                    :props.get(v))\n-                    +value.substring(matcher.end()));\n-            \/\/System.out.println(\"incomming ='\"+value+\"'  v= '\"+v+\"' value='\"+value+\"'->'\"+result+\"'\");\n-        }\n-        return result;\n-    }\n-\n-    public static void main(String[] args) throws Throwable{\n-         var props = new LinkedHashMap<String,String>();\n-\n-        var dir = new File(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\");\n-\n-        var topPom = new XMLNode(new File(dir,\"pom.xml\"));\n-        topPom.write( new File(dir,\"gramminet.xml\"));\n-        topPom.children.stream()\n-                .filter(e->e.element.getNodeName().equals(\"properties\")).\n-                forEach(properties ->\n-                        properties .children.stream() .forEach(property ->\n-                                props.put(property.element.getNodeName(),varExpand(props,property.element.getTextContent()))\n-                        )\n-                );\n-        \/\/props.forEach((k,v)->System.out.println(k+\"->\"+v));\n-        var spirvDirKey = \"beehive.spirv.toolkit.dir\";\n-        var hatDirKey = \"hat.dir\";\n-        var dirKeys = new String[]{spirvDirKey, hatDirKey};\n-        var requiredDirKeys = new String[]{hatDirKey};\n-        var dirKeyToDirMap = new HashMap<String,File>();\n-        for (var dirKey:dirKeys){\n-            if (props.containsKey(dirKey)){\n-                dirKeyToDirMap.put(dirKey,new File(props.get(dirKey)));\n-            }\n-        }\n-        for (var dirKey:requiredDirKeys){\n-            if (props.containsKey(dirKey)){\n-                if (!dirKeyToDirMap.get(dirKey).exists()){\n-                    System.out.println(\"pom.xml has key'\"+dirKey+\"' but dir does not exists\");\n-                    System.exit(1);\n-                }\n-            }\n-        }\n-\n-        var hatDir = dirKeyToDirMap.get(hatDirKey);\n-        var hereDir = new File(System.getProperty(\"user.dir\"));\n-        if (!hatDir.equals(hereDir)){\n-            System.out.println(\"hat.dir='\"+hatDir+\"' != ${PWD}='\"+hereDir+\"'\");\n-        } else{\n-            System.out.println(\"hat.dir='\"+hatDir+\"' looks good\");\n-            var backendsPom = new XMLNode(new File(dir,\"backends\/pom.xml\"));\n-            var modules = backendsPom.children.stream().filter(e->e.element.getNodeName().equals(\"modules\")).findFirst().get();\n-            var spirvModule = modules.children.stream().filter(e->e.element.getTextContent().equals(\"spirv\")).findFirst();\n-\n-            if (spirvModule.isPresent()){\n-\n-                if (dirKeyToDirMap.containsKey(spirvDirKey)) {\n-                    var spirvDir = dirKeyToDirMap.get(spirvDirKey);\n-                    if (spirvDir.exists()) {\n-                        System.out.println(\"OK \"+spirvDirKey + \" -> '\" + spirvDir + \"' dir exists and module included in backends\");\n-                    } else {\n-                        System.out.println(\"ERR \"+spirvDirKey + \" -> '\" + spirvDir + \"' dir does not exists but module included in backends \");\n-                    }\n-                }else{\n-                    System.out.println(\"ERR \"+spirvDirKey + \" -> variable dir does not exists but module included in backends \");\n-                }\n-            } else{\n-                if (dirKeyToDirMap.containsKey(spirvDirKey)) {\n-                    var spirvDir = dirKeyToDirMap.get(spirvDirKey);\n-                if (spirvDir.exists()){\n-                    System.out.println(\"ERR \"+spirvDirKey+\" -> '\"+spirvDir+\"' dir exists but spirv module not included in backends \");\n-                }else{\n-                    System.out.println(\"WARN \"+spirvDirKey+\" -> '\"+spirvDir+\"' dir does not exist and not included in backends \");\n-                }\n-                }else{\n-                    System.out.println(\"OK \"+ spirvDirKey + \" -> variable dir does not exist and module not included in backends \");\n-                }\n-            }\n-        }\n-    }\n-\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PomChecker.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package experiments;\n-\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.CodeReflection;\n-import java.util.List;\n-import java.util.Map;\n-\n-public class PrePostInc {\n-        @CodeReflection\n-        public static int  preInc(int value) {\n-            int pre = 25 + ++value;\n-            return pre;\n-        }\n-\n-        @CodeReflection\n-        public static int  postInc(int value) {\n-           int post = 25 + value++;\n-           return post;\n-        }\n-\n-        static public void main(String[] args) throws Exception {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            Method pre = PrePostInc.class.getDeclaredMethod(\"preInc\",  int.class);\n-            Method post = PrePostInc.class.getDeclaredMethod(\"postInc\",  int.class);\n-            CoreOp.FuncOp preFunc = Op.ofMethod(pre).get();\n-            CoreOp.FuncOp postFunc = Op.ofMethod(post).get();\n-\n-            Object preResult = Interpreter.invoke(lookup,preFunc,5);\n-            System.out.println(\"Pre \"+ preResult);\n-            Object postResult = Interpreter.invoke(lookup,postFunc,5);\n-            System.out.println(\"Pre \"+ postResult);\n-          \/\/  javaFunc.writeTo(System.out);\n-\n-        }\n-}\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrePostInc.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import hat.codebuilders.C99HATComputeBuilder;\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import static jdk.incubator.code.dialect.core.CoreOp.return_;\n-import static jdk.incubator.code.dialect.core.CoreOp.closureCall;\n-import static jdk.incubator.code.dialect.core.CoreOp.constant;\n-import static jdk.incubator.code.dialect.core.CoreOp.func;\n-import static jdk.incubator.code.dialect.core.CoreType.functionType;\n-import static jdk.incubator.code.dialect.java.JavaOp.add;\n-import static jdk.incubator.code.dialect.java.JavaType.INT;\n-\/*\n-https:\/\/github.com\/openjdk\/babylon\/tree\/code-reflection\/test\/jdk\/java\/lang\/reflect\/code\n-*\/\n-\n-public class QuotedTest {\n-    public static void quotedTest() {\n-        Quoted quoted = () -> {\n-        }; \/\/See TestClosureOps:132\n-        Op qop = quoted.op();\n-        Op top = qop.ancestorOp().ancestorOp();\n-\n-\n-        CoreOp.FuncOp fop = (CoreOp.FuncOp) top;\n-    }\n-\n-    public static void main(String[] args) {\n-        quotedTest();\n-        CoreOp.FuncOp f = func(\"f\", functionType(INT, INT))\n-                .body(block -> {\n-                    \/\/  OpWrapper.BodyWrapper.onlyBlock(block, l->{});\n-                    Block.Parameter i = block.parameters().get(0);\n-\n-                    \/\/ functional type = (int)int\n-                    \/\/   captures i\n-                    CoreOp.ClosureOp closure = CoreOp.closure(block.parentBody(), functionType(INT, INT))\n-                            .body(cblock -> {\n-                                Block.Parameter ci = cblock.parameters().get(0);\n-                                cblock.op(return_(cblock.op(add(i, ci))));\n-                            });\n-                    Op.Result c = block.op(closure);\n-                    Op.Result fortyTwo = block.op(constant(INT, 42));\n-                    Op.Result or = block.op(closureCall(c, fortyTwo));\n-                    block.op(return_(or));\n-                });\n-\n-        System.out.println(f.toText());\n-        MethodHandles.Lookup lookup =  MethodHandles.lookup();\n-        C99HATComputeBuilder codeBuilder = new C99HATComputeBuilder();\n-        \/\/FuncOpWrapper wf = OpWrapper.wrap(lookup,f);\n-        codeBuilder.compute(lookup,f);\n-        System.out.println(codeBuilder);\n-\n-        \/\/ target type of a lambda must be an interface\n-\n-    }\n-\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedTest.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -74,1 +74,1 @@\n-    public static void rgbToGreyKernel(@RO KernelContext kc, @RO S08x3RGBImage rgbImage, @RW F32Array2D greyImage) {\n+    public static void rgbToGreyKernel(@RO KernelContext kc, @RO S08x3RGBImage rgbImage, @WO F32Array2D greyImage) {\n@@ -173,2 +173,2 @@\n-        float C = integralOrIntegralSqImage.array(xyToLong(imageWidth, x, y + h));       \/\/   |         |\n-        float B = integralOrIntegralSqImage.array(xyToLong(imageWidth, x + w, y));       \/\/  [C]-------[D]\n+        float C = integralOrIntegralSqImage.array(xyToLong(imageWidth, x, y + h));         \/\/   |         |\n+        float B = integralOrIntegralSqImage.array(xyToLong(imageWidth, x + w, y));         \/\/  [C]-------[D]\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}