{"files":[{"patch":"@@ -110,1 +110,1 @@\n-    public CudaHATKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n+    public CudaHATKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorStoreView hatVectorStoreView) {\n@@ -136,1 +136,1 @@\n-        if (hatVectorStoreView.operands().get(1) instanceof Op.Result r && r.op() instanceof HATVectorBinaryOp) {\n+        if (hatVectorStoreView.operands().get(1) instanceof Op.Result r && r.op() instanceof HATVectorOp.HATVectorBinaryOp) {\n@@ -146,1 +146,1 @@\n-    public CudaHATKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n+    public CudaHATKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -154,1 +154,1 @@\n-        if (op1 instanceof Op.Result r && r.op() instanceof HATVectorBinaryOp hatVectorBinaryOp1) {\n+        if (op1 instanceof Op.Result r && r.op() instanceof HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp1) {\n@@ -162,1 +162,1 @@\n-        if (op2 instanceof Op.Result r && r.op() instanceof HATVectorBinaryOp hatVectorBinaryOp2) {\n+        if (op2 instanceof Op.Result r && r.op() instanceof HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp2) {\n@@ -178,1 +178,1 @@\n-                if (!(r.op() instanceof HATVectorBinaryOp hatVectorBinaryOp1)) {\n+                if (!(r.op() instanceof HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp1)) {\n@@ -188,1 +188,1 @@\n-                if (!(r.op() instanceof HATVectorBinaryOp hatVectorBinaryOp2)) {\n+                if (!(r.op() instanceof HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp2)) {\n@@ -201,1 +201,1 @@\n-    public CudaHATKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n+    public CudaHATKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorLoadOp hatVectorLoadOp) {\n@@ -230,1 +230,1 @@\n-    public CudaHATKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n+    public CudaHATKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectLoadOp hatVSelectLoadOp) {\n@@ -238,1 +238,1 @@\n-    public CudaHATKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n+    public CudaHATKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectStoreOp hatVSelectStoreOp) {\n@@ -257,1 +257,1 @@\n-    public CudaHATKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n+    public CudaHATKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ConvOp hatF16ConvOp) {\n@@ -274,1 +274,1 @@\n-    public CudaHATKernelBuilder hatF16ToFloatConvOp(ScopedCodeBuilderContext builderContext, HATF16ToFloatConvOp hatF16ToFloatConvOp) {\n+    public CudaHATKernelBuilder hatF16ToFloatConvOp(ScopedCodeBuilderContext builderContext, HATF16Op.HATF16ToFloatConvOp hatF16ToFloatConvOp) {\n@@ -291,1 +291,1 @@\n-    public CudaHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n+    public CudaHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarOp hatVectorVarOp) {\n@@ -297,1 +297,1 @@\n-        if (operand instanceof Op.Result r && r.op() instanceof HATVectorBinaryOp) {\n+        if (operand instanceof Op.Result r && r.op() instanceof HATVectorOp.HATVectorBinaryOp) {\n@@ -310,1 +310,1 @@\n-    public CudaHATKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp) {\n+    public CudaHATKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOp.HATVectorOfOp hatVectorOfOp) {\n@@ -316,1 +316,1 @@\n-    public CudaHATKernelBuilder hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatF16BinaryOp) {\n+    public CudaHATKernelBuilder hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatF16BinaryOp) {\n@@ -321,1 +321,1 @@\n-        byte f32Mixed = hatF16BinaryOp.getF32();\n+        byte f32Mixed = hatF16BinaryOp.getByteFloatRepresentation();\n@@ -325,1 +325,1 @@\n-        if (f32Mixed == HATF16BinaryOp.LAST_OP) {\n+        if (f32Mixed == HATF16Op.HATF16BinaryOp.LAST_OP) {\n@@ -338,1 +338,1 @@\n-        if (f32Mixed == HATF16BinaryOp.LAST_OP) {\n+        if (f32Mixed == HATF16Op.HATF16BinaryOp.LAST_OP) {\n@@ -344,1 +344,1 @@\n-        if (f32Mixed == HATF16BinaryOp.FIRST_OP) {\n+        if (f32Mixed == HATF16Op.HATF16BinaryOp.FIRST_OP) {\n@@ -358,1 +358,1 @@\n-        if (f32Mixed == HATF16BinaryOp.FIRST_OP) {\n+        if (f32Mixed == HATF16Op.HATF16BinaryOp.FIRST_OP) {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import hat.dialect.HATF16Op;\n+import hat.dialect.HATVectorOp;\n@@ -30,9 +32,0 @@\n-import hat.dialect.HATF16ConvOp;\n-import hat.dialect.HATF16ToFloatConvOp;\n-import hat.dialect.HATVectorBinaryOp;\n-import hat.dialect.HATVectorLoadOp;\n-import hat.dialect.HATVectorOfOp;\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorSelectStoreOp;\n-import hat.dialect.HATVectorStoreView;\n-import hat.dialect.HATVectorVarOp;\n@@ -96,1 +89,1 @@\n-    public OpenCLHATKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n+    public OpenCLHATKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorStoreView hatVectorStoreView) {\n@@ -103,1 +96,1 @@\n-        if (hatVectorStoreView.operands().get(1) instanceof Op.Result r && r.op() instanceof HATVectorBinaryOp) {\n+        if (hatVectorStoreView.operands().get(1) instanceof Op.Result r && r.op() instanceof HATVectorOp.HATVectorBinaryOp) {\n@@ -129,1 +122,1 @@\n-    public OpenCLHATKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n+    public OpenCLHATKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -148,1 +141,1 @@\n-    public OpenCLHATKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n+    public OpenCLHATKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorLoadOp hatVectorLoadOp) {\n@@ -165,2 +158,2 @@\n-    public OpenCLHATKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n-        if (hatVSelectLoadOp.operands().getFirst() instanceof Op.Result res && res.op() instanceof HATVectorLoadOp vLoadOp) {\n+    public OpenCLHATKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectLoadOp hatVSelectLoadOp) {\n+        if (hatVSelectLoadOp.operands().getFirst() instanceof Op.Result res && res.op() instanceof HATVectorOp.HATVectorLoadOp vLoadOp) {\n@@ -176,2 +169,2 @@\n-    public OpenCLHATKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n-        if (hatVSelectStoreOp.operands().getFirst() instanceof Op.Result res && res.op() instanceof HATVectorLoadOp vLoadOp) {\n+    public OpenCLHATKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectStoreOp hatVSelectStoreOp) {\n+        if (hatVSelectStoreOp.operands().getFirst() instanceof Op.Result res && res.op() instanceof HATVectorOp.HATVectorLoadOp vLoadOp) {\n@@ -198,1 +191,1 @@\n-    public OpenCLHATKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n+    public OpenCLHATKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ConvOp hatF16ConvOp) {\n@@ -226,1 +219,1 @@\n-    public OpenCLHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n+    public OpenCLHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarOp hatVectorVarOp) {\n@@ -238,1 +231,1 @@\n-    public OpenCLHATKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp) {\n+    public OpenCLHATKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOp.HATVectorOfOp hatVectorOfOp) {\n@@ -243,1 +236,1 @@\n-    public OpenCLHATKernelBuilder hatF16ToFloatConvOp(ScopedCodeBuilderContext builderContext, HATF16ToFloatConvOp hatF16ToFloatConvOp) {\n+    public OpenCLHATKernelBuilder hatF16ToFloatConvOp(ScopedCodeBuilderContext builderContext, HATF16Op.HATF16ToFloatConvOp hatF16ToFloatConvOp) {\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import hat.dialect.HATF16Op;\n+import hat.dialect.HATVectorOp;\n@@ -30,9 +32,0 @@\n-import hat.dialect.HATF16ConvOp;\n-import hat.dialect.HATF16ToFloatConvOp;\n-import hat.dialect.HATVectorBinaryOp;\n-import hat.dialect.HATVectorLoadOp;\n-import hat.dialect.HATVectorOfOp;\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorSelectStoreOp;\n-import hat.dialect.HATVectorStoreView;\n-import hat.dialect.HATVectorVarOp;\n@@ -82,1 +75,1 @@\n-    public OpenCLJExtractedHATKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n+    public OpenCLJExtractedHATKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorStoreView hatVectorStoreView) {\n@@ -111,1 +104,1 @@\n-    public OpenCLJExtractedHATKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n+    public OpenCLJExtractedHATKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -130,1 +123,1 @@\n-    public OpenCLJExtractedHATKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n+    public OpenCLJExtractedHATKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorLoadOp hatVectorLoadOp) {\n@@ -155,1 +148,1 @@\n-    public OpenCLJExtractedHATKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n+    public OpenCLJExtractedHATKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectLoadOp hatVSelectLoadOp) {\n@@ -163,1 +156,1 @@\n-    public OpenCLJExtractedHATKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n+    public OpenCLJExtractedHATKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectStoreOp hatVSelectStoreOp) {\n@@ -179,1 +172,1 @@\n-    public OpenCLJExtractedHATKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n+    public OpenCLJExtractedHATKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ConvOp hatF16ConvOp) {\n@@ -188,1 +181,1 @@\n-    public OpenCLJExtractedHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n+    public OpenCLJExtractedHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarOp hatVectorVarOp) {\n@@ -202,1 +195,1 @@\n-    public OpenCLJExtractedHATKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp) {\n+    public OpenCLJExtractedHATKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOp.HATVectorOfOp hatVectorOfOp) {\n@@ -207,1 +200,1 @@\n-    public OpenCLJExtractedHATKernelBuilder hatF16ToFloatConvOp(ScopedCodeBuilderContext builderContext, HATF16ToFloatConvOp hatF16ToFloatConvOp) {\n+    public OpenCLJExtractedHATKernelBuilder hatF16ToFloatConvOp(ScopedCodeBuilderContext builderContext, HATF16Op.HATF16ToFloatConvOp hatF16ToFloatConvOp) {\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLJExtractedHATKernelBuilder.java","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.phases.HATDTier;\n+import hat.phases.HATTier;\n@@ -86,1 +86,1 @@\n-        HATDTier tier = new HATDTier(this);\n+        HATTier tier = new HATTier(this);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATLocalVarOp barrierOp);\n+    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATLocalVarOp barrierOp);\n@@ -42,1 +42,1 @@\n-    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATPrivateVarOp hatLocalVarOp);\n+    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATPrivateVarOp hatLocalVarOp);\n@@ -44,1 +44,1 @@\n-    T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp hatGlobalThreadIdOp);\n+    T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp hatGlobalThreadIdOp);\n@@ -46,1 +46,1 @@\n-    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATGlobalSizeOp hatGlobalSizeOp);\n+    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp hatGlobalSizeOp);\n@@ -48,1 +48,1 @@\n-    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATLocalThreadIdOp hatLocalThreadIdOp);\n+    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp hatLocalThreadIdOp);\n@@ -50,1 +50,1 @@\n-    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATLocalSizeOp hatLocalSizeOp);\n+    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp);\n@@ -52,1 +52,1 @@\n-    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATBlockThreadIdOp hatBlockThreadIdOp);\n+    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp);\n@@ -54,1 +54,1 @@\n-    T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp);\n+    T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarOp hatVectorVarOp);\n@@ -56,1 +56,1 @@\n-    T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatFloat4StoreOp);\n+    T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorStoreView hatFloat4StoreOp);\n@@ -58,1 +58,1 @@\n-    T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp);\n+    T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp);\n@@ -60,1 +60,1 @@\n-    T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp);\n+    T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorLoadOp hatVectorLoadOp);\n@@ -62,1 +62,1 @@\n-    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp);\n+    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectLoadOp hatVSelectLoadOp);\n@@ -64,1 +64,1 @@\n-    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp);\n+    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectStoreOp hatVSelectStoreOp);\n@@ -66,1 +66,1 @@\n-    T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp);\n+    T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarLoadOp hatVectorVarLoadOp);\n@@ -68,1 +68,1 @@\n-    T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16VarOp hatF16VarOp);\n+    T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarOp hatF16VarOp);\n@@ -70,1 +70,1 @@\n-    T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatF16BinaryOp);\n+    T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatF16BinaryOp);\n@@ -72,1 +72,1 @@\n-    T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16VarLoadOp hatF16VarLoadOp);\n+    T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarLoadOp hatF16VarLoadOp);\n@@ -74,1 +74,1 @@\n-    T hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp);\n+    T hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ConvOp hatF16ConvOp);\n@@ -76,1 +76,1 @@\n-    T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOfOp hatVectorOp);\n+    T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorOfOp hatVectorOp);\n@@ -78,1 +78,1 @@\n-    T hatVectorMakeOf(ScopedCodeBuilderContext buildContext, HATVectorMakeOfOp hatVectorMakeOfOp);\n+    T hatVectorMakeOf(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorMakeOfOp hatVectorMakeOfOp);\n@@ -80,1 +80,1 @@\n-    T hatF16ToFloatConvOp(ScopedCodeBuilderContext buildContext, HATF16ToFloatConvOp hatF16ToFloatConvOp);\n+    T hatF16ToFloatConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ToFloatConvOp hatF16ToFloatConvOp);\n@@ -82,1 +82,1 @@\n-    T hatPrivateVarInitOp(ScopedCodeBuilderContext buildContext, HATPrivateInitVarOp hatPrivateInitVarOp);\n+    T hatPrivateVarInitOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp);\n@@ -84,1 +84,1 @@\n-    T hatMemoryLoadOp(ScopedCodeBuilderContext buildContext, HATMemoryLoadOp hatMemoryLoadOp);\n+    T hatMemoryLoadOp(ScopedCodeBuilderContext buildContext, HATMemoryDefOp.HATMemoryLoadOp hatMemoryLoadOp);\n@@ -86,1 +86,1 @@\n-    T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrLoadOp hatPtrLoadOp);\n+    T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLoadOp hatPtrLoadOp);\n@@ -88,1 +88,1 @@\n-    T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrStoreOp hatPtrStoreOp);\n+    T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrStoreOp hatPtrStoreOp);\n@@ -90,1 +90,1 @@\n-    T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrLengthOp hatPtrLengthOp);\n+    T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLengthOp hatPtrLengthOp);\n@@ -120,26 +120,26 @@\n-            case HATLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n-            case HATPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n-            case HATPrivateInitVarOp $ -> hatPrivateVarInitOp(buildContext, $);\n-            case HATGlobalThreadIdOp $ -> hatGlobalThreadIdOp(buildContext, $);\n-            case HATGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n-            case HATLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n-            case HATLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n-            case HATBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n-            case HATVectorVarOp $ -> hatVectorVarOp(buildContext, $);\n-            case HATVectorStoreView $ -> hatVectorStoreOp(buildContext, $);\n-            case HATVectorBinaryOp $ -> hatBinaryVectorOp(buildContext, $);\n-            case HATVectorLoadOp $ -> hatVectorLoadOp(buildContext, $);\n-            case HATVectorSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n-            case HATVectorSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n-            case HATVectorVarLoadOp $ -> hatVectorVarLoadOp(buildContext, $);\n-            case HATVectorOfOp $ -> hatVectorOfOps(buildContext, $);\n-            case HATF16VarOp $ -> hatF16VarOp(buildContext, $);\n-            case HATF16BinaryOp $ -> hatF16BinaryOp(buildContext, $);\n-            case HATF16VarLoadOp $ -> hatF16VarLoadOp(buildContext, $);\n-            case HATF16ConvOp $ -> hatF16ConvOp(buildContext, $);\n-            case HATVectorMakeOfOp $ -> hatVectorMakeOf(buildContext, $);\n-            case HATPtrLoadOp $ -> hatPtrLoadOp(buildContext, $);\n-            case HATPtrStoreOp $ -> hatPtrStoreOp(buildContext, $);\n-            case HATPtrLengthOp $ -> hatPtrLengthOp(buildContext, $);\n-            case HATF16ToFloatConvOp $ -> hatF16ToFloatConvOp(buildContext, $);\n-            case HATMemoryLoadOp $ -> hatMemoryLoadOp(buildContext, $);\n+            case HATMemoryVarOp.HATLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n+            case HATMemoryVarOp.HATPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n+            case HATMemoryVarOp.HATPrivateInitVarOp $ -> hatPrivateVarInitOp(buildContext, $);\n+            case HATThreadOp.HATGlobalThreadIdOp $ -> hatGlobalThreadIdOp(buildContext, $);\n+            case HATThreadOp.HATGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n+            case HATThreadOp.HATLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n+            case HATThreadOp.HATLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n+            case HATThreadOp.HATBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n+            case HATVectorOp.HATVectorVarOp $ -> hatVectorVarOp(buildContext, $);\n+            case HATVectorOp.HATVectorStoreView $ -> hatVectorStoreOp(buildContext, $);\n+            case HATVectorOp.HATVectorBinaryOp $ -> hatBinaryVectorOp(buildContext, $);\n+            case HATVectorOp.HATVectorLoadOp $ -> hatVectorLoadOp(buildContext, $);\n+            case HATVectorOp.HATVectorSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n+            case HATVectorOp.HATVectorSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n+            case HATVectorOp.HATVectorVarLoadOp $ -> hatVectorVarLoadOp(buildContext, $);\n+            case HATVectorOp.HATVectorOfOp $ -> hatVectorOfOps(buildContext, $);\n+            case HATF16Op.HATF16VarOp $ -> hatF16VarOp(buildContext, $);\n+            case HATF16Op.HATF16BinaryOp $ -> hatF16BinaryOp(buildContext, $);\n+            case HATF16Op.HATF16VarLoadOp $ -> hatF16VarLoadOp(buildContext, $);\n+            case HATF16Op.HATF16ConvOp $ -> hatF16ConvOp(buildContext, $);\n+            case HATVectorOp.HATVectorMakeOfOp $ -> hatVectorMakeOf(buildContext, $);\n+            case HATPtrOp.HATPtrLoadOp $ -> hatPtrLoadOp(buildContext, $);\n+            case HATPtrOp.HATPtrStoreOp $ -> hatPtrStoreOp(buildContext, $);\n+            case HATPtrOp.HATPtrLengthOp $ -> hatPtrLengthOp(buildContext, $);\n+            case HATF16Op.HATF16ToFloatConvOp $ -> hatF16ToFloatConvOp(buildContext, $);\n+            case HATMemoryDefOp.HATMemoryLoadOp $ -> hatMemoryLoadOp(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonKernelOpBuilder.java","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import hat.dialect.HATF16VarOp;\n+import hat.dialect.HATF16Op;\n@@ -28,5 +28,1 @@\n-import hat.dialect.HATVectorBinaryOp;\n-import hat.dialect.HATVectorLoadOp;\n-import hat.dialect.HATVectorStoreView;\n-import hat.dialect.HATVectorVarLoadOp;\n-import hat.dialect.HATVectorVarOp;\n+import hat.dialect.HATVectorOp;\n@@ -44,1 +40,1 @@\n-    public final T varName(HATVectorVarOp hatVectorVarOp) {\n+    public final T varName(HATVectorOp.HATVectorVarOp hatVectorVarOp) {\n@@ -49,1 +45,1 @@\n-    public final T varName(HATVectorLoadOp vectorLoadOp) {\n+    public final T varName(HATVectorOp.HATVectorLoadOp vectorLoadOp) {\n@@ -54,1 +50,1 @@\n-    public final T varName(HATVectorStoreView hatVectorStoreView) {\n+    public final T varName(HATVectorOp.HATVectorStoreView hatVectorStoreView) {\n@@ -59,1 +55,1 @@\n-    public final T varName(HATVectorBinaryOp hatVectorBinaryOp) {\n+    public final T varName(HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -64,1 +60,1 @@\n-    public final T varName(HATVectorVarLoadOp hatVectorVarLoadOp) {\n+    public final T varName(HATVectorOp.HATVectorVarLoadOp hatVectorVarLoadOp) {\n@@ -69,1 +65,1 @@\n-    public final T varName(HATF16VarOp hatF16VarOp) {\n+    public final T varName(HATF16Op.HATF16VarOp hatF16VarOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilder.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.dialect.HATF16Op;\n+import hat.dialect.HATVectorOp;\n@@ -31,2 +33,0 @@\n-import hat.dialect.HATF16VarOp;\n-import hat.dialect.HATLocalVarOp;\n@@ -34,5 +34,0 @@\n-import hat.dialect.HATPrivateInitVarOp;\n-import hat.dialect.HATPrivateVarOp;\n-import hat.dialect.HATVectorBinaryOp;\n-import hat.dialect.HATVectorLoadOp;\n-import hat.dialect.HATVectorVarOp;\n@@ -80,4 +75,4 @@\n-            case HATVectorVarOp $ -> varName($);\n-            case HATVectorLoadOp $ -> varName($);\n-            case HATVectorBinaryOp $ -> varName($);\n-            case HATF16VarOp $ -> varName($);\n+            case HATVectorOp.HATVectorVarOp $ -> varName($);\n+            case HATVectorOp.HATVectorLoadOp $ -> varName($);\n+            case HATVectorOp.HATVectorBinaryOp $ -> varName($);\n+            case HATF16Op.HATF16VarOp $ -> varName($);\n@@ -101,5 +96,5 @@\n-            case HATF16VarOp hatf16VarOp -> varName(hatf16VarOp).equals();\n-            case HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp).equals();\n-            case HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp).equals();\n-            case HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp).equals();\n-            case HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp).equals();\n+            case HATF16Op.HATF16VarOp hatf16VarOp -> varName(hatf16VarOp).equals();\n+            case HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp).equals();\n+            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp).equals();\n+            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp).equals();\n+            case HATVectorOp.HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp).equals();\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-    public T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp globalThreadIdOp) {\n+    public T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp globalThreadIdOp) {\n@@ -153,1 +153,1 @@\n-    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATGlobalSizeOp globalSizeOp) {\n+    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp globalSizeOp) {\n@@ -164,1 +164,1 @@\n-    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATLocalThreadIdOp localThreadIdOp) {\n+    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp localThreadIdOp) {\n@@ -175,1 +175,1 @@\n-    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATLocalSizeOp hatLocalSizeOp) {\n+    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp) {\n@@ -185,1 +185,1 @@\n-    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATBlockThreadIdOp hatBlockThreadIdOp) {\n+    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp) {\n@@ -334,1 +334,1 @@\n-    public final T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATLocalVarOp hatLocalVarOp) {\n+    public final T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATLocalVarOp hatLocalVarOp) {\n@@ -339,1 +339,1 @@\n-    public final T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATPrivateVarOp hatLocalVarOp) {\n+    public final T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATPrivateVarOp hatLocalVarOp) {\n@@ -418,1 +418,1 @@\n-    public T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp) {\n+    public T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarLoadOp hatVectorVarLoadOp) {\n@@ -431,1 +431,1 @@\n-    public T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16VarOp hatF16VarOp) {\n+    public T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarOp hatF16VarOp) {\n@@ -443,1 +443,1 @@\n-        return f32Mixed != 0 && f32Mixed != HATF16BinaryOp.FIRST_OP;\n+        return f32Mixed != 0 && f32Mixed != HATF16Op.HATF16BinaryOp.FIRST_OP;\n@@ -447,1 +447,1 @@\n-        return f32Mixed != 0 && f32Mixed != HATF16BinaryOp.LAST_OP;\n+        return f32Mixed != 0 && f32Mixed != HATF16Op.HATF16BinaryOp.LAST_OP;\n@@ -458,2 +458,2 @@\n-    private T binaryOperationsForBfloat16(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatf16BinaryOp) {\n-        byte f32Mixed = hatf16BinaryOp.getF32();\n+    private T binaryOperationsForBfloat16(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatf16BinaryOp) {\n+        byte f32Mixed = hatf16BinaryOp.getByteFloatRepresentation();\n@@ -506,1 +506,1 @@\n-    public T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatF16BinaryOp) {\n+    public T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatF16BinaryOp) {\n@@ -536,1 +536,1 @@\n-    public T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16VarLoadOp hatF16VarLoadOp) {\n+    public T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarLoadOp hatF16VarLoadOp) {\n@@ -541,1 +541,1 @@\n-    public T hatVectorMakeOf(ScopedCodeBuilderContext builderContext, HATVectorMakeOfOp hatVectorMakeOfOp) {\n+    public T hatVectorMakeOf(ScopedCodeBuilderContext builderContext, HATVectorOp.HATVectorMakeOfOp hatVectorMakeOfOp) {\n@@ -545,1 +545,1 @@\n-    public abstract T genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp);\n+    public abstract T genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOp.HATVectorOfOp hatVectorOfOp);\n@@ -548,1 +548,1 @@\n-    public T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOfOp hatVectorOp) {\n+    public T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorOfOp hatVectorOp) {\n@@ -557,1 +557,1 @@\n-    public T hatPrivateVarInitOp(ScopedCodeBuilderContext builderContext, HATPrivateInitVarOp hatPrivateInitVarOp) {\n+    public T hatPrivateVarInitOp(ScopedCodeBuilderContext builderContext, HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp) {\n@@ -565,1 +565,1 @@\n-    public T hatMemoryLoadOp(ScopedCodeBuilderContext builderContext, HATMemoryLoadOp hatMemoryLoadOp) {\n+    public T hatMemoryLoadOp(ScopedCodeBuilderContext builderContext, HATMemoryDefOp.HATMemoryLoadOp hatMemoryLoadOp) {\n@@ -573,1 +573,1 @@\n-    public T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrLoadOp hatPtrLoadOp) {\n+    public T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLoadOp hatPtrLoadOp) {\n@@ -579,1 +579,1 @@\n-    public T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrStoreOp hatPtrStoreOp) {\n+    public T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrStoreOp hatPtrStoreOp) {\n@@ -585,1 +585,1 @@\n-    public T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrLengthOp hatPtrLengthOp) {\n+    public T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLengthOp hatPtrLengthOp) {\n@@ -601,1 +601,1 @@\n-        if (hatPtrOp instanceof HATPtrLengthOp) {\n+        if (hatPtrOp instanceof HATPtrOp.HATPtrLengthOp) {\n@@ -626,2 +626,2 @@\n-            case HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n-            case HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n+            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n+            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import hat.NDRange;\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import optkl.util.Regex;\n-\n-import java.util.List;\n-\n-public final class HATBlockThreadIdOp extends HATThreadOp {\n-    public HATBlockThreadIdOp(int dimension, TypeElement resultType) {\n-        super(\"BlockThreadId\", resultType,dimension, List.of());\n-    }\n-\n-    public HATBlockThreadIdOp(HATBlockThreadIdOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATBlockThreadIdOp(this, copyContext);\n-    }\n-\n-\n-    public static HATBlockThreadIdOp of(int dimension, TypeElement resultType){\n-        return new HATBlockThreadIdOp(dimension,resultType);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATBlockThreadIdOp.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-\n-public final class HATF16AddOp extends HATF16BinaryOp implements Precedence.Additive {\n-\n-    public HATF16AddOp(TypeElement typeElement, ReducedFloatType reducedFloatType, List<Boolean> references, byte f32, List<Value> operands) {\n-        super(typeElement, reducedFloatType, BinaryOpEnum.ADD, references, f32, operands);\n-    }\n-\n-    public HATF16AddOp(HATF16AddOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATF16AddOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16AddOp.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public abstract sealed class HATF16BinaryOp extends HATF16Op permits HATF16AddOp, HATF16DivOp, HATF16MulOp, HATF16SubOp {\n-\n-    protected final TypeElement elementType;\n-    protected final BinaryOpEnum operationType;\n-    protected final List<Boolean> references;\n-    private final ReducedFloatType reducedFloatType;\n-    protected final byte f32;\n-\n-    public static final byte FIRST_OP = 0x01;\n-    public static final byte LAST_OP = 0x10;\n-\n-    public HATF16BinaryOp(TypeElement typeElement, ReducedFloatType reducedFloatType, BinaryOpEnum operationType, List<Boolean> references, byte f32, List<Value> operands) {\n-        super(\"\", operands);\n-        this.elementType = typeElement;\n-        this.operationType = operationType;\n-        this.references = references;\n-        this.f32 = f32;\n-        this.reducedFloatType = reducedFloatType;\n-    }\n-\n-    public HATF16BinaryOp(HATF16BinaryOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        this.elementType = op.elementType;\n-        this.operationType = op.operationType;\n-        this.references = op.references;\n-        this.f32 = op.f32;\n-        this.reducedFloatType = op.reducedFloatType;\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return this.elementType;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.fp16.\" + varName(), operationType.symbol());\n-    }\n-\n-    public BinaryOpEnum binaryOperationType() {\n-        return operationType;\n-    }\n-\n-    public List<Boolean> references() {\n-        return references;\n-    }\n-\n-    public byte getF32() {\n-        return f32;\n-    }\n-\n-    public ReducedFloatType reducedFloatType() {\n-        return reducedFloatType;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16BinaryOp.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.VarType;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATF16ConvOp extends HATF16Op {\n-\n-    private final TypeElement typeElement;\n-    private final ReducedFloatType reducedFloatType;\n-\n-    public HATF16ConvOp(TypeElement typeElement, ReducedFloatType reducedFloatType, List<Value> operands) {\n-        super(\"\", operands);\n-        this.typeElement = typeElement;\n-        this.reducedFloatType = reducedFloatType;\n-    }\n-\n-    public HATF16ConvOp(HATF16ConvOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        this.typeElement = op.typeElement;\n-        this.reducedFloatType = op.reducedFloatType;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATF16ConvOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.f16Conv\", typeElement);\n-    }\n-\n-    public ReducedFloatType reducedFloatType() {\n-        return reducedFloatType;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16ConvOp.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-\n-public final class HATF16DivOp extends HATF16BinaryOp implements Precedence.Multiplicative {\n-\n-    public HATF16DivOp(TypeElement typeElement, ReducedFloatType reducedFloatType, List<Boolean> references, byte f32, List<Value> operands) {\n-        super(typeElement, reducedFloatType, BinaryOpEnum.DIV, references, f32, operands);\n-    }\n-\n-    public HATF16DivOp(HATF16DivOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATF16DivOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16DivOp.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-\n-public final class HATF16MulOp extends HATF16BinaryOp implements Precedence.Multiplicative {\n-\n-    public HATF16MulOp(TypeElement typeElement, ReducedFloatType reducedFloatType, List<Boolean> references, byte f32, List<Value> operands) {\n-        super(typeElement, reducedFloatType, BinaryOpEnum.MUL, references, f32, operands);\n-    }\n-\n-    public HATF16MulOp(HATF16MulOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATF16MulOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16MulOp.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n@@ -29,0 +32,3 @@\n+import jdk.incubator.code.dialect.core.VarType;\n+import optkl.util.ops.Precedence;\n+import optkl.util.ops.StatementLikeOp;\n@@ -32,0 +38,1 @@\n+import java.util.Map;\n@@ -34,1 +41,2 @@\n-public abstract sealed class  HATF16Op extends HATOp implements VarLikeOp permits HATF16BinaryOp, HATF16ConvOp, HATF16ToFloatConvOp, HATF16VarLoadOp, HATF16VarOp {\n+public abstract sealed class  HATF16Op extends HATOp implements VarLikeOp\n+        permits HATF16Op.HATF16BinaryOp, HATF16Op.HATF16ConvOp, HATF16Op.HATF16ToFloatConvOp, HATF16Op.HATF16VarLoadOp, HATF16Op.HATF16VarOp {\n@@ -56,0 +64,280 @@\n+\n+    public static final class HATF16VarOp extends HATF16Op implements StatementLikeOp {\n+\n+        private final VarType typeElement;\n+        private final ReducedFloatType reducedFloatType;\n+\n+        public HATF16VarOp(String varName, ReducedFloatType reducedFloatType, VarType typeElement, List<Value> operands) {\n+            super(varName, operands);\n+            this.typeElement = typeElement;\n+            this.reducedFloatType = reducedFloatType;\n+        }\n+\n+        public HATF16VarOp(HATF16VarOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            this.typeElement = op.typeElement;\n+            this.reducedFloatType = op.reducedFloatType;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATF16VarOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeElement;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.fp16varop.\" + varName(), typeElement);\n+        }\n+\n+        public ReducedFloatType reducedFloatType() {\n+            return reducedFloatType;\n+        }\n+\n+    }\n+\n+    public static final class HATF16VarLoadOp extends HATF16Op implements Precedence.LoadOrConv {\n+\n+        private final VarType typeElement;\n+\n+        public HATF16VarLoadOp(String varName, VarType typeElement, List<Value> operands) {\n+            super(varName, operands);\n+            this.typeElement = typeElement;\n+        }\n+\n+        public HATF16VarLoadOp(HATF16VarLoadOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            this.typeElement = op.typeElement;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATF16VarLoadOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeElement;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.fp16VarOp.\" + varName(), typeElement);\n+        }\n+\n+    }\n+\n+    public static final class HATF16ToFloatConvOp extends HATF16Op implements Precedence.LoadOrConv {\n+\n+        private final TypeElement typeElement;\n+        private final boolean isLocal;\n+        private final boolean wasFloat;\n+        private final ReducedFloatType reducedFloatType;\n+\n+        public HATF16ToFloatConvOp(TypeElement typeElement, ReducedFloatType reducedFloatType, boolean isLocal, boolean wasFloat, List<Value> operands) {\n+            super(\"\", operands);\n+            this.typeElement = typeElement;\n+            this.isLocal = isLocal;\n+            this.wasFloat = wasFloat;\n+            this.reducedFloatType = reducedFloatType;\n+        }\n+\n+        public HATF16ToFloatConvOp(HATF16ToFloatConvOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            this.typeElement = op.typeElement;\n+            this.isLocal = op.isLocal;\n+            this.wasFloat = op.wasFloat;\n+            this.reducedFloatType = op.reducedFloatType;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATF16ToFloatConvOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeElement;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.f16ToFloat\", typeElement);\n+        }\n+\n+        public boolean isLocal() {\n+            return isLocal;\n+        }\n+\n+        public boolean wasFloat() {\n+            return wasFloat;\n+        }\n+\n+        public ReducedFloatType reducedFloatType() {\n+            return reducedFloatType;\n+        }\n+\n+    }\n+\n+    public static final class HATF16ConvOp extends HATF16Op {\n+\n+        private final TypeElement typeElement;\n+        private final ReducedFloatType reducedFloatType;\n+\n+        public HATF16ConvOp(TypeElement typeElement, ReducedFloatType reducedFloatType, List<Value> operands) {\n+            super(\"\", operands);\n+            this.typeElement = typeElement;\n+            this.reducedFloatType = reducedFloatType;\n+        }\n+\n+        public HATF16ConvOp(HATF16ConvOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            this.typeElement = op.typeElement;\n+            this.reducedFloatType = op.reducedFloatType;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATF16ConvOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeElement;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.f16Conv\", typeElement);\n+        }\n+\n+        public ReducedFloatType reducedFloatType() {\n+            return reducedFloatType;\n+        }\n+\n+    }\n+\n+    public abstract sealed static class HATF16BinaryOp extends HATF16Op\n+            permits HATF16BinaryOp.HATF16AddOp, hat.dialect.HATF16Op.HATF16BinaryOp.HATF16DivOp, hat.dialect.HATF16Op.HATF16BinaryOp.HATF16MulOp, hat.dialect.HATF16Op.HATF16BinaryOp.HATF16SubOp {\n+\n+        protected final TypeElement elementType;\n+        protected final BinaryOpEnum operationType;\n+        protected final List<Boolean> references;\n+        private final ReducedFloatType reducedFloatType;\n+        protected final byte byteFloatRepresentation;\n+\n+        public static final byte FIRST_OP = 0x01;\n+        public static final byte LAST_OP = 0x10;\n+\n+        public HATF16BinaryOp(TypeElement typeElement, ReducedFloatType reducedFloatType, BinaryOpEnum operationType, List<Boolean> references, byte byteFloatRepresentation, List<Value> operands) {\n+            super(\"\", operands);\n+            this.elementType = typeElement;\n+            this.operationType = operationType;\n+            this.references = references;\n+            this.byteFloatRepresentation = byteFloatRepresentation;\n+            this.reducedFloatType = reducedFloatType;\n+        }\n+\n+        public HATF16BinaryOp(HATF16BinaryOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            this.elementType = op.elementType;\n+            this.operationType = op.operationType;\n+            this.references = op.references;\n+            this.byteFloatRepresentation = op.byteFloatRepresentation;\n+            this.reducedFloatType = op.reducedFloatType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.elementType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.fp16.\" + varName(), operationType.symbol());\n+        }\n+\n+        public BinaryOpEnum binaryOperationType() {\n+            return operationType;\n+        }\n+\n+        public List<Boolean> references() {\n+            return references;\n+        }\n+\n+        public byte getByteFloatRepresentation() {\n+            return byteFloatRepresentation;\n+        }\n+\n+        public ReducedFloatType reducedFloatType() {\n+            return reducedFloatType;\n+        }\n+\n+        public static final class HATF16AddOp extends HATF16BinaryOp implements Precedence.Additive {\n+\n+            public HATF16AddOp(TypeElement typeElement, ReducedFloatType reducedFloatType, List<Boolean> references, byte f32, List<Value> operands) {\n+                super(typeElement, reducedFloatType, BinaryOpEnum.ADD, references, f32, operands);\n+            }\n+\n+            public HATF16AddOp(HATF16AddOp op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HATF16AddOp(this, copyContext);\n+            }\n+        }\n+\n+        public static final class HATF16DivOp extends HATF16BinaryOp implements Precedence.Multiplicative {\n+\n+            public HATF16DivOp(TypeElement typeElement, ReducedFloatType reducedFloatType, List<Boolean> references, byte f32, List<Value> operands) {\n+                super(typeElement, reducedFloatType, BinaryOpEnum.DIV, references, f32, operands);\n+            }\n+\n+            public HATF16DivOp(HATF16DivOp op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HATF16DivOp(this, copyContext);\n+            }\n+        }\n+\n+        public static final class HATF16MulOp extends HATF16BinaryOp implements Precedence.Multiplicative {\n+\n+            public HATF16MulOp(TypeElement typeElement, ReducedFloatType reducedFloatType, List<Boolean> references, byte f32, List<Value> operands) {\n+                super(typeElement, reducedFloatType, BinaryOpEnum.MUL, references, f32, operands);\n+            }\n+\n+            public HATF16MulOp(HATF16MulOp op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HATF16MulOp(this, copyContext);\n+            }\n+        }\n+\n+        public static final class HATF16SubOp extends HATF16BinaryOp implements Precedence.Additive {\n+\n+            public HATF16SubOp(TypeElement typeElement, ReducedFloatType reducedFloatType, List<Boolean> references, byte f32, List<Value> operands) {\n+                super(typeElement, reducedFloatType, BinaryOpEnum.SUB, references, f32, operands);\n+            }\n+\n+            public HATF16SubOp(HATF16SubOp op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HATF16SubOp(this, copyContext);\n+            }\n+        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16Op.java","additions":289,"deletions":1,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-\n-public final class HATF16SubOp extends HATF16BinaryOp implements Precedence.Additive {\n-\n-    public HATF16SubOp(TypeElement typeElement, ReducedFloatType reducedFloatType, List<Boolean> references, byte f32, List<Value> operands) {\n-        super(typeElement, reducedFloatType, BinaryOpEnum.SUB, references, f32, operands);\n-    }\n-\n-    public HATF16SubOp(HATF16SubOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATF16SubOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16SubOp.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATF16ToFloatConvOp extends HATF16Op implements Precedence.LoadOrConv {\n-\n-    private final TypeElement typeElement;\n-    private final boolean isLocal;\n-    private final boolean wasFloat;\n-    private final ReducedFloatType reducedFloatType;\n-\n-    public HATF16ToFloatConvOp(TypeElement typeElement, ReducedFloatType reducedFloatType, boolean isLocal, boolean wasFloat, List<Value> operands) {\n-        super(\"\", operands);\n-        this.typeElement = typeElement;\n-        this.isLocal = isLocal;\n-        this.wasFloat = wasFloat;\n-        this.reducedFloatType = reducedFloatType;\n-    }\n-\n-    public HATF16ToFloatConvOp(HATF16ToFloatConvOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        this.typeElement = op.typeElement;\n-        this.isLocal = op.isLocal;\n-        this.wasFloat = op.wasFloat;\n-        this.reducedFloatType = op.reducedFloatType;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATF16ToFloatConvOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.f16ToFloat\", typeElement);\n-    }\n-\n-    public boolean isLocal() {\n-        return isLocal;\n-    }\n-\n-    public boolean wasFloat() {\n-        return wasFloat;\n-    }\n-\n-    public ReducedFloatType reducedFloatType() {\n-        return reducedFloatType;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16ToFloatConvOp.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.VarType;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATF16VarLoadOp extends HATF16Op implements Precedence.LoadOrConv {\n-\n-    private final VarType typeElement;\n-\n-    public HATF16VarLoadOp(String varName, VarType typeElement, List<Value> operands) {\n-        super(varName, operands);\n-        this.typeElement = typeElement;\n-    }\n-\n-    public HATF16VarLoadOp(HATF16VarLoadOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        this.typeElement = op.typeElement;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATF16VarLoadOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.fp16VarOp.\" + varName(), typeElement);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16VarLoadOp.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.VarType;\n-import optkl.util.ops.StatementLikeOp;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATF16VarOp extends HATF16Op implements StatementLikeOp {\n-\n-    private final VarType typeElement;\n-    private final ReducedFloatType reducedFloatType;\n-\n-    public HATF16VarOp(String varName, ReducedFloatType reducedFloatType, VarType typeElement, List<Value> operands) {\n-        super(varName, operands);\n-        this.typeElement = typeElement;\n-        this.reducedFloatType = reducedFloatType;\n-    }\n-\n-    public HATF16VarOp(HATF16VarOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        this.typeElement = op.typeElement;\n-        this.reducedFloatType = op.reducedFloatType;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATF16VarOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.fp16varop.\" + varName(), typeElement);\n-    }\n-\n-    public ReducedFloatType reducedFloatType() {\n-        return reducedFloatType;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16VarOp.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import hat.NDRange;\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import optkl.util.Regex;\n-\n-import java.util.List;\n-\n-public final class HATGlobalSizeOp extends HATThreadOp {\n-    public HATGlobalSizeOp(int dimension, TypeElement resultType) {\n-        super(\"GlobalThreadSize\",resultType,dimension, List.of());\n-    }\n-\n-    public HATGlobalSizeOp(HATGlobalSizeOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATGlobalSizeOp(this, copyContext);\n-    }\n-\n-\n-    static public HATGlobalSizeOp of(int dimension, TypeElement resultType){\n-        return new HATGlobalSizeOp(dimension,resultType);\n-    }\n-}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalSizeOp.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import hat.NDRange;\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import optkl.util.Regex;\n-\n-import java.util.List;\n-\n-public final class HATGlobalThreadIdOp extends HATThreadOp {\n-\n-    public HATGlobalThreadIdOp(int dimension, TypeElement resultType) {\n-        super(\"GlobalThreadId\",resultType,dimension, List.of());\n-    }\n-\n-    public HATGlobalThreadIdOp(HATGlobalThreadIdOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATGlobalThreadIdOp(this, copyContext);\n-    }\n-\n-    public static  HATGlobalThreadIdOp of(int dimension, TypeElement resultType){\n-        return new HATGlobalThreadIdOp(dimension, resultType);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalThreadIdOp.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import hat.NDRange;\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import optkl.util.Regex;\n-\n-import java.util.List;\n-\n-public final class HATLocalSizeOp extends HATThreadOp {\n-\n-    public HATLocalSizeOp(int dimension, TypeElement resultType) {\n-        super(\"GlobalThreadSize\",resultType,dimension, List.of());\n-    }\n-\n-    public HATLocalSizeOp(HATLocalSizeOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATLocalSizeOp(this, copyContext);\n-    }\n-\n-    public static HATThreadOp of(int dimension, TypeElement resultType){\n-        return new HATLocalSizeOp(dimension, resultType);\n-    }\n-}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalSizeOp.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import hat.NDRange;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import optkl.util.Regex;\n-\n-import java.util.List;\n-\n-public final class HATLocalThreadIdOp extends HATThreadOp {\n-\n-    public HATLocalThreadIdOp(int dimension, TypeElement resultType) {\n-        super(\"LocalThreadId\",resultType,dimension, List.of());\n-    }\n-\n-    public HATLocalThreadIdOp(HATLocalThreadIdOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATLocalThreadIdOp(this, copyContext);\n-    }\n-\n-    public static  HATLocalThreadIdOp of(int dimension, TypeElement resultType){\n-        return new HATLocalThreadIdOp(dimension,resultType);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalThreadIdOp.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.java.ClassType;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final  class HATLocalVarOp extends HATMemoryVarOp {\n-\n-    public static final String INTRINSIC_NAME = \"createLocal\";\n-\n-    private final TypeElement typeElement;\n-    private final ClassType klassType;\n-    private final TypeElement invokeResultType;\n-\n-    public HATLocalVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType, List<Value> operands) {\n-        super(varName, operands);\n-        this.typeElement = typeElement;\n-        this.klassType = javaType;\n-        this.invokeResultType = invokeResultType;\n-    }\n-\n-    public HATLocalVarOp(HATLocalVarOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        this.typeElement = op.resultType();\n-        this.klassType = op.klassType;\n-        this.invokeResultType = op.invokeResultType;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATLocalVarOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.hatSharedVarOp.\" + varName(), typeElement);\n-    }\n-\n-    @Override\n-    public ClassType classType() {\n-        return klassType;\n-    }\n-\n-    @Override\n-    public TypeElement invokeType() {\n-        return invokeResultType;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalVarOp.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n@@ -30,1 +32,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n@@ -33,0 +34,1 @@\n+import java.util.Map;\n@@ -34,1 +36,1 @@\n-public abstract sealed class HATMemoryDefOp extends HATOp permits HATMemoryLoadOp {\n+public abstract sealed class HATMemoryDefOp extends HATOp permits HATMemoryDefOp.HATMemoryLoadOp {\n@@ -50,0 +52,40 @@\n+\n+    public static final class HATMemoryLoadOp extends HATMemoryDefOp {\n+\n+        private final TypeElement typeElement;\n+        private final TypeElement invokeResultType;\n+        private final String memberName;\n+\n+        public HATMemoryLoadOp(TypeElement typeElement, TypeElement invokeResultType, String memberName, List<Value> operands) {\n+            super(\"\", operands);\n+            this.typeElement = typeElement;\n+            this.invokeResultType = invokeResultType;\n+            this.memberName = memberName;\n+        }\n+\n+        public HATMemoryLoadOp(HATMemoryLoadOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            this.typeElement = op.resultType();\n+            this.invokeResultType = op.invokeResultType;\n+            this.memberName = op.memberName;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATMemoryLoadOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeElement;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.hatMemoryLoadOp.\" + memberName, typeElement);\n+        }\n+\n+        public String memberName() {\n+            return memberName;\n+        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATMemoryDefOp.java","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATMemoryLoadOp extends HATMemoryDefOp {\n-\n-    private final TypeElement typeElement;\n-    private final TypeElement invokeResultType;\n-    private final String memberName;\n-\n-    public HATMemoryLoadOp(TypeElement typeElement, TypeElement invokeResultType, String memberName, List<Value> operands) {\n-        super(\"\", operands);\n-        this.typeElement = typeElement;\n-        this.invokeResultType = invokeResultType;\n-        this.memberName = memberName;\n-    }\n-\n-    public HATMemoryLoadOp(HATMemoryLoadOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        this.typeElement = op.resultType();\n-        this.invokeResultType = op.invokeResultType;\n-        this.memberName = op.memberName;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATMemoryLoadOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.hatMemoryLoadOp.\" + memberName, typeElement);\n-    }\n-\n-    public String memberName() {\n-        return memberName;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATMemoryLoadOp.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n@@ -35,0 +37,1 @@\n+import java.util.Map;\n@@ -37,1 +40,2 @@\n-public abstract sealed class HATMemoryVarOp extends HATOp implements VarLikeOp, StatementLikeOp permits HATLocalVarOp, HATPrivateVarOp, HATPrivateInitVarOp  {\n+public abstract sealed class HATMemoryVarOp extends HATOp implements VarLikeOp, StatementLikeOp\n+        permits HATMemoryVarOp.HATLocalVarOp, HATMemoryVarOp.HATPrivateVarOp, HATMemoryVarOp.HATPrivateInitVarOp {\n@@ -59,0 +63,148 @@\n+\n+    public static final  class HATLocalVarOp extends HATMemoryVarOp {\n+\n+        public static final String INTRINSIC_NAME = \"createLocal\";\n+\n+        private final TypeElement typeElement;\n+        private final ClassType klassType;\n+        private final TypeElement invokeResultType;\n+\n+        public HATLocalVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType, List<Value> operands) {\n+            super(varName, operands);\n+            this.typeElement = typeElement;\n+            this.klassType = javaType;\n+            this.invokeResultType = invokeResultType;\n+        }\n+\n+        public HATLocalVarOp(HATLocalVarOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            this.typeElement = op.resultType();\n+            this.klassType = op.klassType;\n+            this.invokeResultType = op.invokeResultType;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATLocalVarOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeElement;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.hatSharedVarOp.\" + varName(), typeElement);\n+        }\n+\n+        @Override\n+        public ClassType classType() {\n+            return klassType;\n+        }\n+\n+        @Override\n+        public TypeElement invokeType() {\n+            return invokeResultType;\n+        }\n+    }\n+\n+    public static final class HATPrivateVarOp extends HATMemoryVarOp {\n+\n+        public static final String INTRINSIC_NAME = \"createPrivate\";\n+\n+        private final TypeElement typeElement;\n+        private final ClassType klassType;\n+        private final TypeElement invokeResultType;\n+        private final String varName;\n+\n+        public HATPrivateVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType, List<Value> operands) {\n+            super(varName, operands);\n+            this.varName = varName;\n+            this.typeElement = typeElement;\n+            this.klassType = javaType;\n+            this.invokeResultType = invokeResultType;\n+        }\n+\n+        public HATPrivateVarOp(HATPrivateVarOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            this.varName = op.varName;\n+            this.typeElement = op.resultType();\n+            this.klassType = op.klassType;\n+            this.invokeResultType = op.invokeResultType;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATPrivateVarOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeElement;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.hatPrivateVarOp.\" + varName, typeElement);\n+        }\n+\n+        @Override\n+        public ClassType classType() {\n+            return klassType;\n+        }\n+\n+        @Override\n+        public TypeElement invokeType() {\n+            return invokeResultType;\n+        }\n+    }\n+\n+    public static final class HATPrivateInitVarOp extends HATMemoryVarOp {\n+\n+        private final TypeElement typeElement;\n+        private final ClassType klassType;\n+        private final TypeElement invokeResultType;\n+        private final String varName;\n+\n+        public HATPrivateInitVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType, List<Value> operands) {\n+            super(varName, operands);\n+            this.varName = varName;\n+            this.typeElement = typeElement;\n+            this.klassType = javaType;\n+            this.invokeResultType = invokeResultType;\n+        }\n+\n+        public HATPrivateInitVarOp(HATPrivateInitVarOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            this.varName = op.varName;\n+            this.typeElement = op.resultType();\n+            this.klassType = op.klassType;\n+            this.invokeResultType = op.invokeResultType;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATPrivateInitVarOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeElement;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.hatPrivateVarInitOp.\" + varName, typeElement);\n+        }\n+\n+        @Override\n+        public ClassType classType() {\n+            return klassType;\n+        }\n+\n+        @Override\n+        public TypeElement invokeType() {\n+            return invokeResultType;\n+        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATMemoryVarOp.java","additions":153,"deletions":1,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -42,14 +42,0 @@\n-    public static TypeElement getVectorElementType(String primitive) {\n-        return switch (primitive) {\n-            case \"float\" -> JavaType.FLOAT;\n-            case \"double\" -> JavaType.DOUBLE;\n-            case \"int\" -> JavaType.INT;\n-            case \"long\" -> JavaType.LONG;\n-            case \"short\" -> JavaType.SHORT;\n-            case \"byte\" -> JavaType.BYTE;\n-            case \"char\" -> JavaType.CHAR;\n-            case \"boolean\" -> JavaType.BOOLEAN;\n-            default -> null;\n-        };\n-    }\n-\n@@ -70,6 +56,12 @@\n-\n-    private static CoreOp.FuncOp buildCodeModelFor(Class<?> klass, String methodName) {\n-        Optional<Method> methodFunction = Stream.of(klass.getMethods())\n-                .filter(m -> m.getName().equals(methodName))\n-                .findFirst();\n-        return Op.ofMethod(methodFunction.get()).get();\n+    public static TypeElement getVectorElementType(String primitive) {\n+        return switch (primitive) {\n+            case \"float\" -> JavaType.FLOAT;\n+            case \"double\" -> JavaType.DOUBLE;\n+            case \"int\" -> JavaType.INT;\n+            case \"long\" -> JavaType.LONG;\n+            case \"short\" -> JavaType.SHORT;\n+            case \"byte\" -> JavaType.BYTE;\n+            case \"char\" -> JavaType.CHAR;\n+            case \"boolean\" -> JavaType.BOOLEAN;\n+            default -> null;\n+        };\n@@ -121,15 +113,0 @@\n-    public static int getWitdh(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return getWitdh(varLoadOp.operands().getFirst());\n-    }\n-\n-    public static int getWitdh(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return getWitdh(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.vectorN();\n-            }\n-            return -1;\n-        }\n-    }\n@@ -137,46 +114,5 @@\n-    public static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findVectorTypeElement(varLoadOp.operands().getFirst());\n-    }\n-\n-    public static TypeElement findVectorTypeElement(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findVectorTypeElement(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.vectorElementType();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().getFirst());\n-    }\n-\n-    public static String findNameVector(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findNameVector(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.varName();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static boolean findF16IsLocal(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findF16IsLocal(varLoadOp.operands().getFirst());\n-    }\n-\n-    public static boolean findF16IsLocal(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findF16IsLocal(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATF16VarOp hatf16VarOp) {\n-                return true;\n-            }\n-            return false;\n-        }\n+    private static CoreOp.FuncOp buildCodeModelFor(Class<?> klass, String methodName) {\n+        Optional<Method> methodFunction = Stream.of(klass.getMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+        return Op.ofMethod(methodFunction.get()).get();\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPhaseUtils.java","additions":17,"deletions":81,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.java.ClassType;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATPrivateInitVarOp extends HATMemoryVarOp {\n-\n-    private final TypeElement typeElement;\n-    private final ClassType klassType;\n-    private final TypeElement invokeResultType;\n-    private final String varName;\n-\n-    public HATPrivateInitVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType, List<Value> operands) {\n-        super(varName, operands);\n-        this.varName = varName;\n-        this.typeElement = typeElement;\n-        this.klassType = javaType;\n-        this.invokeResultType = invokeResultType;\n-    }\n-\n-    public HATPrivateInitVarOp(HATPrivateInitVarOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        this.varName = op.varName;\n-        this.typeElement = op.resultType();\n-        this.klassType = op.klassType;\n-        this.invokeResultType = op.invokeResultType;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATPrivateInitVarOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.hatPrivateVarInitOp.\" + varName, typeElement);\n-    }\n-\n-    @Override\n-    public ClassType classType() {\n-        return klassType;\n-    }\n-\n-    @Override\n-    public TypeElement invokeType() {\n-        return invokeResultType;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPrivateInitVarOp.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.java.ClassType;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATPrivateVarOp extends HATMemoryVarOp {\n-\n-    public static final String INTRINSIC_NAME = \"createPrivate\";\n-\n-    private final TypeElement typeElement;\n-    private final ClassType klassType;\n-    private final TypeElement invokeResultType;\n-    private final String varName;\n-\n-    public HATPrivateVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType, List<Value> operands) {\n-        super(varName, operands);\n-        this.varName = varName;\n-        this.typeElement = typeElement;\n-        this.klassType = javaType;\n-        this.invokeResultType = invokeResultType;\n-    }\n-\n-    public HATPrivateVarOp(HATPrivateVarOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        this.varName = op.varName;\n-        this.typeElement = op.resultType();\n-        this.klassType = op.klassType;\n-        this.invokeResultType = op.invokeResultType;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATPrivateVarOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.hatPrivateVarOp.\" + varName, typeElement);\n-    }\n-\n-    @Override\n-    public ClassType classType() {\n-        return klassType;\n-    }\n-\n-    @Override\n-    public TypeElement invokeType() {\n-        return invokeResultType;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPrivateVarOp.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.*;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATPtrLengthOp extends HATPtrOp implements Precedence.LoadOrConv {\n-\n-    private static final String NAME = \"HATPtrLengthOp\";\n-\n-    public HATPtrLengthOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n-        super(resultType, bufferClass, operands);\n-    }\n-\n-    public HATPtrLengthOp(HATPtrLengthOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATPtrLengthOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.\" + NAME, this.resultType());\n-    }\n-}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrLengthOp.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.*;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATPtrLoadOp extends HATPtrOp implements Precedence.LoadOrConv {\n-\n-    private static final String NAME = \"HATPtrLoadOp\";\n-\n-    public HATPtrLoadOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n-        super(resultType, bufferClass, operands);\n-    }\n-\n-    public HATPtrLoadOp(HATPtrLoadOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATPtrLoadOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.\" + NAME, this.resultType());\n-    }\n-}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrLoadOp.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.device.DeviceSchema;\n@@ -30,0 +29,1 @@\n+import optkl.util.ops.Precedence;\n@@ -35,1 +35,2 @@\n-public abstract sealed class HATPtrOp extends HATOp permits HATPtrLengthOp, HATPtrLoadOp, HATPtrStoreOp {\n+public abstract sealed class HATPtrOp extends HATOp\n+        permits HATPtrOp.HATPtrLengthOp, HATPtrOp.HATPtrLoadOp, HATPtrOp.HATPtrStoreOp {\n@@ -90,0 +91,69 @@\n+    public static final class HATPtrStoreOp extends HATPtrOp implements Precedence.Store {\n+\n+        private static final String NAME = \"HATPtrStoreOp\";\n+\n+        public HATPtrStoreOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n+            super(resultType, bufferClass, operands);\n+        }\n+\n+        public HATPtrStoreOp(HATPtrStoreOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATPtrStoreOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.\" + NAME, this.resultType());\n+        }\n+\n+    }\n+\n+    public static final class HATPtrLoadOp extends HATPtrOp implements Precedence.LoadOrConv {\n+\n+        private static final String NAME = \"HATPtrLoadOp\";\n+\n+        public HATPtrLoadOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n+            super(resultType, bufferClass, operands);\n+        }\n+\n+        public HATPtrLoadOp(HATPtrLoadOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATPtrLoadOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.\" + NAME, this.resultType());\n+        }\n+    }\n+\n+    public static final class HATPtrLengthOp extends HATPtrOp implements Precedence.LoadOrConv {\n+\n+        private static final String NAME = \"HATPtrLengthOp\";\n+\n+        public HATPtrLengthOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n+            super(resultType, bufferClass, operands);\n+        }\n+\n+        public HATPtrLengthOp(HATPtrLengthOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATPtrLengthOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.\" + NAME, this.resultType());\n+        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrOp.java","additions":72,"deletions":2,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.*;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATPtrStoreOp extends HATPtrOp implements Precedence.Store {\n-\n-    private static final String NAME = \"HATPtrStoreOp\";\n-\n-    public HATPtrStoreOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n-        super(resultType, bufferClass, operands);\n-    }\n-\n-    public HATPtrStoreOp(HATPtrStoreOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATPtrStoreOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.\" + NAME, this.resultType());\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrStoreOp.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n@@ -35,1 +37,2 @@\n-public abstract sealed class HATThreadOp extends HATOp implements Precedence.LoadOrConv permits HATBlockThreadIdOp, HATGlobalSizeOp, HATGlobalThreadIdOp, HATLocalSizeOp, HATLocalThreadIdOp  {\n+public abstract sealed class HATThreadOp extends HATOp implements Precedence.LoadOrConv\n+        permits HATThreadOp.HATBlockThreadIdOp, HATThreadOp.HATGlobalSizeOp, HATThreadOp.HATGlobalThreadIdOp, HATThreadOp.HATLocalSizeOp, HATThreadOp.HATLocalThreadIdOp {\n@@ -69,0 +72,99 @@\n+    public static final class HATLocalThreadIdOp extends HATThreadOp {\n+\n+        public HATLocalThreadIdOp(int dimension, TypeElement resultType) {\n+            super(\"LocalThreadId\",resultType,dimension, List.of());\n+        }\n+\n+        public HATLocalThreadIdOp(HATLocalThreadIdOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATLocalThreadIdOp(this, copyContext);\n+        }\n+\n+        public static HATLocalThreadIdOp of(int dimension, TypeElement resultType){\n+            return new HATLocalThreadIdOp(dimension,resultType);\n+        }\n+    }\n+\n+    public static final class HATBlockThreadIdOp extends HATThreadOp {\n+        public HATBlockThreadIdOp(int dimension, TypeElement resultType) {\n+            super(\"BlockThreadId\", resultType,dimension, List.of());\n+        }\n+\n+        public HATBlockThreadIdOp(HATBlockThreadIdOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATBlockThreadIdOp(this, copyContext);\n+        }\n+\n+\n+        public static HATBlockThreadIdOp of(int dimension, TypeElement resultType){\n+            return new HATBlockThreadIdOp(dimension,resultType);\n+        }\n+    }\n+\n+    public static final class HATLocalSizeOp extends HATThreadOp {\n+\n+        public HATLocalSizeOp(int dimension, TypeElement resultType) {\n+            super(\"GlobalThreadSize\",resultType,dimension, List.of());\n+        }\n+\n+        public HATLocalSizeOp(HATLocalSizeOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATLocalSizeOp(this, copyContext);\n+        }\n+\n+        public static HATThreadOp of(int dimension, TypeElement resultType){\n+            return new HATLocalSizeOp(dimension, resultType);\n+        }\n+    }\n+\n+    public static final class HATGlobalThreadIdOp extends HATThreadOp {\n+\n+        public HATGlobalThreadIdOp(int dimension, TypeElement resultType) {\n+            super(\"GlobalThreadId\",resultType,dimension, List.of());\n+        }\n+\n+        public HATGlobalThreadIdOp(HATGlobalThreadIdOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATGlobalThreadIdOp(this, copyContext);\n+        }\n+\n+        public static HATGlobalThreadIdOp of(int dimension, TypeElement resultType){\n+            return new HATGlobalThreadIdOp(dimension, resultType);\n+        }\n+    }\n+\n+    public static final class HATGlobalSizeOp extends HATThreadOp {\n+        public HATGlobalSizeOp(int dimension, TypeElement resultType) {\n+            super(\"GlobalThreadSize\",resultType,dimension, List.of());\n+        }\n+\n+        public HATGlobalSizeOp(HATGlobalSizeOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATGlobalSizeOp(this, copyContext);\n+        }\n+\n+\n+        static public HATGlobalSizeOp of(int dimension, TypeElement resultType){\n+            return new HATGlobalSizeOp(dimension,resultType);\n+        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATThreadOp.java","additions":103,"deletions":1,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-\n-public final class HATVectorAddOp extends HATVectorBinaryOp implements Precedence.Additive {\n-\n-    public HATVectorAddOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n-        super(varName, typeElement, BinaryOpEnum.ADD, vectorElementType, width, operands);\n-    }\n-\n-    public HATVectorAddOp(HATVectorAddOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorAddOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorAddOp.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-\n-public abstract sealed class HATVectorBinaryOp extends HATVectorOp permits HATVectorAddOp, HATVectorDivOp, HATVectorMulOp, HATVectorSubOp {\n-   \/\/ private final TypeElement elementType;\n-    private final BinaryOpEnum operationType;\n-\n-    public HATVectorBinaryOp(String varName, TypeElement resultType, BinaryOpEnum operationType, TypeElement vectorElementType, int width, List<Value> operands) {\n-        super(varName, resultType, vectorElementType, width, operands);\n-        \/\/this.elementType = typeElement;\n-        this.operationType = operationType;\n-\n-    }\n-\n-    public HATVectorBinaryOp(HATVectorBinaryOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-       \/\/ this.elementType = op.elementType;\n-        this.operationType = op.operationType;\n-    }\n-\n-  \/\/  @Override\n-    \/\/public TypeElement resultType() {\n-      \/\/  return this.elementType;\n-   \/\/ }\n-\n-    public BinaryOpEnum operationType() {\n-        return operationType;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorBinaryOp.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-\n-public final class HATVectorDivOp extends HATVectorBinaryOp implements Precedence.Multiplicative {\n-\n-    public HATVectorDivOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n-        super(varName, typeElement, BinaryOpEnum.DIV, vectorElementType, width, operands);\n-    }\n-\n-    public HATVectorDivOp(HATVectorDivOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorDivOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorDivOp.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATVectorLoadOp extends HATVectorOp implements Precedence.LoadOrConv {\n-    private final int loadN;\n-    private final boolean isSharedOrPrivate;\n-\n-    public HATVectorLoadOp(String varName, TypeElement typeElement, TypeElement vectorType, int loadN, boolean isShared, List<Value> operands) {\n-        super(varName, typeElement, vectorType, loadN, operands);\n-        \/\/this.typeElement = typeElement;\n-        this.loadN = loadN;\n-       \/\/ this.vectorType = vectorType;\n-        this.isSharedOrPrivate = isShared;\n-    }\n-\n-    public HATVectorLoadOp(HATVectorLoadOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        \/\/this.typeElement = op.typeElement;\n-        this.loadN = op.loadN;\n-       \/\/ this.vectorType = op.vectorType;\n-        this.isSharedOrPrivate = op.isSharedOrPrivate;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorLoadOp(this, copyContext);\n-    }\n-\n-   \/\/ @Override\n-  \/\/  public TypeElement resultType() {\n-    \/\/    return typeElement;\n-   \/\/ }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.vectorLoadView.\" + varName(), resultType());\n-    }\n-\n-    public boolean isSharedOrPrivate() {\n-        return this.isSharedOrPrivate;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorLoadOp.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATVectorMakeOfOp extends HATVectorOp {\n-\n-  \/\/  private final TypeElement typeElement;\n-    private final int loadN;\n-\n-    public HATVectorMakeOfOp(String varName, TypeElement resultType, int loadN, List<Value> operands) {\n-        super(varName, resultType, resultType, loadN, operands);\n-    \/\/    this.typeElement = typeElement;\n-        this.loadN = loadN;\n-    }\n-\n-    public HATVectorMakeOfOp(HATVectorMakeOfOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-      \/\/  this.typeElement = op.typeElement;\n-        this.loadN = op.loadN;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorMakeOfOp(this, copyContext);\n-    }\n-\n-   \/\/ @Override\n-   \/\/ public TypeElement resultType() {\n-     \/\/   return typeElement;\n-   \/\/ }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.makeOf.\" + varName(), resultType());\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorMakeOfOp.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-\n-public final class HATVectorMulOp extends HATVectorBinaryOp implements Precedence.Multiplicative {\n-\n-    public HATVectorMulOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n-        super(varName, typeElement, BinaryOpEnum.MUL, vectorElementType, width, operands);\n-    }\n-\n-    public HATVectorMulOp(HATVectorMulOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorMulOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorMulOp.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATVectorOfOp extends HATVectorOp {\n-\n-   \/\/ private final TypeElement typeElement;\n-    private final int loadN;\n-\n-    public HATVectorOfOp(TypeElement resultType, TypeElement vectorTypeElement, int loadN, List<Value> operands) {\n-        super(\"\", resultType, vectorTypeElement, loadN, operands);\n-       \/\/ this.typeElement = typeElement;\n-        this.loadN = loadN;\n-    }\n-\n-    public HATVectorOfOp(HATVectorOfOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-       \/\/ this.typeElement = op.typeElement;\n-        this.loadN = op.loadN;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorOfOp(this, copyContext);\n-    }\n-\n-   \/\/ @Override\n-   \/\/ public TypeElement resultType() {\n-     \/\/   return typeElement;\n-   \/\/ }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.vectorOf.\" + varName(), resultType());\n-    }\n-\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorOfOp.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n@@ -30,0 +32,4 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.VarType;\n+import optkl.util.ops.Precedence;\n+import optkl.util.ops.StatementLikeOp;\n@@ -33,0 +39,1 @@\n+import java.util.Map;\n@@ -35,1 +42,2 @@\n-public abstract sealed class HATVectorOp extends HATOp implements VarLikeOp permits HATVectorBinaryOp, HATVectorLoadOp, HATVectorMakeOfOp, HATVectorOfOp, HATVectorSelectLoadOp, HATVectorSelectStoreOp, HATVectorStoreView, HATVectorVarLoadOp, HATVectorVarOp {\n+public abstract sealed class HATVectorOp extends HATOp implements VarLikeOp\n+        permits HATVectorOp.HATVectorBinaryOp, HATVectorOp.HATVectorLoadOp, HATVectorOp.HATVectorMakeOfOp, HATVectorOp.HATVectorOfOp, HATVectorOp.HATVectorSelectLoadOp, HATVectorOp.HATVectorSelectStoreOp, HATVectorOp.HATVectorStoreView, HATVectorOp.HATVectorVarLoadOp, HATVectorOp.HATVectorVarOp {\n@@ -88,0 +96,354 @@\n+\n+    public abstract sealed static class HATVectorBinaryOp extends HATVectorOp\n+            permits HATVectorBinaryOp.HATVectorAddOp, hat.dialect.HATVectorOp.HATVectorBinaryOp.HATVectorDivOp, hat.dialect.HATVectorOp.HATVectorBinaryOp.HATVectorMulOp, hat.dialect.HATVectorOp.HATVectorBinaryOp.HATVectorSubOp {\n+\n+        private final BinaryOpEnum operationType;\n+\n+        public HATVectorBinaryOp(String varName, TypeElement resultType, BinaryOpEnum operationType, TypeElement vectorElementType, int width, List<Value> operands) {\n+            super(varName, resultType, vectorElementType, width, operands);\n+            \/\/this.elementType = typeElement;\n+            this.operationType = operationType;\n+\n+        }\n+\n+        public HATVectorBinaryOp(HATVectorBinaryOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+           \/\/ this.elementType = op.elementType;\n+            this.operationType = op.operationType;\n+        }\n+\n+      \/\/  @Override\n+        \/\/public TypeElement resultType() {\n+          \/\/  return this.elementType;\n+       \/\/ }\n+\n+        public BinaryOpEnum operationType() {\n+            return operationType;\n+        }\n+\n+        public static final class HATVectorAddOp extends HATVectorBinaryOp implements Precedence.Additive {\n+\n+            public HATVectorAddOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n+                super(varName, typeElement, BinaryOpEnum.ADD, vectorElementType, width, operands);\n+            }\n+\n+            public HATVectorAddOp(HATVectorAddOp op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HATVectorAddOp(this, copyContext);\n+            }\n+        }\n+\n+        public static final class HATVectorDivOp extends HATVectorBinaryOp implements Precedence.Multiplicative {\n+\n+            public HATVectorDivOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n+                super(varName, typeElement, BinaryOpEnum.DIV, vectorElementType, width, operands);\n+            }\n+\n+            public HATVectorDivOp(HATVectorDivOp op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HATVectorDivOp(this, copyContext);\n+            }\n+        }\n+\n+        public static final class HATVectorMulOp extends HATVectorBinaryOp implements Precedence.Multiplicative {\n+\n+            public HATVectorMulOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n+                super(varName, typeElement, BinaryOpEnum.MUL, vectorElementType, width, operands);\n+            }\n+\n+            public HATVectorMulOp(HATVectorMulOp op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HATVectorMulOp(this, copyContext);\n+            }\n+        }\n+\n+        public static final class HATVectorSubOp extends HATVectorBinaryOp implements Precedence.Additive {\n+\n+            public HATVectorSubOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n+                super(varName, typeElement, BinaryOpEnum.SUB, vectorElementType, width, operands);\n+            }\n+\n+            public HATVectorSubOp(HATVectorSubOp op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HATVectorSubOp(this, copyContext);\n+            }\n+        }\n+    }\n+\n+    public static final class HATVectorLoadOp extends HATVectorOp implements Precedence.LoadOrConv {\n+        private final int loadN;\n+        private final boolean isSharedOrPrivate;\n+\n+        public HATVectorLoadOp(String varName, TypeElement typeElement, TypeElement vectorType, int loadN, boolean isShared, List<Value> operands) {\n+            super(varName, typeElement, vectorType, loadN, operands);\n+            \/\/this.typeElement = typeElement;\n+            this.loadN = loadN;\n+           \/\/ this.vectorType = vectorType;\n+            this.isSharedOrPrivate = isShared;\n+        }\n+\n+        public HATVectorLoadOp(HATVectorLoadOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            \/\/this.typeElement = op.typeElement;\n+            this.loadN = op.loadN;\n+           \/\/ this.vectorType = op.vectorType;\n+            this.isSharedOrPrivate = op.isSharedOrPrivate;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATVectorLoadOp(this, copyContext);\n+        }\n+\n+       \/\/ @Override\n+      \/\/  public TypeElement resultType() {\n+        \/\/    return typeElement;\n+       \/\/ }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.vectorLoadView.\" + varName(), resultType());\n+        }\n+\n+        public boolean isSharedOrPrivate() {\n+            return this.isSharedOrPrivate;\n+        }\n+    }\n+\n+    public static final class HATVectorOfOp extends HATVectorOp {\n+\n+       \/\/ private final TypeElement typeElement;\n+        private final int loadN;\n+\n+        public HATVectorOfOp(TypeElement resultType, TypeElement vectorTypeElement, int loadN, List<Value> operands) {\n+            super(\"\", resultType, vectorTypeElement, loadN, operands);\n+           \/\/ this.typeElement = typeElement;\n+            this.loadN = loadN;\n+        }\n+\n+        public HATVectorOfOp(HATVectorOfOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+           \/\/ this.typeElement = op.typeElement;\n+            this.loadN = op.loadN;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATVectorOfOp(this, copyContext);\n+        }\n+\n+       \/\/ @Override\n+       \/\/ public TypeElement resultType() {\n+         \/\/   return typeElement;\n+       \/\/ }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.vectorOf.\" + varName(), resultType());\n+        }\n+\n+\n+    }\n+\n+    public static final class HATVectorMakeOfOp extends HATVectorOp {\n+\n+      \/\/  private final TypeElement typeElement;\n+        private final int loadN;\n+\n+        public HATVectorMakeOfOp(String varName, TypeElement resultType, int loadN, List<Value> operands) {\n+            super(varName, resultType, resultType, loadN, operands);\n+        \/\/    this.typeElement = typeElement;\n+            this.loadN = loadN;\n+        }\n+\n+        public HATVectorMakeOfOp(HATVectorMakeOfOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+          \/\/  this.typeElement = op.typeElement;\n+            this.loadN = op.loadN;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATVectorMakeOfOp(this, copyContext);\n+        }\n+\n+       \/\/ @Override\n+       \/\/ public TypeElement resultType() {\n+         \/\/   return typeElement;\n+       \/\/ }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.makeOf.\" + varName(), resultType());\n+        }\n+\n+    }\n+\n+    public static final class HATVectorSelectLoadOp extends HATVectorOp implements Precedence.LoadOrConv {\n+\n+        private final int lane;\n+\n+        public HATVectorSelectLoadOp(String varName, TypeElement resultType, int lane, List<Value> operands) {\n+            super(varName, resultType, resultType, -1, operands);\n+            this.lane = lane;\n+        }\n+\n+        public HATVectorSelectLoadOp(HATVectorSelectLoadOp that, CodeContext cc) {\n+            super(that, cc);\n+            this.lane = that.lane;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATVectorSelectLoadOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.vselect.\" + lane, resultType());\n+        }\n+\n+        public String mapLane() {\n+            return super.mapLane(lane);\n+        }\n+\n+    }\n+\n+    public static final class HATVectorSelectStoreOp extends HATVectorOp {\n+\n+      \/\/  private final TypeElement elementType;\n+        private final int lane;\n+        private final CoreOp.VarOp resultVarOp;\n+\n+        public HATVectorSelectStoreOp(String varName, TypeElement resultType, int lane, CoreOp.VarOp resultVarOp, List<Value> operands) {\n+            super(varName, resultType, resultType, -1, operands);\n+          \/\/  this.elementType = typeElement;\n+            this.lane = lane;\n+            this.resultVarOp = resultVarOp;\n+        }\n+\n+        public HATVectorSelectStoreOp(HATVectorSelectStoreOp that, CodeContext cc) {\n+            super(that, cc);\n+         \/\/   this.elementType = that.elementType;\n+            this.lane = that.lane;\n+            this.resultVarOp = that.resultVarOp;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATVectorSelectStoreOp(this, copyContext);\n+        }\n+\n+      \/\/  @Override\n+        \/\/public TypeElement resultType() {\n+          \/\/  return elementType;\n+       \/\/ }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.vselect.store.\" + lane, resultType());\n+        }\n+\n+        public String mapLane() {\n+            return super.mapLane(lane);\n+        }\n+\n+        public CoreOp.VarOp resultValue() {\n+            return resultVarOp;\n+        }\n+\n+    }\n+\n+    public static final class HATVectorStoreView extends HATVectorOp {\n+\n+        private final boolean isSharedOrPrivate;\n+\n+        public HATVectorStoreView(String varName, TypeElement resultType, int storeN, TypeElement vectorElementType, boolean isSharedOrPrivate, List<Value> operands) {\n+            super(varName, resultType, vectorElementType, storeN, operands);\n+            this.isSharedOrPrivate = isSharedOrPrivate;\n+        }\n+\n+        public HATVectorStoreView(HATVectorStoreView op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            this.isSharedOrPrivate = op.isSharedOrPrivate;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATVectorStoreView(this, copyContext);\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.\" + vectorElementType().toString() + vectorN() + \"StoreView.\" + varName(), resultType());\n+        }\n+\n+        public boolean isSharedOrPrivate() {\n+            return this.isSharedOrPrivate;\n+        }\n+\n+    }\n+\n+    public static final class HATVectorVarLoadOp extends HATVectorOp {\n+\n+        public HATVectorVarLoadOp(String varName, TypeElement resultType, TypeElement vectorElementType, int width, List<Value> operands) {\n+            super(varName, resultType, vectorElementType, width, operands);\n+        }\n+\n+        public HATVectorVarLoadOp(HATVectorVarLoadOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATVectorVarLoadOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.vectorVarLoadOp.\" + varName(), resultType());\n+        }\n+\n+    }\n+\n+    public static final class HATVectorVarOp extends HATVectorOp implements StatementLikeOp {\n+\n+        private final int loadN;\n+\n+        public HATVectorVarOp(String varName, VarType resultType, TypeElement vectorElementType, int loadN, List<Value> operands) {\n+            super(varName, resultType, vectorElementType, loadN, operands);\n+            this.loadN = loadN;\n+        }\n+\n+        public HATVectorVarOp(HATVectorVarOp op, CodeContext copyContext) {\n+            super(op, copyContext);\n+            this.loadN = op.loadN;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new HATVectorVarOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"hat.dialect.vectorVarOp.\" + varName(), resultType());\n+        }\n+\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorOp.java","additions":363,"deletions":1,"binary":false,"changes":364,"status":"modified"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATVectorSelectLoadOp extends HATVectorOp implements Precedence.LoadOrConv {\n-\n-    private final int lane;\n-\n-    public HATVectorSelectLoadOp(String varName, TypeElement resultType, int lane, List<Value> operands) {\n-        super(varName, resultType, resultType, -1, operands);\n-        this.lane = lane;\n-    }\n-\n-    public HATVectorSelectLoadOp(HATVectorSelectLoadOp that, CodeContext cc) {\n-        super(that, cc);\n-        this.lane = that.lane;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorSelectLoadOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.vselect.\" + lane, resultType());\n-    }\n-\n-    public String mapLane() {\n-        return super.mapLane(lane);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSelectLoadOp.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATVectorSelectStoreOp extends HATVectorOp {\n-\n-  \/\/  private final TypeElement elementType;\n-    private final int lane;\n-    private final CoreOp.VarOp resultVarOp;\n-\n-    public HATVectorSelectStoreOp(String varName, TypeElement resultType, int lane, CoreOp.VarOp resultVarOp, List<Value> operands) {\n-        super(varName, resultType, resultType, -1, operands);\n-      \/\/  this.elementType = typeElement;\n-        this.lane = lane;\n-        this.resultVarOp = resultVarOp;\n-    }\n-\n-    public HATVectorSelectStoreOp(HATVectorSelectStoreOp that, CodeContext cc) {\n-        super(that, cc);\n-     \/\/   this.elementType = that.elementType;\n-        this.lane = that.lane;\n-        this.resultVarOp = that.resultVarOp;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorSelectStoreOp(this, copyContext);\n-    }\n-\n-  \/\/  @Override\n-    \/\/public TypeElement resultType() {\n-      \/\/  return elementType;\n-   \/\/ }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.vselect.store.\" + lane, resultType());\n-    }\n-\n-    public String mapLane() {\n-        return super.mapLane(lane);\n-    }\n-\n-    public CoreOp.VarOp resultValue() {\n-        return resultVarOp;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSelectStoreOp.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATVectorStoreView extends HATVectorOp {\n-\n-    private final boolean isSharedOrPrivate;\n-\n-    public HATVectorStoreView(String varName, TypeElement resultType, int storeN, TypeElement vectorElementType, boolean isSharedOrPrivate, List<Value> operands) {\n-        super(varName, resultType, vectorElementType, storeN, operands);\n-        this.isSharedOrPrivate = isSharedOrPrivate;\n-    }\n-\n-    public HATVectorStoreView(HATVectorStoreView op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        this.isSharedOrPrivate = op.isSharedOrPrivate;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorStoreView(this, copyContext);\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.\" + vectorElementType().toString() + vectorN() + \"StoreView.\" + varName(), resultType());\n-    }\n-\n-    public boolean isSharedOrPrivate() {\n-        return this.isSharedOrPrivate;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorStoreView.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import optkl.util.ops.Precedence;\n-\n-import java.util.List;\n-\n-public final class HATVectorSubOp extends HATVectorBinaryOp implements Precedence.Additive {\n-\n-    public HATVectorSubOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int width, List<Value> operands) {\n-        super(varName, typeElement, BinaryOpEnum.SUB, vectorElementType, width, operands);\n-    }\n-\n-    public HATVectorSubOp(HATVectorSubOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorSubOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSubOp.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATVectorVarLoadOp extends HATVectorOp {\n-\n-    public HATVectorVarLoadOp(String varName, TypeElement resultType, TypeElement vectorElementType, int width, List<Value> operands) {\n-        super(varName, resultType, vectorElementType, width, operands);\n-    }\n-\n-    public HATVectorVarLoadOp(HATVectorVarLoadOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorVarLoadOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.vectorVarLoadOp.\" + varName(), resultType());\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorVarLoadOp.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.VarType;\n-import optkl.util.ops.StatementLikeOp;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class HATVectorVarOp extends HATVectorOp implements StatementLikeOp {\n-\n-    private final int loadN;\n-\n-    public HATVectorVarOp(String varName, VarType resultType, TypeElement vectorElementType, int loadN, List<Value> operands) {\n-        super(varName, resultType, vectorElementType, loadN, operands);\n-        this.loadN = loadN;\n-    }\n-\n-    public HATVectorVarOp(HATVectorVarOp op, CodeContext copyContext) {\n-        super(op, copyContext);\n-        this.loadN = op.loadN;\n-    }\n-\n-    @Override\n-    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-        return new HATVectorVarOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.vectorVarOp.\" + varName(), resultType());\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorVarOp.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -62,1 +62,1 @@\n-                        HATVectorBinaryOp vBinaryOp = buildVectorBinaryOp(\n+                        HATVectorOp.HATVectorBinaryOp vBinaryOp = buildVectorBinaryOp(\n@@ -90,1 +90,1 @@\n-                        HATVectorVarOp vVarOp = new HATVectorVarOp(\n+                        HATVectorOp.HATVectorVarOp vVarOp = new HATVectorOp.HATVectorVarOp(\n@@ -130,2 +130,2 @@\n-                                case HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n-                                case HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n+                                case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n+                                case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n@@ -135,1 +135,1 @@\n-                            HATVectorLoadOp vLoadOp = new HATVectorLoadOp(\n+                            HATVectorOp.HATVectorLoadOp vLoadOp = new HATVectorOp.HATVectorLoadOp(\n@@ -151,1 +151,1 @@\n-                            HATPtrLoadOp ptrLoadOp = new HATPtrLoadOp(\n+                            HATPtrOp.HATPtrLoadOp ptrLoadOp = new HATPtrOp.HATPtrLoadOp(\n@@ -169,2 +169,2 @@\n-                            String name = (varOp instanceof HATVectorVarOp) ? ((HATVectorVarOp) varOp).varName() : ((CoreOp.VarOp) varOp).varName();\n-                            TypeElement resultType = (varOp instanceof HATVectorVarOp) ? (varOp).resultType() : ((CoreOp.VarOp) varOp).resultType();\n+                            String name = (varOp instanceof HATVectorOp.HATVectorVarOp) ? ((HATVectorOp.HATVectorVarOp) varOp).varName() : ((CoreOp.VarOp) varOp).varName();\n+                            TypeElement resultType = (varOp instanceof HATVectorOp.HATVectorVarOp) ? (varOp).resultType() : ((CoreOp.VarOp) varOp).resultType();\n@@ -173,1 +173,1 @@\n-                            HATVectorStoreView vStoreOp = new HATVectorStoreView(\n+                            HATVectorOp.HATVectorStoreView vStoreOp = new HATVectorOp.HATVectorStoreView(\n@@ -190,1 +190,1 @@\n-                            HATPtrStoreOp ptrLoadOp = new HATPtrStoreOp(\n+                            HATPtrOp.HATPtrStoreOp ptrLoadOp = new HATPtrOp.HATPtrStoreOp(\n@@ -206,1 +206,1 @@\n-                        HATPtrLengthOp ptrLengthOp = new HATPtrLengthOp(\n+                        HATPtrOp.HATPtrLengthOp ptrLengthOp = new HATPtrOp.HATPtrLengthOp(\n@@ -282,1 +282,1 @@\n-    private HATVectorBinaryOp buildVectorBinaryOp(String opType, String varName, TypeElement resultType, List<Value> outputOperands) {\n+    private HATVectorOp.HATVectorBinaryOp buildVectorBinaryOp(String opType, String varName, TypeElement resultType, List<Value> outputOperands) {\n@@ -285,4 +285,4 @@\n-            case \"add\" -> new HATVectorAddOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n-            case \"sub\" -> new HATVectorSubOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n-            case \"mul\" -> new HATVectorMulOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n-            case \"div\" -> new HATVectorDivOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            case \"add\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorAddOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            case \"sub\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorSubOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            case \"mul\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorMulOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            case \"div\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorDivOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n@@ -304,1 +304,1 @@\n-        return searchForOp(op, Set.of(CoreOp.VarOp.class, HATVectorVarOp.class));\n+        return searchForOp(op, Set.of(CoreOp.VarOp.class, HATVectorOp.HATVectorVarOp.class));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,276 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.callgraph.KernelCallGraph;\n-import hat.device.DeviceType;\n-import hat.dialect.HATLocalVarOp;\n-import hat.dialect.HATMemoryLoadOp;\n-import hat.dialect.HATMemoryVarOp;\n-import hat.dialect.HATPrivateInitVarOp;\n-import hat.dialect.HATPrivateVarOp;\n-import hat.optools.IfaceBufferPattern;\n-import hat.optools.RefactorMe;\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-import optkl.util.CallSite;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.isMethod;\n-import static optkl.OpTkl.transform;\n-\n-public abstract sealed class HATDMemoryPhase implements HATPhase {\n-\n-    protected final KernelCallGraph kernelCallGraph;\n-\n-    @Override\n-    public KernelCallGraph kernelCallGraph(){\n-        return this.kernelCallGraph;\n-    }\n-\n-    private static final Set<String> reservedMethods = new HashSet<>();\n-\n-    static {\n-        reservedMethods.add(\"createLocal\");\n-        reservedMethods.add(\"createPrivate\");\n-        reservedMethods.add(\"create\");\n-        reservedMethods.add(\"float2View\");\n-        reservedMethods.add(\"float4View\");\n-    }\n-\n-    protected abstract HATMemoryVarOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp);\n-\n-    protected abstract boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp);\n-\n-    public HATDMemoryPhase(KernelCallGraph kernelCallGraph) {\n-        this.kernelCallGraph = kernelCallGraph;\n-    }\n-\n-    @Override\n-    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n-        var here = CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase\");\n-        before(here,funcOp);\n-        Set<CoreOp.VarOp> removeMe = new LinkedHashSet<>();\n-        Set<JavaOp.InvokeOp> mapMe = new LinkedHashSet<>();\n-\n-        funcOp.elements()\n-                .filter(e -> e instanceof CoreOp.VarOp )\n-                .map(e-> (CoreOp.VarOp) e)\n-                .forEach(varOp->varOp\n-                        .operands()\n-                        .stream()\n-                        .filter(o -> o instanceof Op.Result result\n-                                && result.op() instanceof JavaOp.InvokeOp invokeOp\n-                                && isIfaceBufferInvokeWithName(invokeOp))\n-                        .map(r -> (JavaOp.InvokeOp) (((Op.Result) r).op()))\n-                        .findFirst().ifPresent(remove-> {\n-                            removeMe.add(varOp);\n-                            mapMe.add(remove);\n-                    })\n-                );\n-\n-        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n-            if (op instanceof JavaOp.InvokeOp invokeOp && mapMe.contains(invokeOp)) {\n-                invokeOp.result()\n-                        .uses()\n-                        .stream()\n-                        .filter(r->r.op() instanceof CoreOp.VarOp).map(r->(CoreOp.VarOp)r.op())\n-                        .forEach(varOp->\n-                            blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(factory(blockBuilder, varOp, invokeOp)))\n-                        );\n-            } else if (op instanceof CoreOp.VarOp varOp && removeMe.contains(varOp)) {\n-                      blockBuilder.context().mapValue(varOp.result(), blockBuilder.context().getValue(varOp.operands().getFirst()));\n-            } else {\n-                blockBuilder.op(op);\n-            }\n-            return blockBuilder;\n-        });\n-        after(here,funcOp );\n-        return funcOp;\n-    }\n-\n-\n-    public static final class PrivateMemoryPhase extends HATDMemoryPhase {\n-        public PrivateMemoryPhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph);\n-        }\n-\n-        @Override\n-        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp) {\n-            if (IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(), invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))) {\n-                return true;\n-            } else {\n-                return isMethod(invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))\n-                        && isAssignable(lookup(),invokeOp.invokeDescriptor().refType(),DeviceType.class);\n-            }\n-        }\n-\n-        @Override\n-        protected HATMemoryVarOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n-            var op = new HATPrivateVarOp(\n-                    varOp.varName(),\n-                    (ClassType) varOp.varValueType(),\n-                    varOp.resultType(),\n-                    invokeOp.resultType(),\n-                    builder.context().getValues(invokeOp.operands())\n-            );\n-            op.setLocation(varOp.location());\n-            return op;\n-        }\n-    }\n-\n-    public static final  class LocalMemoryPhase extends HATDMemoryPhase {\n-\n-        public LocalMemoryPhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph);\n-        }\n-\n-        @Override\n-        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n-            if (IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))) {\n-                return true;\n-            } else {\n-                return (isMethod(invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n-                        && invokeOp.resultType() instanceof JavaType javaType &&\n-                        isAssignable(lookup(),javaType,DeviceType.class));\n-            }\n-        }\n-\n-        @Override\n-        protected HATMemoryVarOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n-            var op = new HATLocalVarOp(\n-                    varOp.varName(),\n-                    (ClassType) varOp.varValueType(),\n-                    varOp.resultType(),\n-                    invokeOp.resultType(),\n-                    builder.context().getValues(invokeOp.operands())\n-            );\n-            op.setLocation(varOp.location());\n-            return op;\n-        }\n-    }\n-\n-    public static final class DeviceTypePhase extends HATDMemoryPhase {\n-\n-        public DeviceTypePhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph);\n-        }\n-\n-        @Override\n-        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n-            return IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n-               || (isMethod(invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n-                    && invokeOp.resultType() instanceof JavaType javaType &&\n-                    isAssignable(lookup(),javaType,DeviceType.class));\n-        }\n-\n-         private boolean isDeviceTypeReservedMethod(JavaOp.InvokeOp invokeOp){\n-            return reservedMethods.contains(invokeOp.invokeDescriptor().name());\n-        }\n-\n-        private boolean meetConditionsForMemoryLoadOp(JavaOp.InvokeOp invokeOp) {\n-            return RefactorMe.isInvokeDescriptorSubtypeOf(lookup(),invokeOp, DeviceType.class)\n-                    && (invokeOp.resultType() != JavaType.VOID)\n-                    && (!(invokeOp.resultType() instanceof PrimitiveType))\n-                    && (!isDeviceTypeReservedMethod(invokeOp));\n-        }\n-\n-        @Override\n-        public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n-            var here = CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase - memoryLoadOp\");\n-            before(here, funcOp);\n-            Map<CoreOp.VarOp, JavaOp.InvokeOp> varTable = new HashMap<>();\n-            Stream<CodeElement<?, ?>> memoryLoadOps = funcOp.elements()\n-                    .mapMulti((codeElement, consumer) -> {\n-                        if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                            if (meetConditionsForMemoryLoadOp(invokeOp)) {\n-                                Op.Result result = invokeOp.result();\n-                                Set<Op.Result> uses = result.uses();\n-                                for (Op.Result use : uses) {\n-                                    if (use.op() instanceof CoreOp.VarOp varOp) {\n-                                        varTable.put(varOp, invokeOp);\n-                                        consumer.accept(invokeOp);\n-                                        consumer.accept(varOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    });\n-\n-            Set<CodeElement<?, ?>> nodesInvolved = memoryLoadOps.collect(Collectors.toSet());\n-            funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n-                if (!nodesInvolved.contains(op)) {\n-                    blockBuilder.op(op);\n-                } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                    insertHatMemoryLoadOp(blockBuilder, invokeOp);\n-                } else if (op instanceof CoreOp.VarOp varOp) {\n-                    JavaOp.InvokeOp invokeOp = varTable.get(varOp);\n-                    factory(blockBuilder, varOp, invokeOp);\n-                }\n-\n-                return blockBuilder;\n-            });\n-            after(here, funcOp);\n-            return funcOp;\n-        }\n-\n-        private void insertHatMemoryLoadOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp) {\n-            HATMemoryLoadOp loadOp = new HATMemoryLoadOp(invokeOp.resultType(),\n-                    invokeOp.invokeDescriptor().refType(),\n-                    invokeOp.invokeDescriptor().name(),\n-                    blockBuilder.context().getValues(invokeOp.operands()));\n-            Op.Result resultLoad = blockBuilder.op(loadOp);\n-            loadOp.setLocation(invokeOp.location());\n-            blockBuilder.context().mapValue(invokeOp.result(), resultLoad);\n-        }\n-\n-        @Override\n-        protected HATMemoryVarOp factory(Block.Builder blockBuilder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n-            HATPrivateInitVarOp privateVarOp = new HATPrivateInitVarOp(varOp.varName(),\n-                    (ClassType) varOp.varValueType(),\n-                    varOp.resultType(),\n-                    invokeOp.invokeDescriptor().refType(),\n-                    blockBuilder.context().getValues(varOp.operands()));\n-            Op.Result op1 = blockBuilder.op(privateVarOp);\n-            privateVarOp.setLocation(varOp.location());\n-            blockBuilder.context().mapValue(varOp.result(), op1);\n-            return privateVarOp;\n-        }\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDMemoryPhase.java","additions":0,"deletions":276,"binary":false,"changes":276,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.dialect.HATF16Op;\n@@ -32,9 +33,0 @@\n-import hat.dialect.HATF16AddOp;\n-import hat.dialect.HATF16BinaryOp;\n-import hat.dialect.HATF16ConvOp;\n-import hat.dialect.HATF16DivOp;\n-import hat.dialect.HATF16MulOp;\n-import hat.dialect.HATF16SubOp;\n-import hat.dialect.HATF16ToFloatConvOp;\n-import hat.dialect.HATF16VarLoadOp;\n-import hat.dialect.HATF16VarOp;\n@@ -59,1 +51,1 @@\n-import static hat.dialect.HATPhaseUtils.findF16IsLocal;\n+\/\/import static hat.dialect.HATPhaseUtils.findF16IsLocal;\n@@ -64,0 +56,15 @@\n+    public static boolean findF16IsLocal(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findF16IsLocal(varLoadOp.operands().getFirst());\n+    }\n+\n+    public static boolean findF16IsLocal(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findF16IsLocal(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATF16Op.HATF16VarOp hatf16VarOp) {\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n@@ -121,1 +128,1 @@\n-        HATF16VarOp hatf16VarOp = new HATF16VarOp(varOp.varName(), reducedFloatType, varOp.resultType(), outputOperands);\n+        HATF16Op.HATF16VarOp hatf16VarOp = new HATF16Op.HATF16VarOp(varOp.varName(), reducedFloatType, varOp.resultType(), outputOperands);\n@@ -130,1 +137,1 @@\n-        HATF16ConvOp convOp1 = new HATF16ConvOp(JavaType.VOID, reducedFloatType, outputOperands);\n+        HATF16Op.HATF16ConvOp convOp1 = new HATF16Op.HATF16ConvOp(JavaType.VOID, reducedFloatType, outputOperands);\n@@ -147,1 +154,1 @@\n-        HATF16ToFloatConvOp convOp1 = new HATF16ToFloatConvOp(JavaType.FLOAT, reducedFloatType, isLocal, wasFloat, outputOperands);\n+        HATF16Op.HATF16ToFloatConvOp convOp1 = new HATF16Op.HATF16ToFloatConvOp(JavaType.FLOAT, reducedFloatType, isLocal, wasFloat, outputOperands);\n@@ -157,1 +164,1 @@\n-        HATF16VarLoadOp hatf16VarLoadOp = new HATF16VarLoadOp(nameVar, varLoadOp.varType(), outputOperands);\n+        HATF16Op.HATF16VarLoadOp hatf16VarLoadOp = new HATF16Op.HATF16VarLoadOp(nameVar, varLoadOp.varType(), outputOperands);\n@@ -175,1 +182,1 @@\n-            valF32Conversion = HATF16BinaryOp.FIRST_OP;\n+            valF32Conversion = HATF16Op.HATF16BinaryOp.FIRST_OP;\n@@ -177,1 +184,1 @@\n-            valF32Conversion = HATF16BinaryOp.LAST_OP;\n+            valF32Conversion = HATF16Op.HATF16BinaryOp.LAST_OP;\n@@ -183,5 +190,5 @@\n-        HATF16BinaryOp binaryOp = switch (binaryOpEnum) {\n-            case ADD -> new HATF16AddOp(typeElement, reducedFloatType, refList, valF32Conversion, outputOperands);\n-            case SUB -> new HATF16SubOp(typeElement, reducedFloatType, refList, valF32Conversion, outputOperands);\n-            case MUL -> new HATF16MulOp(typeElement, reducedFloatType, refList, valF32Conversion, outputOperands);\n-            case DIV -> new HATF16DivOp(typeElement, reducedFloatType, refList, valF32Conversion, outputOperands);\n+        HATF16Op.HATF16BinaryOp binaryOp = switch (binaryOpEnum) {\n+            case ADD -> new HATF16Op.HATF16BinaryOp.HATF16AddOp(typeElement, reducedFloatType, refList, valF32Conversion, outputOperands);\n+            case SUB -> new HATF16Op.HATF16BinaryOp.HATF16SubOp(typeElement, reducedFloatType, refList, valF32Conversion, outputOperands);\n+            case MUL -> new HATF16Op.HATF16BinaryOp.HATF16MulOp(typeElement, reducedFloatType, refList, valF32Conversion, outputOperands);\n+            case DIV -> new HATF16Op.HATF16BinaryOp.HATF16DivOp(typeElement, reducedFloatType, refList, valF32Conversion, outputOperands);\n@@ -249,1 +256,1 @@\n-                                if (valLoad instanceof Op.Result r1 && r1.op() instanceof HATF16VarOp) {\n+                                if (valLoad instanceof Op.Result r1 && r1.op() instanceof HATF16Op.HATF16VarOp) {\n@@ -361,1 +368,1 @@\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATF16VarOp hatf16VarOp) {\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATF16Op.HATF16VarOp hatf16VarOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":30,"deletions":23,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.callgraph.KernelCallGraph;\n+import hat.device.DeviceType;\n+import hat.dialect.HATMemoryDefOp;\n+import hat.dialect.HATMemoryVarOp;\n+import hat.optools.IfaceBufferPattern;\n+import hat.optools.RefactorMe;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+import optkl.util.CallSite;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static optkl.OpTkl.isAssignable;\n+import static optkl.OpTkl.isMethod;\n+import static optkl.OpTkl.transform;\n+\n+public abstract sealed class HATMemoryPhase implements HATPhase {\n+\n+    protected final KernelCallGraph kernelCallGraph;\n+\n+    @Override\n+    public KernelCallGraph kernelCallGraph(){\n+        return this.kernelCallGraph;\n+    }\n+\n+    private static final Set<String> reservedMethods = new HashSet<>();\n+\n+    static {\n+        reservedMethods.add(\"createLocal\");\n+        reservedMethods.add(\"createPrivate\");\n+        reservedMethods.add(\"create\");\n+        reservedMethods.add(\"float2View\");\n+        reservedMethods.add(\"float4View\");\n+    }\n+\n+    protected abstract HATMemoryVarOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp);\n+\n+    protected abstract boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp);\n+\n+    public HATMemoryPhase(KernelCallGraph kernelCallGraph) {\n+        this.kernelCallGraph = kernelCallGraph;\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        var here = CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase\");\n+        before(here,funcOp);\n+        Set<CoreOp.VarOp> removeMe = new LinkedHashSet<>();\n+        Set<JavaOp.InvokeOp> mapMe = new LinkedHashSet<>();\n+\n+        funcOp.elements()\n+                .filter(e -> e instanceof CoreOp.VarOp )\n+                .map(e-> (CoreOp.VarOp) e)\n+                .forEach(varOp->varOp\n+                        .operands()\n+                        .stream()\n+                        .filter(o -> o instanceof Op.Result result\n+                                && result.op() instanceof JavaOp.InvokeOp invokeOp\n+                                && isIfaceBufferInvokeWithName(invokeOp))\n+                        .map(r -> (JavaOp.InvokeOp) (((Op.Result) r).op()))\n+                        .findFirst().ifPresent(remove-> {\n+                            removeMe.add(varOp);\n+                            mapMe.add(remove);\n+                    })\n+                );\n+\n+        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp && mapMe.contains(invokeOp)) {\n+                invokeOp.result()\n+                        .uses()\n+                        .stream()\n+                        .filter(r->r.op() instanceof CoreOp.VarOp).map(r->(CoreOp.VarOp)r.op())\n+                        .forEach(varOp->\n+                            blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(factory(blockBuilder, varOp, invokeOp)))\n+                        );\n+            } else if (op instanceof CoreOp.VarOp varOp && removeMe.contains(varOp)) {\n+                      blockBuilder.context().mapValue(varOp.result(), blockBuilder.context().getValue(varOp.operands().getFirst()));\n+            } else {\n+                blockBuilder.op(op);\n+            }\n+            return blockBuilder;\n+        });\n+        after(here,funcOp );\n+        return funcOp;\n+    }\n+\n+\n+    public static final class PrivateMemoryPhase extends HATMemoryPhase {\n+        public PrivateMemoryPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph);\n+        }\n+\n+        @Override\n+        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp) {\n+            if (IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(), invokeOp, n->n.equals(HATMemoryVarOp.HATPrivateVarOp.INTRINSIC_NAME))) {\n+                return true;\n+            } else {\n+                return isMethod(invokeOp, n->n.equals(HATMemoryVarOp.HATPrivateVarOp.INTRINSIC_NAME))\n+                        && isAssignable(lookup(),invokeOp.invokeDescriptor().refType(),DeviceType.class);\n+            }\n+        }\n+\n+        @Override\n+        protected HATMemoryVarOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n+            var op = new HATMemoryVarOp.HATPrivateVarOp(\n+                    varOp.varName(),\n+                    (ClassType) varOp.varValueType(),\n+                    varOp.resultType(),\n+                    invokeOp.resultType(),\n+                    builder.context().getValues(invokeOp.operands())\n+            );\n+            op.setLocation(varOp.location());\n+            return op;\n+        }\n+    }\n+\n+    public static final  class LocalMemoryPhase extends HATMemoryPhase {\n+\n+        public LocalMemoryPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph);\n+        }\n+\n+        @Override\n+        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n+            if (IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))) {\n+                return true;\n+            } else {\n+                return (isMethod(invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))\n+                        && invokeOp.resultType() instanceof JavaType javaType &&\n+                        isAssignable(lookup(),javaType,DeviceType.class));\n+            }\n+        }\n+\n+        @Override\n+        protected HATMemoryVarOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n+            var op = new HATMemoryVarOp.HATLocalVarOp(\n+                    varOp.varName(),\n+                    (ClassType) varOp.varValueType(),\n+                    varOp.resultType(),\n+                    invokeOp.resultType(),\n+                    builder.context().getValues(invokeOp.operands())\n+            );\n+            op.setLocation(varOp.location());\n+            return op;\n+        }\n+    }\n+\n+    public static final class DeviceTypePhase extends HATMemoryPhase {\n+\n+        public DeviceTypePhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph);\n+        }\n+\n+        @Override\n+        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n+            return IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))\n+               || (isMethod(invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))\n+                    && invokeOp.resultType() instanceof JavaType javaType &&\n+                    isAssignable(lookup(),javaType,DeviceType.class));\n+        }\n+\n+         private boolean isDeviceTypeReservedMethod(JavaOp.InvokeOp invokeOp){\n+            return reservedMethods.contains(invokeOp.invokeDescriptor().name());\n+        }\n+\n+        private boolean meetConditionsForMemoryLoadOp(JavaOp.InvokeOp invokeOp) {\n+            return RefactorMe.isInvokeDescriptorSubtypeOf(lookup(),invokeOp, DeviceType.class)\n+                    && (invokeOp.resultType() != JavaType.VOID)\n+                    && (!(invokeOp.resultType() instanceof PrimitiveType))\n+                    && (!isDeviceTypeReservedMethod(invokeOp));\n+        }\n+\n+        @Override\n+        public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+            var here = CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase - memoryLoadOp\");\n+            before(here, funcOp);\n+            Map<CoreOp.VarOp, JavaOp.InvokeOp> varTable = new HashMap<>();\n+            Stream<CodeElement<?, ?>> memoryLoadOps = funcOp.elements()\n+                    .mapMulti((codeElement, consumer) -> {\n+                        if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                            if (meetConditionsForMemoryLoadOp(invokeOp)) {\n+                                Op.Result result = invokeOp.result();\n+                                Set<Op.Result> uses = result.uses();\n+                                for (Op.Result use : uses) {\n+                                    if (use.op() instanceof CoreOp.VarOp varOp) {\n+                                        varTable.put(varOp, invokeOp);\n+                                        consumer.accept(invokeOp);\n+                                        consumer.accept(varOp);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    });\n+\n+            Set<CodeElement<?, ?>> nodesInvolved = memoryLoadOps.collect(Collectors.toSet());\n+            funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n+                if (!nodesInvolved.contains(op)) {\n+                    blockBuilder.op(op);\n+                } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                    insertHatMemoryLoadOp(blockBuilder, invokeOp);\n+                } else if (op instanceof CoreOp.VarOp varOp) {\n+                    JavaOp.InvokeOp invokeOp = varTable.get(varOp);\n+                    factory(blockBuilder, varOp, invokeOp);\n+                }\n+\n+                return blockBuilder;\n+            });\n+            after(here, funcOp);\n+            return funcOp;\n+        }\n+\n+        private void insertHatMemoryLoadOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp) {\n+            HATMemoryDefOp.HATMemoryLoadOp loadOp = new HATMemoryDefOp.HATMemoryLoadOp(invokeOp.resultType(),\n+                    invokeOp.invokeDescriptor().refType(),\n+                    invokeOp.invokeDescriptor().name(),\n+                    blockBuilder.context().getValues(invokeOp.operands()));\n+            Op.Result resultLoad = blockBuilder.op(loadOp);\n+            loadOp.setLocation(invokeOp.location());\n+            blockBuilder.context().mapValue(invokeOp.result(), resultLoad);\n+        }\n+\n+        @Override\n+        protected HATMemoryVarOp factory(Block.Builder blockBuilder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n+            HATMemoryVarOp.HATPrivateInitVarOp privateVarOp = new HATMemoryVarOp.HATPrivateInitVarOp(varOp.varName(),\n+                    (ClassType) varOp.varValueType(),\n+                    varOp.resultType(),\n+                    invokeOp.invokeDescriptor().refType(),\n+                    blockBuilder.context().getValues(varOp.operands()));\n+            Op.Result op1 = blockBuilder.op(privateVarOp);\n+            privateVarOp.setLocation(varOp.location());\n+            blockBuilder.context().mapValue(varOp.result(), op1);\n+            return privateVarOp;\n+        }\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -37,1 +37,1 @@\n-        HATDMemoryPhase, HATThreadsPhase, HATVectorPhase, HATVectorSelectPhase, HATVectorStorePhase {\n+        HATMemoryPhase, HATThreadsPhase, HATVectorPhase, HATVectorSelectPhase, HATVectorStorePhase {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,5 +29,1 @@\n-import hat.dialect.HATBlockThreadIdOp;\n-import hat.dialect.HATGlobalSizeOp;\n-import hat.dialect.HATGlobalThreadIdOp;\n-import hat.dialect.HATLocalSizeOp;\n-import hat.dialect.HATLocalThreadIdOp;\n+import hat.dialect.HATThreadOp;\n@@ -90,5 +86,5 @@\n-                              case BlockPhase _->HATBlockThreadIdOp.of(dimIdx, $.resultType());\n-                              case GlobalIdPhase _->HATGlobalThreadIdOp.of(dimIdx, $.resultType());\n-                              case GlobalSizePhase _-> HATGlobalSizeOp.of(dimIdx, $.resultType());\n-                              case LocalIdPhase _-> HATLocalThreadIdOp.of(dimIdx, $.resultType());\n-                              case LocalSizePhase _-> HATLocalSizeOp.of(dimIdx,$.resultType());\n+                              case BlockPhase _-> HATThreadOp.HATBlockThreadIdOp.of(dimIdx, $.resultType());\n+                              case GlobalIdPhase _-> HATThreadOp.HATGlobalThreadIdOp.of(dimIdx, $.resultType());\n+                              case GlobalSizePhase _-> HATThreadOp.HATGlobalSizeOp.of(dimIdx, $.resultType());\n+                              case LocalIdPhase _-> HATThreadOp.HATLocalThreadIdOp.of(dimIdx, $.resultType());\n+                              case LocalSizePhase _-> HATThreadOp.HATLocalSizeOp.of(dimIdx,$.resultType());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public class HATDTier implements  LookupCarrier {\n+public class HATTier implements  LookupCarrier {\n@@ -46,1 +46,1 @@\n-    public HATDTier(KernelCallGraph kernelCallGraph) {\n+    public HATTier(KernelCallGraph kernelCallGraph) {\n@@ -55,3 +55,3 @@\n-        hatPhases.add(new HATDMemoryPhase.LocalMemoryPhase(kernelCallGraph));\n-        hatPhases.add(new HATDMemoryPhase.PrivateMemoryPhase(kernelCallGraph));\n-        hatPhases.add(new HATDMemoryPhase.DeviceTypePhase(kernelCallGraph));\n+        hatPhases.add(new HATMemoryPhase.LocalMemoryPhase(kernelCallGraph));\n+        hatPhases.add(new HATMemoryPhase.PrivateMemoryPhase(kernelCallGraph));\n+        hatPhases.add(new HATMemoryPhase.DeviceTypePhase(kernelCallGraph));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATTier.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDTier.java","status":"renamed"},{"patch":"@@ -29,11 +29,1 @@\n-import hat.dialect.HATLocalVarOp;\n-import hat.dialect.HATPrivateVarOp;\n-import hat.dialect.HATVectorAddOp;\n-import hat.dialect.HATVectorDivOp;\n-import hat.dialect.HATVectorLoadOp;\n-import hat.dialect.HATVectorMakeOfOp;\n-import hat.dialect.HATVectorMulOp;\n-import hat.dialect.HATVectorOfOp;\n-import hat.dialect.HATVectorSubOp;\n-import hat.dialect.HATVectorVarLoadOp;\n-import hat.dialect.HATVectorVarOp;\n+import hat.dialect.HATMemoryVarOp;\n@@ -41,1 +31,0 @@\n-import hat.dialect.HATVectorBinaryOp;\n@@ -62,2 +51,1 @@\n-import static hat.dialect.HATPhaseUtils.findNameVector;\n-import static hat.dialect.HATPhaseUtils.findVectorTypeElement;\n+\/\/import static hat.dialect.HATPhaseUtils.findVectorTypeElement;\n@@ -65,1 +53,0 @@\n-import static hat.dialect.HATPhaseUtils.getWitdh;\n@@ -78,0 +65,47 @@\n+\n+\n+    public static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findVectorTypeElement(varLoadOp.operands().getFirst());\n+    }\n+\n+    private static TypeElement findVectorTypeElement(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findVectorTypeElement(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.vectorElementType();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().getFirst());\n+    }\n+\n+    private static int getWidth(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return getWidth(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.vectorN();\n+            }\n+            return -1;\n+        }\n+    }\n+    public static int getWidth(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return getWidth(varLoadOp.operands().getFirst());\n+    }\n+    public static String findNameVector(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findNameVector(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n@@ -118,1 +152,1 @@\n-            if (v instanceof CoreOp.Result r && (r.op() instanceof HATLocalVarOp || r.op() instanceof HATPrivateVarOp)) {\n+            if (v instanceof CoreOp.Result r && (r.op() instanceof HATMemoryVarOp.HATLocalVarOp || r.op() instanceof HATMemoryVarOp.HATPrivateVarOp)) {\n@@ -125,2 +159,2 @@\n-    private HATVectorBinaryOp buildVectorBinaryOp(BinaryOpEnum opType, String varName, TypeElement resultType,\n-                                                  TypeElement vectorElementType, int witdh, List<Value> outputOperands) {\n+    private HATVectorOp.HATVectorBinaryOp buildVectorBinaryOp(BinaryOpEnum opType, String varName, TypeElement resultType,\n+                                                              TypeElement vectorElementType, int witdh, List<Value> outputOperands) {\n@@ -128,4 +162,4 @@\n-            case ADD -> new HATVectorAddOp(varName, resultType, vectorElementType, witdh, outputOperands);\n-            case SUB -> new HATVectorSubOp(varName, resultType, vectorElementType, witdh, outputOperands);\n-            case MUL -> new HATVectorMulOp(varName, resultType, vectorElementType, witdh, outputOperands);\n-            case DIV -> new HATVectorDivOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+            case ADD -> new HATVectorOp.HATVectorBinaryOp.HATVectorAddOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+            case SUB -> new HATVectorOp.HATVectorBinaryOp.HATVectorSubOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+            case MUL -> new HATVectorOp.HATVectorBinaryOp.HATVectorMulOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+            case DIV -> new HATVectorOp.HATVectorBinaryOp.HATVectorDivOp(varName, resultType, vectorElementType, witdh, outputOperands);\n@@ -139,1 +173,1 @@\n-        HATVectorOp memoryViewOp = new HATVectorLoadOp(varOp.varName(), varOp.resultType(), metaData.vectorTypeElement(), metaData.lanes(), isShared, outputOperandsVarOp);\n+        HATVectorOp memoryViewOp = new HATVectorOp.HATVectorLoadOp(varOp.varName(), varOp.resultType(), metaData.vectorTypeElement(), metaData.lanes(), isShared, outputOperandsVarOp);\n@@ -149,1 +183,1 @@\n-        HATVectorOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperandsVarOp);\n+        HATVectorOp memoryViewOp = new HATVectorOp.HATVectorVarOp(varOp.varName(), varOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperandsVarOp);\n@@ -172,1 +206,1 @@\n-        int lanes = getWitdh(varLoadOp);\n+        int lanes = getWidth(varLoadOp);\n@@ -174,1 +208,1 @@\n-        HATVectorOp memoryViewOp = new HATVectorVarLoadOp(varLoadName, varLoadOp.resultType(), vectorElementType, lanes, outputOperandsVarLoad);\n+        HATVectorOp memoryViewOp = new HATVectorOp.HATVectorVarLoadOp(varLoadName, varLoadOp.resultType(), vectorElementType, lanes, outputOperandsVarLoad);\n@@ -196,1 +230,1 @@\n-        HATVectorOfOp memoryViewOp = new HATVectorOfOp(invokeOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperandsVarOp);\n+        HATVectorOp.HATVectorOfOp memoryViewOp = new HATVectorOp.HATVectorOfOp(invokeOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperandsVarOp);\n@@ -208,1 +242,1 @@\n-        HATVectorMakeOfOp makeOf = new HATVectorMakeOfOp(varName, invokeOp.resultType(), vmd.lanes(), outputOperandsVarOp);\n+        HATVectorOp.HATVectorMakeOfOp makeOf = new HATVectorOp.HATVectorMakeOfOp(varName, invokeOp.resultType(), vmd.lanes(), outputOperandsVarOp);\n@@ -407,1 +441,1 @@\n-                    } else if (codeElement instanceof HATVectorBinaryOp hatVectorBinaryOp) {\n+                    } else if (codeElement instanceof HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":63,"deletions":29,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorSelectStoreOp;\n@@ -136,1 +134,1 @@\n-                            vSelectOp = new HATVectorSelectLoadOp(name, invokeOp.resultType(), lane, outputOperandsInvokeOp);\n+                            vSelectOp = new HATVectorOp.HATVectorSelectLoadOp(name, invokeOp.resultType(), lane, outputOperandsInvokeOp);\n@@ -196,1 +194,1 @@\n-                        vSelectOp = new HATVectorSelectStoreOp(name, invokeOp.resultType(), lane, resultOp, outputOperandsInvokeOp);\n+                        vSelectOp = new HATVectorOp.HATVectorSelectStoreOp(name, invokeOp.resultType(), lane, resultOp, outputOperandsInvokeOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import hat.dialect.HATLocalVarOp;\n-import hat.dialect.HATPrivateVarOp;\n-import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATMemoryVarOp;\n@@ -76,1 +74,1 @@\n-            return (v instanceof CoreOp.Result r && (r.op() instanceof HATLocalVarOp || r.op() instanceof HATPrivateVarOp));\n+            return (v instanceof CoreOp.Result r && (r.op() instanceof HATMemoryVarOp.HATLocalVarOp || r.op() instanceof HATMemoryVarOp.HATPrivateVarOp));\n@@ -112,1 +110,1 @@\n-                HATVectorOp storeView = new HATVectorStoreView(findNameVector(invokeOp.operands().get(1)), invokeOp.resultType(), vectorMetaData.lanes(),\n+                HATVectorOp storeView = new HATVectorOp.HATVectorStoreView(findNameVector(invokeOp.operands().get(1)), invokeOp.resultType(), vectorMetaData.lanes(),\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"}]}