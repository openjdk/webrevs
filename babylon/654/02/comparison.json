{"files":[{"patch":"@@ -30,0 +30,4 @@\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -34,0 +38,1 @@\n+import jdk.incubator.code.internal.CodeModel;\n@@ -47,0 +52,2 @@\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n@@ -166,0 +173,108 @@\n+    \/**\n+     * Produces a bootstrap call site that returns a code model operation defined by an annotated method on the lookup\n+     * class.\n+     * <p>\n+     * The target of the returned {@link ConstantCallSite} invokes {@link #fromAnnotation(Class, String)} with the\n+     * {@code lookup} class and the provided {@code methodName}. The method identified by {@code methodName} must be\n+     * declared on {@code lookup.lookupClass()} and annotated with {@link CodeModel}.\n+     * <p>\n+     * Note: The current implementation binds a static method handle and does not cache the constructed {@link Op}\n+     * across invocations; callers should cache if needed.\n+     *\n+     * @param lookup the lookup context used to identify the host class\n+     * @param methodName the name of the annotated method on the lookup class\n+     * @param callSiteType the invokedynamic call site type (ignored by this bootstrap except for linkage)\n+     * @return a constant call site whose target, when invoked, yields the {@link Op} for the annotated method\n+     * @throws ReflectiveOperationException if the bootstrap cannot create the target method handle\n+     *\/\n+    public static CallSite fromAnnotation(MethodHandles.Lookup lookup,\n+                                          String methodName,\n+                                          MethodType callSiteType) throws ReflectiveOperationException {\n+        return new ConstantCallSite(\n+                \/\/ caching implementation\n+\/\/                MethodHandles.constant(Op.class, fromAnnotation(lookup.lookupClass(), methodName)));\n+\n+                \/\/ non-caching implementation\n+                MethodHandles.insertArguments(\n+                        MethodHandles.lookup().findStatic(OpParser.class, \"fromAnnotation\", MethodType.methodType(Op.class, Class.class, String.class)),\n+                        0,\n+                        lookup.lookupClass(), methodName));\n+    }\n+\n+    static Op fromAnnotation(Class<?> cls, String method) {\n+        try {\n+            if (cls.getDeclaredMethod(method).getAnnotation(CodeModel.class) instanceof CodeModel cm) {\n+                DialectFactory f = JavaOp.JAVA_DIALECT_FACTORY;\n+                Context c = new Context(f.opFactory(), f.typeElementFactory());\n+                OpNode n = new CodeModelParser(cm.bodies(), cm.types()).parseOpNode(cm.funcOp());\n+                Op op = nodeToOp(n, VOID, c, null);\n+                op.seal();\n+                return op;\n+            }\n+            return null;\n+        } catch (NoSuchMethodException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    static final class CodeModelParser {\n+\n+        final CodeModel.Body[] allBodies;\n+        final CodeModel.Type[] allTypes;\n+        int valueIndex, blockIndex;\n+\n+        public CodeModelParser(CodeModel.Body[] allBodies, CodeModel.Type[] allTypes) {\n+            this.allBodies = allBodies;\n+            this.allTypes = allTypes;\n+            valueIndex = -1;\n+            blockIndex = -1;\n+        }\n+\n+        OpNode parseOpNode(CodeModel.Op op) {\n+            Map<String, Object> attrMap = new HashMap<>();\n+            String[] attributes = op.attributes();\n+            if (!op.defaultAttribute().isEmpty()) {\n+                attrMap.put(\"\", parseAttributeValue(op.defaultAttribute()));\n+            }\n+            var loc = op.location();\n+            if (loc.length == 2) {\n+                attrMap.put(\"loc\", new Location(op.sourceRef().isEmpty() ? null : op.sourceRef(), loc[0], loc[1]));\n+            }\n+            for (int i = 0; i < attributes.length; i+=2) {\n+                attrMap.put(attributes[i], parseAttributeValue(attributes[i + 1]));\n+            }\n+            return new OpNode(\n+                    op.resultType() < 0 ? null : new ValueNode(String.valueOf(++valueIndex), parseExTypeElem(op.resultType())),\n+                    op.name(),\n+                    toStrings(op.operands()),\n+                    Stream.of(op.successors()).map(br -> new SuccessorNode(String.valueOf(br.targetBlock()), toStrings(br.arguments()))).toList(),\n+                    attrMap,\n+                    IntStream.of(op.bodyDefinitions()).mapToObj(bi -> parseBodyNode(bi)).toList());\n+        }\n+\n+        BodyNode parseBodyNode(int bodyIndex) {\n+            CodeModel.Body body = allBodies[bodyIndex];\n+            return new BodyNode(\n+                    parseExTypeElem(body.yieldType()),\n+                    Stream.of(body.blocks()).map(bl -> new BlockNode(\n+                            String.valueOf(++blockIndex),\n+                            IntStream.of(bl.paramTypes()).mapToObj(pt -> new ValueNode(String.valueOf(++valueIndex), parseExTypeElem(pt))).toList(),\n+                            Stream.of(bl.ops()).map(this::parseOpNode).toList())).toList());\n+        }\n+\n+        ExternalizedTypeElement parseExTypeElem(int typeIndex) {\n+            var type = allTypes[typeIndex];\n+            return new ExternalizedTypeElement(type.identifier(), IntStream.of(type.arguments()).mapToObj(this::parseExTypeElem).toList());\n+        }\n+    }\n+\n+    static List<String> toStrings(int[] indexes) {\n+        return IntStream.of(indexes).mapToObj(String::valueOf).toList();\n+    }\n+\n+    static Object parseAttributeValue(String value) {\n+        Scanner sc = Scanner.factory().newScanner(value);\n+        sc.nextToken();\n+        return new OpParser(sc).parseAttributeValue();\n+    }\n+\n@@ -198,1 +313,0 @@\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/OpParser.java","additions":115,"deletions":1,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.incubator.code.extern.impl.AttributeMapper;\n@@ -34,1 +35,0 @@\n-import java.lang.reflect.Array;\n@@ -76,82 +76,0 @@\n-    static final class AttributeMapper {\n-        static String toString(Object value) {\n-            if (value == ExternalizedOp.NULL_ATTRIBUTE_VALUE) {\n-                return \"null\";\n-            }\n-\n-            StringBuilder sb = new StringBuilder();\n-            toString(value, sb);\n-            return sb.toString();\n-        }\n-\n-        static void toString(Object o, StringBuilder sb) {\n-            if (o.getClass().isArray()) {\n-                \/\/ note, while we can't parse back the array representation, this might be useful\n-                \/\/ for non-externalizable ops that want better string representation of array attribute values (e.g. ONNX)\n-                arrayToString(o, sb);\n-            } else {\n-                switch (o) {\n-                    case Integer i -> sb.append(i);\n-                    case Long l -> sb.append(l).append('L');\n-                    case Float f -> sb.append(f).append('f');\n-                    case Double d -> sb.append(d).append('d');\n-                    case Character c -> sb.append('\\'').append(c).append('\\'');\n-                    case Boolean b -> sb.append(b);\n-                    case TypeElement te -> sb.append(JavaTypeUtils.flatten(te.externalize()));\n-                    default -> {  \/\/ fallback to a string\n-                        sb.append('\"');\n-                        quote(o.toString(), sb);\n-                        sb.append('\"');\n-                    }\n-                }\n-            }\n-        }\n-\n-        static void arrayToString(Object a, StringBuilder sb) {\n-            boolean first = true;\n-            sb.append(\"[\");\n-            for (int i = 0; i < Array.getLength(a); i++) {\n-                if (!first) {\n-                    sb.append(\", \");\n-                }\n-\n-                toString(Array.get(a, i), sb);\n-                first = false;\n-            }\n-            sb.append(\"]\");\n-        }\n-    }\n-\n-    static void quote(String s, StringBuilder sb) {\n-        for (int i = 0; i < s.length(); i++) {\n-            sb.append(quote(s.charAt(i)));\n-        }\n-    }\n-\n-    \/**\n-     * Escapes a character if it has an escape sequence or is\n-     * non-printable ASCII.  Leaves non-ASCII characters alone.\n-     *\/\n-    \/\/ Copied from com.sun.tools.javac.util.Convert\n-    static String quote(char ch) {\n-        return switch (ch) {\n-            case '\\b' -> \"\\\\b\";\n-            case '\\f' -> \"\\\\f\";\n-            case '\\n' -> \"\\\\n\";\n-            case '\\r' -> \"\\\\r\";\n-            case '\\t' -> \"\\\\t\";\n-            case '\\'' -> \"\\\\'\";\n-            case '\\\"' -> \"\\\\\\\"\";\n-            case '\\\\' -> \"\\\\\\\\\";\n-            default -> (isPrintableAscii(ch))\n-                    ? String.valueOf(ch)\n-                    : String.format(\"\\\\u%04x\", (int) ch);\n-        };\n-    }\n-\n-    \/**\n-     * Is a character printable ASCII?\n-     *\/\n-    static boolean isPrintableAscii(char ch) {\n-        return ch >= ' ' && ch <= '~';\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/OpWriter.java","additions":2,"deletions":84,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.code.extern.impl;\n+\n+import java.lang.reflect.Array;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n+import jdk.incubator.code.extern.ExternalizedOp;\n+\n+public final class AttributeMapper {\n+\n+    private AttributeMapper() {\n+    }\n+\n+    public static String toString(Object value) {\n+        if (value == ExternalizedOp.NULL_ATTRIBUTE_VALUE) {\n+            return \"null\";\n+        }\n+        StringBuilder sb = new StringBuilder();\n+        toString(value, sb);\n+        return sb.toString();\n+    }\n+\n+    static void toString(Object o, StringBuilder sb) {\n+        if (o.getClass().isArray()) {\n+            \/\/ note, while we can't parse back the array representation, this might be useful\n+            \/\/ for non-externalizable ops that want better string representation of array attribute values (e.g. ONNX)\n+            arrayToString(o, sb);\n+        } else {\n+            switch (o) {\n+                case Integer i -> sb.append(i);\n+                case Long l -> sb.append(l).append('L');\n+                case Float f -> sb.append(f).append('f');\n+                case Double d -> sb.append(d).append('d');\n+                case Character c -> sb.append('\\'').append(c).append('\\'');\n+                case Boolean b -> sb.append(b);\n+                case TypeElement te -> sb.append(JavaTypeUtils.flatten(te.externalize()));\n+                default -> {\n+                    \/\/ fallback to a string\n+                    sb.append('\"');\n+                    quote(o.toString(), sb);\n+                    sb.append('\"');\n+                }\n+            }\n+        }\n+    }\n+\n+    static void arrayToString(Object a, StringBuilder sb) {\n+        boolean first = true;\n+        sb.append(\"[\");\n+        for (int i = 0; i < Array.getLength(a); i++) {\n+            if (!first) {\n+                sb.append(\", \");\n+            }\n+            toString(Array.get(a, i), sb);\n+            first = false;\n+        }\n+        sb.append(\"]\");\n+    }\n+\n+    static void quote(String s, StringBuilder sb) {\n+        for (int i = 0; i < s.length(); i++) {\n+            sb.append(quote(s.charAt(i)));\n+        }\n+    }\n+\n+    \/**\n+     * Escapes a character if it has an escape sequence or is\n+     * non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    \/\/ Copied from com.sun.tools.javac.util.Convert\n+    static String quote(char ch) {\n+        return switch (ch) {\n+            case '\\b' -> \"\\\\b\";\n+            case '\\f' -> \"\\\\f\";\n+            case '\\n' -> \"\\\\n\";\n+            case '\\r' -> \"\\\\r\";\n+            case '\\t' -> \"\\\\t\";\n+            case '\\'' -> \"\\\\'\";\n+            case '\\\"' -> \"\\\\\\\"\";\n+            case '\\\\' -> \"\\\\\\\\\";\n+            default -> (isPrintableAscii(ch)) ? String.valueOf(ch) : String.format(\"\\\\u%04x\", (int) ch);\n+        };\n+    }\n+\n+    \/**\n+     * Is a character printable ASCII?\n+     *\/\n+    static boolean isPrintableAscii(char ch) {\n+        return ch >= ' ' && ch <= '~';\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/impl\/AttributeMapper.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.internal;\n+\n+import java.lang.annotation.*;\n+\n+\/**\n+ * Annotation for embedding a code reflection model alongside a Java method.\n+ *\/\n+@Target({ElementType.METHOD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface CodeModel {\n+\n+    \/**\n+     * The root operation associated with the method.\n+     *\/\n+    Op funcOp();\n+\n+    \/**\n+     * The collection of bodies referenced by operations and blocks in this model. The indexing of these entries is\n+     * local to this array.\n+     *\/\n+    Body[] bodies();\n+\n+    \/**\n+     * The collection of types referenced by operations, blocks, bodies and types in this model. The indexing of these\n+     * entries is local to this array.\n+     *\/\n+    Type[] types();\n+\n+    \/**\n+     * Describes an operation in the code reflection model. An operation may reference operands, attributes, successors,\n+     * and types.\n+     *\n+     * @see jdk.incubator.code.Op\n+     * @see jdk.incubator.code.extern.ExternalizedOp\n+     *\/\n+    @interface Op {\n+\n+        \/**\n+         * Operation name or opcode identifier.\n+         *\n+         * @see jdk.incubator.code.Op#externalizeOpName()\n+         *\/\n+        String name();\n+\n+        \/**\n+         * Operand references, expressed as indices local to the current context (previously produced\n+         * results or block parameters).\n+         *\n+         * @see jdk.incubator.code.Op#operands()\n+         *\/\n+        int[] operands() default {};\n+\n+        \/**\n+         * Control-flow successors for this operation, if any (e.g., branch targets). Each successor references a block\n+         * and optional argument indices.\n+         *\n+         * @see jdk.incubator.code.Op#successors()\n+         *\/\n+        BlockReference[] successors() default {};\n+\n+        \/**\n+         * Index of the result type for this operation within the enclosing {@link Body#types()} array.\n+         *\n+         * @see jdk.incubator.code.Op#resultType()\n+         *\/\n+        int resultType() default -1;\n+\n+        \/**\n+         * Optional default attribute value for this operation.\n+         *\n+         * @see jdk.incubator.code.Op#externalize()\n+         *\/\n+        String defaultAttribute() default \"\";\n+\n+        \/**\n+         * Optional reference to source file information.\n+         *\n+         * @see jdk.incubator.code.Op#location()\n+         * @see jdk.incubator.code.Location#sourceRef()\n+         *\/\n+        String sourceRef() default \"\";\n+\n+        \/**\n+         * Optional source location coordinates (e.g., line\/column pairs).\n+         *\n+         * @see jdk.incubator.code.Op#location()\n+         * @see jdk.incubator.code.Location#line()\n+         * @see jdk.incubator.code.Location#column()\n+         *\/\n+        int[] location() default {};\n+\n+        \/**\n+         * Additional operation attributes as string pairs (key, value).\n+         *\n+         * @see jdk.incubator.code.Op#externalize()\n+         *\/\n+        String[] attributes() default {};\n+\n+        \/**\n+         * References to body definitions that belong to this operation. Indices are relative to the\n+         * {@link CodeModel#bodies()} array.\n+         *\n+         * @see jdk.incubator.code.Op#bodies()\n+         *\/\n+        int[] bodyDefinitions() default {};\n+    }\n+\n+    \/**\n+     * A body groups one or more blocks and may declares a yield type.\n+     *\n+     * @see jdk.incubator.code.Body\n+     *\/\n+    @interface Body {\n+\n+        \/**\n+         * Index of the type produced by this body within the enclosing {@link Body#types()} array.\n+         *\n+         * @see jdk.incubator.code.Body#yieldType()\n+         *\/\n+        int yieldType();\n+\n+        \/**\n+         * Blocks contained within this body. Block indices are local to this array.\n+         *\n+         * @see jdk.incubator.code.Body#blocks()\n+         *\/\n+        Block[] blocks();\n+    }\n+\n+    \/**\n+     * A basic block consisting of optional parameters and a sequence of operations.\n+     *\n+     * @see jdk.incubator.code.Block\n+     *\/\n+    @interface Block {\n+\n+        \/**\n+         * Indexes of the block parameter types within the enclosing {@link Body#types()} array.\n+         *\n+         * @see jdk.incubator.code.Block#parameterTypes()\n+         *\/\n+        int[] paramTypes() default {};\n+\n+        \/**\n+         * Operations contained in this block, evaluated in order.\n+         *\n+         * @see jdk.incubator.code.Block#ops()\n+         *\/\n+        Op[] ops();\n+    }\n+\n+    \/**\n+     * A reference to a block and the argument indices provided to it.\n+     *\n+     * @see jdk.incubator.code.Block.Reference\n+     *\/\n+    @interface BlockReference {\n+\n+        \/**\n+         * Index of the target block within the enclosing {@link Body#blocks()} array.\n+         *\n+         * @see jdk.incubator.code.Block.Reference#targetBlock()\n+         *\/\n+        int targetBlock();\n+\n+        \/**\n+         * Indices of the arguments passed to the target blockâ€™s parameters. Argument indices are local to the\n+         * referencing context.\n+         *\n+         * @see jdk.incubator.code.Block.Reference#arguments()\n+         *\/\n+        int[] arguments() default {};\n+    }\n+\n+    \/**\n+     * Describes a type used in the code reflection model. A type is identified by an externalized name and may\n+     * carry zero or more nested type arguments to represent parameterized or composite types.\n+     *\n+     * @see jdk.incubator.code.TypeElement\n+     * @see jdk.incubator.code.extern.ExternalizedTypeElement\n+     *\/\n+    @interface Type {\n+\n+        \/**\n+         * Fully qualified, stable identifier of the type. This is the externalized form used to serialize and restore\n+         * the type.\n+         *\n+         * @return the externalized type identifier\n+         *\/\n+        String identifier();\n+\n+        \/**\n+         * Indexes of the of type arguments within the enclosing {@link Body#types()} array.\n+         * For non-parameterized types, this array is empty.\n+         *\n+         * @return the type arguments, or an empty array if none\n+         *\/\n+        int[] arguments();\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModel.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -0,0 +1,333 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.internal;\n+\n+import java.util.Map;\n+\n+import com.sun.tools.javac.code.Attribute;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Symbol.DynamicMethodSymbol;\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.MethodType;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+import com.sun.tools.javac.util.Pair;\n+import java.util.HashMap;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.Location;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n+import jdk.incubator.code.extern.impl.AttributeMapper;\n+\n+\n+ \/**\n+  * Initializes and provides javac symbols and helper builders to encode a\n+  * jdk.incubator.code model as a javac attribute compatible with the\n+  * {@link CodeModel} annotation format.\n+  * <p>\n+  * Instances of this class set up the necessary symbol and type handles and\n+  * offer utilities to transform high-level code model elements (ops, bodies,\n+  * blocks, successors) into {@link Attribute} representations.\n+  *\/\n+public final class CodeModelSymbols {\n+\n+    final class Indexer<T> {\n+        final Map<T, Integer> map = new HashMap<>();\n+\n+        int indexOf(T t) {\n+            return map.computeIfAbsent(t, _ -> map.size());\n+        }\n+    }\n+\n+    final Symtab syms;\n+\n+    final Type intArrayType,\n+               stringArrayType,\n+               bodyArrayType,\n+               blockArrayType,\n+               opArrayType,\n+               codeModelType,\n+               bodyType,\n+               blockType,\n+               blockReferenceType,\n+               blockReferenceArrayType,\n+               opType,\n+               typeType,\n+               typeArrayType,\n+               opParserType,\n+               fromAnnotation;\n+\n+    final MethodSymbol modelFuncOp,\n+                       modelBodies,\n+                       modelTypes,\n+                       bodyYieldType,\n+                       bodyBlocks,\n+                       blockParamTypes,\n+                       blockOps,\n+                       blockReferenceTargetBlock,\n+                       blockReferenceArguments,\n+                       opName,\n+                       opOperands,\n+                       opSuccessors,\n+                       opResultType,\n+                       opDefaultAttribute,\n+                       opSourceRef,\n+                       opLocation,\n+                       opAttributes,\n+                       opBodyDefinitions,\n+                       typeIdentifier,\n+                       typeArguments,\n+                       bsmFromAnnotation;\n+\n+    \/**\n+     * Constructs and initializes symbol\/type handles used to build CodeModel attributes. This performs module\/class\n+     * symbol lookups and synthesizes method signatures to align with the CodeModel annotation schema.\n+     *\n+     * @param context the javac compilation context\n+     *\/\n+    public CodeModelSymbols(Context context) {\n+        syms = Symtab.instance(context);\n+        Names names = Names.instance(context);\n+        Types types = Types.instance(context);\n+        ModuleSymbol jdk_incubator_code = syms.enterModule(names.jdk_incubator_code);\n+        intArrayType = types.makeArrayType(syms.intType);\n+        stringArrayType = types.makeArrayType(syms.stringType);\n+        codeModelType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.internal.CodeModel\");\n+        bodyType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.internal.CodeModel$Body\");\n+        bodyArrayType = types.makeArrayType(bodyType);\n+        blockType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.internal.CodeModel$Block\");\n+        blockArrayType = types.makeArrayType(blockType);\n+        blockReferenceType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.internal.CodeModel$BlockReference\");\n+        blockReferenceArrayType = types.makeArrayType(blockReferenceType);\n+        opType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.internal.CodeModel$Op\");\n+        opArrayType = types.makeArrayType(opType);\n+        typeType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.internal.CodeModel$Type\");\n+        typeArrayType = types.makeArrayType(typeType);\n+        opParserType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.extern.OpParser\");\n+        var atypes = new Object() {\n+            MethodSymbol methodType(String name, Type restype, Type owner) {\n+                return new MethodSymbol(\n+                        Flags.PUBLIC | Flags.ABSTRACT,\n+                        names.fromString(name),\n+                        new MethodType(List.nil(), restype, List.nil(), syms.methodClass),\n+                        owner.tsym);\n+            }\n+        };\n+        modelFuncOp = atypes.methodType(\"funcOp\", opType, codeModelType);\n+        modelBodies = atypes.methodType(\"bodies\", bodyArrayType, codeModelType);\n+        modelTypes = atypes.methodType(\"types\", typeArrayType, codeModelType);\n+        bodyYieldType = atypes.methodType(\"yieldType\", syms.intType, bodyType);\n+        bodyBlocks = atypes.methodType(\"blocks\", blockArrayType, bodyType);\n+        blockParamTypes = atypes.methodType(\"paramTypes\", intArrayType, blockType);\n+        blockOps = atypes.methodType(\"ops\", opArrayType, blockType);\n+        blockReferenceTargetBlock = atypes.methodType(\"targetBlock\", syms.intType, blockReferenceType);\n+        blockReferenceArguments = atypes.methodType(\"arguments\", intArrayType, blockReferenceType);\n+        opName = atypes.methodType(\"name\", syms.stringType, opType);\n+        opOperands = atypes.methodType(\"operands\", intArrayType, opType);\n+        opSuccessors = atypes.methodType(\"successors\", blockReferenceArrayType, opType);\n+        opResultType = atypes.methodType(\"resultType\", syms.intType, opType);\n+        opDefaultAttribute = atypes.methodType(\"defaultAttribute\", syms.stringType, opType);\n+        opSourceRef = atypes.methodType(\"sourceRef\", syms.stringType, opType);\n+        opLocation = atypes.methodType(\"location\", intArrayType, opType);\n+        opAttributes = atypes.methodType(\"attributes\", stringArrayType, opType);\n+        opBodyDefinitions = atypes.methodType(\"bodyDefinitions\", intArrayType, opType);\n+        typeIdentifier = atypes.methodType(\"identifier\", syms.stringType, typeType);\n+        typeArguments = atypes.methodType(\"arguments\", intArrayType, typeType);\n+        var opT = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.Op\");\n+        fromAnnotation = new MethodType(List.nil(), opT, List.nil(), syms.methodClass);\n+        bsmFromAnnotation = new MethodSymbol(Flags.PUBLIC | Flags.STATIC,\n+                names.fromString(\"fromAnnotation\"),\n+                new MethodType(List.of(syms.methodHandleLookupType, syms.stringType, syms.methodTypeType),\n+                        syms.enterClass(syms.java_base, \"java.lang.invoke.CallSite\"), List.nil(), syms.methodClass),\n+                opParserType.tsym);\n+    }\n+\n+    \/**\n+     * Produces the top-level CodeModel attribute for a function operation, including the root op and the flattened set\n+     * of referenced bodies.\n+     *\n+     * @param funcOp the function operation to encode\n+     * @return the compound attribute suitable for storage in the CodeModel annotation\n+     *\/\n+    public Attribute.Compound toCodeModelAttribute(CoreOp.FuncOp funcOp) {\n+        Indexer<Value> valueIndexer = new Indexer<>();\n+        Indexer<Block> blockIndexer = new Indexer<>();\n+        Indexer<Body> bodyIndexer = new Indexer<>();\n+        Indexer<ExternalizedTypeElement> typeIndexer = new Indexer<>();\n+        ListBuffer<Attribute> allBodies = new ListBuffer<>();\n+        ListBuffer<Attribute> allTypes = new ListBuffer<>();\n+        return new Attribute.Compound(codeModelType, List.of(\n+                Pair.of(modelFuncOp, op(funcOp, valueIndexer, blockIndexer, bodyIndexer, typeIndexer, allBodies, allTypes)),\n+                Pair.of(modelBodies, new Attribute.Array(bodyArrayType, allBodies.toList())),\n+                Pair.of(modelTypes, new Attribute.Array(typeArrayType, allTypes.toList()))));\n+    }\n+\n+    \/**\n+     * Creates an invokedynamic bootstrap-bound dynamic method symbol for a given name, using the {@code fromAnnotation}\n+     * bootstrap.\n+     *\n+     * @param methodName the dynamic method name\n+     * @return a {@link DynamicMethodSymbol} configured with the bootstrap and signature\n+     *\/\n+    public DynamicMethodSymbol indyType(Name methodName) {\n+        return new DynamicMethodSymbol(\n+                methodName,\n+                syms.noSymbol,\n+                bsmFromAnnotation.asHandle(),\n+                fromAnnotation,\n+                new LoadableConstant[0]);\n+    }\n+\n+    Attribute.Constant stringConstant(String s) {\n+        return new Attribute.Constant(syms.stringType, s);\n+    }\n+\n+    Attribute.Array intArray(List<Integer> ints) {\n+        return new Attribute.Array(intArrayType, ints.map(i -> new Attribute.Constant(syms.intType, i)));\n+    }\n+\n+    Attribute.Compound op(Op op,\n+                          Indexer<Value> valueIndexer,\n+                          Indexer<Block> blockIndexer,\n+                          Indexer<Body> bodyIndexer,\n+                          Indexer<ExternalizedTypeElement> typeIndexer,\n+                          ListBuffer<Attribute> allBodies,\n+                          ListBuffer<Attribute> allTypes) {\n+        var lb = new ListBuffer<Pair<MethodSymbol, Attribute>>();\n+        lb.add(Pair.of(opName, stringConstant(op.externalizeOpName())));\n+        if (!op.operands().isEmpty()) {\n+            lb.add(Pair.of(opOperands, intArray(List.from(op.operands()).map(valueIndexer::indexOf))));\n+        }\n+        if (!op.successors().isEmpty()) {\n+            lb.add(Pair.of(opSuccessors, new Attribute.Array(blockReferenceArrayType, successors(List.from(op.successors()), valueIndexer, blockIndexer))));\n+        }\n+        if (op.resultType() != JavaType.VOID) {\n+            valueIndexer.indexOf(op.result());\n+            lb.add(Pair.of(opResultType, type(op.resultType().externalize(), typeIndexer, allTypes)));\n+        }\n+        if (op.location() instanceof Location loc) {\n+            if (loc.sourceRef() != null) {\n+                lb.add(Pair.of(opSourceRef, stringConstant(loc.sourceRef())));\n+            }\n+            lb.add(Pair.of(opLocation, intArray(List.of(loc.line(), loc.column()))));\n+        }\n+        ListBuffer<Attribute> attrs = new ListBuffer<>();\n+        op.externalize().entrySet().forEach(me -> {\n+            if (me.getKey().isEmpty()) {\n+                lb.add(Pair.of(opDefaultAttribute, stringConstant(AttributeMapper.toString(me.getValue()))));\n+            } else {\n+                attrs.add(stringConstant(me.getKey()));\n+                attrs.add(stringConstant(AttributeMapper.toString(me.getValue())));\n+            }\n+        });\n+        if (!attrs.isEmpty()) {\n+            lb.add(Pair.of(opAttributes, new Attribute.Array(stringArrayType, attrs.toList())));\n+        }\n+        if (!op.bodies().isEmpty()) {\n+            var bodies = List.from(op.bodies());\n+            bodies(bodies, valueIndexer, blockIndexer, bodyIndexer, typeIndexer, allBodies, allTypes);\n+            lb.add(Pair.of(opBodyDefinitions, intArray(bodies.map(bodyIndexer::indexOf))));\n+        }\n+        return new Attribute.Compound(opType, lb.toList());\n+    }\n+\n+    void bodies(List<Body> opBodies,\n+                Indexer<Value> valueIndexer,\n+                Indexer<Block> blockIndexer,\n+                Indexer<Body> bodyIndexer,\n+                Indexer<ExternalizedTypeElement> typeIndexer,\n+                ListBuffer<Attribute> allBodies,\n+                ListBuffer<Attribute> allTypes) {\n+        for (Body body : opBodies) {\n+            bodyIndexer.indexOf(body);\n+            var nested = new ListBuffer<Attribute>();\n+            allBodies.add(new Attribute.Compound(bodyType, List.of(Pair.of(bodyYieldType, type(body.yieldType().externalize(), typeIndexer, allTypes)),\n+                Pair.of(bodyBlocks, new Attribute.Array(blockArrayType, blocks(List.from(body.blocks()), valueIndexer, blockIndexer, bodyIndexer, typeIndexer, nested, allTypes))))));\n+            allBodies.appendList(nested);\n+        }\n+    }\n+\n+    List<Attribute> blocks(List<Block> blocks,\n+                           Indexer<Value> valueIndexer,\n+                           Indexer<Block> blockIndexer,\n+                           Indexer<Body> bodyIndexer,\n+                           Indexer<ExternalizedTypeElement> typeIndexer,\n+                           ListBuffer<Attribute> allBodies,\n+                           ListBuffer<Attribute> allTypes) {\n+        var lb = new ListBuffer<Attribute>();\n+        for (Block block : blocks) {\n+            blockIndexer.indexOf(block);\n+            block.parameters().forEach(valueIndexer::indexOf);\n+            var args = new ListBuffer<Pair<MethodSymbol, Attribute>>();\n+            args.add(Pair.of(blockOps, new Attribute.Array(opArrayType, List.from(block.ops()).map(op -> op(op, valueIndexer, blockIndexer, bodyIndexer, typeIndexer, allBodies, allTypes)))));\n+            if (!block.parameterTypes().isEmpty()) {\n+                args.add(Pair.of(blockParamTypes, new Attribute.Array(stringArrayType, List.from(block.parameterTypes()).map(pt -> type(pt.externalize(), typeIndexer, allTypes)))));\n+            }\n+            lb.add(new Attribute.Compound(blockType, args.toList()));\n+        }\n+        return lb.toList();\n+    }\n+\n+    Attribute.Constant type(ExternalizedTypeElement type,\n+                            Indexer<ExternalizedTypeElement> typeIndexer,\n+                            ListBuffer<Attribute> allTypes) {\n+        var args = type.arguments().stream().map(et -> type(et, typeIndexer, allTypes)).toArray(Attribute[]::new);\n+        int index = allTypes.size();\n+        allTypes.add(new Attribute.Compound(typeType, List.of(\n+                Pair.of(typeIdentifier, stringConstant(type.identifier())),\n+                Pair.of(typeArguments, new Attribute.Array(intArrayType, args)))));\n+        return new Attribute.Constant(syms.intType, index);\n+    }\n+\n+    List<Attribute> successors(List<Block.Reference> successors,\n+                               Indexer<Value> valueIndexer,\n+                               Indexer<Block> blockIndexer) {\n+        var lb = new ListBuffer<Attribute>();\n+        for (Block.Reference succ : successors) {\n+            var args = new ListBuffer<Pair<MethodSymbol, Attribute>>();\n+            args.add(Pair.of(blockReferenceTargetBlock, new Attribute.Constant(syms.intType, blockIndexer.indexOf(succ.targetBlock()))));\n+            if (!succ.arguments().isEmpty()) {\n+                args.add(Pair.of(blockReferenceArguments, intArray(List.from(succ.arguments()).map(valueIndexer::indexOf))));\n+            }\n+            lb.add(new Attribute.Compound(blockReferenceType, args.toList()));\n+        }\n+        return lb.toList();\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelSymbols.java","additions":333,"deletions":0,"binary":false,"changes":333,"status":"added"},{"patch":"@@ -139,0 +139,1 @@\n+    private final CodeModelSymbols cmSyms;\n@@ -167,0 +168,1 @@\n+        cmSyms = new CodeModelSymbols(context);\n@@ -362,0 +364,6 @@\n+    \/**\n+     * Defines how the generated code model for a reflected method or lambda is persisted in the containing class.\n+     * <p>\n+     * The storage strategy can be selected via the compiler option {@code codeModelStorageOption}. If the option is not\n+     * provided, the default is {@link #CODE_BUILDER}.\n+     *\/\n@@ -363,1 +371,19 @@\n-        CODE_BUILDER;\n+\n+        \/**\n+         * Store the model as builder code.\n+         * <p>\n+         * With this strategy, the compiler emits a private static synthetic method whose body contains Java statements\n+         * that reconstruct the code model using the public builder API (via {@code OpBuilder}). At runtime, invoking\n+         * the method executes the builder code and returns the model.\n+         *\/\n+        CODE_BUILDER,\n+\n+        \/**\n+         * Store the model as a classfile attribute and load it at runtime.\n+         * <p>\n+         * With this strategy, the compiler attaches a code-model attribute to the method (via\n+         * {@code cmSyms.toCodeModelAttribute(op)}). The synthesized helper method then returns the model by invoking a\n+         * bootstrap (via the {@link indyType} for the method name) that reads and materializes the attribute at\n+         * runtime.\n+         *\/\n+        CODE_MODEL_ATTRIBUTE;\n@@ -380,9 +406,19 @@\n-        \/\/ Create the method body\n-        \/\/ Code model is stored as code that builds the code model\n-        \/\/ using the builder API and public APIs\n-        var opBuilder = OpBuilder.createBuilderFunction(op,\n-                b -> b.op(JavaOp.fieldLoad(\n-                        FieldRef.field(JavaOp.class, \"JAVA_DIALECT_FACTORY\", DialectFactory.class))));\n-        var codeModelTranslator = new CodeModelTranslator();\n-        var body = codeModelTranslator.translateFuncOp(opBuilder, ms);\n-\n+        var body = switch (codeModelStorageOption) {\n+            case CODE_BUILDER -> {\n+                \/\/ Create the method body\n+                \/\/ Code model is stored as code that builds the code model\n+                \/\/ using the builder API and public APIs\n+                var opBuilder = OpBuilder.createBuilderFunction(op,\n+                        b -> b.op(JavaOp.fieldLoad(\n+                                FieldRef.field(JavaOp.class, \"JAVA_DIALECT_FACTORY\", DialectFactory.class))));\n+                var codeModelTranslator = new CodeModelTranslator();\n+                yield codeModelTranslator.translateFuncOp(opBuilder, ms);\n+            }\n+            case CODE_MODEL_ATTRIBUTE -> {\n+                \/\/ create code model annotation\n+                ms.appendAttributes(com.sun.tools.javac.util.List.of(cmSyms.toCodeModelAttribute(op)));\n+                \/\/ create method building the model from annotation\n+                \/\/ return OpParser.fromCallerAnnotation();\n+                yield make.Return(make.App(make.Ident(cmSyms.indyType(methodName))));\n+            }\n+        };\n@@ -391,0 +427,1 @@\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":47,"deletions":10,"binary":false,"changes":57,"status":"modified"}]}