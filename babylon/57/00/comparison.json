{"files":[{"patch":"@@ -290,0 +290,44 @@\n+    \/**\n+     * Computes values captured by this body. A captured value is a value that dominates\n+     * this body and is used by a descendant operation of this body.\n+     * <p>\n+     * The order of the captured values is first use encountered in depth\n+     * first search of this body's descendant operations.\n+     *\n+     * @return the list of captured values, modifiable\n+     *\/\n+    public List<Value> capturedValues() {\n+        Set<Value> cvs = new LinkedHashSet<>();\n+\n+        capturedValues(cvs, new ArrayDeque<>(), this);\n+        return new ArrayList<>(cvs);\n+    }\n+\n+    static void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Body body) {\n+        bodyStack.push(body);\n+\n+        for (Block b : body.blocks()) {\n+            for (Op op : b.ops()) {\n+                for (Body childBody : op.bodies()) {\n+                    capturedValues(capturedValues, bodyStack, childBody);\n+                }\n+\n+                for (Value a : op.operands()) {\n+                    if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n+                        capturedValues.add(a);\n+                    }\n+                }\n+\n+                for (Block.Reference s : op.successors()) {\n+                    for (Value a : s.arguments()) {\n+                        if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n+                            capturedValues.add(a);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        bodyStack.pop();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Body.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -98,1 +98,4 @@\n-         * {@return the captured values}\n+         * Computes values captured by this invokable operation's body.\n+         *\n+         * @return the captured values.\n+         * @see Body#capturedValues()\n@@ -393,0 +396,23 @@\n+    \/**\n+     * Computes values captured by this operation. A captured value is a value that dominates\n+     * this operation and is used by a descendant operation.\n+     * <p>\n+     * The order of the captured values is first use encountered in depth\n+     * first search of this operation's descendant operations.\n+     *\n+     * @return the list of captured values, modifiable\n+     * @see Body#capturedValues()\n+     *\/\n+    public List<Value> capturedValues() {\n+        Set<Value> cvs = new LinkedHashSet<>();\n+\n+        capturedValues(cvs, new ArrayDeque<>(), this);\n+        return new ArrayList<>(cvs);\n+    }\n+\n+    static void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Op op) {\n+        for (Body childBody : op.bodies()) {\n+            Body.capturedValues(capturedValues, bodyStack, childBody);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Op.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.ArrayList;\n@@ -42,1 +43,1 @@\n-     * Constructs the quoted form of a given invokable operation.\n+     * Constructs the quoted form of a given operation.\n@@ -51,1 +52,7 @@\n-     * Constructs the quoted form of a given invokable operation.\n+     * Constructs the quoted form of a given operation.\n+     * <p>\n+     * The captured values key set must have the same elements and same encounter order as\n+     * operation's captured values, specifically the following expression should evaluate to true:\n+     * {@snippet lang=java :\n+     * op.capturedValues().equals(new ArrayList<>(capturedValues.keySet()));\n+     * }\n@@ -53,2 +60,3 @@\n-     * @param op             the invokable operation.\n-     * @param capturedValues the capture values referred to by the operation\n+     * @param op             the operation.\n+     * @param capturedValues the captured values referred to by the operation\n+     * @see Op#capturedValues()\n@@ -57,0 +65,3 @@\n+        \/\/ @@@ This check is potentially expensive, remove or keep as assert?\n+        \/\/ @@@ Or make Quoted an interface, with a module private implementation?\n+        assert op.capturedValues().equals(new ArrayList<>(capturedValues.keySet()));\n@@ -62,1 +73,1 @@\n-     * Returns the invokable operation.\n+     * Returns the operation.\n@@ -64,1 +75,1 @@\n-     * @return the invokable operation.\n+     * @return the operation.\n@@ -72,0 +83,6 @@\n+     * <p>\n+     * The captured values key set has the same elements and same encounter order as\n+     * operation's captured values, specifically the following expression evaluates to true:\n+     * {@snippet lang=java :\n+     * op().capturedValues().equals(new ArrayList<>(capturedValues().keySet()));\n+     * }\n@@ -78,4 +95,0 @@\n-\n-    public static Quoted quote(Op t) {\n-        return new Quoted(t);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Quoted.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -439,1 +439,1 @@\n-                    .collect(toMap(v -> v, oc::getValue));\n+                    .collect(toMap(v -> v, oc::getValue, (v, _) -> v, LinkedHashMap::new));\n@@ -443,1 +443,1 @@\n-                    .collect(toMap(v -> v, oc::getValue));\n+                    .collect(toMap(v -> v, oc::getValue, (v, _) -> v, LinkedHashMap::new));\n@@ -453,1 +453,1 @@\n-                        (proxy, method, args) -> {\n+                        (_, method, args) -> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-        \/\/ Returns the set of values used in but declared outside the lambda's body\n+        @Override\n@@ -395,24 +395,1 @@\n-            Set<Value> cvs = new LinkedHashSet<>();\n-\n-            capturedValues(cvs, new ArrayDeque<>(), quotedBody);\n-            return new ArrayList<>(cvs);\n-        }\n-\n-        void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Body body) {\n-            bodyStack.push(body);\n-\n-            for (Block b : body.blocks()) {\n-                for (Op op : b.ops()) {\n-                    for (Body childBody : op.bodies()) {\n-                        capturedValues(capturedValues, bodyStack, childBody);\n-                    }\n-\n-                    for (Value a : op.operands()) {\n-                        if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n-                            capturedValues.add(a);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            bodyStack.pop();\n+            return quotedBody.capturedValues();\n@@ -510,1 +487,0 @@\n-        \/\/ Returns the set of values used in but declared outside the lambda's body\n@@ -513,25 +489,1 @@\n-            Set<Value> cvs = new LinkedHashSet<>();\n-            Body body = body();\n-\n-            capturedValues(cvs, new ArrayDeque<>(), body);\n-            return new ArrayList<>(cvs);\n-        }\n-\n-        void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Body body) {\n-            bodyStack.push(body);\n-\n-            for (Block b : body.blocks()) {\n-                for (Op op : b.ops()) {\n-                    for (Body childBody : op.bodies()) {\n-                        capturedValues(capturedValues, bodyStack, childBody);\n-                    }\n-\n-                    for (Value a : op.operands()) {\n-                        if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n-                            capturedValues.add(a);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            bodyStack.pop();\n+            return body.capturedValues();\n@@ -626,1 +578,0 @@\n-        \/\/ Returns the set of values used in but declared outside the lambda's body\n@@ -629,25 +580,1 @@\n-            Set<Value> cvs = new LinkedHashSet<>();\n-            Body body = body();\n-\n-            capturedValues(cvs, new ArrayDeque<>(), body);\n-            return new ArrayList<>(cvs);\n-        }\n-\n-        void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Body body) {\n-            bodyStack.push(body);\n-\n-            for (Block b : body.blocks()) {\n-                for (Op op : b.ops()) {\n-                    for (Body childBody : op.bodies()) {\n-                        capturedValues(capturedValues, bodyStack, childBody);\n-                    }\n-\n-                    for (Value a : op.operands()) {\n-                        if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n-                            capturedValues.add(a);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            bodyStack.pop();\n+            return body.capturedValues();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":4,"deletions":77,"binary":false,"changes":81,"status":"modified"}]}