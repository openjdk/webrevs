{"files":[{"patch":"@@ -308,0 +308,4 @@\n+    public static boolean eq(char l, char r) {\n+        return l == r;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -648,5 +648,1 @@\n-        public Value toValue(JCTree tree) {\n-            return toValue(tree, Type.noType);\n-        }\n-\n-        public Value toValue(JCTree tree, Type target) {\n+        public Value toValue(JCExpression expression, Type targetType) {\n@@ -656,2 +652,2 @@\n-                pt = target;\n-                scan(tree);\n+                pt = targetType;\n+                scan(expression);\n@@ -659,1 +655,1 @@\n-                        coerce(result, tree.type, target) :\n+                        coerce(result, expression.type, targetType) :\n@@ -666,0 +662,10 @@\n+        public Value toValue(JCExpression expression) {\n+            return toValue(expression, Type.noType);\n+        }\n+\n+        public Value toValue(JCTree.JCStatement statement) {\n+            result = null; \/\/ reset\n+            scan(statement);\n+            return result;\n+        }\n+\n@@ -1210,0 +1216,2 @@\n+                        \/\/ @@@ when we support ANYPATTERN, we must add result of toValue only if it's non-null\n+                        \/\/ because passing null to recordPattern methods will cause an error\n@@ -1372,1 +1380,1 @@\n-                Value exprVal = toValue(tree.body, tree.getDescriptorType(types).getReturnType());\n+                Value exprVal = toValue(((JCExpression) tree.body), tree.getDescriptorType(types).getReturnType());\n@@ -1382,1 +1390,1 @@\n-                    toValue(tree.body);\n+                    toValue(((JCTree.JCStatement) tree.body));\n@@ -1529,2 +1537,4 @@\n-                        \/\/ @@@ Conversion of localTarget\n-                        if (ccl.expr.type.isPrimitive()) {\n+                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                        \/\/ so, we convert constant to the type of the selector expression\n+                        expr = convert(expr, tree.selector.type);\n+                        if (tree.selector.type.isPrimitive()) {\n@@ -1544,1 +1554,1 @@\n-                            \/\/ @@@ Conversion of localTarget\n+                            expr = convert(expr, tree.selector.type);\n@@ -1546,1 +1556,1 @@\n-                            if (ccl.expr.type.isPrimitive()) {\n+                            if (tree.selector.type.isPrimitive()) {\n@@ -1587,3 +1597,2 @@\n-                        if (c.body instanceof JCExpression) {\n-                            \/\/ Yield the boolean result of the condition\n-                            Value bodyVal = toValue(c.body, yieldType);\n+                        if (c.body instanceof JCTree.JCExpression e) {\n+                            Value bodyVal = toValue(e, yieldType);\n@@ -1591,1 +1600,1 @@\n-                        } else {\n+                        } else if (c.body instanceof JCTree.JCStatement s){\n@@ -1596,1 +1605,1 @@\n-                                Value bodyVal = toValue(c.body);\n+                                Value bodyVal = toValue(s);\n@@ -2009,1 +2018,5 @@\n-                    rValues.add(toValue(resource));\n+                    if (resource instanceof JCTree.JCExpression e) {\n+                        rValues.add(toValue(e));\n+                    } else if (resource instanceof JCTree.JCStatement s) {\n+                        rValues.add(toValue(s));\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -4,0 +4,4 @@\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.StringWriter;\n+import java.lang.invoke.MethodHandles;\n@@ -8,0 +12,1 @@\n+import java.lang.reflect.code.writer.OpWriter;\n@@ -9,1 +14,1 @@\n-import java.util.Optional;\n+import java.util.*;\n@@ -18,2 +23,16 @@\n-    \/\/ TODO more testing\n-    \/\/  cover cases where MatchException will be thrown\n+    @Test\n+    void testCasePatternGuard() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternGuard\");\n+        Object[] args = {\"c++\", \"java\", new R(8), new R(2L), new R(3f), new R(4.0)};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), casePatternGuard(arg));\n+        }\n+    }\n+    @CodeReflection\n+    static String casePatternGuard(Object obj) {\n+        return switch (obj) {\n+            case String s when s.length() > 3 -> \"str with length > %d\".formatted(s.length());\n+            case R(Number n) when n.getClass().equals(Double.class) -> \"R(Double)\";\n+            default -> \"else\";\n+        };\n+    }\n@@ -21,0 +40,11 @@\n+    @Test\n+    void testCaseRecordPattern() {\n+        \/\/ @@@ new R(null) must match the pattern R(Number c), but it doesn't\n+        \/\/ @@@ test with generic record\n+        CoreOp.FuncOp lmodel = lower(\"caseRecordPattern\");\n+        Object[] args = {new R(8), new R(1.0), new R(2L), \"abc\"};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseRecordPattern(arg));\n+        }\n+    }\n+    record R(Number n) {}\n@@ -22,6 +52,86 @@\n-    public static Object f1(String r) {\n-        return switch (r) {\n-            case \"FOO\" -> \"FOO\";\n-            case \"BAR\" -> \"FOO\";\n-            case \"BAZ\" -> \"FOO\";\n-            default -> \"\";\n+    static String caseRecordPattern(Object o) {\n+        return switch (o) {\n+            case R(Number _) -> \"R(_)\";\n+            default -> \"else\";\n+        };\n+    }\n+    @Test\n+    void testCaseTypePattern() {\n+        CoreOp.FuncOp lmodel = lower(\"caseTypePattern\");\n+        Object[] args = {\"str\", new ArrayList<>(), new int[]{}, new Stack[][]{}, new Collection[][][]{}, 8, 'x'};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseTypePattern(arg));\n+        }\n+    }\n+    @CodeReflection\n+    static String caseTypePattern(Object o) {\n+        return switch (o) {\n+            case String _ -> \"String\"; \/\/ class\n+            case RandomAccess _ -> \"RandomAccess\"; \/\/ interface\n+            case int[] _ -> \"int[]\"; \/\/ array primitive\n+            case Stack[][] _ -> \"Stack[][]\"; \/\/ array class\n+            case Collection[][][] _ -> \"Collection[][][]\"; \/\/ array interface\n+            case final Number n -> \"Number\"; \/\/ final modifier\n+            default -> \"something else\";\n+        };\n+    }\n+\n+    @Test\n+    void testCasePatternWithCaseConstant() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternWithCaseConstant\");\n+        int[] args = {42, 43, -44, 0};\n+        for (int arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternWithCaseConstant(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String casePatternWithCaseConstant(Integer a) {\n+        return switch (a) {\n+            case 42 -> \"forty two\";\n+            \/\/ @@@ case int will not match, because of the way InstanceOfOp is interpreted\n+            case Integer i when i > 0 -> \"positive int\";\n+            case Integer i when i < 0 -> \"negative int\";\n+            default -> \"zero\";\n+        };\n+    }\n+\n+    \/\/ @Test\n+    void testCasePatternMultiLabel() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternMultiLabel\");\n+        Object[] args = {(byte) 1, (short) 2, 'A', 3, 4L, 5f, 6d, true, \"str\"};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternMultiLabel(arg));\n+        }\n+    }\n+    \/\/ @CodeReflection\n+    \/\/ code model for such as code is not supported\n+    \/\/ @@@ support this case and uncomment its test\n+    private static String casePatternMultiLabel(Object o) {\n+        return switch (o) {\n+            case Integer _, Long _, Character _, Byte _, Short _-> \"integral type\";\n+            default -> \"non integral type\";\n+        };\n+    }\n+\n+    @Test\n+    void testCasePatternThrow() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternThrow\");\n+\n+        Object[] args = {Byte.MAX_VALUE, Short.MIN_VALUE, 0, 1L, 11f, 22d};\n+        for (Object arg : args) {\n+            Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, arg));\n+        }\n+\n+        Object[] args2 = {\"abc\", List.of()};\n+        for (Object arg : args2) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternThrow(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternThrow(Object o) {\n+        return switch (o) {\n+            case Number n -> throw new IllegalArgumentException();\n+            case String s -> \"a string\";\n+            default -> o.getClass().getName();\n@@ -32,2 +142,6 @@\n-    public void test1() {\n-        CoreOp.FuncOp lf = lower(\"f1\");\n+    void testCasePatternBehaviorIsSyntaxIndependent() {\n+        CoreOp.FuncOp ruleExpression = lower(\"casePatternRuleExpression\");\n+        CoreOp.FuncOp ruleBlock = lower(\"casePatternRuleBlock\");\n+        CoreOp.FuncOp statement = lower(\"casePatternStatement\");\n+\n+        String[] args = {\"FOO\", \"BAR\", \"BAZ\", \"OTHER\"};\n@@ -35,4 +149,4 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f1(\"FOO\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f1(\"BAR\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAZ\"), f1(\"BAZ\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f1(\"ELSE\"));\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+        }\n@@ -42,3 +156,13 @@\n-    public static Object f2(String r) { \/\/ switch expr with fallthrough\n-        return switch (r) {\n-            case \"FOO\" : {\n+    private static String casePatternRuleExpression(Object o) {\n+        return switch (o) {\n+            case Integer i -> \"integer\";\n+            case String s -> \"string\";\n+            default -> \"not integer nor string\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternRuleBlock(Object o) {\n+        return switch (o) {\n+            case Integer i -> {\n+                yield \"integer\";\n@@ -46,2 +170,5 @@\n-            case \"BAR\" : {\n-                yield \"2\";\n+            case String s -> {\n+                yield \"string\";\n+            }\n+            default -> {\n+                yield \"not integer nor string\";\n@@ -49,1 +176,9 @@\n-            default : yield \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternStatement(Object o) {\n+        return switch (o) {\n+            case Integer i: yield \"integer\";\n+            case String s: yield \"string\";\n+            default: yield \"not integer nor string\";\n@@ -54,2 +189,6 @@\n-    public void test2() {\n-        CoreOp.FuncOp lf = lower(\"f2\");\n+    void testCaseConstantOtherKindsOfExpr() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantOtherKindsOfExpr\");\n+        for (int i = 0; i < 14; i++) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, i), caseConstantOtherKindsOfExpr(i));\n+        }\n+    }\n@@ -57,3 +196,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f2(\"FOO\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f2(\"BAR\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f2(\"ELSE\"));\n+    static class Constants {\n+        static final int c1 = 12;\n@@ -63,5 +201,17 @@\n-    \/\/ null is handled, when selector expr is null the switch will complete normally\n-    private static String f3(String s) {\n-        return switch (s) {\n-            case null -> \"null\";\n-            default -> \"default\";\n+    private static String caseConstantOtherKindsOfExpr(int i) {\n+        final int eleven = 11;\n+        return switch (i) {\n+            case 1 & 0xF -> \"1\";\n+            case 4>>1 -> \"2\";\n+            case (int) 3L -> \"3\";\n+            case 2<<1 -> \"4\";\n+            case 10 \/ 2 -> \"5\";\n+            case 12 - 6 -> \"6\";\n+            case 3 + 4 -> \"7\";\n+            case 2 * 2 * 2 -> \"8\";\n+            case 8 | 1 -> \"9\";\n+            case (10) -> \"10\";\n+            case eleven -> \"11\";\n+            case Constants.c1 -> String.valueOf(Constants.c1);\n+            case 1 > 0 ? 13 : 133 -> \"13\";\n+            default -> \"an int\";\n@@ -72,2 +222,6 @@\n-    public void test3() {\n-        CoreOp.FuncOp lf = lower(\"f3\");\n+    void testCaseConstantEnum() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantEnum\");\n+        for (Day day : Day.values()) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, day), caseConstantEnum(day));\n+        }\n+    }\n@@ -75,2 +229,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, new Object[]{null}), f3(null));\n+    enum Day {\n+        MON, TUE, WED, THU, FRI, SAT, SUN\n@@ -80,2 +234,33 @@\n-    \/\/ null not handled, when selector expr is null it will throw NPE\n-    private static String f4(String s) {\n+    private static int caseConstantEnum(Day d) {\n+        return switch (d) {\n+            case MON, FRI, SUN -> 6;\n+            case TUE -> 7;\n+            case THU, SAT -> 8;\n+            case WED -> 9;\n+        };\n+    }\n+\n+    @Test\n+    void testCaseConstantFallThrough() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantFallThrough\");\n+        char[] args = {'A', 'B', 'C'};\n+        for (char arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantFallThrough(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static String caseConstantFallThrough(char c) {\n+        return switch (c) {\n+            case 'A':\n+            case 'B':\n+                yield \"A or B\";\n+            default:\n+                yield \"Neither A nor B\";\n+        };\n+    }\n+\n+    \/\/ @CodeReflection\n+    \/\/ compiler code doesn't support case null, default\n+    \/\/ @@@ support such as case and test the switch expression lowering for this case\n+    private static String caseConstantNullAndDefault(String s) {\n@@ -83,1 +268,2 @@\n-            default -> \"default\";\n+            case \"abc\" -> \"alphabet\";\n+            case null, default -> \"null or default\";\n@@ -88,2 +274,7 @@\n-    public void test4() {\n-        CoreOp.FuncOp lf = lower(\"f4\");\n+    void testCaseConstantNullLabel() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantNullLabel\");\n+        String[] args = {null, \"non null\"};\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantNullLabel(arg));\n+        }\n+    }\n@@ -91,3 +282,16 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n-        Assert.assertThrows(NullPointerException.class, () -> f4(null));\n-        Assert.assertThrows(NullPointerException.class, () -> Interpreter.invoke(lf, new Object[]{null}));\n+    @CodeReflection\n+    private static String caseConstantNullLabel(String s) {\n+        return switch (s) {\n+            case null -> \"null\";\n+            default -> \"non null\";\n+        };\n+    }\n+\n+    @Test\n+    void testCaseConstantThrow() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantThrow\");\n+        Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, 8));\n+        int[] args = {9, 10};\n+        for (int arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantThrow(arg));\n+        }\n@@ -97,1 +301,1 @@\n-    private static String f5(int i) {\n+    private static String caseConstantThrow(Integer i) {\n@@ -99,3 +303,3 @@\n-            case 1 -> \"1\";\n-            case 2 -> \"2\";\n-            default -> \"default\";\n+            case 8 -> throw new IllegalArgumentException();\n+            case 9 -> \"NINE\";\n+            default -> \"An integer\";\n@@ -106,2 +310,7 @@\n-    public void test5() {\n-        CoreOp.FuncOp lf = lower(\"f5\");\n+    void testCaseConstantMultiLabels() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantMultiLabels\");\n+        char[] args = {'a', 'e', 'i', 'o', 'u', 'j', 'p', 'g'};\n+        for (char arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantMultiLabels(arg));\n+        }\n+    }\n@@ -109,3 +318,6 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, 1), f5(1));\n-        Assert.assertEquals(Interpreter.invoke(lf, 2), f5(2));\n-        Assert.assertEquals(Interpreter.invoke(lf, 99), f5(99));\n+    @CodeReflection\n+    private static String caseConstantMultiLabels(char c) {\n+        return switch (Character.toLowerCase(c)) {\n+            case 'a', 'e', 'i', 'o', 'u': yield \"vowel\";\n+            default: yield \"consonant\";\n+        };\n@@ -114,4 +326,5 @@\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n+    @Test\n+    void testCaseConstantBehaviorIsSyntaxIndependent() {\n+        CoreOp.FuncOp ruleExpression = lower(\"caseConstantRuleExpression\");\n+        CoreOp.FuncOp ruleBlock = lower(\"caseConstantRuleBlock\");\n+        CoreOp.FuncOp statement = lower(\"caseConstantStatement\");\n@@ -119,1 +332,44 @@\n-        return om.get().getCodeModel().get();\n+        String[] args = {\"FOO\", \"BAR\", \"BAZ\", \"OTHER\"};\n+\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static String caseConstantRuleExpression(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"BAR\";\n+            case \"BAR\" -> \"BAZ\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    public static String caseConstantRuleBlock(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> {\n+                yield \"BAR\";\n+            }\n+            case \"BAR\" -> {\n+                yield \"BAZ\";\n+            }\n+            case \"BAZ\" -> {\n+                yield \"FOO\";\n+            }\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+\n+    @CodeReflection\n+    private static String caseConstantStatement(String s) {\n+        return switch (s) {\n+            case \"FOO\": yield \"BAR\";\n+            case \"BAR\": yield \"BAZ\";\n+            case \"BAZ\": yield \"FOO\";\n+            default: yield \"\";\n+        };\n@@ -123,1 +379,1 @@\n-        return lower(getFuncOp(methodName));\n+        return lower(getCodeModel(methodName));\n@@ -127,1 +383,1 @@\n-        f.writeTo(System.out);\n+        writeModel(f, System.out, OpWriter.LocationOption.DROP_LOCATION);\n@@ -130,2 +386,1 @@\n-\n-        lf.writeTo(System.out);\n+        writeModel(lf, System.out, OpWriter.LocationOption.DROP_LOCATION);\n@@ -135,0 +390,18 @@\n+\n+    private static void writeModel(CoreOp.FuncOp f, OutputStream os, OpWriter.Option... options) {\n+        StringWriter sw = new StringWriter();\n+        new OpWriter(sw, options).writeOp(f);\n+        try {\n+            os.write(sw.toString().getBytes());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static CoreOp.FuncOp getCodeModel(String methodName) {\n+        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":334,"deletions":61,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -0,0 +1,633 @@\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @build SwitchExpressionTest2\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester SwitchExpressionTest2\n+ *\/\n+public class SwitchExpressionTest2 {\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantRuleExpression\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %7 : java.lang.String = constant @\"BAR\";\n+                        yield %7;\n+                    }\n+                    (%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"BAZ\";\n+                        yield %11;\n+                    }\n+                    (%12 : java.lang.String)boolean -> {\n+                        %13 : java.lang.String = constant @\"BAZ\";\n+                        %14 : boolean = invoke %12 %13 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %14;\n+                    }\n+                    ()java.lang.String -> {\n+                        %15 : java.lang.String = constant @\"FOO\";\n+                        yield %15;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %16 : java.lang.String = constant @\"\";\n+                        yield %16;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    public static String caseConstantRuleExpression(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"BAR\";\n+            case \"BAR\" -> \"BAZ\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantRuleBlock\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %7 : java.lang.String = constant @\"BAR\";\n+                        java.yield %7;\n+                    }\n+                    (%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"BAZ\";\n+                        java.yield %11;\n+                    }\n+                    (%12 : java.lang.String)boolean -> {\n+                        %13 : java.lang.String = constant @\"BAZ\";\n+                        %14 : boolean = invoke %12 %13 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %14;\n+                    }\n+                    ()java.lang.String -> {\n+                        %15 : java.lang.String = constant @\"FOO\";\n+                        java.yield %15;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %16 : java.lang.String = constant @\"\";\n+                        java.yield %16;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    public static String caseConstantRuleBlock(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> {\n+                yield \"BAR\";\n+            }\n+            case \"BAR\" -> {\n+                yield \"BAZ\";\n+            }\n+            case \"BAZ\" -> {\n+                yield \"FOO\";\n+            }\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantStatement\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %7 : java.lang.String = constant @\"BAR\";\n+                        java.yield %7;\n+                    }\n+                    (%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"BAZ\";\n+                        java.yield %11;\n+                    }\n+                    (%12 : java.lang.String)boolean -> {\n+                        %13 : java.lang.String = constant @\"BAZ\";\n+                        %14 : boolean = invoke %12 %13 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %14;\n+                    }\n+                    ()java.lang.String -> {\n+                        %15 : java.lang.String = constant @\"FOO\";\n+                        java.yield %15;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %16 : java.lang.String = constant @\"\";\n+                        java.yield %16;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantStatement(String s) {\n+        return switch (s) {\n+            case \"FOO\": yield \"BAR\";\n+            case \"BAR\": yield \"BAZ\";\n+            case \"BAZ\": yield \"FOO\";\n+            default: yield \"\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantMultiLabels\" (%0 : char)java.lang.String -> {\n+                %1 : Var<char> = var %0 @\"c\";\n+                %2 : char = var.load %1;\n+                %3 : char = invoke %2 @\"java.lang.Character::toLowerCase(char)char\";\n+                %4 : java.lang.String = java.switch.expression %3\n+                    (%5 : char)boolean -> {\n+                        %6 : boolean = java.cor\n+                            ()boolean -> {\n+                                %7 : char = constant @\"a\";\n+                                %8 : boolean = eq %5 %7;\n+                                yield %8;\n+                            }\n+                            ()boolean -> {\n+                                %9 : char = constant @\"e\";\n+                                %10 : boolean = eq %5 %9;\n+                                yield %10;\n+                            }\n+                            ()boolean -> {\n+                                %11 : char = constant @\"i\";\n+                                %12 : boolean = eq %5 %11;\n+                                yield %12;\n+                            }\n+                            ()boolean -> {\n+                                %13 : char = constant @\"o\";\n+                                %14 : boolean = eq %5 %13;\n+                                yield %14;\n+                            }\n+                            ()boolean -> {\n+                                %15 : char = constant @\"u\";\n+                                %16 : boolean = eq %5 %15;\n+                                yield %16;\n+                            };\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %17 : java.lang.String = constant @\"vowel\";\n+                        java.yield %17;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %18 : java.lang.String = constant @\"consonant\";\n+                        java.yield %18;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantMultiLabels(char c) {\n+        return switch (Character.toLowerCase(c)) {\n+            case 'a', 'e', 'i', 'o', 'u': yield \"vowel\";\n+            default: yield \"consonant\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantThrow\" (%0 : java.lang.Integer)java.lang.String -> {\n+                %1 : Var<java.lang.Integer> = var %0 @\"i\";\n+                %2 : java.lang.Integer = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : java.lang.Integer)boolean -> {\n+                        %5 : int = constant @\"8\";\n+                        %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %7 : boolean = invoke %4 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.IllegalArgumentException = new @\"func<java.lang.IllegalArgumentException>\";\n+                        throw %8;\n+                    }\n+                    (%9 : java.lang.Integer)boolean -> {\n+                        %10 : int = constant @\"9\";\n+                        %11 : java.lang.Integer = invoke %10 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %12 : boolean = invoke %9 %11 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %12;\n+                    }\n+                    ()java.lang.String -> {\n+                        %13 : java.lang.String = constant @\"NINE\";\n+                        yield %13;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %14 : java.lang.String = constant @\"An integer\";\n+                        yield %14;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantThrow(Integer i) {\n+        return switch (i) {\n+            case 8 -> throw new IllegalArgumentException();\n+            case 9 -> \"NINE\";\n+            default -> \"An integer\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantNullLabel\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.Object = constant @null;\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %7 : java.lang.String = constant @\"null\";\n+                        yield %7;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @\"non null\";\n+                        yield %8;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantNullLabel(String s) {\n+        return switch (s) {\n+            case null -> \"null\";\n+            default -> \"non null\";\n+        };\n+    }\n+\n+    \/\/ @CodeReflection\n+    \/\/ compiler code doesn't support case null, default\n+    \/\/ @@@ support such as case and test the switch expression lowering for this case\n+    private static String caseConstantNullAndDefault(String s) {\n+        return switch (s) {\n+            case \"abc\" -> \"alphabet\";\n+            case null, default -> \"null or default\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantFallThrough\" (%0 : char)java.lang.String -> {\n+                %1 : Var<char> = var %0 @\"c\";\n+                %2 : char = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : char)boolean -> {\n+                        %5 : char = constant @\"A\";\n+                        %6 : boolean = eq %4 %5;\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        java.switch.fallthrough;\n+                    }\n+                    (%7 : char)boolean -> {\n+                        %8 : char = constant @\"B\";\n+                        %9 : boolean = eq %7 %8;\n+                        yield %9;\n+                    }\n+                    ()java.lang.String -> {\n+                        %10 : java.lang.String = constant @\"A or B\";\n+                        java.yield %10;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"Neither A nor B\";\n+                        java.yield %11;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantFallThrough(char c) {\n+        return switch (c) {\n+            case 'A':\n+            case 'B':\n+                yield \"A or B\";\n+            default:\n+                yield \"Neither A nor B\";\n+        };\n+    }\n+\n+    enum Day {\n+        MON, TUE, WED, THU, FRI, SAT, SUN\n+    }\n+    @IR(\"\"\"\n+            func @\"caseConstantEnum\" (%0 : SwitchExpressionTest2$Day)int -> {\n+                %1 : Var<SwitchExpressionTest2$Day> = var %0 @\"d\";\n+                %2 : SwitchExpressionTest2$Day = var.load %1;\n+                %3 : int = java.switch.expression %2\n+                    (%4 : SwitchExpressionTest2$Day)boolean -> {\n+                        %5 : boolean = java.cor\n+                            ()boolean -> {\n+                                %6 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::MON()SwitchExpressionTest2$Day\";\n+                                %7 : boolean = invoke %4 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %7;\n+                            }\n+                            ()boolean -> {\n+                                %8 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::FRI()SwitchExpressionTest2$Day\";\n+                                %9 : boolean = invoke %4 %8 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %9;\n+                            }\n+                            ()boolean -> {\n+                                %10 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::SUN()SwitchExpressionTest2$Day\";\n+                                %11 : boolean = invoke %4 %10 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %11;\n+                            };\n+                        yield %5;\n+                    }\n+                    ()int -> {\n+                        %12 : int = constant @\"6\";\n+                        yield %12;\n+                    }\n+                    (%13 : SwitchExpressionTest2$Day)boolean -> {\n+                        %14 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::TUE()SwitchExpressionTest2$Day\";\n+                        %15 : boolean = invoke %13 %14 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %15;\n+                    }\n+                    ()int -> {\n+                        %16 : int = constant @\"7\";\n+                        yield %16;\n+                    }\n+                    (%17 : SwitchExpressionTest2$Day)boolean -> {\n+                        %18 : boolean = java.cor\n+                            ()boolean -> {\n+                                %19 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::THU()SwitchExpressionTest2$Day\";\n+                                %20 : boolean = invoke %17 %19 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %20;\n+                            }\n+                            ()boolean -> {\n+                                %21 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::SAT()SwitchExpressionTest2$Day\";\n+                                %22 : boolean = invoke %17 %21 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %22;\n+                            };\n+                        yield %18;\n+                    }\n+                    ()int -> {\n+                        %23 : int = constant @\"8\";\n+                        yield %23;\n+                    }\n+                    (%24 : SwitchExpressionTest2$Day)boolean -> {\n+                        %25 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::WED()SwitchExpressionTest2$Day\";\n+                        %26 : boolean = invoke %24 %25 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %26;\n+                    }\n+                    ()int -> {\n+                        %27 : int = constant @\"9\";\n+                        yield %27;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static int caseConstantEnum(Day d) {\n+        return switch (d) {\n+            case MON, FRI, SUN -> 6;\n+            case TUE -> 7;\n+            case THU, SAT -> 8;\n+            case WED -> 9;\n+        };\n+    }\n+\n+    static class Constants {\n+        static final int c1 = 12;\n+    }\n+    @IR(\"\"\"\n+            func @\"caseConstantOtherKindsOfExpr\" (%0 : int)java.lang.String -> {\n+                %1 : Var<int> = var %0 @\"i\";\n+                %2 : int = constant @\"11\";\n+                %3 : Var<int> = var %2 @\"eleven\";\n+                %4 : int = var.load %1;\n+                %5 : java.lang.String = java.switch.expression %4\n+                    (%6 : int)boolean -> {\n+                        %7 : int = constant @\"1\";\n+                        %8 : int = constant @\"15\";\n+                        %9 : int = and %7 %8;\n+                        %10 : boolean = eq %6 %9;\n+                        yield %10;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"1\";\n+                        yield %11;\n+                    }\n+                    (%12 : int)boolean -> {\n+                        %13 : int = constant @\"4\";\n+                        %14 : int = constant @\"1\";\n+                        %15 : int = ashr %13 %14;\n+                        %16 : boolean = eq %12 %15;\n+                        yield %16;\n+                    }\n+                    ()java.lang.String -> {\n+                        %17 : java.lang.String = constant @\"2\";\n+                        yield %17;\n+                    }\n+                    (%18 : int)boolean -> {\n+                        %19 : long = constant @\"3\";\n+                        %20 : int = conv %19;\n+                        %21 : boolean = eq %18 %20;\n+                        yield %21;\n+                    }\n+                    ()java.lang.String -> {\n+                        %22 : java.lang.String = constant @\"3\";\n+                        yield %22;\n+                    }\n+                    (%23 : int)boolean -> {\n+                        %24 : int = constant @\"2\";\n+                        %25 : int = constant @\"1\";\n+                        %26 : int = lshl %24 %25;\n+                        %27 : boolean = eq %23 %26;\n+                        yield %27;\n+                    }\n+                    ()java.lang.String -> {\n+                        %28 : java.lang.String = constant @\"4\";\n+                        yield %28;\n+                    }\n+                    (%29 : int)boolean -> {\n+                        %30 : int = constant @\"10\";\n+                        %31 : int = constant @\"2\";\n+                        %32 : int = div %30 %31;\n+                        %33 : boolean = eq %29 %32;\n+                        yield %33;\n+                    }\n+                    ()java.lang.String -> {\n+                        %34 : java.lang.String = constant @\"5\";\n+                        yield %34;\n+                    }\n+                    (%35 : int)boolean -> {\n+                        %36 : int = constant @\"12\";\n+                        %37 : int = constant @\"6\";\n+                        %38 : int = sub %36 %37;\n+                        %39 : boolean = eq %35 %38;\n+                        yield %39;\n+                    }\n+                    ()java.lang.String -> {\n+                        %40 : java.lang.String = constant @\"6\";\n+                        yield %40;\n+                    }\n+                    (%41 : int)boolean -> {\n+                        %42 : int = constant @\"3\";\n+                        %43 : int = constant @\"4\";\n+                        %44 : int = add %42 %43;\n+                        %45 : boolean = eq %41 %44;\n+                        yield %45;\n+                    }\n+                    ()java.lang.String -> {\n+                        %46 : java.lang.String = constant @\"7\";\n+                        yield %46;\n+                    }\n+                    (%47 : int)boolean -> {\n+                        %48 : int = constant @\"2\";\n+                        %49 : int = constant @\"2\";\n+                        %50 : int = mul %48 %49;\n+                        %51 : int = constant @\"2\";\n+                        %52 : int = mul %50 %51;\n+                        %53 : boolean = eq %47 %52;\n+                        yield %53;\n+                    }\n+                    ()java.lang.String -> {\n+                        %54 : java.lang.String = constant @\"8\";\n+                        yield %54;\n+                    }\n+                    (%55 : int)boolean -> {\n+                        %56 : int = constant @\"8\";\n+                        %57 : int = constant @\"1\";\n+                        %58 : int = or %56 %57;\n+                        %59 : boolean = eq %55 %58;\n+                        yield %59;\n+                    }\n+                    ()java.lang.String -> {\n+                        %60 : java.lang.String = constant @\"9\";\n+                        yield %60;\n+                    }\n+                    (%61 : int)boolean -> {\n+                        %62 : int = constant @\"10\";\n+                        %63 : boolean = eq %61 %62;\n+                        yield %63;\n+                    }\n+                    ()java.lang.String -> {\n+                        %64 : java.lang.String = constant @\"10\";\n+                        yield %64;\n+                    }\n+                    (%65 : int)boolean -> {\n+                        %66 : int = var.load %3;\n+                        %67 : boolean = eq %65 %66;\n+                        yield %67;\n+                    }\n+                    ()java.lang.String -> {\n+                        %68 : java.lang.String = constant @\"11\";\n+                        yield %68;\n+                    }\n+                    (%69 : int)boolean -> {\n+                        %70 : int = field.load @\"SwitchExpressionTest2$Constants::c1()int\";\n+                        %71 : boolean = eq %69 %70;\n+                        yield %71;\n+                    }\n+                    ()java.lang.String -> {\n+                        %72 : int = field.load @\"SwitchExpressionTest2$Constants::c1()int\";\n+                        %73 : java.lang.String = invoke %72 @\"java.lang.String::valueOf(int)java.lang.String\";\n+                        yield %73;\n+                    }\n+                    (%74 : int)boolean -> {\n+                        %75 : int = java.cexpression\n+                            ()boolean -> {\n+                                %76 : int = constant @\"1\";\n+                                %77 : int = constant @\"0\";\n+                                %78 : boolean = gt %76 %77;\n+                                yield %78;\n+                            }\n+                            ()int -> {\n+                                %79 : int = constant @\"13\";\n+                                yield %79;\n+                            }\n+                            ()int -> {\n+                                %80 : int = constant @\"133\";\n+                                yield %80;\n+                            };\n+                        %81 : boolean = eq %74 %75;\n+                        yield %81;\n+                    }\n+                    ()java.lang.String -> {\n+                        %82 : java.lang.String = constant @\"13\";\n+                        yield %82;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %83 : java.lang.String = constant @\"an int\";\n+                        yield %83;\n+                    };\n+                return %5;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantOtherKindsOfExpr(int i) {\n+        final int eleven = 11;\n+        return switch (i) {\n+            case 1 & 0xF -> \"1\";\n+            case 4>>1 -> \"2\";\n+            case (int) 3L -> \"3\";\n+            case 2<<1 -> \"4\";\n+            case 10 \/ 2 -> \"5\";\n+            case 12 - 6 -> \"6\";\n+            case 3 + 4 -> \"7\";\n+            case 2 * 2 * 2 -> \"8\";\n+            case 8 | 1 -> \"9\";\n+            case (10) -> \"10\";\n+            case eleven -> \"11\";\n+            case Constants.c1 -> String.valueOf(Constants.c1);\n+            case 1 > 0 ? 13 : 133 -> \"13\";\n+            default -> \"an int\";\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest2.java","additions":633,"deletions":0,"binary":false,"changes":633,"status":"added"}]}