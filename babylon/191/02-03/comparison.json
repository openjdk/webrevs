{"files":[{"patch":"@@ -378,0 +378,40 @@\n+    @Test\n+    void testCaseConstantConv() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantConv\");\n+        short[] args = {1, 2, 3, 4};\n+        for (short arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantConv(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String caseConstantConv(short a) {\n+        final short s = 1;\n+        final byte b = 2;\n+        return switch (a) {\n+            case s -> \"one\"; \/\/ identity\n+            case b -> \"three\"; \/\/ widening primitive conversion\n+            case 3 -> \"two\"; \/\/ narrowing primitive conversion\n+            default -> \"default\";\n+        };\n+    }\n+\n+    @Test\n+    void testCaseConstantConv2() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantConv2\");\n+        Byte[] args = {1, 2, 3};\n+        for (Byte arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantConv2(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String caseConstantConv2(Byte a) {\n+        final byte b = 2;\n+        return switch (a) {\n+            case 1 -> \"one\"; \/\/ narrowing primitive conversion followed by a boxing conversion\n+            case b -> \"two\"; \/\/ boxing\n+            default -> \"default\";\n+        };\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}