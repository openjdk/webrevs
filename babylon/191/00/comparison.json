{"files":[{"patch":"@@ -308,0 +308,4 @@\n+    public static boolean eq(char l, char r) {\n+        return l == r;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -648,5 +648,1 @@\n-        public Value toValue(JCTree tree) {\n-            return toValue(tree, Type.noType);\n-        }\n-\n-        public Value toValue(JCTree tree, Type target) {\n+        public Value toValue(JCExpression expression, Type targetType) {\n@@ -656,2 +652,2 @@\n-                pt = target;\n-                scan(tree);\n+                pt = targetType;\n+                scan(expression);\n@@ -659,1 +655,1 @@\n-                        coerce(result, tree.type, target) :\n+                        coerce(result, expression.type, targetType) :\n@@ -666,0 +662,10 @@\n+        public Value toValue(JCExpression expression) {\n+            return toValue(expression, Type.noType);\n+        }\n+\n+        public Value toValue(JCTree.JCStatement statement) {\n+            result = null; \/\/ reset\n+            scan(statement);\n+            return result;\n+        }\n+\n@@ -1210,0 +1216,2 @@\n+                        \/\/ @@@ when we support ANYPATTERN, we must add result of toValue only if it's non-null\n+                        \/\/ because passing null to recordPattern methods will cause an error\n@@ -1372,1 +1380,1 @@\n-                Value exprVal = toValue(tree.body, tree.getDescriptorType(types).getReturnType());\n+                Value exprVal = toValue(((JCExpression) tree.body), tree.getDescriptorType(types).getReturnType());\n@@ -1382,1 +1390,1 @@\n-                    toValue(tree.body);\n+                    toValue(((JCTree.JCStatement) tree.body));\n@@ -1529,2 +1537,4 @@\n-                        \/\/ @@@ Conversion of localTarget\n-                        if (ccl.expr.type.isPrimitive()) {\n+                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                        \/\/ so, we convert constant to the type of the selector expression\n+                        expr = convert(expr, tree.selector.type);\n+                        if (tree.selector.type.isPrimitive()) {\n@@ -1544,1 +1554,1 @@\n-                            \/\/ @@@ Conversion of localTarget\n+                            expr = convert(expr, tree.selector.type);\n@@ -1546,1 +1556,1 @@\n-                            if (ccl.expr.type.isPrimitive()) {\n+                            if (tree.selector.type.isPrimitive()) {\n@@ -1587,3 +1597,2 @@\n-                        if (c.body instanceof JCExpression) {\n-                            \/\/ Yield the boolean result of the condition\n-                            Value bodyVal = toValue(c.body, yieldType);\n+                        if (c.body instanceof JCTree.JCExpression e) {\n+                            Value bodyVal = toValue(e, yieldType);\n@@ -1591,1 +1600,1 @@\n-                        } else {\n+                        } else if (c.body instanceof JCTree.JCStatement s){\n@@ -1596,1 +1605,1 @@\n-                                Value bodyVal = toValue(c.body);\n+                                Value bodyVal = toValue(s);\n@@ -2009,1 +2018,5 @@\n-                    rValues.add(toValue(resource));\n+                    if (resource instanceof JCTree.JCExpression e) {\n+                        rValues.add(toValue(e));\n+                    } else if (resource instanceof JCTree.JCStatement s) {\n+                        rValues.add(toValue(s));\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -9,1 +10,1 @@\n-import java.util.Optional;\n+import java.util.*;\n@@ -18,2 +19,16 @@\n-    \/\/ TODO more testing\n-    \/\/  cover cases where MatchException will be thrown\n+    @Test\n+    void testCasePatternGuard() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternGuard\");\n+        Object[] args = {\"c++\", \"java\", new R(8), new R(2L), new R(3f), new R(4.0)};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), casePatternGuard(arg));\n+        }\n+    }\n+    @CodeReflection\n+    static String casePatternGuard(Object obj) {\n+        return switch (obj) {\n+            case String s when s.length() > 3 -> \"str with length > %d\".formatted(s.length());\n+            case R(Number n) when n.getClass().equals(Double.class) -> \"R(Double)\";\n+            default -> \"else\";\n+        };\n+    }\n@@ -21,0 +36,11 @@\n+    @Test\n+    void testCaseRecordPattern() {\n+        \/\/ @@@ new R(null) must match the pattern R(Number c), but it doesn't\n+        \/\/ @@@ test with generic record\n+        CoreOp.FuncOp lmodel = lower(\"caseRecordPattern\");\n+        Object[] args = {new R(8), new R(1.0), new R(2L), \"abc\"};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseRecordPattern(arg));\n+        }\n+    }\n+    record R(Number n) {}\n@@ -22,6 +48,62 @@\n-    public static Object f1(String r) {\n-        return switch (r) {\n-            case \"FOO\" -> \"FOO\";\n-            case \"BAR\" -> \"FOO\";\n-            case \"BAZ\" -> \"FOO\";\n-            default -> \"\";\n+    static String caseRecordPattern(Object o) {\n+        return switch (o) {\n+            case R(Number _) -> \"R(_)\";\n+            default -> \"else\";\n+        };\n+    }\n+    @Test\n+    void testCaseTypePattern() {\n+        CoreOp.FuncOp lmodel = lower(\"caseTypePattern\");\n+        Object[] args = {\"str\", new ArrayList<>(), new int[]{}, new Stack[][]{}, new Collection[][][]{}, 8, 'x'};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseTypePattern(arg));\n+        }\n+    }\n+    @CodeReflection\n+    static String caseTypePattern(Object o) {\n+        return switch (o) {\n+            case String _ -> \"String\"; \/\/ class\n+            case RandomAccess _ -> \"RandomAccess\"; \/\/ interface\n+            case int[] _ -> \"int[]\"; \/\/ array primitive\n+            case Stack[][] _ -> \"Stack[][]\"; \/\/ array class\n+            case Collection[][][] _ -> \"Collection[][][]\"; \/\/ array interface\n+            case final Number n -> \"Number\"; \/\/ final modifier\n+            default -> \"something else\";\n+        };\n+    }\n+\n+    @Test\n+    void testCasePatternWithCaseConstant() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternWithCaseConstant\");\n+        int[] args = {42, 43, -44, 0};\n+        for (int arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternWithCaseConstant(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String casePatternWithCaseConstant(Integer a) {\n+        return switch (a) {\n+            case 42 -> \"forty two\";\n+            \/\/ @@@ case int will not match, because of the way InstanceOfOp is interpreted\n+            case Integer i when i > 0 -> \"positive int\";\n+            case Integer i when i < 0 -> \"negative int\";\n+            default -> \"zero\";\n+        };\n+    }\n+\n+    \/\/ @Test\n+    void testCasePatternMultiLabel() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternMultiLabel\");\n+        Object[] args = {(byte) 1, (short) 2, 'A', 3, 4L, 5f, 6d, true, \"str\"};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternMultiLabel(arg));\n+        }\n+    }\n+    \/\/ @CodeReflection\n+    \/\/ code model for such as code is not supported\n+    \/\/ @@@ support this case and uncomment its test\n+    private static String casePatternMultiLabel(Object o) {\n+        return switch (o) {\n+            case Integer _, Long _, Character _, Byte _, Short _-> \"integral type\";\n+            default -> \"non integral type\";\n@@ -32,2 +114,2 @@\n-    public void test1() {\n-        CoreOp.FuncOp lf = lower(\"f1\");\n+    void testCasePatternThrow() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternThrow\");\n@@ -35,4 +117,9 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f1(\"FOO\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f1(\"BAR\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAZ\"), f1(\"BAZ\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f1(\"ELSE\"));\n+        Object[] args = {Byte.MAX_VALUE, Short.MIN_VALUE, 0, 1L, 11f, 22d};\n+        for (Object arg : args) {\n+            Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, arg));\n+        }\n+\n+        Object[] args2 = {\"abc\", List.of()};\n+        for (Object arg : args2) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternThrow(arg));\n+        }\n@@ -42,3 +129,36 @@\n-    public static Object f2(String r) { \/\/ switch expr with fallthrough\n-        return switch (r) {\n-            case \"FOO\" : {\n+    private static String casePatternThrow(Object o) {\n+        return switch (o) {\n+            case Number n -> throw new IllegalArgumentException();\n+            case String s -> \"a string\";\n+            default -> o.getClass().getName();\n+        };\n+    }\n+\n+    @Test\n+    void testCasePatternBehaviorIsSyntaxIndependent() {\n+        CoreOp.FuncOp ruleExpression = lower(\"casePatternRuleExpression\");\n+        CoreOp.FuncOp ruleBlock = lower(\"casePatternRuleBlock\");\n+        CoreOp.FuncOp statement = lower(\"casePatternStatement\");\n+\n+        String[] args = {\"FOO\", \"BAR\", \"BAZ\", \"OTHER\"};\n+\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternRuleExpression(Object o) {\n+        return switch (o) {\n+            case Integer i -> \"integer\";\n+            case String s -> \"string\";\n+            default -> \"not integer nor string\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternRuleBlock(Object o) {\n+        return switch (o) {\n+            case Integer i -> {\n+                yield \"integer\";\n@@ -46,2 +166,2 @@\n-            case \"BAR\" : {\n-                yield \"2\";\n+            case String s -> {\n+                yield \"string\";\n@@ -49,1 +169,12 @@\n-            default : yield \"\";\n+            default -> {\n+                yield \"not integer nor string\";\n+            }\n+        };\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternStatement(Object o) {\n+        return switch (o) {\n+            case Integer i: yield \"integer\";\n+            case String s: yield \"string\";\n+            default: yield \"not integer nor string\";\n@@ -54,2 +185,6 @@\n-    public void test2() {\n-        CoreOp.FuncOp lf = lower(\"f2\");\n+    void testCaseConstantOtherKindsOfExpr() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantOtherKindsOfExpr\");\n+        for (int i = 0; i < 14; i++) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, i), caseConstantOtherKindsOfExpr(i));\n+        }\n+    }\n@@ -57,3 +192,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f2(\"FOO\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f2(\"BAR\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f2(\"ELSE\"));\n+    static class Constants {\n+        static final int c1 = 12;\n@@ -63,5 +197,17 @@\n-    \/\/ null is handled, when selector expr is null the switch will complete normally\n-    private static String f3(String s) {\n-        return switch (s) {\n-            case null -> \"null\";\n-            default -> \"default\";\n+    private static String caseConstantOtherKindsOfExpr(int i) {\n+        final int eleven = 11;\n+        return switch (i) {\n+            case 1 & 0xF -> \"1\";\n+            case 4>>1 -> \"2\";\n+            case (int) 3L -> \"3\";\n+            case 2<<1 -> \"4\";\n+            case 10 \/ 2 -> \"5\";\n+            case 12 - 6 -> \"6\";\n+            case 3 + 4 -> \"7\";\n+            case 2 * 2 * 2 -> \"8\";\n+            case 0xF | 1 -> \"9\";\n+            case (10) -> \"10\";\n+            case eleven -> \"11\";\n+            case Constants.c1 -> String.valueOf(Constants.c1);\n+            case 1 > 0 ? 13 : 133 -> \"13\";\n+            default -> \"an int\";\n@@ -72,2 +218,10 @@\n-    public void test3() {\n-        CoreOp.FuncOp lf = lower(\"f3\");\n+    void testCaseConstantEnum() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantEnum\");\n+        for (Day day : Day.values()) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, day), caseConstantEnum(day));\n+        }\n+    }\n+\n+    enum Day {\n+        MON, TUE, WED, THU, FRI, SAT, SUN\n+    }\n@@ -75,2 +229,17 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, new Object[]{null}), f3(null));\n+    @CodeReflection\n+    private static int caseConstantEnum(Day d) {\n+        return switch (d) {\n+            case MON, FRI, SUN -> 6;\n+            case TUE -> 7;\n+            case THU, SAT -> 8;\n+            case WED -> 9;\n+        };\n+    }\n+\n+    @Test\n+    void testCaseConstantFallThrough() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantFallThrough\");\n+        char[] args = {'A', 'B', 'C'};\n+        for (char arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantFallThrough(arg));\n+        }\n@@ -80,2 +249,14 @@\n-    \/\/ null not handled, when selector expr is null it will throw NPE\n-    private static String f4(String s) {\n+    private static String caseConstantFallThrough(char c) {\n+        return switch (c) {\n+            case 'A':\n+            case 'B':\n+                yield \"A or B\";\n+            default:\n+                yield \"Neither A nor B\";\n+        };\n+    }\n+\n+    \/\/ @CodeReflection\n+    \/\/ compiler code doesn't support case null, default\n+    \/\/ @@@ support such as case and test the switch expression lowering for this case\n+    private static String caseConstantNullAndDefault(String s) {\n@@ -83,1 +264,2 @@\n-            default -> \"default\";\n+            case \"abc\" -> \"alphabet\";\n+            case null, default -> \"null or default\";\n@@ -88,2 +270,15 @@\n-    public void test4() {\n-        CoreOp.FuncOp lf = lower(\"f4\");\n+    void testCaseConstantNullLabel() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantNullLabel\");\n+        String[] args = {null, \"non null\"};\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantNullLabel(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static String caseConstantNullLabel(String s) {\n+        return switch (s) {\n+            case null -> \"null\";\n+            default -> \"non null\";\n+        };\n+    }\n@@ -91,3 +286,8 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n-        Assert.assertThrows(NullPointerException.class, () -> f4(null));\n-        Assert.assertThrows(NullPointerException.class, () -> Interpreter.invoke(lf, new Object[]{null}));\n+    @Test\n+    void testCaseConstantThrow() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantThrow\");\n+        Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, 8));\n+        int[] args = {9, 10};\n+        for (int arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantThrow(arg));\n+        }\n@@ -97,1 +297,1 @@\n-    private static String f5(int i) {\n+    private static String caseConstantThrow(Integer i) {\n@@ -99,3 +299,3 @@\n-            case 1 -> \"1\";\n-            case 2 -> \"2\";\n-            default -> \"default\";\n+            case 8 -> throw new IllegalArgumentException();\n+            case 9 -> \"NINE\";\n+            default -> \"An integer\";\n@@ -106,2 +306,7 @@\n-    public void test5() {\n-        CoreOp.FuncOp lf = lower(\"f5\");\n+    void testCaseConstantMultiLabels() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantMultiLabels\");\n+        char[] args = {'a', 'e', 'i', 'o', 'u', 'j', 'p', 'g'};\n+        for (char arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantMultiLabels(arg));\n+        }\n+    }\n@@ -109,3 +314,6 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, 1), f5(1));\n-        Assert.assertEquals(Interpreter.invoke(lf, 2), f5(2));\n-        Assert.assertEquals(Interpreter.invoke(lf, 99), f5(99));\n+    @CodeReflection\n+    private static String caseConstantMultiLabels(char c) {\n+        return switch (Character.toLowerCase(c)) {\n+            case 'a', 'e', 'i', 'o', 'u': yield \"vowel\";\n+            default: yield \"consonant\";\n+        };\n@@ -114,4 +322,5 @@\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n+    @Test\n+    void testCaseConstantBehaviorIsSyntaxIndependent() {\n+        CoreOp.FuncOp ruleExpression = lower(\"caseConstantRuleExpression\");\n+        CoreOp.FuncOp ruleBlock = lower(\"caseConstantRuleBlock\");\n+        CoreOp.FuncOp statement = lower(\"caseConstantStatement\");\n@@ -119,1 +328,44 @@\n-        return om.get().getCodeModel().get();\n+        String[] args = {\"FOO\", \"BAR\", \"BAZ\", \"OTHER\"};\n+\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static String caseConstantRuleExpression(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"BAR\";\n+            case \"BAR\" -> \"BAZ\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    public static String caseConstantRuleBlock(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> {\n+                yield \"BAR\";\n+            }\n+            case \"BAR\" -> {\n+                yield \"BAZ\";\n+            }\n+            case \"BAZ\" -> {\n+                yield \"FOO\";\n+            }\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+\n+    @CodeReflection\n+    private static String caseConstantStatement(String s) {\n+        return switch (s) {\n+            case \"FOO\": yield \"BAR\";\n+            case \"BAR\": yield \"BAZ\";\n+            case \"BAZ\": yield \"FOO\";\n+            default: yield \"\";\n+        };\n@@ -123,1 +375,1 @@\n-        return lower(getFuncOp(methodName));\n+        return lower(getCodeModel(methodName));\n@@ -135,0 +387,8 @@\n+\n+    private static CoreOp.FuncOp getCodeModel(String methodName) {\n+        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":318,"deletions":58,"binary":false,"changes":376,"status":"modified"}]}