{"files":[{"patch":"@@ -1219,0 +1219,2 @@\n+                        \/\/ @@@ when we support ANYPATTERN, we must add result of toValue only if it's non-null\n+                        \/\/ because passing null to recordPattern methods will cause an error\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-import java.util.Optional;\n+import java.util.*;\n@@ -23,0 +23,165 @@\n+    @Test\n+    void testCasePatternGuard() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternGuard\");\n+        Object[] args = {\"c++\", \"java\", new R(8), new R(2L), new R(3f), new R(4.0)};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), casePatternGuard(arg));\n+        }\n+    }\n+    @CodeReflection\n+    static String casePatternGuard(Object obj) {\n+        return switch (obj) {\n+            case String s when s.length() > 3 -> \"str with length > %d\".formatted(s.length());\n+            case R(Number n) when n.getClass().equals(Double.class) -> \"R(Double)\";\n+            default -> \"else\";\n+        };\n+    }\n+\n+    @Test\n+    void testCaseRecordPattern() {\n+        \/\/ @@@ new R(null) must match the pattern R(Number c), but it doesn't\n+        \/\/ @@@ test with generic record\n+        CoreOp.FuncOp lmodel = lower(\"caseRecordPattern\");\n+        Object[] args = {new R(8), new R(1.0), new R(2L), \"abc\"};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseRecordPattern(arg));\n+        }\n+    }\n+    record R(Number n) {}\n+    @CodeReflection\n+    static String caseRecordPattern(Object o) {\n+        return switch (o) {\n+            case R(Number _) -> \"R(_)\";\n+            default -> \"else\";\n+        };\n+    }\n+    @Test\n+    void testCaseTypePattern() {\n+        CoreOp.FuncOp lmodel = lower(\"caseTypePattern\");\n+        Object[] args = {\"str\", new ArrayList<>(), new int[]{}, new Stack[][]{}, new Collection[][][]{}, 8, 'x'};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseTypePattern(arg));\n+        }\n+    }\n+    @CodeReflection\n+    static String caseTypePattern(Object o) {\n+        return switch (o) {\n+            case String _ -> \"String\"; \/\/ class\n+            case RandomAccess _ -> \"RandomAccess\"; \/\/ interface\n+            case int[] _ -> \"int[]\"; \/\/ array primitive\n+            case Stack[][] _ -> \"Stack[][]\"; \/\/ array class\n+            case Collection[][][] _ -> \"Collection[][][]\"; \/\/ array interface\n+            case final Number n -> \"Number\"; \/\/ final modifier\n+            default -> \"something else\";\n+        };\n+    }\n+\n+    @Test\n+    void testCasePatternWithCaseConstant() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternWithCaseConstant\");\n+        int[] args = {42, 43, -44, 0};\n+        for (int arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternWithCaseConstant(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String casePatternWithCaseConstant(Integer a) {\n+        return switch (a) {\n+            case 42 -> \"forty two\";\n+            \/\/ @@@ case int will not match, because of the way InstanceOfOp is interpreted\n+            case Integer i when i > 0 -> \"positive int\";\n+            case Integer i when i < 0 -> \"negative int\";\n+            default -> \"zero\";\n+        };\n+    }\n+\n+    \/\/ @Test\n+    void testCasePatternMultiLabel() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternMultiLabel\");\n+        Object[] args = {(byte) 1, (short) 2, 'A', 3, 4L, 5f, 6d, true, \"str\"};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternMultiLabel(arg));\n+        }\n+    }\n+    \/\/ @CodeReflection\n+    \/\/ code model for such as code is not supported\n+    \/\/ @@@ support this case and uncomment its test\n+    private static String casePatternMultiLabel(Object o) {\n+        return switch (o) {\n+            case Integer _, Long _, Character _, Byte _, Short _-> \"integral type\";\n+            default -> \"non integral type\";\n+        };\n+    }\n+\n+    @Test\n+    void testCasePatternThrow() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternThrow\");\n+\n+        Object[] args = {Byte.MAX_VALUE, Short.MIN_VALUE, 0, 1L, 11f, 22d};\n+        for (Object arg : args) {\n+            Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, arg));\n+        }\n+\n+        Object[] args2 = {\"abc\", List.of()};\n+        for (Object arg : args2) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternThrow(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternThrow(Object o) {\n+        return switch (o) {\n+            case Number n -> throw new IllegalArgumentException();\n+            case String s -> \"a string\";\n+            default -> o.getClass().getName();\n+        };\n+    }\n+\n+    @Test\n+    void testCasePatternBehaviorIsSyntaxIndependent() {\n+        CoreOp.FuncOp ruleExpression = lower(\"casePatternRuleExpression\");\n+        CoreOp.FuncOp ruleBlock = lower(\"casePatternRuleBlock\");\n+        CoreOp.FuncOp statement = lower(\"casePatternStatement\");\n+\n+        String[] args = {\"FOO\", \"BAR\", \"BAZ\", \"OTHER\"};\n+\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternRuleExpression(Object o) {\n+        return switch (o) {\n+            case Integer i -> \"integer\";\n+            case String s -> \"string\";\n+            default -> \"not integer nor string\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternRuleBlock(Object o) {\n+        return switch (o) {\n+            case Integer i -> {\n+                yield \"integer\";\n+            }\n+            case String s -> {\n+                yield \"string\";\n+            }\n+            default -> {\n+                yield \"not integer nor string\";\n+            }\n+        };\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternStatement(Object o) {\n+        return switch (o) {\n+            case Integer i: yield \"integer\";\n+            case String s: yield \"string\";\n+            default: yield \"not integer nor string\";\n+        };\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":166,"deletions":1,"binary":false,"changes":167,"status":"modified"}]}