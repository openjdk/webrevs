{"files":[{"patch":"@@ -524,3 +524,2 @@\n-                MethodHandle makeQuoted = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n-                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, FUNC_OP_CLASS, Object[].class));\n-                HANDLE_MAKE_QUOTED = makeQuoted.bindTo(Lookup.IMPL_LOOKUP);\n+                HANDLE_MAKE_QUOTED = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n+                        MethodType.methodType(QUOTED_CLASS, FUNC_OP_CLASS, Object[].class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    private SequencedMap<Value, Object> operands;\n@@ -73,0 +74,7 @@\n+    public Quoted(Op op, SequencedMap<Value, Object> capturedValues, SequencedMap<Value, Object> operands) {\n+        this(op, capturedValues);\n+\n+        assert op.operands().equals(new ArrayList<>(operands.keySet()));\n+        this.operands = Collections.unmodifiableSequencedMap(new LinkedHashMap<>(operands));\n+    }\n+\n@@ -96,0 +104,4 @@\n+\n+    public SequencedMap<Value, Object> operands() {\n+        return operands;\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-                                .loadConstant(quote(lop).toText())\n+                                .loadConstant(CoreOp.quoteOp(lop).toText())\n@@ -1288,40 +1288,0 @@\n-\n-    static FuncOp quote(LambdaOp lop) {\n-        List<Value> captures = lop.capturedValues();\n-\n-        \/\/ Build the function type\n-        List<TypeElement> params = captures.stream()\n-                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n-                .toList();\n-        FunctionType ft = FunctionType.functionType(QuotedOp.QUOTED_TYPE, params);\n-\n-        \/\/ Build the function that quotes the lambda\n-        return CoreOp.func(\"q\", ft).body(b -> {\n-            \/\/ Create variables as needed and obtain the captured values\n-            \/\/ for the copied lambda\n-            List<Value> outputCaptures = new ArrayList<>();\n-            for (int i = 0; i < captures.size(); i++) {\n-                Value c = captures.get(i);\n-                Block.Parameter p = b.parameters().get(i);\n-                if (c.type() instanceof VarType _) {\n-                    Value var = b.op(CoreOp.var(String.valueOf(i), p));\n-                    outputCaptures.add(var);\n-                } else {\n-                    outputCaptures.add(p);\n-                }\n-            }\n-\n-            \/\/ Quoted the lambda expression\n-            Value q = b.op(CoreOp.quoted(b.parentBody(), qb -> {\n-                \/\/ Map the entry block of the lambda's ancestor body to the quoted block\n-                \/\/ We are copying lop in the context of the quoted block, the block mapping\n-                \/\/ ensures the use of captured values are reachable when building\n-                qb.context().mapBlock(lop.ancestorBody().entryBlock(), qb);\n-                \/\/ Map the lambda's captured values\n-                qb.context().mapValues(captures, outputCaptures);\n-                \/\/ Return the lambda to be copied in the quoted operation\n-                return lop;\n-            }));\n-            b.op(CoreOp._return(q));\n-        });\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.*;\n@@ -30,0 +30,1 @@\n+import jdk.incubator.code.op.CoreOp;\n@@ -31,1 +32,0 @@\n-import jdk.incubator.code.parser.OpParser;\n@@ -33,1 +33,3 @@\n-import java.lang.invoke.MethodHandles;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n@@ -36,2 +38,21 @@\n-    public static Quoted makeQuoted(MethodHandles.Lookup lookup, FuncOp op, Object[] args) {\n-        return (Quoted)Interpreter.invoke(lookup, op, args);\n+\n+    public static Quoted makeQuoted(FuncOp op, Object[] args) {\n+\n+        CoreOp.QuotedOp qop = (CoreOp.QuotedOp) op.body().entryBlock().ops().stream()\n+                .filter(o -> o instanceof CoreOp.QuotedOp).findFirst().orElseThrow();\n+\n+        Iterator<Object> argsIterator = Arrays.stream(args).iterator();\n+        LinkedHashMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value capturedValue : qop.capturedValues()) {\n+            if (capturedValue instanceof Block.Parameter) {\n+                m.put(capturedValue, argsIterator.next());\n+            } else if (capturedValue instanceof Op.Result opr && opr.op() instanceof CoreOp.VarOp varOp) {\n+                if (varOp.initOperand() instanceof Block.Parameter) {\n+                    m.put(capturedValue, new Interpreter.VarBox(argsIterator.next()));\n+                } else if (varOp.initOperand() instanceof Op.Result opr2 && opr2.op() instanceof CoreOp.ConstantOp cop) {\n+                    m.put(capturedValue, new Interpreter.VarBox(cop.value()));\n+                }\n+            }\n+        }\n+\n+        return new Quoted(qop.quotedOp(), m);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/QuotedHelper.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-    static final class VarBox\n+    public static final class VarBox\n@@ -238,1 +238,1 @@\n-        VarBox(Object value) {\n+        public VarBox(Object value) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -4438,0 +4439,78 @@\n+\n+    public static FuncOp quoteOp(Op op) {\n+\n+        List<Value> inputOperandsAndCaptures = Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList();\n+\n+        \/\/ Build the function type\n+        List<TypeElement> params = inputOperandsAndCaptures.stream()\n+                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n+                .toList();\n+        FunctionType ft = FunctionType.functionType(QuotedOp.QUOTED_TYPE, params);\n+\n+        \/\/ Build the function that quotes the lambda\n+        return CoreOp.func(\"q\", ft).body(b -> {\n+            \/\/ Create variables as needed and obtain the operands and captured values for the copied lambda\n+            List<Value> outputOperandsAndCaptures = new ArrayList<>();\n+            for (int i = 0; i < inputOperandsAndCaptures.size(); i++) {\n+                Value inputValue = inputOperandsAndCaptures.get(i);\n+                Value outputValue = b.parameters().get(i);\n+                if (inputValue.type() instanceof VarType _) {\n+                    outputValue = b.op(CoreOp.var(String.valueOf(i), outputValue));\n+                }\n+                outputOperandsAndCaptures.add(outputValue);\n+            }\n+\n+            \/\/ Quoted the lambda expression\n+            Value q = b.op(CoreOp.quoted(b.parentBody(), qb -> {\n+                \/\/ Map the entry block of the lambda's ancestor body to the quoted block\n+                \/\/ We are copying lop in the context of the quoted block, the block mapping\n+                \/\/ ensures the use of operands and captured values are reachable when building\n+                qb.context().mapBlock(op.ancestorBody().entryBlock(), qb);\n+                \/\/ Map the op's operands and captured values\n+                qb.context().mapValues(inputOperandsAndCaptures, outputOperandsAndCaptures);\n+                \/\/ Return the op to be copied in the quoted operation\n+                return op;\n+            }));\n+            b.op(CoreOp._return(q));\n+        });\n+    }\n+\n+    public static Quoted quotedOp(FuncOp funcOp, Object[] args) {\n+\n+        assert funcOp.body().blocks().size() == 1;\n+        Block fopBlock = funcOp.body().entryBlock();\n+\n+        assert fopBlock.ops().size() == 2 + funcOp.parameters().size();\n+\n+        assert fopBlock.ops().subList(0, funcOp.parameters().size()).stream().allMatch(o -> o instanceof VarOp);\n+\n+        assert fopBlock.ops().get(funcOp.parameters().size()) instanceof QuotedOp;\n+        QuotedOp qop = (QuotedOp) fopBlock.ops().get(funcOp.parameters().size());\n+\n+        assert fopBlock.ops().getLast() instanceof ReturnOp returnOp && returnOp.returnValue().equals(qop.result());\n+\n+        Op op = qop.quotedOp();\n+\n+        List<Op> fopBlockVarOps = fopBlock.ops().subList(0, funcOp.parameters().size());\n+\n+        assert fopBlockVarOps.size() == op.capturedValues().size() + op.operands().size();\n+\n+        assert op.capturedValues().equals(fopBlockVarOps.subList(0, op.capturedValues().size())\n+                .stream().map(Op::result).toList());\n+\n+        assert fopBlockVarOps.stream().map(o -> ((VarOp) o).initOperand()).toList().equals(funcOp.parameters());\n+\n+        assert funcOp.parameters().size() == args.length;\n+        LinkedHashMap<Value, Object> m = new LinkedHashMap<>();\n+        Iterator<Object> argsIterator = Arrays.stream(args).iterator();\n+        for (Value v : op.capturedValues()) {\n+            \/\/ @@@ The interpreter map captured value to instance of VarBox, should we do the same ?\n+            m.put(v, argsIterator.next());\n+        }\n+        LinkedHashMap<Value, Object> m2 = new LinkedHashMap<>();\n+        for (Value operand : op.operands()) {\n+            m2.put(operand, argsIterator.next());\n+        }\n+\n+        return new Quoted(op, m, m2);\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.op.CoreOp;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestQuoteOp\n+ *\/\n+public class TestQuoteOp {\n+\n+    @CodeReflection\n+    public void f(int i) {\n+        String s = \"abc\";\n+        Runnable r = () -> {\n+            System.out.println(i + s + hashCode());\n+        };\n+    }\n+\n+    @Test\n+    void test() throws NoSuchMethodException {\n+        Method f = getClass().getDeclaredMethod(\"f\", int.class);\n+        CoreOp.FuncOp fm = Op.ofMethod(f).orElseThrow();\n+        Op lop = fm.body().entryBlock().ops().stream().filter(op -> op instanceof CoreOp.LambdaOp).findFirst().orElseThrow();\n+\n+        fm.writeTo(System.out);\n+\n+        CoreOp.FuncOp funcOp = CoreOp.quoteOp(lop);\n+        funcOp.writeTo(System.out);\n+\n+        Object[] args = {1, \"s\", this};\n+        Quoted q = CoreOp.quotedOp(funcOp, args);\n+\n+        Assert.assertTrue(lop.getClass().isInstance(q.op()));\n+\n+        \/\/ q.op() must have the same structure as lop\n+        \/\/ for the moment, we don't have utility to check that\n+\n+        Assert.assertEquals(args, q.capturedValues().values().toArray());\n+\n+        Assert.assertTrue(q.operands().isEmpty());\n+    }\n+\n+    @CodeReflection\n+    static void g(String s) {\n+        boolean b = s.startsWith(\"a\");\n+    }\n+\n+    @Test\n+    void testQuoteOpThatHasOperands() throws NoSuchMethodException { \/\/ op with operands\n+        Method g = getClass().getDeclaredMethod(\"g\", String.class);\n+        CoreOp.FuncOp gm = Op.ofMethod(g).orElseThrow();\n+        Op op = gm.body().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.InvokeOp).findFirst().orElseThrow();\n+\n+        gm.writeTo(System.out);\n+\n+        CoreOp.FuncOp funcOp = CoreOp.quoteOp(op);\n+        funcOp.writeTo(System.out);\n+\n+        Object[] args = {\"str\", \"s\"};\n+        Quoted q = CoreOp.quotedOp(funcOp, args);\n+\n+        Assert.assertTrue(op.getClass().isInstance(q.op()));\n+\n+        Assert.assertTrue(q.capturedValues().isEmpty());\n+\n+        Assert.assertEquals(args, q.operands().values().toArray());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}