{"files":[{"patch":"@@ -524,3 +524,2 @@\n-                MethodHandle makeQuoted = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n-                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, FUNC_OP_CLASS, Object[].class));\n-                HANDLE_MAKE_QUOTED = makeQuoted.bindTo(Lookup.IMPL_LOOKUP);\n+                HANDLE_MAKE_QUOTED = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n+                        MethodType.methodType(QUOTED_CLASS, FUNC_OP_CLASS, Object[].class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.*;\n@@ -30,0 +30,1 @@\n+import jdk.incubator.code.op.CoreOp;\n@@ -31,1 +32,0 @@\n-import jdk.incubator.code.parser.OpParser;\n@@ -33,1 +33,3 @@\n-import java.lang.invoke.MethodHandles;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n@@ -36,2 +38,21 @@\n-    public static Quoted makeQuoted(MethodHandles.Lookup lookup, FuncOp op, Object[] args) {\n-        return (Quoted)Interpreter.invoke(lookup, op, args);\n+\n+    public static Quoted makeQuoted(FuncOp op, Object[] args) {\n+\n+        CoreOp.QuotedOp qop = (CoreOp.QuotedOp) op.body().entryBlock().ops().stream()\n+                .filter(o -> o instanceof CoreOp.QuotedOp).findFirst().orElseThrow();\n+\n+        Iterator<Object> argsIterator = Arrays.stream(args).iterator();\n+        LinkedHashMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value capturedValue : qop.capturedValues()) {\n+            if (capturedValue instanceof Block.Parameter) {\n+                m.put(capturedValue, argsIterator.next());\n+            } else if (capturedValue instanceof Op.Result opr && opr.op() instanceof CoreOp.VarOp varOp) {\n+                if (varOp.initOperand() instanceof Block.Parameter) {\n+                    m.put(capturedValue, new Interpreter.VarBox(argsIterator.next()));\n+                } else if (varOp.initOperand() instanceof Op.Result opr2 && opr2.op() instanceof CoreOp.ConstantOp cop) {\n+                    m.put(capturedValue, new Interpreter.VarBox(cop.value()));\n+                }\n+            }\n+        }\n+\n+        return new Quoted(qop.quotedOp(), m);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/QuotedHelper.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-    static final class VarBox\n+    public static final class VarBox\n@@ -238,1 +238,1 @@\n-        VarBox(Object value) {\n+        public VarBox(Object value) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4438,0 +4438,84 @@\n+\n+    public static FuncOp quoteOp(Op op) {\n+\n+        return func(\"q\", FunctionType.functionType(JavaType.type(Quoted.class))).body(block -> {\n+\n+            List<Value> capturedValues = op.capturedValues();\n+            for (Value v : capturedValues) {\n+                TypeElement t;\n+                if (v instanceof Op.Result opr && opr.op() instanceof VarOp varOp) {\n+                    t = varOp.varValueType();\n+                } else {\n+                    t = v.type();\n+                }\n+                Block.Parameter p = block.parameter(t);\n+                Op.Result nv = block.op(var(p));\n+                block.context().mapValue(v, nv);\n+            }\n+\n+            Body.Builder qbody = Body.Builder.of(block.parentBody(), FunctionType.VOID, CopyContext.create(block.context()));\n+            Block.Builder qblock = qbody.entryBlock();\n+\n+            if (op.ancestorBody() != null) {\n+                \/\/ needed for reachability check (of captured values) to succeed\n+                qblock.context().mapBlock(op.ancestorBody().entryBlock(), qblock);\n+            }\n+            Op.Result opr = qblock.op(op, (b, o) -> {\n+                \/\/ a modified copy transformer, that insert var.load before use of captured values (if needed)\n+                Map<Value, Value> m = new HashMap<>();\n+                for (Value operand : o.operands()) {\n+                    if (capturedValues.contains(operand) && !(operand instanceof Op.Result r && r.op() instanceof VarOp)) {\n+                        Value capVar = b.context().getValue(operand);\n+                        Op.Result capVal = b.op(varLoad(capVar));\n+                        m.put(operand, capVar);\n+                        b.context().mapValue(operand, capVal);\n+                    }\n+                }\n+\n+                b.op(o);\n+\n+                for (Value k : m.keySet()) {\n+                    b.context().mapValue(k, m.get(k));\n+                }\n+\n+                return b;\n+            });\n+\n+            qblock.op(_yield(opr));\n+\n+            Op.Result qopr = block.op(quoted(qbody));\n+\n+            block.op(_return(qopr));\n+        });\n+    }\n+\n+    public static Quoted quotedOp(FuncOp funcOp, Object[] args) {\n+\n+        assert funcOp.body().blocks().size() == 1;\n+        Block fopBlock = funcOp.body().entryBlock();\n+\n+        assert fopBlock.ops().size() == 2 + funcOp.parameters().size();\n+\n+        assert fopBlock.ops().subList(0, funcOp.parameters().size()).stream().allMatch(o -> o instanceof VarOp);\n+\n+        assert fopBlock.ops().get(funcOp.parameters().size()) instanceof QuotedOp;\n+        QuotedOp qop = (QuotedOp) fopBlock.ops().get(funcOp.parameters().size());\n+\n+        assert fopBlock.ops().getLast() instanceof ReturnOp returnOp && returnOp.returnValue().equals(qop.result());\n+\n+        Op op = qop.quotedOp();\n+\n+        List<Op> fopBlockVarOps = fopBlock.ops().subList(0, funcOp.parameters().size());\n+        assert op.capturedValues().equals(fopBlockVarOps.stream().map(Op::result).toList());\n+        assert fopBlockVarOps.stream().map(o -> ((VarOp) o).initOperand()).toList().equals(funcOp.parameters());\n+\n+        assert funcOp.parameters().size() == args.length;\n+        LinkedHashMap<Value, Object> m = new LinkedHashMap<>();\n+        Iterator<Object> argsIterator = Arrays.stream(args).iterator();\n+        for (Value v : op.capturedValues()) {\n+            \/\/ @@@ The interpreter map captured value to instance of VarBox, should we do the same ?\n+            m.put(v, argsIterator.next());\n+        }\n+\n+        return new Quoted(op, m);\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestQuoteOp\n+ *\/\n+public class TestQuoteOp {\n+\n+    @CodeReflection\n+    public void f(int i) {\n+        String s = \"abc\";\n+        Runnable r = () -> {\n+            System.out.println(i + s + hashCode());\n+        };\n+    }\n+\n+    @Test\n+    void test() throws NoSuchMethodException {\n+        Method f = getClass().getDeclaredMethod(\"f\", int.class);\n+        CoreOp.FuncOp fm = Op.ofMethod(f).orElseThrow();\n+        Op lop = fm.body().entryBlock().ops().stream().filter(op -> op instanceof CoreOp.LambdaOp).findFirst().orElseThrow();\n+\n+        fm.writeTo(System.out);\n+\n+        CoreOp.FuncOp funcOp = CoreOp.quoteOp(lop);\n+        funcOp.writeTo(System.out);\n+\n+        Object[] args = {1, \"s\", this};\n+        Quoted q = CoreOp.quotedOp(funcOp, args);\n+\n+        \/\/ q.op() must have the same structure as lop\n+        \/\/ for the moment, we don't have utility to check that\n+\n+        Iterator<Object> argsIterator = Arrays.stream(args).iterator();\n+        for (Map.Entry<Value, Object> e : q.capturedValues().entrySet()) {\n+            Assert.assertSame(e.getValue(), argsIterator.next());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"}]}