{"files":[{"patch":"@@ -524,3 +524,2 @@\n-                MethodHandle makeQuoted = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n-                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, FUNC_OP_CLASS, Object[].class));\n-                HANDLE_MAKE_QUOTED = makeQuoted.bindTo(Lookup.IMPL_LOOKUP);\n+                HANDLE_MAKE_QUOTED = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n+                        MethodType.methodType(QUOTED_CLASS, FUNC_OP_CLASS, Object[].class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.*;\n@@ -30,0 +30,1 @@\n+import jdk.incubator.code.op.CoreOp;\n@@ -31,1 +32,0 @@\n-import jdk.incubator.code.parser.OpParser;\n@@ -33,1 +33,3 @@\n-import java.lang.invoke.MethodHandles;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n@@ -36,2 +38,21 @@\n-    public static Quoted makeQuoted(MethodHandles.Lookup lookup, FuncOp op, Object[] args) {\n-        return (Quoted)Interpreter.invoke(lookup, op, args);\n+\n+    public static Quoted makeQuoted(FuncOp op, Object[] args) {\n+\n+        CoreOp.QuotedOp qop = (CoreOp.QuotedOp) op.body().entryBlock().ops().stream()\n+                .filter(o -> o instanceof CoreOp.QuotedOp).findFirst().orElseThrow();\n+\n+        Iterator<Object> argsIterator = Arrays.stream(args).iterator();\n+        LinkedHashMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value capturedValue : qop.capturedValues()) {\n+            if (capturedValue instanceof Block.Parameter) {\n+                m.put(capturedValue, argsIterator.next());\n+            } else if (capturedValue instanceof Op.Result opr && opr.op() instanceof CoreOp.VarOp varOp) {\n+                if (varOp.initOperand() instanceof Block.Parameter) {\n+                    m.put(capturedValue, new Interpreter.VarBox(argsIterator.next()));\n+                } else if (varOp.initOperand() instanceof Op.Result opr2 && opr2.op() instanceof CoreOp.ConstantOp cop) {\n+                    m.put(capturedValue, new Interpreter.VarBox(cop.value()));\n+                }\n+            }\n+        }\n+\n+        return new Quoted(qop.quotedOp(), m);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/QuotedHelper.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-    static final class VarBox\n+    public static final class VarBox\n@@ -238,1 +238,1 @@\n-        VarBox(Object value) {\n+        public VarBox(Object value) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4438,0 +4438,34 @@\n+\n+    public static FuncOp quoteOp(Op op) {\n+\n+        return func(\"q\", FunctionType.VOID).body(block -> {\n+            List<Value> usedValues = new ArrayList<>();\n+            usedValues.addAll(op.capturedValues());\n+            usedValues.addAll(op.operands());\n+            for (Value v : usedValues) {\n+                Value nv;\n+                if (v instanceof Op.Result opr && opr.op() instanceof VarOp varOp) {\n+                    Block.Parameter p = block.parameter(varOp.varValueType());\n+                    nv = block.op(var(p));\n+                } else {\n+                    nv = block.parameter(v.type());\n+                }\n+                block.context().mapValue(v, nv);\n+            }\n+\n+            Body.Builder qbody = Body.Builder.of(block.parentBody(), FunctionType.VOID, CopyContext.create(block.context()));\n+            Block.Builder qblock = qbody.entryBlock();\n+\n+            if (op.ancestorBody() != null) {\n+                \/\/ needed for reachability check (of captured values) to succeed\n+                qblock.context().mapBlock(op.ancestorBody().entryBlock(), qblock);\n+            }\n+            Op.Result opr = qblock.op(op);\n+\n+            qblock.op(_yield(opr));\n+\n+            block.op(quoted(qbody));\n+\n+            block.op(_return());\n+        });\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.Optional;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestQuoteOp\n+ *\/\n+public class TestQuoteOp {\n+\n+    @CodeReflection\n+    public void f(int i) {\n+        String s = \"abc\";\n+        Runnable r = () -> {\n+            System.out.println(i + s + hashCode());\n+        };\n+    }\n+\n+    @Test\n+    void test() throws NoSuchMethodException {\n+        Method f = getClass().getDeclaredMethod(\"f\", int.class);\n+        CoreOp.FuncOp fm = Op.ofMethod(f).orElseThrow();\n+        Op lop = fm.body().entryBlock().ops().stream().filter(op -> op instanceof CoreOp.LambdaOp).findFirst().orElseThrow();\n+\n+        fm.writeTo(System.out);\n+        CoreOp.FuncOp funcOp = CoreOp.quoteOp(lop);\n+        funcOp.writeTo(System.out);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}