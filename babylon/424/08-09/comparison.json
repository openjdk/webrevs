{"files":[{"patch":"@@ -4478,1 +4478,1 @@\n-    public static Quoted quotedOp(FuncOp funcOp, Object[] args) {\n+    public static OpAndValues quotedOp(FuncOp funcOp) {\n@@ -4481,1 +4481,1 @@\n-        Block fopBlock = funcOp.body().entryBlock();\n+        Block fblock = funcOp.body().entryBlock();\n@@ -4483,1 +4483,2 @@\n-        assert fopBlock.ops().size() == 2 + funcOp.parameters().size();\n+        assert fblock.ops().get(fblock.ops().size() - 2) instanceof QuotedOp;\n+        QuotedOp qop = (QuotedOp) fblock.ops().get(fblock.ops().size() - 2);\n@@ -4485,6 +4486,1 @@\n-        assert fopBlock.ops().subList(0, funcOp.parameters().size()).stream().allMatch(o -> o instanceof VarOp);\n-\n-        assert fopBlock.ops().get(funcOp.parameters().size()) instanceof QuotedOp;\n-        QuotedOp qop = (QuotedOp) fopBlock.ops().get(funcOp.parameters().size());\n-\n-        assert fopBlock.ops().getLast() instanceof ReturnOp returnOp && returnOp.returnValue().equals(qop.result());\n+        assert fblock.ops().getLast() instanceof ReturnOp returnOp && returnOp.returnValue().equals(qop.result());\n@@ -4494,22 +4490,4 @@\n-        List<Op> fopBlockVarOps = fopBlock.ops().subList(0, funcOp.parameters().size());\n-\n-        assert fopBlockVarOps.size() == op.capturedValues().size() + op.operands().size();\n-\n-        assert op.capturedValues().equals(fopBlockVarOps.subList(0, op.capturedValues().size())\n-                .stream().map(Op::result).toList());\n-\n-        assert fopBlockVarOps.stream().map(o -> ((VarOp) o).initOperand()).toList().equals(funcOp.parameters());\n-\n-        assert funcOp.parameters().size() == args.length;\n-        LinkedHashMap<Value, Object> m = new LinkedHashMap<>();\n-        Iterator<Object> argsIterator = Arrays.stream(args).iterator();\n-        for (Value v : op.capturedValues()) {\n-            \/\/ @@@ The interpreter map captured value to instance of VarBox, should we do the same ?\n-            m.put(v, argsIterator.next());\n-        }\n-        LinkedHashMap<Value, Object> m2 = new LinkedHashMap<>();\n-        for (Value operand : op.operands()) {\n-            m2.put(operand, argsIterator.next());\n-        }\n-\n-        return new Quoted(op, m, m2);\n+        SequencedSet<Value> operandsAndCaptures = new LinkedHashSet<>();\n+        operandsAndCaptures.addAll(op.operands());\n+        operandsAndCaptures.addAll(op.capturedValues());\n+        return new OpAndValues(op, operandsAndCaptures);\n@@ -4517,0 +4495,2 @@\n+\n+    public record OpAndValues (Op op, SequencedSet<Value> operandsAndCaptures) { }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":11,"deletions":31,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import jdk.incubator.code.Value;\n@@ -9,0 +10,2 @@\n+import java.util.LinkedHashSet;\n+import java.util.SequencedSet;\n@@ -36,6 +39,2 @@\n-        Object[] args = {1, \"s\", this};\n-        Quoted q = CoreOp.quotedOp(funcOp, args);\n-\n-        Assert.assertTrue(lop.getClass().isInstance(q.op()));\n-\n-        \/\/ q.op() must have the same structure as lop\n+        CoreOp.OpAndValues opAndValues = CoreOp.quotedOp(funcOp);\n+        \/\/ op must have the same structure as lop\n@@ -43,0 +42,1 @@\n+        Op op = opAndValues.op();\n@@ -44,1 +44,1 @@\n-        Assert.assertEquals(args, q.capturedValues().values().toArray());\n+        Assert.assertTrue(lop.getClass().isInstance(op));\n@@ -46,1 +46,4 @@\n-        Assert.assertTrue(q.operands().isEmpty());\n+        SequencedSet<Value> e = new LinkedHashSet<>();\n+        e.addAll(op.operands());\n+        e.addAll(op.capturedValues());\n+        Assert.assertEquals(opAndValues.operandsAndCaptures(), e);\n@@ -58,1 +61,1 @@\n-        Op op = gm.body().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.InvokeOp).findFirst().orElseThrow();\n+        Op invOp = gm.body().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.InvokeOp).findFirst().orElseThrow();\n@@ -62,1 +65,1 @@\n-        CoreOp.FuncOp funcOp = CoreOp.quoteOp(op);\n+        CoreOp.FuncOp funcOp = CoreOp.quoteOp(invOp);\n@@ -65,4 +68,2 @@\n-        Object[] args = {\"str\", \"s\"};\n-        Quoted q = CoreOp.quotedOp(funcOp, args);\n-\n-        Assert.assertTrue(op.getClass().isInstance(q.op()));\n+        CoreOp.OpAndValues opAndValues = CoreOp.quotedOp(funcOp);\n+        Op op = opAndValues.op();\n@@ -70,1 +71,1 @@\n-        Assert.assertTrue(q.capturedValues().isEmpty());\n+        Assert.assertTrue(invOp.getClass().isInstance(op));\n@@ -72,1 +73,4 @@\n-        Assert.assertEquals(args, q.operands().values().toArray());\n+        SequencedSet<Value> e = new LinkedHashSet<>();\n+        e.addAll(op.operands());\n+        e.addAll(op.capturedValues());\n+        Assert.assertEquals(opAndValues.operandsAndCaptures(), e);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"}]}