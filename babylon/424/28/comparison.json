{"files":[{"patch":"@@ -383,1 +383,1 @@\n-                        List.of(implementation, quotableOpGetter, CodeReflectionSupport.HANDLE_MAKE_QUOTED);\n+                        List.of(implementation, quotableOpGetter, CodeReflectionSupport.QUOTED_OP_MH);\n@@ -495,1 +495,1 @@\n-        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(CodeReflectionSupport.HANDLE_MAKE_QUOTED.type()))\n+        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(CodeReflectionSupport.QUOTED_OP_MH.type()))\n@@ -502,1 +502,1 @@\n-        static final MethodHandle HANDLE_MAKE_QUOTED;\n+        static final MethodHandle QUOTED_OP_MH;\n@@ -511,1 +511,0 @@\n-                Class<?> quotedHelper = cl.loadClass(\"jdk.incubator.code.internal.QuotedHelper\");\n@@ -513,3 +512,2 @@\n-                MethodHandle makeQuoted = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n-                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, FUNC_OP_CLASS, Object[].class));\n-                HANDLE_MAKE_QUOTED = makeQuoted.bindTo(Lookup.IMPL_LOOKUP);\n+                QUOTED_OP_MH = Lookup.IMPL_LOOKUP.findStatic(QUOTED_CLASS, \"quotedOp\",\n+                        MethodType.methodType(QUOTED_CLASS, FUNC_OP_CLASS, Object[].class));\n@@ -602,1 +600,1 @@\n-        clb.withMethod(NAME_METHOD_QUOTED, CodeReflectionSupport.MTD_Quoted, ACC_PRIVATE + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethod(NAME_METHOD_QUOTED, CodeReflectionSupport.MTD_Quoted, ACC_PUBLIC + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.VarType;\n+\n@@ -29,0 +33,2 @@\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n@@ -42,1 +48,0 @@\n-\n@@ -68,1 +73,2 @@\n-        assert op.capturedValues().equals(new ArrayList<>(capturedValues.keySet()));\n+        assert Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList()\n+                .equals(new ArrayList<>(capturedValues.keySet()));\n@@ -96,0 +102,148 @@\n+\n+    \/\/ Take an op from its original context to a new one where operands and captured values are parameters\n+    public static CoreOp.FuncOp quoteOp(Op op) {\n+\n+        if (op.result() == null) {\n+            throw new IllegalArgumentException(\"Op not bound\");\n+        }\n+\n+        List<Value> inputOperandsAndCaptures = Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList();\n+\n+        \/\/ Build the function type\n+        List<TypeElement> params = inputOperandsAndCaptures.stream()\n+                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n+                .toList();\n+        FunctionType ft = FunctionType.functionType(CoreOp.QuotedOp.QUOTED_TYPE, params);\n+\n+        \/\/ Build the function that quotes the lambda\n+        return CoreOp.func(\"q\", ft).body(b -> {\n+            \/\/ Create variables as needed and obtain the operands and captured values for the copied lambda\n+            List<Value> outputOperandsAndCaptures = new ArrayList<>();\n+            for (int i = 0; i < inputOperandsAndCaptures.size(); i++) {\n+                Value inputValue = inputOperandsAndCaptures.get(i);\n+                Value outputValue = b.parameters().get(i);\n+                if (inputValue.type() instanceof VarType) {\n+                    outputValue = b.op(CoreOp.var(String.valueOf(i), outputValue));\n+                }\n+                outputOperandsAndCaptures.add(outputValue);\n+            }\n+\n+            \/\/ Quoted the lambda expression\n+            Value q = b.op(CoreOp.quoted(b.parentBody(), qb -> {\n+                \/\/ Map the entry block of the op's ancestor body to the quoted block\n+                \/\/ We are copying op in the context of the quoted block, the block mapping\n+                \/\/ ensures the use of operands and captured values are reachable when building\n+                qb.context().mapBlock(op.ancestorBody().entryBlock(), qb);\n+                \/\/ Map the op's operands and captured values\n+                qb.context().mapValues(inputOperandsAndCaptures, outputOperandsAndCaptures);\n+                \/\/ Return the op to be copied in the quoted operation\n+                return op;\n+            }));\n+            b.op(CoreOp._return(q));\n+        });\n+    }\n+\n+    private static RuntimeException invalidQuotedModel(CoreOp.FuncOp model) {\n+        return new RuntimeException(\"Invalid code model for quoted operation : \" + model);\n+    }\n+\n+    \/\/ Extract the quoted operation from funcOp and maps the operands and captured values to the runtime values\n+    public static Quoted quotedOp(CoreOp.FuncOp funcOp, Object[] args) {\n+\n+        if (funcOp.body().blocks().size() != 1) {\n+            throw invalidQuotedModel(funcOp);\n+        }\n+        Block fblock = funcOp.body().entryBlock();\n+\n+        if (fblock.ops().size() < 2) {\n+            throw invalidQuotedModel(funcOp);\n+        }\n+\n+        if (!(fblock.ops().get(fblock.ops().size() - 2) instanceof CoreOp.QuotedOp qop)) {\n+            throw invalidQuotedModel(funcOp);\n+        }\n+\n+        if (!(fblock.ops().getLast() instanceof CoreOp.ReturnOp returnOp)) {\n+            throw invalidQuotedModel(funcOp);\n+        }\n+        if (returnOp.returnValue() == null) {\n+            throw invalidQuotedModel(funcOp);\n+        }\n+        if (!returnOp.returnValue().equals(qop.result())) {\n+            throw invalidQuotedModel(funcOp);\n+        }\n+\n+        Op op = qop.quotedOp();\n+\n+        SequencedSet<Value> operandsAndCaptures = new LinkedHashSet<>();\n+        operandsAndCaptures.addAll(op.operands());\n+        operandsAndCaptures.addAll(op.capturedValues());\n+\n+        \/\/ validation rule of block params and constant op result\n+        Consumer<Value> validate = v -> {\n+            if (v.uses().isEmpty()) {\n+                throw invalidQuotedModel(funcOp);\n+            } else if (v.uses().size() == 1\n+                    && !(v.uses().iterator().next().op() instanceof CoreOp.VarOp vop && vop.result().uses().size() >= 1\n+                    && vop.result().uses().stream().noneMatch(u -> u.op().parentBlock() == fblock))\n+                    && !operandsAndCaptures.contains(v)) {\n+                throw invalidQuotedModel(funcOp);\n+            } else if (v.uses().size() > 1 && v.uses().stream().anyMatch(u -> u.op().parentBlock() == fblock)) {\n+                throw invalidQuotedModel(funcOp);\n+            }\n+        };\n+\n+        for (Block.Parameter p : fblock.parameters()) {\n+            validate.accept(p);\n+        }\n+\n+        List<Op> ops = fblock.ops().subList(0, fblock.ops().size() - 2);\n+        for (Op o : ops) {\n+            switch (o) {\n+                case CoreOp.VarOp varOp -> {\n+                    if (varOp.isUninitialized()) {\n+                        throw invalidQuotedModel(funcOp);\n+                    }\n+                    if (varOp.initOperand() instanceof Op.Result opr && !(opr.op() instanceof CoreOp.ConstantOp)) {\n+                        throw invalidQuotedModel(funcOp);\n+                    }\n+                }\n+                case CoreOp.ConstantOp cop -> validate.accept(cop.result());\n+                default -> throw invalidQuotedModel(funcOp);\n+            }\n+        }\n+\n+        \/\/ map captured values to their corresponding runtime values\n+        \/\/ captured value can be:\n+        \/\/ 1- block param\n+        \/\/ 2- result of VarOp whose initial value is constant\n+        \/\/ 3- result of VarOp whose initial value is block param\n+        \/\/ 4- result of ConstantOp\n+        List<Block.Parameter> params = funcOp.parameters();\n+        if (params.size() != args.length) {\n+            throw invalidQuotedModel(funcOp);\n+        }\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value v : operandsAndCaptures) {\n+            switch (v) {\n+                case Block.Parameter p -> {\n+                    Object rv = args[p.index()];\n+                    m.put(v, rv);\n+                }\n+                case Op.Result opr when opr.op() instanceof CoreOp.VarOp varOp -> {\n+                    if (varOp.initOperand() instanceof Op.Result r && r.op() instanceof CoreOp.ConstantOp cop) {\n+                        m.put(v, CoreOp.Var.of(cop.value()));\n+                    } else if (varOp.initOperand() instanceof Block.Parameter p) {\n+                        Object rv = args[p.index()];\n+                        m.put(v, CoreOp.Var.of(rv));\n+                    }\n+                }\n+                case Op.Result opr when opr.op() instanceof CoreOp.ConstantOp cop -> {\n+                    m.put(v, cop.value());\n+                }\n+                default -> throw invalidQuotedModel(funcOp);\n+            }\n+        }\n+\n+        return new Quoted(op, m);\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":156,"deletions":2,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.incubator.code.Quoted;\n@@ -56,1 +57,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -170,1 +170,1 @@\n-                                .loadConstant(quote(lop).toText())\n+                                .loadConstant(Quoted.quoteOp(lop).toText())\n@@ -1284,40 +1284,0 @@\n-\n-    static FuncOp quote(LambdaOp lop) {\n-        List<Value> captures = lop.capturedValues();\n-\n-        \/\/ Build the function type\n-        List<TypeElement> params = captures.stream()\n-                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n-                .toList();\n-        FunctionType ft = FunctionType.functionType(QuotedOp.QUOTED_TYPE, params);\n-\n-        \/\/ Build the function that quotes the lambda\n-        return CoreOp.func(\"q\", ft).body(b -> {\n-            \/\/ Create variables as needed and obtain the captured values\n-            \/\/ for the copied lambda\n-            List<Value> outputCaptures = new ArrayList<>();\n-            for (int i = 0; i < captures.size(); i++) {\n-                Value c = captures.get(i);\n-                Block.Parameter p = b.parameters().get(i);\n-                if (c.type() instanceof VarType _) {\n-                    Value var = b.op(CoreOp.var(String.valueOf(i), p));\n-                    outputCaptures.add(var);\n-                } else {\n-                    outputCaptures.add(p);\n-                }\n-            }\n-\n-            \/\/ Quoted the lambda expression\n-            Value q = b.op(CoreOp.quoted(b.parentBody(), qb -> {\n-                \/\/ Map the entry block of the lambda's ancestor body to the quoted block\n-                \/\/ We are copying lop in the context of the quoted block, the block mapping\n-                \/\/ ensures the use of captured values are reachable when building\n-                qb.context().mapBlock(lop.ancestorBody().entryBlock(), qb);\n-                \/\/ Map the lambda's captured values\n-                qb.context().mapValues(captures, outputCaptures);\n-                \/\/ Return the lambda to be copied in the quoted operation\n-                return lop;\n-            }));\n-            b.op(CoreOp._return(q));\n-        });\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":2,"deletions":42,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.internal;\n-\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import jdk.incubator.code.dialect.core.CoreOp.FuncOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class QuotedHelper {\n-    public static Quoted makeQuoted(MethodHandles.Lookup lookup, FuncOp op, Object[] args) {\n-        return (Quoted)Interpreter.invoke(lookup, op, args);\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/QuotedHelper.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -232,1 +232,1 @@\n-    static final class VarBox\n+    public static final class VarBox\n@@ -240,1 +240,1 @@\n-        VarBox(Object value) {\n+        public VarBox(Object value) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-    opens jdk.incubator.code.internal to java.base;\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/module-info.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,451 @@\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.parser.OpParser;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.function.IntUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestQuoteOp\n+ *\/\n+public class TestQuoteOp {\n+\n+    @CodeReflection\n+    public void f(int i) {\n+        String s = \"abc\";\n+        Runnable r = () -> {\n+            System.out.println(i + s + hashCode());\n+        };\n+    }\n+\n+    @Test\n+    void testQuoteOpThatHasCaptures() throws NoSuchMethodException {\n+        Method f = getClass().getDeclaredMethod(\"f\", int.class);\n+        CoreOp.FuncOp fm = Op.ofMethod(f).orElseThrow();\n+        Op lop = fm.body().entryBlock().ops().stream().filter(op -> op instanceof JavaOp.LambdaOp).findFirst().orElseThrow();\n+\n+        CoreOp.FuncOp funcOp = Quoted.quoteOp(lop);\n+\n+        Object[] args = new Object[]{1, \"a\", this};\n+        Quoted quoted = Quoted.quotedOp(funcOp, args);\n+        \/\/ op must have the same structure as lop\n+        \/\/ for the moment, we don't have utility to check that\n+\n+        Assert.assertTrue(lop.getClass().isInstance(quoted.op()));\n+\n+        Iterator<Object> iterator = quoted.capturedValues().values().iterator();\n+\n+        Assert.assertEquals(((CoreOp.Var) iterator.next()).value(), args[0]);\n+        Assert.assertEquals(((CoreOp.Var) iterator.next()).value(), args[1]);\n+        Assert.assertEquals(iterator.next(), args[2]);\n+    }\n+\n+    @CodeReflection\n+    static void g(String s) {\n+        boolean b = s.startsWith(\"a\");\n+    }\n+\n+    @Test\n+    void testQuoteOpThatHasOperands() throws NoSuchMethodException { \/\/ op with operands\n+        Method g = getClass().getDeclaredMethod(\"g\", String.class);\n+        CoreOp.FuncOp gm = Op.ofMethod(g).orElseThrow();\n+        Op invOp = gm.body().entryBlock().ops().stream().filter(o -> o instanceof JavaOp.InvokeOp).findFirst().orElseThrow();\n+\n+        CoreOp.FuncOp funcOp = Quoted.quoteOp(invOp);\n+\n+        Object[] args = {\"abc\", \"b\"};\n+        Quoted quoted = Quoted.quotedOp(funcOp, args);\n+\n+        Assert.assertTrue(invOp.getClass().isInstance(quoted.op()));\n+\n+        Iterator<Object> iterator = quoted.capturedValues().values().iterator();\n+\n+        Assert.assertEquals(iterator.next(), args[0]);\n+        Assert.assertEquals(iterator.next(), args[1]);\n+    }\n+\n+    @Test\n+    void testWithJavacModel() {\n+        final int y = 88;\n+        int z = 99;\n+        Quotable q = (IntUnaryOperator & Quotable) x -> x + y + z + hashCode();\n+\n+        \/\/ access FuncOp created by javac\n+        Quoted quoted = Op.ofQuotable(q).orElseThrow();\n+        Op op = quoted.op();\n+        CoreOp.QuotedOp qop = ((CoreOp.QuotedOp) op.ancestorBody().parentOp());\n+        CoreOp.FuncOp fop = ((CoreOp.FuncOp) qop.ancestorBody().parentOp());\n+\n+        Object[] args = {this, 111};\n+        Quoted quoted2 = Quoted.quotedOp(fop, args);\n+\n+        Iterator<Object> iterator = quoted2.capturedValues().values().iterator();\n+\n+        Assert.assertEquals(((CoreOp.Var) iterator.next()).value(), y);\n+        Assert.assertEquals(((CoreOp.Var) iterator.next()).value(), args[1]);\n+        Assert.assertEquals(iterator.next(), args[0]);\n+    }\n+\n+    @DataProvider\n+    Object[][] invalidCases() {\n+        return new Object[][]{\n+              \/\/ TODO describe error in a comment\n+                {\n+                        \/\/ func op must have one block\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    branch ^block_1;\n+\n+  ^block_1:\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+        %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+            return;\n+        };\n+        yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{}\n+                },\n+                {\n+              \/\/ before last op must be QuotedOp\n+              \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+          return;\n+      };\n+      yield %6;\n+    };\n+    %0 : java.type:\"boolean\" = constant @false;\n+    return %5;\n+};\n+\"\"\", new Object[]{}\n+                },\n+                {\n+                        \/\/ last op must be ReturnOp\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+          return;\n+      };\n+      yield %6;\n+    };\n+    yield %5;\n+};\n+\"\"\", new Object[]{}\n+                },\n+                {\n+                        \/\/ the result of QuotedOp must be returned\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+          return;\n+      };\n+      yield %6;\n+    };\n+    return;\n+};\n+\"\"\", new Object[]{}\n+                },\n+                {\n+                        \/\/ the result of QuotedOp must be returned\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %0 : java.type:\"int\" = constant @1;\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+          return;\n+      };\n+      yield %6;\n+    };\n+    return %0;\n+};\n+\"\"\", new Object[]{}\n+                },\n+                {\n+                        \/\/ param must be used\n+                        \"\"\"\n+func @\"q\" (%0 : java.type:\"Object\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+          return;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{\"s\"}\n+                },\n+                {\n+                        \/\/ param used more than once, all uses must be as operand or capture of quoted op\n+                        \"\"\"\n+func @\"q\" (%0 : java.type:\"int\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %2 : Var<java.type:\"int\"> = var %0 @\"y\";\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+        %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+            return %0;\n+        };\n+        yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{1}\n+                },\n+                {\n+                        \/\/ operations before quoted op must be ConstantOp or VarOp\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %0 : java.type:\"java.lang.String\" = new @java.ref:\"java.lang.String::()\";\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+           %7 : java.type:\"int\" = invoke %0 @java.ref:\"java.lang.String::length():int\";\n+           return %7;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{}\n+                },\n+                {\n+                        \/\/ constant op must be used\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %0 : java.type:\"int\" = constant @1;\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+          return;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{}\n+                },\n+                {\n+                        \/\/ constant used more than once, all its uses must be as operand or capture of quoted op\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %0 : java.type:\"int\" = constant @1;\n+    %1 : Var<java.type:\"int\"> = var %0 @\"y\";\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+            %7 : java.type:\"int\" = var.load %1;\n+            %8 : java.type:\"int\" = add %0 %7;\n+            return %8;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{}\n+                },\n+                {\n+                        \/\/ var op must be initialized with param or result of constant op\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %1 : Var<java.type:\"int\"> = var @\"y\";\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+            %7 : java.type:\"int\" = var.load %1;\n+            return %7;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{}\n+                },\n+                {\n+                        \/\/ model must contain at least two operations\n+                        \"\"\"\n+func @\"q\" (%5 : java.type:\"jdk.incubator.code.Quoted\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    return %5;\n+};\n+\"\"\", new Object[]{null}\n+                },\n+                \/\/ args length must be equal to params size\n+                {\n+                        \"\"\"\n+func @\"q\" (%0 : java.type:\"int\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+            return %0;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{1, 2}\n+                }\n+      };\n+}\n+\n+\n+    @Test(dataProvider = \"invalidCases\")\n+    void testInvalidCases(String model, Object[] args) {\n+        CoreOp.FuncOp fop = ((CoreOp.FuncOp) OpParser.fromStringOfJavaCodeModel(model));\n+        Assert.assertThrows(RuntimeException.class, () -> Quoted.quotedOp(fop, args));\n+    }\n+\n+    @DataProvider\n+    Object[][] validCases() {\n+        return new Object[][] {\n+                {\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+          return;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[] {}\n+                },\n+                {\n+                        \"\"\"\n+func @\"q\" (%0 : java.type:\"int\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+            return %0;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[] {1}\n+                },\n+                {\n+                        \"\"\"\n+func @\"q\" (%0 : java.type:\"int\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %1 : Var<java.type:\"int\"> = var %0;\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+            %7 : java.type:\"int\" = var.load %1;\n+            return %7;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[] {2}\n+                },\n+                {\n+                        \"\"\"\n+func @\"q\" (%0 : java.type:\"int\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+            %7 : java.type:\"int\" = add %0 %0;\n+            %8 : java.type:\"int\" = mul %0 %0;\n+            %9 : java.type:\"int\" = sub %8 %7;\n+            return %9;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[] {3}\n+                },\n+                {\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %0 : java.type:\"int\" = constant @1;\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+            return %0;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[] {}\n+                },\n+                {\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %0 : java.type:\"int\" = constant @1;\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+            %7 : java.type:\"int\" = add %0 %0;\n+            %8 : java.type:\"int\" = mul %0 %0;\n+            %9 : java.type:\"int\" = sub %8 %7;\n+            return %9;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[] {}\n+                },\n+                {\n+                        \"\"\"\n+func @\"q\" ()java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %0 : java.type:\"int\" = constant @1;\n+    %1 : Var<java.type:\"int\"> = var %0;\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+            %7 : java.type:\"int\" = var.load %1;\n+            %8 : java.type:\"int\" = mul %7 %7;\n+            return %8;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[] {}\n+                },\n+                {\n+                        \"\"\"\n+func @\"q\" (%0 : java.type:\"int\", %2 : java.type:\"int\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %1 : Var<java.type:\"int\"> = var %0;\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+      %6 : java.type:\"java.util.function.IntSupplier\" = lambda ()java.type:\"int\" -> {\n+            %7 : java.type:\"int\" = var.load %1;\n+            %8 : java.type:\"int\" = add %7 %2;\n+            return %8;\n+      };\n+      yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{8, 9}\n+                }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"validCases\")\n+    void testValidCases(String model, Object[] args) {\n+        CoreOp.FuncOp fop = ((CoreOp.FuncOp) OpParser.fromStringOfJavaCodeModel(model));\n+        Quoted quoted = Quoted.quotedOp(fop, args);\n+\n+        for (Map.Entry<Value, Object> e : quoted.capturedValues().entrySet()) {\n+            Value sv = e.getKey();\n+            Object rv = e.getValue();\n+            \/\/ assert only when captured value is block param, or result of VarOp initialized with block param\n+            if (sv instanceof Op.Result opr && opr.op() instanceof CoreOp.VarOp vop\n+                    && vop.initOperand() instanceof Block.Parameter p) {\n+                Assert.assertEquals(((CoreOp.Var) rv).value(), args[p.index()]);\n+            } else if (sv instanceof Block.Parameter p) {\n+                Assert.assertEquals(rv, args[p.index()]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":451,"deletions":0,"binary":false,"changes":451,"status":"added"}]}