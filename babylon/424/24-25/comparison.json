{"files":[{"patch":"@@ -28,0 +28,4 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.VarType;\n+\n@@ -29,0 +33,1 @@\n+import java.util.function.Consumer;\n@@ -97,0 +102,142 @@\n+\n+    public static CoreOp.FuncOp quoteOp(Op op) {\n+\n+        if (op.result() == null) {\n+            throw new IllegalArgumentException(\"Op not bound\");\n+        }\n+\n+        List<Value> inputOperandsAndCaptures = Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList();\n+\n+        \/\/ Build the function type\n+        List<TypeElement> params = inputOperandsAndCaptures.stream()\n+                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n+                .toList();\n+        FunctionType ft = FunctionType.functionType(CoreOp.QuotedOp.QUOTED_TYPE, params);\n+\n+        \/\/ Build the function that quotes the lambda\n+        return CoreOp.func(\"q\", ft).body(b -> {\n+            \/\/ Create variables as needed and obtain the operands and captured values for the copied lambda\n+            List<Value> outputOperandsAndCaptures = new ArrayList<>();\n+            for (int i = 0; i < inputOperandsAndCaptures.size(); i++) {\n+                Value inputValue = inputOperandsAndCaptures.get(i);\n+                Value outputValue = b.parameters().get(i);\n+                if (inputValue.type() instanceof VarType) {\n+                    outputValue = b.op(CoreOp.var(String.valueOf(i), outputValue));\n+                }\n+                outputOperandsAndCaptures.add(outputValue);\n+            }\n+\n+            \/\/ Quoted the lambda expression\n+            Value q = b.op(CoreOp.quoted(b.parentBody(), qb -> {\n+                \/\/ Map the entry block of the op's ancestor body to the quoted block\n+                \/\/ We are copying op in the context of the quoted block, the block mapping\n+                \/\/ ensures the use of operands and captured values are reachable when building\n+                qb.context().mapBlock(op.ancestorBody().entryBlock(), qb);\n+                \/\/ Map the op's operands and captured values\n+                qb.context().mapValues(inputOperandsAndCaptures, outputOperandsAndCaptures);\n+                \/\/ Return the op to be copied in the quoted operation\n+                return op;\n+            }));\n+            b.op(CoreOp._return(q));\n+        });\n+    }\n+\n+    public static Quoted quotedOp(CoreOp.FuncOp funcOp, Object[] args) {\n+\n+        if (funcOp.body().blocks().size() != 1) {\n+            throw new IllegalArgumentException(\"Argument operation has more then one block\");\n+        }\n+        Block fblock = funcOp.body().entryBlock();\n+\n+        if (fblock.ops().size() < 2) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        if (!(fblock.ops().get(fblock.ops().size() - 2) instanceof CoreOp.QuotedOp qop)) {\n+            throw new IllegalArgumentException(\"Before last operation is not a QuotedOp\");\n+        }\n+\n+        if (!(fblock.ops().getLast() instanceof CoreOp.ReturnOp returnOp)) {\n+            throw new IllegalArgumentException(\"Last operation not a ReturnOp\");\n+        }\n+        if (returnOp.returnValue() == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (!returnOp.returnValue().equals(qop.result())) {\n+            throw new IllegalArgumentException(\"Argument operation doesn't return the result of QuotedOp\");\n+        }\n+\n+        Op op = qop.quotedOp();\n+\n+        SequencedSet<Value> operandsAndCaptures = new LinkedHashSet<>();\n+        operandsAndCaptures.addAll(op.operands());\n+        operandsAndCaptures.addAll(op.capturedValues());\n+\n+        \/\/ validation rule of block params and constant op result\n+        Consumer<Value> validate = v -> {\n+            if (v.uses().isEmpty()) {\n+                throw new IllegalArgumentException();\n+            } else if (v.uses().size() == 1\n+                    && !(v.uses().iterator().next().op() instanceof CoreOp.VarOp vop && vop.result().uses().size() >= 1\n+                    && vop.result().uses().stream().noneMatch(u -> u.op().parentBlock() == fblock))\n+                    && !operandsAndCaptures.contains(v)) {\n+                throw new IllegalArgumentException();\n+            } else if (v.uses().size() > 1 && v.uses().stream().anyMatch(u -> u.op().parentBlock() == fblock)) {\n+                throw new IllegalArgumentException();\n+            }\n+        };\n+\n+        for (Block.Parameter p : fblock.parameters()) {\n+            validate.accept(p);\n+        }\n+\n+        List<Op> ops = fblock.ops().subList(0, fblock.ops().size() - 2);\n+        for (Op o : ops) {\n+            switch (o) {\n+                case CoreOp.VarOp varOp -> {\n+                    if (varOp.isUninitialized()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+                    if (varOp.initOperand() instanceof Op.Result opr && !(opr.op() instanceof CoreOp.ConstantOp)) {\n+                        throw new IllegalArgumentException(\"VarOp initial value came from an operation that's not a ConstantOp\");\n+                    }\n+                }\n+                case CoreOp.ConstantOp cop -> validate.accept(cop.result());\n+                default -> throw new IllegalArgumentException(\"Operation not a VarOp nor a ConstantOp, \" + o);\n+            }\n+        }\n+\n+        \/\/ map captured values to their corresponding runtime values\n+        \/\/ captured value can be:\n+        \/\/ 1- block param\n+        \/\/ 2- result of VarOp whose initial value is constant\n+        \/\/ 3- result of VarOp whose initial value is block param\n+        \/\/ 4- result of ConstantOp\n+        List<Block.Parameter> params = funcOp.parameters();\n+        if (params.size() != args.length) {\n+            throw new IllegalArgumentException();\n+        }\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value v : operandsAndCaptures) {\n+            switch (v) {\n+                case Block.Parameter p -> {\n+                    Object rv = args[p.index()];\n+                    m.put(v, rv);\n+                }\n+                case Op.Result opr when opr.op() instanceof CoreOp.VarOp varOp -> {\n+                    if (varOp.initOperand() instanceof Op.Result r && r.op() instanceof CoreOp.ConstantOp cop) {\n+                        m.put(v, CoreOp.Var.of(cop.value()));\n+                    } else if (varOp.initOperand() instanceof Block.Parameter p) {\n+                        Object rv = args[p.index()];\n+                        m.put(v, CoreOp.Var.of(rv));\n+                    }\n+                }\n+                case Op.Result opr when opr.op() instanceof CoreOp.ConstantOp cop -> {\n+                    m.put(v, cop.value());\n+                }\n+                default -> throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        return new Quoted(op, m);\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.incubator.code.Quoted;\n@@ -56,1 +57,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -170,1 +170,1 @@\n-                                .loadConstant(CoreOp.quoteOp(lop).toText())\n+                                .loadConstant(Quoted.quoteOp(lop).toText())\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.stream.Stream;\n@@ -1793,142 +1792,0 @@\n-\n-    public static CoreOp.FuncOp quoteOp(Op op) {\n-\n-        if (op.result() == null) {\n-            throw new IllegalArgumentException(\"Op not bound\");\n-        }\n-\n-        List<Value> inputOperandsAndCaptures = Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList();\n-\n-        \/\/ Build the function type\n-        List<TypeElement> params = inputOperandsAndCaptures.stream()\n-                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n-                .toList();\n-        FunctionType ft = FunctionType.functionType(CoreOp.QuotedOp.QUOTED_TYPE, params);\n-\n-        \/\/ Build the function that quotes the lambda\n-        return CoreOp.func(\"q\", ft).body(b -> {\n-            \/\/ Create variables as needed and obtain the operands and captured values for the copied lambda\n-            List<Value> outputOperandsAndCaptures = new ArrayList<>();\n-            for (int i = 0; i < inputOperandsAndCaptures.size(); i++) {\n-                Value inputValue = inputOperandsAndCaptures.get(i);\n-                Value outputValue = b.parameters().get(i);\n-                if (inputValue.type() instanceof VarType) {\n-                    outputValue = b.op(CoreOp.var(String.valueOf(i), outputValue));\n-                }\n-                outputOperandsAndCaptures.add(outputValue);\n-            }\n-\n-            \/\/ Quoted the lambda expression\n-            Value q = b.op(CoreOp.quoted(b.parentBody(), qb -> {\n-                \/\/ Map the entry block of the op's ancestor body to the quoted block\n-                \/\/ We are copying op in the context of the quoted block, the block mapping\n-                \/\/ ensures the use of operands and captured values are reachable when building\n-                qb.context().mapBlock(op.ancestorBody().entryBlock(), qb);\n-                \/\/ Map the op's operands and captured values\n-                qb.context().mapValues(inputOperandsAndCaptures, outputOperandsAndCaptures);\n-                \/\/ Return the op to be copied in the quoted operation\n-                return op;\n-            }));\n-            b.op(CoreOp._return(q));\n-        });\n-    }\n-\n-    public static Quoted quotedOp(FuncOp funcOp, Object[] args) {\n-\n-        if (funcOp.body().blocks().size() != 1) {\n-            throw new IllegalArgumentException(\"Argument operation has more then one block\");\n-        }\n-        Block fblock = funcOp.body().entryBlock();\n-\n-        if (fblock.ops().size() < 2) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        if (!(fblock.ops().get(fblock.ops().size() - 2) instanceof CoreOp.QuotedOp qop)) {\n-            throw new IllegalArgumentException(\"Before last operation is not a QuotedOp\");\n-        }\n-\n-        if (!(fblock.ops().getLast() instanceof CoreOp.ReturnOp returnOp)) {\n-            throw new IllegalArgumentException(\"Last operation not a ReturnOp\");\n-        }\n-        if (returnOp.returnValue() == null) {\n-            throw new IllegalArgumentException();\n-        }\n-        if (!returnOp.returnValue().equals(qop.result())) {\n-            throw new IllegalArgumentException(\"Argument operation doesn't return the result of QuotedOp\");\n-        }\n-\n-        Op op = qop.quotedOp();\n-\n-        SequencedSet<Value> operandsAndCaptures = new LinkedHashSet<>();\n-        operandsAndCaptures.addAll(op.operands());\n-        operandsAndCaptures.addAll(op.capturedValues());\n-\n-        \/\/ validation rule of block params and constant op result\n-        Consumer<Value> validate = v -> {\n-            if (v.uses().isEmpty()) {\n-                throw new IllegalArgumentException();\n-            } else if (v.uses().size() == 1\n-                    && !(v.uses().iterator().next().op() instanceof CoreOp.VarOp vop && vop.result().uses().size() >= 1\n-                    && vop.result().uses().stream().noneMatch(u -> u.op().parentBlock() == fblock))\n-                    && !operandsAndCaptures.contains(v)) {\n-                throw new IllegalArgumentException();\n-            } else if (v.uses().size() > 1 && v.uses().stream().anyMatch(u -> u.op().parentBlock() == fblock)) {\n-                throw new IllegalArgumentException();\n-            }\n-        };\n-\n-        for (Block.Parameter p : fblock.parameters()) {\n-            validate.accept(p);\n-        }\n-\n-        List<Op> ops = fblock.ops().subList(0, fblock.ops().size() - 2);\n-        for (Op o : ops) {\n-            switch (o) {\n-                case CoreOp.VarOp varOp -> {\n-                    if (varOp.isUninitialized()) {\n-                        throw new IllegalArgumentException();\n-                    }\n-                    if (varOp.initOperand() instanceof Op.Result opr && !(opr.op() instanceof CoreOp.ConstantOp)) {\n-                        throw new IllegalArgumentException(\"VarOp initial value came from an operation that's not a ConstantOp\");\n-                    }\n-                }\n-                case CoreOp.ConstantOp cop -> validate.accept(cop.result());\n-                default -> throw new IllegalArgumentException(\"Operation not a VarOp nor a ConstantOp, \" + o);\n-            }\n-        }\n-\n-        \/\/ map captured values to their corresponding runtime values\n-        \/\/ captured value can be:\n-        \/\/ 1- block param\n-        \/\/ 2- result of VarOp whose initial value is constant\n-        \/\/ 3- result of VarOp whose initial value is block param\n-        \/\/ 4- result of ConstantOp\n-        List<Block.Parameter> params = funcOp.parameters();\n-        if (params.size() != args.length) {\n-            throw new IllegalArgumentException();\n-        }\n-        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n-        for (Value v : operandsAndCaptures) {\n-            switch (v) {\n-                case Block.Parameter p -> {\n-                    Object rv = args[p.index()];\n-                    m.put(v, rv);\n-                }\n-                case Result opr when opr.op() instanceof CoreOp.VarOp varOp -> {\n-                    if (varOp.initOperand() instanceof Result r && r.op() instanceof CoreOp.ConstantOp cop) {\n-                        m.put(v, CoreOp.Var.of(cop.value()));\n-                    } else if (varOp.initOperand() instanceof Block.Parameter p) {\n-                        Object rv = args[p.index()];\n-                        m.put(v, CoreOp.Var.of(rv));\n-                    }\n-                }\n-                case Result opr when opr.op() instanceof CoreOp.ConstantOp cop -> {\n-                    m.put(v, cop.value());\n-                }\n-                default -> throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        return new Quoted(op, m);\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":0,"deletions":143,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -35,1 +34,1 @@\n-        return CoreOp.quotedOp(funcOp, args);\n+        return Quoted.quotedOp(funcOp, args);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/QuotedHelper.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        CoreOp.FuncOp funcOp = CoreOp.quoteOp(lop);\n+        CoreOp.FuncOp funcOp = Quoted.quoteOp(lop);\n@@ -43,1 +43,1 @@\n-        Quoted quoted = CoreOp.quotedOp(funcOp, args);\n+        Quoted quoted = Quoted.quotedOp(funcOp, args);\n@@ -67,1 +67,1 @@\n-        CoreOp.FuncOp funcOp = CoreOp.quoteOp(invOp);\n+        CoreOp.FuncOp funcOp = Quoted.quoteOp(invOp);\n@@ -70,1 +70,1 @@\n-        Quoted quoted = CoreOp.quotedOp(funcOp, args);\n+        Quoted quoted = Quoted.quotedOp(funcOp, args);\n@@ -93,1 +93,1 @@\n-        Quoted quoted2 = CoreOp.quotedOp(fop, args);\n+        Quoted quoted2 = Quoted.quotedOp(fop, args);\n@@ -304,1 +304,1 @@\n-        Assert.assertThrows(IllegalArgumentException.class, () -> CoreOp.quotedOp(fop, args));\n+        Assert.assertThrows(IllegalArgumentException.class, () -> Quoted.quotedOp(fop, args));\n@@ -437,1 +437,1 @@\n-        Quoted quoted = CoreOp.quotedOp(fop, args);\n+        Quoted quoted = Quoted.quotedOp(fop, args);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}