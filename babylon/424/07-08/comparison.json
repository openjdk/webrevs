{"files":[{"patch":"@@ -4442,33 +4442,17 @@\n-        return func(\"q\", FunctionType.functionType(JavaType.type(Quoted.class))).body(block -> {\n-\n-            List<Value> capturedValues = op.capturedValues();\n-\n-            for (Value v : Stream.concat(capturedValues.stream(), op.operands().stream()).toList()) {\n-                TypeElement t;\n-                if (v instanceof Op.Result opr && opr.op() instanceof VarOp varOp) {\n-                    t = varOp.varValueType();\n-                } else {\n-                    t = v.type();\n-                }\n-                Block.Parameter p = block.parameter(t);\n-                Op.Result nv = block.op(var(p));\n-                block.context().mapValue(v, nv);\n-            }\n-\n-            Body.Builder qbody = Body.Builder.of(block.parentBody(), FunctionType.VOID, CopyContext.create(block.context()));\n-            Block.Builder qblock = qbody.entryBlock();\n-\n-            if (op.ancestorBody() != null) {\n-                \/\/ needed for reachability check (of captured values) to succeed\n-                qblock.context().mapBlock(op.ancestorBody().entryBlock(), qblock);\n-            }\n-\n-            \/\/ if op has operands, they will be represented by VarOp results initialized with block params\n-            \/\/ we may need to do var.load for some of the operands\n-            Map<Value, Value> m2 = new HashMap<>();\n-            for (Value operand : op.operands()) {\n-                if (!(operand instanceof Op.Result r && r.op() instanceof VarOp)) {\n-                    Value capVar = qblock.context().getValue(operand);\n-                    Op.Result capVal = qblock.op(varLoad(capVar));\n-                    m2.put(operand, capVar);\n-                    qblock.context().mapValue(operand, capVal);\n+        List<Value> inputOperandsAndCaptures = Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList();\n+\n+        \/\/ Build the function type\n+        List<TypeElement> params = inputOperandsAndCaptures.stream()\n+                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n+                .toList();\n+        FunctionType ft = FunctionType.functionType(QuotedOp.QUOTED_TYPE, params);\n+\n+        \/\/ Build the function that quotes the lambda\n+        return CoreOp.func(\"q\", ft).body(b -> {\n+            \/\/ Create variables as needed and obtain the operands and captured values for the copied lambda\n+            List<Value> outputOperandsAndCaptures = new ArrayList<>();\n+            for (int i = 0; i < inputOperandsAndCaptures.size(); i++) {\n+                Value inputValue = inputOperandsAndCaptures.get(i);\n+                Value outputValue = b.parameters().get(i);\n+                if (inputValue.type() instanceof VarType _) {\n+                    outputValue = b.op(CoreOp.var(String.valueOf(i), outputValue));\n@@ -4476,0 +4460,1 @@\n+                outputOperandsAndCaptures.add(outputValue);\n@@ -4478,32 +4463,12 @@\n-            \/\/@@@ op transformer only runs on operations inside bodies of op\n-            Op.Result opr = qblock.op(op, (b, o) -> {\n-                \/\/ a modified copy transformer, that insert var.load before use of captured values (if needed)\n-                Map<Value, Value> m = new HashMap<>();\n-                for (Value operand : o.operands()) {\n-                    if (capturedValues.contains(operand) && !(operand instanceof Op.Result r && r.op() instanceof VarOp)) {\n-                        Value capVar = b.context().getValue(operand);\n-                        Op.Result capVal = b.op(varLoad(capVar));\n-                        m.put(operand, capVar);\n-                        b.context().mapValue(operand, capVal);\n-                    }\n-                }\n-\n-                b.op(o);\n-\n-                for (Value k : m.keySet()) {\n-                    b.context().mapValue(k, m.get(k));\n-                }\n-\n-                return b;\n-            });\n-\n-            \/\/ restore the mapping for op's operands\n-            for (Map.Entry<Value, Value> e : m2.entrySet()) {\n-                qblock.context().mapValue(e.getKey(), e.getValue());\n-            }\n-\n-            qblock.op(_yield(opr));\n-\n-            Op.Result qopr = block.op(quoted(qbody));\n-\n-            block.op(_return(qopr));\n+            \/\/ Quoted the lambda expression\n+            Value q = b.op(CoreOp.quoted(b.parentBody(), qb -> {\n+                \/\/ Map the entry block of the lambda's ancestor body to the quoted block\n+                \/\/ We are copying lop in the context of the quoted block, the block mapping\n+                \/\/ ensures the use of operands and captured values are reachable when building\n+                qb.context().mapBlock(op.ancestorBody().entryBlock(), qb);\n+                \/\/ Map the op's operands and captured values\n+                qb.context().mapValues(inputOperandsAndCaptures, outputOperandsAndCaptures);\n+                \/\/ Return the op to be copied in the quoted operation\n+                return op;\n+            }));\n+            b.op(CoreOp._return(q));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":30,"deletions":65,"binary":false,"changes":95,"status":"modified"}]}