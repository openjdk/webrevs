{"files":[{"patch":"@@ -524,3 +524,2 @@\n-                MethodHandle makeQuoted = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n-                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, FUNC_OP_CLASS, Object[].class));\n-                HANDLE_MAKE_QUOTED = makeQuoted.bindTo(Lookup.IMPL_LOOKUP);\n+                HANDLE_MAKE_QUOTED = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n+                        MethodType.methodType(QUOTED_CLASS, FUNC_OP_CLASS, Object[].class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-                                .loadConstant(quote(lop).toText())\n+                                .loadConstant(CoreOp.quoteOp(lop).toText())\n@@ -1288,40 +1288,0 @@\n-\n-    static FuncOp quote(LambdaOp lop) {\n-        List<Value> captures = lop.capturedValues();\n-\n-        \/\/ Build the function type\n-        List<TypeElement> params = captures.stream()\n-                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n-                .toList();\n-        FunctionType ft = FunctionType.functionType(QuotedOp.QUOTED_TYPE, params);\n-\n-        \/\/ Build the function that quotes the lambda\n-        return CoreOp.func(\"q\", ft).body(b -> {\n-            \/\/ Create variables as needed and obtain the captured values\n-            \/\/ for the copied lambda\n-            List<Value> outputCaptures = new ArrayList<>();\n-            for (int i = 0; i < captures.size(); i++) {\n-                Value c = captures.get(i);\n-                Block.Parameter p = b.parameters().get(i);\n-                if (c.type() instanceof VarType _) {\n-                    Value var = b.op(CoreOp.var(String.valueOf(i), p));\n-                    outputCaptures.add(var);\n-                } else {\n-                    outputCaptures.add(p);\n-                }\n-            }\n-\n-            \/\/ Quoted the lambda expression\n-            Value q = b.op(CoreOp.quoted(b.parentBody(), qb -> {\n-                \/\/ Map the entry block of the lambda's ancestor body to the quoted block\n-                \/\/ We are copying lop in the context of the quoted block, the block mapping\n-                \/\/ ensures the use of captured values are reachable when building\n-                qb.context().mapBlock(lop.ancestorBody().entryBlock(), qb);\n-                \/\/ Map the lambda's captured values\n-                qb.context().mapValues(captures, outputCaptures);\n-                \/\/ Return the lambda to be copied in the quoted operation\n-                return lop;\n-            }));\n-            b.op(CoreOp._return(q));\n-        });\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n@@ -31,1 +31,0 @@\n-import jdk.incubator.code.parser.OpParser;\n@@ -33,1 +32,3 @@\n-import java.lang.invoke.MethodHandles;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.SequencedMap;\n@@ -36,2 +37,27 @@\n-    public static Quoted makeQuoted(MethodHandles.Lookup lookup, FuncOp op, Object[] args) {\n-        return (Quoted)Interpreter.invoke(lookup, op, args);\n+\n+    public static Quoted makeQuoted(FuncOp funcOp, Object[] args) {\n+\n+        CoreOp.OpAndValues opAndValues = CoreOp.quotedOp(funcOp);\n+\n+        \/\/ map captured values to their corresponding runtime values\n+        \/\/ captured value can be:\n+        \/\/ 1- block param\n+        \/\/ 2- result of VarOp whose initial value is constant\n+        \/\/ 3- result of VarOp whose initial value is block param\n+        List<Block.Parameter> params = funcOp.parameters();\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value v : opAndValues.operandsAndCaptures()) {\n+            if (v instanceof Block.Parameter p) {\n+                Object rv = args[params.indexOf(p)];\n+                m.put(v, rv);\n+            } else if (v instanceof Op.Result opr && opr.op() instanceof CoreOp.VarOp varOp) {\n+                if (varOp.initOperand() instanceof Op.Result r && r.op() instanceof CoreOp.ConstantOp cop) {\n+                    m.put(v, CoreOp.Var.of(cop.value()));\n+                } else if (varOp.initOperand() instanceof Block.Parameter p) {\n+                    Object rv = args[params.indexOf(p)];\n+                    m.put(v, CoreOp.Var.of(rv));\n+                }\n+            }\n+        }\n+\n+        return new Quoted(opAndValues.op(), m);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/QuotedHelper.java","additions":32,"deletions":6,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-    static final class VarBox\n+    public static final class VarBox\n@@ -238,1 +238,1 @@\n-        VarBox(Object value) {\n+        public VarBox(Object value) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -4438,0 +4439,105 @@\n+\n+    public static FuncOp quoteOp(Op op) {\n+\n+        if (op.result() == null) {\n+            throw new IllegalArgumentException(\"Op not bound\");\n+        }\n+\n+        List<Value> inputOperandsAndCaptures = Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList();\n+\n+        \/\/ Build the function type\n+        List<TypeElement> params = inputOperandsAndCaptures.stream()\n+                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n+                .toList();\n+        FunctionType ft = FunctionType.functionType(QuotedOp.QUOTED_TYPE, params);\n+\n+        \/\/ Build the function that quotes the lambda\n+        return CoreOp.func(\"q\", ft).body(b -> {\n+            \/\/ Create variables as needed and obtain the operands and captured values for the copied lambda\n+            List<Value> outputOperandsAndCaptures = new ArrayList<>();\n+            for (int i = 0; i < inputOperandsAndCaptures.size(); i++) {\n+                Value inputValue = inputOperandsAndCaptures.get(i);\n+                Value outputValue = b.parameters().get(i);\n+                if (inputValue.type() instanceof VarType _) {\n+                    outputValue = b.op(CoreOp.var(String.valueOf(i), outputValue));\n+                }\n+                outputOperandsAndCaptures.add(outputValue);\n+            }\n+\n+            \/\/ Quoted the lambda expression\n+            Value q = b.op(CoreOp.quoted(b.parentBody(), qb -> {\n+                \/\/ Map the entry block of the lambda's ancestor body to the quoted block\n+                \/\/ We are copying lop in the context of the quoted block, the block mapping\n+                \/\/ ensures the use of operands and captured values are reachable when building\n+                qb.context().mapBlock(op.ancestorBody().entryBlock(), qb);\n+                \/\/ Map the op's operands and captured values\n+                qb.context().mapValues(inputOperandsAndCaptures, outputOperandsAndCaptures);\n+                \/\/ Return the op to be copied in the quoted operation\n+                return op;\n+            }));\n+            b.op(CoreOp._return(q));\n+        });\n+    }\n+\n+    public static OpAndValues quotedOp(FuncOp funcOp) {\n+\n+        if (funcOp.body().blocks().size() != 1) {\n+            throw new IllegalArgumentException(\"Argument operation has more then one block\");\n+        }\n+        Block fblock = funcOp.body().entryBlock();\n+\n+        if (!(fblock.ops().get(fblock.ops().size() - 2) instanceof QuotedOp qop)) {\n+            throw new IllegalArgumentException(\"Before last operation is not a QuotedOp\");\n+        }\n+\n+        if (!(fblock.ops().getLast() instanceof ReturnOp returnOp)) {\n+            throw new IllegalArgumentException(\"Last operation not a ReturnOp\");\n+        }\n+        if (!returnOp.returnValue().equals(qop.result())) {\n+            throw new IllegalArgumentException(\"Argument operation doesn't return the result of QuotedOp\");\n+        }\n+\n+        Op op = qop.quotedOp();\n+\n+        List<Op> ops = fblock.ops().subList(0, fblock.ops().size() - 2);\n+        List<Block.Parameter> unvisitedParams = new ArrayList<>(fblock.parameters());\n+        for (Op o : ops) {\n+            if (o instanceof VarOp varOp) {\n+                if (varOp.initOperand() instanceof Block.Parameter p) {\n+                    if (!op.operands().contains(varOp.result()) && !op.capturedValues().contains(varOp.result())) {\n+                        throw new IllegalArgumentException(\"Result of VarOp initialized with a block parameter,\" +\n+                                \"expected to be an operand or a captured value\");\n+                    }\n+                    unvisitedParams.remove(p);\n+                } else if (varOp.initOperand() instanceof Op.Result opr) {\n+                    if (!(opr.op() instanceof ConstantOp)) {\n+                        throw new IllegalArgumentException(\"VarOp initial value came from an operation that's not a ConstantOp\");\n+                    }\n+                    if (!op.capturedValues().contains(varOp.result())) {\n+                        throw new IllegalArgumentException(\"Result of a VarOp initialized with a constant,\" +\n+                                \"expected to be a captured value\");\n+                    }\n+                }\n+            } else if (o instanceof ConstantOp cop) {\n+                if (cop.result().uses().size() != 1) {\n+                    throw new IllegalArgumentException(\"Constant expected to have one use\");\n+                } else if (!(cop.result().uses().iterator().next().op() instanceof VarOp)) {\n+                    throw new IllegalArgumentException(\"Result of a ConstantOp expected to be used by a VarOp\");\n+                }\n+            } else {\n+                throw new IllegalArgumentException(\"Operation not a VarOp nor a ConstantOp, \" + o);\n+            }\n+        }\n+        for (Block.Parameter p : unvisitedParams) {\n+            if (!op.operands().contains(p) && !op.capturedValues().contains(p)) {\n+                throw new IllegalArgumentException(\"Block parameter not an operand nor a captured value\");\n+            }\n+        }\n+\n+        SequencedSet<Value> operandsAndCaptures = new LinkedHashSet<>();\n+        operandsAndCaptures.addAll(op.operands());\n+        operandsAndCaptures.addAll(op.capturedValues());\n+        return new OpAndValues(op, operandsAndCaptures);\n+    }\n+\n+    public record OpAndValues (Op op, SequencedSet<Value> operandsAndCaptures) { }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.LinkedHashSet;\n+import java.util.SequencedSet;\n+import java.util.function.IntUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestQuoteOp\n+ *\/\n+public class TestQuoteOp {\n+\n+    @CodeReflection\n+    public void f(int i) {\n+        String s = \"abc\";\n+        Runnable r = () -> {\n+            System.out.println(i + s + hashCode());\n+        };\n+    }\n+\n+    @Test\n+    void testQuoteOpThatHasCaptures() throws NoSuchMethodException {\n+        Method f = getClass().getDeclaredMethod(\"f\", int.class);\n+        CoreOp.FuncOp fm = Op.ofMethod(f).orElseThrow();\n+        Op lop = fm.body().entryBlock().ops().stream().filter(op -> op instanceof CoreOp.LambdaOp).findFirst().orElseThrow();\n+\n+        fm.writeTo(System.out);\n+\n+        CoreOp.FuncOp funcOp = CoreOp.quoteOp(lop);\n+        funcOp.writeTo(System.out);\n+\n+        CoreOp.OpAndValues opAndValues = CoreOp.quotedOp(funcOp);\n+        \/\/ op must have the same structure as lop\n+        \/\/ for the moment, we don't have utility to check that\n+        Op op = opAndValues.op();\n+\n+        Assert.assertTrue(lop.getClass().isInstance(op));\n+\n+        SequencedSet<Value> e = new LinkedHashSet<>();\n+        e.addAll(op.operands());\n+        e.addAll(op.capturedValues());\n+        Assert.assertEquals(opAndValues.operandsAndCaptures(), e);\n+    }\n+\n+    @CodeReflection\n+    static void g(String s) {\n+        boolean b = s.startsWith(\"a\");\n+    }\n+\n+    @Test\n+    void testQuoteOpThatHasOperands() throws NoSuchMethodException { \/\/ op with operands\n+        Method g = getClass().getDeclaredMethod(\"g\", String.class);\n+        CoreOp.FuncOp gm = Op.ofMethod(g).orElseThrow();\n+        Op invOp = gm.body().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.InvokeOp).findFirst().orElseThrow();\n+\n+        gm.writeTo(System.out);\n+\n+        CoreOp.FuncOp funcOp = CoreOp.quoteOp(invOp);\n+        funcOp.writeTo(System.out);\n+\n+        CoreOp.OpAndValues opAndValues = CoreOp.quotedOp(funcOp);\n+        Op op = opAndValues.op();\n+\n+        Assert.assertTrue(invOp.getClass().isInstance(op));\n+\n+        SequencedSet<Value> e = new LinkedHashSet<>();\n+        e.addAll(op.operands());\n+        e.addAll(op.capturedValues());\n+        Assert.assertEquals(opAndValues.operandsAndCaptures(), e);\n+    }\n+\n+    @Test\n+    void testWithJavacModel() {\n+        final int y = 88;\n+        int z = 99;\n+        Quotable q = (IntUnaryOperator & Quotable) x -> x + y + z + hashCode();\n+\n+        Quoted quoted = Op.ofQuotable(q).orElseThrow();\n+        Op op = quoted.op();\n+        CoreOp.QuotedOp qop = ((CoreOp.QuotedOp) op.ancestorBody().parentOp());\n+        CoreOp.FuncOp fop = ((CoreOp.FuncOp) qop.ancestorBody().parentOp());\n+        fop.writeTo(System.out);\n+\n+        CoreOp.OpAndValues opAndValues = CoreOp.quotedOp(fop);\n+\n+        SequencedSet<Value> e = new LinkedHashSet<>();\n+        e.addAll(op.operands());\n+        e.addAll(op.capturedValues());\n+        Assert.assertEquals(opAndValues.operandsAndCaptures(), e);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"}]}