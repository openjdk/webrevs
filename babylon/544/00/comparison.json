{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import hat.optools.FuncOpParams;\n@@ -39,0 +40,1 @@\n+import jdk.incubator.code.analysis.SSA;\n@@ -404,3 +406,2 @@\n-       \/\/ FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp());\n-        CoreOp.FuncOp lowered = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp());\n-        var paramTable = new OpTk.ParamTable(kernelCallGraph.entrypoint.funcOp());\n+        CoreOp.FuncOp lowered = OpTk.lower(kernelCallGraph.entrypoint.funcOp());\n+        var paramTable = new FuncOpParams(kernelCallGraph.entrypoint.funcOp());\n@@ -417,2 +418,1 @@\n-              \/\/  FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,funcOp);\n-                CoreOp.FuncOp loweredFunc = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,funcOp);\n+                CoreOp.FuncOp loweredFunc = OpTk.lower(funcOp);\n@@ -420,1 +420,1 @@\n-                invokedMethods.append(createFunction(kernelCallGraph.computeContext.accelerator.lookup,new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+                invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n@@ -426,1 +426,1 @@\n-                CoreOp.FuncOp loweredFunc = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,calledFunc);\n+                CoreOp.FuncOp loweredFunc = OpTk.lower(calledFunc);\n@@ -428,1 +428,1 @@\n-                invokedMethods.append(createFunction(kernelCallGraph.computeContext.accelerator.lookup,new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+                invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n@@ -439,1 +439,1 @@\n-        out.append(createFunction(kernelCallGraph.computeContext.accelerator.lookup,builder.nl().nl(), lowered, true));\n+        out.append(createFunction(builder.nl().nl(), lowered, true));\n@@ -479,3 +479,3 @@\n-    static public String createFunction(MethodHandles.Lookup lookup,PTXHATKernelBuilder builder, CoreOp.FuncOp lowered, boolean entry) {\n-        CoreOp.FuncOp ssa = OpTk.ssa(lookup,lowered);\n-        String out, body;\n+    static public String createFunction(PTXHATKernelBuilder builder, CoreOp.FuncOp lowered, boolean entry) {\n+        CoreOp.FuncOp ssa = SSA.transform(lowered);\n+\n@@ -485,1 +485,1 @@\n-        var paramTable = new OpTk.ParamTable(lowered);\n+        var paramTable = new FuncOpParams(lowered);\n@@ -492,1 +492,1 @@\n-        out = builder.getTextAndReset();\n+        String out = builder.getTextAndReset();\n@@ -497,1 +497,1 @@\n-        body = builder.getTextAndReset();\n+        String body = builder.getTextAndReset();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -103,2 +104,2 @@\n-    public CudaHATKernelBuilder kernelDeclaration(String name) {\n-        return externC().space().keyword(\"__global__\").space().voidType().space().identifier(name);\n+    public CudaHATKernelBuilder kernelDeclaration(CoreOp.FuncOp funcOp) {\n+        return externC().space().keyword(\"__global__\").space().voidType().space().identifier(funcOp.funcName());\n@@ -108,2 +109,2 @@\n-    public CudaHATKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType javaType, String name) {\n-        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(codeBuilderContext,javaType).space().identifier(name);\n+    public CudaHATKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType javaType, CoreOp.FuncOp funcOp) {\n+        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(codeBuilderContext,javaType).space().identifier(funcOp.funcName());\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-    public PTXHATKernelBuilder parameters(List<OpTk.ParamTable.Info> infoList) {\n+    public PTXHATKernelBuilder parameters(List<FuncOpParams.Info> infoList) {\n@@ -469,1 +469,1 @@\n-        switch (OpTk.methodRef(op).toString()) {\n+        switch (op.invokeDescriptor().toString()) {\n@@ -507,1 +507,1 @@\n-                call().uni().space().oparen().retVal().cparen().commaSpace().append(OpTk.method(MethodHandles.lookup(),op).getName()).commaSpace();\n+                call().uni().space().oparen().retVal().cparen().commaSpace().append(OpTk.methodOrThrow(MethodHandles.lookup(),op).getName()).commaSpace();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -83,2 +84,2 @@\n-    public OpenCLHATKernelBuilder kernelDeclaration(String name) {\n-        return keyword(\"__kernel\").space().voidType().space().identifier(name);\n+    public OpenCLHATKernelBuilder kernelDeclaration(CoreOp.FuncOp funcOp) {\n+        return keyword(\"__kernel\").space().voidType().space().identifier(funcOp.funcName());\n@@ -88,2 +89,2 @@\n-    public OpenCLHATKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType type, String name) {\n-        return keyword(\"inline\").space().type(codeBuilderContext,type).space().identifier(name);\n+    public OpenCLHATKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType type, CoreOp.FuncOp funcOp) {\n+        return keyword(\"inline\").space().type(codeBuilderContext,type).space().identifier(funcOp.funcName());\n@@ -99,4 +100,3 @@\n-          return identifier(\"atomic_inc\").paren(_ -> {\n-              ampersand().recurse(buildContext, instanceResult.op());\n-              rarrow().identifier(name);\n-          });\n+          return identifier(\"atomic_inc\").paren(_ ->\n+              ampersand().recurse(buildContext, instanceResult.op()).rarrow().identifier(name)\n+          );\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-            System.out.println(OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp()).toText());\n+            System.out.println(OpTk.lower(kernelCallGraph.entrypoint.funcOp()).toText());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import hat.optools.FuncOpParams;\n@@ -35,1 +36,0 @@\n-import jdk.incubator.code.Block;\n@@ -42,1 +42,0 @@\n-import jdk.incubator.code.dialect.java.MethodRef;\n@@ -71,1 +70,1 @@\n-                    OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOp());\n+                    OpTk.lower(computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -143,1 +142,1 @@\n-            var paramTable = new OpTk.ParamTable(prevFO);\n+            var paramTable = new FuncOpParams(prevFO);\n@@ -159,1 +158,1 @@\n-                    } else if (OpTk.isComputeContextMethod(lookup,invokeO) || OpTk.isRawKernelCall(lookup,invokeO)) { \/\/dispatchKernel\n+                    } else if (OpTk.isComputeContextMethod(lookup,invokeO) || OpTk.isKernelContextMethod(lookup,invokeO)) { \/\/dispatchKernel\n@@ -166,1 +165,1 @@\n-                            Annotation[][] parameterAnnotations = OpTk.method(lookup, invokeO).getParameterAnnotations();\n+                            Annotation[][] parameterAnnotations = OpTk.methodOrThrow(lookup, invokeO).getParameterAnnotations();\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -81,2 +82,2 @@\n-    public OpenCLHatKernelBuilder kernelDeclaration(String name) {\n-        return keyword(\"__kernel\").space().voidType().space().identifier(name);\n+    public OpenCLHatKernelBuilder kernelDeclaration(CoreOp.FuncOp funcOp) {\n+        return keyword(\"__kernel\").space().voidType().space().identifier(funcOp.funcName());\n@@ -86,2 +87,2 @@\n-    public OpenCLHatKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType type, String name) {\n-        return keyword(\"inline\").space().type(codeBuilderContext,type).space().identifier(name);\n+    public OpenCLHatKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType type, CoreOp.FuncOp funcOp) {\n+        return keyword(\"inline\").space().type(codeBuilderContext,type).space().identifier(funcOp.funcName());\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-        System.out.println(OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp()).toText());\n+        System.out.println(OpTk.lower(kernelCallGraph.entrypoint.funcOp()).toText());\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-\/\/import hat.optools.InvokeOpWrapper;\n+import hat.optools.FuncOpParams;\n@@ -36,2 +36,1 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n@@ -41,1 +40,1 @@\n-import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.dialect.java.ClassType;\n@@ -44,0 +43,1 @@\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -48,1 +48,0 @@\n-\/\/import static hat.ComputeContext.WRAPPER.ESCAPE;\n@@ -68,1 +67,1 @@\n-                    OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOp());\n+                    OpTk.lower(computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -70,2 +69,0 @@\n-\n-\n@@ -88,1 +85,1 @@\n- \/\/ This code should be common with ffi-shared probably should be pushed down into another lib?\n+    \/\/ This code should be common with ffi-shared probably should be pushed down into another lib?\n@@ -90,47 +87,32 @@\n-        CoreOp.FuncOp prevFO = computeMethod.funcOp();\n-        CoreOp.FuncOp returnFO = prevFO;\n-        boolean transform = true;\n-        if (transform) {\n-            System.out.println(\"COMPUTE entrypoint before injecting buffer tracking...\");\n-            System.out.println(returnFO.toText());\n-            var paramTable = new OpTk.ParamTable(prevFO);\n-            var lookup = computeMethod.callGraph.computeContext.accelerator.lookup;\n-            returnFO = prevFO.transform((bldr, op)->{\n-\n-                if (op instanceof JavaOp.InvokeOp invokeO) {\n-                    CopyContext bldrCntxt = bldr.context();\n-                    \/\/Map compute method's first param (computeContext) value to transformed model\n-                    Value cc = bldrCntxt.getValue(paramTable.list().getFirst().parameter);\n-                    if (OpTk.isIfaceMutator(lookup,invokeO)) {                    \/\/ iface.v(newV)\n-                        Value iface = bldrCntxt.getValue(invokeO.operands().getFirst());\n-                        bldr.op(JavaOp.invoke(MUTATE.pre, cc, iface));  \/\/ cc->preMutate(iface);\n-                        bldr.op(invokeO);                         \/\/ iface.v(newV);\n-                        bldr.op(JavaOp.invoke(MUTATE.post, cc, iface)); \/\/ cc->postMutate(iface)\n-                    } else if (OpTk.isIfaceAccessor(lookup,invokeO)) {            \/\/ iface.v()\n-                        Value iface = bldrCntxt.getValue(invokeO.operands().getFirst());\n-                        bldr.op(JavaOp.invoke(ACCESS.pre, cc, iface));  \/\/ cc->preAccess(iface);\n-                        bldr.op(invokeO);                         \/\/ iface.v();\n-                        bldr.op(JavaOp.invoke(ACCESS.post, cc, iface)); \/\/ cc->postAccess(iface) } else {\n-                    } else if (OpTk.isComputeContextMethod(lookup,invokeO) || OpTk.isRawKernelCall(lookup,invokeO)) { \/\/dispatchKernel\n-                        bldr.op(invokeO);\n-                    } else {\n-                        invokeO.operands().stream()\n-                                .filter(val -> val.type() instanceof JavaType javaType &&\n-                                        OpTk.isAssignable(lookup, javaType, MappableIface.class))\n-                                \/\/ isIfaceUsingLookup(prevFOW.lookup,javaType))\n-                                .forEach(val ->\n-                                        bldr.op(JavaOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(val)))\n-                                );\n-                        bldr.op(invokeO);\n-                        invokeO.operands().stream()\n-                                .filter(val -> val.type() instanceof JavaType javaType &&\n-                                        OpTk.isAssignable(lookup, javaType, MappableIface.class))\n-                                \/\/ isIfaceUsingLookup(prevFOW.lookup,javaType))\n-\n-                                .forEach(val -> bldr.op(\n-                                        JavaOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(val)))\n-                                );\n-                    }\n-                    return bldr;\n-                }else{\n-                    bldr.op(op);\n+        System.out.println(\"COMPUTE entrypoint before injecting buffer tracking...\");\n+        System.out.println(computeMethod.funcOp().toText());\n+        var paramTable = new FuncOpParams(computeMethod.funcOp());\n+        var lookup = computeMethod.callGraph.computeContext.accelerator.lookup;\n+        var transformedFuncOp = computeMethod.funcOp().transform((bldr, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                Value computeContext = bldr.context().getValue(paramTable.list().getFirst().parameter);\n+                if (OpTk.isIfaceBufferMethod(lookup, invokeOp) && OpTk.javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n+                    Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n+                    bldr.op(JavaOp.invoke(MUTATE.pre, computeContext, iface));  \/\/ cc->preMutate(iface);\n+                    bldr.op(invokeOp);                                          \/\/ iface.v(newV);\n+                    bldr.op(JavaOp.invoke(MUTATE.post, computeContext, iface)); \/\/ cc->postMutate(iface)\n+                } else if (OpTk.isIfaceBufferMethod(lookup, invokeOp)\n+                        \/\/&& !OpTk.javaReturnType(invokeOp).equals(JavaType.VOID) not sure we need this\n+                        && OpTk.javaReturnType(invokeOp) instanceof ClassType returnClassType\n+                        && OpTk.classTypeToTypeOrThrow(lookup, returnClassType) instanceof Class<?> type\n+                        && Buffer.class.isAssignableFrom(type)\n+                ) {            \/\/ iface.v()\n+                    Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n+                    bldr.op(JavaOp.invoke(ACCESS.pre, computeContext, iface));  \/\/ cc->preAccess(iface);\n+                    bldr.op(invokeOp);                                          \/\/ iface.v();\n+                    bldr.op(JavaOp.invoke(ACCESS.post, computeContext, iface)); \/\/ cc->postAccess(iface) } else {\n+                } else if (OpTk.isComputeContextMethod(lookup, invokeOp) || OpTk.isKernelContextMethod(lookup, invokeOp)) { \/\/dispatchKernel\n+                    bldr.op(invokeOp);\n+                } else {\n+                    invokeOp.operands().stream()\n+                            .filter(val -> val.type() instanceof JavaType javaType && OpTk.isAssignable(lookup, javaType, MappableIface.class))\n+                            .forEach(val -> bldr.op(JavaOp.invoke(MUTATE.pre, computeContext, bldr.context().getValue(val))));\n+                    bldr.op(invokeOp);\n+                    invokeOp.operands().stream()\n+                            .filter(val -> val.type() instanceof JavaType javaType && OpTk.isAssignable(lookup, javaType, MappableIface.class))\n+                            .forEach(val -> bldr.op(JavaOp.invoke(MUTATE.post, computeContext, bldr.context().getValue(val))));\n@@ -139,6 +121,9 @@\n-            });\n-            System.out.println(\"COMPUTE entrypoint after injecting buffer tracking...\");\n-            System.out.println(returnFO.toText());\n-        }\n-        computeMethod.funcOp(returnFO);\n-        return returnFO;\n+            } else {\n+                bldr.op(op);\n+            }\n+            return bldr;\n+        });\n+        System.out.println(\"COMPUTE entrypoint after injecting buffer tracking...\");\n+        System.out.println(transformedFuncOp.toText());\n+        computeMethod.funcOp(transformedFuncOp);\n+        return transformedFuncOp;\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":47,"deletions":62,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -162,14 +162,0 @@\n-\/*\n-    @Override\n-    public void preEscape(Buffer b) {\n-        if (backend instanceof BufferTracker) {\n-            ((BufferTracker) backend).preEscape(b);\n-        }\n-    }\n-\n-    @Override\n-    public void postEscape(Buffer b) {\n-        if (backend instanceof BufferTracker) {\n-            ((BufferTracker) backend).postEscape(b);\n-        }\n-    } *\/\n@@ -217,2 +203,1 @@\n-        Method method = OpTk.method(lookup,OpTk.getQuotableTargetInvokeOpWrapper(lambda));\n-\n+        Method method = OpTk.methodOrThrow(lookup,OpTk.getQuotableTargetInvokeOpWrapper(lambda));\n@@ -223,3 +208,1 @@\n-        ComputeContext computeContext = cache.computeIfAbsent(method, (_) ->\n-                new ComputeContext(this, method)\n-        );\n+        ComputeContext computeContext = cache.computeIfAbsent(method, (_) -> new ComputeContext(this, method));\n@@ -229,1 +212,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-        MethodRef methodRef =OpTk.getQuotableTargetMethodRef(lambdaOp);\n+        MethodRef methodRef =OpTk.getQuotableTargetInvokeOpWrapper( lambdaOp).invokeDescriptor();\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOp());\n+                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -77,1 +77,1 @@\n-                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOp());\n+                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -112,1 +112,1 @@\n-                var lowered = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp());\n+                var lowered = OpTk.lower(kernelCallGraph.entrypoint.funcOp());\n@@ -117,1 +117,1 @@\n-                var lowered = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp());\n+                var lowered = OpTk.lower(kernelCallGraph.entrypoint.funcOp());\n@@ -156,1 +156,0 @@\n-                \/\/ highLevelForm.lower();\n@@ -161,9 +160,0 @@\n-\/*\n-                FunctionType functionType = OpsAndTypes.transformTypes(kernelCallGraph.computeContext.accelerator.lookup, ssaInvokeForm);\n-                System.out.println(\"SSA form with types transformed args\");\n-                System.out.println(ssaInvokeForm.toText());\n-                System.out.println(\"------------------\");\n-\n-                CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(kernelCallGraph.computeContext.accelerator.lookup, ssaInvokeForm, functionType);\n-                System.out.println(\"SSA form with invokes replaced by ptrs\");\n-                System.out.println(ssaPtrForm.toText()); *\/\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,4 +37,0 @@\n-   \/\/  void preEscape(Buffer b);\n-\n-    \/\/ void postEscape(Buffer b) ;\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/BufferTracker.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.optools.FuncOpParams;\n@@ -98,1 +99,1 @@\n-                OpTk.ParamTable paramTable = new OpTk.ParamTable(fow);\n+                FuncOpParams paramTable = new FuncOpParams(fow);\n@@ -150,4 +151,2 @@\n-                MethodRef methodRef = OpTk.methodRef(invokeOp);\n-\n-                Class<?> javaRefClass = OpTk.javaRefClass(lookup,invokeOp).orElseThrow();\n-                Method invokeWrapperCalledMethod = OpTk.method(lookup,invokeOp);\n+                Class<?> javaRefClass = OpTk.javaRefClassOrThrow(lookup,invokeOp);\n+                Method invokeWrapperCalledMethod = OpTk.methodOrThrow(lookup,invokeOp);\n@@ -155,3 +154,2 @@\n-                    \/\/ System.out.println(\"iface mapped buffer call  -> \" + methodRef);\n-                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                            new ComputeReachableIfaceMappedMethodCall(this, methodRef, invokeWrapperCalledMethod)\n+                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n+                            new ComputeReachableIfaceMappedMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod)\n@@ -160,3 +158,2 @@\n-                    \/\/ System.out.println(\"call on the accelerator (must be through the computeContext) -> \" + methodRef);\n-                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                            new ComputeReachableAcceleratorMethodCall(this, methodRef, invokeWrapperCalledMethod)\n+                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n+                            new ComputeReachableAcceleratorMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod)\n@@ -166,3 +163,2 @@\n-                    \/\/ System.out.println(\"call on the computecontext -> \" + methodRef);\n-                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                            new ComputeContextMethodCall(this, methodRef, invokeWrapperCalledMethod)\n+                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n+                            new ComputeContextMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod)\n@@ -176,2 +172,2 @@\n-                            kernelCallGraphMap.computeIfAbsent(methodRef, _ ->\n-                                    new KernelCallGraph(this, methodRef, invokeWrapperCalledMethod, fow).close()\n+                            kernelCallGraphMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n+                                    new KernelCallGraph(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod, fow).close()\n@@ -181,2 +177,2 @@\n-                            computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                                    new OtherComputeReachableResolvedMethodCall(this, methodRef, invokeWrapperCalledMethod, fow)\n+                            computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n+                                    new OtherComputeReachableResolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod, fow)\n@@ -187,2 +183,2 @@\n-                        computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                                new ComputeReachableUnresolvedMethodCall(this, methodRef, invokeWrapperCalledMethod)\n+                        computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n+                                new ComputeReachableUnresolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod)\n@@ -194,2 +190,2 @@\n-                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                            new ComputeReachableUnresolvedMethodCall(this, methodRef, invokeWrapperCalledMethod)\n+                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n+                            new ComputeReachableUnresolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod)\n@@ -232,1 +228,0 @@\n-       \/\/ moduleOpWrapper = moduleOp;\/\/ OpWrapper.wrap(computeContext.accelerator.lookup, moduleOp);\n@@ -237,2 +232,1 @@\n-\n-        if (entrypoint.method.getDeclaringClass().equals(OpTk.javaRefClass(computeContext.accelerator.lookup,invokeOp).orElseThrow()) && isKernelDispatch(computeContext.accelerator.lookup,method, f)) {\n+        if (entrypoint.method.getDeclaringClass().equals(OpTk.javaRefClassOrThrow(computeContext.accelerator.lookup,invokeOp)) && isKernelDispatch(computeContext.accelerator.lookup,method, f)) {\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -96,4 +96,3 @@\n-              \/\/  var invokeOpWrapper = (InvokeOpWrapper)OpWrapper.wrap(  kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp);\n-                MethodRef methodRef = OpTk.methodRef(invokeOp);\n-                Class<?> javaRefTypeClass = OpTk.javaRefClass(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp).orElseThrow();\n-                Method invokeOpCalledMethod = OpTk.method(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp);\n+              \/\/  MethodRef methodRef = invokeOp.invokeDescriptor();\n+                Class<?> javaRefTypeClass = OpTk.javaRefClassOrThrow(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp);\n+                Method invokeOpCalledMethod = OpTk.methodOrThrow(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp);\n@@ -101,3 +100,2 @@\n-                    \/\/System.out.println(\"kernel reachable iface mapped buffer call  -> \" + methodRef);\n-                    kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                            new KernelReachableUnresolvedIfaceMappedMethodCall(this, methodRef, invokeOpCalledMethod)\n+                        kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n+                            new KernelReachableUnresolvedIfaceMappedMethodCall(this, invokeOp.invokeDescriptor(), invokeOpCalledMethod)\n@@ -108,3 +106,2 @@\n-                        \/\/System.out.println(\"A call to a method on the kernel class which we have code model for \" + methodRef);\n-                        kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                                new KernelReachableResolvedMethodCall(this, methodRef, invokeOpCalledMethod, optionalFuncOp.get()\n+                             kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n+                                new KernelReachableResolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeOpCalledMethod, optionalFuncOp.get()\n@@ -113,3 +110,2 @@\n-                        \/\/ System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n-                        kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                                new KernelReachableUnresolvedMethodCall(this, methodRef, invokeOpCalledMethod)\n+                           kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n+                                new KernelReachableUnresolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeOpCalledMethod)\n@@ -119,3 +115,2 @@\n-                    \/\/  System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n-                    kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                            new KernelReachableUnresolvedMethodCall(this, methodRef, invokeOpCalledMethod)\n+                       kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n+                            new KernelReachableUnresolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeOpCalledMethod)\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-                OpTk.rootOpStream(buildContext.lookup,funcOp)\n+                OpTk.rootOpStream(funcOp)\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import hat.optools.FuncOpParams;\n@@ -190,2 +191,1 @@\n-            functionDeclaration(buildContext,(JavaType) buildContext.funcOp.body().yieldType(),\n-                    buildContext.funcOp.funcName());\n+            functionDeclaration(buildContext,(JavaType) buildContext.funcOp.body().yieldType(), buildContext.funcOp);\n@@ -199,1 +199,1 @@\n-                StreamCounter.of(OpTk.rootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n+                StreamCounter.of(OpTk.rootOpStream(buildContext.funcOp), (c, root) ->\n@@ -213,1 +213,1 @@\n-                    buildContext.funcOp.funcName());\n+                    buildContext.funcOp);\n@@ -221,1 +221,1 @@\n-                StreamCounter.of(OpTk.rootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n+                StreamCounter.of(OpTk.rootOpStream(buildContext.funcOp), (c, root) ->\n@@ -233,1 +233,1 @@\n-            kernelDeclaration(buildContext.funcOp.funcName());\n+            kernelDeclaration(buildContext.funcOp);\n@@ -237,3 +237,2 @@\n-                if (args[arg] instanceof Buffer buffer) {\n-                    OpTk.ParamTable.Info info = list.get(arg);\n-                    info.setLayout((GroupLayout) Buffer.getLayout(buffer));\n+                if (args[arg] instanceof Buffer) {\n+                    FuncOpParams.Info info = list.get(arg);\n@@ -253,1 +252,1 @@\n-                StreamCounter.of(OpTk.rootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n+                StreamCounter.of(OpTk.rootOpStream(buildContext.funcOp), (c, root) ->\n@@ -266,1 +265,1 @@\n-    public abstract T kernelDeclaration(String name);\n+    public abstract T kernelDeclaration(CoreOp.FuncOp funcOp);\n@@ -268,1 +267,1 @@\n-    public abstract T functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType javaType, String name);\n+    public abstract T functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType javaType, CoreOp.FuncOp funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.optools.OpTk;\n+import hat.optools.FuncOpParams;\n@@ -60,1 +60,1 @@\n-        final OpTk.ParamTable paramTable;\n+        final FuncOpParams paramTable;\n@@ -63,1 +63,1 @@\n-            paramTable = new OpTk.ParamTable(funcOp);\n+            paramTable = new FuncOpParams(funcOp);\n@@ -243,1 +243,1 @@\n-    final public OpTk.ParamTable paramTable;\n+    final public FuncOpParams paramTable;\n@@ -247,1 +247,1 @@\n-        this.paramTable = new OpTk.ParamTable(funcOp);\n+        this.paramTable = new FuncOpParams(funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderContext.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.stream.Stream;\n@@ -152,5 +153,3 @@\n-        if (varOp.isUninitialized()) {\n-            \/\/ Variable is uninitialized\n-            type(buildContext, OpTk.javaType(varOp)).space().identifier(OpTk.varName(varOp));\n-        } else {\n-            type(buildContext, OpTk.javaType(varOp)).space().identifier(OpTk.varName(varOp)).space().equals().space();\n+        type(buildContext, (JavaType) varOp.varValueType()).space().identifier(varOp.varName());\n+        if (!varOp.isUninitialized()) {\n+            space().equals().space();\n@@ -225,1 +224,1 @@\n-        parencedence(buildContext, binaryOp, OpTk.lhsAsOp(binaryOp));\n+        parencedence(buildContext, binaryOp, ((Op.Result) binaryOp.operands().get(0)).op());\n@@ -227,1 +226,1 @@\n-        parencedence(buildContext, binaryOp, OpTk.rhsAsOp(binaryOp));\n+        parencedence(buildContext, binaryOp, ((Op.Result) binaryOp.operands().get(1)).op());\n@@ -233,1 +232,2 @@\n-        OpTk.lhsYieldOpStream(logicalOp).forEach(o ->  recurse(buildContext, o));\n+        logicalOp.bodies().get(0).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n+                .forEach(o ->  recurse(buildContext, o));\n@@ -235,1 +235,2 @@\n-        OpTk.rhsYieldOpStream(logicalOp).forEach(o-> recurse(buildContext, o));\n+        logicalOp.bodies().get(1).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n+                .forEach(o-> recurse(buildContext, o));\n@@ -241,1 +242,1 @@\n-        parencedence(buildContext, binaryTestOp, OpTk.lhsAsOp(binaryTestOp));\n+        parencedence(buildContext, binaryTestOp, ((Op.Result) binaryTestOp.operands().get(0)).op());\n@@ -243,1 +244,1 @@\n-        parencedence(buildContext, binaryTestOp, OpTk.rhsAsOp(binaryTestOp));\n+        parencedence(buildContext, binaryTestOp, ((Op.Result) binaryTestOp.operands().get(1)).op());\n@@ -354,1 +355,2 @@\n-                    if (OpTk.hasElse(ifOp,c.value())) { \/\/ we might have more than one else\n+                    int idx = c.value();\n+                    if (ifOp.bodies().size() > idx && ifOp.bodies().get(idx).entryBlock().ops().size() > 1){\n@@ -385,1 +387,3 @@\n-                OpTk.conditionYieldOpStream(whileOp).forEach(o -> recurse(buildContext, o))\n+                whileOp.bodies().getFirst().entryBlock().ops().stream() \/\/ cond\n+                        .filter(o -> o instanceof CoreOp.YieldOp)\n+                        .forEach(o -> recurse(buildContext, o))\n@@ -387,1 +391,1 @@\n-                StreamCounter.of(OpTk.loopRootOpStream(buildContext.lookup,whileOp), (c, root) ->\n+                StreamCounter.of(OpTk.loopRootOpStream(whileOp), (c, root) ->\n@@ -398,1 +402,3 @@\n-                    OpTk.initYieldOpStream(forOp).forEach(o -> recurse(buildContext, o));\n+                    forOp.init().entryBlock().ops().stream()\n+                            .filter(o -> o instanceof CoreOp.YieldOp)\n+                            .forEach(o -> recurse(buildContext, o));\n@@ -400,1 +406,3 @@\n-                    OpTk.conditionYieldOpStream(forOp).forEach(o -> recurse(buildContext, o));\n+                    forOp.cond().entryBlock().ops().stream()\n+                            .filter(o -> o instanceof CoreOp.YieldOp)\n+                            .forEach(o -> recurse(buildContext, o));\n@@ -402,2 +410,3 @@\n-                    StreamCounter.of(OpTk.mutateRootOpStream(buildContext.lookup,forOp), (c, wrapped) ->\n-                            commaSpaceIf(c.isNotFirst()).recurse(buildContext, wrapped)\n+                    StreamCounter.of(\n+                            OpTk.rootsExcludingVarFuncDeclarationsAndYields( forOp.bodies().get(2).entryBlock()) \/\/mutate block\n+                            , (c, op) -> commaSpaceIf(c.isNotFirst()).recurse(buildContext, op)\n@@ -406,1 +415,1 @@\n-                        StreamCounter.of(OpTk.loopRootOpStream(buildContext.lookup,forOp), (c, root) ->\n+                        StreamCounter.of(OpTk.loopRootOpStream(forOp), (c, root) ->\n@@ -624,1 +633,3 @@\n-        OpTk.conditionYieldOpStream(ternaryOp).forEach(o -> recurse(buildContext, o));\n+        ternaryOp.bodies().get(0).entryBlock().ops().stream()\n+                .filter(o -> o instanceof CoreOp.YieldOp) \/\/ cond\n+                .forEach(o -> recurse(buildContext, o));\n@@ -626,1 +637,3 @@\n-        OpTk.thenYieldOpStream(ternaryOp).forEach(o -> recurse(buildContext, o));\n+        ternaryOp.bodies().get(1).entryBlock().ops().stream()\n+                .filter(o -> o instanceof CoreOp.YieldOp) \/\/ iff yield\n+                .forEach(o -> recurse(buildContext, o));\n@@ -628,1 +641,3 @@\n-        OpTk.elseYieldOpStream(ternaryOp).forEach(o -> recurse(buildContext, o));\n+        ternaryOp.bodies().get(2).entryBlock().ops().stream()\n+                 .filter(o -> o instanceof CoreOp.YieldOp) \/\/ else yield\n+                 .forEach(o -> recurse(buildContext, o));\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":37,"deletions":22,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.optools;\n+\n+import hat.util.BiMap;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class FuncOpParams {\n+    public static class Info {\n+        public final int idx;\n+        public final Block.Parameter parameter;\n+        public final JavaType javaType;\n+        public final CoreOp.VarOp varOp;\n+        public Class<?> clazz = null;\n+\n+        Info(int idx, Block.Parameter parameter, CoreOp.VarOp varOp) {\n+            this.idx = idx;\n+            this.parameter = parameter;\n+            this.javaType = (JavaType) parameter.type();\n+            this.varOp = varOp;\n+        }\n+\n+        public boolean isPrimitive() {\n+            return javaType instanceof PrimitiveType;\n+        }\n+\n+        public void setClass(Class<?> clazz) {\n+            this.clazz = clazz;\n+        }\n+    }\n+\n+    final public BiMap<Block.Parameter, CoreOp.VarOp> parameterVarOpMap = new BiMap<>();\n+    final public BiMap<Block.Parameter, JavaOp.InvokeOp> parameterInvokeOpMap = new BiMap<>();\n+\n+    final private Map<Block.Parameter, Info> parameterToInfo = new LinkedHashMap<>();\n+    final private Map<CoreOp.VarOp, Info> varOpToInfo = new LinkedHashMap<>();\n+\n+    final private List<Info> list = new ArrayList<>();\n+\n+    public Info info(Block.Parameter parameter) {\n+        return parameterToInfo.get(parameter);\n+    }\n+\n+    void add(Map.Entry<Block.Parameter, CoreOp.VarOp> parameterToVarOp) {\n+        \/\/We add a new ParameterInfo to both maps using parameter and varOp as keys\n+        varOpToInfo.put(parameterToVarOp.getValue(),\n+                \/\/ always called but convenient because computeIfAbsent returns what we added :)\n+                parameterToInfo.computeIfAbsent(parameterToVarOp.getKey(), (parameterKey) -> {\n+                    var info = new Info(list.size(), parameterKey, parameterToVarOp.getValue());\n+                    list.add(info);\n+                    return info;\n+                })\n+        );\n+    }\n+\n+    public List<Info> list() {\n+        return list;\n+    }\n+\n+    public Stream<Info> stream() {\n+        return list.stream();\n+    }\n+\n+    final public CoreOp funcOp;\n+\n+    public FuncOpParams(CoreOp.FuncOp funcOp) {\n+        this.funcOp = funcOp;\n+        funcOp.parameters().forEach(parameter -> {\n+            Optional<Op.Result> optionalResult = parameter.uses().stream().findFirst();\n+            optionalResult.ifPresentOrElse(result -> {\n+                if (result.op() instanceof CoreOp.VarOp varOp) {\n+                    parameterVarOpMap.add(parameter, varOp);\n+                    add(Map.entry(parameter, varOp));\n+                } else if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n+                    parameterInvokeOpMap.add(parameter, invokeOp);\n+                }\n+            }, () -> {\n+                throw new IllegalStateException(\"FuncOp has unused params \");\n+            });\n+        });\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FuncOpParams.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.buffer.Buffer;\n@@ -32,1 +31,0 @@\n-import hat.util.BiMap;\n@@ -37,1 +35,0 @@\n-import jdk.incubator.code.TypeElement;\n@@ -39,1 +36,0 @@\n-import jdk.incubator.code.analysis.SSA;\n@@ -45,1 +41,0 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -47,1 +42,0 @@\n-import java.lang.foreign.GroupLayout;\n@@ -60,1 +54,0 @@\n-import java.util.Optional;\n@@ -62,1 +55,2 @@\n-import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n@@ -67,23 +61,0 @@\n-\n-    public static Op lhsAsOp(Op op) {\n-        return ((Op.Result) op.operands().getFirst()).op();\n-    }\n-\n-    public static Op rhsAsOp(Op op) {\n-        return ((Op.Result) op.operands().get(1)).op();\n-    }\n-\n-   \/\/ public static Stream<OpWrapper<?>> lhsWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.JavaConditionalOp op) {\n-     \/\/   return op.bodies().get(0).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).map(o -> OpWrapper.wrap(lookup, o));\n-   \/\/ }\n-    public static Stream<Op> lhsYieldOpStream(JavaOp.JavaConditionalOp op) {\n-        return op.bodies().get(0).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n-    }\n-\n-   \/\/ public static Stream<OpWrapper<?>> rhsWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.JavaConditionalOp op) {\n-     \/\/   return op.bodies().get(1).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).map(o -> OpWrapper.wrap(lookup, o));\n-   \/\/ }\n-    public static Stream<Op> rhsYieldOpStream( JavaOp.JavaConditionalOp op) {\n-        return op.bodies().get(1).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n-    }\n-\n@@ -94,3 +65,0 @@\n-    public static TypeElement fieldType(JavaOp.FieldAccessOp fieldAccessOp) {\n-        return fieldAccessOp.fieldDescriptor().refType();\n-    }\n@@ -102,8 +70,0 @@\n-    public static JavaType javaType(CoreOp.VarOp op) {\n-        return (JavaType) op.varValueType();\n-    }\n-\n-    public static String varName(CoreOp.VarOp op) {\n-        return op.varName();\n-    }\n-\n@@ -111,2 +71,2 @@\n-        if (fieldType(fieldLoadOp) instanceof ClassType classType) {\n-            Class<?> clazz = (Class<?>) classTypeToType(lookup, classType);\n+        if (fieldLoadOp.fieldDescriptor().refType() instanceof ClassType classType) {\n+            Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup, classType);\n@@ -124,3 +84,0 @@\n-   \/\/ public static Stream<OpWrapper<?>> initWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op) {\n-     \/\/   return op.init().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).map(o -> OpWrapper.wrap(lookup, o));\n-   \/\/ }\n@@ -128,19 +85,1 @@\n-    public static Stream<Op> initYieldOpStream(JavaOp.ForOp op) {\n-        return op.init().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n-    }\n-    \/\/ Maybe instead of three of these we can add cond() to Op.Loop?\n-  \/\/  public static Stream<OpWrapper<?>> conditionWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op) {\n-    \/\/    return op.cond().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).map(o -> OpWrapper.wrap(lookup, o));\n-   \/\/ }\n-    public static Stream<Op> conditionYieldOpStream(JavaOp.ForOp op) {\n-        return op.cond().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n-    }\n-    public static Stream<Op> conditionYieldOpStream( JavaOp.WhileOp op) {\n-        \/\/ ADD op.cond() to JavaOp.WhileOp  match ForOp?\n-        return op.bodies().getFirst().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n-    }\n-    public static Stream<Op> conditionYieldOpStream( JavaOp.ConditionalExpressionOp op) {\n-        \/\/ ADD op.cond() to JavaOp.WhileOp  match ForOp?\n-        return op.bodies().getFirst().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n-    }\n-    public static Stream<Op> loopRootOpStream(MethodHandles.Lookup lookup, Op.Loop op) {\n+    public static Stream<Op> loopRootOpStream(Op.Loop op) {\n@@ -154,20 +93,0 @@\n-\n-    public static Stream<Op> mutateRootOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op) {\n-        return rootsExcludingVarFuncDeclarationsAndYields( op.bodies().get(2).entryBlock());\n-    }\n-\n-\n-    public static Stream<Op> thenYieldOpStream( JavaOp.ConditionalExpressionOp op) {\n-        return op.bodies().get(1).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n-    }\n-\n-    public static Stream<Op> elseYieldOpStream(JavaOp.ConditionalExpressionOp op) {\n-        return op.bodies().get(2).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n-    }\n-\n-\n-    public static boolean hasElse(JavaOp.IfOp op, int idx) {\n-        return op.bodies().size() > idx && op.bodies().get(idx).entryBlock().ops().size() > 1;\n-    }\n-\n-\n@@ -184,3 +103,1 @@\n-                MethodRef methodRef = methodRef(invokeOp);\n-                Method method = null;\n-                Class<?> javaRefTypeClass = javaRefClass(callGraph.computeContext.accelerator.lookup, invokeOp).orElseThrow();\n+                Class<?> javaRefTypeClass = javaRefClassOrThrow(callGraph.computeContext.accelerator.lookup, invokeOp);\n@@ -188,1 +105,5 @@\n-                    method = methodRef.resolveToMethod(l, invokeOp.invokeKind());\n+                    var method = invokeOp.invokeDescriptor().resolveToMethod(l, invokeOp.invokeKind());\n+                    CoreOp.FuncOp f = Op.ofMethod(method).orElse(null);\n+                    if (f != null && !callGraph.filterCalls(f, invokeOp, method, invokeOp.invokeDescriptor(), javaRefTypeClass)) {\n+                        work.push(new RefAndFunc(invokeOp.invokeDescriptor(),  f));\n+                    }\n@@ -192,4 +113,0 @@\n-                Optional<CoreOp.FuncOp> f = Op.ofMethod(method);\n-                if (f.isPresent() && !callGraph.filterCalls(f.get(), invokeOp, method, methodRef, javaRefTypeClass)) {\n-                    work.push(new RefAndFunc(methodRef,  f.get()));\n-                }\n@@ -208,3 +125,0 @@\n-                    \/\/  InvokeOpWrapper iopWrapper = OpWrapper.wrap(entry.lookup, iop);\n-                    MethodRef methodRef = methodRef(iop);\n-                    Method invokeOpCalledMethod = null;\n@@ -212,1 +126,14 @@\n-                        invokeOpCalledMethod = methodRef.resolveToMethod(l, iop.invokeKind());\n+                        Method invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(l, iop.invokeKind());\n+                        if (invokeOpCalledMethod instanceof Method m) {\n+                            CoreOp.FuncOp f = Op.ofMethod(m).orElse(null);\n+                            if (f!=null) {\n+                                RefAndFunc call = new RefAndFunc(iop.invokeDescriptor(), f);\n+                                work.push(call);\n+                                Op.Result result = blockBuilder.op(CoreOp.funcCall(\n+                                        call.r.name(),\n+                                        call.f.invokableType(),\n+                                        blockBuilder.context().getValues(iop.operands())));\n+                                blockBuilder.context().mapValue(op.result(), result);\n+                                return blockBuilder;\n+                            }\n+                        }\n@@ -216,14 +143,0 @@\n-                    if (invokeOpCalledMethod instanceof Method m) {\n-                        Optional<CoreOp.FuncOp> f = Op.ofMethod(m);\n-                        if (f.isPresent()) {\n-                            RefAndFunc call = new RefAndFunc(methodRef, f.get());\n-                            work.push(call);\n-\n-                            Op.Result result = blockBuilder.op(CoreOp.funcCall(\n-                                    call.r.name(),\n-                                    call.f.invokableType(),\n-                                    blockBuilder.context().getValues(iop.operands())));\n-                            blockBuilder.context().mapValue(op.result(), result);\n-                            return blockBuilder;\n-                        }\n-                    }\n@@ -240,2 +153,1 @@\n-    public static Type classTypeToType(MethodHandles.Lookup lookup, ClassType classType) {\n-        Type javaTypeClass = null;\n+    public static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n@@ -243,1 +155,1 @@\n-            javaTypeClass = classType.resolve(lookup);\n+            return classType.resolve(lookup);\n@@ -247,2 +159,0 @@\n-        return javaTypeClass;\n-\n@@ -253,1 +163,1 @@\n-            Type type = classTypeToType(lookup, classType);\n+            Type type = classTypeToTypeOrThrow(lookup, classType);\n@@ -269,5 +179,1 @@\n-                .findFirst().get();\n-    }\n-\n-    public static MethodRef getQuotableTargetMethodRef(JavaOp.LambdaOp lambdaOp) {\n-        return methodRef(getQuotableTargetInvokeOpWrapper( lambdaOp));\n+                .findFirst().orElseThrow();\n@@ -285,2 +191,0 @@\n-\n-\n@@ -309,1 +213,1 @@\n-    public static CoreOp.FuncOp lower(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+    public static CoreOp.FuncOp lower( CoreOp.FuncOp funcOp) {\n@@ -313,8 +217,1 @@\n-    public static CoreOp.FuncOp ssa(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-        return SSA.transform(funcOp);\n-    }\n-\/*\n-    public static Stream<OpWrapper<?>> wrappedRootOpStream(MethodHandles.Lookup lookup, CoreOp.FuncOp op) {\n-        return wrappedRootsExcludingVarFuncDeclarationsAndYields(lookup, op.bodies().getFirst().entryBlock());\n-    } *\/\n-    public static Stream<Op> rootOpStream(MethodHandles.Lookup lookup, CoreOp.FuncOp op) {\n+    public static Stream<Op> rootOpStream( CoreOp.FuncOp op) {\n@@ -325,28 +222,6 @@\n-    static public Set<Op> roots(Block block) {\n-        record Node<T extends Value>(T node, List<Node<T>> children) {\n-        }\n-        Set<Op> roots = new LinkedHashSet<>();\n-        Map<Op, Node<Value>> trees = new LinkedHashMap<>();\n-        Map<Value, Node<Value>> params = new HashMap<>();\n-        block.ops().forEach(op -> {\n-            List<Node<Value>> children = new ArrayList<>();\n-\n-            op.operands().forEach(operand -> {\n-                if (operand instanceof Op.Result result) {\n-                    children.add(trees.get(result.op()));\n-                } else {\n-                    children.add(params.computeIfAbsent(operand, _ -> new Node<>(operand, List.of())));\n-                }\n-            });\n-            trees.put(op, new Node<>(op.result(), children));\n-        });\n-\n-        trees.keySet().forEach(op -> {\n-            if (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2) {\n-                roots.add(op);\n-            } else if (op instanceof CoreOp.VarOp || op.result().uses().isEmpty()) {\n-                roots.add(op);\n-            }\n-        });\n-        return roots;\n-    }\n+    static Predicate<Op> rootFilter = op->\n+            (   (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n+              || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n+            )\n+            && !(op instanceof CoreOp.VarOp varOp && paramVar(varOp) != null)\n+            && !(op instanceof CoreOp.YieldOp);\n@@ -355,9 +230,1 @@\n-        var roots = roots(block);\n-        return block.ops().stream()\n-                .filter(roots::contains)\n-                .filter(w -> !(w instanceof CoreOp.VarOp varOp && paramVar(varOp) != null))\n-                .filter(w -> !(w instanceof CoreOp.YieldOp));\n-    }\n-\n-    public static MethodRef methodRef(JavaOp.InvokeOp op) {\n-        return op.invokeDescriptor();\n+        return block.ops().stream().filter(rootFilter);\n@@ -367,1 +234,1 @@\n-        return (JavaType) methodRef(op).refType();\n+        return (JavaType) op.invokeDescriptor().refType();\n@@ -374,1 +241,1 @@\n-    public static boolean isRawKernelCall(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+    public static boolean isKernelContextMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n@@ -386,1 +253,1 @@\n-        return (JavaType) methodRef(op).type().returnType();\n+        return (JavaType) op.invokeDescriptor().type().returnType();\n@@ -389,1 +256,1 @@\n-    public static Method method(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+    public static Method methodOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n@@ -391,1 +258,1 @@\n-            return methodRef(op).resolveToMethod(lookup, op.invokeKind());\n+            return op.invokeDescriptor().resolveToMethod(lookup, op.invokeKind());\n@@ -396,15 +263,1 @@\n-\n-    public static boolean isIfaceAccessor(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        if (isIfaceBufferMethod(lookup, invokeOp) && !javaReturnType(invokeOp).equals(JavaType.VOID)) {\n-            Optional<Class<?>> optionalClazz = javaReturnClass(lookup, invokeOp);\n-            return optionalClazz.isPresent() && Buffer.class.isAssignableFrom(optionalClazz.get());\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public static boolean isIfaceMutator(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return isIfaceBufferMethod(lookup, invokeOp) && javaReturnType(invokeOp).equals(JavaType.VOID);\n-    }\n-\n-    public static Optional<Class<?>> javaRefClass(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+    public static Class<?> javaRefClassOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n@@ -412,1 +265,1 @@\n-            return Optional.of((Class<?>) classTypeToType(lookup, classType));\n+            return (Class<?>) classTypeToTypeOrThrow(lookup, classType);\n@@ -414,1 +267,1 @@\n-            return Optional.empty();\n+            throw new IllegalStateException(\" javaRef class is null\");\n@@ -418,92 +271,0 @@\n-    public static Optional<Class<?>> javaReturnClass(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n-        if (javaReturnType(op) instanceof ClassType classType) {\n-            return Optional.of((Class<?>) classTypeToType(lookup, classType));\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n-\n-    public static class ParamTable {\n-        public static class Info {\n-            public final int idx;\n-            public final Block.Parameter parameter;\n-            public final JavaType javaType;\n-            public final CoreOp.VarOp varOp;\n-            public GroupLayout layout = null;\n-            public Class<?> clazz = null;\n-\n-            Info(int idx, Block.Parameter parameter, CoreOp.VarOp varOp) {\n-                this.idx = idx;\n-                this.parameter = parameter;\n-                this.javaType = (JavaType) parameter.type();\n-                this.varOp = varOp;\n-            }\n-\n-            public boolean isPrimitive() {\n-                return javaType instanceof PrimitiveType;\n-            }\n-\n-            public void setLayout(GroupLayout layout) {\n-                this.layout = layout;\n-            }\n-\n-            public void setClass(Class<?> clazz) {\n-                this.clazz = clazz;\n-            }\n-        }\n-\n-        final public BiMap<Block.Parameter, CoreOp.VarOp> parameterVarOpMap = new BiMap<>();\n-        final public BiMap<Block.Parameter, JavaOp.InvokeOp> parameterInvokeOpMap = new BiMap<>();\n-\n-        final private Map<Block.Parameter, Info> parameterToInfo = new LinkedHashMap<>();\n-        final private Map<CoreOp.VarOp, Info> varOpToInfo = new LinkedHashMap<>();\n-\n-        final private List<Info> list = new ArrayList<>();\n-\n-        public ParamTable.Info info(Block.Parameter parameter) {\n-            return parameterToInfo.get(parameter);\n-        }\n-\n-        void add(Map.Entry<Block.Parameter, CoreOp.VarOp> parameterToVarOp) {\n-            \/\/We add a new ParameterInfo to both maps using parameter and varOp as keys\n-            varOpToInfo.put(parameterToVarOp.getValue(),\n-                    \/\/ always called but convenient because computeIfAbsent returns what we added :)\n-                    parameterToInfo.computeIfAbsent(parameterToVarOp.getKey(), (parameterKey) -> {\n-                        var info = new ParamTable.Info(list.size(), parameterKey, parameterToVarOp.getValue());\n-                        list.add(info);\n-                        return info;\n-                    })\n-            );\n-        }\n-\n-        public List<Info> list() {\n-            return list;\n-        }\n-\n-        public Stream<Info> stream() {\n-            return list.stream();\n-        }\n-\n-        final public CoreOp funcOp;\n-\n-        public ParamTable(CoreOp.FuncOp funcOp) {\n-            this.funcOp = funcOp;\n-            funcOp.parameters().forEach(parameter -> {\n-                Optional<Op.Result> optionalResult = parameter.uses().stream().findFirst();\n-                optionalResult.ifPresentOrElse(result -> {\n-                    var resultOp = result.op();\n-                    if (resultOp instanceof CoreOp.VarOp varOp) {\n-                        parameterVarOpMap.add(parameter, varOp);\n-                        add(Map.entry(parameter, varOp));\n-                    } else if (resultOp instanceof JavaOp.InvokeOp invokeOp) {\n-                        parameterInvokeOpMap.add(parameter, invokeOp);\n-                    } else {\n-                        \/\/System.out.println(\"neither varOp or an invokeOp \"+resultOp.getClass().getName());\n-                    }\n-                }, () -> {\n-                    throw new IllegalStateException(\"no use of param\");\n-                });\n-            });\n-        }\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":46,"deletions":285,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-                OpTk.rootOpStream(buildContext.lookup,funcOp)\n+                OpTk.rootOpStream(funcOp)\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}