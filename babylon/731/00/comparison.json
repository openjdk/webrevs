{"files":[{"patch":"@@ -68,2 +68,0 @@\n-                 \/\/ .hashIfdef(\"HAT_CUDA\", _ ->\n-                   \/\/     indent(_ -> self()\n@@ -92,2 +90,2 @@\n-                .buildStructSingleMember(\"F16\", \"value\", \"half\")\n-                .buildStructSingleMember(\"BF16\", \"value\", \"BFLOAT16\");\n+                .buildStructSingleValueMember(\"F16\", \"half\")\n+                .buildStructSingleValueMember(\"BF16\",  \"BFLOAT16\");\n@@ -105,1 +103,0 @@\n-\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -115,5 +115,9 @@\n-                nl().separated(infoList,(t)->t.comma().nl(), (info) -> {\n-            ptxIndent().dot().param().space().paramType(info.javaType);\n-            space().regName(info.varOp.varName());\n-            paramNames.add(info.varOp.varName());\n-        }).nl()).nl();\n+                nl()\n+                        .commaNlSeparated(\n+                        infoList,\n+                        info -> {\n+                            ptxIndent().dot().param().space().paramType(info.javaType);\n+                            space().regName(info.varOp.varName());\n+                            paramNames.add(info.varOp.varName());\n+                        }\n+                        ).nl()).nl();\n@@ -517,3 +521,5 @@\n-                        separated(op.operands(),(_)->commaSpace(),\n-                        \/\/commaSeparated(op.operands(),\n-                                _ -> param().intVal(counter[0]++))).ptxNl();\n+                        commaSpaceSeparated(\n+                                op.operands(),\n+                                _ -> param().intVal(counter[0]++)\n+                        )\n+                ).ptxNl();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-                .buildStructSingleMember(\"F16\", \"value\", \"half\")\n-                .buildStructSingleMember(\"BF16\", \"value\", \"BFLOAT16\")\n+                .buildStructSingleValueMember(\"F16\",  \"half\")\n+                .buildStructSingleValueMember(\"BF16\",  \"BFLOAT16\")\n@@ -254,1 +254,1 @@\n-            oparen().floatType().cparen();\n+            oparen().f32Type().cparen();\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-            builder.nl().kernelEntrypoint(buildContext, args).nl();\n+            builder.nl().kernelEntrypoint(buildContext).nl();\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.Accelerator;\n@@ -34,1 +33,0 @@\n-import hat.ifacemapper.Schema;\n@@ -38,2 +36,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-\n@@ -72,1 +68,1 @@\n-            String code = createCode(kernelCallGraph, new OpenCLHatKernelBuilder(), args);\n+            String code = createCode(kernelCallGraph, new OpenCLHATKernelBuilder(), args);\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLBackend.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-public class OpenCLHatKernelBuilder extends C99HATKernelBuilder<OpenCLHatKernelBuilder> {\n+public class OpenCLHATKernelBuilder extends C99HATKernelBuilder<OpenCLHATKernelBuilder> {\n@@ -45,1 +45,1 @@\n-    public OpenCLHatKernelBuilder defines() {\n+    public OpenCLHATKernelBuilder defines() {\n@@ -79,1 +79,1 @@\n-    public OpenCLHatKernelBuilder atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n+    public OpenCLHATKernelBuilder atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n@@ -84,1 +84,1 @@\n-    public OpenCLHatKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n+    public OpenCLHATKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n@@ -113,1 +113,1 @@\n-    public OpenCLHatKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n+    public OpenCLHATKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -132,1 +132,1 @@\n-    public OpenCLHatKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n+    public OpenCLHATKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n@@ -157,1 +157,1 @@\n-    public OpenCLHatKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n+    public OpenCLHATKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n@@ -165,1 +165,1 @@\n-    public OpenCLHatKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n+    public OpenCLHATKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n@@ -181,1 +181,1 @@\n-    public OpenCLHatKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n+    public OpenCLHATKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n@@ -190,1 +190,1 @@\n-    public OpenCLHatKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n+    public OpenCLHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n@@ -204,1 +204,1 @@\n-    public OpenCLHatKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp) {\n+    public OpenCLHATKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp) {\n@@ -209,1 +209,1 @@\n-    public OpenCLHatKernelBuilder hatF16ToFloatConvOp(ScopedCodeBuilderContext builderContext, HATF16ToFloatConvOp hatF16ToFloatConvOp) {\n+    public OpenCLHATKernelBuilder hatF16ToFloatConvOp(ScopedCodeBuilderContext builderContext, HATF16ToFloatConvOp hatF16ToFloatConvOp) {\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHATKernelBuilder.java","additions":12,"deletions":12,"binary":false,"changes":24,"previous_filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","status":"copied"},{"patch":"@@ -42,1 +42,1 @@\n-public class OpenCLHatKernelBuilder extends C99HATKernelBuilder<OpenCLHatKernelBuilder> {\n+public class OpenCLHATKernelBuilder extends C99HATKernelBuilder<OpenCLHATKernelBuilder> {\n@@ -45,1 +45,1 @@\n-    public OpenCLHatKernelBuilder defines() {\n+    public OpenCLHATKernelBuilder defines() {\n@@ -79,1 +79,1 @@\n-    public OpenCLHatKernelBuilder atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n+    public OpenCLHATKernelBuilder atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n@@ -84,1 +84,1 @@\n-    public OpenCLHatKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n+    public OpenCLHATKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n@@ -113,1 +113,1 @@\n-    public OpenCLHatKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n+    public OpenCLHATKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -132,1 +132,1 @@\n-    public OpenCLHatKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n+    public OpenCLHATKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n@@ -157,1 +157,1 @@\n-    public OpenCLHatKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n+    public OpenCLHATKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n@@ -165,1 +165,1 @@\n-    public OpenCLHatKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n+    public OpenCLHATKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n@@ -181,1 +181,1 @@\n-    public OpenCLHatKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n+    public OpenCLHATKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n@@ -190,1 +190,1 @@\n-    public OpenCLHatKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n+    public OpenCLHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n@@ -204,1 +204,1 @@\n-    public OpenCLHatKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp) {\n+    public OpenCLHATKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp) {\n@@ -209,1 +209,1 @@\n-    public OpenCLHatKernelBuilder hatF16ToFloatConvOp(ScopedCodeBuilderContext builderContext, HATF16ToFloatConvOp hatF16ToFloatConvOp) {\n+    public OpenCLHATKernelBuilder hatF16ToFloatConvOp(ScopedCodeBuilderContext builderContext, HATF16ToFloatConvOp hatF16ToFloatConvOp) {\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-        builder.nl().kernelEntrypoint(buildContext, args).nl();\n+        builder.nl().kernelEntrypoint(buildContext).nl();\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,2 +90,3 @@\n-                            cb.separated(Config.bitList.stream().filter(bit -> bit.size() == 1), CodeBuilder::nl, bit ->\n-                                    cb.stdCout(\"native \" + C99HATConfigBuilder.toCamelExceptFirst(bit.name()) + \" \").space().leftShift().space().camelExceptFirst(bit.name()).space().leftShift().space().stdEndl().semicolon()\n+                            cb.nlSeparated(\n+                                    Config.bitList.stream().filter(bit -> bit.size() == 1),\n+                                    bit -> cb.stdCout(\"native \" + cb.toCamelExceptFirst(bit.name()) + \" \").space().leftShift().space().camelExceptFirst(bit.name()).space().leftShift().space().stdEndl().semicolon()\n","filename":"hat\/core\/src\/main\/java\/hat\/FFIConfigCreator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,1 +41,6 @@\n-                brace((_) -> separated(structLayout.memberLayouts(),(_)->comma(), this::layout));\n+                brace(_ ->\n+                        commaSeparated(\n+                                structLayout.memberLayouts(),\n+                                this::layout\n+                        )\n+                );\n@@ -43,1 +48,6 @@\n-                chevron((_) -> separated(unionLayout.memberLayouts(),(_)->bar(), this::layout));\n+                chevron(_ ->\n+                        barSeparated(\n+                                unionLayout.memberLayouts(),\n+                                this::layout\n+                        )\n+                );\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/SchemaBuilder.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.codebuilders;\n+\n+import hat.dialect.HATBarrierOp;\n+import hat.dialect.HATBlockThreadIdOp;\n+import hat.dialect.HATF16BinaryOp;\n+import hat.dialect.HATF16ConvOp;\n+import hat.dialect.HATF16ToFloatConvOp;\n+import hat.dialect.HATF16VarLoadOp;\n+import hat.dialect.HATF16VarOp;\n+import hat.dialect.HATGlobalSizeOp;\n+import hat.dialect.HATGlobalThreadIdOp;\n+import hat.dialect.HATLocalSizeOp;\n+import hat.dialect.HATLocalThreadIdOp;\n+import hat.dialect.HATLocalVarOp;\n+import hat.dialect.HATMemoryLoadOp;\n+import hat.dialect.HATPrivateInitVarOp;\n+import hat.dialect.HATPrivateVarOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorMakeOfOp;\n+import hat.dialect.HATVectorOfOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATVectorVarLoadOp;\n+import hat.dialect.HATVectorVarOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+\/* this should not be too C99 specific *\/\n+public interface BabylonCoreOpBuilder<T extends C99HATCodeBuilder<?>> {\n+    T type(ScopedCodeBuilderContext buildContext, JavaType javaType);\n+\n+    T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp);\n+\n+    T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp);\n+\n+    T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp);\n+\n+    T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, OpTk.ParamVar paramVar );\n+\n+    T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp);\n+\n+    T fieldStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp);\n+\n+    T unaryOp(ScopedCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp);\n+\n+    T binaryOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp);\n+\n+    T conditionalOp(ScopedCodeBuilderContext buildContext, JavaOp.JavaConditionalOp conditionalOp);\n+\n+    T binaryTestOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp);\n+\n+    T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp);\n+\n+    T constantOp(ScopedCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp);\n+\n+    T yieldOp(ScopedCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp);\n+\n+    T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp);\n+\n+    T tupleOp(ScopedCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp);\n+\n+    T funcCallOp(ScopedCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp);\n+\n+    T ifOp(ScopedCodeBuilderContext buildContext, JavaOp.IfOp ifOp);\n+\n+    T whileOp(ScopedCodeBuilderContext buildContext, JavaOp.WhileOp whileOp);\n+\n+    T labeledOp(ScopedCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp);\n+\n+    T continueOp(ScopedCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp);\n+\n+    T breakOp(ScopedCodeBuilderContext buildContext, JavaOp.BreakOp breakOp);\n+\n+    T forOp(ScopedCodeBuilderContext buildContext, JavaOp.ForOp forOp);\n+\n+    T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp);\n+\n+    T conditionalExpressionOp(ScopedCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp);\n+\n+    T parenthesisIfNeeded(ScopedCodeBuilderContext buildContext, Op parent, Op child);\n+\n+    T returnOp(ScopedCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp);\n+\n+    default T recurse(ScopedCodeBuilderContext buildContext, Op op) {\n+        switch (op) {\n+            case CoreOp.VarAccessOp.VarLoadOp $ -> varLoadOp(buildContext, $);\n+            case CoreOp.VarAccessOp.VarStoreOp $ -> varStoreOp(buildContext, $);\n+            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoadOp(buildContext, $);\n+            case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStoreOp(buildContext, $);\n+            case JavaOp.ConvOp $ -> convOp(buildContext, $);\n+            case CoreOp.ConstantOp $ -> constantOp(buildContext, $);\n+            case CoreOp.YieldOp $ -> yieldOp(buildContext, $);\n+            case CoreOp.FuncCallOp $ -> funcCallOp(buildContext, $);\n+            case JavaOp.InvokeOp $ -> invokeOp(buildContext, $);\n+            case JavaOp.ConditionalExpressionOp $ -> conditionalExpressionOp(buildContext, $);\n+            case CoreOp.VarOp $ when OpTk.paramVar($) instanceof OpTk.ParamVar paramVar -> varOp(buildContext, $,paramVar);\n+            case CoreOp.VarOp $ -> varOp(buildContext, $);\n+            case JavaOp.LambdaOp $ -> lambdaOp(buildContext, $);\n+            case CoreOp.TupleOp $ -> tupleOp(buildContext, $);\n+            case JavaOp.WhileOp $ -> whileOp(buildContext, $);\n+            case JavaOp.IfOp $ -> ifOp(buildContext, $);\n+            case JavaOp.ForOp $ -> forOp(buildContext, $);\n+            case CoreOp.ReturnOp $ -> returnOp(buildContext, $);\n+            case JavaOp.LabeledOp $ -> labeledOp(buildContext, $);\n+            case JavaOp.BreakOp $ -> breakOp(buildContext, $);\n+            case JavaOp.ContinueOp $ -> continueOp(buildContext, $);\n+            case JavaOp.BinaryTestOp $ -> binaryTestOp(buildContext, $);\n+            case JavaOp.BinaryOp $ -> binaryOp(buildContext, $);\n+            case JavaOp.JavaConditionalOp $ -> conditionalOp(buildContext, $);\n+            case JavaOp.UnaryOp $ -> unaryOp(buildContext, $);\n+\n+            default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n+        }\n+        return (T) this;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonCoreOpBuilder.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.codebuilders;\n+\n+import hat.dialect.HATBarrierOp;\n+import hat.dialect.HATBlockThreadIdOp;\n+import hat.dialect.HATF16BinaryOp;\n+import hat.dialect.HATF16ConvOp;\n+import hat.dialect.HATF16ToFloatConvOp;\n+import hat.dialect.HATF16VarLoadOp;\n+import hat.dialect.HATF16VarOp;\n+import hat.dialect.HATGlobalSizeOp;\n+import hat.dialect.HATGlobalThreadIdOp;\n+import hat.dialect.HATLocalSizeOp;\n+import hat.dialect.HATLocalThreadIdOp;\n+import hat.dialect.HATLocalVarOp;\n+import hat.dialect.HATMemoryLoadOp;\n+import hat.dialect.HATPrivateInitVarOp;\n+import hat.dialect.HATPrivateVarOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorMakeOfOp;\n+import hat.dialect.HATVectorOfOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATVectorVarLoadOp;\n+import hat.dialect.HATVectorVarOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+\/* this should not be too C99 specific *\/\n+public interface BabylonKernelOpBuilder<T extends C99HATCodeBuilder<?>> extends BabylonCoreOpBuilder<T> {\n+\n+    T hatBarrierOp(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp);\n+\n+    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATLocalVarOp barrierOp);\n+\n+    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATPrivateVarOp hatLocalVarOp);\n+\n+    T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp hatGlobalThreadIdOp);\n+\n+    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATGlobalSizeOp hatGlobalSizeOp);\n+\n+    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATLocalThreadIdOp hatLocalThreadIdOp);\n+\n+    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATLocalSizeOp hatLocalSizeOp);\n+\n+    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATBlockThreadIdOp hatBlockThreadIdOp);\n+\n+    T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp);\n+\n+    T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatFloat4StoreOp);\n+\n+    T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp);\n+\n+    T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp);\n+\n+    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp);\n+\n+    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp);\n+\n+    T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp);\n+\n+    T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16VarOp hatF16VarOp);\n+\n+    T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatF16BinaryOp);\n+\n+    T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16VarLoadOp hatF16VarLoadOp);\n+\n+    T hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp);\n+\n+    T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOfOp hatVectorOp);\n+\n+    T hatVectorMakeOf(ScopedCodeBuilderContext buildContext, HATVectorMakeOfOp hatVectorMakeOfOp);\n+\n+    T hatF16ToFloatConvOp(ScopedCodeBuilderContext buildContext, HATF16ToFloatConvOp hatF16ToFloatConvOp);\n+\n+    T hatPrivateVarInitOp(ScopedCodeBuilderContext buildContext, HATPrivateInitVarOp hatPrivateInitVarOp);\n+\n+    T hatMemoryLoadOp(ScopedCodeBuilderContext buildContext, HATMemoryLoadOp hatMemoryLoadOp);\n+\n+    default T recurse(ScopedCodeBuilderContext buildContext, Op op) {\n+        switch (op) {\n+            case CoreOp.VarAccessOp.VarLoadOp $ -> varLoadOp(buildContext, $);\n+            case CoreOp.VarAccessOp.VarStoreOp $ -> varStoreOp(buildContext, $);\n+            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoadOp(buildContext, $);\n+            case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStoreOp(buildContext, $);\n+            case JavaOp.ConvOp $ -> convOp(buildContext, $);\n+            case CoreOp.ConstantOp $ -> constantOp(buildContext, $);\n+            case CoreOp.YieldOp $ -> yieldOp(buildContext, $);\n+            case CoreOp.FuncCallOp $ -> funcCallOp(buildContext, $);\n+            case JavaOp.InvokeOp $ -> invokeOp(buildContext, $);\n+            case JavaOp.ConditionalExpressionOp $ -> conditionalExpressionOp(buildContext, $);\n+            case CoreOp.VarOp $ when OpTk.paramVar($) instanceof OpTk.ParamVar paramVar -> varOp(buildContext, $,paramVar);\n+            case CoreOp.VarOp $ -> varOp(buildContext, $);\n+            case JavaOp.LambdaOp $ -> lambdaOp(buildContext, $);\n+            case CoreOp.TupleOp $ -> tupleOp(buildContext, $);\n+            case JavaOp.WhileOp $ -> whileOp(buildContext, $);\n+            case JavaOp.IfOp $ -> ifOp(buildContext, $);\n+            case JavaOp.ForOp $ -> forOp(buildContext, $);\n+            case CoreOp.ReturnOp $ -> returnOp(buildContext, $);\n+            case JavaOp.LabeledOp $ -> labeledOp(buildContext, $);\n+            case JavaOp.BreakOp $ -> breakOp(buildContext, $);\n+            case JavaOp.ContinueOp $ -> continueOp(buildContext, $);\n+            case JavaOp.BinaryTestOp $ -> binaryTestOp(buildContext, $);\n+            case JavaOp.BinaryOp $ -> binaryOp(buildContext, $);\n+            case JavaOp.JavaConditionalOp $ -> conditionalOp(buildContext, $);\n+            case JavaOp.UnaryOp $ -> unaryOp(buildContext, $);\n+            case HATBarrierOp $ -> hatBarrierOp(buildContext, $);\n+            case HATLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n+            case HATPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n+            case HATPrivateInitVarOp $ -> hatPrivateVarInitOp(buildContext, $);\n+            case HATGlobalThreadIdOp $ -> hatGlobalThreadOp(buildContext, $);\n+            case HATGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n+            case HATLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n+            case HATLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n+            case HATBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n+            case HATVectorVarOp $ -> hatVectorVarOp(buildContext, $);\n+            case HATVectorStoreView $ -> hatVectorStoreOp(buildContext, $);\n+            case HATVectorBinaryOp $ -> hatBinaryVectorOp(buildContext, $);\n+            case HATVectorLoadOp $ -> hatVectorLoadOp(buildContext, $);\n+            case HATVectorSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n+            case HATVectorSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n+            case HATVectorVarLoadOp $ -> hatVectorVarLoadOp(buildContext, $);\n+            case HATVectorOfOp $ -> hatVectorOfOps(buildContext, $);\n+            case HATF16VarOp $ -> hatF16VarOp(buildContext, $);\n+            case HATF16BinaryOp $ -> hatF16BinaryOp(buildContext, $);\n+            case HATF16VarLoadOp $ -> hatF16VarLoadOp(buildContext, $);\n+            case HATF16ConvOp $ -> hatF16ConvOp(buildContext, $);\n+            case HATVectorMakeOfOp $ -> hatVectorMakeOf(buildContext, $);\n+            case HATF16ToFloatConvOp $ -> hatF16ToFloatConvOp(buildContext, $);\n+            case HATMemoryLoadOp $ -> hatMemoryLoadOp(buildContext, $);\n+            default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n+        }\n+        return (T) this;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonKernelOpBuilder.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -1,214 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.dialect.HATBarrierOp;\n-import hat.dialect.HATBlockThreadIdOp;\n-import hat.dialect.HATF16BinaryOp;\n-import hat.dialect.HATF16ConvOp;\n-import hat.dialect.HATF16ToFloatConvOp;\n-import hat.dialect.HATF16VarLoadOp;\n-import hat.dialect.HATF16VarOp;\n-import hat.dialect.HATGlobalSizeOp;\n-import hat.dialect.HATGlobalThreadIdOp;\n-import hat.dialect.HATLocalSizeOp;\n-import hat.dialect.HATLocalThreadIdOp;\n-import hat.dialect.HATLocalVarOp;\n-import hat.dialect.HATMemoryLoadOp;\n-import hat.dialect.HATPrivateInitVarOp;\n-import hat.dialect.HATPrivateVarOp;\n-import hat.dialect.HATVectorBinaryOp;\n-import hat.dialect.HATVectorLoadOp;\n-import hat.dialect.HATVectorMakeOfOp;\n-import hat.dialect.HATVectorOfOp;\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorSelectStoreOp;\n-import hat.dialect.HATVectorStoreView;\n-import hat.dialect.HATVectorVarLoadOp;\n-import hat.dialect.HATVectorVarOp;\n-import hat.optools.OpTk;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-\/* this should not be too C99 specific *\/\n-public interface BabylonOpBuilder<T extends HATCodeBuilderWithContext<?>> {\n-\n-    T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp);\n-\n-    T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp);\n-\n-    T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp);\n-\n-    T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, OpTk.ParamVar paramVar );\n-\n-    T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp);\n-\n-    T fieldStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp);\n-\n-    T unaryOp(ScopedCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp);\n-\n-    T binaryOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp);\n-\n-    T conditionalOp(ScopedCodeBuilderContext buildContext, JavaOp.JavaConditionalOp conditionalOp);\n-\n-    T binaryTestOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp);\n-\n-    T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp);\n-\n-    T constantOp(ScopedCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp);\n-\n-    T yieldOp(ScopedCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp);\n-\n-    T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp);\n-\n-    T tupleOp(ScopedCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp);\n-\n-    T funcCallOp(ScopedCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp);\n-\n-    T ifOp(ScopedCodeBuilderContext buildContext, JavaOp.IfOp ifOp);\n-\n-    T whileOp(ScopedCodeBuilderContext buildContext, JavaOp.WhileOp whileOp);\n-\n-    T labeledOp(ScopedCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp);\n-\n-    T continueOp(ScopedCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp);\n-\n-    T breakOp(ScopedCodeBuilderContext buildContext, JavaOp.BreakOp breakOp);\n-\n-    T forOp(ScopedCodeBuilderContext buildContext, JavaOp.ForOp forOp);\n-\n-    T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp);\n-\n-    T conditionalExpressionOp(ScopedCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp);\n-\n-    T parenthesisIfNeeded(ScopedCodeBuilderContext buildContext, Op parent, Op child);\n-\n-    T returnOp(ScopedCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp);\n-\n-    T barrier(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp);\n-\n-    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATLocalVarOp barrierOp);\n-\n-    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATPrivateVarOp hatLocalVarOp);\n-\n-    T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp hatGlobalThreadIdOp);\n-\n-    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATGlobalSizeOp hatGlobalSizeOp);\n-\n-    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATLocalThreadIdOp hatLocalThreadIdOp);\n-\n-    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATLocalSizeOp hatLocalSizeOp);\n-\n-    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATBlockThreadIdOp hatBlockThreadIdOp);\n-\n-    T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp);\n-\n-    T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatFloat4StoreOp);\n-\n-    T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp);\n-\n-    T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp);\n-\n-    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp);\n-\n-    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp);\n-\n-    T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp);\n-\n-    T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16VarOp hatF16VarOp);\n-\n-    T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatF16BinaryOp);\n-\n-    T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16VarLoadOp hatF16VarLoadOp);\n-\n-    T hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp);\n-\n-    T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOfOp hatVectorOp);\n-\n-    T hatVectorMakeOf(ScopedCodeBuilderContext buildContext, HATVectorMakeOfOp hatVectorMakeOfOp);\n-\n-    T hatF16ToFloatConvOp(ScopedCodeBuilderContext buildContext, HATF16ToFloatConvOp hatF16ToFloatConvOp);\n-\n-    T hatPrivateVarInitOp(ScopedCodeBuilderContext buildContext, HATPrivateInitVarOp hatPrivateInitVarOp);\n-\n-    T hatMemoryLoadOp(ScopedCodeBuilderContext buildContext, HATMemoryLoadOp hatMemoryLoadOp);\n-\n-    default T recurse(ScopedCodeBuilderContext buildContext, Op op) {\n-        switch (op) {\n-            case CoreOp.VarAccessOp.VarLoadOp $ -> varLoadOp(buildContext, $);\n-            case CoreOp.VarAccessOp.VarStoreOp $ -> varStoreOp(buildContext, $);\n-            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoadOp(buildContext, $);\n-            case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStoreOp(buildContext, $);\n-            case JavaOp.ConvOp $ -> convOp(buildContext, $);\n-            case CoreOp.ConstantOp $ -> constantOp(buildContext, $);\n-            case CoreOp.YieldOp $ -> yieldOp(buildContext, $);\n-            case CoreOp.FuncCallOp $ -> funcCallOp(buildContext, $);\n-            case JavaOp.InvokeOp $ -> invokeOp(buildContext, $);\n-            case JavaOp.ConditionalExpressionOp $ -> conditionalExpressionOp(buildContext, $);\n-            case CoreOp.VarOp $ when OpTk.paramVar($) instanceof OpTk.ParamVar paramVar -> varOp(buildContext, $,paramVar);\n-            case CoreOp.VarOp $ -> varOp(buildContext, $);\n-            case JavaOp.LambdaOp $ -> lambdaOp(buildContext, $);\n-            case CoreOp.TupleOp $ -> tupleOp(buildContext, $);\n-            case JavaOp.WhileOp $ -> whileOp(buildContext, $);\n-            case JavaOp.IfOp $ -> ifOp(buildContext, $);\n-            case JavaOp.ForOp $ -> forOp(buildContext, $);\n-            case CoreOp.ReturnOp $ -> returnOp(buildContext, $);\n-            case JavaOp.LabeledOp $ -> labeledOp(buildContext, $);\n-            case JavaOp.BreakOp $ -> breakOp(buildContext, $);\n-            case JavaOp.ContinueOp $ -> continueOp(buildContext, $);\n-            case JavaOp.BinaryTestOp $ -> binaryTestOp(buildContext, $);\n-            case JavaOp.BinaryOp $ -> binaryOp(buildContext, $);\n-            case JavaOp.JavaConditionalOp $ -> conditionalOp(buildContext, $);\n-            case JavaOp.UnaryOp $ -> unaryOp(buildContext, $);\n-            case HATBarrierOp $ -> barrier(buildContext, $);\n-            case HATLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n-            case HATPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n-            case HATPrivateInitVarOp $ -> hatPrivateVarInitOp(buildContext, $);\n-            case HATGlobalThreadIdOp $ -> hatGlobalThreadOp(buildContext, $);\n-            case HATGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n-            case HATLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n-            case HATLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n-            case HATBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n-            case HATVectorVarOp $ -> hatVectorVarOp(buildContext, $);\n-            case HATVectorStoreView $ -> hatVectorStoreOp(buildContext, $);\n-            case HATVectorBinaryOp $ -> hatBinaryVectorOp(buildContext, $);\n-            case HATVectorLoadOp $ -> hatVectorLoadOp(buildContext, $);\n-            case HATVectorSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n-            case HATVectorSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n-            case HATVectorVarLoadOp $ -> hatVectorVarLoadOp(buildContext, $);\n-            case HATVectorOfOp $ -> hatVectorOfOps(buildContext, $);\n-            case HATF16VarOp $ -> hatF16VarOp(buildContext, $);\n-            case HATF16BinaryOp $ -> hatF16BinaryOp(buildContext, $);\n-            case HATF16VarLoadOp $ -> hatF16VarLoadOp(buildContext, $);\n-            case HATF16ConvOp $ -> hatF16ConvOp(buildContext, $);\n-            case HATVectorMakeOfOp $ -> hatVectorMakeOf(buildContext, $);\n-            case HATF16ToFloatConvOp $ -> hatF16ToFloatConvOp(buildContext, $);\n-            case HATMemoryLoadOp $ -> hatMemoryLoadOp(buildContext, $);\n-            default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n-        }\n-        return (T) this;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonOpBuilder.java","additions":0,"deletions":214,"binary":false,"changes":214,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-public class C99CodeBuilder<T extends HATCodeBuilder<T>> extends CodeBuilder<T> {\n-\n-    public C99CodeBuilder() {}\n-\n-    public C99CodeBuilder(String text) {\n-        this.emitText(text);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99CodeBuilder.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -0,0 +1,276 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.codebuilders;\n+import jdk.incubator.code.dialect.java.ClassType;\n+\n+import java.util.Arrays;\n+import java.util.function.Consumer;\n+\n+public  class C99HATCodeBuilder<T extends C99HATCodeBuilder<T>> extends HATCodeBuilder<T> {\n+\n+    public final T suffix_t(ClassType type){\n+        String name = type.toClassName();\n+        int dotIdx = name.lastIndexOf('.');\n+        int dollarIdx = name.lastIndexOf('$');\n+        int idx = Math.max(dotIdx, dollarIdx);\n+        if (idx > 0) {\n+            name = name.substring(idx + 1);\n+        }\n+        return suffix_t(name);\n+    }\n+\n+    public final T suffix_t(String name) {\n+        return identifier(name).identifier(\"_t\");\n+    }\n+\n+    public final T suffix_u(String name) {\n+        return identifier(name).identifier(\"_u\");\n+    }\n+\n+    public final T suffix_s(String name) {\n+        return identifier(name).identifier(\"_s\");\n+    }\n+\n+    public final T suffix_t(Class<?> klass) {\n+        return suffix_t(klass.getSimpleName());\n+    }\n+\n+    public final T suffix_u(Class<?> klass) {\n+        return suffix_u(klass.getSimpleName());\n+    }\n+\n+    public final T suffix_s(Class<?> klass) {\n+        return suffix_s(klass.getSimpleName());\n+    }\n+\n+    public final T structOrUnion(boolean isStruct) {\n+        return (isStruct ? structKeyword() : union());\n+    }\n+\n+\n+    public final T typedefKeyword() {\n+        return keyword(\"typedef\");\n+    }\n+\n+\n+    public final T structKeyword() {\n+        return keyword(\"struct\");\n+    }\n+\n+    public final T union() {\n+        return keyword(\"union\");\n+    }\n+\n+\n+    public final T externC() {\n+        return externKeyword().space().dquote(\"C\");\n+    }\n+\n+    public final T hashDefineKeyword() {\n+        return hash().keyword(\"define\");\n+    }\n+\n+    public final T hashIfdefKeyword() {\n+        return hash().keyword(\"ifdef\");\n+    }\n+\n+    public final T hashIfndefKeyword() {\n+        return hash().keyword(\"ifndef\");\n+    }\n+\n+    public final T hashEndif() {\n+        return hash().keyword(\"endif\").nl();\n+    }\n+\n+    public final T hashIfdef(String value) {\n+        return hashIfdefKeyword().space().constant(value).nl();\n+    }\n+\n+    public final T hashIfndef(String value) {\n+        return hashIfndefKeyword().space().constant(value).nl();\n+    }\n+\n+    public final T hashIfdef(String value, Consumer<T> consumer) {\n+        return hashIfdef(value).accept(consumer).hashEndif();\n+    }\n+\n+    public final T hashIfndef(String value, Consumer<T> consumer) {\n+        return hashIfndef(value).accept(consumer).hashEndif();\n+    }\n+\n+    public final T pragmaKeyword() {\n+        return keyword(\"pragma\");\n+    }\n+\n+    public final T includeKeyword() {\n+        return keyword(\"include\");\n+    }\n+\n+    public final T hashDefine(String name, String... values) {\n+        hashDefineKeyword().space().identifier(name);\n+        for (String value : values) {\n+            space().constant(value);\n+        }\n+        return nl();\n+    }\n+\n+    public final T hashDefine(String name, Consumer<T> consumer) {\n+        hashDefineKeyword().space().identifier(name);\n+        space();\n+        consumer.accept(self());\n+        return nl();\n+    }\n+\n+    public final T pragma(String name, String... values) {\n+        hash().pragmaKeyword().space().identifier(name);\n+        for (String value : values) {\n+            space().constant(value);\n+        }\n+        return nl();\n+    }\n+    public final T includeSys(String... values) {\n+        for (String value : values) {\n+            hash().includeKeyword().space().lt().identifier(value).gt().nl();\n+        }\n+        return self();\n+    }\n+    public final T include(String... values) {\n+        for (String value : values) {\n+            hash().includeKeyword().space().dquote().identifier(value).dquote().nl();\n+        }\n+        return nl();\n+    }\n+\n+    public final T externKeyword() {\n+        return keyword(\"extern\");\n+    }\n+\n+    public final T unsignedCharType() {\n+        return typeName(\"unsigned\").space().charType();\n+    }\n+    public final T unsignedCharType(String identifier) {\n+        return unsignedCharType().space().identifier(identifier);\n+    }\n+    public final T u08PtrType() {\n+        return unsignedCharType().space().asterisk();\n+    }\n+    public final T u08PtrType(String identifier) {\n+        return u08PtrType().identifier(identifier);\n+    }\n+\n+    public final T charTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> charType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public final T unsignedCharTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedCharType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public final T shortTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> shortType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public final T unsignedShortTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedShortType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public final T intTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> intType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public final T unsignedIntTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> u32Type(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public final T floatTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> f32Type(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public final T longTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> longType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public final T unsignedLongTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedLongType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public final T doubleTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> doubleType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+     public final  T typedef(Consumer<T> lhs, Consumer<T> rhs) {\n+        return semicolonNlTerminated(_ -> typedefKeyword().space().accept(lhs).space().accept(rhs));\n+    }\n+\n+    public final T u32Type() {\n+        return typeName(\"unsigned\").space().intType();\n+    }\n+\n+    public final T u32Type(String identifier ) {\n+        return u32Type().space().identifier(identifier);\n+    }\n+\n+    public final T unsignedLongType() {\n+        return typeName(\"unsigned\").space().longType();\n+    }\n+\n+    public final T unsignedShortType() {\n+        return typeName(\"unsigned\").space().shortType();\n+    }\n+    public final T unsignedShortType(String identifier) {\n+        return unsignedShortType().space().identifier(identifier);\n+    }\n+\n+    public final  T typedefStructOrUnion(boolean isStruct, Class<?> klass, Consumer<T> consumer) {\n+        return typedefKeyword()\n+                .space()\n+                .structOrUnion(isStruct)\n+                .space()\n+                .either(isStruct, _ -> suffix_s(klass), _ -> suffix_u(klass))\n+                .braceNlIndented(consumer)\n+                .suffix_t(klass).semicolonNl();\n+    }\n+\n+    public final T typedefStruct(String name, Consumer<T> consumer) {\n+        return typedefKeyword()\n+                .space()\n+                .structKeyword()\n+                .space()\n+                .suffix_s(name)\n+                .braceNlIndented(consumer)\n+                .suffix_t(name)\n+                .semicolonNl();\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilder.java","additions":276,"deletions":0,"binary":false,"changes":276,"status":"added"},{"patch":"@@ -0,0 +1,526 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.codebuilders;\n+\n+import hat.buffer.HAType;\n+import hat.device.DeviceType;\n+import hat.dialect.HATF16VarOp;\n+import hat.dialect.HATLocalVarOp;\n+import hat.dialect.HATMemoryOp;\n+import hat.dialect.HATPrivateInitVarOp;\n+import hat.dialect.HATPrivateVarOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorVarOp;\n+import hat.ifacemapper.MappableIface;\n+import hat.optools.FuncOpParams;\n+import hat.optools.OpTk;\n+import hat.util.StreamMutable;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n+import java.util.List;\n+\n+public abstract class C99HATCodeBuilderContext<T extends C99HATCodeBuilderContext<T>> extends C99HATCodeBuilder<T> implements BabylonCoreOpBuilder<T> {\n+\n+  \/*  public final  T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n+        if (OpTk.isAssignable(buildContext.lookup, javaType, MappableIface.class)\n+                        && javaType instanceof ClassType classType) {\n+            suffix_t(classType).asterisk();\n+        } else {\n+            typeName(javaType.toBasicType().toString());\n+        }\n+        return self();\n+    } *\/\n+\n+    @Override\n+    public final T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n+        switch (resolve) {\n+            case CoreOp.VarOp $ -> varName($);\n+            case HATMemoryOp $ -> varName($);\n+            case HATVectorVarOp $ -> varName($);\n+            case HATVectorLoadOp $ -> varName($);\n+            case HATVectorBinaryOp $ -> varName($);\n+            case HATF16VarOp $ -> varName($);\n+            case null, default -> {\n+            }\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp) {\n+        Op op = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n+        \/\/ When the op is intended to operate as VarOp, then we need to include it in the following switch.\n+        \/\/ This is because HAT has its own dialect, and some of the Ops operate on HAT Types (not included in the Java\n+        \/\/ dialect). For instance, private data structures, local data structures, vector types, etc.\n+        switch (op) {\n+            case CoreOp.VarOp varOp -> varName(varOp).equals();\n+            case HATF16VarOp hatf16VarOp -> varName(hatf16VarOp).equals();\n+            case HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp).equals();\n+            case HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp).equals();\n+            case HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp).equals();\n+            case HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp).equals();\n+            case null, default -> {\n+            }\n+        }\n+        parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n+        return self();\n+    }\n+\n+\n+    private void varDeclarationWithInitialization(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n+        if (buildContext.isVarOpFinal(varOp)) {\n+            constKeyword().space();\n+        }\n+        type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp).space().equals().space();\n+        parenthesisIfNeeded(buildContext, varOp, ((Op.Result)varOp.operands().getFirst()).op());\n+    }\n+\n+    @Override\n+    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n+        if (varOp.isUninitialized()) {\n+            type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp);\n+        } else {\n+            varDeclarationWithInitialization(buildContext, varOp);\n+        }\n+        return self();\n+    }\n+\n+\n+\n+    @Override\n+    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, OpTk.ParamVar paramVar) {\n+        return self();\n+    }\n+\n+    @Override\n+    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n+            Object value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n+            literal(value.toString());\n+        } else {\n+            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOp);\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public T fieldStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp) {\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public T unaryOp(ScopedCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp) {\n+        symbol(unaryOp).parenthesisIfNeeded(buildContext, unaryOp, ((Op.Result)unaryOp.operands().getFirst()).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public T binaryOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp) {\n+        parenthesisIfNeeded(buildContext, binaryOp, OpTk.lhsResult(binaryOp).op());\n+        symbol(binaryOp);\n+        parenthesisIfNeeded(buildContext, binaryOp, OpTk.rhsResult(binaryOp).op());\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public T conditionalOp(ScopedCodeBuilderContext buildContext, JavaOp.JavaConditionalOp logicalOp) {\n+        OpTk.lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n+        space().symbol(logicalOp).space();\n+        OpTk.rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n+        return self();\n+    }\n+\n+    @Override\n+    public T binaryTestOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp) {\n+        parenthesisIfNeeded(buildContext, binaryTestOp, OpTk.lhsResult(binaryTestOp).op());\n+        symbol(binaryTestOp);\n+        parenthesisIfNeeded(buildContext, binaryTestOp, OpTk.rhsResult(binaryTestOp).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n+        if (convOp.resultType() == JavaType.DOUBLE) {\n+            paren(_ -> type(buildContext,JavaType.FLOAT)); \/\/ why double to float?\n+        } else {\n+            paren(_ -> type(buildContext,(JavaType)convOp.resultType()));\n+        }\n+        parenthesisIfNeeded(buildContext, convOp, OpTk.result(convOp).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public T constantOp(ScopedCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp) {\n+        if (constantOp.value() == null) {\n+            nullConst();\n+        } else {\n+            literal(constantOp.value().toString());\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public T yieldOp(ScopedCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp) {\n+        if (yieldOp.operands().getFirst() instanceof Op.Result result) {\n+            recurse(buildContext, result.op());\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp) {\n+        return comment(\"\/*LAMBDA*\/\");\n+    }\n+\n+    @Override\n+    public T tupleOp(ScopedCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp) {\n+        commaSpaceSeparated(tupleOp.operands(),operand->{\n+            if (operand instanceof Op.Result result) {\n+                recurse(buildContext, result.op());\n+            } else {\n+                comment(\"\/*nothing to tuple*\/\");\n+            }\n+        });\n+        return self();\n+    }\n+\n+    @Override\n+    public T funcCallOp(ScopedCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp) {\n+        funcName(funcCallOp);\n+        paren(_ ->\n+            commaSpaceSeparated(\n+                    funcCallOp.operands().stream().filter(e->e instanceof Op.Result ).map(e->(Op.Result)e),\n+                    result -> recurse(buildContext,result.op())\n+            )\n+        );\n+        return self();\n+    }\n+\n+    @Override\n+    public T labeledOp(ScopedCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp) {\n+        var labelNameOp = labeledOp.bodies().getFirst().entryBlock().ops().getFirst();\n+        CoreOp.ConstantOp constantOp = (CoreOp.ConstantOp) labelNameOp;\n+        literal(constantOp.value().toString()).colon().nl();\n+        var forLoopOp = labeledOp.bodies().getFirst().entryBlock().ops().get(1);\n+        recurse(buildContext,forLoopOp);\n+        return self();\n+    }\n+    @Override\n+    public T breakOp(ScopedCodeBuilderContext buildContext, JavaOp.BreakOp breakOp) {\n+        breakKeyword();\n+        if (!breakOp.operands().isEmpty() && breakOp.operands().getFirst() instanceof Op.Result result) {\n+            space();\n+            if (result.op() instanceof CoreOp.ConstantOp c) {\n+                literal(c.value().toString());\n+            }\n+        }\n+        return self();\n+    }\n+    @Override\n+    public T continueOp(ScopedCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp) {\n+        if (!continueOp.operands().isEmpty()\n+                && continueOp.operands().getFirst() instanceof Op.Result result\n+                && result.op() instanceof CoreOp.ConstantOp c\n+        ) {\n+            continueKeyword().space().literal(c.value().toString());\n+        } else if (buildContext.scope.parent instanceof ScopedCodeBuilderContext.ForScope) {\n+            \/\/ nope\n+        } else {\n+            continueKeyword();\n+        }\n+\n+        return self();\n+    }\n+\n+    @Override\n+    public T ifOp(ScopedCodeBuilderContext buildContext, JavaOp.IfOp ifOp) {\n+        buildContext.ifScope(ifOp, () -> {\n+            var lastWasBody = StreamMutable.of(false);\n+            var i = StreamMutable.of(0);\n+            \/\/ We probably should just use a regular for loop here ;)\n+            ifOp.bodies().forEach(b->{\n+                int idx = i.get();\n+                if (b.yieldType() instanceof JavaType javaType && javaType == JavaType.VOID) {\n+                    if (ifOp.bodies().size() > idx && ifOp.bodies().get(idx).entryBlock().ops().size() > 1){\n+                        if (lastWasBody.get()) {\n+                            elseKeyword();\n+                        }\n+                        braceNlIndented(_ ->\n+                                        nlSeparated(OpTk.statements(ifOp.bodies().get(idx).entryBlock()),\n+                                        root-> statement(buildContext,root)\n+                                        ));\n+                    }\n+                    lastWasBody.set(true);\n+                } else {\n+                    if (idx>0) {\n+                        elseKeyword().space();\n+                    }\n+                    ifKeyword().paren(_ ->\n+                            ifOp.bodies().get(idx).entryBlock()            \/\/ get the entryblock if bodies[c.value]\n+                                    .ops().stream().filter(o->o instanceof CoreOp.YieldOp) \/\/ we want all the yields\n+                                    .forEach((yield) -> recurse(buildContext, yield))\n+                    );\n+                    lastWasBody.set(false);\n+                }\n+                i.set(i.get()+1);\n+            });\n+        });\n+        return self();\n+    }\n+\n+    @Override\n+    public T whileOp(ScopedCodeBuilderContext buildContext, JavaOp.WhileOp whileOp) {\n+        whileKeyword().paren(_ ->\n+                OpTk.condBlock(whileOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n+                        .forEach(o -> recurse(buildContext, o))\n+        );\n+        braceNlIndented(_ ->\n+                        nlSeparated(OpTk.statements(whileOp),\n+                        statement->statement(buildContext,statement)\n+                )\n+        );\n+        return self();\n+    }\n+\n+    @Override\n+    public T forOp(ScopedCodeBuilderContext buildContext, JavaOp.ForOp forOp) {\n+        buildContext.forScope(forOp, () ->\n+                forKeyword().paren(_ -> {\n+                    OpTk.initBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+                    semicolon().space();\n+                    OpTk.condBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+                    semicolon().space();\n+                    commaSpaceSeparated(\n+                            OpTk.statements(OpTk.mutateBlock(forOp)),\n+                            op -> recurse(buildContext, op)\n+                    );\n+                }).braceNlIndented(_ ->\n+                            nlSeparated(OpTk.statements(forOp),\n+                                    statement ->statement(buildContext,statement)\n+                        )\n+                )\n+        );\n+        return self();\n+    }\n+\n+    public abstract  T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name);\n+\n+    @Override\n+    public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n+        if (OpTk.isIfaceBufferMethod(buildContext.lookup, invokeOp)\n+                || OpTk.isInvokeDescriptorSubtypeOfAnyMatch(invokeOp, List.of(HAType.class, DeviceType.class))) {\n+            if (invokeOp.operands().size() == 1\n+                    && OpTk.funcName(invokeOp) instanceof String funcName\n+                    && funcName.startsWith(\"atomic\")\n+                    && funcName.endsWith(\"Inc\")\n+                    && OpTk.javaReturnType(invokeOp).equals(JavaType.INT)) {\n+                \/\/ this is a bit of a hack for atomics.\n+                if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n+                    atomicInc(buildContext, instanceResult, funcName.substring(0, funcName.length() - \"Inc\".length()));\n+                } else {\n+                    throw new IllegalStateException(\"bad atomic\");\n+                }\n+            } else {\n+\n+               if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n+                \/*\n+                We have three types of returned values from an ifaceBuffer\n+                A primitive\n+                    int id = stage.firstTreeId(); -> stage->firstTreeId;\n+\n+                Or a sub interface from an array\n+                     Tree tree = cascade.tree(treeIdx); -> Tree_t * tree = &cascade->tree[treeIdx]\n+                                                        ->               = cascade->tree + treeIdx;\n+\n+                Or a sub interface from a field\n+\n+                var left = feature.left();              ->  LinkOrValue_t * left= &feature->left\n+\n+                                -\n+                    if (left.hasValue()) {                  left->hasValue\n+                        sum += left.anon().value();         left->anon.value;\n+                        feature = null; \/\/ loop ends\n+                    } else {\n+                        feature = cascade.feature(tree.firstFeatureId() + left.anon().featureId());\n+                    }\n+                 sumOfThisStage += left.anon().value();\n+\n+\n+                For a primitive we know that the accessor refers to a field so we just  map\n+                         stage.firstTreeId() -> stage->firstTreeId;\n+\n+                For the sub interface we need to treat the call\n+                          cascade.tree(treeIdx);\n+\n+                As an array index into cascade->tree[] that returns a typedef of Tree_t\n+                so we need to prefix with an & to return a Tree_t ptr\n+                          &cascade->tree[treeIdx]\n+\n+                 of course we could return\n+                          cascade->tree + treeIdx;\n+                 *\/\n+\n+                   \/\/ TODO: extra parenthesis to be removed if we have a dialect to express iface memory access\n+                   boolean needExtraParenthesis = OpTk.needExtraParenthesis(invokeOp);\n+                   when(needExtraParenthesis, _ -> oparen());\n+\n+                   if (OpTk.javaReturnType(invokeOp) instanceof ClassType) { \/\/ isAssignable?\n+                       ampersand();\n+                        \/* This is way more complicated I think we need to determine the expression type.\n+                         * sumOfThisStage=sumOfThisStage+&left->anon->value; from    sumOfThisStage += left.anon().value();\n+                         *\/\n+                   }\n+\n+                   recurse(buildContext, instanceResult.op());\n+\n+                   \/\/ TODO: extra parenthesis to be removed if we have a dialect to express iface memory access\n+                   when(needExtraParenthesis, _ -> cparen());\n+\n+                    \/\/ Check if the varOpLoad that could follow corresponds to a local\/private type\n+                    boolean isLocalOrPrivateDS = false;\n+                    if (instanceResult.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n+                        \/\/if (localDataStructures.contains(resolve)) {\n+                        if (resolve instanceof HATMemoryOp) {\n+                            isLocalOrPrivateDS = true;\n+                        }\n+                    }\n+\n+                    either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n+\n+                    funcName(invokeOp);\n+\n+                    if (OpTk.javaReturnTypeIsVoid(invokeOp)) {\n+                        \/\/   setter\n+                        switch (invokeOp.operands().size()) {\n+                            case 2: {\n+                                if (invokeOp.operands().get(1) instanceof Op.Result result1) {\n+                                    equals().recurse(buildContext, result1.op());\n+                                } else {\n+                                    throw new IllegalStateException(\"How \");\n+                                }\n+                                break;\n+                            }\n+                            case 3: {\n+                                if (invokeOp.operands().get(1) instanceof Op.Result result1\n+                                        && invokeOp.operands().get(2) instanceof Op.Result result2) {\n+                                    sbrace(_ -> recurse(buildContext, result1.op()));\n+                                    equals().recurse(buildContext, result2.op());\n+                                } else {\n+                                    throw new IllegalStateException(\"How \");\n+                                }\n+                                break;\n+                            }\n+                            default: {\n+                                throw new IllegalStateException(\"How \");\n+                            }\n+                        }\n+                    } else {\n+                        if (OpTk.resultOrNull(invokeOp,1) instanceof Op.Result result1) {\n+                            sbrace(_ -> recurse(buildContext, result1.op()));\n+                        } else {\n+                            \/\/ This is a simple usage.   So scaleTable->multiScaleAccumRange\n+                        }\n+                    }\n+                } else {\n+                    throw new IllegalStateException(\"[Illegal] Expected a parameter for the InvokOpWrapper Node\");\n+                }\n+            }\n+        } else {\n+            \/\/ General case\n+            funcName(invokeOp).paren(_ ->\n+                    commaSpaceSeparated(invokeOp.operands(),\n+                            op -> {if (op instanceof Op.Result result) {recurse(buildContext, result.op());}\n+                    })\n+            );\n+        }\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public T conditionalExpressionOp(ScopedCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp) {\n+        OpTk.condBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        questionMark();\n+        OpTk.thenBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        colon();\n+        OpTk.elseBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        return self();\n+    }\n+\n+    \/**\n+     * Wrap paren() of precedence of op is higher than parent.\n+     *\n+     * @param buildContext\n+     * @param parent\n+     * @param child\n+     *\/\n+    @Override\n+    public T parenthesisIfNeeded(ScopedCodeBuilderContext buildContext, Op parent, Op child) {\n+        return parenWhen(OpTk.needsParenthesis(parent,child), _ -> recurse(buildContext, child));\n+    }\n+\n+    @Override\n+    public T returnOp(ScopedCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp) {\n+        returnKeyword().when(!returnOp.operands().isEmpty(),\n+                        $-> $.space().parenthesisIfNeeded(buildContext, returnOp, OpTk.result(returnOp).op())\n+                );\n+        return self();\n+    }\n+\n+    public T statement(ScopedCodeBuilderContext buildContext,Op op) {\n+        recurse(buildContext, op);\n+        if (switch (op){\n+                case JavaOp.ForOp _ -> false;\n+                case JavaOp.WhileOp _ -> false;\n+                case JavaOp.IfOp _ -> false;\n+                case JavaOp.LabeledOp _ -> false;\n+                case JavaOp.YieldOp _ -> false;\n+                case CoreOp.TupleOp _ ->false;\n+                default -> true;\n+            }\n+        ){\n+            semicolon();\n+        }\n+        return self();\n+    }\n+\n+\n+\n+    public T declareParam(ScopedCodeBuilderContext buildContext, FuncOpParams.Info param){\n+        return  type(buildContext,(JavaType) param.parameter.type()).space().varName(param.varOp);\n+    }\n+\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":526,"deletions":0,"binary":false,"changes":526,"status":"added"},{"patch":"@@ -30,2 +30,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -33,1 +31,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -35,2 +32,1 @@\n-\n-public abstract class C99HATComputeBuilder<T extends C99HATComputeBuilder<T>> extends HATCodeBuilderWithContext<T> {\n+public abstract class C99HATComputeBuilder<T extends C99HATComputeBuilder<T>> extends C99HATCodeBuilderContext<T> {\n@@ -46,2 +42,3 @@\n-                separated(buildContext.paramTable.list(), (_)->comma().space()\n-                        , param -> declareParam(buildContext, param)\n+                commaSpaceSeparated(\n+                        buildContext.paramTable.list(),\n+                        param -> declareParam(buildContext, param)\n@@ -51,2 +48,6 @@\n-        braceNlIndented(_ -> separated(OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()), (_)->nl(),\n-                statement ->statement(buildContext,statement).nl()));\n+        braceNlIndented(_ ->\n+                nlSeparated(\n+                        OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                        statement ->statement(buildContext,statement).nl()\n+                )\n+        );\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.Op;\n@@ -29,1 +30,1 @@\n-public class C99HATConfigBuilder extends HATCodeBuilder<C99HATConfigBuilder> {\n+public  class C99HATConfigBuilder extends C99HATCodeBuilder<C99HATConfigBuilder> {\n@@ -31,1 +32,1 @@\n-    C99HATConfigBuilder staticConstInt(String name, int padWidth, int value) {\n+   public  C99HATConfigBuilder staticConstInt(String name, int padWidth, int value) {\n@@ -65,1 +66,1 @@\n-    public static String toCamelExceptFirst(String s) {\n+    public  String toCamelExceptFirst(String s) {\n@@ -67,1 +68,1 @@\n-        StringBuilder camelCaseString = new StringBuilder(\"\");\n+        StringBuilder camelCaseString = new StringBuilder();\n@@ -97,0 +98,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATConfigBuilder.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import hat.buffer.F16Array;\n+import hat.dialect.HATBarrierOp;\n@@ -40,0 +42,1 @@\n+import hat.dialect.HATLocalVarOp;\n@@ -41,0 +44,1 @@\n+import hat.dialect.HATMemoryOp;\n@@ -42,0 +46,1 @@\n+import hat.dialect.HATPrivateVarOp;\n@@ -46,0 +51,1 @@\n+import hat.ifacemapper.BoundSchema;\n@@ -47,0 +53,1 @@\n+import hat.ifacemapper.Schema;\n@@ -49,0 +56,1 @@\n+import hat.util.StreamMutable;\n@@ -62,1 +70,1 @@\n-public abstract class C99HATKernelBuilder<T extends C99HATKernelBuilder<T>> extends HATCodeBuilderWithContext<T> {\n+public abstract class C99HATKernelBuilder<T extends C99HATKernelBuilder<T>> extends C99HATCodeBuilderContext<T>implements BabylonKernelOpBuilder<T>  {\n@@ -84,0 +92,105 @@\n+\n+    public final boolean isHalfType(Schema.IfaceType ifaceType) {\n+        return (ifaceType.iface.getName().equals(F16.class.getName())\n+                || ifaceType.iface.getName().equals(F16Array.F16Impl.class.getName()));\n+    }\n+\n+    public final boolean isbfloat16(Schema.IfaceType ifaceType) {\n+        return (ifaceType.iface.getName().equals(BF16.class.getName())\n+                || ifaceType.iface.getName().equals(BF16Array.BF16Impl.class.getName()));\n+    }\n+\n+    public final T typedef(BoundSchema<?> boundSchema, Schema.IfaceType ifaceType) {\n+        typedefKeyword()\n+                .space()\n+                .structOrUnion(ifaceType instanceof Schema.IfaceType.Struct)\n+                .space()\n+                .suffix_s(ifaceType.iface.getSimpleName())\n+                .braceNlIndented(_ -> {\n+                    int fieldCount = ifaceType.fields.size();\n+                    var fieldIdx = StreamMutable.of(0);\n+                    semicolonNlSeparated(\n+                            ifaceType.fields,\n+                            field -> {\n+                        boolean isLast = fieldIdx.get() == fieldCount - 1;\n+                        if (field instanceof Schema.FieldNode.AbstractPrimitiveField primitiveField) {\n+                            if (isHalfType(ifaceType)) {\n+                                typeName(\"half\");\n+                            } else if (isbfloat16(ifaceType)) {\n+                                typeName(\"BFLOAT16\");\n+                            } else {\n+                                typeName(primitiveField.type.getSimpleName());\n+                            }\n+                            space().typeName(primitiveField.name);\n+                            if (primitiveField instanceof Schema.FieldNode.PrimitiveArray array) {\n+                                if (array instanceof Schema.FieldNode.PrimitiveFieldControlledArray fieldControlledArray) {\n+                                    if (isLast && ifaceType.parent == null) {\n+                                        sbrace(_ -> literal(1));\n+                                    } else {\n+                                        boolean[] done = new boolean[]{false};\n+                                        if (boundSchema != null) {\n+                                            boundSchema.boundArrayFields().forEach(a -> {\n+                                                if (a.field.equals(array)) {\n+                                                    sbrace(_ -> literal(a.len));\n+                                                    done[0] = true;\n+                                                }\n+                                            });\n+                                            if (!done[0]) {\n+                                                throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n+                                            }\n+                                        } else {\n+                                            throw new IllegalStateException(\"bound schema is null  !\");\n+                                        }\n+                                    }\n+                                } else if (array instanceof Schema.FieldNode.PrimitiveFixedArray fixed) {\n+                                    sbrace(_ -> literal(Math.max(1, fixed.len)));\n+                                } else {\n+                                    throw new IllegalStateException(\"what kind of array \");\n+                                }\n+                            }\n+                        } else if (field instanceof Schema.FieldNode.AbstractIfaceField ifaceField) {\n+                            suffix_t(ifaceField.ifaceType.iface);\n+                            space().typeName(ifaceField.name);\n+                            if (ifaceField instanceof Schema.FieldNode.IfaceArray array) {\n+                                if (array instanceof Schema.FieldNode.IfaceFieldControlledArray fieldControlledArray) {\n+                                    if (isLast && ifaceType.parent == null) {\n+                                        sbrace(_ -> literal(1));\n+                                    } else {\n+                                        if (boundSchema != null) {\n+                                            boolean[] done = new boolean[]{false};\n+                                            boundSchema.boundArrayFields().forEach(a -> {\n+                                                if (a.field.equals(ifaceField)) {\n+                                                    sbrace(_ -> literal(a.len));\n+                                                    done[0] = true;\n+                                                }\n+                                            });\n+                                            if (!done[0]) {\n+                                                throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n+                                            }\n+                                        } else {\n+                                            throw new IllegalStateException(\"bound schema is null  !\");\n+                                        }\n+                                    }\n+                                } else if (array instanceof Schema.FieldNode.IfaceFixedArray fixed) {\n+                                    sbrace(_ -> literal(Math.max(1, fixed.len)));\n+                                } else {\n+                                    throw new IllegalStateException(\"what kind of array \");\n+                                }\n+                            }\n+                        } else if (field instanceof Schema.SchemaNode.Padding padding) {\n+                            emitText(padding.toC99());\n+                        } else {\n+                            throw new IllegalStateException(\"hmm\");\n+                        }\n+                        fieldIdx.set(fieldIdx.get() + 1);\n+                    });\n+                }).suffix_t(ifaceType.iface).semicolon().nl().nl();\n+        return self();\n+    }\n+\n+     public record LocalArrayDeclaration(ClassType classType, HATMemoryOp varOp) {}\n+\n+\n+    public final T privateDeclaration(LocalArrayDeclaration localArrayDeclaration) {\n+        return suffix_t(localArrayDeclaration.classType()).space().varName(localArrayDeclaration.varOp());\n+    }\n@@ -87,0 +200,6 @@\n+    public final T localDeclaration(LocalArrayDeclaration localArrayDeclaration) {\n+        return localPtrPrefix() \/\/ we should be able to compose-call to privateDeclaration?\n+                .suffix_t(localArrayDeclaration.classType())\n+                .space()\n+                .varName(localArrayDeclaration.varOp());\n+    }\n@@ -88,1 +207,2 @@\n-    public T syncBlockThreads() {\n+    @Override\n+    public T hatBarrierOp(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp) {\n@@ -92,0 +212,11 @@\n+\n+\n+    @Override\n+    public final T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATLocalVarOp hatLocalVarOp) {\n+        return   localDeclaration(new LocalArrayDeclaration(hatLocalVarOp.classType(), hatLocalVarOp));\n+    }\n+\n+    @Override\n+    public final T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATPrivateVarOp hatLocalVarOp) {\n+        return privateDeclaration(new LocalArrayDeclaration(hatLocalVarOp.classType(), hatLocalVarOp));\n+    }\n@@ -95,2 +226,2 @@\n-        return this\n-                .charTypeDefs(\"byte\", \"boolean\").nl()\n+        return charTypeDefs(\"byte\", \"boolean\")\n+                .nl()\n@@ -105,2 +236,1 @@\n-            Object value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n-            literal(value.toString());\n+            literal(OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp).toString());\n@@ -113,10 +243,0 @@\n-    T typedefStructOrUnion(boolean isStruct, Class<?> klass, Consumer<T> consumer) {\n-        return typedefKeyword()\n-                .space()\n-                .structOrUnion(isStruct)\n-                .space()\n-                .either(isStruct, _ -> suffix_s(klass), _ -> suffix_u(klass))\n-                .braceNlIndented(consumer)\n-                .suffix_t(klass).semicolon().nl();\n-    }\n-\n@@ -142,1 +262,0 @@\n-\n@@ -147,1 +266,0 @@\n-              var paramTable = new FuncOpParams(funcOp);\n@@ -149,2 +267,3 @@\n-                    separated(paramTable.list(),(_)->comma().nl(), param ->\n-                        declareParam(buildContext,param)\n+                    commaNlSeparated(\n+                            new FuncOpParams(funcOp).list(),\n+                            param -> declareParam(buildContext,param)\n@@ -155,1 +274,2 @@\n-                separated(OpTk.statements(funcOp.bodies().getFirst().entryBlock()),(_)->nl(),\n+                nlSeparated(\n+                        OpTk.statements(funcOp.bodies().getFirst().entryBlock()),\n@@ -163,1 +283,1 @@\n-    public T kernelEntrypoint(ScopedCodeBuilderContext buildContext, Object... args) {\n+    public T kernelEntrypoint(ScopedCodeBuilderContext buildContext) {\n@@ -165,17 +285,12 @@\n-        buildContext.funcScope(buildContext.funcOp, () -> {\n-            kernelDeclaration(buildContext.funcOp);\n-            \/\/ We skip the first arg which was KernelContext.\n-            var list = buildContext.paramTable.list();\n-            for (int arg = 0; arg < args.length; arg++) {\n-                if (args[arg] instanceof Buffer) {\n-                    list.get(arg).setClass(args[arg].getClass());  \/\/ de we have to do this?\n-                }\n-            }\n-            parenNlIndented(_ -> separated(list.stream(),(_)->comma().nl(),param -> declareParam(buildContext,param)));\n-\n-            braceNlIndented(_ -> {\n-                 separated(OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()), (_)->nl(),\n-                        statement ->statement(buildContext,statement)\n-                );\n-            });\n-        });\n+        buildContext.funcScope(buildContext.funcOp, () ->\n+                kernelDeclaration(buildContext.funcOp)\n+                .parenNlIndented(_ -> commaNlSeparated(\n+                    buildContext.paramTable.list(),\n+                    param -> declareParam(buildContext,param))\n+                )\n+                .braceNlIndented(_ -> nlSeparated(\n+                    OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                    statement ->statement(buildContext,statement)\n+                )\n+            )\n+        );\n@@ -185,8 +300,0 @@\n-    public T privateDeclaration(HATCodeBuilderWithContext.LocalArrayDeclaration localArrayDeclaration) {\n-        return suffix_t(localArrayDeclaration.classType()).space().varName(localArrayDeclaration.varOp());\n-    }\n-\n-    public T localDeclaration(HATCodeBuilderWithContext.LocalArrayDeclaration localArrayDeclaration) {\n-        return localPtrPrefix() \/\/ we should be able to compose-call to privateDeclaration?\n-                .suffix_t(localArrayDeclaration.classType()).space().varName(localArrayDeclaration.varOp());\n-    }\n@@ -196,2 +303,1 @@\n-        globalId(globalThreadIdOp.getDimension());\n-        return self();\n+        return globalId(globalThreadIdOp.getDimension());\n@@ -202,2 +308,1 @@\n-        globalSize(globalSizeOp.getDimension());\n-        return self();\n+        return globalSize(globalSizeOp.getDimension());\n@@ -208,2 +313,1 @@\n-        localId(localThreadIdOp.getDimension());\n-        return self();\n+        return localId(localThreadIdOp.getDimension());\n@@ -214,2 +318,1 @@\n-        localSize(hatLocalSizeOp.getDimension());\n-        return self();\n+        return localSize(hatLocalSizeOp.getDimension());\n@@ -220,2 +323,1 @@\n-        blockId(hatBlockThreadIdOp.getDimension());\n-        return self();\n+        return blockId(hatBlockThreadIdOp.getDimension());\n@@ -235,1 +337,1 @@\n-        switch (id) {\n+        return (switch (id) {\n@@ -240,2 +342,1 @@\n-        }\n-        return self();\n+        });\n@@ -245,1 +346,1 @@\n-        switch (id) {\n+        return (switch (id) {\n@@ -250,2 +351,1 @@\n-        }\n-        return self();\n+        });\n@@ -255,1 +355,1 @@\n-        switch (id) {\n+        return (switch (id) {\n@@ -260,2 +360,1 @@\n-        }\n-        return self();\n+        });\n@@ -266,1 +365,1 @@\n-        switch (id) {\n+        return (switch (id) {\n@@ -271,2 +370,1 @@\n-        }\n-        return self();\n+        });\n@@ -277,2 +375,1 @@\n-        varName(hatVectorVarLoadOp);\n-        return self();\n+        return varName(hatVectorVarLoadOp);\n@@ -283,1 +380,0 @@\n-\n@@ -285,1 +381,1 @@\n-        switch (reducedFloatType) {\n+        return (switch (reducedFloatType) {\n@@ -289,9 +385,7 @@\n-        }\n-\n-        space().identifier(hatF16VarOp.varName())\n-                .space().equals().space();\n-        Value operand = hatF16VarOp.operands().getFirst();\n-        if (operand instanceof Op.Result r) {\n-            recurse(buildContext, r.op());\n-        }\n-        return self();\n+        })\n+                .space()\n+                .identifier(hatF16VarOp.varName())\n+                .space()\n+                .equals()\n+                .space()\n+                .recurse(buildContext, OpTk.asResultOrThrow(hatF16VarOp.operands().getFirst()).op());\n@@ -307,0 +401,3 @@\n+    public final T builtin_float2bfloat16() {\n+        return identifier(\"floatTobfloat16\");\n+    }\n@@ -308,0 +405,3 @@\n+    public final T builtin_bfloat16ToFloat() {\n+        return identifier(\"bfloat16Tofloat\");\n+    }\n@@ -309,15 +409,0 @@\n-        Value op1 = hatf16BinaryOp.operands().get(0);\n-        Value op2 = hatf16BinaryOp.operands().get(1);\n-        List<Boolean> references = hatf16BinaryOp.references();\n-        byte f32Mixed = hatf16BinaryOp.getF32();\n-\n-        oparen().bfloatType()\n-                .cparen().obrace().oparen();\n-\n-        builtin_float2bfloat16()\n-                .oparen();\n-\n-        if (isMixedFirstOperand(f32Mixed) || f32Mixed == 0) {\n-            builtin_bfloat16ToFloat().oparen();\n-        }\n-\n@@ -325,8 +410,1 @@\n-        if (op1 instanceof Op.Result r) {\n-            recurse(buildContext, r.op());\n-        }\n-        if (references.getFirst()) {\n-            rarrow().identifier(\"value\");\n-        } else if (op1 instanceof Op.Result r && !(r.op().resultType() instanceof PrimitiveType)) {\n-            dot().identifier(\"value\");\n-        }\n+        byte f32Mixed = hatf16BinaryOp.getF32();\n@@ -334,4 +412,9 @@\n-        if (isMixedFirstOperand(f32Mixed) || f32Mixed == 0) {\n-            cparen();\n-        }\n-        space().identifier(hatf16BinaryOp.binaryOperationType().symbol()).space();\n+        paren(_->bfloatType());\n+        brace(_-> {\n+            paren(_-> {\n+                builtin_float2bfloat16();\n+                oparen();\n+                if (isMixedFirstOperand(f32Mixed) || f32Mixed == 0) {\n+                    builtin_bfloat16ToFloat().oparen();\/\/ open\n+                }\n+                recurse(buildContext, OpTk.asResultOrThrow(hatf16BinaryOp.operands().get(0)).op());\n@@ -339,3 +422,8 @@\n-        if (isMixedSecondOperand(f32Mixed) || f32Mixed == 0) {\n-            builtin_bfloat16ToFloat().oparen();\n-        }\n+                List<Boolean> references = hatf16BinaryOp.references();\n+                if (references.getFirst()) {\n+                    rarrow().identifier(\"value\");\n+                } else if (hatf16BinaryOp.operands().get(0) instanceof Op.Result r && !(r.op().resultType() instanceof PrimitiveType)) {\n+                    dot().identifier(\"value\");\n+                }else{\n+                    throw new IllegalStateException(\"what happens here 1\");\n+                }\n@@ -343,3 +431,4 @@\n-        if (op2 instanceof Op.Result r) {\n-            recurse(buildContext, r.op());\n-        }\n+                if (isMixedFirstOperand(f32Mixed) || f32Mixed == 0) {\n+                    cparen(); \/\/closed\n+                }\n+                space().identifier(hatf16BinaryOp.binaryOperationType().symbol()).space();\n@@ -347,5 +436,3 @@\n-        if (references.get(1)) {\n-            rarrow().identifier(\"value\");\n-        } else if (op2 instanceof Op.Result r && !(r.op().resultType() instanceof PrimitiveType)) {\n-            dot().identifier(\"value\");\n-        }\n+                if (isMixedSecondOperand(f32Mixed) || f32Mixed == 0) {\n+                    builtin_bfloat16ToFloat().oparen();\n+                }\n@@ -353,1 +440,12 @@\n-        if (isMixedSecondOperand(f32Mixed) || f32Mixed == 0) {\n+                recurse(buildContext, OpTk.asResultOrThrow(hatf16BinaryOp.operands().get(1)).op());\n+                if (references.get(1)) {\n+                    rarrow().identifier(\"value\");\n+                } else if (hatf16BinaryOp.operands().get(1) instanceof Op.Result r && !(r.op().resultType() instanceof PrimitiveType)) {\n+                    dot().identifier(\"value\");\n+                } else{\n+                        throw new IllegalStateException(\"what happens here 2\");\n+                }\n+                if (isMixedSecondOperand(f32Mixed) || f32Mixed == 0) {\n+                    cparen();\n+                }\n+            });\n@@ -355,2 +453,1 @@\n-        }\n-        cparen().cparen().cbrace();\n+        });\n@@ -366,4 +463,0 @@\n-        Value op1 = hatF16BinaryOp.operands().get(0);\n-        Value op2 = hatF16BinaryOp.operands().get(1);\n-        List<Boolean> references = hatF16BinaryOp.references();\n-\n@@ -371,1 +464,1 @@\n-        brace(_-> {\n+        return brace(_->\n@@ -373,4 +466,2 @@\n-                if (op1 instanceof Op.Result r) {\n-                    recurse(buildContext, r.op());\n-                }\n-                if (references.getFirst()) {\n+                recurse(buildContext, OpTk.asResultOrThrow(hatF16BinaryOp.operands().getFirst()).op());\n+                if (hatF16BinaryOp.references().getFirst()) {\n@@ -378,1 +469,1 @@\n-                } else if (op1 instanceof Op.Result r && !(r.op().resultType() instanceof PrimitiveType)) {\n+                } else if (hatF16BinaryOp.operands().getFirst() instanceof Op.Result r2 && !(r2.op().resultType() instanceof PrimitiveType)) {\n@@ -380,0 +471,2 @@\n+                } else {\n+                    blockComment(\"hatF16BinaryOp not a result !!\");\n@@ -382,4 +475,2 @@\n-                if (op2 instanceof Op.Result r) {\n-                    recurse(buildContext, r.op());\n-                }\n-                if (references.get(1)) {\n+                recurse(buildContext, OpTk.asResultOrThrow(hatF16BinaryOp.operands().get(1)).op());\n+                if (hatF16BinaryOp.references().get(1)) {\n@@ -387,1 +478,1 @@\n-                } else if (op2 instanceof Op.Result r && !(r.op().resultType() instanceof PrimitiveType)) {\n+                } else if (hatF16BinaryOp.operands().get(1) instanceof Op.Result r4 && !(r4.op().resultType() instanceof PrimitiveType)) {\n@@ -389,0 +480,2 @@\n+                }else {\n+                    blockComment(\"hatF16BinaryOp not a value !!\");\n@@ -390,3 +483,2 @@\n-            });\n-        });\n-        return self();\n+            })\n+        );\n@@ -402,2 +494,1 @@\n-        identifier(hatVectorMakeOfOp.varName());\n-        return self();\n+        return identifier(hatVectorMakeOfOp.varName());\n@@ -411,5 +502,3 @@\n-                .paren(_->separated(\n-                        hatVectorOp.operands(),\/\/.stream().map(operand->(Op.Result)operand),\n-                        _ -> commaSpace(),\n-                        (operand) -> recurse(buildContext, OpTk.asResultOrThrow(operand).op())\n-                        )\n+                .paren(_->commaSpaceSeparated(\n+                        hatVectorOp.operands(),\n+                        operand -> recurse(buildContext, OpTk.asResultOrThrow(operand).op()))\n@@ -438,0 +527,125 @@\n+\n+    public final T buildStructSingleValueMember(String structName,  String type) {\n+       return typedefStruct(structName,_-> typeName(type).space().identifier(\"value\").semicolonNl());\n+    }\n+\n+    public final T buildForLoopHeader(String loopVar, String init, String loopBound) {\n+        forKeyword().paren(_ -> intType().space().identifier(loopVar).space().equals().identifier(init).semicolon().space()\n+                .identifier(loopVar).lt().identifier(loopBound).semicolon().space()\n+                .identifier(loopVar).plusplus());\n+        return self();\n+    }\n+\n+    \/\/public final T call_builtin_byteCopy(){\n+      \/\/  return identifier(\"\");\n+   \/\/ }\n+\n+    public final T funcDef(Consumer<T> type,Consumer<T> name, Consumer<T> args, Consumer<T> body){\n+         type.accept(self());\n+         space();\n+         name.accept(self());\n+         paren(args);\n+         braceNlIndented(body);\n+         return nl();\n+    }\n+    public final T assign(Consumer<T> lhs,Consumer<T> rhs){\n+        lhs.accept(self());\n+        space().equals().space();\n+        rhs.accept(self());\n+        return semicolonNl();\n+    }\n+    public final T cast(Consumer<T> type){\n+        return paren(_-> type.accept(self()));\n+    }\n+    public final T returnKeyword(Consumer<T> exp){\n+        return returnKeyword().space().paren(_-> exp.accept(self())).semicolon();\n+    }\n+\n+    public final T call(Consumer<T> name,Consumer<T> ...args){\n+        name.accept(self());\n+        return paren(_->commaSpaceSeparated(args));\n+    }\n+    public final T call(String name,Consumer<T> ...args){\n+        return call(_->identifier(name),args);\n+    }\n+\n+    \/**\n+     * <code>\n+     *  void byteCopy(void *dest, const void* src, size_t size) {\n+     *      unsigned char *c = (unsigned char*)dest;\n+     *      unsigned char *s = (unsigned char*)src;\n+     *      for (int i = 0; i < size; i++) {\n+     *          *c++ = *s++;\n+     *      }\n+     *  }\n+     * <\/code>\n+     * @return\n+     *\/\n+\n+    public final T build_builtin_byteCopy() {\n+        return funcDef(\n+                _->voidType(),\n+                _->identifier(\"byteCopy\"),\n+                _->commaSpaceSeparated(\n+                        _-> voidPtrType(\"dest\"),\n+                        _-> voidPtrType(\"src\"),\n+                        _-> size_t(\"size\")\n+                ),\n+                _ ->\n+                   assign(_->u08PtrType(\"c\"), _->cast(_ -> u08PtrType()).identifier(\"dest\"))\n+                   .assign(_->u08PtrType(\"s\"), _->cast(_ -> u08PtrType()).identifier(\"src\"))\n+                   .buildForLoopHeader(\"i\", \"0\", \"size\").braceNlIndented(_ ->\n+                        dereference(\"c\").plusplus().equals().dereference(\"s\").plusplus().semicolon()\n+                   )\n+                );\n+    }\n+\n+    \/**\n+     * <code>\n+     *  float bfloat16Tofloat(ushort bf16) {\n+     *      uint bitsRecovered = bf16 << 16;\n+     *      float r = bitsRecovered;\n+     *      byteCopy(&r, &bitsRecovered, sizeof(r));\n+     *      return r;\n+     * }\n+     * <\/code>\n+     *\n+     * @param parameterName\n+     * @return\n+     *\/\n+    public final T build_builtin_bfloat16ToFloat(String parameterName) {\n+        return funcDef(_->f32Type(),\n+                _->builtin_bfloat16ToFloat(),\n+                _->unsignedShortType(parameterName),\n+                 _ -> assign(_->u32Type(\"bits\"), _->identifier(parameterName).leftShift(16))\n+                      .f32Type(\"r\").semicolonNl()\n+                      .call(\"byteCopy\",_->addressOf(\"r\"),_->addressOf(\"bits\"),_->sizeof(\"r\"))\n+                      .semicolonNl()\n+                      .returnKeyword(_->identifier(\"r\"))\n+                );\n+    }\n+\n+    \/**\n+     * <code>\n+     * ushort floatTobfloat16(float f) {\n+     *      uint bits;\n+     *      byteCopy(&bits, &f, sizeof(bits));\n+     *      short bf16 = bits >> 16;\n+     *      return bf16;\n+     * }\n+     * <\/code>\n+     * @param parameterName\n+     * @return\n+     *\/\n+    public final T build_builtin_float2bfloat16(String parameterName) {\n+        return funcDef(\n+                _->shortType(),\n+                _->builtin_float2bfloat16(),\n+                _->f32Type(parameterName),\n+                _->\n+                   u32Type(\"bits\").semicolonNl()\n+                   .call(\"byteCopy\", _->addressOf(\"bits\"), _->addressOf(parameterName), _->sizeof(\"bits\")).semicolonNl()\n+                   .returnKeyword(_->identifier(\"bits\").rightShift(16))\n+                );\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":362,"deletions":148,"binary":false,"changes":510,"status":"modified"},{"patch":"@@ -289,0 +289,1 @@\n+\n@@ -475,0 +476,27 @@\n+    public <I> T commaSpaceSeparated(Iterable<I> iterable,  Consumer<I> consumer) {\n+        return separated(iterable,_->commaSpace(),consumer);\n+    }\n+    public T commaSpaceSeparated(Consumer<T> ...consumers){\n+        for (int i=0;i<consumers.length;i++){\n+            if (i>0){\n+                commaSpace();\n+            }\n+            consumers[i].accept(self());\n+        }\n+        return self();\n+    }\n+    public <I> T commaSeparated(Iterable<I> iterable,  Consumer<I> consumer) {\n+        return separated(iterable,_->comma(),consumer);\n+    }\n+    public <I> T commaNlSeparated(Iterable<I> iterable,  Consumer<I> consumer) {\n+        return separated(iterable,_->comma().nl(),consumer);\n+    }\n+    public <I> T barSeparated(Iterable<I> iterable,  Consumer<I> consumer) {\n+        return separated(iterable,_->bar(),consumer);\n+    }\n+    public <I> T semicolonNlSeparated(Iterable<I> iterable,  Consumer<I> consumer) {\n+        return separated(iterable,_->semicolonNl(),consumer);\n+    }\n+    public <I> T nlSeparated(Iterable<I> iterable,  Consumer<I> consumer) {\n+        return separated(iterable,_->nl(),consumer);\n+    }\n@@ -487,0 +515,9 @@\n+    public <I> T commaSpaceSeparated(Stream<I> stream,  Consumer<I> consumer) {\n+        return separated(stream,_->commaSpace(),consumer);\n+    }\n+    public <I> T commaSeparated(Stream<I> stream,  Consumer<I> consumer) {\n+        return separated(stream,_->comma(),consumer);\n+    }\n+    public <I> T nlSeparated(Stream<I> stream,  Consumer<I> consumer) {\n+        return separated(stream,_->nl(),consumer);\n+    }\n@@ -520,2 +557,1 @@\n-\n-    public final T floatType() {\n+    public final T f32Type() {\n@@ -524,2 +560,2 @@\n-    public final T floatType(String identifier) {\n-        return floatType().space().identifier(identifier);\n+    public final T f32Type(String identifier) {\n+        return f32Type().space().identifier(identifier);\n@@ -616,1 +652,1 @@\n-        return sizeof(_->paren(_->identifier(identifier)));\n+        return sizeof(_->identifier(identifier));\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilder.java","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -33,4 +33,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-import java.util.Arrays;\n-import java.util.function.Consumer;\n@@ -40,4 +36,0 @@\n-\n-\n-\n-\n@@ -71,23 +63,0 @@\n-    public T suffix_t(String name) {\n-        return identifier(name).identifier(\"_t\");\n-    }\n-\n-    public T suffix_u(String name) {\n-        return identifier(name).identifier(\"_u\");\n-    }\n-\n-    public T suffix_s(String name) {\n-        return identifier(name).identifier(\"_s\");\n-    }\n-\n-    public T suffix_t(Class<?> klass) {\n-        return suffix_t(klass.getSimpleName());\n-    }\n-\n-    public T suffix_u(Class<?> klass) {\n-        return suffix_u(klass.getSimpleName());\n-    }\n-\n-    public T suffix_s(Class<?> klass) {\n-        return suffix_s(klass.getSimpleName());\n-    }\n@@ -100,1 +69,1 @@\n-        return floatType().space().identifier(name);\n+        return f32Type().space().identifier(name);\n@@ -123,54 +92,0 @@\n-    public T structOrUnion(boolean isStruct) {\n-        return (isStruct ? structKeyword() : union());\n-    }\n-\n-\n-    public T typedefKeyword() {\n-        return keyword(\"typedef\");\n-    }\n-\n-\n-    public T structKeyword() {\n-        return keyword(\"struct\");\n-    }\n-\n-    public T union() {\n-        return keyword(\"union\");\n-    }\n-\n-\n-    public T externC() {\n-        return externKeyword().space().dquote(\"C\");\n-    }\n-\n-    public T hashDefineKeyword() {\n-        return hash().keyword(\"define\");\n-    }\n-\n-    public T hashIfdefKeyword() {\n-        return hash().keyword(\"ifdef\");\n-    }\n-\n-    public T hashIfndefKeyword() {\n-        return hash().keyword(\"ifndef\");\n-    }\n-\n-    protected T hashEndif() {\n-        return hash().keyword(\"endif\").nl();\n-    }\n-\n-    protected T hashIfdef(String value) {\n-        return hashIfdefKeyword().space().constant(value).nl();\n-    }\n-\n-    protected T hashIfndef(String value) {\n-        return hashIfndefKeyword().space().constant(value).nl();\n-    }\n-\n-    public T hashIfdef(String value, Consumer<T> consumer) {\n-        return hashIfdef(value).accept(consumer).hashEndif();\n-    }\n-\n-    protected T hashIfndef(String value, Consumer<T> consumer) {\n-        return hashIfndef(value).accept(consumer).hashEndif();\n-    }\n@@ -217,57 +132,0 @@\n-    public T builtin_float2bfloat16() {\n-        identifier(\"floatTobfloat16\");\n-        return self();\n-    }\n-\n-    public T builtin_bfloat16ToFloat() {\n-        identifier(\"bfloat16Tofloat\");\n-        return self();\n-    }\n-\n-    public T pragmaKeyword() {\n-        return keyword(\"pragma\");\n-    }\n-\n-    public T includeKeyword() {\n-        return keyword(\"include\");\n-    }\n-\n-    public T hashDefine(String name, String... values) {\n-        hashDefineKeyword().space().identifier(name);\n-        for (String value : values) {\n-            space().constant(value);\n-        }\n-        return nl();\n-    }\n-\n-    public T hashDefine(String name, Consumer<T> consumer) {\n-        hashDefineKeyword().space().identifier(name);\n-        space();\n-        consumer.accept(self());\n-        return nl();\n-    }\n-\n-    public T pragma(String name, String... values) {\n-        hash().pragmaKeyword().space().identifier(name);\n-        for (String value : values) {\n-            space().constant(value);\n-        }\n-        return nl();\n-    }\n-    public T includeSys(String... values) {\n-        for (String value : values) {\n-            hash().includeKeyword().space().lt().identifier(value).gt().nl();\n-        }\n-        return self();\n-    }\n-    public T include(String... values) {\n-        for (String value : values) {\n-            hash().includeKeyword().space().dquote().identifier(value).dquote().nl();\n-        }\n-        return nl();\n-    }\n-\n-    public T externKeyword() {\n-        return keyword(\"extern\");\n-    }\n-\n@@ -282,86 +140,0 @@\n-    public final T unsignedCharType() {\n-        return typeName(\"unsigned\").space().charType();\n-    }\n-    public final T unsignedCharType(String identifier) {\n-        return unsignedCharType().space().identifier(identifier);\n-    }\n-    public final T unsignedCharPtrType() {\n-        return unsignedCharType().space().asterisk();\n-    }\n-    public final T unsignedCharPtrType(String identifier) {\n-        return unsignedCharPtrType().identifier(identifier);\n-    }\n-\n-    public T charTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> charType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T unsignedCharTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedCharType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T shortTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> shortType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T unsignedShortTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedShortType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T intTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> intType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T unsignedIntTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedIntType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T floatTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> floatType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T longTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> longType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T unsignedLongTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedLongType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T doubleTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> doubleType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    private T typedef(Consumer<T> lhs, Consumer<T> rhs) {\n-        return semicolonNlTerminated(_ -> typedefKeyword().space().accept(lhs).space().accept(rhs));\n-    }\n-\n-    public final T unsignedIntType() {\n-        return typeName(\"unsigned\").space().intType();\n-    }\n-\n-    public final T unsignedIntType(String identifier ) {\n-        return unsignedIntType().space().identifier(identifier);\n-    }\n-\n-    public final T unsignedLongType() {\n-        return typeName(\"unsigned\").space().longType();\n-    }\n-\n-    public final T unsignedShortType() {\n-        return typeName(\"unsigned\").space().shortType();\n-    }\n-    public final T unsignedShortType(String identifier) {\n-        return unsignedShortType().space().identifier(identifier);\n-    }\n-\n@@ -369,1 +141,1 @@\n-    public T declareVarFromJavaType(JavaType type, String varName) {\n+  \/*  public T declareVarFromJavaType(JavaType type, String varName) {\n@@ -380,1 +152,1 @@\n-    }\n+    } *\/\n@@ -421,96 +193,0 @@\n-    public T buildStructSingleMember(String structName, String member, String type) {\n-        typedefKeyword().space().structKeyword().space().suffix_s(structName)\n-                .obrace().nl()\n-                .in()\n-                    .typeName(type).space().typeName(member).semicolon().nl()\n-                .out().cbrace().space().suffix_t(structName).semicolon().nl();\n-        return self();\n-    }\n-\n-    public T buildForLoopHeader(String loopVar, String init, String loopBound) {\n-        forKeyword().paren(_ -> intType().space().identifier(loopVar).space().equals().identifier(init).semicolon().space()\n-                        .identifier(loopVar).lt().identifier(loopBound).semicolon().space()\n-                        .identifier(loopVar).plusplus());\n-        return self();\n-    }\n-\n-    public T builtin_byteCopy(){\n-        return identifier(\"byteCopy\");\n-    }\n-\n-    \/**\n-     * <code>\n-     *  void byteCopy(void *dest, const void* src, size_t size) {\n-     *      unsigned char *c = (unsigned char*)dest;\n-     *      unsigned char *s = (unsigned char*)src;\n-     *      for (int i = 0; i < size; i++) {\n-     *          *c++ = *s++;\n-     *      }\n-     *  }\n-     * <\/code>\n-     * @return\n-     *\/\n-    public T build_builtin_byteCopy() {\n-        voidType().space().builtin_byteCopy()\n-                .paren(_-> voidPtrType(\"dest\").commaSpace().voidPtrType(\"src\").commaSpace().size_t(\"size\"));\n-        braceNlIndented(_ ->\n-                         unsignedCharPtrType(\"c\").equals().paren( _ -> unsignedCharPtrType()).identifier(\"dest\").semicolonNl()\n-                        .unsignedCharPtrType(\"s\").equals().paren( _ -> unsignedCharPtrType()).identifier(\"src\").semicolonNl()\n-                        .buildForLoopHeader(\"i\", \"0\", \"size\").braceNlIndented(_ ->\n-                                         dereference(\"c\").plusplus().equals().dereference(\"s\").plusplus().semicolon()\n-                                 )\n-        );\n-        nl();\n-        return self();\n-    }\n-\n-    \/**\n-     * <code>\n-     *  float bfloat16Tofloat(ushort bf16) {\n-     *      uint bitsRecovered = bf16 << 16;\n-     *      float r = bitsRecovered;\n-     *      byteCopy(&r, &bitsRecovered, sizeof(r));\n-     *      return r;\n-     * }\n-     * <\/code>\n-     *\n-     * @param parameterName\n-     * @return\n-     *\/\n-    public T build_builtin_bfloat16ToFloat(String parameterName) {\n-        floatType().space().builtin_bfloat16ToFloat().paren(_ -> unsignedShortType(parameterName))\n-                .brace( _ ->\n-                        nl()\n-                        .unsignedIntType(\"bits\").equals().identifier(parameterName).leftShift(16).semicolonNl()\n-                        .floatType(\"r\").equals().identifier(\"bits\").semicolonNl()\n-                        .builtin_byteCopy().paren(_ -> addressOf(\"r\").commaSpace().addressOf(\"bits\").comma().sizeof(\"r\")).semicolonNl()\n-                        .returnKeyword(\"r\").semicolonNl()\n-                );\n-        nl();\n-        return self();\n-    }\n-\n-    \/**\n-     * <code>\n-     * ushort floatTobfloat16(float f) {\n-     *      uint bits;\n-     *      byteCopy(&bits, &f, sizeof(bits));\n-     *      short bf16 = bits >> 16;\n-     *      return bf16;\n-     * }\n-     * <\/code>\n-     * @param parameterName\n-     * @return\n-     *\/\n-    public T build_builtin_float2bfloat16(String parameterName) {\n-        shortType().space().builtin_float2bfloat16().paren(_ -> floatType().space().identifier(parameterName))\n-                .brace( _ -> nl()\n-                        .unsignedIntType(\"bits\").semicolonNl()\n-                        .builtin_byteCopy().paren(_ ->\n-                                addressOf(\"bits\").commaSpace().addressOf(parameterName).commaSpace().sizeof(\"bits\")).semicolonNl()\n-                                .shortType(\"bf16\").equals().identifier(\"bits\").rightShift(16).semicolonNl()\n-                                .returnKeyword(\"bf16\").semicolonNl()\n-                );\n-        nl();\n-        return self();\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":3,"deletions":327,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -1,655 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.buffer.BF16;\n-import hat.buffer.BF16Array;\n-import hat.buffer.F16;\n-import hat.buffer.F16Array;\n-import hat.buffer.HAType;\n-import hat.device.DeviceType;\n-import hat.dialect.*;\n-import hat.ifacemapper.BoundSchema;\n-import hat.ifacemapper.MappableIface;\n-import hat.ifacemapper.Schema;\n-import hat.optools.FuncOpParams;\n-import hat.optools.OpTk;\n-import hat.util.StreamMutable;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-import java.util.List;\n-\n-public abstract class HATCodeBuilderWithContext<T extends HATCodeBuilderWithContext<T>> extends HATCodeBuilder<T> implements BabylonOpBuilder<T> {\n-\n-    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n-        if (OpTk.isAssignable(buildContext.lookup, javaType, MappableIface.class)\n-                        && javaType instanceof ClassType classType) {\n-            suffix_t(classType).asterisk();\n-        } else {\n-            typeName(javaType.toBasicType().toString());\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n-        switch (resolve) {\n-            case CoreOp.VarOp $ -> varName($);\n-            case HATMemoryOp $ -> varName($);\n-            case HATVectorVarOp $ -> varName($);\n-            case HATVectorLoadOp $ -> varName($);\n-            case HATVectorBinaryOp $ -> varName($);\n-            case HATF16VarOp $ -> varName($);\n-            case null, default -> {\n-            }\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp) {\n-        Op op = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n-        \/\/ When the op is intended to operate as VarOp, then we need to include it in the following switch.\n-        \/\/ This is because HAT has its own dialect, and some of the Ops operate on HAT Types (not included in the Java\n-        \/\/ dialect). For instance, private data structures, local data structures, vector types, etc.\n-        switch (op) {\n-            case CoreOp.VarOp varOp -> varName(varOp).equals();\n-            case HATF16VarOp hatf16VarOp -> varName(hatf16VarOp).equals();\n-            case HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp).equals();\n-            case HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp).equals();\n-            case HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp).equals();\n-            case HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp).equals();\n-            case null, default -> {\n-            }\n-        }\n-        parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n-        return self();\n-    }\n-\n-    public record LocalArrayDeclaration(ClassType classType, HATMemoryOp varOp) {}\n-\n-    private void varDeclarationWithInitialization(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n-        if (buildContext.isVarOpFinal(varOp)) {\n-            constKeyword().space();\n-        }\n-        type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp).space().equals().space();\n-        parenthesisIfNeeded(buildContext, varOp, ((Op.Result)varOp.operands().getFirst()).op());\n-    }\n-\n-    @Override\n-    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n-        if (varOp.isUninitialized()) {\n-            type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp);\n-        } else {\n-            varDeclarationWithInitialization(buildContext, varOp);\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATLocalVarOp hatLocalVarOp) {\n-        LocalArrayDeclaration localArrayDeclaration = new LocalArrayDeclaration(hatLocalVarOp.classType(), hatLocalVarOp);\n-        localDeclaration(localArrayDeclaration);\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATPrivateVarOp hatLocalVarOp) {\n-        LocalArrayDeclaration localArrayDeclaration = new LocalArrayDeclaration(hatLocalVarOp.classType(), hatLocalVarOp);\n-        privateDeclaration(localArrayDeclaration);\n-        return self();\n-    }\n-\n-    @Override\n-    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, OpTk.ParamVar paramVar) {\n-        return self();\n-    }\n-\n-    @Override\n-    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n-            Object value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n-            literal(value.toString());\n-        } else {\n-            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOp);\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T fieldStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp) {\n-        return self();\n-    }\n-\n-\n-    @Override\n-    public T unaryOp(ScopedCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp) {\n-        symbol(unaryOp).parenthesisIfNeeded(buildContext, unaryOp, ((Op.Result)unaryOp.operands().getFirst()).op());\n-        return self();\n-    }\n-\n-    @Override\n-    public T binaryOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp) {\n-        parenthesisIfNeeded(buildContext, binaryOp, OpTk.lhsResult(binaryOp).op());\n-        symbol(binaryOp);\n-        parenthesisIfNeeded(buildContext, binaryOp, OpTk.rhsResult(binaryOp).op());\n-        return self();\n-    }\n-\n-\n-    @Override\n-    public T conditionalOp(ScopedCodeBuilderContext buildContext, JavaOp.JavaConditionalOp logicalOp) {\n-        OpTk.lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n-        space().symbol(logicalOp).space();\n-        OpTk.rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n-        return self();\n-    }\n-\n-    @Override\n-    public T binaryTestOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp) {\n-        parenthesisIfNeeded(buildContext, binaryTestOp, OpTk.lhsResult(binaryTestOp).op());\n-        symbol(binaryTestOp);\n-        parenthesisIfNeeded(buildContext, binaryTestOp, OpTk.rhsResult(binaryTestOp).op());\n-        return self();\n-    }\n-\n-    @Override\n-    public T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n-        if (convOp.resultType() == JavaType.DOUBLE) {\n-            paren(_ -> type(buildContext,JavaType.FLOAT)); \/\/ why double to float?\n-        } else {\n-            paren(_ -> type(buildContext,(JavaType)convOp.resultType()));\n-        }\n-        parenthesisIfNeeded(buildContext, convOp, OpTk.result(convOp).op());\n-        return self();\n-    }\n-\n-    @Override\n-    public T constantOp(ScopedCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp) {\n-        if (constantOp.value() == null) {\n-            nullConst();\n-        } else {\n-            literal(constantOp.value().toString());\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T yieldOp(ScopedCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp) {\n-        if (yieldOp.operands().getFirst() instanceof Op.Result result) {\n-            recurse(buildContext, result.op());\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp) {\n-        return comment(\"\/*LAMBDA*\/\");\n-    }\n-\n-    @Override\n-    public T tupleOp(ScopedCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp) {\n-        separated(tupleOp.operands(),(_)->commaSpace(),operand->{\n-            if (operand instanceof Op.Result result) {\n-                recurse(buildContext, result.op());\n-            } else {\n-                comment(\"\/*nothing to tuple*\/\");\n-            }\n-        });\n-        return self();\n-    }\n-\n-    @Override\n-    public T funcCallOp(ScopedCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp) {\n-        funcName(funcCallOp);\n-        paren(_ ->\n-            separated(funcCallOp.operands().stream()\n-                    .filter(e->e instanceof Op.Result ).map(e->(Op.Result)e),(_)->commaSpace(), result ->\n-                     recurse(buildContext,result.op())\n-            )\n-        );\n-        return self();\n-    }\n-\n-    @Override\n-    public T labeledOp(ScopedCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp) {\n-        var labelNameOp = labeledOp.bodies().getFirst().entryBlock().ops().getFirst();\n-        CoreOp.ConstantOp constantOp = (CoreOp.ConstantOp) labelNameOp;\n-        literal(constantOp.value().toString()).colon().nl();\n-        var forLoopOp = labeledOp.bodies().getFirst().entryBlock().ops().get(1);\n-        recurse(buildContext,forLoopOp);\n-        return self();\n-    }\n-\n-    public T breakOp(ScopedCodeBuilderContext buildContext, JavaOp.BreakOp breakOp) {\n-        breakKeyword();\n-        if (!breakOp.operands().isEmpty() && breakOp.operands().getFirst() instanceof Op.Result result) {\n-            space();\n-            if (result.op() instanceof CoreOp.ConstantOp c) {\n-                literal(c.value().toString());\n-            }\n-        }\n-        return self();\n-    }\n-\n-    public T continueOp(ScopedCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp) {\n-        if (!continueOp.operands().isEmpty()\n-                && continueOp.operands().getFirst() instanceof Op.Result result\n-                && result.op() instanceof CoreOp.ConstantOp c\n-        ) {\n-            continueKeyword().space().literal(c.value().toString());\n-        } else if (buildContext.scope.parent instanceof ScopedCodeBuilderContext.ForScope) {\n-            \/\/ nope\n-        } else {\n-            continueKeyword();\n-        }\n-\n-        return self();\n-    }\n-\n-    @Override\n-    public T ifOp(ScopedCodeBuilderContext buildContext, JavaOp.IfOp ifOp) {\n-        buildContext.ifScope(ifOp, () -> {\n-            var lastWasBody = StreamMutable.of(false);\n-            var i = StreamMutable.of(0);\n-            \/\/ We probably should just use a regular for loop here ;)\n-            ifOp.bodies().forEach(b->{\n-                int idx = i.get();\n-                if (b.yieldType() instanceof JavaType javaType && javaType == JavaType.VOID) {\n-                    if (ifOp.bodies().size() > idx && ifOp.bodies().get(idx).entryBlock().ops().size() > 1){\n-                        if (lastWasBody.get()) {\n-                            elseKeyword();\n-                        }\n-                        braceNlIndented(_ ->\n-                                separated(OpTk.statements(ifOp.bodies().get(idx).entryBlock()),(_)->nl(), root->\n-                                        statement(buildContext,root)\n-                                )\n-                        );\n-                    }\n-                    lastWasBody.set(true);\n-                } else {\n-                    if (idx>0) {\n-                        elseKeyword().space();\n-                    }\n-                    ifKeyword().paren(_ ->\n-                            ifOp.bodies().get(idx).entryBlock()            \/\/ get the entryblock if bodies[c.value]\n-                                    .ops().stream().filter(o->o instanceof CoreOp.YieldOp) \/\/ we want all the yields\n-                                    .forEach((yield) -> recurse(buildContext, yield))\n-                    );\n-                    lastWasBody.set(false);\n-                }\n-                i.set(i.get()+1);\n-            });\n-        });\n-        return self();\n-    }\n-\n-    @Override\n-    public T whileOp(ScopedCodeBuilderContext buildContext, JavaOp.WhileOp whileOp) {\n-        whileKeyword().paren(_ ->\n-                OpTk.condBlock(whileOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n-                        .forEach(o -> recurse(buildContext, o))\n-        );\n-        braceNlIndented(_ ->\n-                separated(OpTk.statements(whileOp),(_)->nl(), statement->statement(buildContext,statement)\n-                       \/\/ recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n-                )\n-        );\n-        return self();\n-    }\n-\n-    @Override\n-    public T forOp(ScopedCodeBuilderContext buildContext, JavaOp.ForOp forOp) {\n-        buildContext.forScope(forOp, () ->\n-                forKeyword().paren(_ -> {\n-                    OpTk.initBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-                    semicolon().space();\n-                    OpTk.condBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-                    semicolon().space();\n-                    separated(OpTk.statements(OpTk.mutateBlock(forOp)), (_)->commaSpace(),\n-                            op -> recurse(buildContext, op)\n-                    );\n-                }).braceNlIndented(_ ->\n-                        separated(OpTk.statements(forOp), (_)->nl(),statement ->statement(buildContext,statement)\n-                              \/\/  root-> recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n-                        )\n-                )\n-        );\n-        return self();\n-    }\n-\n-    private boolean isHalfType(Schema.IfaceType ifaceType) {\n-        return (ifaceType.iface.getName().equals(F16.class.getName())\n-                || ifaceType.iface.getName().equals(F16Array.F16Impl.class.getName()));\n-    }\n-\n-    private boolean isbfloat16(Schema.IfaceType ifaceType) {\n-        return (ifaceType.iface.getName().equals(BF16.class.getName())\n-                || ifaceType.iface.getName().equals(BF16Array.BF16Impl.class.getName()));\n-    }\n-\n-    public T typedef(BoundSchema<?> boundSchema, Schema.IfaceType ifaceType) {\n-        typedefKeyword().space().structOrUnion(ifaceType instanceof Schema.IfaceType.Struct)\n-                .space().suffix_s(ifaceType.iface.getSimpleName()).braceNlIndented(_ -> {\n-                    int fieldCount = ifaceType.fields.size();\n-                    var fieldIdx = StreamMutable.of(0);\n-                    separated(ifaceType.fields, (_) -> semicolon().nl(), field -> {\n-                        boolean isLast = fieldIdx.get() == fieldCount - 1;\n-                        if (field instanceof Schema.FieldNode.AbstractPrimitiveField primitiveField) {\n-                            if (isHalfType(ifaceType)) {\n-                                typeName(\"half\");\n-                            } else if (isbfloat16(ifaceType)) {\n-                                typeName(\"BFLOAT16\");\n-                            } else {\n-                                typeName(primitiveField.type.getSimpleName());\n-                            }\n-                            space().typeName(primitiveField.name);\n-                            if (primitiveField instanceof Schema.FieldNode.PrimitiveArray array) {\n-                                if (array instanceof Schema.FieldNode.PrimitiveFieldControlledArray fieldControlledArray) {\n-                                    if (isLast && ifaceType.parent == null) {\n-                                        sbrace(_ -> literal(1));\n-                                    } else {\n-                                        boolean[] done = new boolean[]{false};\n-                                        if (boundSchema != null) {\n-                                            boundSchema.boundArrayFields().forEach(a -> {\n-                                                if (a.field.equals(array)) {\n-                                                    sbrace(_ -> literal(a.len));\n-                                                    done[0] = true;\n-                                                }\n-                                            });\n-                                            if (!done[0]) {\n-                                                throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n-                                            }\n-                                        } else {\n-                                            throw new IllegalStateException(\"bound schema is null  !\");\n-                                        }\n-                                    }\n-                                } else if (array instanceof Schema.FieldNode.PrimitiveFixedArray fixed) {\n-                                    sbrace(_ -> literal(Math.max(1, fixed.len)));\n-                                } else {\n-                                    throw new IllegalStateException(\"what kind of array \");\n-                                }\n-                            }\n-                        } else if (field instanceof Schema.FieldNode.AbstractIfaceField ifaceField) {\n-                            suffix_t(ifaceField.ifaceType.iface);\n-                            space().typeName(ifaceField.name);\n-                            if (ifaceField instanceof Schema.FieldNode.IfaceArray array) {\n-                                if (array instanceof Schema.FieldNode.IfaceFieldControlledArray fieldControlledArray) {\n-                                    if (isLast && ifaceType.parent == null) {\n-                                        sbrace(_ -> literal(1));\n-                                    } else {\n-                                        if (boundSchema != null) {\n-                                            boolean[] done = new boolean[]{false};\n-                                            boundSchema.boundArrayFields().forEach(a -> {\n-                                                if (a.field.equals(ifaceField)) {\n-                                                    sbrace(_ -> literal(a.len));\n-                                                    done[0] = true;\n-                                                }\n-                                            });\n-                                            if (!done[0]) {\n-                                                throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n-                                            }\n-                                        } else {\n-                                            throw new IllegalStateException(\"bound schema is null  !\");\n-                                        }\n-                                    }\n-                                } else if (array instanceof Schema.FieldNode.IfaceFixedArray fixed) {\n-                                    sbrace(_ -> literal(Math.max(1, fixed.len)));\n-                                } else {\n-                                    throw new IllegalStateException(\"what kind of array \");\n-                                }\n-                            }\n-                        } else if (field instanceof Schema.SchemaNode.Padding padding) {\n-                            emitText(padding.toC99());\n-                        } else {\n-                            throw new IllegalStateException(\"hmm\");\n-                        }\n-                        fieldIdx.set(fieldIdx.get() + 1);\n-                    });\n-                }).suffix_t(ifaceType.iface).semicolon().nl().nl();\n-        return self();\n-    }\n-\n-    public T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n-        throw new IllegalStateException(\"atomicInc not implemented\");\n-    }\n-\n-    @Override\n-    public T barrier(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp) {\n-        return syncBlockThreads();\n-    }\n-\n-    @Override\n-    public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n-        if (OpTk.isIfaceBufferMethod(buildContext.lookup, invokeOp)\n-                || OpTk.isInvokeDescriptorSubtypeOfAnyMatch(invokeOp, List.of(HAType.class, DeviceType.class))) {\n-            if (invokeOp.operands().size() == 1\n-                    && OpTk.funcName(invokeOp) instanceof String funcName\n-                    && funcName.startsWith(\"atomic\")\n-                    && funcName.endsWith(\"Inc\")\n-                    && OpTk.javaReturnType(invokeOp).equals(JavaType.INT)) {\n-                \/\/ this is a bit of a hack for atomics.\n-                if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n-                    atomicInc(buildContext, instanceResult, funcName.substring(0, funcName.length() - \"Inc\".length()));\n-                } else {\n-                    throw new IllegalStateException(\"bad atomic\");\n-                }\n-            } else {\n-\n-               if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n-                \/*\n-                We have three types of returned values from an ifaceBuffer\n-                A primitive\n-                    int id = stage.firstTreeId(); -> stage->firstTreeId;\n-\n-                Or a sub interface from an array\n-                     Tree tree = cascade.tree(treeIdx); -> Tree_t * tree = &cascade->tree[treeIdx]\n-                                                        ->               = cascade->tree + treeIdx;\n-\n-                Or a sub interface from a field\n-\n-                var left = feature.left();              ->  LinkOrValue_t * left= &feature->left\n-\n-                                -\n-                    if (left.hasValue()) {                  left->hasValue\n-                        sum += left.anon().value();         left->anon.value;\n-                        feature = null; \/\/ loop ends\n-                    } else {\n-                        feature = cascade.feature(tree.firstFeatureId() + left.anon().featureId());\n-                    }\n-                 sumOfThisStage += left.anon().value();\n-\n-\n-                For a primitive we know that the accessor refers to a field so we just  map\n-                         stage.firstTreeId() -> stage->firstTreeId;\n-\n-                For the sub interface we need to treat the call\n-                          cascade.tree(treeIdx);\n-\n-                As an array index into cascade->tree[] that returns a typedef of Tree_t\n-                so we need to prefix with an & to return a Tree_t ptr\n-                          &cascade->tree[treeIdx]\n-\n-                 of course we could return\n-                          cascade->tree + treeIdx;\n-                 *\/\n-\n-                   \/\/ TODO: extra parenthesis to be removed if we have a dialect to express iface memory access\n-                   boolean needExtraParenthesis = OpTk.needExtraParenthesis(invokeOp);\n-                   when(needExtraParenthesis, _ -> oparen());\n-\n-                   if (OpTk.javaReturnType(invokeOp) instanceof ClassType) { \/\/ isAssignable?\n-                       ampersand();\n-                        \/* This is way more complicated I think we need to determine the expression type.\n-                         * sumOfThisStage=sumOfThisStage+&left->anon->value; from    sumOfThisStage += left.anon().value();\n-                         *\/\n-                   }\n-\n-                   recurse(buildContext, instanceResult.op());\n-\n-                   \/\/ TODO: extra parenthesis to be removed if we have a dialect to express iface memory access\n-                   when(needExtraParenthesis, _ -> cparen());\n-\n-                    \/\/ Check if the varOpLoad that could follow corresponds to a local\/private type\n-                    boolean isLocalOrPrivateDS = false;\n-                    if (instanceResult.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n-                        \/\/if (localDataStructures.contains(resolve)) {\n-                        if (resolve instanceof HATMemoryOp) {\n-                            isLocalOrPrivateDS = true;\n-                        }\n-                    }\n-\n-                    either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n-\n-                    funcName(invokeOp);\n-\n-                    if (OpTk.javaReturnTypeIsVoid(invokeOp)) {\n-                        \/\/   setter\n-                        switch (invokeOp.operands().size()) {\n-                            case 2: {\n-                                if (invokeOp.operands().get(1) instanceof Op.Result result1) {\n-                                    equals().recurse(buildContext, result1.op());\n-                                } else {\n-                                    throw new IllegalStateException(\"How \");\n-                                }\n-                                break;\n-                            }\n-                            case 3: {\n-                                if (invokeOp.operands().get(1) instanceof Op.Result result1\n-                                        && invokeOp.operands().get(2) instanceof Op.Result result2) {\n-                                    sbrace(_ -> recurse(buildContext, result1.op()));\n-                                    equals().recurse(buildContext, result2.op());\n-                                } else {\n-                                    throw new IllegalStateException(\"How \");\n-                                }\n-                                break;\n-                            }\n-                            default: {\n-                                throw new IllegalStateException(\"How \");\n-                            }\n-                        }\n-                    } else {\n-                        if (OpTk.resultOrNull(invokeOp,1) instanceof Op.Result result1) {\n-                            sbrace(_ -> recurse(buildContext, result1.op()));\n-                        } else {\n-                            \/\/ This is a simple usage.   So scaleTable->multiScaleAccumRange\n-                        }\n-                    }\n-                } else {\n-                    throw new IllegalStateException(\"[Illegal] Expected a parameter for the InvokOpWrapper Node\");\n-                }\n-            }\n-        } else {\n-            \/\/ General case\n-            funcName(invokeOp).paren(_ ->\n-                    separated(invokeOp.operands(), ($) -> $.comma().space(), (op) -> {\n-                        if (op instanceof Op.Result result) {\n-                            recurse(buildContext, result.op());\n-                        }\n-                    })\n-            );\n-        }\n-        return self();\n-    }\n-\n-\n-\n-    public abstract T privateDeclaration(LocalArrayDeclaration localArrayDeclaration);\n-\n-    public abstract T localDeclaration(LocalArrayDeclaration localArrayDeclaration);\n-\n-    public abstract T syncBlockThreads();\n-\n-    @Override\n-    public T conditionalExpressionOp(ScopedCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp) {\n-        OpTk.condBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-        questionMark();\n-        OpTk.thenBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-        colon();\n-        OpTk.elseBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-        return self();\n-    }\n-\n-    \/**\n-     * Wrap paren() of precedence of op is higher than parent.\n-     *\n-     * @param buildContext\n-     * @param parent\n-     * @param child\n-     *\/\n-    @Override\n-    public T parenthesisIfNeeded(ScopedCodeBuilderContext buildContext, Op parent, Op child) {\n-        return parenWhen(OpTk.needsParenthesis(parent,child), _ -> recurse(buildContext, child));\n-    }\n-\n-    @Override\n-    public T returnOp(ScopedCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp) {\n-        returnKeyword().when(!returnOp.operands().isEmpty(),\n-                        $-> $.space().parenthesisIfNeeded(buildContext, returnOp, OpTk.result(returnOp).op())\n-                );\n-        return self();\n-    }\n-\n-    public T statement(ScopedCodeBuilderContext buildContext,Op op) {\n-        recurse(buildContext, op);\n-        if (switch (op){\n-                case JavaOp.ForOp _ -> false;\n-                case JavaOp.WhileOp _ -> false;\n-                case JavaOp.IfOp _ -> false;\n-                case JavaOp.LabeledOp _ -> false;\n-                case JavaOp.YieldOp _ -> false;\n-                case CoreOp.TupleOp _ ->false;\n-                default -> true;\n-            }\n-        ){\n-            semicolon();\n-        }\n-        return self();\n-    }\n-\n-    public T suffix_t(ClassType type){\n-        String name = type.toClassName();\n-        int dotIdx = name.lastIndexOf('.');\n-        int dollarIdx = name.lastIndexOf('$');\n-        int idx = Math.max(dotIdx, dollarIdx);\n-        if (idx > 0) {\n-            name = name.substring(idx + 1);\n-        }\n-        return suffix_t(name);\n-    }\n-\n-    public T declareParam(ScopedCodeBuilderContext buildContext, FuncOpParams.Info param){\n-        return  type(buildContext,(JavaType) param.parameter.type()).space().varName(param.varOp);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":0,"deletions":655,"binary":false,"changes":655,"status":"deleted"},{"patch":"@@ -129,1 +129,1 @@\n-        return emitText(text);\n+        return emitText(buf.toString());\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/TextBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.codebuilders.C99CodeBuilder;\n+import hat.codebuilders.C99HATCodeBuilder;\n@@ -45,1 +45,1 @@\n-    private final C99CodeBuilder representationBuilder = new C99CodeBuilder<>();\n+    private final C99HATCodeBuilder<?> representationBuilder = new C99HATCodeBuilder<>();\n@@ -107,1 +107,1 @@\n-    private void materialize(C99CodeBuilder builder, Class<?> klass) {\n+    private void materialize(C99HATCodeBuilder<?> builder, Class<?> klass) {\n@@ -126,1 +126,2 @@\n-                            C99CodeBuilder depsBuilder = new C99CodeBuilder<>(builder.getText());\n+                            C99HATCodeBuilder<?> depsBuilder = new C99HATCodeBuilder<>();\n+                            depsBuilder.preformatted(builder.getText());\n","filename":"hat\/core\/src\/main\/java\/hat\/device\/DeviceSchema.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.codebuilders.BabylonCoreOpBuilder;\n+import hat.codebuilders.C99HATCodeBuilderContext;\n@@ -28,22 +30,1 @@\n-import hat.codebuilders.HATCodeBuilderWithContext;\n-import hat.dialect.HATBlockThreadIdOp;\n-import hat.dialect.HATF16BinaryOp;\n-import hat.dialect.HATF16ConvOp;\n-import hat.dialect.HATF16ToFloatConvOp;\n-import hat.dialect.HATF16VarLoadOp;\n-import hat.dialect.HATF16VarOp;\n-import hat.dialect.HATGlobalSizeOp;\n-import hat.dialect.HATGlobalThreadIdOp;\n-import hat.dialect.HATLocalSizeOp;\n-import hat.dialect.HATLocalThreadIdOp;\n-import hat.dialect.HATMemoryLoadOp;\n-import hat.dialect.HATPrivateInitVarOp;\n-import hat.dialect.HATVectorBinaryOp;\n-import hat.dialect.HATVectorLoadOp;\n-import hat.dialect.HATVectorMakeOfOp;\n-import hat.dialect.HATVectorOfOp;\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorSelectStoreOp;\n-import hat.dialect.HATVectorStoreView;\n-import hat.dialect.HATVectorVarLoadOp;\n-import hat.dialect.HATVectorVarOp;\n+\n@@ -56,1 +37,2 @@\n-public class JavaHATCodeBuilder<T extends JavaHATCodeBuilder<T>> extends HATCodeBuilderWithContext<T> {\n+public class JavaHATCodeBuilder<T extends JavaHATCodeBuilder<T>> extends C99HATCodeBuilderContext<T> implements BabylonCoreOpBuilder<T> {\n+\n@@ -60,6 +42,1 @@\n-            try {\n-                typeName(javaType.resolve(buildContext.lookup).getTypeName());\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        return self();\n+        return null;\n@@ -68,1 +45,0 @@\n-\n@@ -82,0 +58,5 @@\n+    @Override\n+    public T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n+        return null;\n+    }\n+\n@@ -90,1 +71,1 @@\n-            separated(  invokeOp.operands().subList(0,invokeOp.operands().size()-1), (_)->commaSpace(),o->\n+            commaSpaceSeparated(  invokeOp.operands().subList(0,invokeOp.operands().size()-1), o->\n@@ -97,89 +78,0 @@\n-    @Override\n-    public T privateDeclaration(LocalArrayDeclaration localArrayDeclaration) {\n-        blockComment(\"\/* private declaration !! *\/\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T localDeclaration(LocalArrayDeclaration localArrayDeclaration) {\n-        blockComment(\"\/* local declaration !! *\/\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T syncBlockThreads() {\n-        blockComment(\"\/* group wide barrier!! *\/\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp globalThreadIdOp) {\n-        blockInlineComment(\"Thread ID access\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATGlobalSizeOp hatGlobalThreadIdOp) {\n-        blockInlineComment(\"GlobalSize\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATLocalThreadIdOp hatLocalThreadIdOp) {\n-        blockInlineComment(\"Local Thread ID\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATLocalSizeOp hatLocalSizeOp) {\n-        blockInlineComment(\"Local Size\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATBlockThreadIdOp hatBlockThreadIdOp) {\n-        blockInlineComment(\"Block ID \");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n-        blockComment(\"Vector Variable Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n-        blockComment(\"Store Vector Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n-        blockComment(\"Binary Vector Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n-        blockComment(\"Load Vector Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n-        blockComment(\"Select Vector Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n-        blockComment(\"Select Vector Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp) {\n-        blockComment(\"Vector Variable Not Implemented\");\n-        return self();\n-    }\n@@ -187,53 +79,0 @@\n-    @Override\n-    public T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16VarOp hatF16VarOp) {\n-        blockComment(\"F16 Variable Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatF16BinaryOp) {\n-        blockComment(\"Binary F16 Op Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16VarLoadOp hatF16VarLoadOp) {\n-        blockComment(\"F16 Load Op Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n-        blockComment(\"F16 Conv Op Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOfOp hatVectorOp) {\n-        blockComment(\"Vector Of Ops Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatVectorMakeOf(ScopedCodeBuilderContext builderContext, HATVectorMakeOfOp hatVectorMakeOfOp) {\n-        blockComment(\"Vector Make Of Op Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatF16ToFloatConvOp(ScopedCodeBuilderContext builderContext, HATF16ToFloatConvOp hatF16ToFloatConvOp) {\n-        blockComment(\"Float Conv Op Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatPrivateVarInitOp(ScopedCodeBuilderContext builderContext, HATPrivateInitVarOp hatPrivateInitVarOp) {\n-        blockComment(\"Private Var Init Op Not Implemented\");\n-        return self();\n-    }\n-\n-    @Override\n-    public T hatMemoryLoadOp(ScopedCodeBuilderContext builderContext, HATMemoryLoadOp hatMemoryLoadOp) {\n-        blockComment(\"Memory Load Op Not Implemented\");\n-        return self();\n-    }\n@@ -244,4 +83,10 @@\n-            parenNlIndented(_ -> separated(buildContext.paramTable.list(), (_) -> comma().nl(),\n-                    param -> declareParam(buildContext, param)));\n-            braceNlIndented(_ -> separated(OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()), (_) -> nl(),\n-                    statement -> statement(buildContext, statement))\n+            parenNlIndented(_ ->\n+                    commaNlSeparated(\n+                            buildContext.paramTable.list(),\n+                            param -> declareParam(buildContext, param)\n+                    )\n+            );\n+            braceNlIndented(_ -> nlSeparated(\n+                    OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                    statement -> statement(buildContext, statement)\n+                    )\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":22,"deletions":177,"binary":false,"changes":199,"status":"modified"}]}