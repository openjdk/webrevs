{"files":[{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.reflect.code.op.ExtendedOps;\n@@ -41,0 +40,1 @@\n+import java.util.stream.Collectors;\n@@ -556,0 +556,5 @@\n+        } else if (o instanceof CoreOps.ConcatOp) {\n+            return o.operands().stream()\n+                    .map(oc::getValue)\n+                    .map(String::valueOf)\n+                    .collect(Collectors.joining());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2357,0 +2357,33 @@\n+    \/**\n+     * The String Concatenation Operation\n+     *\/\n+\n+    @OpDeclaration(ConcatOp.NAME)\n+    public static final class ConcatOp extends OpWithDefinition implements Op.Pure {\n+        public static final String NAME = \"concat\";\n+\n+        public ConcatOp(ConcatOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        public ConcatOp(OpDefinition def) {\n+            super(def);\n+            if(def.operands().size() != 2) {\n+                throw new IllegalArgumentException(\"Concatenation Operation must have two operands.\");\n+            }\n+        }\n+\n+        public ConcatOp(Value lhs, Value rhs) {\n+            super(ConcatOp.NAME, List.of(lhs,rhs));\n+        }\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new ConcatOp(this, cc);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.J_L_STRING;\n+        }\n+    }\n+\n@@ -3732,0 +3765,9 @@\n+\n+    \/**\n+     * Creates a string concatenation operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the string concatenation operation\n+     *\/\n+    public static ConcatOp concat(Value lhs, Value rhs) { return new ConcatOp(lhs, rhs); }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import com.sun.tools.javac.jvm.ByteCodes;\n@@ -2057,1 +2058,11 @@\n-            } else {\n+            } else if (tag == Tag.PLUS && tree.operator.opcode == ByteCodes.string_add) {\n+                \/\/Ignore the operator and query both subexpressions for their type with concats\n+                Type lhsType = tree.lhs.type;\n+                Type rhsType = tree.rhs.type;\n+\n+                Value lhs = toValue(tree.lhs, lhsType);\n+                Value rhs = toValue(tree.rhs, rhsType);\n+\n+                result = append(CoreOps.concat(lhs, rhs));\n+            }\n+            else {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestConcat\n+ *\/\n+\n+public class TestConcat {\n+\n+    static final String TESTSTR = \"TESTING STRING\";\n+\n+    static final int TESTINT = 42;\n+    @CodeReflection\n+    static String f() {\n+       int test = 1;\n+       \/\/String res = TESTINT + TESTSTR + test;\n+       String res = \"HI \" + TESTSTR + test;\n+       return res;\n+    }\n+\n+\n+    @CodeReflection\n+    public static String byteConcat1(byte b, String s) {\n+       return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String byteConcat2(String s, byte b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String shortConcat1(short b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String shortConcat2(String s, short b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String intConcat1(int b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String intConcat2(String s, int b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String longConcat1(long b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String longConcat2(String s, long b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String floatConcat1(float b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String floatConcat2(String s, float b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String doubleConcat1(double b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String doubleConcat2(String s, double b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String booleanConcat1(boolean b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String booleanConcat2(String s, boolean b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String charConcat1(char b, String s) {\n+        return b + s;\n+    }\n+    @CodeReflection\n+    public static String charConcat2(String s, char b) {\n+        return s + b;\n+    }\n+    @CodeReflection\n+    public static String objectConcat1(Object b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String objectConcat2(String s, Object b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String objectConcat3(TestObject b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String objectConcat4(String s, TestObject b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String stringConcat(String b, String s) {\n+        return b + s;\n+    }\n+\n+\n+    record Triple(Class<?> first, Class<?> second, String third) {\n+    }\n+\n+    static final Map<Class<?>, Object> valMap;\n+    static {\n+        valMap = new HashMap<>();\n+        valMap.put(byte.class, (byte) 42);\n+        valMap.put(short.class, (short) 42);\n+        valMap.put(int.class, 42);\n+        valMap.put(long.class, (long) 42);\n+        valMap.put(float.class, 42f);\n+        valMap.put(double.class, 42d);\n+        valMap.put(char.class, 'z');\n+        valMap.put(boolean.class, false);\n+        valMap.put(Object.class, new Object() {\n+                    @Override\n+                    public String toString() {\n+                        return \"I'm a test string.\";\n+                    }\n+                });\n+        valMap.put(TestObject.class, new TestObject());\n+        valMap.put(String.class, TESTSTR);\n+    }\n+    private static String testName(Class<?> n, Integer i){\n+        return n.getSimpleName().toLowerCase() + \"Concat\" + i;\n+    }\n+    @DataProvider(name = \"testData\")\n+    public static Object[][]  testData() {\n+        Set<Class<?>> types = Set.of(byte.class, short.class, int.class, long.class, float.class,\n+                double.class, char.class, boolean.class, Object.class);\n+\n+\n+\n+        \/\/Types from types concatenated to strings left-to-right and right-to-left\n+        Stream<Triple> s1 = types.stream().map(t -> new Triple(t,String.class, testName(t, 1)));\n+        Stream<Triple> s2 = types.stream().map(t -> new Triple(String.class, t, testName(t, 2)));\n+\n+        \/\/Custom Object and basic string concat tests\n+        Stream<Triple> s3 = Stream.of(new Triple(TestObject.class, String.class, testName(Object.class, 3)),\n+                                      new Triple(String.class, TestObject.class, testName(Object.class, 4)),\n+                                      new Triple(String.class, String.class, \"stringConcat\"));\n+\n+        Object[] t = Stream.concat(Stream.concat(s1,s2),s3).toArray();\n+\n+        Object[][] args = new Object[t.length][];\n+\n+        for(int i = 0; i < args.length; i++) {\n+            args[i] = new Object[]{ t[i] };\n+        }\n+\n+        return args;\n+\n+    }\n+\n+    @Test(dataProvider = \"testData\")\n+    public static void testRun(Triple t) {\n+        try {\n+\n+            Object[] args = new Object[] {valMap.get(t.first), valMap.get(t.second)};\n+            Class<TestConcat> clazz = TestConcat.class;\n+            Method method = clazz.getDeclaredMethod(t.third, t.first, t.second);\n+            CoreOps.FuncOp f = method.getCodeModel().orElseThrow();\n+            var res1 = Interpreter.invoke(MethodHandles.lookup(), f, args);\n+            var res2 = method.invoke(null, args);\n+\n+            Assert.assertEquals(res1, res2);\n+\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static final class TestObject {\n+        TestObject(){}\n+\n+        @Override\n+        public String toString() {\n+            return \"TestObject String\";\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConcat.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"}]}