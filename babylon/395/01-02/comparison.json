{"files":[{"patch":"@@ -30,4 +30,2 @@\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.type.*;\n+\n@@ -54,1 +52,1 @@\n-                Op.Result builder = block.apply(CoreOp._new(FunctionType.functionType(J_L_STRING_BUILDER)));\n+                Op.Result builder = block.apply(CoreOp._new(ConstructorRef.constructor(J_L_STRING_BUILDER)));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/StringConcatTransformer.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-            case NewOp op when !(op.constructorType().returnType() instanceof ArrayType) ->\n+            case NewOp op when !(op.constructorDescriptor().type().returnType() instanceof ArrayType) ->\n@@ -747,1 +747,1 @@\n-                        switch (op.constructorType().returnType()) {\n+                        switch (op.constructorDescriptor().type().returnType()) {\n@@ -768,1 +768,1 @@\n-                                        MethodRef.toNominalDescriptor(op.constructorType())\n+                                        MethodRef.toNominalDescriptor(op.constructorDescriptor().type())\n@@ -773,1 +773,1 @@\n-                                                                    + op.constructorType().returnType());\n+                                                                    + op.constructorDescriptor().type().returnType());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.type.*;\n@@ -58,6 +59,1 @@\n-import jdk.incubator.code.type.FieldRef;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.PrimitiveType;\n-import jdk.incubator.code.type.VarType;\n+\n@@ -438,1 +434,1 @@\n-                                        FunctionType.functionType(\n+                                        ConstructorRef.constructor(\n@@ -591,1 +587,1 @@\n-                            FunctionType.functionType(\n+                            ConstructorRef.constructor(\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeLift.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-                        resolveTo(ut, no.constructorType().parameterTypes().get(i));\n+                        resolveTo(ut, no.constructorDescriptor().type().parameterTypes().get(i));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/UnresolvedTypesTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-                    setVarargs(nc, newOp.constructorType());\n+                    setVarargs(nc, newOp.constructorDescriptor().type());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1529,1 +1529,1 @@\n-                FunctionType constructorType = FunctionType.functionType(arrayType,\n+                ConstructorRef constructorRef = ConstructorRef.constructor(arrayType,\n@@ -1531,1 +1531,1 @@\n-                result = append(CoreOp._new(arrayType, constructorType, indexes));\n+                result = append(CoreOp._new(constructorRef, indexes));\n@@ -1727,1 +1727,1 @@\n-                        append(CoreOp._new(FunctionType.functionType(JavaType.type(MatchException.class))))\n+                        append(CoreOp._new(ConstructorRef.constructor(MatchException.class)))\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1683,9 +1683,0 @@\n-        NewOp(boolean isVarArgs, FunctionType constructorType, List<Value> args) {\n-            this(isVarArgs, constructorType.returnType(), constructorType, args);\n-        }\n-\n-        NewOp(boolean isVarArgs, TypeElement resultType, FunctionType constructorType, List<Value> args) {\n-            this(isVarArgs, resultType,\n-                    ConstructorRef.constructor(constructorType), args);\n-        }\n-\n@@ -1722,4 +1713,0 @@\n-        public FunctionType constructorType() {\n-            return constructorDescriptor.type();\n-        }\n-\n@@ -3879,1 +3866,1 @@\n-     * @param constructorType the constructor type\n+     * @param constructorDescriptor the constructor descriptor\n@@ -3883,2 +3870,2 @@\n-    public static NewOp _new(FunctionType constructorType, Value... args) {\n-        return _new(constructorType, List.of(args));\n+    public static NewOp _new(ConstructorRef constructorDescriptor, Value... args) {\n+        return _new(constructorDescriptor, List.of(args));\n@@ -3890,1 +3877,1 @@\n-     * @param constructorType the constructor type\n+     * @param constructorDescriptor the constructor descriptor\n@@ -3894,2 +3881,2 @@\n-    public static NewOp _new(FunctionType constructorType, List<Value> args) {\n-        return new NewOp(false, constructorType, args);\n+    public static NewOp _new(ConstructorRef constructorDescriptor, List<Value> args) {\n+        return new NewOp(false, constructorDescriptor.refType(), constructorDescriptor, args);\n@@ -3902,1 +3889,1 @@\n-     * @param constructorType the constructor type\n+     * @param constructorDescriptor the constructor descriptor\n@@ -3906,1 +3893,1 @@\n-    public static NewOp _new(TypeElement returnType, FunctionType constructorType,\n+    public static NewOp _new(TypeElement returnType, ConstructorRef constructorDescriptor,\n@@ -3908,1 +3895,1 @@\n-        return _new(returnType, constructorType, List.of(args));\n+        return _new(returnType, constructorDescriptor, List.of(args));\n@@ -3915,1 +3902,1 @@\n-     * @param constructorType the constructor type\n+     * @param constructorDescriptor the constructor descriptor\n@@ -3919,1 +3906,1 @@\n-    public static NewOp _new(TypeElement returnType, FunctionType constructorType,\n+    public static NewOp _new(TypeElement returnType, ConstructorRef constructorDescriptor,\n@@ -3921,1 +3908,1 @@\n-        return new NewOp(false, returnType, constructorType, args);\n+        return new NewOp(false, returnType, constructorDescriptor, args);\n@@ -3945,1 +3932,2 @@\n-        return _new(FunctionType.functionType(arrayType, JavaType.INT), length);\n+        ConstructorRef constructorDescriptor = ConstructorRef.constructor(arrayType, JavaType.INT);\n+        return _new(constructorDescriptor, length);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":14,"deletions":26,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -946,1 +946,1 @@\n-                        throwBlock.op(_new(FunctionType.functionType(JavaType.type(NullPointerException.class))))\n+                        throwBlock.op(_new(ConstructorRef.constructor(NullPointerException.class)))\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/ExtendedOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,3 @@\n-    TypeElement refType();\n+    default TypeElement refType() {\n+        return type().returnType();\n+    }\n@@ -63,2 +65,2 @@\n-    static ConstructorRef constructor(Class<?> refType, MethodType mt) {\n-        return constructor(refType, mt.parameterList());\n+    static ConstructorRef constructor(MethodType mt) {\n+        return constructor(mt.returnType(), mt.parameterList());\n@@ -79,0 +81,4 @@\n+    static ConstructorRef constructor(TypeElement refType, TypeElement... params) {\n+        return constructor(functionType(refType, params));\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/ConstructorRef.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-        return builder.op(_new(EXTERNALIZED_OP_F_TYPE, args));\n+        return builder.op(_new(ConstructorRef.constructor(EXTERNALIZED_OP_F_TYPE), args));\n@@ -364,1 +364,2 @@\n-            Value map = builder.op(_new(mapType, functionType(J_U_HASH_MAP)));\n+            ConstructorRef constructorRef = ConstructorRef.constructor(HashMap.class);\n+            Value map = builder.op(_new(mapType, constructorRef));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/OpBuilder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.*;\n-import org.junit.Test;\n-\n-import java.io.PrintStream;\n-import java.lang.invoke.MethodType;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestAddVarsWhenNecessary\n- *\/\n-public class TestAddVarsWhenNecessary {\n-\n-    static final MethodRef MAP_PUT = MethodRef.method(Map.class, \"put\",\n-            MethodType.methodType(Object.class, Object.class, Object.class));\n-    static final JavaType MAP = JavaType.type(Map.class.describeConstable().get());\n-    static final JavaType HASH_MAP = JavaType.type(HashMap.class.describeConstable().get());\n-    static CoreOp.FuncOp f() {\n-        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(MAP));\n-        Block.Builder block = body.entryBlock();\n-        Op.Result map = block.op(CoreOp._new(\n-                JavaType.parameterized(MAP, JavaType.J_L_INTEGER, JavaType.J_L_INTEGER),\n-                FunctionType.functionType(HASH_MAP)));\n-        Op.Result c1 = block.op(CoreOp.constant(JavaType.INT, 1));\n-        Op.Result c2 = block.op(CoreOp.constant(JavaType.INT, 2));\n-        block.op(CoreOp.invoke(MAP_PUT, map, c1, c2));\n-        block.op(CoreOp._return(map));\n-        return CoreOp.func(\"f\", body);\n-    }\n-    static CoreOp.FuncOp g() {\n-        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(JavaType.INT));\n-        Block.Builder block = body.entryBlock();\n-        Op.Result var = block.op(CoreOp.var(block.op(CoreOp.constant(JavaType.INT, 1))));\n-        block.op(CoreOp.varStore(var, block.op(CoreOp.constant(JavaType.INT, 2))));\n-        block.op(CoreOp._return(block.op(CoreOp.varLoad(var))));\n-        return CoreOp.func(\"g\", body);\n-    }\n-\n-    static final MethodRef PRINT_INT = MethodRef.method(PrintStream.class, \"print\",\n-            MethodType.methodType(Void.class, int.class));\n-\n-    static CoreOp.FuncOp h() {\n-        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(JavaType.INT, JavaType.INT));\n-        Block.Builder block = body.entryBlock();\n-        Block.Parameter p = block.parameters().get(0);\n-        \/\/ @@@ do we need the type to construct a FieldRef ??\n-        Op.Result sout = block.op(CoreOp.fieldLoad(FieldRef.field(System.class, \"out\", PrintStream.class)));\n-        block.op(CoreOp.invoke(PRINT_INT, sout, p));\n-        block.op(CoreOp._return(p));\n-        return CoreOp.func(\"h\", body);\n-    }\n-\n-    @Test\n-    public void test() {\n-        CoreOp.FuncOp f = f();\n-        f.writeTo(System.out);\n-\n-        f = addVarsWhenNecessary(f);\n-        f.writeTo(System.out);\n-    }\n-\n-    @Test\n-    public void test2() {\n-        CoreOp.FuncOp g = g();\n-        g.writeTo(System.out);\n-\n-        g = addVarsWhenNecessary(g);\n-        g.writeTo(System.out);\n-    }\n-\n-    @Test\n-    public void test3() {\n-        CoreOp.FuncOp h = h();\n-        h.writeTo(System.out);\n-\n-        h = addVarsWhenNecessary(h);\n-        h.writeTo(System.out);\n-    }\n-\n-    public static CoreOp.FuncOp addVarsWhenNecessary(CoreOp.FuncOp funcOp) {\n-        \/\/ using cc only is not possible\n-        \/\/ because at first opr --> varOpRes\n-        \/\/ at the first usage we would have to opr --> varLoad\n-        \/\/ meaning we would have to back up the mapping, update it, then restore it before transforming the next op\n-\n-        Map<Value, CoreOp.VarOp> valueToVar = new HashMap<>();\n-\n-        return CoreOp.func(funcOp.funcName(), funcOp.body().bodyType()).body(block -> {\n-            var newParams = block.parameters();\n-            var oldParams = funcOp.parameters();\n-            for (int i = 0; i < newParams.size(); i++) {\n-                Op.Result var = block.op(CoreOp.var(newParams.get(i)));\n-                valueToVar.put(oldParams.get(i), ((CoreOp.VarOp) var.op()));\n-            }\n-\n-            block.transformBody(funcOp.body(), List.of(), (Block.Builder b, Op op) -> {\n-                var cc = b.context();\n-                for (Value operand : op.operands()) {\n-                    if (valueToVar.containsKey(operand)) {\n-                        var varLoadRes = b.op(CoreOp.varLoad(valueToVar.get(operand).result()));\n-                        cc.mapValue(operand, varLoadRes);\n-                    }\n-                }\n-                var opr = b.op(op);\n-                if (!(op instanceof CoreOp.VarOp) && op.result().uses().size() > 1) {\n-                    var varOpRes = b.op(CoreOp.var(opr));\n-                    valueToVar.put(op.result(), ((CoreOp.VarOp) varOpRes.op()));\n-                }\n-                return b;\n-            });\n-        });\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestAddVarsWhenNecessary.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"}]}