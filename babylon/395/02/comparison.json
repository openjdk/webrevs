{"files":[{"patch":"@@ -30,4 +30,2 @@\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.type.*;\n+\n@@ -54,1 +52,1 @@\n-                Op.Result builder = block.apply(CoreOp._new(FunctionType.functionType(J_L_STRING_BUILDER)));\n+                Op.Result builder = block.apply(CoreOp._new(ConstructorRef.constructor(J_L_STRING_BUILDER)));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/StringConcatTransformer.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-            case NewOp op when !(op.constructorType().returnType() instanceof ArrayType) ->\n+            case NewOp op when !(op.constructorDescriptor().type().returnType() instanceof ArrayType) ->\n@@ -747,1 +747,1 @@\n-                        switch (op.constructorType().returnType()) {\n+                        switch (op.constructorDescriptor().type().returnType()) {\n@@ -768,1 +768,1 @@\n-                                        MethodRef.toNominalDescriptor(op.constructorType())\n+                                        MethodRef.toNominalDescriptor(op.constructorDescriptor().type())\n@@ -773,1 +773,1 @@\n-                                                                    + op.constructorType().returnType());\n+                                                                    + op.constructorDescriptor().type().returnType());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.type.*;\n@@ -58,6 +59,1 @@\n-import jdk.incubator.code.type.FieldRef;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.PrimitiveType;\n-import jdk.incubator.code.type.VarType;\n+\n@@ -438,1 +434,1 @@\n-                                        FunctionType.functionType(\n+                                        ConstructorRef.constructor(\n@@ -591,1 +587,1 @@\n-                            FunctionType.functionType(\n+                            ConstructorRef.constructor(\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeLift.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-                        resolveTo(ut, no.constructorType().parameterTypes().get(i));\n+                        resolveTo(ut, no.constructorDescriptor().type().parameterTypes().get(i));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/UnresolvedTypesTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,0 +10,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.TreeInfo;\n@@ -83,6 +85,1 @@\n-            var lastParam = invokeOp.invokeDescriptor().type().parameterTypes().getLast();\n-            if (lastParam instanceof ArrayType varargType) {\n-                methodInvocation.varargsElement = typeElementToType(varargType.componentType());\n-            } else {\n-                Assert.error(\"Vararg method doesn't have a trailing array type: \" + invokeOp.invokeDescriptor());\n-            }\n+            setVarargs(methodInvocation, invokeOp.invokeDescriptor().type());\n@@ -93,0 +90,9 @@\n+    void setVarargs(JCExpression tree, FunctionType type) {\n+        var lastParam = type.parameterTypes().getLast();\n+        if (lastParam instanceof ArrayType varargType) {\n+            TreeInfo.setVarargsElement(tree, typeElementToType(varargType.componentType()));\n+        } else {\n+            Assert.error(\"Expected trailing array type: \" + type);\n+        }\n+    }\n+\n@@ -99,10 +105,5 @@\n-            case CoreOp.NewOp newOp -> {\n-                if (newOp.resultType() instanceof ArrayType at) {\n-                    var elemType = treeMaker.Ident(typeElementToType(at.componentType()).tsym);\n-                    var dims = new ListBuffer<JCTree.JCExpression>();\n-                    for (int d = 0; d < at.dimensions(); d++) {\n-                        dims.add(exprTree(newOp.operands().get(d)));\n-                    }\n-                    var na = treeMaker.NewArray(elemType, dims.toList(), null);\n-                    na.type = typeElementToType(at);\n-                    yield na;\n+            case CoreOp.NewOp newOp when newOp.resultType() instanceof ArrayType at -> {\n+                var elemType = treeMaker.Ident(typeElementToType(at.componentType()).tsym);\n+                var dims = new ListBuffer<JCTree.JCExpression>();\n+                for (int d = 0; d < at.dimensions(); d++) {\n+                    dims.add(exprTree(newOp.operands().get(d)));\n@@ -110,1 +111,6 @@\n-                var ownerType = typeElementToType(newOp.constructorType().returnType());\n+                var na = treeMaker.NewArray(elemType, dims.toList(), null);\n+                na.type = typeElementToType(at);\n+                yield na;\n+            }\n+            case CoreOp.NewOp newOp -> {\n+                var ownerType = typeElementToType(newOp.constructorDescriptor().refType());\n@@ -117,3 +123,2 @@\n-                var argTypes = new ListBuffer<Type>();\n-                for (Value operand : newOp.operands()) {\n-                    argTypes.add(typeElementToType(operand.type()));\n+                if (newOp.isVarargs()) {\n+                    setVarargs(nc, newOp.constructorDescriptor().type());\n@@ -122,3 +127,2 @@\n-                \/\/ TODO: this should be fixed to use a MethodRef in the new op (once that is added)\n-                nc.constructorType = new Type.MethodType(argTypes.toList(), syms.voidType, List.nil(), syms.methodClass);\n-                nc.constructor = new Symbol.MethodSymbol(PUBLIC, names.init, nc.constructorType, ownerType.tsym);\n+                nc.constructor = constructorDescriptorToSymbol(newOp.constructorDescriptor());\n+                nc.constructorType = nc.constructor.type;\n@@ -212,0 +216,7 @@\n+    MethodSymbol constructorDescriptorToSymbol(ConstructorRef constructorRef) {\n+        Type site = typeElementToType(constructorRef.refType());\n+        List<Type> argtypes = constructorRef.type().parameterTypes().stream()\n+                .map(this::typeElementToType).collect(List.collector());\n+        return resolve.resolveInternalConstructor(attrEnv.enclClass, attrEnv, site, argtypes, List.nil());\n+    }\n+\n@@ -214,2 +225,0 @@\n-    \/\/ TODO: fix NewOp to contain MethodRef of constructor\n-    \/\/ TODO: share method and constructor code\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":34,"deletions":25,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1489,1 +1489,3 @@\n-            \/\/ @@@ require symbol site type?\n+            \/\/ We need to manually construct the constructor reference,\n+            \/\/ as the signature of the constructor symbol is not augmented\n+            \/\/ with enclosing this and captured params.\n@@ -1495,0 +1497,1 @@\n+            ConstructorRef constructorRef = ConstructorRef.constructor(constructorType);\n@@ -1498,1 +1501,1 @@\n-            result = append(CoreOp._new(typeToTypeElement(type), constructorType, args));\n+            result = append(CoreOp._new(tree.varargsElement != null, typeToTypeElement(type), constructorRef, args));\n@@ -1526,1 +1529,1 @@\n-                FunctionType constructorType = FunctionType.functionType(arrayType,\n+                ConstructorRef constructorRef = ConstructorRef.constructor(arrayType,\n@@ -1528,1 +1531,1 @@\n-                result = append(CoreOp._new(arrayType, constructorType, indexes));\n+                result = append(CoreOp._new(constructorRef, indexes));\n@@ -1724,1 +1727,1 @@\n-                        append(CoreOp._new(FunctionType.functionType(JavaType.type(MatchException.class))))\n+                        append(CoreOp._new(ConstructorRef.constructor(MatchException.class)))\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,5 +35,1 @@\n-import jdk.incubator.code.type.ArrayType;\n-import jdk.incubator.code.type.FieldRef;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.*;\n@@ -41,1 +37,1 @@\n-import jdk.incubator.code.type.VarType;\n+\n@@ -45,1 +41,0 @@\n-import java.util.stream.Stream;\n@@ -464,14 +459,2 @@\n-            JavaType nType = (JavaType) no.constructorType().returnType();\n-            if (nType instanceof ArrayType at) {\n-                if (values.length > at.dimensions()) {\n-                    throw interpreterException(new IllegalArgumentException(\"Bad constructor NewOp: \" + no));\n-                }\n-                int[] lengths = Stream.of(values).mapToInt(v -> (int) v).toArray();\n-                for (int length : lengths) {\n-                    nType = ((ArrayType)nType).componentType();\n-                }\n-                return Array.newInstance(resolveToClass(l, nType), lengths);\n-            } else {\n-                MethodHandle mh = constructorHandle(l, no.constructorType());\n-                return invoke(mh, values);\n-            }\n+            MethodHandle mh = resolveToConstructorHandle(l, no.constructorDescriptor());\n+            return invoke(mh, values);\n@@ -669,17 +652,0 @@\n-    static MethodHandle constructorHandle(MethodHandles.Lookup l, FunctionType ft) {\n-        MethodType mt = resolveToMethodType(l, ft);\n-\n-        if (mt.returnType().isArray()) {\n-            if (mt.parameterCount() != 1 || mt.parameterType(0) != int.class) {\n-                throw interpreterException(new IllegalArgumentException(\"Bad constructor descriptor: \" + ft));\n-            }\n-            return MethodHandles.arrayConstructor(mt.returnType());\n-        } else {\n-            try {\n-                return l.findConstructor(mt.returnType(), mt.changeReturnType(void.class));\n-            } catch (NoSuchMethodException | IllegalAccessException e) {\n-                throw interpreterException(e);\n-            }\n-        }\n-    }\n-\n@@ -712,0 +678,8 @@\n+    static MethodHandle resolveToConstructorHandle(MethodHandles.Lookup l, ConstructorRef d) {\n+        try {\n+            return d.resolveToHandle(l);\n+        } catch (ReflectiveOperationException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":12,"deletions":38,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.op.CoreOp.InvokeOp.InvokeKind;\n@@ -1620,0 +1621,1 @@\n+\n@@ -1622,0 +1624,1 @@\n+        public static final String ATTRIBUTE_NEW_VARARGS = NAME + \".varargs\";\n@@ -1623,1 +1626,2 @@\n-        final FunctionType constructorType;\n+        final boolean isVarArgs;\n+        final ConstructorRef constructorDescriptor;\n@@ -1627,12 +1631,7 @@\n-            FunctionType constructorType = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR, true,\n-                    v -> switch (v) {\n-                        case String s -> {\n-                            TypeElement te = CoreTypeFactory.CORE_TYPE_FACTORY\n-                                    .constructType(TypeElement.ExternalizedTypeElement.ofString(s));\n-                            if (!(te instanceof FunctionType ft)) {\n-                                throw new UnsupportedOperationException(\"Unsupported new descriptor value:\" + v);\n-                            }\n-                            yield ft;\n-                        }\n-                        case FunctionType ct -> ct;\n-                        case null, default -> throw new UnsupportedOperationException(\"Unsupported new descriptor value:\" + v);\n+            \/\/ Required attribute\n+            ConstructorRef constructorDescriptor = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR,\n+                    true, v -> switch (v) {\n+                        case String s -> ConstructorRef.ofString(s);\n+                        case ConstructorRef cd -> cd;\n+                        case null, default ->\n+                                throw new UnsupportedOperationException(\"Unsupported constructor descriptor value:\" + v);\n@@ -1640,1 +1639,10 @@\n-            return new NewOp(def, constructorType);\n+\n+            \/\/ If not present defaults to false\n+            boolean isVarArgs = def.extractAttributeValue(ATTRIBUTE_NEW_VARARGS,\n+                    false, v -> switch (v) {\n+                        case String s -> Boolean.valueOf(s);\n+                        case Boolean b -> b;\n+                        case null, default -> false;\n+                    });\n+\n+            return new NewOp(def, isVarArgs, constructorDescriptor);\n@@ -1643,1 +1651,1 @@\n-        NewOp(ExternalizedOp def, FunctionType constructorType) {\n+        NewOp(ExternalizedOp def, boolean isVarArgs, ConstructorRef constructorDescriptor) {\n@@ -1646,1 +1654,4 @@\n-            this.constructorType = constructorType;\n+            validateArgCount(isVarArgs, constructorDescriptor, def.operands());\n+\n+            this.isVarArgs = isVarArgs;\n+            this.constructorDescriptor = constructorDescriptor;\n@@ -1653,1 +1664,2 @@\n-            this.constructorType = that.constructorType;\n+            this.isVarArgs = that.isVarArgs;\n+            this.constructorDescriptor = that.constructorDescriptor;\n@@ -1657,0 +1669,9 @@\n+        static void validateArgCount(boolean isVarArgs, ConstructorRef constructorDescriptor, List<Value> operands) {\n+            int paramCount = constructorDescriptor.type().parameterTypes().size();\n+            int argCount = operands.size();\n+            if ((!isVarArgs && argCount != paramCount)\n+                    || argCount < paramCount - 1) {\n+                throw new IllegalArgumentException(isVarArgs + \" \" + constructorDescriptor);\n+            }\n+        }\n+\n@@ -1662,5 +1683,1 @@\n-        NewOp(FunctionType constructorType, List<Value> args) {\n-            this(constructorType.returnType(), constructorType, args);\n-        }\n-\n-        NewOp(TypeElement resultType, FunctionType constructorType, List<Value> args) {\n+        NewOp(boolean isVarargs, TypeElement resultType, ConstructorRef constructorDescriptor, List<Value> args) {\n@@ -1669,1 +1686,2 @@\n-            this.constructorType = constructorType;\n+            this.isVarArgs = isVarargs;\n+            this.constructorDescriptor = constructorDescriptor;\n@@ -1676,1 +1694,4 @@\n-            m.put(\"\", constructorType);\n+            m.put(\"\", constructorDescriptor);\n+            if (isVarArgs) {\n+                m.put(ATTRIBUTE_NEW_VARARGS, isVarArgs);\n+            }\n@@ -1680,0 +1701,4 @@\n+        public boolean isVarargs() {\n+            return isVarArgs;\n+        }\n+\n@@ -1682,1 +1707,1 @@\n-        }\n+        } \/\/ @@@ duplication, same as resultType()\n@@ -1684,2 +1709,2 @@\n-        public FunctionType constructorType() {\n-            return constructorType;\n+        public ConstructorRef constructorDescriptor() {\n+            return constructorDescriptor;\n@@ -3841,1 +3866,1 @@\n-     * @param constructorType the constructor type\n+     * @param constructorDescriptor the constructor descriptor\n@@ -3845,2 +3870,2 @@\n-    public static NewOp _new(FunctionType constructorType, Value... args) {\n-        return _new(constructorType, List.of(args));\n+    public static NewOp _new(ConstructorRef constructorDescriptor, Value... args) {\n+        return _new(constructorDescriptor, List.of(args));\n@@ -3852,1 +3877,1 @@\n-     * @param constructorType the constructor type\n+     * @param constructorDescriptor the constructor descriptor\n@@ -3856,2 +3881,2 @@\n-    public static NewOp _new(FunctionType constructorType, List<Value> args) {\n-        return new NewOp(constructorType, args);\n+    public static NewOp _new(ConstructorRef constructorDescriptor, List<Value> args) {\n+        return new NewOp(false, constructorDescriptor.refType(), constructorDescriptor, args);\n@@ -3864,1 +3889,1 @@\n-     * @param constructorType the constructor type\n+     * @param constructorDescriptor the constructor descriptor\n@@ -3868,1 +3893,1 @@\n-    public static NewOp _new(TypeElement returnType, FunctionType constructorType,\n+    public static NewOp _new(TypeElement returnType, ConstructorRef constructorDescriptor,\n@@ -3870,1 +3895,14 @@\n-        return _new(returnType, constructorType, List.of(args));\n+        return _new(returnType, constructorDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param returnType      the instance type\n+     * @param constructorDescriptor the constructor descriptor\n+     * @param args            the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(TypeElement returnType, ConstructorRef constructorDescriptor,\n+                             List<Value> args) {\n+        return new NewOp(false, returnType, constructorDescriptor, args);\n@@ -3877,1 +3915,1 @@\n-     * @param constructorType the constructor type\n+     * @param constructorDescriptor the constructor descriptor\n@@ -3881,1 +3919,1 @@\n-    public static NewOp _new(TypeElement returnType, FunctionType constructorType,\n+    public static NewOp _new(boolean isVarargs, TypeElement returnType, ConstructorRef constructorDescriptor,\n@@ -3883,1 +3921,1 @@\n-        return new NewOp(returnType, constructorType, args);\n+        return new NewOp(isVarargs, returnType, constructorDescriptor, args);\n@@ -3894,1 +3932,2 @@\n-        return _new(FunctionType.functionType(arrayType, JavaType.INT), length);\n+        ConstructorRef constructorDescriptor = ConstructorRef.constructor(arrayType, JavaType.INT);\n+        return _new(constructorDescriptor, length);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":79,"deletions":40,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -946,1 +946,1 @@\n-                        throwBlock.op(_new(FunctionType.functionType(JavaType.type(NullPointerException.class))))\n+                        throwBlock.op(_new(ConstructorRef.constructor(NullPointerException.class)))\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/ExtendedOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.code.type.impl.ConstructorRefImpl;\n@@ -65,0 +66,12 @@\n+    \/**\n+     * Parse a constructor reference from its serialized textual form.\n+     *\n+     * @param desc the serialized constructor reference\n+     * @return the constructor reference\n+     *\/\n+    public static ConstructorRef parseConstructorRef(String desc) {\n+        Scanner s = Scanner.factory().newScanner(desc);\n+        s.nextToken();\n+        return parseConstructorRef(s);\n+    }\n+\n@@ -149,2 +162,1 @@\n-    \/\/ (T, T, T, T)R\n-    static FunctionType parseMethodType(Lexer l) {\n+    static List<TypeElement> parseParameterTypes(Lexer l) {\n@@ -160,0 +172,6 @@\n+        return ptypes;\n+    }\n+\n+    \/\/ (T, T, T, T)R\n+    static FunctionType parseMethodType(Lexer l) {\n+        List<TypeElement> ptypes = parseParameterTypes(l);\n@@ -169,9 +187,1 @@\n-        String methodName;\n-        if (l.acceptIf(Tokens.TokenKind.LT)) {\n-            \/\/ Special name such as \"<new>\"\n-            Tokens.Token t = l.accept(Tokens.TokenKind.IDENTIFIER);\n-            l.accept(Tokens.TokenKind.GT);\n-            methodName = \"<\" + t.name() + \">\";\n-        } else {\n-            methodName = l.accept(Tokens.TokenKind.IDENTIFIER).name();\n-        }\n+        String methodName = l.accept(Tokens.TokenKind.IDENTIFIER).name();\n@@ -184,0 +194,17 @@\n+    static ConstructorRef parseConstructorRef(Lexer l) {\n+        TypeElement refType = parseTypeElement(l);\n+\n+        l.accept(Tokens.TokenKind.COLCOL);\n+\n+        \/\/ Constructor reference has the special name \"<new>\"\n+        l.accept(Tokens.TokenKind.LT);\n+        Tokens.Token t = l.accept(Tokens.TokenKind.IDENTIFIER);\n+        if (!t.name().equals(\"new\")) {\n+            throw new IllegalArgumentException(\"Invalid name for constructor reference: \" + t.name());\n+        }\n+        l.accept(Tokens.TokenKind.GT);\n+\n+        List<TypeElement> ptypes = parseParameterTypes(l);\n+        return new ConstructorRefImpl(FunctionType.functionType(refType, ptypes));\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/DescParser.java","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.type;\n+\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.impl.ConstructorRefImpl;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Constructor;\n+import java.util.List;\n+\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+\n+\/**\n+ * The symbolic reference to a Java constructor.\n+ *\/\n+public sealed interface ConstructorRef extends TypeVarRef.Owner permits ConstructorRefImpl {\n+\n+    default TypeElement refType() {\n+        return type().returnType();\n+    }\n+\n+    FunctionType type();\n+\n+    \/\/ Resolutions to constructors and method handles\n+\n+    \/\/ Resolve to constructor on referenced class\n+    Constructor<?> resolveToConstructor(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    \/\/ Resolve to constructor on referenced class\n+    MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    \/\/ Factories\n+\n+    static ConstructorRef constructor(Constructor<?> c) {\n+        return constructor(c.getDeclaringClass(),\n+                c.getParameterTypes());\n+    }\n+\n+    static ConstructorRef constructor(MethodType mt) {\n+        return constructor(mt.returnType(), mt.parameterList());\n+    }\n+\n+    static ConstructorRef constructor(Class<?> refType, Class<?>... params) {\n+        return constructor(refType, List.of(params));\n+    }\n+\n+    static ConstructorRef constructor(Class<?> refType, List<Class<?>> params) {\n+        return constructor(JavaType.type(refType), params.stream().map(JavaType::type).toList());\n+    }\n+\n+    static ConstructorRef constructor(TypeElement refType, List<? extends TypeElement> params) {\n+        return constructor(functionType(refType, params));\n+    }\n+\n+    static ConstructorRef constructor(TypeElement refType, TypeElement... params) {\n+        return constructor(functionType(refType, params));\n+    }\n+\n+    static ConstructorRef constructor(FunctionType type) {\n+        return new ConstructorRefImpl(type);\n+    }\n+\n+    static ConstructorRef ofString(String s) {\n+        return jdk.incubator.code.parser.impl.DescParser.parseConstructorRef(s);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/ConstructorRef.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -131,4 +131,8 @@\n-                    \/\/ method type-var\n-                    return JavaType.typeVarRef(parts[2],\n-                            parseMethodRef(String.format(\"%s::%s\", parts[0], parts[1])),\n-                            constructTypeArgument(tree, 0, NO_WILDCARDS));\n+                    \/\/ method or constructor type-var\n+                    String desc = String.format(\"%s::%s\", parts[0], parts[1]);\n+                    TypeVarRef.Owner owner = parts[1].startsWith(\"<new>\") ?\n+                            parseConstructorRef(desc) :\n+                            parseMethodRef(String.format(\"%s::%s\", parts[0], parts[1]));\n+                            return JavaType.typeVarRef(parts[2],\n+                                    owner,\n+                                    constructTypeArgument(tree, 0, NO_WILDCARDS));\n@@ -208,0 +212,4 @@\n+    static ConstructorRef parseConstructorRef(String desc) {\n+        return jdk.incubator.code.parser.impl.DescParser.parseConstructorRef(desc);\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/CoreTypeFactory.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,6 +32,2 @@\n-import java.lang.reflect.Executable;\n-import java.lang.reflect.GenericArrayType;\n-import java.lang.reflect.GenericDeclaration;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.*;\n+\n@@ -213,1 +209,2 @@\n-            case Executable e -> MethodRef.method(e);\n+            case Constructor<?> c -> ConstructorRef.constructor(c);\n+            case Method m -> MethodRef.method(m);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/JavaType.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -69,4 +69,4 @@\n-    static MethodRef method(Executable e) {\n-        return method(e.getDeclaringClass(), e.getName(),\n-                e instanceof Method m ? m.getReturnType() : e.getDeclaringClass(),\n-                e.getParameterTypes());\n+    static MethodRef method(Method m) {\n+        return method(m.getDeclaringClass(), m.getName(),\n+                m.getReturnType(),\n+                m.getParameterTypes());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/MethodRef.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Constructor;\n@@ -53,0 +54,4 @@\n+            case ConstructorRef constructorRef -> {\n+                Constructor<?> constructor = constructorRef.resolveToConstructor(lookup);\n+                yield constructor.getTypeParameters();\n+            }\n@@ -133,1 +138,1 @@\n-    public sealed interface Owner permits ClassType, MethodRef { }\n+    public sealed interface Owner permits ClassType, MethodRef, ConstructorRef { }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/TypeVarRef.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.type.impl;\n+\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.ArrayType;\n+import jdk.incubator.code.type.ConstructorRef;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleInfo;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+public final class ConstructorRefImpl implements ConstructorRef {\n+    final FunctionType type;\n+    final TypeElement refType;\n+\n+    static final MethodHandle MULTI_NEW_ARRAY_MH;\n+\n+    static {\n+        try {\n+            MULTI_NEW_ARRAY_MH = MethodHandles.lookup().findStatic(Array.class, \"newInstance\",\n+                    MethodType.methodType(Object.class, Class.class, int[].class));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+\n+    public ConstructorRefImpl(FunctionType functionType) {\n+        this.type = functionType;\n+        this.refType = functionType.returnType();\n+    }\n+\n+    @Override\n+    public TypeElement refType() {\n+        return refType;\n+    }\n+\n+    @Override\n+    public FunctionType type() {\n+        return type;\n+    }\n+\n+    @Override\n+    public Constructor<?> resolveToConstructor(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        MethodHandleInfo methodHandleInfo = l.revealDirect(resolveToHandle(l));\n+        return methodHandleInfo.reflectAs(Constructor.class, l);\n+    }\n+\n+    @Override\n+    public MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        Class<?> refC = resolve(l, refType);\n+        if (refType instanceof ArrayType at) {\n+            if (at.dimensions() == 1) {\n+                return MethodHandles.arrayConstructor(refC);\n+            } else {\n+                int dims = type.parameterTypes().size();\n+                Class<?> elementType = refC;\n+                for (int i = 0 ; i < type.parameterTypes().size(); i++) {\n+                    elementType = elementType.componentType();\n+                }\n+                \/\/ only the use-site knows how many dimensions are specified\n+                return MULTI_NEW_ARRAY_MH.asType(MULTI_NEW_ARRAY_MH.type().changeReturnType(refC))\n+                        .bindTo(elementType)\n+                        .asCollector(int[].class, dims);\n+            }\n+        } else {\n+            \/\/ MH lookup wants a void-returning lookup type\n+            MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l).changeReturnType(void.class);\n+            return l.findConstructor(refC, mt);\n+        }\n+    }\n+\n+    static Class<?> resolve(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n+        if (t instanceof JavaType jt) {\n+            return (Class<?>)jt.erasure().resolve(l);\n+        } else {\n+            \/\/ @@@\n+            throw new ReflectiveOperationException();\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return refType.externalize() + \"::<new>\" +\n+            type.parameterTypes().stream().map(t -> t.externalize().toString())\n+                    .collect(joining(\", \", \"(\", \")\"));\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        ConstructorRefImpl that = (ConstructorRefImpl) o;\n+\n+        if (!refType.equals(that.refType)) return false;\n+        return type.equals(that.type);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = refType.hashCode();\n+        result = 31 * result + type.hashCode();\n+        return result;\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/ConstructorRefImpl.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -84,0 +84,3 @@\n+    static final MethodRef CONSTRUCTOR_REF_OF_STRING = MethodRef.method(ConstructorRef.class, \"ofString\",\n+            ConstructorRef.class, String.class);\n+\n@@ -225,1 +228,1 @@\n-        return builder.op(_new(EXTERNALIZED_OP_F_TYPE, args));\n+        return builder.op(_new(ConstructorRef.constructor(EXTERNALIZED_OP_F_TYPE), args));\n@@ -317,0 +320,4 @@\n+            case ConstructorRef r -> {\n+                Value string = builder.op(constant(J_L_STRING, value.toString()));\n+                yield builder.op(invoke(CONSTRUCTOR_REF_OF_STRING, string));\n+            }\n@@ -357,1 +364,2 @@\n-            Value map = builder.op(_new(mapType, functionType(J_U_HASH_MAP)));\n+            ConstructorRef constructorRef = ConstructorRef.constructor(HashMap.class);\n+            Value map = builder.op(_new(mapType, constructorRef));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/OpBuilder.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.*;\n-import org.junit.Test;\n-\n-import java.io.PrintStream;\n-import java.lang.invoke.MethodType;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestAddVarsWhenNecessary\n- *\/\n-public class TestAddVarsWhenNecessary {\n-\n-    static final MethodRef MAP_PUT = MethodRef.method(Map.class, \"put\",\n-            MethodType.methodType(Object.class, Object.class, Object.class));\n-    static final JavaType MAP = JavaType.type(Map.class.describeConstable().get());\n-    static final JavaType HASH_MAP = JavaType.type(HashMap.class.describeConstable().get());\n-    static CoreOp.FuncOp f() {\n-        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(MAP));\n-        Block.Builder block = body.entryBlock();\n-        Op.Result map = block.op(CoreOp._new(\n-                JavaType.parameterized(MAP, JavaType.J_L_INTEGER, JavaType.J_L_INTEGER),\n-                FunctionType.functionType(HASH_MAP)));\n-        Op.Result c1 = block.op(CoreOp.constant(JavaType.INT, 1));\n-        Op.Result c2 = block.op(CoreOp.constant(JavaType.INT, 2));\n-        block.op(CoreOp.invoke(MAP_PUT, map, c1, c2));\n-        block.op(CoreOp._return(map));\n-        return CoreOp.func(\"f\", body);\n-    }\n-    static CoreOp.FuncOp g() {\n-        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(JavaType.INT));\n-        Block.Builder block = body.entryBlock();\n-        Op.Result var = block.op(CoreOp.var(block.op(CoreOp.constant(JavaType.INT, 1))));\n-        block.op(CoreOp.varStore(var, block.op(CoreOp.constant(JavaType.INT, 2))));\n-        block.op(CoreOp._return(block.op(CoreOp.varLoad(var))));\n-        return CoreOp.func(\"g\", body);\n-    }\n-\n-    static final MethodRef PRINT_INT = MethodRef.method(PrintStream.class, \"print\",\n-            MethodType.methodType(Void.class, int.class));\n-\n-    static CoreOp.FuncOp h() {\n-        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(JavaType.INT, JavaType.INT));\n-        Block.Builder block = body.entryBlock();\n-        Block.Parameter p = block.parameters().get(0);\n-        \/\/ @@@ do we need the type to construct a FieldRef ??\n-        Op.Result sout = block.op(CoreOp.fieldLoad(FieldRef.field(System.class, \"out\", PrintStream.class)));\n-        block.op(CoreOp.invoke(PRINT_INT, sout, p));\n-        block.op(CoreOp._return(p));\n-        return CoreOp.func(\"h\", body);\n-    }\n-\n-    @Test\n-    public void test() {\n-        CoreOp.FuncOp f = f();\n-        f.writeTo(System.out);\n-\n-        f = addVarsWhenNecessary(f);\n-        f.writeTo(System.out);\n-    }\n-\n-    @Test\n-    public void test2() {\n-        CoreOp.FuncOp g = g();\n-        g.writeTo(System.out);\n-\n-        g = addVarsWhenNecessary(g);\n-        g.writeTo(System.out);\n-    }\n-\n-    @Test\n-    public void test3() {\n-        CoreOp.FuncOp h = h();\n-        h.writeTo(System.out);\n-\n-        h = addVarsWhenNecessary(h);\n-        h.writeTo(System.out);\n-    }\n-\n-    public static CoreOp.FuncOp addVarsWhenNecessary(CoreOp.FuncOp funcOp) {\n-        \/\/ using cc only is not possible\n-        \/\/ because at first opr --> varOpRes\n-        \/\/ at the first usage we would have to opr --> varLoad\n-        \/\/ meaning we would have to back up the mapping, update it, then restore it before transforming the next op\n-\n-        Map<Value, CoreOp.VarOp> valueToVar = new HashMap<>();\n-\n-        return CoreOp.func(funcOp.funcName(), funcOp.body().bodyType()).body(block -> {\n-            var newParams = block.parameters();\n-            var oldParams = funcOp.parameters();\n-            for (int i = 0; i < newParams.size(); i++) {\n-                Op.Result var = block.op(CoreOp.var(newParams.get(i)));\n-                valueToVar.put(oldParams.get(i), ((CoreOp.VarOp) var.op()));\n-            }\n-\n-            block.transformBody(funcOp.body(), List.of(), (Block.Builder b, Op op) -> {\n-                var cc = b.context();\n-                for (Value operand : op.operands()) {\n-                    if (valueToVar.containsKey(operand)) {\n-                        var varLoadRes = b.op(CoreOp.varLoad(valueToVar.get(operand).result()));\n-                        cc.mapValue(operand, varLoadRes);\n-                    }\n-                }\n-                var opr = b.op(op);\n-                if (!(op instanceof CoreOp.VarOp) && op.result().uses().size() > 1) {\n-                    var varOpRes = b.op(CoreOp.var(opr));\n-                    valueToVar.put(op.result(), ((CoreOp.VarOp) varOpRes.op()));\n-                }\n-                return b;\n-            });\n-        });\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestAddVarsWhenNecessary.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.code.type.ConstructorRef;\n@@ -53,2 +54,0 @@\n-                {\"MethodReferenceTest$X::<new>(int)MethodReferenceTest$X\", \"MethodReferenceTest$X\", \"<new>\"},\n-                {\"MethodReferenceTest$A[]::<new>(int)MethodReferenceTest$A[]\", \"MethodReferenceTest$A[]\", \"<new>\"},\n@@ -67,0 +66,14 @@\n+    @DataProvider\n+    public Object[][] constructorRefs() {\n+        return new Object[][]{\n+                {\"MethodReferenceTest$X::<new>(int)\", \"MethodReferenceTest$X\"},\n+                {\"MethodReferenceTest$A[]::<new>(int)\", \"MethodReferenceTest$A[]\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"constructorRefs\")\n+    public void testConstructorRef(String cds, String refType) {\n+        ConstructorRef cr = ConstructorRef.ofString(cds);\n+        Assert.assertEquals(cr.toString(), cds);\n+        Assert.assertEquals(cr.refType().externalize().toString(), refType);\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestReferences.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-                             %3 : java.lang.RuntimeException = new @\"func<java.lang.RuntimeException>\";\n+                             %3 : java.lang.RuntimeException = new @\"java.lang.RuntimeException::<new>()\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/BlockTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-                %1 : BoxingConversionTest$Box = new @\"func<BoxingConversionTest$Box>\";\n+                %1 : BoxingConversionTest$Box = new @\"BoxingConversionTest$Box::<new>()\";\n@@ -150,1 +150,1 @@\n-                %1 : BoxingConversionTest$Box = new @\"func<BoxingConversionTest$Box>\";\n+                %1 : BoxingConversionTest$Box = new @\"BoxingConversionTest$Box::<new>()\";\n@@ -605,1 +605,1 @@\n-                %5 : BoxingConversionTest$Box2 = new %4 @\"func<BoxingConversionTest$Box2, java.lang.Integer>\";\n+                %5 : BoxingConversionTest$Box2 = new %4 @\"BoxingConversionTest$Box2::<new>(java.lang.Integer)\";\n@@ -619,1 +619,1 @@\n-                %5 : BoxingConversionTest$Box2 = new %3 %4 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n+                %5 : BoxingConversionTest$Box2 = new %3 %4 @new.varargs=\"true\" @\"BoxingConversionTest$Box2::<new>(int,int,java.lang.Integer[])\";\n@@ -635,1 +635,1 @@\n-                %7 : BoxingConversionTest$Box2 = new %3 %4 %6 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n+                %7 : BoxingConversionTest$Box2 = new %3 %4 %6 @new.varargs=\"true\" @\"BoxingConversionTest$Box2::<new>(int,int,java.lang.Integer[])\";\n@@ -653,1 +653,1 @@\n-                %9 : BoxingConversionTest$Box2 = new %3 %4 %6 %8 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n+                %9 : BoxingConversionTest$Box2 = new %3 %4 %6 %8 @new.varargs=\"true\" @\"BoxingConversionTest$Box2::<new>(int,int,java.lang.Integer[])\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/BoxingConversionTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-                    %1 : FieldAccessTest$Box<java.lang.String> = new %0 @\"func<FieldAccessTest$Box, java.lang.Object>\";\n+                    %1 : FieldAccessTest$Box<java.lang.String> = new %0 @\"FieldAccessTest$Box::<new>(java.lang.Object)\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/FieldAccessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -518,1 +518,1 @@\n-                %5 : ImplicitConversionTest$Box = new %4 @\"func<ImplicitConversionTest$Box, long>\";\n+                %5 : ImplicitConversionTest$Box = new %4 @\"ImplicitConversionTest$Box::<new>(long)\";\n@@ -532,1 +532,1 @@\n-                %5 : ImplicitConversionTest$Box = new %3 %4 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n+                %5 : ImplicitConversionTest$Box = new %3 %4 @new.varargs=\"true\" @\"ImplicitConversionTest$Box::<new>(int, int, long[])\";\n@@ -548,1 +548,1 @@\n-               %7 : ImplicitConversionTest$Box = new %3 %4 %6 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n+               %7 : ImplicitConversionTest$Box = new %3 %4 %6 @new.varargs=\"true\" @\"ImplicitConversionTest$Box::<new>(int, int, long[])\";\n@@ -566,1 +566,1 @@\n-                %9 : ImplicitConversionTest$Box = new %3 %4 %6 %8 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n+                %9 : ImplicitConversionTest$Box = new %3 %4 %6 %8 @new.varargs=\"true\" @\"ImplicitConversionTest$Box::<new>(int, int, long[])\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-                %1 : .<LocalClassTest, LocalClassTest$1Foo> = new %0 @\"func<.<LocalClassTest, LocalClassTest$1Foo>, LocalClassTest>\";\n+                %1 : .<LocalClassTest, LocalClassTest$1Foo> = new %0 @\".<LocalClassTest, LocalClassTest$1Foo>::<new>(LocalClassTest)\";\n@@ -60,1 +60,1 @@\n-                %1 : .<LocalClassTest, LocalClassTest$1> = new %0 @\"func<.<LocalClassTest, LocalClassTest$1>, LocalClassTest>\";\n+                %1 : .<LocalClassTest, LocalClassTest$1> = new %0 @\".<LocalClassTest, LocalClassTest$1>::<new>(LocalClassTest)\";\n@@ -76,1 +76,1 @@\n-                %4 : .<LocalClassTest, LocalClassTest$2Foo> = new %0 %3 @\"func<.<LocalClassTest, LocalClassTest$2Foo>, LocalClassTest, java.lang.String>\";\n+                %4 : .<LocalClassTest, LocalClassTest$2Foo> = new %0 %3 @\".<LocalClassTest, LocalClassTest$2Foo>::<new>(LocalClassTest, java.lang.String)\";\n@@ -93,1 +93,1 @@\n-                %4 : .<LocalClassTest, LocalClassTest$2> = new %0 %3 @\"func<.<LocalClassTest, LocalClassTest$2>, LocalClassTest, java.lang.String>\";\n+                %4 : .<LocalClassTest, LocalClassTest$2> = new %0 %3 @\".<LocalClassTest, LocalClassTest$2>::<new>(LocalClassTest, java.lang.String)\";\n@@ -111,1 +111,1 @@\n-                %6 : .<LocalClassTest, LocalClassTest$3Foo> = new %0 %5 @\"func<.<LocalClassTest, LocalClassTest$3Foo>, LocalClassTest, java.lang.String>\";\n+                %6 : .<LocalClassTest, LocalClassTest$3Foo> = new %0 %5 @\".<LocalClassTest, LocalClassTest$3Foo>::<new>(LocalClassTest, java.lang.String)\";\n@@ -131,1 +131,1 @@\n-                %6 : .<LocalClassTest, LocalClassTest$3> = new %0 %5 @\"func<.<LocalClassTest, LocalClassTest$3>, LocalClassTest, java.lang.String>\";\n+                %6 : .<LocalClassTest, LocalClassTest$3> = new %0 %5 @\".<LocalClassTest, LocalClassTest$3>::<new>(LocalClassTest, java.lang.String)\";\n@@ -150,1 +150,1 @@\n-                %7 : .<LocalClassTest, LocalClassTest$1Bar> = new %0 %5 %6 @\"func<.<LocalClassTest, LocalClassTest$1Bar>, LocalClassTest, int, int>\";\n+                %7 : .<LocalClassTest, LocalClassTest$1Bar> = new %0 %5 %6 @\".<LocalClassTest, LocalClassTest$1Bar>::<new>(LocalClassTest, int, int)\";\n@@ -172,1 +172,1 @@\n-                %7 : .<LocalClassTest, LocalClassTest$4> = new %0 %5 %6 @\"func<.<LocalClassTest, LocalClassTest$4>, LocalClassTest, int, int>\";\n+                %7 : .<LocalClassTest, LocalClassTest$4> = new %0 %5 %6 @\".<LocalClassTest, LocalClassTest$4>::<new>(LocalClassTest, int, int)\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalClassTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-                    %6 : MethodReferenceTest$X = new %5 @\"func<MethodReferenceTest$X, int>\";\n+                    %6 : MethodReferenceTest$X = new %5 @\"MethodReferenceTest$X::<new>(int)\";\n@@ -172,1 +172,1 @@\n-                    %2 : .<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>> = new %0 @\"func<.<MethodReferenceTest, MethodReferenceTest$A>, MethodReferenceTest>\";\n+                    %2 : .<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>> = new %0 @\".<MethodReferenceTest, MethodReferenceTest$A>::<new>(MethodReferenceTest)\";\n@@ -189,1 +189,1 @@\n-                    %5 : .<MethodReferenceTest, MethodReferenceTest$A>[] = new %4 @\"func<.<MethodReferenceTest, MethodReferenceTest$A>[], int>\";\n+                    %5 : .<MethodReferenceTest, MethodReferenceTest$A>[] = new %4 @\".<MethodReferenceTest, MethodReferenceTest$A>[]::<new>(int)\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodReferenceTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-                %2 : int[] = new %1 @\"func<int[], int>\";\n+                %2 : int[] = new %1 @\"int[]::<new>(int)\";\n@@ -58,1 +58,1 @@\n-                %6 : int[] = new %5 @\"func<int[], int>\";\n+                %6 : int[] = new %5 @\"int[]::<new>(int)\";\n@@ -71,1 +71,1 @@\n-                %2 : java.lang.String[] = new %1 @\"func<java.lang.String[], int>\";\n+                %2 : java.lang.String[] = new %1 @\"java.lang.String[]::<new>(int)\";\n@@ -84,1 +84,1 @@\n-                %2 : java.lang.String[][] = new %1 @\"func<java.lang.String[][], int>\";\n+                %2 : java.lang.String[][] = new %1 @\"java.lang.String[][]::<new>(int)\";\n@@ -98,1 +98,1 @@\n-                %3 : java.lang.String[][] = new %1 %2 @\"func<java.lang.String[][], int, int>\";\n+                %3 : java.lang.String[][] = new %1 %2 @\"java.lang.String[][]::<new>(int, int)\";\n@@ -111,1 +111,1 @@\n-                %2 : java.lang.String[][] = new %1 @\"func<java.lang.String[][], int>\";\n+                %2 : java.lang.String[][] = new %1 @\"java.lang.String[][]::<new>(int)\";\n@@ -113,1 +113,1 @@\n-                %4 : java.lang.String[] = new %3 @\"func<java.lang.String[], int>\";\n+                %4 : java.lang.String[] = new %3 @\"java.lang.String[]::<new>(int)\";\n@@ -123,1 +123,1 @@\n-                %11 : java.lang.String[] = new %10 @\"func<java.lang.String[], int>\";\n+                %11 : java.lang.String[] = new %10 @\"java.lang.String[]::<new>(int)\";\n@@ -144,1 +144,1 @@\n-                %2 : java.lang.String[][] = new %1 @\"func<java.lang.String[][], int>\";\n+                %2 : java.lang.String[][] = new %1 @\"java.lang.String[][]::<new>(int)\";\n@@ -146,1 +146,1 @@\n-                %4 : java.lang.String[] = new %3 @\"func<java.lang.String[], int>\";\n+                %4 : java.lang.String[] = new %3 @\"java.lang.String[]::<new>(int)\";\n@@ -156,1 +156,1 @@\n-                %11 : java.lang.String[] = new %10 @\"func<java.lang.String[], int>\";\n+                %11 : java.lang.String[] = new %10 @\"java.lang.String[]::<new>(int)\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewArrayTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-                %2 : java.math.BigDecimal = new %1 @\"func<java.math.BigDecimal, java.lang.String>\";\n+                %2 : java.math.BigDecimal = new %1 @\"java.math.BigDecimal::<new>(java.lang.String)\";\n@@ -61,1 +61,1 @@\n-                %1 : NewTest$A = new @\"func<NewTest$A>\";\n+                %1 : NewTest$A = new @\"NewTest$A::<new>()\";\n@@ -75,1 +75,1 @@\n-                %3 : NewTest$A = new %1 %2 @\"func<NewTest$A, int, int>\";\n+                %3 : NewTest$A = new %1 %2 @\"NewTest$A::<new>(int, int)\";\n@@ -100,1 +100,1 @@\n-                %1 : .<NewTest, NewTest$B> = new %0 @\"func<.<NewTest, NewTest$B>, NewTest>\";\n+                %1 : .<NewTest, NewTest$B> = new %0 @\".<NewTest, NewTest$B>::<new>(NewTest)\";\n@@ -114,1 +114,1 @@\n-                %3 : .<NewTest, NewTest$B> = new %0 %1 %2 @\"func<.<NewTest, NewTest$B>, NewTest, int, int>\";\n+                %3 : .<NewTest, NewTest$B> = new %0 %1 %2 @\".<NewTest, NewTest$B>::<new>(NewTest, int, int)\";\n@@ -126,1 +126,1 @@\n-                %1 : .<NewTest, NewTest$B> = new %0 @\"func<.<NewTest, NewTest$B>, NewTest>\";\n+                %1 : .<NewTest, NewTest$B> = new %0 @\".<NewTest, NewTest$B>::<new>(NewTest)\";\n@@ -139,1 +139,1 @@\n-                %2 : .<.<NewTest, NewTest$B>, NewTest$B$C> = new %1 @\"func<.<.<NewTest, NewTest$B>, NewTest$B$C>, .<NewTest, NewTest$B>>\";\n+                %2 : .<.<NewTest, NewTest$B>, NewTest$B$C> = new %1 @\".<.<NewTest, NewTest$B>, NewTest$B$C>::<new>(.<NewTest, NewTest$B>)\";\n@@ -152,1 +152,1 @@\n-                %2 : .<.<NewTest, NewTest$B>, NewTest$B$C> = new %1 @\"func<.<.<NewTest, NewTest$B>, NewTest$B$C>, .<NewTest, NewTest$B>>\";\n+                %2 : .<.<NewTest, NewTest$B>, NewTest$B$C> = new %1 @\".<.<NewTest, NewTest$B>, NewTest$B$C>::<new>(.<NewTest, NewTest$B>)\";\n@@ -170,1 +170,1 @@\n-                %4 : NewTest$AG<java.lang.String> = new %3 @\"func<NewTest$AG, java.util.List>\";\n+                %4 : NewTest$AG<java.lang.String> = new %3 @\"NewTest$AG::<new>(java.util.List)\";\n@@ -193,1 +193,1 @@\n-                %6 : .<NewTest, NewTest$BG<java.lang.String>> = new %0 %5 @\"func<.<NewTest, NewTest$BG>, NewTest, java.util.List>\";\n+                %6 : .<NewTest, NewTest$BG<java.lang.String>> = new %0 %5 @\".<NewTest, NewTest$BG>::<new>(NewTest, java.util.List)\";\n@@ -195,1 +195,1 @@\n-                %8 : .<.<NewTest, NewTest$BG<java.lang.String>>, NewTest$BG$CG<java.lang.Number>> = new %6 %7 @\"func<.<.<NewTest, NewTest$BG>, NewTest$BG$CG>, .<NewTest, NewTest$BG<java.lang.String>>, java.util.List>\";\n+                %8 : .<.<NewTest, NewTest$BG<java.lang.String>>, NewTest$BG$CG<java.lang.Number>> = new %6 %7 @\".<.<NewTest, NewTest$BG>, NewTest$BG$CG>::<new>(.<NewTest, NewTest$BG<java.lang.String>>, java.util.List)\";\n@@ -209,1 +209,1 @@\n-                %2 : int[] = new %1 @\"func<int[], int>\";\n+                %2 : int[] = new %1 @\"int[]::<new>(int)\";\n@@ -229,1 +229,1 @@\n-                %10 : java.lang.String[][][] = new %3 %6 %9 @\"func<java.lang.String[][][], int, int, int>\";\n+                %10 : java.lang.String[][][] = new %3 %6 %9 @\"java.lang.String[][][]::<new>(int, int, int)\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewTest.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-                %2 : NullTest$Box = new %1 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\";\n+                %2 : NullTest$Box = new %1 @new.varargs=\"true\" @\"NullTest$Box::<new>(java.lang.String, java.lang.String[])\";\n@@ -504,1 +504,1 @@\n-                %3 : NullTest$Box = new %1 %2 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\";\n+                %3 : NullTest$Box = new %1 %2 @\"NullTest$Box::<new>(java.lang.String, java.lang.String[])\";\n@@ -518,1 +518,1 @@\n-                %4 : NullTest$Box = new %1 %2 %3 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\";\n+                %4 : NullTest$Box = new %1 %2 %3 @new.varargs=\"true\" @\"NullTest$Box::<new>(java.lang.String, java.lang.String[])\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/NullTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-                    %1 : java.lang.AssertionError = new @\"func<java.lang.AssertionError>\";\n+                    %1 : java.lang.AssertionError = new @\"java.lang.AssertionError::<new>()\";\n@@ -222,1 +222,1 @@\n-                    %4 : int[] = new %3 @\"func<int[], int>\";\n+                    %4 : int[] = new %3 @\"int[]::<new>(int)\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableIntersectionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-                    %2 : java.lang.AssertionError = new @\"func<java.lang.AssertionError>\";\n+                    %2 : java.lang.AssertionError = new @\"java.lang.AssertionError::<new>()\";\n@@ -226,1 +226,1 @@\n-                    %5 : int[] = new %4 @\"func<int[], int>\";\n+                    %5 : int[] = new %4 @\"int[]::<new>(int)\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableSubtypeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-                    %2 : java.lang.AssertionError = new @\"func<java.lang.AssertionError>\";\n+                    %2 : java.lang.AssertionError = new @\"java.lang.AssertionError::<new>()\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-                        %8 : java.lang.IllegalArgumentException = new @\"func<java.lang.IllegalArgumentException>\";\n+                        %8 : java.lang.IllegalArgumentException = new @\"java.lang.IllegalArgumentException::<new>()\";\n@@ -442,1 +442,1 @@\n-                        %28 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        %28 : java.lang.MatchException = new @\"java.lang.MatchException::<new>()\";\n@@ -796,1 +796,1 @@\n-                        %12 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        %12 : java.lang.MatchException = new @\"java.lang.MatchException::<new>()\";\n@@ -902,1 +902,1 @@\n-                        %18 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        %18 : java.lang.MatchException = new @\"java.lang.MatchException::<new>()\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest2.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-                        %9 : java.lang.IllegalArgumentException = new @\"func<java.lang.IllegalArgumentException>\";\n+                        %9 : java.lang.IllegalArgumentException = new @\"java.lang.IllegalArgumentException::<new>()\";\n@@ -1056,1 +1056,1 @@\n-                          %25 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                          %25 : java.lang.MatchException = new @\"java.lang.MatchException::<new>()\";\n@@ -1131,1 +1131,1 @@\n-                        %23 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        %23 : java.lang.MatchException = new @\"java.lang.MatchException::<new>()\";\n@@ -1462,1 +1462,1 @@\n-                        %13 : java.lang.IllegalArgumentException = new @\"func<java.lang.IllegalArgumentException>\";\n+                        %13 : java.lang.IllegalArgumentException = new @\"java.lang.IllegalArgumentException::<new>()\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchStatementTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-                %1 : java.lang.RuntimeException = new @\"func<java.lang.RuntimeException>\";\n+                %1 : java.lang.RuntimeException = new @\"java.lang.RuntimeException::<new>()\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/ThrowTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}