{"files":[{"patch":"@@ -37,0 +37,2 @@\n+        ${SHARED_BACKEND}\/include\/shared.h\n+        ${OPENCL_BACKEND}\/include\/opencl_backend.h\n","filename":"hat\/backends\/ffi\/opencl\/CMakeLists.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,4 @@\n+       showWhy((configBits&SHOW_WHY_BIT)==SHOW_WHY_BIT),\n+       useState((configBits&USE_STATE_BIT)==USE_STATE_BIT),\n+       showState((configBits&SHOW_STATE_BIT)==SHOW_STATE_BIT),\n+\n@@ -43,1 +47,1 @@\n-          std::cout << \"native show_code \" << showCode <<std::endl;\n+          std::cout << \"native showCode \" << showCode <<std::endl;\n@@ -53,0 +57,3 @@\n+          std::cout << \"native showWhy \" << showWhy<<std::endl;\n+           std::cout << \"native useState \" << useState<<std::endl;\n+            std::cout << \"native showState \" << showState<<std::endl;\n@@ -65,2 +72,2 @@\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_s *arg)\n-        : Backend::Program::Kernel::Buffer(kernel, arg) {\n+OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_s *arg, BufferState_s *bufferState)\n+        : Backend::Program::Kernel::Buffer(kernel, arg), bufferState(bufferState) {\n@@ -72,1 +79,1 @@\n-        arg->value.buffer.sizeInBytes,\n+        bufferState->length,\/\/ arg->value.buffer.sizeInBytes,\n@@ -80,2 +87,0 @@\n-\n-    BufferState_s * bufferState = BufferState_s::of(arg);\n@@ -89,0 +94,73 @@\n+bool OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::shouldCopyToDevice( Arg_s *arg){\n+   OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(kernel->program->backend);\n+   bool kernelReadsFromThisArg = (arg->value.buffer.access==RW_BYTE) || (arg->value.buffer.access==RO_BYTE);\n+\n+   if (openclBackend->openclConfig.useState){\n+     bool isAlwaysCopyingOrNewStateOrHostOwned =\n+        openclBackend->openclConfig.alwaysCopy\n+        ||  (bufferState->state == BufferState_s::NEW_STATE)\n+         || ((bufferState->state == BufferState_s::HOST_OWNED));\n+     if (openclBackend->openclConfig.showWhy){\n+       std::cout<<\n+                   \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n+                   << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n+                   << \" | arg.RO=\"<<(arg->value.buffer.access==RO_BYTE)\n+                   << \" | kernel.needsToRead=\"<<  kernelReadsFromThisArg\n+                   << \" | Buffer state = \"<< BufferState_s::stateNames[bufferState->state]\n+                   <<\" so \"\n+                     ;\n+     }\n+     return isAlwaysCopyingOrNewStateOrHostOwned;\n+   }else{\n+     bool isHostDirtyOrNew = bufferState->isHostDirty() | bufferState->isHostNew();\n+\n+      if (openclBackend->openclConfig.showWhy){\n+        std::cout<<\n+          \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n+          << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n+          << \" | arg.RO=\"<<(arg->value.buffer.access==RO_BYTE)\n+          << \" | kernel.needsToRead=\"<<  kernelReadsFromThisArg\n+          << \" | buffer.hostDirty=\"<< bufferState->isHostDirty()\n+          << \" | buffer.hostNew=\"<< bufferState->isHostNew()\n+          << \" | buffer.deviceDirty=\"<< bufferState->isDeviceDirty()\n+          <<\" so \"\n+            ;\n+      }\n+\n+     bool result=  (kernelReadsFromThisArg & isHostDirtyOrNew);\n+     if (result && bufferState->isDeviceDirty()){\n+       result= false;\n+     }\n+     return openclBackend->openclConfig.alwaysCopy |result;\n+   }\n+}\n+bool OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::shouldCopyFromDevice(Arg_s *arg){\n+   OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(kernel->program->backend);\n+ bool kernelWroteToThisArg = (arg->value.buffer.access==WO_BYTE) |  (arg->value.buffer.access==RW_BYTE);\n+    if (openclBackend->openclConfig.useState){\n+       if (openclBackend->openclConfig.showWhy){\n+           std::cout<<\n+             \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n+                << \" | arg.WO=\"<<(arg->value.buffer.access==WO_BYTE)\n+                << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n+                << \" | kernel.wroteToThisArg=\"<<  kernelWroteToThisArg\n+                << \"Buffer state = \"<< BufferState_s::stateNames[bufferState->state]\n+                <<\" so \" ;\n+       }\n+       return openclBackend->openclConfig.alwaysCopy;\n+    }else{\n+\n+       if (openclBackend->openclConfig.showWhy){\n+         std::cout<<\n+            \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n+            << \" | arg.WO=\"<<(arg->value.buffer.access==WO_BYTE)\n+            << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n+            << \" | kernel.wroteToThisArg=\"<<  kernelWroteToThisArg\n+            <<\" so \" ;\n+       }\n+       return openclBackend->openclConfig.alwaysCopy;\n+    }\n+\n+\n+}\n+\n@@ -93,0 +171,2 @@\n+   \/\/  std::cout << \"copyTo(\" <<std::hex << (long) arg->value.buffer.memorySegment << \",\" << std::dec<<   bufferState->length <<\")\"<<std::endl;\n+\n@@ -98,1 +178,1 @@\n-       arg->value.buffer.sizeInBytes,\n+       bufferState->length, \/\/ arg->value.buffer.sizeInBytes,\n@@ -118,0 +198,1 @@\n+ \/\/  std::cout << \"copyFrom(\" <<std::hex << (long) arg->value.buffer.memorySegment << \",\" << std::dec<<   bufferState->length <<\")\"<<std::endl;\n@@ -124,1 +205,1 @@\n-       arg->value.buffer.sizeInBytes,\n+       bufferState->length,\/\/arg->value.buffer.sizeInBytes,\n@@ -138,0 +219,3 @@\n+\n+\n+\n@@ -184,0 +268,3 @@\n+    if (openclConfig.traceCalls){\n+      std::cout << \"getBufferFromDeviceIfDirty(\" <<std::hex << (long)memorySegment << \",\" << std::dec<< memorySegmentLength <<\"){\"<<std::endl;\n+    }\n@@ -186,2 +273,3 @@\n-       if (bufferState->isDeviceDirty()){\n-          std::cout << \"from getBufferFromDeviceIfDirty Buffer is device dirty so attempting to get buffer from device from OpenCLBackend \"<<std::endl;\n+       if (   (openclConfig.useState && (bufferState->state == BufferState_s::DEVICE_OWNED))\n+           || (!openclConfig.useState && bufferState->isDeviceDirty())){\n+\n@@ -202,1 +290,3 @@\n-\n+    if (openclConfig.traceCalls){\n+      std::cout << \"}getBufferFromDeviceIfDirty()\"<<std::endl;\n+    }\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":101,"deletions":11,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -53,37 +53,1 @@\n-bool shouldCopyToDevice(BufferState_s *bufferState, Arg_s *arg, bool alwaysCopy, bool showWhy){\n-   bool kernelReadsFromThisArg = (arg->value.buffer.access==RW_BYTE) || (arg->value.buffer.access==RO_BYTE);\n-   bool isHostDirtyOrNew = bufferState->isHostDirty() | bufferState->isHostNew();\n-\n-   bool result=  (kernelReadsFromThisArg & isHostDirtyOrNew);\n-\n-   if (showWhy){\n-     std::cout<<\n-          \"alwaysCopy=\"<<alwaysCopy\n-          << \" | argRW=\"<<(arg->value.buffer.access==RW_BYTE)\n-          << \" | argRO=\"<<(arg->value.buffer.access==RO_BYTE)\n-          << \" | kernelNeedsToRead=\"<<  kernelReadsFromThisArg\n-          << \" | hostDirty=\"<< bufferState->isHostDirty()\n-          << \" | hostNew=\"<< bufferState->isHostNew()\n-          << \" | deviceDirty=\"<< bufferState->isDeviceDirty()\n-          <<\" so \"\n-            ;\n-    }\n-    if (result && bufferState->isDeviceDirty()){\n-            result= false;\n-      }\n-   return alwaysCopy |result;\n-}\n-bool shouldCopyFromDevice( BufferState_s *bufferState, Arg_s *arg, bool alwaysCopy, bool showWhy ){\n-   bool kernelWroteToThisArg = (arg->value.buffer.access==WO_BYTE) |  (arg->value.buffer.access==RW_BYTE);\n-   bool result = kernelWroteToThisArg;\n-   if (showWhy){\n-       std::cout<<\n-         \"alwaysCopy=\"<<alwaysCopy\n-            << \" | argWO=\"<<(arg->value.buffer.access==WO_BYTE)\n-            << \" | argRW=\"<<(arg->value.buffer.access==RW_BYTE)\n-            << \" | kernelWroteToThisArg=\"<<  kernelWroteToThisArg\n-            <<\" so \"\n-              ;\n-      }\n-   return alwaysCopy;\n-}\n+\n@@ -125,2 +89,3 @@\n-               if (bufferState->isHostNew()){\n-                  openclBuffer = new OpenCLBuffer(this, arg);\n+               if ((openclBackend->openclConfig.useState && (bufferState->state == BufferState_s::NEW_STATE))\n+                || (!openclBackend->openclConfig.useState && bufferState->isHostNew())){\n+                  openclBuffer = new OpenCLBuffer(this, arg, bufferState);\n@@ -130,1 +95,0 @@\n-                  bufferState->clearHostNew();\n@@ -137,6 +101,5 @@\n-                if (shouldCopyToDevice(bufferState, arg,openclBackend->openclConfig.alwaysCopy,\n-                      (openclBackend->openclConfig.traceCopies|openclBackend->openclConfig.traceEnqueues))){\n-\n-                       if (openclBackend->openclConfig.traceCopies){\n-                          std::cout << \"We are always cloying  OR (HOST is JAVA dirty and the kernel is READS this arg) so copying arg \" << arg->idx <<\" to device \"<< std::endl;\n-                       }\n+                if (openclBuffer->shouldCopyToDevice(arg)){\n+                   openclBuffer->copyToDevice();\n+                   if (openclBackend->openclConfig.useState){\n+                   }else{\n+                       bufferState->clearHostNew();\n@@ -144,11 +107,5 @@\n-                       if (openclBackend->openclConfig.traceEnqueues){\n-                           std::cout << \"copying arg \" << arg->idx <<\" to device \"<< std::endl;\n-                       }\n-                       openclBuffer->copyToDevice();\n-\n-                    }else{\n-                     if (openclBackend->openclConfig.traceSkippedCopies){\n-                           std::cout << \"NOT copying arg \" << arg->idx <<\" to device \"<< std::endl;\n-                                                       \/\/ bufferState->dump(\"After copy from device\");\n-                     }\n-                    }\n+                   }\n+\n+                }else if (openclBackend->openclConfig.traceSkippedCopies){\n+                       std::cout << \"NOT copying arg \" << arg->idx <<\" to device \"<< std::endl;\n+                }\n@@ -217,1 +174,1 @@\n-       for (int i = 1; i < argSled.argc(); i++) { \/\/ note i = 1... we don't need to copy back the KernelContext\n+       for (int i = 0; i < argSled.argc(); i++) { \/\/ note i = 1... we don't need to copy back the KernelContext\n@@ -221,9 +178,4 @@\n-             if (shouldCopyFromDevice(bufferState,arg,\n-                 openclBackend->openclConfig.alwaysCopy,\n-                 openclBackend->openclConfig.traceEnqueues)){\n-                static_cast<OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n-                \/\/if (openclBackend->openclConfig.traceCopies){\n-                    \/\/std::cout << \"copying arg \" << arg->idx <<\" from device \"<< std::endl;\n-                   \/\/ bufferState->dump(\"After copy from device\");\n-                \/\/}\n-                if (openclBackend->openclConfig.traceEnqueues){\n+             OpenCLBuffer *openclBuffer = static_cast<OpenCLBuffer *>(bufferState->vendorPtr);\n+             if (openclBuffer->shouldCopyFromDevice(arg)){\n+                openclBuffer->copyFromDevice();\n+                if (openclBackend->openclConfig.traceCopies||openclBackend->openclConfig.traceEnqueues){\n@@ -232,1 +184,9 @@\n-                bufferState->setDeviceDirty();\n+\n+\n+    if (openclBackend->openclConfig.useState){\n+     \/\/ std::cout << \"setting device dirty\"<<std::endl;\n+       bufferState->state = BufferState_s::HOST_OWNED;\n+    }else{\n+       bufferState->clearDeviceDirty();\n+\n+    }\n@@ -236,1 +196,0 @@\n-                                   \/\/ bufferState->dump(\"After copy from device\");\n@@ -238,0 +197,8 @@\n+                    if (openclBackend->openclConfig.useState){\n+                      \/\/ std::cout << \"setting device dirty\"<<std::endl;\n+                        bufferState->state = BufferState_s::DEVICE_OWNED;\n+                     }else{\n+                        bufferState->setDeviceDirty();\n+                        bufferState->clearDeviceDirty();\n+\n+                     }\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_kernel_dispatch.cpp","additions":36,"deletions":69,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -63,1 +63,4 @@\n-        const static  int END_BIT_IDX = 27;\n+        const static  int SHOW_WHY_BIT = 1 <<27;\n+        const static  int USE_STATE_BIT = 1 <<28;\n+        const static  int SHOW_STATE_BIT = 1 <<29;\n+        const static  int END_BIT_IDX = 30;\n@@ -77,0 +80,3 @@\n+        bool showWhy;\n+        bool useState;\n+        bool showState;\n@@ -134,0 +140,1 @@\n+                BufferState_s * bufferState;\n@@ -136,1 +143,3 @@\n-                OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_s *arg);\n+                bool shouldCopyToDevice(Arg_s *arg);\n+                bool shouldCopyFromDevice(Arg_s *arg);\n+                OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_s *arg, BufferState_s *bufferState);\n@@ -195,0 +204,3 @@\n+              \"SHOW_WHY_BIT\",\n+              \"USE_STATE_BIT\",\n+              \"SHOW_STATE_BIT\"\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import hat.ifacemapper.BufferState;\n@@ -104,1 +105,29 @@\n-        if (b.isDeviceDirty()) {\n+        if (config.isUSE_STATE() ) {\n+\n+            switch (b.getState()){\n+                case BufferState.NO_STATE:\n+                case BufferState.NEW_STATE :\n+                case BufferState.HOST_OWNED :\n+                case BufferState.DEVICE_VALID_HOST_HAS_COPY:{\n+                    if (config.isSHOW_STATE()) {\n+                        System.out.println(\"in preMutate state = \" + b.getStateString() + \" no action to take\");\n+                    }\n+                break;\n+                }\n+                case BufferState.DEVICE_OWNED:{\n+                    getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n+\n+                    if (config.isSHOW_STATE()) {\n+                        System.out.print(\"in preMutate state = \" + b.getStateString() + \" we pulled from device \");\n+                    }\n+                    b.setState(BufferState.DEVICE_VALID_HOST_HAS_COPY);\n+                    if (config.isSHOW_STATE()) {\n+                        System.out.println(\"and switched to \" + b.getStateString());\n+                    }\n+                    break;\n+                }\n+                default:\n+                    throw new IllegalStateException(\"Not expecting this state \");\n+            }\n+        }else {\n+            if (b.isDeviceDirty()) {\n@@ -111,0 +140,1 @@\n+        }\n@@ -119,1 +149,9 @@\n-\n+        if (config.isUSE_STATE()) {\n+            if (config.isSHOW_STATE()) {\n+                System.out.print(\"in postMutate state = \" + b.getStateString() + \" no action to take \");\n+            }\n+            b.setState(BufferState.HOST_OWNED);\n+            if (config.isSHOW_STATE()) {\n+                System.out.println(\"and switched to (or stayed on) \" + b.getStateString());\n+            }\n+        }else {\n@@ -121,0 +159,1 @@\n+        }\n@@ -129,0 +168,14 @@\n+        if (config.isUSE_STATE() ) {\n+\n+            switch (b.getState()){\n+                case BufferState.NO_STATE:\n+                case BufferState.NEW_STATE :\n+                case BufferState.HOST_OWNED :\n+                case BufferState.DEVICE_VALID_HOST_HAS_COPY:{\n+                    if (config.isSHOW_STATE()) {\n+                        System.out.println(\"in preAccess state = \" + b.getStateString() + \" no action to take\");\n+                    }\n+                    break;\n+                }\n+                case BufferState.DEVICE_OWNED:{\n+                    getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n@@ -130,0 +183,13 @@\n+                    if (config.isSHOW_STATE()) {\n+                        System.out.print(\"in preAccess state = \" + b.getStateString() + \" we pulled from device \");\n+                    }\n+                    b.setState(BufferState.DEVICE_VALID_HOST_HAS_COPY);\n+                    if (config.isSHOW_STATE()) {\n+                        System.out.println(\"and switched to \" + b.getStateString());\n+                    }\n+                    break;\n+                }\n+                default:\n+                    throw new IllegalStateException(\"Not expecting this state \");\n+            }\n+        }else {\n@@ -136,0 +202,1 @@\n+        }\n@@ -144,0 +211,3 @@\n+        if (config.isUSE_STATE() && config.isSHOW_STATE()) {\n+            System.out.println(\"in postAccess state = \" + b.getStateString());\n+        }\n@@ -152,0 +222,14 @@\n+        if (config.isUSE_STATE() ) {\n+\n+            switch (b.getState()){\n+                case BufferState.NO_STATE:\n+                case BufferState.NEW_STATE :\n+                case BufferState.HOST_OWNED :\n+                case BufferState.DEVICE_VALID_HOST_HAS_COPY:{\n+                    if (config.isSHOW_STATE()) {\n+                        System.out.println(\"in preEscape state = \" + b.getStateString() + \" no action to take\");\n+                    }\n+                    break;\n+                }\n+                case BufferState.DEVICE_OWNED:{\n+                    getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n@@ -153,0 +237,13 @@\n+                    if (config.isSHOW_STATE()) {\n+                        System.out.print(\"in preEscape state = \" + b.getStateString() + \" we pulled from device \");\n+                    }\n+                    b.setState(BufferState.DEVICE_VALID_HOST_HAS_COPY);\n+                    if (config.isSHOW_STATE()) {\n+                        System.out.println(\"and switched to \" + b.getStateString());\n+                    }\n+                    break;\n+                }\n+                default:\n+                    throw new IllegalStateException(\"Not expecting this state \");\n+            }\n+        }else {\n@@ -158,1 +255,1 @@\n-               \/\/ b.clearDeviceDirty();\n+                \/\/ b.clearDeviceDirty();\n@@ -160,0 +257,1 @@\n+        }\n@@ -168,0 +266,1 @@\n+        if (config.isUSE_STATE() ) {\n@@ -169,1 +268,12 @@\n-            b.setHostDirty(); \/\/ We have no choice but to assume escapee was modified by the call\n+                    if (config.isSHOW_STATE()) {\n+                        System.out.print(\"in postEscape state = \" + b.getStateString() + \" we pulled from device \");\n+                    }\n+                    b.setState(BufferState.HOST_OWNED);\n+                    if (config.isSHOW_STATE()) {\n+                        System.out.println(\"and switched to \" + b.getStateString());\n+                    }\n+\n+        }else {\n+\n+            b.setHostDirty();\n+        }\/\/ We have no choice but to assume escapee was modified by the call\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":114,"deletions":4,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -26,1 +26,4 @@\n-    private static final int END_BIT_IDX = 27;\n+    private static final int SHOW_WHY_BIT = 1 << 27;\n+    private static final int USE_STATE_BIT = 1 << 28;\n+    private static final int SHOW_STATE_BIT = 1 << 29;\n+    private static final int END_BIT_IDX = 28;\n@@ -39,1 +42,4 @@\n-            \"TRACE_CALLS\"\n+            \"TRACE_CALLS\",\n+            \"SHOW_WHY\",\n+            \"USE_STATE\",\n+            \"SHOW_STATE\",\n@@ -108,0 +114,21 @@\n+    public static OpenCLConfig USE_STATE() {\n+        return new OpenCLConfig(USE_STATE_BIT);\n+    }\n+\n+    public boolean isUSE_STATE() {\n+        return (bits & USE_STATE_BIT) == USE_STATE_BIT;\n+    }\n+    public static OpenCLConfig SHOW_STATE() {\n+        return new OpenCLConfig(SHOW_STATE_BIT);\n+    }\n+\n+    public boolean isSHOW_STATE() {\n+        return (bits & SHOW_STATE_BIT) == SHOW_STATE_BIT;\n+    }\n+    public static OpenCLConfig SHOW_WHY() {\n+        return new OpenCLConfig(SHOW_WHY_BIT);\n+    }\n+\n+    public boolean isSHOW_WHY() {\n+        return (bits & SHOW_WHY_BIT) == SHOW_WHY_BIT;\n+    }\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLConfig.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#define shared_cpp\n","filename":"hat\/backends\/ffi\/shared\/cpp\/shared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,3 +67,1 @@\n- \/\/ hat iface buffer bits\n- \/\/ hat iface bffa   bits\n- \/\/ 4a7 1face bffa   b175\n+\n@@ -130,0 +128,7 @@\n+   static const int NO_STATE = 0;\n+   static const int NEW_STATE = 1;\n+   static const int HOST_OWNED = 2;\n+   static const int DEVICE_OWNED = 3;\n+   static const int DEVICE_VALID_HOST_HAS_COPY = 4;\n+   const static  char *stateNames[]; \/\/ See below for out of line definition\n+\n@@ -131,0 +136,1 @@\n+   long length;\n@@ -132,1 +138,1 @@\n-   int unused;\n+   int state;\n@@ -138,1 +144,6 @@\n-\n+   void setState(int newState) {\n+      state = newState;\n+   }\n+   int getState() {\n+      return state;\n+   }\n@@ -200,1 +211,1 @@\n-        printf(\"{%s, bits:%08x, unused:%08x, vendorPtr:%016lx}\\n\", msg, bits, unused, (long)vendorPtr);\n+        printf(\"{%s,length: %016lx, bits:%08x, state:%08x, vendorPtr:%016lx}\\n\", msg, length, bits, state, (long)vendorPtr);\n@@ -204,1 +215,1 @@\n-        printf(\"{%s, bits:%08x, unused:%08x, vendorPtr:%016lx}\", msg, bits, unused, (long)vendorPtr);\n+        printf(\"{%s, length: %016lx, bits:%08x, state:%08x, vendorPtr:%016lx}\", msg, length, bits, state, (long)vendorPtr);\n@@ -219,0 +230,9 @@\n+#ifdef shared_cpp\n+const  char *BufferState_s::stateNames[] = {\n+              \"NO_STATE\",\n+              \"NEW_STATE\",\n+              \"HOST_OWNED\",\n+              \"DEVICE_OWNED\",\n+              \"DEVICE_VALID_HOST_HAS_COPY\"\n+        };\n+#endif\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.backend.Backend;\n@@ -33,0 +32,1 @@\n+import hat.ifacemapper.BufferState;\n@@ -34,1 +34,0 @@\n-import hat.ifacemapper.SegmentMapper;\n@@ -214,1 +213,1 @@\n-        static void  updateUI(long now, CellGrid cellGrid, Viewer viewer, int from) {\n+        static void  updateUI(long now, @RO CellGrid cellGrid, Viewer viewer, int from) {\n@@ -227,1 +226,1 @@\n-            int skipped = 0;\n+            int range = cellGrid.width() * cellGrid.height();\n@@ -229,5 +228,1 @@\n-                long now = System.currentTimeMillis();\n-                boolean shouldUpdateUI =  viewer.state.lastUIUpdateCompleted\n-                        && ((now - viewer.state.timeOfLastUIUpdate) >= viewer.state.msPerFrame);\n-\n-                cc.dispatchKernel(cellGrid.width() * cellGrid.height(), kc -> Compute.life(kc, control, cellGrid));\n+                cc.dispatchKernel(range, kc -> Compute.life(kc, control, cellGrid));\n@@ -235,3 +230,1 @@\n-                int to = control.from();\n-                control.from(control.to());\n-                control.to(to);\n+                int to = control.from(); control.from(control.to()); control.to(to);\n@@ -241,0 +234,1 @@\n+                long now = System.currentTimeMillis();\n@@ -242,5 +236,2 @@\n-                if (shouldUpdateUI) {\n-                    if (skipped > 0) {\n-                        System.out.println(\"skipped \" + skipped);\n-                    }\n-                    skipped=0;\n+                if (viewer.state.lastUIUpdateCompleted\n+                        && ((now - viewer.state.timeOfLastUIUpdate) >= viewer.state.msPerFrame)) {\n@@ -248,3 +239,0 @@\n-\n-                }else{\n-                    skipped++;\n@@ -256,1 +244,1 @@\n-int skipped = 0;\n+\/\/int skipped = 0;\n@@ -264,1 +252,1 @@\n-                    SegmentMapper.BufferState bufferState = SegmentMapper.BufferState.of(cellGrid);\n+                    BufferState bufferState = BufferState.of(cellGrid);\n@@ -281,4 +269,1 @@\n-                    if (skipped > 0) {\n-                       \/\/ System.out.println(\"skipped \" + skipped);\n-                    }\n-                    skipped=0;\n+\n@@ -291,7 +276,3 @@\n-                   \/\/ viewer.controls.updateCounters(now);\n-                  \/\/  cellGrid.copySliceTo(viewer.mainPanel.rasterData, control.from());\n-                  \/\/  viewer.state.lastUIUpdateCompleted=false;\n-                   \/\/ viewer.mainPanel.repaint();\n-                   \/\/ viewer.state.timeOfLastUIUpdate = now;\n-                }else{\n-                   skipped++;\n+\n+                \/\/}else{\n+                \/\/   skipped++;\n@@ -305,2 +286,2 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),\/\/ FIRST\n-                new OpenCLBackend(\"INFO,MINIMIZE_COPIES\")\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),FIRST\n+               \/\/ new OpenCLBackend(\"INFO,MINIMIZE_COPIES\")\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":16,"deletions":35,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        public final long requiredFrameRate = 10;\n+        public final long requiredFrameRate = 5;\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Viewer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import hat.ifacemapper.SegmentMapper;\n+import hat.ifacemapper.BufferState;\n@@ -319,1 +319,1 @@\n-            SegmentMapper.BufferState.of(universe).setHostDirty(true).setDeviceDirty(true);\n+            BufferState.of(universe).setHostDirty(true).setDeviceDirty(true);\n@@ -323,1 +323,1 @@\n-            SegmentMapper.BufferState.of(universe).setHostDirty(false).setDeviceDirty(true);\n+            BufferState.of(universe).setHostDirty(false).setDeviceDirty(true);\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/opencl\/OpenCLNBodyGLWindow.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+       \/\/ System.out.println(\"  !!!!!!!!!!!!!                   Getting buffer from device!!!\");\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/ffi\/FFIBackendDriver.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ifacemapper.BufferState;\n@@ -30,1 +31,0 @@\n-import hat.ifacemapper.SegmentMapper;\n@@ -43,0 +43,10 @@\n+    default int getState(){\n+        return BufferState.of(this).getState();\n+    }\n+    default void setState(int newState ){\n+         BufferState.of(this).setState(newState);\n+    }\n+\n+    default String getStateString(){\n+        return BufferState.of(this).getStateString();\n+    }\n@@ -44,1 +54,1 @@\n-        return SegmentMapper.BufferState.of(this).isDeviceDirty();\n+        return BufferState.of(this).isDeviceDirty();\n@@ -47,1 +57,1 @@\n-        return SegmentMapper.BufferState.of(this).isHostChecked();\n+        return BufferState.of(this).isHostChecked();\n@@ -51,1 +61,1 @@\n-         SegmentMapper.BufferState.of(this).clearDeviceDirty();\n+         BufferState.of(this).clearDeviceDirty();\n@@ -54,1 +64,1 @@\n-        SegmentMapper.BufferState.of(this).setHostDirty(true);\n+        BufferState.of(this).setHostDirty(true);\n@@ -58,1 +68,1 @@\n-        SegmentMapper.BufferState.of(this).setHostChecked(true);\n+        BufferState.of(this).setHostChecked(true);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,285 @@\n+package hat.ifacemapper;\n+\n+import hat.buffer.Buffer;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.util.Objects;\n+\n+\n+\n+    \/*\n+\n+\n+     See backend_ffi_shared\/include\/shared.h\n+\n+     Make sure the final static values below match the #defines\n+      \/\/ hat iface buffer bitz\n+    \/\/ hat iface bffa   bitz\n+    \/\/ 4a7 1face bffa   b175\n+\n+\n+\n+    struct state{\n+       long magic1; \/\/ MAGIC\n+       int bits;\n+       int mode;\n+       void * vendorPtr; \/\/ In OpenCL this points to native OpenCL::Buffer\n+       long magic2; \/\/ MAGIC\n+    }\n+     *\/\n+\n+public record BufferState(MemorySegment segment, long paddedSize) {\n+    public static final long alignment = ValueLayout.JAVA_LONG.byteSize();\n+    \/\/ hat iface buffer bitz\n+    \/\/ hat iface bffa   bitz\n+    \/\/ 4a7 1face bffa   b175\n+    public static final long MAGIC = 0x4a71facebffab175L;\n+    public static final int NONE = 0;\n+    public static final int BIT_HOST_NEW = 1<< 0;\n+    public static final int BIT_DEVICE_NEW = 1 << 1;\n+    public static final int BIT_HOST_DIRTY = 1 << 2;\n+    public static final int BIT_DEVICE_DIRTY = 1 << 3;\n+    public static final int BIT_HOST_CHECKED = 1 << 4;\n+\n+    public static final int NO_STATE = 0;\n+    public static final int NEW_STATE = 1;\n+    public static final int HOST_OWNED = 2;\n+    public static final int DEVICE_OWNED = 3;\n+    public static final int DEVICE_VALID_HOST_HAS_COPY = 4;\n+    public static String[] stateNames = new String[]{\n+            \"NO_STATE\",\n+            \"NEW_STATE\",\n+            \"HOST_OWNED\",\n+            \"DEVICE_OWNED\",\n+            \"DEVICE_VALID_HOST_HAS_COPY\"\n+    };\n+    static final MemoryLayout stateMemoryLayout = MemoryLayout.structLayout(\n+            ValueLayout.JAVA_LONG.withName(\"magic1\"),\n+            ValueLayout.JAVA_LONG.withName(\"length\"),\n+            ValueLayout.JAVA_INT.withName(\"bits\"),\n+            ValueLayout.JAVA_INT.withName(\"state\"),\n+            ValueLayout.ADDRESS.withName(\"vendorPtr\"),\n+            ValueLayout.JAVA_LONG.withName(\"magic2\")\n+    ).withName(\"state\");\n+\n+    static long byteSize() {\n+        return stateMemoryLayout.byteSize();\n+    }\n+\n+    static final VarHandle magic1 = stateMemoryLayout.varHandle(\n+            MemoryLayout.PathElement.groupElement(\"magic1\")\n+    );\n+    static final VarHandle length = stateMemoryLayout.varHandle(\n+            MemoryLayout.PathElement.groupElement(\"length\")\n+    );\n+    static final VarHandle bits = stateMemoryLayout.varHandle(\n+            MemoryLayout.PathElement.groupElement(\"bits\")\n+    );\n+    static final VarHandle state = stateMemoryLayout.varHandle(\n+            MemoryLayout.PathElement.groupElement(\"state\")\n+    );\n+\n+    static final VarHandle magic2 = stateMemoryLayout.varHandle(\n+            MemoryLayout.PathElement.groupElement(\"magic2\")\n+    );\n+\n+    static final VarHandle vendorPtr = stateMemoryLayout.varHandle(\n+            MemoryLayout.PathElement.groupElement(\"vendorPtr\")\n+    );\n+\n+    public static long getLayoutSizeAfterPadding(GroupLayout layout) {\n+        return layout.byteSize() +\n+                ((layout.byteSize() % BufferState.alignment) == 0 ? 0 : BufferState.alignment - (layout.byteSize() % BufferState.alignment));\n+    }\n+\n+    public static <T> BufferState of(T t) {\n+        Buffer buffer = (Buffer) Objects.requireNonNull(t);\n+        MemorySegment s = Buffer.getMemorySegment(buffer);\n+        return new BufferState(s, s.byteSize() - BufferState.byteSize());\n+    }\n+    public BufferState setState(int newState) {\n+        BufferState.state.set(segment, paddedSize, newState);\n+        return this;\n+    }\n+\n+\n+\n+    BufferState setLength(long newLength) {\n+        BufferState.length.set(segment, paddedSize, newLength);\n+        return this;\n+    }\n+    BufferState setMagic() {\n+        BufferState.magic1.set(segment, paddedSize, MAGIC);\n+        BufferState.magic2.set(segment, paddedSize, MAGIC);\n+        return this;\n+    }\n+\n+    public BufferState assignBits(int bits) {\n+        BufferState.bits.set(segment, paddedSize, bits);\n+        return this;\n+    }\n+\n+    public BufferState and(int bitz) {\n+        BufferState.bits.set(segment, paddedSize, getBits() & bitz);\n+        return this;\n+    }\n+\n+    public BufferState or(int bitz) {\n+        BufferState.bits.set(segment, paddedSize, getBits() | bitz);\n+        return this;\n+    }\n+\n+    public BufferState xor(int bitz) {\n+        \/\/ if getBits() = 0b0111 (7) and bitz = 0b0100 (4) xored = 0x0011 3\n+        \/\/ if getBits() = 0b0011 (3) and bitz = 0b0100 (4) xored = 0x0111 7\n+        BufferState.bits.set(segment, paddedSize, getBits() ^ bitz);\n+        return this;\n+    }\n+\n+    public BufferState andNot(int bitz) {\n+        \/\/ if getBits() = 0b0111 (7) and bitz = 0b0100 (4) andNot = 0b0111 & 0b1011 = 0x0011 3\n+        \/\/ if getBits() = 0b0011 (3) and bitz = 0b0100 (4) andNot = 0b0011 & 0b1011 = 0x0011 3\n+        BufferState.bits.set(segment, paddedSize, getBits() & ~bitz);\n+        return this;\n+    }\n+\n+    public int getState() {\n+        return (Integer)BufferState.state.get(segment, paddedSize);\n+    }\n+    public String getStateString(){\n+        return stateNames[getState()];\n+    }\n+    public int getBits() {\n+        return (Integer) BufferState.bits.get(segment, paddedSize);\n+    }\n+\n+    public MemorySegment getVendorPtr() {\n+        return (MemorySegment) BufferState.vendorPtr.get(segment, paddedSize);\n+    }\n+\n+    public void setVendorPtr(MemorySegment vendorPtr) {\n+        BufferState.vendorPtr.set(segment, paddedSize, vendorPtr);\n+    }\n+\n+    public boolean all(int bitz) {\n+        return (getBits() & bitz) == bitz;\n+    }\n+\n+    public boolean any(int bitz) {\n+        return (getBits() & bitz) != 0;\n+    }\n+\n+    public BufferState setHostDirty(boolean dirty) {\n+        if (dirty) {\n+            or(BIT_HOST_DIRTY);\n+        } else {\n+            andNot(BIT_HOST_DIRTY);\n+        }\n+        return this;\n+    }\n+\n+    public BufferState setHostChecked(boolean checked) {\n+        if (checked) {\n+            or(BIT_HOST_CHECKED);\n+        } else {\n+            andNot(BIT_HOST_CHECKED); \/\/ this is wrong we want bits&=!BIT_DEVICE_DIRTY\n+        }\n+        return this;\n+    }\n+\n+    public BufferState setDeviceDirty(boolean dirty) {\n+        if (dirty) {\n+            or(BIT_DEVICE_DIRTY);\n+        } else {\n+            andNot(BIT_DEVICE_DIRTY); \/\/ this is wrong we want bits&=!BIT_DEVICE_DIRTY\n+        }\n+        return this;\n+    }\n+\n+    public boolean isHostNew() {\n+        return all(BIT_HOST_NEW);\n+    }\n+\n+    public boolean isHostDirty() {\n+        return all(BIT_HOST_DIRTY);\n+    }\n+\n+    public boolean isHostChecked() {\n+        return all(BIT_HOST_CHECKED);\n+    }\n+\n+    public boolean isHostNewOrDirty() {\n+        return all(BIT_HOST_NEW | BIT_HOST_DIRTY);\n+    }\n+\n+    public boolean isDeviceDirty() {\n+        return all(BIT_DEVICE_DIRTY);\n+    }\n+\n+    public BufferState clearHostChecked() {\n+        return xor(BIT_HOST_CHECKED);\n+    }\n+\n+    public BufferState clearDeviceDirty() {\n+        return xor(BIT_DEVICE_DIRTY);\n+    }\n+\n+    public BufferState resetHostDirty() {\n+        return xor(BIT_HOST_DIRTY);\n+    }\n+\n+    public BufferState resetHostNew() {\n+        return xor(BIT_HOST_NEW);\n+    }\n+\n+    public long magic1() {\n+        return (Long) BufferState.magic1.get(segment, paddedSize);\n+    }\n+\n+    public long magic2() {\n+        return (Long) BufferState.magic2.get(segment, paddedSize);\n+    }\n+\n+    public boolean ok() {\n+        return MAGIC == magic1() && MAGIC == magic2();\n+    }\n+\n+    static String paddedString(int bits) {\n+        String s = Integer.toBinaryString(bits);\n+        String s32 = \"                                  \";\n+        return s32.substring(0, s32.length() - s.length()) + s;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder builder = new StringBuilder();\n+        if (ok()) {\n+            builder.append(\"State:ok\").append(\"\\n\");\n+            builder.append(\"State:Bits:\").append(paddedString(getBits()));\n+            if (all(BIT_HOST_DIRTY)) {\n+                builder.append(\",\").append(\"HOST_DIRTY\");\n+            }\n+            if (all(BIT_DEVICE_DIRTY)) {\n+                builder.append(\",\").append(\"DEVICE_DIRTY\");\n+            }\n+            if (all(BIT_HOST_NEW)) {\n+                builder.append(\",\").append(\"HOST_NEW\");\n+            }\n+            var vendorPtr = getVendorPtr();\n+            builder.append(\",\").append(\"VENDOR_PTR:\").append(Long.toHexString(vendorPtr.address()));\n+            builder.append(\"\\n\");\n+\n+\n+        } else {\n+            builder.append(\"State: not ok\").append(\"\\n\");\n+        }\n+        return builder.toString();\n+    }\n+\n+\n+}\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/BufferState.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"},{"patch":"@@ -38,1 +38,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -331,1 +330,1 @@\n-     *}\n+     * }\n@@ -347,219 +346,0 @@\n-\n-\n-        \/*\n-\n-\n-         See backend_ffi_shared\/include\/shared.h\n-\n-         Make sure the final static values below match the #defines\n-          \/\/ hat iface buffer bitz\n-        \/\/ hat iface bffa   bitz\n-        \/\/ 4a7 1face bffa   b175\n-\n-\n-\n-        struct state{\n-           long magic1; \/\/ MAGIC\n-           int bits;\n-           int mode;\n-           void * vendorPtr; \/\/ In OpenCL this points to native OpenCL::Buffer\n-           long magic2; \/\/ MAGIC\n-        }\n-         *\/\n-\n-    record BufferState(MemorySegment segment, long paddedSize) {\n-        public static final long alignment = ValueLayout.JAVA_LONG.byteSize();\n-        \/\/ hat iface buffer bitz\n-        \/\/ hat iface bffa   bitz\n-        \/\/ 4a7 1face bffa   b175\n-        public static final long MAGIC = 0x4a71facebffab175L;\n-        public static int NONE = 0;\n-        public static int BIT_HOST_NEW = 1<<0;\n-        public static int BIT_DEVICE_NEW = 1<<1;\n-        public static int BIT_HOST_DIRTY = 1<<2;\n-        public static int BIT_DEVICE_DIRTY = 1<<3;\n-        public static int BIT_HOST_CHECKED = 1<<4;\n-\n-        static final MemoryLayout stateMemoryLayout = MemoryLayout.structLayout(\n-                ValueLayout.JAVA_LONG.withName(\"magic1\"),\n-                        ValueLayout.JAVA_INT.withName(\"bits\"),\n-                        ValueLayout.JAVA_INT.withName(\"unused\"),\n-                        ValueLayout.ADDRESS.withName(\"vendorPtr\"),\n-                ValueLayout.JAVA_LONG.withName(\"magic2\")\n-        ).withName(\"state\");\n-\n-        static long byteSize(){\n-            return stateMemoryLayout.byteSize();\n-        }\n-\n-        static final VarHandle magic1 = stateMemoryLayout.varHandle(\n-                MemoryLayout.PathElement.groupElement(\"magic1\")\n-        );\n-        static final VarHandle bits = stateMemoryLayout.varHandle(\n-                MemoryLayout.PathElement.groupElement(\"bits\")\n-        );\n-\n-        static final VarHandle magic2 = stateMemoryLayout.varHandle(\n-                MemoryLayout.PathElement.groupElement(\"magic2\")\n-        );\n-\n-        static final VarHandle vendorPtr = stateMemoryLayout.varHandle(\n-                MemoryLayout.PathElement.groupElement(\"vendorPtr\")\n-        );\n-\n-        public static long getLayoutSizeAfterPadding(GroupLayout layout) {\n-            return layout.byteSize() +\n-                    ((layout.byteSize() % BufferState.alignment) == 0 ? 0 : BufferState.alignment - (layout.byteSize() % BufferState.alignment));\n-        }\n-\n-        public static <T> BufferState of(T t) {\n-            Buffer buffer = (Buffer) Objects.requireNonNull(t);\n-            MemorySegment s = Buffer.getMemorySegment(buffer);\n-            return new BufferState(s,s.byteSize()- BufferState.byteSize());\n-        }\n-\n-\n-        BufferState setMagic(){\n-            BufferState.magic1.set(segment, paddedSize, MAGIC);\n-            BufferState.magic2.set(segment, paddedSize, MAGIC);\n-            return this;\n-        }\n-\n-        public BufferState assignBits(int bits) {\n-            BufferState.bits.set(segment, paddedSize, bits);\n-            return this;\n-        }\n-        public BufferState and(int bitz) {\n-            BufferState.bits.set(segment, paddedSize, getBits()&bitz);\n-            return this;\n-        }\n-        public BufferState or(int bitz) {\n-            BufferState.bits.set(segment, paddedSize, getBits()|bitz);\n-            return this;\n-        }\n-\n-        public BufferState xor(int bitz) {\n-             \/\/ if getBits() = 0b0111 (7) and bitz = 0b0100 (4) xored = 0x0011 3\n-             \/\/ if getBits() = 0b0011 (3) and bitz = 0b0100 (4) xored = 0x0111 7\n-            BufferState.bits.set(segment, paddedSize, getBits()^bitz);\n-            return this;\n-        }\n-\n-        public BufferState andNot(int bitz) {\n-            \/\/ if getBits() = 0b0111 (7) and bitz = 0b0100 (4) andNot = 0b0111 & 0b1011 = 0x0011 3\n-            \/\/ if getBits() = 0b0011 (3) and bitz = 0b0100 (4) andNot = 0b0011 & 0b1011 = 0x0011 3\n-            BufferState.bits.set(segment, paddedSize, getBits()&~bitz);\n-            return this;\n-        }\n-\n-\n-        public int getBits() {\n-            return (Integer) BufferState.bits.get(segment, paddedSize);\n-        }\n-        public MemorySegment getVendorPtr(){return (MemorySegment) BufferState.vendorPtr.get(segment, paddedSize);}\n-        public void setVendorPtr(MemorySegment vendorPtr){BufferState.vendorPtr.set(segment, paddedSize,vendorPtr);}\n-        public boolean all(int bitz) {\n-            return (getBits()&bitz)==bitz;\n-        }\n-        public boolean any(int bitz) {\n-            return (getBits()&bitz)!=0;\n-        }\n-        public BufferState setHostDirty(boolean dirty) {\n-            if (dirty){\n-                or(BIT_HOST_DIRTY);\n-            }else{\n-                andNot(BIT_HOST_DIRTY);\n-            }\n-            return this;\n-        }\n-        public BufferState setHostChecked(boolean checked) {\n-            if (checked){\n-                or(BIT_HOST_CHECKED);\n-            }else{\n-                andNot(BIT_HOST_CHECKED); \/\/ this is wrong we want bits&=!BIT_DEVICE_DIRTY\n-            }\n-            return this;\n-        }\n-        public BufferState setDeviceDirty(boolean dirty) {\n-            if (dirty){\n-                or(BIT_DEVICE_DIRTY);\n-            }else{\n-                andNot(BIT_DEVICE_DIRTY); \/\/ this is wrong we want bits&=!BIT_DEVICE_DIRTY\n-            }\n-            return this;\n-        }\n-        public boolean isHostNew() {\n-            return all(BIT_HOST_NEW);\n-        }\n-        public boolean isHostDirty() {\n-            return all(BIT_HOST_DIRTY);\n-        }\n-        public boolean isHostChecked() {\n-            return all(BIT_HOST_CHECKED);\n-        }\n-        public boolean isHostNewOrDirty() {\n-            return all(BIT_HOST_NEW|BIT_HOST_DIRTY);\n-        }\n-        public boolean isDeviceDirty() {\n-            return all(BIT_DEVICE_DIRTY);\n-        }\n-        public BufferState clearHostChecked() {\n-            return xor(BIT_HOST_CHECKED);\n-        }\n-        public BufferState clearDeviceDirty() {\n-            return xor(BIT_DEVICE_DIRTY);\n-        }\n-        public BufferState resetHostDirty() {\n-            return xor(BIT_HOST_DIRTY);\n-        }\n-        public BufferState resetHostNew() {\n-            return xor(BIT_HOST_NEW);\n-        }\n-\n-        public long magic1() {\n-            return (Long) BufferState.magic1.get(segment, paddedSize);\n-        }\n-\n-        public long magic2() {\n-            return (Long) BufferState.magic2.get(segment, paddedSize);\n-        }\n-\n-        public boolean ok() {\n-            return MAGIC == magic1() && MAGIC == magic2();\n-        }\n-\n-        static String paddedString(int bits) {\n-            String s = Integer.toBinaryString(bits);\n-            String s32 = \"                                  \";\n-            return s32.substring(0,s32.length()-s.length())+s;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder builder = new StringBuilder();\n-            if (ok()){\n-                builder.append(\"State:ok\").append(\"\\n\");\n-                builder.append(\"State:Bits:\").append(paddedString(getBits()));\n-                if (all(BIT_HOST_DIRTY)){\n-                    builder.append(\",\").append(\"HOST_DIRTY\");\n-                }\n-                if (all(BIT_DEVICE_DIRTY)){\n-                    builder.append(\",\").append(\"DEVICE_DIRTY\");\n-                }\n-                if (all(BIT_HOST_NEW)){\n-                    builder.append(\",\").append(\"HOST_NEW\");\n-                }\n-                var vendorPtr = getVendorPtr();\n-                builder.append(\",\").append(\"VENDOR_PTR:\").append(Long.toHexString(vendorPtr.address()));\n-                builder.append(\"\\n\");\n-\n-\n-            }else{\n-                builder.append(\"State: not ok\").append(\"\\n\");\n-            }\n-            return builder.toString();\n-        }\n-\n-\n-    }\n-\n@@ -572,1 +352,1 @@\n-        new BufferState(segment, BufferState.getLayoutSizeAfterPadding(layout())).setMagic().assignBits(BufferState.BIT_HOST_NEW| BufferState.BIT_HOST_DIRTY);\n+        new BufferState(segment, BufferState.getLayoutSizeAfterPadding(layout())).setMagic().setLength(layout().byteSize()).setState(BufferState.NEW_STATE).assignBits(BufferState.BIT_HOST_NEW| BufferState.BIT_HOST_DIRTY);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":2,"deletions":222,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -471,3 +471,3 @@\n-       \/\/ public Stream<DirEntry> subDirs(Predicate<DirEntry> predicate) {\n-        \/\/    return subDirs().filter(predicate);\n-       \/\/ }\n+     \/\/   public Stream<DirEntry> subDirs(Predicate<DirEntry> predicate) {\n+       \/\/     return subDirs().filter(predicate);\n+      \/\/  }\n","filename":"hat\/hat\/Script.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  var extractions = hatDir.existingDir(\"extractions\");\n+  Script.DirEntry extractions = hatDir.existingDir(\"extractions\");\n@@ -140,1 +140,1 @@\n-      .subDirs(extraction -> !extraction.matches(\"^.*(target)$\")).filter(dir -> capabilities.capabilityIsAvailable(dir.fileName())).toList();\n+      .subDirs().filter(extraction -> !extraction.matches(\"^.*(target)$\")).filter(dir -> capabilities.capabilityIsAvailable(dir.fileName())).toList();\n@@ -146,1 +146,1 @@\n-      .modules(extractionDirs.stream().map(PathHolder::fileName).toList())\n+      .modules(extractionDirs.stream().map(Script.PathHolder::fileName).toList())\n@@ -206,1 +206,1 @@\n-  var exampleDirs = examples.subDirs(example -> !example.matches(\"^.*(experiments|target|nbody|.idea)$\")).toList();\n+  var exampleDirs = examples.subDirs().filter(example -> !example.matches(\"^.*(experiments|target|nbody|.idea)$\")).toList();\n@@ -214,1 +214,1 @@\n-      .modules(exampleDirs.stream().map(PathHolder::fileName).toList())\n+      .modules(exampleDirs.stream().map(Script.PathHolder::fileName).toList())\n@@ -236,1 +236,1 @@\n-  var backendDirs = backends.subDirs(backend -> !backend.matches(\"^.*(jextracted|target|.idea)$\")).toList();\n+  var backendDirs = backends.subDirs().filter(backend -> !backend.matches(\"^.*(jextracted|target|.idea)$\")).toList();\n@@ -251,1 +251,1 @@\n-    var ffiBackendDirs = ffiBackend.subDirs(backend -> !backend.matches(\"^.*(hip|spirv|shared|openclx|target|.idea)$\")).toList();\n+    var ffiBackendDirs = ffiBackend.subDirs().filter(backend -> !backend.matches(\"^.*(hip|spirv|shared|openclx|target|.idea)$\")).toList();\n@@ -258,1 +258,1 @@\n-        .modules(ffiBackendDirs.stream().map(PathHolder::fileName).toList())\n+        .modules(ffiBackendDirs.stream().map(Script.PathHolder::fileName).toList())\n@@ -298,1 +298,1 @@\n-    var javaBackendDirs = javaBackend.subDirs(backend -> !backend.matches(\"^.*(target|.idea)$\")).toList();\n+    var javaBackendDirs = javaBackend.subDirs().filter(backend -> !backend.matches(\"^.*(target|.idea)$\")).toList();\n@@ -305,1 +305,1 @@\n-        .modules(javaBackendDirs.stream().map(PathHolder::fileName).toList())\n+        .modules(javaBackendDirs.stream().map(Script.PathHolder::fileName).toList())\n","filename":"hat\/hat\/mkpoms.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 24 hat\/run.java  java-mt\n","filename":"hat\/hat\/run-java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 24 hat\/run.java ffi-opencl \n","filename":"hat\/hat\/run-opencl","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.ifacemapper.SegmentMapper;\n+import hat.ifacemapper.BufferState;\n@@ -246,1 +246,1 @@\n-                                SegmentMapper.BufferState bufferState = SegmentMapper.BufferState.of(buffer);\n+                                BufferState bufferState = BufferState.of(buffer);\n@@ -346,1 +346,1 @@\n-                                SegmentMapper.BufferState bufferState = SegmentMapper.BufferState.of(buffer);\n+                                BufferState bufferState = BufferState.of(buffer);\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/CLPlatform.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}