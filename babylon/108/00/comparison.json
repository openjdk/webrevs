{"files":[{"patch":"@@ -873,0 +873,34 @@\n+add_custom_target(violajones_headless_java DEPENDS violajones.jar\n+   COMMAND  ${DOIT}\n+     ${JAVA_HOME}\/bin\/java\n+       --enable-preview --enable-native-access=ALL-UNNAMED\n+       --class-path ${HAT_JAR}:${VIOLAJONES_JAR}:${CMAKE_SOURCE_DIR}\/backends\/shared\/services\n+       --add-exports=java.base\/jdk.internal=ALL-UNNAMED\n+       -Djava.library.path=${CMAKE_BINARY_DIR}\n+       -Dheadless=true\n+       violajones.ViolaJonesCompute\n+)\n+\n+add_custom_target(violajones_headless_opencl DEPENDS violajones.jar opencl_backend.jar opencl_backend\n+   COMMAND  ${DOIT}\n+     ${JAVA_HOME}\/bin\/java\n+       --enable-preview --enable-native-access=ALL-UNNAMED\n+       --class-path ${HAT_JAR}:${VIOLAJONES_JAR}:${OPENCL_BACKEND_JAR}\n+       --add-exports=java.base\/jdk.internal=ALL-UNNAMED\n+       -Djava.library.path=${CMAKE_BINARY_DIR}\n+       -Dheadless=true\n+       violajones.ViolaJonesCompute\n+)\n+\n+add_custom_target(violajones_headless_cuda DEPENDS violajones.jar cuda_backend.jar cuda_backend\n+   COMMAND  ${DOIT}\n+     ${JAVA_HOME}\/bin\/java\n+       --enable-preview --enable-native-access=ALL-UNNAMED\n+       --class-path ${HAT_JAR}:${VIOLAJONES_JAR}:${CUDA_BACKEND_JAR}\n+       --add-exports=java.base\/jdk.internal=ALL-UNNAMED\n+       -Djava.library.path=${CMAKE_BINARY_DIR}\n+       -Dheadless=true\n+       violajones.ViolaJonesCompute\n+)\n+\n+\n","filename":"hat\/CMakeLists.txt","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -61,2 +61,4 @@\n-        for (XYList.XY xy : path) {\n-            polygon.addPoint(xy.x - path.x1 + 1, xy.y - path.y1 + 1);\n+        for (int i = 0; i < path.length(); i++) {\n+\n+        XYList.XY xy= (XYList.XY)path.xy(i);\n+            polygon.addPoint(xy.x() - path.x1 + 1, xy.y() - path.y1 + 1);\n@@ -201,1 +203,1 @@\n-        if (selection.path.size != 0) {\n+        if (selection.path.length() != 0) {\n@@ -217,2 +219,9 @@\n-                    if (!selection.contains(x, y)) {\n-                        extractCurve(comp, selection, x - selection.path.x1, y - selection.path.y1);\n+                    if (!selection.contains(x, y)) { \/\/ don't search inside the area we are healing\n+                        int sdx = x - selection.path.x1;\n+                        int sdy = y - selection.path.y1;\n+\n+                        for (int i=0;i<selection.path.length();i++){\n+                            XYList.XY xy= (XYList.XY)selection.path.xy(i);\n+                            comp.setRGB(xy.idx(), selection.imageData.data[sdy * selection.imageData.width + sdx + xy.y() * selection.imageData.width + xy.x()]);\n+                        }\n+\n@@ -243,2 +252,3 @@\n-        for (XYList.XY xy : selection.path) {\n-            rgbList.addRGB(selection.imageData.data[xy.y * selection.imageData.width + xy.x]);\n+        for (int i=0;i<selection.path.length();i++){\n+        XYList.XY xy= (XYList.XY)selection.path.xy(i);\n+            rgbList.addRGB(selection.imageData.data[xy.y() * selection.imageData.width + xy.x()]);\n@@ -249,1 +259,1 @@\n-    static RGBList extractCurve(RGBList rgbList, Selection selection,\n+    static void extractCurve(RGBList rgbList, Selection selection,\n@@ -252,3 +262,3 @@\n-\n-        for (XYList.XY xy : selection.path) {\n-            rgbList.setRGB(xy.idx, selection.imageData.data[dy * selection.imageData.width + dx + xy.y * selection.imageData.width + xy.x]);\n+        for (int i=0;i<selection.path.length();i++){\n+            XYList.XY xy= (XYList.XY)selection.path.xy(i);\n+            rgbList.setRGB(xy.idx(), selection.imageData.data[dy * selection.imageData.width + dx + xy.y() * selection.imageData.width + xy.x()]);\n@@ -256,1 +266,1 @@\n-        return rgbList;\n+\n","filename":"hat\/examples\/heal\/src\/java\/heal\/HealingBrush.java","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -133,2 +133,3 @@\n-                for (XYList.XY p : matchPath){\n-                    g.drawRect(p.x, p.y, 4, 4);\n+                for (int i=0; i<matchPath.length();i++){\n+                XYList.XY p = (XYList.XY)matchPath.xy(i);\n+                    g.drawRect(p.x(), p.y(), 4, 4);\n","filename":"hat\/examples\/heal\/src\/java\/heal\/HealingBrushDisplay.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -69,2 +69,3 @@\n-        for (XY xy:path){\n-            add(xy.x+offsetx, xy.y+offsety);\n+        for (int i=0;i<length();i++){\n+            XY xy = (XYList.XY)xy(i);\n+            add(xy.x()+offsetx, xy.y()+offsety);\n@@ -75,2 +76,3 @@\n-        for (XY xy:this){\n-            p.addPoint(xy.x, xy.y);\n+        for (int i=0;i<length();i++){\n+            XY xy = (XYList.XY)xy(i);\n+            p.addPoint(xy.x(), xy.y());\n@@ -82,2 +84,1 @@\n-\n-        add(xy[size*2-2],xy[size*2-1], x, y);\n+        add(xy[length()*2-2],xy[length()*2-1], x, y);\n@@ -88,1 +89,1 @@\n-        xy = Arrays.copyOf(xy, size * 2);\n+        xy = Arrays.copyOf(xy, length() * 2);\n","filename":"hat\/examples\/heal\/src\/java\/heal\/Path.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package heal;\n+\n+import hat.Accelerator;\n+import hat.buffer.Table;\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+public interface S32RGBTable extends Table<S32RGBTable.RGB> {\n+\n+    interface RGB {\n+        StructLayout layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"r\"),\n+                JAVA_INT.withName(\"g\"),\n+                JAVA_INT.withName(\"b\")\n+        ).withName(\"RGB\");\n+        int r();\n+\n+        int g();\n+\n+        int b();\n+\n+        void r(int r);\n+        void g(int g);\n+\n+        void b(int b);\n+    }\n+\n+    static S32RGBTable create(Accelerator accelerator, int length) {\n+        S32RGBTable table = SegmentMapper.of(accelerator.lookup, S32RGBTable.class,\n+                JAVA_INT.withName(\"length\"),\n+\n+                MemoryLayout.sequenceLayout(length, S32RGBTable.RGB.layout).withName(\"rgb\")\n+        ).allocate(accelerator.backend.arena());\n+        table.length(length);\n+        return table;\n+    }\n+\n+\n+    RGB rgb(long idx);\n+\n+}\n","filename":"hat\/examples\/heal\/src\/java\/heal\/S32RGBTable.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package heal;\n+\n+import hat.Accelerator;\n+import hat.buffer.Table;\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+public interface S32XYTable extends Table<S32XYTable.XY> {\n+    interface XY {\n+        StructLayout layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"idx\"),\n+                JAVA_INT.withName(\"x\"),\n+                JAVA_INT.withName(\"y\")\n+        ).withName(\"XY\");\n+        int x();\n+        int y();\n+        int idx();\n+        void y(int y);\n+        void x(int x);\n+        void idx(int idx);\n+    }\n+\n+    static S32XYTable create(Accelerator accelerator, int length) {\n+        S32XYTable table = SegmentMapper.of(accelerator.lookup, S32XYTable.class,\n+                JAVA_INT.withName(\"length\"),\n+                MemoryLayout.sequenceLayout(length, S32XYTable.XY.layout).withName(\"xy\")\n+        ).allocate(accelerator.backend.arena());\n+        table.length(length);\n+        return table;\n+    }\n+\n+    XY xy(long idx);\n+}\n","filename":"hat\/examples\/heal\/src\/java\/heal\/S32XYTable.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -48,1 +48,0 @@\n-import java.util.Iterator;\n@@ -50,1 +49,1 @@\n-class XYList implements Iterable<XYList.XY>{\n+class XYList implements S32XYTable {\n@@ -53,2 +52,9 @@\n-    final static int X= 0;\n-    final static int Y= 1;\n+    final static int Xidx = 0;\n+    final static int Yidx = 1;\n+    private int length;\n+    protected int[] xy = new int[INIT*STRIDE];\n+    private XY cursor = new XY(this);\n+    @Override\n+    public S32XYTable.XY xy(long idx) {\n+        return cursor.set((int) idx);\n+    }\n@@ -56,4 +62,4 @@\n-    public class XY implements Iterator<XY>{\n-        int idx=-1;\n-        int x;\n-        int y;\n+    @Override\n+    public int length() {\n+        return length;\n+    }\n@@ -61,4 +67,4 @@\n-        @Override\n-        public boolean hasNext() {\n-            return idx+1<size;\n-        }\n+    @Override\n+    public void length(int length) {\n+        this.length=length;\n+    }\n@@ -66,0 +72,6 @@\n+    public static class XY implements S32XYTable.XY{\n+        XYList xyList;\n+        private int idx=-1;\n+        public XY(XYList table) {\n+            this.xyList=table;\n+        }\n@@ -68,2 +80,0 @@\n-            x = xy[idx*STRIDE+X];\n-            y = xy[idx*STRIDE+Y];\n@@ -74,4 +84,22 @@\n-        public XY next() {\n-            idx++;\n-            set(idx);\n-            return this;\n+        public int x() {\n+            return xyList.xy[idx*STRIDE+ Xidx];\n+        }\n+\n+        @Override\n+        public int y() {\n+            return xyList.xy[idx*STRIDE+ Yidx];\n+        }\n+\n+        @Override\n+        public int idx() {\n+            return idx;\n+        }\n+\n+        @Override\n+        public void y(int y) {\n+            xyList.xy[idx*STRIDE+ Yidx] =y;\n+        }\n+\n+        @Override\n+        public void x(int x) {\n+            xyList.xy[idx*STRIDE+ Yidx]=x;\n@@ -81,2 +109,2 @@\n-        public void remove() {\n-           throw new IllegalStateException(\"remove not supported\");\n+        public void idx(int idx) {\n+            this.idx = idx;\n@@ -86,2 +114,1 @@\n-    int size;\n-    int xy[] = new int[INIT*STRIDE];\n+\n@@ -89,1 +116,1 @@\n-        if (size*STRIDE==xy.length){\n+        if (length*STRIDE==xy.length){\n@@ -92,3 +119,3 @@\n-        xy[size*STRIDE+X]=x;\n-        xy[size*STRIDE+Y]=y;\n-        size++;\n+        xy[length*STRIDE+ Xidx]=x;\n+        xy[length*STRIDE+ Yidx]=y;\n+        length++;\n@@ -100,1 +127,1 @@\n-    XYList(int x, int y){\n+   XYList(int x, int y){\n@@ -103,6 +130,0 @@\n-\n-\n-    @Override\n-    public Iterator<XY> iterator() {\n-        return new XY();\n-    }\n","filename":"hat\/examples\/heal\/src\/java\/heal\/XYList.java","additions":54,"deletions":33,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -49,286 +49,0 @@\n-    @CodeReflection\n-    public static int b2i(int v) {\n-        return v < 0 ? 256 + v : v;\n-    }\n-\n-    @CodeReflection\n-    public static int grey(int r, int g, int b) {\n-        return (29 * b2i(r) + 60 * b2i(g) + 11 * b2i(b)) \/ 100;\n-    }\n-\n-    @CodeReflection\n-    public static void rgbToGrey(int id, RgbS08x3Image rgbImage, F32Array2D greyImage) {\n-        byte r = rgbImage.data(id * 3 + 0);\n-        byte g = rgbImage.data(id * 3 + 1);\n-        byte b = rgbImage.data(id * 3 + 2);\n-        greyImage.array(id, grey(r, g, b));\n-    }\n-\n-    \/*\n-     * A pure java implementation so no @CodeReflection\n-     *\/\n-    static long javaRgbToGreyScale(RgbS08x3Image rgb, F32Array2D grey) {\n-        long start = System.currentTimeMillis();\n-        int size = grey.width() * grey.height();\n-\n-        for (int i = 0; i < size; i++) {\n-            rgbToGrey(i, rgb, grey);\n-        }\n-\n-        return System.currentTimeMillis() - start;\n-    }\n-\n-    @CodeReflection\n-    public static void rgbToGreyKernel(KernelContext kc, RgbS08x3Image rgbImage, F32Array2D greyImage) {\n-        if (kc.x < kc.maxX){\n-           rgbToGrey(kc.x, rgbImage, greyImage);\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void integralCol(int id, int width, F32Array2D greyImage, F32Array2D integral, F32Array2D integralSq) {\n-        float greyValue = greyImage.array(id);\n-        float greyValueSq = greyValue * greyValue;\n-        integralSq.array(id, greyValueSq + integralSq.array(id - width));\n-        integral.array(id, greyValue + integral.array(id - width));\n-    }\n-\n-    @CodeReflection\n-    public static void integralColKernel(KernelContext kc, F32Array2D greyImage, F32Array2D integral, F32Array2D integralSq) {\n-        if (kc.x <kc.maxX){  \/\/ kc.maxX = imageWidth\n-           int x = kc.x;\n-           int width = kc.maxX;\n-           int height = greyImage.height();\n-           for (int y = 1; y < height; y++) {\n-               int id =(y * width) + x;\n-               integralCol(id, width, greyImage, integral, integralSq);\n-           }\n-        }\n-    }\n-\n-    public static void javaIntegralCol(F32Array2D greyImage, F32Array2D integral, F32Array2D integralSq) {\n-        int height = greyImage.height();\n-        int width = greyImage.width();\n-        for (int x = 0; x<width; x++){\n-           for (int y = 1; y < height; y++) {\n-               int id =(y * width) + x;\n-               integralCol(id, width, greyImage, integral, integralSq);\n-           }\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void integralRow(int id, F32Array2D integral, F32Array2D integralSq) {\n-        integral.array(id, integral.array(id) + integral.array(id - 1));\n-        integralSq.array(id, integralSq.array(id) + integralSq.array(id - 1));\n-    }\n-\n-    @CodeReflection\n-    public static void integralRowKernel(KernelContext kc, F32Array2D integral, F32Array2D integralSq) {\n-        if (kc.x <kc.maxX){  \/\/ kc.maxX == imageHeight\n-           int y = kc.x;\n-           int width = integral.width();\n-           for (int x = 1; x < width; x++) {\n-               int id =(y * width) + x;\n-               integralRow(id, integral, integralSq);\n-           }\n-        }\n-    }\n-    public static void javaIntegralRow(F32Array2D integral, F32Array2D integralSq) {\n-        int height = integral.height();\n-        int width = integral.width();\n-        for (int y = 0; y<height; y++){\n-           for (int x = 1; x < width; x++) {\n-               int id =(y * width) + x;\n-               integralRow(id, integral, integralSq);\n-           }\n-        }\n-    }\n-\n-    \/*\n-     * A pure java implementation so no @CodeReflection\n-     *\/\n-    public static long javaCreateIntegralImage(F32Array2D greyFloats, F32Array2D integral, F32Array2D integralSq) {\n-        long start = System.currentTimeMillis();\n-        int width = greyFloats.width();\n-        int height = greyFloats.height();\n-\n-        \/\/ The col pass creates both the integral and integralSq cols and populate the 'square'\n-        for (int x = 0; x < width; x++) {\n-            for (int y = 1; y < height; y++) {\n-                integralCol((y * width) + x, width, greyFloats, integral, integralSq);\n-            }\n-        }\n-\n-        for (int y = 0; y < height; y++) {\n-            for (int x = 1; x < width; x++) {\n-                integralRow((y * width) + x, integral, integralSq);\n-            }\n-        }\n-        return System.currentTimeMillis() - start;\n-    }\n-\n-    @CodeReflection\n-    static long xyToLong(int imageWidth, int x, int y) {\n-        return (long) y * imageWidth + x;\n-    }\n-\n-    @CodeReflection\n-    static float gradient(F32Array2D integralOrIntegralSqImage, int x, int y, int w, int h) {\n-        int imageWidth = integralOrIntegralSqImage.width();\n-        float A = integralOrIntegralSqImage.array(xyToLong(imageWidth, x, y));\n-        float D = integralOrIntegralSqImage.array(xyToLong(imageWidth, x + w, y + h));   \/\/  [A]-------[B]\n-        float C = integralOrIntegralSqImage.array(xyToLong(imageWidth, x, y + h));       \/\/   |         |\n-        float B = integralOrIntegralSqImage.array(xyToLong(imageWidth, x + w, y));       \/\/  [C]-------[D]\n-        return D - B - C + A;\n-    }\n-\n-\n-    @CodeReflection\n-    static boolean isAFaceStage(\n-            long gid,\n-            float scale,\n-            float invArea,\n-            int x,\n-            int y,\n-            float vnorm,\n-            F32Array2D integral,\n-            Cascade.Stage stage,\n-            Cascade cascade) {\n-        float sumOfThisStage = 0;\n-        int startTreeIdx = stage.firstTreeId();\n-        int endTreeIdx = startTreeIdx + stage.treeCount();\n-        for (int treeIdx = startTreeIdx; treeIdx < endTreeIdx; treeIdx++) {\n-            \/\/ Todo: Find a way to iterate which is interface mapped segment friendly.\n-            Cascade.Tree tree = cascade.tree(treeIdx);\n-            Cascade.Feature feature = cascade.feature(tree.firstFeatureId());\n-\n-            while (feature != null) {\n-                float featureGradientSum = .0f;\n-                \/\/ features have 1, 2 or 3 rects to scan  we might be best to unroll\n-                \/\/ but we made sure that x,y,w,h and weight were all 0 for 'unused' rects.\n-                \/\/ so this is theoretically less wave divergent...\n-                for (int r = 0; r < 3; r++) {\n-                    Cascade.Feature.Rect rect = feature.rect(r);\n-                    if (rect != null) {\n-                        featureGradientSum += gradient(integral,\n-                                x + (int) (rect.x() * scale), \/\/x\n-                                y + (int) (rect.y() * scale),   \/\/y\n-                                (int) (rect.width() * scale),   \/\/w\n-                                (int) (rect.height() * scale)   \/\/h\n-                        ) * rect.weight();\n-                    }\/\/ weight is 0 for unused so should not impact featureGradientSum\n-                }\n-\n-                \/\/ Now either navigate the tree (left or right) or update the sumOfThisStage\n-                \/\/ with left or right value based on comparison with features Threshold\n-                float featureThreshold = feature.threshold();\n-                boolean isLeft = ((featureGradientSum * invArea) < (featureThreshold * vnorm));\n-                Cascade.Feature.LinkOrValue leftOrRight = isLeft ? feature.left() : feature.right();\n-                Cascade.Feature.LinkOrValue.Anon anon = leftOrRight.anon();\n-                if (leftOrRight.hasValue()) {\n-                    sumOfThisStage += anon.value(); \/\/ leftOrRight.anon().value() breaks C99 codegen\n-                    feature = null; \/\/ loop ends\n-                } else {\n-                    feature = cascade.feature(tree.firstFeatureId() + anon.featureId());\n-                }\n-            }\n-        }\n-\n-        return sumOfThisStage > stage.threshold(); \/\/ true if this looks like a face\n-    }\n-\n-    @CodeReflection\n-    public static void findFeaturesKernel(KernelContext kc,\n-                                          Cascade cascade,\n-                                          F32Array2D integral,\n-                                          F32Array2D integralSq,\n-                                          ScaleTable scaleTable,\n-                                          ResultTable resultTable\n-\n-    ) {\n-\n-        if (kc.x < scaleTable.multiScaleAccumulativeRange()) {\n-            \/\/ We need to determine the scale information for a given gid.\n-            \/\/ we check each scale in the scale table and check if our gid is\n-            \/\/ covered by the scale.\n-            int scalc = 0;\n-            ScaleTable.Scale scale = scaleTable.scale(scalc++);\n-            while (kc.x >= scale.accumGridSizeMax()) {\n-                scale = scaleTable.scale(scalc++);\n-            }\n-\n-            \/\/ Now we need to convert our scale relative git to an x,y,w,h\n-            int scaleGid = kc.x - scale.accumGridSizeMin();\n-\n-            int x = (int) ((scaleGid % scale.gridWidth()) * scale.scaledXInc());\n-            int y = (int) ((scaleGid \/ scale.gridWidth()) * scale.scaledYInc());\n-            int w = scale.scaledFeatureWidth();\n-            int h = scale.scaledFeatureHeight();\n-\n-            \/\/ We now have  a unique x,y,w,h and scale value which we use to walk the cascade\n-\n-\n-            float integralGradient = gradient(integral, x, y, w, h) * scale.invArea();\n-            float integralSqGradient = gradient(integralSq, x, y, w, h) * scale.invArea();\n-            float vnorm = integralSqGradient - integralGradient * integralGradient;\n-            vnorm = (vnorm > 1) ? (float) Math.sqrt(vnorm) : 1;\n-\n-            \/\/ If we had converted greyScale of original image into an edge highlighted image\n-            \/\/ (via soebel filter) it is possible to determine that the area x,y,x+w,x+h is\n-            \/\/ uninteresting based on the gradient values and vnorm. This is called 'Canny' pruning.\n-\n-            boolean stillLooksLikeAFace = true;\n-\n-            \/\/ Walk the stage list whilst each stage still resembles a face.\n-\n-            int stageCount = cascade.stageCount();\n-            for (int stagec = 0; stagec < stageCount && stillLooksLikeAFace; stagec++) {\n-                Cascade.Stage stage = cascade.stage(stagec);\n-                stillLooksLikeAFace = isAFaceStage(kc.x, scale.scaleValue(), scale.invArea(), x, y, vnorm, integral, stage, cascade);\n-            }\n-\n-            if (stillLooksLikeAFace) {\n-               int index = resultTable.atomicResultTableCountInc();\n-               if (index < resultTable.length()) {\n-                   ResultTable.Result result = resultTable.result(index);\n-                   result.x(x);\n-                   result.y(y);\n-                   result.width(w);\n-                   result.height(h);\n-               }\n-           }\n-        }\n-    }\n-\n-    @CodeReflection\n-    static public void compute(final ComputeContext cc, Cascade cascade, BufferedImage bufferedImage, RgbS08x3Image rgbS08x3Image, ResultTable resultTable) {\n-        long start = System.currentTimeMillis();\n-        int width = rgbS08x3Image.width();\n-\n-        int height = rgbS08x3Image.height();\n-        Accelerator accelerator = cc.accelerator;\n-        F32Array2D greyImage = F32Array2D.create(accelerator, width, height);\n-        \/\/javaRgbToGreyScale(rgbS08x3Image, greyImage);\n-\n-        cc.dispatchKernel(width * height, kc -> rgbToGreyKernel(kc, rgbS08x3Image, greyImage));\n-        F32Array2D integralImage = F32Array2D.create(accelerator, width, height);\n-        F32Array2D integralSqImage = F32Array2D.create(accelerator, width, height);\n-\n-        \/\/javaCreateIntegralImage(greyImage, integralImage, integralSqImage);\n-\n-        \/\/javaIntegralCol(greyImage, integralImage, integralSqImage);\n-        \/\/javaIntegralRow(integralImage, integralSqImage);\n-        cc.dispatchKernel(width, kc -> integralColKernel(kc, greyImage, integralImage, integralSqImage));\n-        cc.dispatchKernel(height, kc -> integralRowKernel(kc, integralImage, integralSqImage));\n-        \/\/ harViz.showIntegrals();\n-        ScaleTable scaleTable = ScaleTable.create(accelerator, cascade, width, height);\n-\n-        cc.dispatchKernel(scaleTable.multiScaleAccumulativeRange(), kc ->\n-                findFeaturesKernel(kc, cascade, integralImage, integralSqImage, scaleTable, resultTable));\n-        long end = System.currentTimeMillis();\n-        System.out.print(end - start);\n-        System.out.println(\"ms\");\n-        \/\/ harViz.showResults(resultTable, null, null);\n-    }\n-\n@@ -348,1 +62,4 @@\n-        HaarViewer harViz = new HaarViewer(accelerator, nasa1996, rgbImage, cascade, null, null);\n+        HaarViewer harViz = null;\n+        if (!Boolean.getBoolean(\"headless\")){\n+            harViz = new HaarViewer(accelerator, nasa1996, rgbImage, cascade, null, null);\n+        }\n@@ -354,1 +71,1 @@\n-                    ViolaJonesCompute.compute(cc, cascade, nasa1996, rgbImage, resultTable)\n+                    ViolaJonesCoreCompute.compute(cc, cascade, nasa1996, rgbImage, resultTable)\n@@ -356,1 +73,4 @@\n-            System.out.println(\"results = \"+resultTable.atomicResultTableCount());\n+            System.out.println(resultTable.atomicResultTableCount()+ \"faces found\");\n+        }\n+        if (harViz != null) {\n+            harViz.showResults(resultTable, null, null);\n@@ -358,1 +78,0 @@\n-        harViz.showResults(resultTable, null, null);\n","filename":"hat\/examples\/violajones\/src\/java\/violajones\/ViolaJonesCompute.java","additions":9,"deletions":290,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-public class ViolaJonesCompute {\n+public class ViolaJonesCoreCompute {\n@@ -335,25 +335,1 @@\n-    public static void main(String[] args) throws IOException, ParserConfigurationException, SAXException {\n-        BufferedImage nasa1996 = ImageIO.read(ViolaJones.class.getResourceAsStream(\n-               \/\/\"\/images\/team.jpg\"\n-              \/\/ \"\/images\/eggheads.jpg\"\n-              \/\/ \"\/images\/highett.jpg\"\n-             \"\/images\/Nasa1996.jpg\"\n-        ));\n-        XMLHaarCascadeModel haarCascade = XMLHaarCascadeModel.load(\n-                ViolaJonesRaw.class.getResourceAsStream(\"\/cascades\/haarcascade_frontalface_default.xml\"));\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        Cascade cascade = Cascade.create(accelerator, haarCascade);\n-        RgbS08x3Image rgbImage = RgbS08x3Image.create(accelerator, nasa1996);\n-        ResultTable resultTable = ResultTable.create(accelerator, 1000);\n-        HaarViewer harViz = new HaarViewer(accelerator, nasa1996, rgbImage, cascade, null, null);\n-\n-        \/\/System.out.println(\"Compute units \"+((NativeBackend)accelerator.backend).getGetMaxComputeUnits());\n-        for (int i = 0; i < 10; i++) {\n-            resultTable.atomicResultTableCount(0);\n-            accelerator.compute(cc ->\n-                    ViolaJonesCompute.compute(cc, cascade, nasa1996, rgbImage, resultTable)\n-            );\n-            System.out.println(\"results = \"+resultTable.atomicResultTableCount());\n-        }\n-        harViz.showResults(resultTable, null, null);\n-    }\n+\n","filename":"hat\/examples\/violajones\/src\/java\/violajones\/ViolaJonesCoreCompute.java","additions":2,"deletions":26,"binary":false,"changes":28,"previous_filename":"hat\/examples\/violajones\/src\/java\/violajones\/ViolaJonesCompute.java","status":"copied"},{"patch":"@@ -31,4 +31,4 @@\n-    default void with(int i, Consumer<T> consumer) {\n-        T t = get(i);\n-        consumer.accept(t);\n-    }\n+   \/\/ default void with(int i, Consumer<T> consumer) {\n+     \/\/   T t = get(i);\n+       \/\/ consumer.accept(t);\n+   \/\/ }\n@@ -40,1 +40,1 @@\n-    T get(int i);\n+   \/\/ T get(int i);\n","filename":"hat\/hat\/src\/java\/hat\/buffer\/Table.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}