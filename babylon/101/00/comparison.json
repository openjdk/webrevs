{"files":[{"patch":"@@ -85,0 +85,4 @@\n+add_executable(schemadump\n+        ${CMAKE_SOURCE_DIR}\/shared\/cpp\/shared.cpp\n+        ${CMAKE_SOURCE_DIR}\/shared\/cpp\/schemadump.cpp\n+)\n\\ No newline at end of file\n","filename":"hat\/backends\/CMakeLists.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,2 +119,2 @@\n-    std::cout << \"copyToDevice()\"\n-              << arg->value.buffer.sizeInBytes\n+    std::cout << \"copyToDevice()\" << arg->value.buffer.sizeInBytes\n+              << \"devptr \" << std::hex<<  (long)devicePtr <<std::dec\n@@ -126,2 +126,2 @@\n-    std::cout << \"copyFromDevice()\"\n-              << arg->value.buffer.sizeInBytes\n+    std::cout << \"copyFromDevice() \" << arg->value.buffer.sizeInBytes\n+              << \"devptr \" << std::hex<<  (long)devicePtr <<std::dec\n@@ -133,2 +133,2 @@\n-CudaBackend::CudaProgram::CudaKernel::CudaKernel(Backend::Program *program, CUfunction function)\n-        : Backend::Program::Kernel(program), function(function) {\n+CudaBackend::CudaProgram::CudaKernel::CudaKernel(Backend::Program *program,std::string name, CUfunction function)\n+        : Backend::Program::Kernel(program, name), function(function) {\n@@ -143,1 +143,1 @@\n-    std::cout << \"ndrange(\" << range << \") \" << std::endl;\n+    std::cout << \"ndrange(\" << range << \") \" << name << std::endl;\n@@ -145,0 +145,1 @@\n+    Schema::dumpSled(std::cout, argArray);\n@@ -230,1 +231,1 @@\n-    return reinterpret_cast<long>(new CudaKernel(this, function));\n+    return reinterpret_cast<long>(new CudaKernel(this, std::string(name), function));\n","filename":"hat\/backends\/cuda\/cpp\/cuda_backend.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\n","filename":"hat\/backends\/cuda\/cpp\/info.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-            CudaKernel(Backend::Program *program, CUfunction function);\n+            CudaKernel(Backend::Program *program, std::string name, CUfunction function);\n","filename":"hat\/backends\/cuda\/include\/cuda_backend.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-  \/\/  char *schema = (char*)\"args:[1:?:4+S32Array:{length:s32,array:[*:?:s32]}]\";\n-   \/\/ std::cout << \"schema = '\"<<schema<<\"'\"<<std::endl;\n-   \/\/ backend.dumpSchema(std::cout, 0, schema, nullptr);\n","filename":"hat\/backends\/opencl\/cpp\/info.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLKernel(Backend::Program *program, cl_kernel kernel)\n-        : Backend::Program::Kernel(program), kernel(kernel), eventMax(0), events(nullptr),\n+OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLKernel(Backend::Program *program, std::string name, cl_kernel kernel)\n+        : Backend::Program::Kernel(program, name), kernel(kernel), eventMax(0), events(nullptr),\n@@ -108,180 +108,0 @@\n-enum state_e {\n-    awaitingName,\n-    inName,\n-    awaitingArrayLen,\n-    haveName,\n-    inArrayLen,\n-    inAnonName,\n-    lastEnum\n-};\n-const char *stateNames[]={\n-        \"awaitingName\",\n-        \"inName\",\n-        \"awaitingArrayLen\",\n-        \"haveName\",\n-        \"inArrayLen\",\n-        \"inAnonName\",\n-        \"lastEnum\"\n-};\n-char *strduprange(char *start, char *end ){\n-    char *s = new char[end-start+1];\n-    std::memcpy(s, start, end-start);\n-    s[end-start]='\\0';\n-    return s;\n-}\n-\n-char * OpenCLBackend::dumpSchema(std::ostream &out, int depth, char *ptr, void *data){\n-\n-    state_e state = awaitingName;\n-    char *nameStart = nullptr;\n-    char *numStart = nullptr;\n-    char *indent = new char[depth*4+1];\n-    for (int i=0; i<depth*4; i++){\n-        indent[i]=' ';\n-    }\n-    indent[depth*4]='\\0';\n-    out << indent;\n-    while (ptr != nullptr && *ptr != '\\0' ){\n-       \/\/ out <<\"<\"<<stateNames[state] <<\"> with '\" <<((char)*ptr)<<\"'\";\n-        switch (state){\n-            case awaitingName:{\n-                if (*ptr=='?') {\n-                    nameStart = ptr;\n-                    state = inAnonName;\n-                    ptr++;\n-                }else if (std::isalpha(*ptr)) {\n-                    nameStart = ptr;\n-                    state = inName;\n-                    ptr++;\n-                }else{\n-                    std::cerr<<\"err \"<<\"<\"<<stateNames[state] <<\"> with '\" <<((char)*ptr)<<\"'\";\n-                    exit(1);\n-                }\n-                break;\n-            }\n-            case inName:\n-            case inAnonName:{\n-                if (state == inName && std::isalnum(*ptr) || *ptr=='_') {\n-                    ptr++;\n-                }else if (*ptr == ':') {\n-                    char *name = strduprange(nameStart, ptr);\n-                    out << \"name '\" << name << \"'\" << std::endl << indent;\n-                    delete[] name;\n-                    ptr++;\n-                    state = haveName;\n-                }else{\n-                    std::cerr<<\"err \"<<\"<\"<<stateNames[state] <<\"> with '\" <<((char)*ptr)<<\"'\";\n-                    exit(1);\n-                }\n-                break;\n-            }\n-            case haveName:{\n-                \/\/ we expect a type\n-                if (*ptr == '[') {\n-                    ptr++;\n-                    state = awaitingArrayLen;\n-                    \/\/ we expect a type\n-                }else if (*ptr == '{' ) {\n-                        ptr++;\n-                        state=awaitingName;\n-                }else if (*ptr == '<') {\n-                    ptr++;\n-                    state=awaitingName;\n-                } else{\n-                    std::cerr<<\"err \"<<\"<\"<<stateNames[state] <<\"> with '\" <<((char)*ptr)<<\"'\";\n-                    exit(1);\n-                }\n-                break;\n-            }\n-            case awaitingArrayLen:{\n-                if (std::isdigit(*ptr)) {\n-                    numStart = ptr;\n-                    ptr++;\n-                    state=inArrayLen;\n-                } else{\n-                    std::cerr<<\"err \"<<\"<\"<<stateNames[state] <<\"> with '\" <<((char)*ptr)<<\"'\";\n-                    exit(1);\n-                }\n-                break;\n-            }\n-\n-            case inArrayLen:{\n-                if (std::isdigit(*ptr)) {\n-                    ptr++;\n-                }   else if (*ptr == ':') {\n-                    char *num = strduprange(numStart, ptr);\n-                    out<<\"num '\"<<num<<\"'\"<<std::endl<<indent;\n-                    delete [] num;\n-                    ptr++;\n-                    state=awaitingName;\n-                    ptr = dumpSchema(out, depth+1, ptr, nullptr);\n-                } else{\n-                    std::cerr<<\"err \"<<\"<\"<<stateNames[state] <<\"> with '\" <<((char)*ptr)<<\"'\";\n-                    exit(1);\n-                }\n-                break;\n-            }\n-            case lastEnum:\n-                {\n-                    std::cerr<<\"err \"<<\"<\"<<stateNames[state] <<\"> with '\" <<((char)*ptr)<<\"'\";\n-                    exit(1);\n-                }\n-        }\n-    }\n-    delete[] indent;\n-    return ptr;\n-}\n-\n-void OpenCLBackend::dumpSled(std::ostream &out,void *argArray){\n-    ArgSled argSled(static_cast<ArgArray_t *>(argArray));\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        Arg_t *arg = argSled.arg(i);\n-        switch (arg->variant) {\n-            case '&': {\n-                out << \"Buf: of \" << arg->value.buffer.sizeInBytes << \" bytes \"<<std::endl;\n-                break;\n-            }\n-            case 'B':{\n-                out << \"S8:\" << arg->value.s8 << std::endl;\n-                break;\n-            }\n-            case 'Z':{\n-                out << \"Z:\" << arg->value.z1 << std::endl;\n-                break;\n-            }\n-            case 'C':{\n-                out << \"U16:\" << arg->value.u16 << std::endl;\n-                break;\n-            }\n-            case 'S':{\n-                out << \"S16:\" << arg->value.s16 << std::endl;\n-                break;\n-            }\n-            case 'I':{\n-                out << \"S32:\" << arg->value.s32 << std::endl;\n-                break;\n-            }\n-            case 'F':{\n-                out << \"F32:\" << arg->value.s32 << std::endl;\n-                break;\n-            }\n-            case 'J':{\n-                out << \"S64:\" << arg->value.s64 << std::endl;\n-                break;\n-            }\n-            case 'D':{\n-                out << \"F64:\" << arg->value.f64 << std::endl;\n-                break;\n-            }\n-            default: {\n-                std::cerr <<\"unexpected variant '\"<< (char) arg->variant << \"'\"<< std::endl;\n-                exit(1);\n-            }\n-        }\n-    }\n-    out << \"schema len = \" << argSled.schemaLen() <<std::endl;\n-\n-    out << \"schem = \" << argSled.schema() <<std::endl;\n-\n-   \/\/ dumpSchema(out, 0, argSled.schema(), nullptr);\n-}\n@@ -292,1 +112,1 @@\n-    dynamic_cast<OpenCLBackend *>(program->backend)->dumpSled(std::cout, argArray);\n+    Schema::dumpSled(std::cout, argArray);\n@@ -418,1 +238,1 @@\n-    return (long) new OpenCLKernel(this, kernel);\n+    return (long) new OpenCLKernel(this,std::string(name), kernel);\n","filename":"hat\/backends\/opencl\/cpp\/opencl_backend.cpp","additions":4,"deletions":184,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-            OpenCLKernel(Backend::Program *program, cl_kernel kernel);\n+            OpenCLKernel(Backend::Program *program, std::string name,cl_kernel kernel);\n","filename":"hat\/backends\/opencl\/include\/opencl_backend.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"shared.h\"\n+\n+\n+int main(int argc, char **argv) {\n+    char *mandelSchema = (char *) \"args:[5:?:8+S32Array2D:{width:s32,height:s32,array:[*:?:s32]},?:4+S32Array:{length:s32,array:[*:?:s32]},?:f32,?:f32,?:f32]\";\n+    char *squaresSchema = (char *) \"args:[1:?:4+S32Array:{length:s32,array:[*:?:s32]}]\";\n+    char *colIntegralSchema = (char *)\n+            \"args:[2:\"\n+            \"?:8+F32Array2D:{\"\n+            \"width:s32,\"\n+            \"height:s32,\"\n+            \"array:[*:\"\n+            \"?:f32\"\n+            \"]\"\n+            \"},\"\n+            \"?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}\"\n+            \"]\";\n+    char *rowIntegralSchema = (char *) \"args:[3:?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]},?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]},?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}]\";\n+\n+    char *cascadeSchema = (char *) \"args:[5:!:163448!Cascade:{width:s32,height:s32,featureCount:s32,feature:[2913:Feature:{id:s32,threshold:f32,left:{hasValue:z8,?:x3,anon:<featureId:s32|value:f32>},right:{hasValue:z8,?:x3,anon:<featureId:s32|value:f32>},rect:[3:Rect:{x:s8,y:s8,width:s8,height:s8,weight:f32}]}],stageCount:s32,stage:[25:Stage:{id:s32,threshold:f32,firstTreeId:s16,treeCount:s16}],treeCount:s32,tree:[2913:Tree:{id:s32,firstFeatureId:s16,featureCount:s16}]},?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]},?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]},?:8+ScaleTable:{length:s32,multiScaleAccumulativeRange:s32,scale:[*:Scale:{scaleValue:f32,scaledXInc:f32,scaledYInc:f32,invArea:f32,scaledFeatureWidth:s32,scaledFeatureHeight:s32,gridWidth:s32,gridHeight:s32,gridSize:s32,accumGridSizeMin:s32,accumGridSizeMax:s32}]},?:8+ResultTable:{length:s32,atomicResultTableCount:s32,result:[*:Result:{x:f32,y:f32,width:f32,height:f32}]}]\";\n+    char *schema = cascadeSchema;\n+    std::cout << \"schema = '\" << schema << \"'\" << std::endl;\n+    Schema::dumpSchema(std::cout, schema);\n+\n+}\n+\n","filename":"hat\/backends\/shared\/cpp\/schemadump.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -188,0 +188,308 @@\n+char *Schema::strduprange(char *start, char *end) {\n+    char *s = new char[end - start + 1];\n+    std::memcpy(s, start, end - start);\n+    s[end - start] = '\\0';\n+    return s;\n+}\n+\n+std::ostream &Schema::dump(std::ostream &out, char *start, char *end) {\n+    while (start < end) {\n+        out << (char) *start;\n+        start++;\n+    }\n+    return out;\n+}\n+\n+std::ostream &Schema::indent(std::ostream &out, int depth) {\n+    while (depth > 0) {\n+        out << \"  \";\n+        depth++;\n+    }\n+    return out;\n+}\n+\n+std::ostream &Schema::dump(std::ostream &out, char *label, char *start, char *end) {\n+    out << label << \" '\";\n+    dump(out, start, end) << \"' \" << std::endl;\n+    return out;\n+}\n+\n+\n+static const int AWAITING_STATE = 0x00001;\n+static const int IN_STATE = 0x00002;\n+static const int HAVE_STATE = 0x00004;\n+\n+static const int NAME_STATE = 0x00010;\n+static const int CAN_BE_ANON_STATE = 0x00020;\n+static const int NUMERIC_STATE = 0x00040;\n+static const int CAN_BE_FLEX_STATE = 0x00080;\n+\n+static const int ARGS_STATE = 0x00100;\n+static const int ARRAY_STATE = 0x00200;\n+static const int BUFFER_STATE = 0x00400;\n+static const int FIELD_STATE = 0x01000;\n+static const int TYPE_STATE = 0x02000;\n+static const int STRUCT_STATE = 0x04000;\n+static const int UNION_STATE = 0x08000;\n+\n+static const int awaitingArgsName = (ARGS_STATE | NAME_STATE | AWAITING_STATE);\n+static const int awaitingArrayName = (ARRAY_STATE | NAME_STATE | AWAITING_STATE);\n+static const int awaitingBufferName = (BUFFER_STATE | NAME_STATE | AWAITING_STATE);\n+static const int awaitingArrayLen = (ARRAY_STATE | NUMERIC_STATE | AWAITING_STATE);\n+static const int awaitingFieldName = (FIELD_STATE | NAME_STATE | AWAITING_STATE);\n+static const int awaitingTypeName = (TYPE_STATE | NAME_STATE | AWAITING_STATE);\n+\n+static const int inArgsName = (ARGS_STATE | NAME_STATE | IN_STATE);\n+static const int inArrayName = (ARRAY_STATE | CAN_BE_ANON_STATE | NAME_STATE | IN_STATE);\n+static const int inBufferName = (BUFFER_STATE | NAME_STATE | IN_STATE);\n+static const int inArrayLen = (ARRAY_STATE | CAN_BE_FLEX_STATE | NUMERIC_STATE | IN_STATE);\n+static const int inBufferSize = (BUFFER_STATE | NUMERIC_STATE | IN_STATE);\n+static const int inFieldName = (FIELD_STATE | CAN_BE_ANON_STATE | NAME_STATE | IN_STATE);\n+static const int inTypeName = (TYPE_STATE | NAME_STATE | IN_STATE);\n+\n+static const int haveArrayName = (ARRAY_STATE | NAME_STATE | HAVE_STATE);\n+static const int haveBufferName = (BUFFER_STATE | NAME_STATE | HAVE_STATE);\n+static const int haveArgsName = (ARGS_STATE | NAME_STATE | HAVE_STATE);\n+static const int haveFieldName = (FIELD_STATE | NAME_STATE | HAVE_STATE);\n+static const int haveTypeName = (TYPE_STATE | NAME_STATE | HAVE_STATE);\n+\n+#define nameit(s) {s, #s}\n+std::map<int, std::string> Schema::stateNameMap = {\n+        nameit(awaitingArrayLen),\n+        nameit(awaitingArrayName),\n+        nameit(awaitingArgsName),\n+        nameit(inArgsName),\n+        nameit(inTypeName),\n+        nameit(inArrayLen),\n+        nameit(inArrayName),\n+        nameit(inBufferName),\n+        nameit(inBufferSize),\n+        nameit(haveArrayName),\n+        nameit(haveArgsName),\n+        nameit(haveTypeName),\n+        nameit(haveFieldName)\n+};\n+\n+int Schema::replaceStateBit(int state, int remove, int set) {\n+    state |= set;\n+    state &= ~remove;\n+    return state;\n+}\n+\n+int Schema::newState(int state, int to) {\n+    return to;\n+}\n+\n+std::ostream &Schema::stateDescribe(std::ostream &out, int state) {\n+    out << \"(\";\n+    if (state & AWAITING_STATE) {\n+        out << \"Awaiting\";\n+    } else if (state & IN_STATE) {\n+        out << \"In\";\n+    } else if (state & HAVE_STATE) {\n+        out << \"Have\";\n+    }\n+\n+    if (state & FIELD_STATE) {\n+        out << \"Field\";\n+    } else if (state & TYPE_STATE) {\n+        out << \"Type\";\n+    } else if (state & BUFFER_STATE) {\n+        out << \"Buffer\";\n+    } else if (state & ARRAY_STATE) {\n+        out << \"Array\";\n+    } else if (state & ARGS_STATE) {\n+        out << \"Args\";\n+    }\n+\n+    if (state & NAME_STATE) {\n+        out << \"Name\";\n+    } else if (state & NUMERIC_STATE) {\n+        out << \"Numeric\";\n+    }\n+\n+    if (state & CAN_BE_ANON_STATE) {\n+        out << \"(? ok)\";\n+    } else if (state & CAN_BE_FLEX_STATE) {\n+        out << \"(* ok)\";\n+    }\n+    out << \")\";\n+    return out;\n+}\n+\n+std::ostream &Schema::stateType(std::ostream &out, int state) {\n+    if (state & FIELD_STATE) {\n+        out << \"field\";\n+    } else if (state & TYPE_STATE) {\n+        out << \"type\";\n+    } else if (state & BUFFER_STATE) {\n+        out << \"buffer\";\n+    } else if (state & ARRAY_STATE) {\n+        out << \"array\";\n+    } else if (state & ARGS_STATE) {\n+        out << \"args\";\n+    } else {\n+        out << \"WTF\";\n+    }\n+    return out;\n+}\n+\n+char *Schema::dumpSchema(std::ostream &out, int state, int depth, char *ptr, void *data) {\n+    char *start = nullptr;\n+    indent(out, depth);\n+    while (ptr != nullptr && *ptr != '\\0') {\n+        if (stateNameMap.count(state) == 0) {\n+            std::cerr << \"no key\" << std::endl;\n+            exit(1);\n+        }\n+        stateDescribe(out, state) << \"> with '\" << ((char) *ptr) << \"'\";\n+        out.flush();\n+        if (state & AWAITING_STATE) {\n+            start = ptr;\n+            if (\n+                    (((state == awaitingArrayName) || (state == awaitingFieldName)) && (*ptr == '?'))\n+                    || ((state & NAME_STATE) && (std::isalpha(*ptr)))\n+                    || ((state & NUMERIC_STATE) && (std::isdigit(*ptr)))\n+                    || ((state == awaitingArrayLen) && (*ptr == '*'))\n+                    ) {\n+                state = replaceStateBit(state, AWAITING_STATE, IN_STATE);\n+                ptr++;\n+            } else if (((*ptr == ',') || (*ptr == '}') || (*ptr == ']') || (*ptr == '>'))) {\n+                ptr++;\n+            } else {\n+                std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n+                          << std::endl;\n+                exit(1);\n+            }\n+        } else if (state & IN_STATE) {\n+            if (\n+                    ((state & NAME_STATE) && (std::isalnum(*ptr) || *ptr == '_'))\n+                    ||  ((state & NUMERIC_STATE) && std::isdigit(*ptr))\n+                    || ((state == inBufferSize) && ((*ptr == '+') || (*ptr == '!')))\n+                    ){\n+                ptr++;\n+            } else if (*ptr == ':') {\n+                stateType(out, state);\n+                dump(out, start, ptr++);\n+                indent(out, depth);\n+                state = replaceStateBit(state, IN_STATE, HAVE_STATE);\n+            } else {\n+                std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n+                          << std::endl;\n+                exit(1);\n+            }\n+        } else if ((state & HAVE_STATE)) {\n+            switch (state) {\n+                case haveArrayName: {\n+                    \/\/ we expect a type\n+                    if (std::isdigit(*ptr)) {\n+                        start = ptr;\n+                        ptr++;\n+                        state = newState(state, inBufferSize);\n+                    } else if (std::isalpha(*ptr)) {\n+                        ptr++;\n+                        state = newState(state, inTypeName);\n+                    } else {\n+                        std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n+                                  << std::endl;\n+                        exit(1);\n+                    }\n+                    break;\n+                }\n+                case haveArgsName: {\n+                    \/\/ we expect a type name  or array, struct, union\n+                    if (*ptr == '[') {\n+                        ptr++;\n+                        state = newState(state, awaitingArrayLen);\n+                        \/\/ we expect a type\n+                    } else if ((*ptr == '{') || (*ptr == '<')) {\n+                        ptr++;\n+                        state = newState(state, awaitingFieldName);\n+                    } else if (std::isalnum(*ptr)) {\n+                        ptr++;\n+                        state =newState(state, inTypeName);\n+                    } else {\n+                        std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n+                                  << std::endl;\n+                        exit(1);\n+                    }\n+                    break;\n+                }\n+                default: {\n+                    std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n+                              << std::endl;\n+                    exit(1);\n+                }\n+            }\n+        } else {\n+            std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n+                      << std::endl;\n+            exit(1);\n+        }\n+\n+    }\n+    return ptr;\n+}\n+\n+char *Schema::dumpSchema(std::ostream &out, char *ptr, void *data) {\n+    return dumpSchema(out, awaitingArgsName, 0, ptr, data);\n+}\n+\n+char *Schema::dumpSchema(std::ostream &out, char *ptr) {\n+    return dumpSchema(out, ptr, nullptr);\n+}\n+\n+void Schema::dumpSled(std::ostream &out, void *argArray) {\n+    ArgSled argSled(static_cast<ArgArray_t *>(argArray));\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_t *arg = argSled.arg(i);\n+        switch (arg->variant) {\n+            case '&': {\n+                out << \"Buf: of \" << arg->value.buffer.sizeInBytes << \" bytes \" << std::endl;\n+                break;\n+            }\n+            case 'B': {\n+                out << \"S8:\" << arg->value.s8 << std::endl;\n+                break;\n+            }\n+            case 'Z': {\n+                out << \"Z:\" << arg->value.z1 << std::endl;\n+                break;\n+            }\n+            case 'C': {\n+                out << \"U16:\" << arg->value.u16 << std::endl;\n+                break;\n+            }\n+            case 'S': {\n+                out << \"S16:\" << arg->value.s16 << std::endl;\n+                break;\n+            }\n+            case 'I': {\n+                out << \"S32:\" << arg->value.s32 << std::endl;\n+                break;\n+            }\n+            case 'F': {\n+                out << \"F32:\" << arg->value.s32 << std::endl;\n+                break;\n+            }\n+            case 'J': {\n+                out << \"S64:\" << arg->value.s64 << std::endl;\n+                break;\n+            }\n+            case 'D': {\n+                out << \"F64:\" << arg->value.f64 << std::endl;\n+                break;\n+            }\n+            default: {\n+                std::cerr << \"unexpected variant '\" << (char) arg->variant << \"'\" << std::endl;\n+                exit(1);\n+            }\n+        }\n+    }\n+    out << \"schema len = \" << argSled.schemaLen() << std::endl;\n+\n+    out << \"schema = \" << argSled.schema() << std::endl;\n+\n+    \/\/ dumpSchema(out, argSled.schema()); not stable yet\n+}\n+\n@@ -191,1 +499,1 @@\n-    std::cout << \"trampolining through backendHandle to backend.getMaxComputeUnits()\" <<std::endl;\n+    std::cout << \"trampolining through backendHandle to backend.getMaxComputeUnits()\" << std::endl;\n@@ -197,1 +505,1 @@\n-    std::cout << \"trampolining through backendHandle to backend.info()\" <<std::endl;\n+    std::cout << \"trampolining through backendHandle to backend.info()\" << std::endl;\n@@ -206,1 +514,1 @@\n-    std::cout << \"trampolining through backendHandle to backend.compileProgram()\" <<std::endl;\n+    std::cout << \"trampolining through backendHandle to backend.compileProgram()\" << std::endl;\n@@ -211,1 +519,1 @@\n-    std::cout << \"trampolining through programHandle to program.getKernel()\" <<std::endl;\n+    std::cout << \"trampolining through programHandle to program.getKernel()\" << std::endl;\n@@ -217,1 +525,1 @@\n-    std::cout << \"trampolining through kernelHandle to kernel.ndrange(...) \" <<std::endl;\n+    std::cout << \"trampolining through kernelHandle to kernel.ndrange(...) \" << std::endl;\n","filename":"hat\/backends\/shared\/cpp\/shared.cpp","additions":313,"deletions":5,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+\n@@ -48,0 +49,1 @@\n+\n@@ -215,69 +217,0 @@\n-   using float64_t = double; \/\/ std::float64_t in c++23\n-   using float32_t = float;  \/\/ std::float32_t in c++23\n-#define TYPE_U    0x01\n-#define TYPE_S    0x02\n-#define TYPE_F    0x04\n-#define ACCESS_RW   0x01\n-#define ACCESS_WO   0x02\n-#define ACCESS_RO   0x04\n-\n-struct arg_s {\n-int32_t argc;\n-int8_t type;\n-int8_t dims;\n-int8_t elementSizeInBytes;\n-int8_t access;\n-int64_t sizeInBytes;\n-union {\n-uint16_t u16;\n-int16_t s16;\n-int32_t s32;\n-float32_t f32;\n-float64_t f64;\n-struct {\n-void *ptr;\n-size_t elements;\n-#ifdef OPENCL_TYPES\n-CLBuf *buf;\n-#else\n-#ifdef CUDA_TYPES\n-CUdeviceptr buf;\n-#else\n-void *buf;\n-#endif\n-#endif\n-} _1d;\n-struct {\n-void *ptr;\n-size_t width;\n-size_t height;\n-#ifdef OPENCL_TYPES\n-CLBuf *buf;\n-#else\n-#ifdef CUDA_TYPES\n-CUdeviceptr buf;\n-#else\n-void *buf;\n-#endif\n-#endif\n-} _2d;\n-struct {\n-void *ptr;\n-size_t width;\n-size_t height;\n-size_t depth;\n-#ifdef OPENCL_TYPES\n-CLBuf *buf;\n-#else\n-#ifdef CUDA_TYPES\n-CUdeviceptr buf;\n-#else\n-void *buf;\n-#endif\n-#endif\n-} _3d;\n-};\n-};\n-\n-\n-\n@@ -463,1 +396,1 @@\n-\/\/extern const char *typeName(int type) ;\n+\n@@ -466,1 +399,1 @@\n-\/\/extern void dumpArg(arg_s *openCLArg);\n+\n@@ -469,0 +402,25 @@\n+class Schema {\n+public:\n+    static std::map<int, std::string> stateNameMap;\n+\n+    static int replaceStateBit(int state, int remove, int set);\n+    static int newState(int state, int to);\n+    static std::ostream &stateType(std::ostream &out, int state);\n+    static std::ostream &stateDescribe(std::ostream &out, int state);\n+    static char *strduprange(char *start, char *end);\n+\n+    static std::ostream &indent(std::ostream &out, int depth);\n+\n+    static std::ostream &dump(std::ostream &out, char *start, char *end);\n+\n+    static std::ostream &dump(std::ostream &out, char *label, char *start, char *end);\n+\n+    static void dumpSled(std::ostream &out, void *argArray);\n+\n+    static char *dumpSchema(std::ostream &out, int, int depth, char *ptr, void *data);\n+\n+    static char *dumpSchema(std::ostream &out, char *ptr, void *data);\n+\n+    static char *dumpSchema(std::ostream &out, char *ptr);\n+};\n+\n@@ -483,3 +441,6 @@\n-                virtual void copyToDevice()=0;\n-                virtual void copyFromDevice()=0;\n-                Buffer(Kernel *kernel, Arg_t *arg):kernel(kernel),arg(arg){\n+\n+                virtual void copyToDevice() = 0;\n+\n+                virtual void copyFromDevice() = 0;\n+\n+                Buffer(Kernel *kernel, Arg_t *arg) : kernel(kernel), arg(arg) {\n@@ -487,0 +448,1 @@\n+\n@@ -490,0 +452,2 @@\n+            std::string name;\n+\n@@ -494,2 +458,2 @@\n-            Kernel(Program *program)\n-                    : program(program) {\n+            Kernel(Program *program, std::string name)\n+                    : program(program), name(name) {\n@@ -535,0 +499,2 @@\n+\n+\n","filename":"hat\/backends\/shared\/include\/shared.h","additions":42,"deletions":76,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -293,0 +293,1 @@\n+        \/\/ createIntegralImage(greyImage, integralImage, integralSqImage);\n@@ -314,1 +315,1 @@\n-        ResultTable resultTable = ResultTable.create(accelerator, 10000);\n+        ResultTable resultTable = ResultTable.create(accelerator, 1000);\n","filename":"hat\/examples\/violajones\/src\/java\/violajones\/ViolaJonesCompute.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}