{"files":[{"patch":"@@ -4,1 +4,1 @@\n-import hat.HatPtr;\n+import hat.OpsAndTypes;\n@@ -72,1 +72,1 @@\n-        FunctionType functionType = HatPtr.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n+        FunctionType functionType = OpsAndTypes.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n@@ -77,1 +77,1 @@\n-        CoreOp.FuncOp ssaPtrForm = HatPtr.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n+        CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InvokeToPtr.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.ifacemapper.BoundSchemaNode;\n+import hat.ifacemapper.BoundSchema;\n@@ -144,1 +144,1 @@\n-        var boundSchema = new BoundSchemaNode.BoundSchemaRootNode<>(MeshData.schema, 100, 10);\n+        var boundSchema = new BoundSchema<>(MeshData.schema, 100, 10);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-import hat.HatPtr;\n+import hat.OpsAndTypes;\n@@ -109,1 +109,1 @@\n-                FunctionType functionType = HatPtr.transformTypes(MethodHandles.lookup(), ssaInvokeForm, args);\n+                FunctionType functionType = OpsAndTypes.transformTypes(MethodHandles.lookup(), ssaInvokeForm, args);\n@@ -114,1 +114,1 @@\n-                CoreOp.FuncOp ssaPtrForm = HatPtr.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n+                CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-import hat.HatPtr;\n+import hat.OpsAndTypes;\n@@ -10,1 +10,0 @@\n-import hat.backend.Backend;\n@@ -14,1 +13,0 @@\n-import hat.callgraph.KernelEntrypoint;\n@@ -16,1 +14,0 @@\n-import hat.backend.DebugBackend;\n@@ -18,1 +15,0 @@\n-import hat.ifacemapper.SegmentMapper;\n@@ -20,1 +16,0 @@\n-import java.lang.foreign.Arena;\n@@ -25,1 +20,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -118,1 +112,1 @@\n-                FunctionType functionType = HatPtr.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n+                FunctionType functionType = OpsAndTypes.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n@@ -123,1 +117,1 @@\n-                CoreOp.FuncOp ssaPtrForm = HatPtr.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n+                CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHatArray.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,502 +0,0 @@\n-package hat;\n-\n-import hat.buffer.Buffer;\n-import hat.ifacemapper.BoundSchema;\n-import hat.ifacemapper.MappableIface;\n-import hat.ifacemapper.Schema;\n-import hat.optools.FuncOpWrapper;\n-import hat.optools.InvokeOpWrapper;\n-import hat.optools.OpWrapper;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.op.OpFactory;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.PrimitiveType;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-public class HatPtr {\n-\n-        public static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement, BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceType ifaceType) {\n-            if (getMappableClassOrNull(lookup, typeElement) instanceof Class<?> clazz){\n-               \/\/ MemoryLayout layout = boundSchema.getLayout(clazz);\n-                return new HatPtr.HatPtrType<>((Class<T>) clazz, getLayout((Class<T>) clazz));\n-            }else{\n-                return typeElement;\n-            }\n-        }\n-\n-        public static <T extends MappableIface> MemoryLayout getLayout(Class<T> mappableIface) {\n-            try {\n-                return (MemoryLayout) mappableIface.getDeclaredField(\"LAYOUT\").get(null);\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        public static <T extends MappableIface> Class<T> getMappableClassOrNull(MethodHandles.Lookup lookup, TypeElement typeElement) {\n-            try {\n-                return (typeElement instanceof JavaType jt\n-                        && jt.resolve(lookup) instanceof Class<?> possiblyMappableIface\n-                        && MappableIface.class.isAssignableFrom(possiblyMappableIface)) ? (Class<T>) possiblyMappableIface : null;\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        public static FunctionType transformTypes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp, Object ...args) {\n-            List<TypeElement> transformedTypeElements = new ArrayList<>();\n-            for (int i = 0; i < args.length; i++) {\n-                Block.Parameter parameter = funcOp.parameters().get(i);\n-                TypeElement parameterTypeElement=null;\n-                if (args[i] instanceof Buffer buffer) {\n-                    var boundSchema = Buffer.getBoundSchema(buffer);\n-                    parameterTypeElement=convertToPtrTypeIfPossible(lookup, parameter.type(), boundSchema,boundSchema.schema().rootIfaceType);\n-                }else{\n-                    parameterTypeElement =parameter.type();\n-                }\n-                transformedTypeElements.add(parameterTypeElement);\n-            }\n-            TypeElement returnTypeElement = convertToPtrTypeIfPossible(lookup, funcOp.invokableType().returnType(),null, null);\n-            return FunctionType.functionType(returnTypeElement, transformedTypeElements);\n-        }\n-\n-        public static <T extends MappableIface> CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n-                                                                                     CoreOp.FuncOp ssaForm, FunctionType functionType) {\n-            return CoreOp.func(ssaForm.funcName(), functionType).body(funcBlock -> {\n-                funcBlock.transformBody(ssaForm.body(), funcBlock.parameters(), (builder, op) -> {\n-                \/*\n-                   We are looking for\n-                      interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                         T foo();\n-                         void foo(T foo);\n-                      }\n-                   Were T is either a primitive or a nested iface mapping and foo matches the field name\n-                 *\/\n-\n-                    if (op instanceof CoreOp.InvokeOp invokeOp\n-                            && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n-                            && invokeOpWrapper.hasOperands()\n-                            && invokeOpWrapper.isIfaceBufferMethod()\n-                            && invokeOpWrapper.getReceiver() instanceof Value iface \/\/ Is there a containing iface type Iface\n-                            && getMappableClassOrNull(lookup, iface.type()) != null\n-                    ) {\n-                        Value ifaceValue = builder.context().getValue(iface);     \/\/ ? Ensure we have an output value for the iface\n-                        HatPtr.HatPtrOp<T> hatPtrOp = new HatPtr.HatPtrOp<>(ifaceValue, invokeOpWrapper.name());         \/\/ Create ptrOp to replace invokeOp\n-                        Op.Result ptrResult = builder.op(hatPtrOp);\/\/ replace and capture the result of the invoke\n-                        if (invokeOpWrapper.operandCount() == 1) {                  \/\/ No args (operand(0)==containing iface))\n-                        \/*\n-                          this turns into a load\n-                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                              T foo();\n-                          }\n-                         *\/\n-                            if (hatPtrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n-                                HatPtr.HatPtrLoadValue primitiveLoad = new HatPtr.HatPtrLoadValue(iface.type(), ptrResult);\n-                                Op.Result replacedReturnValue = builder.op(primitiveLoad);\n-                                builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n-                            } else {                                                 \/\/ pointing to another iface mappable\n-                                builder.context().mapValue(invokeOp.result(), ptrResult);\n-                            }\n-                        } else if (invokeOpWrapper.operandCount() == 2) {\n-                         \/*\n-                          This turns into a store\n-                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                              void foo(T);\n-                          }\n-                         *\/\n-                            if (hatPtrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n-                                Value valueToStore = builder.context().getValue(invokeOpWrapper.operandNAsValue(1));\n-                                HatPtr.HatPtrStoreValue primitiveStore = new HatPtr.HatPtrStoreValue(iface.type(), ptrResult, valueToStore);\n-                                Op.Result replacedReturnValue = builder.op(primitiveStore);\n-                                builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n-                            } else {                                                 \/\/ pointing to another iface mappable\n-                                builder.context().mapValue(invokeOp.result(), ptrResult);\n-                            }\n-                        } else {\n-                            builder.op(op);\n-                        }\n-                    } else {\n-                        builder.op(op);\n-                    }\n-                    return builder; \/\/ why? oh why?\n-                });\n-            });\n-        }\n-\n-\n-    public abstract  static class HatOp extends Op {\n-        private final TypeElement type;\n-\n-        HatOp(String opName, TypeElement type, List<Value> operands) {\n-            super(opName, operands);\n-            this.type = type;\n-        }\n-\n-        HatOp(HatOp that, CopyContext cc) {\n-            super(that, cc);\n-            this.type = that.type;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return type;\n-        }\n-    }\n-\n-\n-    public final static class HatKernelContextOp extends HatOp {\n-        public final static String NAME=\"hat.kc.op\";\n-        public final String fieldName;\n-        public HatKernelContextOp(String fieldName, TypeElement typeElement, List<Value> operands) {\n-            super(NAME+\".\"+fieldName, typeElement, operands);\n-            this.fieldName=fieldName;\n-        }\n-        public HatKernelContextOp(String fieldName, FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME+\".\"+fieldName, replacer.currentResultType(), replacer.currentOperandValues());\n-            this.fieldName=fieldName;\n-\n-        }\n-        public HatKernelContextOp(String fieldName,TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME+\".\"+fieldName, typeElement, replacer.currentOperandValues());\n-            this.fieldName=fieldName;\n-        }\n-        public HatKernelContextOp(HatKernelContextOp that, CopyContext cc) {\n-            super(that, cc); this.fieldName = that.fieldName;\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new HatKernelContextOp(this, cc);\n-        }\n-    }\n-\n-\/*\n-    public abstract static  class HatPtrOp extends HatOp {\n-\n-        public HatPtrOp(String name, TypeElement typeElement, List<Value> operands) {\n-            super(name, typeElement, operands);\n-        }\n-        public HatPtrOp(String name, FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(name, replacer.currentResultType(), replacer.currentOperandValues());\n-        }\n-        public HatPtrOp(String name, TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(name, typeElement, replacer.currentOperandValues());\n-        }\n-\n-        public HatPtrOp(HatOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-    }\n-    public final static class HatPtrStoreOp extends HatPtrOp {\n-        public final static String NAME=\"hat.ptr.store\";\n-        public HatPtrStoreOp(TypeElement typeElement, List<Value> operands) {\n-            super(NAME, typeElement, operands);\n-        }\n-        public HatPtrStoreOp(FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME, replacer);\n-        }\n-        public HatPtrStoreOp(TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME, typeElement,replacer);\n-        }\n-        public HatPtrStoreOp(HatOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new HatPtrStoreOp(this, cc);\n-        }\n-    }\n-    public final static class HatPtrLoadOp extends HatPtrOp {\n-        public final static String NAME=\"hat.ptr.load\";\n-        public HatPtrLoadOp(TypeElement typeElement, List<Value> operands) {\n-            super(NAME, typeElement, operands);\n-        }\n-        public HatPtrLoadOp(TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME, typeElement, replacer);\n-        }\n-        public HatPtrLoadOp( FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME,  replacer);\n-        }\n-        public HatPtrLoadOp(HatOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new HatPtrStoreOp(this, cc);\n-        }\n-    }\n-\n-*\/\n-\n-\n-\n-    public abstract sealed static class HatType implements TypeElement permits HatPtrType {\n-        String name;\n-        HatType(String name){\n-            this.name = name;\n-        }\n-    }\n-\n-    public static final class HatPtrType<T extends MappableIface> extends HatType {\n-        static final String NAME = \"ptrType\";\n-        public final Class<T> mappableIface;\n-        final MemoryLayout layout;\n-        final JavaType referringType;\n-\n-        public HatPtrType(Class<T> mappableIface, MemoryLayout layout) {\n-            super(NAME);\n-            this.mappableIface = mappableIface;\n-            this.layout = layout;\n-            if (layout instanceof StructLayout structLayout){\n-                this.referringType =  JavaType.type(ClassDesc.of(structLayout.name().orElseThrow()));\n-            }else if  (layout instanceof ValueLayout valueLayout) {\n-                this.referringType = JavaType.type(valueLayout.carrier());\n-            }else    if (layout instanceof SequenceLayout sequenceLayout){\n-                this.referringType =  JavaType.type(ClassDesc.of(sequenceLayout.name().orElseThrow()));\n-            }else {\n-                throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-            }\n-        }\n-\n-        public JavaType referringType() {\n-            return referringType;\n-        }\n-\n-        public MemoryLayout layout() {\n-            return layout;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            HatPtrType<T> hatPtrType = (HatPtrType<T>) o;\n-            return Objects.equals(layout, hatPtrType.layout);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(layout);\n-        }\n-\n-        @Override\n-        public ExternalizedTypeElement externalize() {\n-            return new ExternalizedTypeElement(NAME, List.of(referringType.externalize()));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return externalize().toString();\n-        }\n-    }\n-\n-\n-   \/* public static final class HatPtrType extends HatType {\n-        static final String NAME = \"hat.ptr\";\n-        final TypeElement type;\n-\n-        public HatPtrType(TypeElement type) {\n-            super(NAME);\n-            this.type = type;\n-\n-        }\n-\n-        public TypeElement type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            HatPtrType hatPtrType = (HatPtrType) o;\n-            return Objects.equals(type, hatPtrType.type);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(type);\n-        }\n-\n-        @Override\n-        public ExternalizedTypeElement externalize() {\n-            return new ExternalizedTypeElement(NAME, List.of(type.externalize()));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return externalize().toString();\n-        }\n-    } *\/\n-\n-\n-\n-    @OpFactory.OpDeclaration(HatPtrOp.NAME)\n-    public static final class HatPtrOp<T extends MappableIface> extends ExternalizableOp {\n-        public static final String NAME = \"ptr.to.member\";\n-        public static final String ATTRIBUTE_OFFSET = \"offset\";\n-        final HatPtr.HatPtrType<T> hatPtrType;\n-        final HatPtr.HatPtrType<T> resultType;\n-        final String simpleMemberName;\n-        final long memberOffset;\n-\n-\n-        HatPtrOp(HatPtrOp<T> that, CopyContext cc) {\n-            super(that, cc);\n-            this.hatPtrType = that.hatPtrType;\n-            this.resultType = that.resultType;\n-            this.simpleMemberName = that.simpleMemberName;\n-            this.memberOffset = that.memberOffset;\n-\n-        }\n-\n-        @Override\n-        public HatPtrOp<T> transform(CopyContext cc, OpTransformer ot) {\n-            return new HatPtrOp<T>(this, cc);\n-        }\n-\n-        public HatPtrOp(Value ptr, String simpleMemberName) {\n-            super(NAME, List.of(ptr));\n-\n-            this.simpleMemberName = simpleMemberName;\n-            if (ptr.type() instanceof HatPtr.HatPtrType<?> hatPtrType) {\n-\n-                if (hatPtrType.layout() instanceof StructLayout structLayout) {\n-                    this.hatPtrType = (HatPtr.HatPtrType<T>) hatPtrType;\n-                    MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(simpleMemberName);\n-                    this.memberOffset = structLayout.byteOffset(memberPathElement);\n-                    MemoryLayout memberLayout = structLayout.select(memberPathElement);\n-                    this.resultType = new HatPtr.HatPtrType<>((Class<T>) hatPtrType.mappableIface, memberLayout);\n-                }else   if (hatPtrType.layout() instanceof SequenceLayout sequenceLayout) {\n-                    this.hatPtrType = (HatPtr.HatPtrType<T>) hatPtrType;\n-                    MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(simpleMemberName);\n-                    this.memberOffset = sequenceLayout.byteOffset(memberPathElement);\n-                    MemoryLayout memberLayout = sequenceLayout.select(memberPathElement);\n-                    this.resultType = new HatPtr.HatPtrType<>((Class<T>) hatPtrType.mappableIface, memberLayout);\n-                } else {\n-                    throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + hatPtrType.layout());\n-                }\n-            } else {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-        }\n-\n-\n-        @Override\n-        public HatPtr.HatPtrType<T> resultType() {\n-            return resultType;\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-            attrs.put(\"\", simpleMemberName);\n-            attrs.put(ATTRIBUTE_OFFSET, memberOffset);\n-            return attrs;\n-        }\n-    }\n-\n-\n-    public static abstract class HatPtrAccessValue extends Op {\n-        final String name;\n-        final TypeElement resultType;\n-        final TypeElement typeElement;\n-\n-        HatPtrAccessValue(String name, TypeElement typeElement, HatPtrAccessValue that, CopyContext cc) {\n-            super(that, cc);\n-            this.name = name;\n-            this.typeElement = typeElement;\n-            this.resultType = that.resultType;\n-        }\n-\n-        public HatPtrAccessValue(String name, TypeElement typeElement, TypeElement resultType, List<Value> values) {\n-            super(name, values);\n-            this.name = name;\n-            this.typeElement = typeElement;\n-            this.resultType = resultType;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    @OpFactory.OpDeclaration(HatPtrLoadValue.NAME)\n-    public static final class HatPtrLoadValue extends HatPtrAccessValue {\n-        public static final String NAME = \"ptr.load.value\";\n-\n-        HatPtrLoadValue(TypeElement typeElement, HatPtrLoadValue that, CopyContext cc) {\n-            super(NAME, typeElement, that, cc);\n-        }\n-        public HatPtrLoadValue(TypeElement typeElement, Value ptr) {\n-            super(NAME, typeElement, ((HatPtr.HatPtrType<?>) ptr.type()).referringType(), List.of(ptr));\n-        }\n-        \/\/  public HatPtrLoadValue(String name,TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n-        \/\/    super(name, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n-        \/\/  }\n-        public HatPtrLoadValue(TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n-        }\n-\n-        @Override\n-        public HatPtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n-            return new HatPtrLoadValue(typeElement, this, cc);\n-        }\n-    }\n-\n-    @OpFactory.OpDeclaration(HatPtrStoreValue.NAME)\n-    public static final class HatPtrStoreValue extends HatPtrAccessValue {\n-        public static final String NAME = \"ptr.store.value\";\n-\n-        public HatPtrStoreValue(TypeElement typeElement, HatPtrStoreValue that, CopyContext cc) {\n-            super(NAME, typeElement, that, cc);\n-        }\n-        public HatPtrStoreValue(TypeElement typeElement, PrimitiveType resultType, List<Value> operandValues) {\n-            super(NAME, typeElement, resultType, operandValues);\n-        }\n-        public HatPtrStoreValue(TypeElement typeElement, Value ptr, Value arg1) {\n-            super(NAME, typeElement, JavaType.VOID, List.of(ptr, arg1));\n-        }\n-      \/\/  public HatPtrStoreValue(String name,TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n-        \/\/    super(name, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n-      \/\/  }\n-        public HatPtrStoreValue(TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n-        }\n-\n-\n-        @Override\n-        public HatPtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n-            return new HatPtrStoreValue(typeElement, this, cc);\n-        }\n-\n-\n-    }\n-\n-\n-\n-\n-\n-\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/HatPtr.java","additions":0,"deletions":502,"binary":false,"changes":502,"status":"deleted"},{"patch":"@@ -0,0 +1,421 @@\n+package hat;\n+\n+import hat.buffer.Buffer;\n+import hat.ifacemapper.BoundSchema;\n+import hat.ifacemapper.MappableIface;\n+import hat.ifacemapper.Schema;\n+import hat.optools.FuncOpWrapper;\n+import hat.optools.InvokeOpWrapper;\n+import hat.optools.OpWrapper;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.op.ExternalizableOp;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static hat.ifacemapper.MapperUtil.isMappableIface;\n+\n+public class OpsAndTypes {\n+\n+    public static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement, BoundSchema<?> boundSchema, Schema.IfaceType ifaceType) {\n+        try {\n+            if (typeElement instanceof JavaType javaType\n+                    && javaType.resolve(lookup) instanceof Class<?> possiblyMappableIface\n+                    && isMappableIface(possiblyMappableIface)) {\n+                return new OpsAndTypes.HatPtrType<>((Class<T>) possiblyMappableIface, boundSchema.rootBoundSchemaNode());\n+            } else {\n+                return typeElement;\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+\n+    }\n+\n+    public static <T extends MappableIface> MemoryLayout getLayout(Class<T> mappableIface) {\n+        try {\n+            return (MemoryLayout) mappableIface.getDeclaredField(\"LAYOUT\").get(null);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static <T extends MappableIface> Class<T> getMappableClassOrNull(MethodHandles.Lookup lookup, TypeElement typeElement) {\n+        try {\n+            return (typeElement instanceof JavaType javaType\n+                    && javaType.resolve(lookup) instanceof Class<?> possiblyMappableIface\n+                    && MappableIface.class.isAssignableFrom(possiblyMappableIface)) ? (Class<T>) possiblyMappableIface : null;\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static FunctionType transformTypes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp, Object... args) {\n+        List<TypeElement> transformedTypeElements = new ArrayList<>();\n+        for (int i = 0; i < args.length; i++) {\n+            Block.Parameter parameter = funcOp.parameters().get(i);\n+            TypeElement parameterTypeElement = null;\n+            if (args[i] instanceof Buffer buffer) {\n+                var boundSchema = Buffer.getBoundSchema(buffer);\n+                parameterTypeElement = convertToPtrTypeIfPossible(lookup, parameter.type(), boundSchema, boundSchema.schema().rootIfaceType);\n+            } else {\n+                parameterTypeElement = parameter.type();\n+            }\n+            transformedTypeElements.add(parameterTypeElement);\n+        }\n+        TypeElement returnTypeElement = convertToPtrTypeIfPossible(lookup, funcOp.invokableType().returnType(), null, null);\n+        return FunctionType.functionType(returnTypeElement, transformedTypeElements);\n+    }\n+\n+    public static <T extends MappableIface> CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n+                                                                                 CoreOp.FuncOp ssaForm, FunctionType functionType) {\n+        return CoreOp.func(ssaForm.funcName(), functionType).body(funcBlock -> {\n+            funcBlock.transformBody(ssaForm.body(), funcBlock.parameters(), (builder, op) -> {\n+                \/*\n+                   We are looking for\n+                      interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                         T foo();\n+                         void foo(T foo);\n+                      }\n+                   Were T is either a primitive or a nested iface mapping and foo matches the field name\n+                 *\/\n+\n+                if (op instanceof CoreOp.InvokeOp invokeOp\n+                        && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n+                        && invokeOpWrapper.hasOperands()\n+                        && invokeOpWrapper.isIfaceBufferMethod()\n+                        && invokeOpWrapper.getReceiver() instanceof Value iface \/\/ Is there a containing iface type Iface\n+                        && getMappableClassOrNull(lookup, iface.type()) != null\n+                ) {\n+                    Value hatPtrTypeValue = builder.context().getValue(iface);\/\/ ? Ensure we have an output value for the iface\n+                    \/\/ HatPtr.HatPtrType existingPtr = (HatPtr.HatPtrType)ifaceValue.type();\n+                    String fieldName = invokeOpWrapper.name();\n+                    \/\/   BoundSchema.BoundSchemaNode boundSchemaNode = existingPtr.boundSchemaNode;\n+                    \/\/    BoundSchema.FieldLayout layout= boundSchemaNode.getChild(fieldName);\n+                    OpsAndTypes.HatPtrOp<T> hatPtrOp = new OpsAndTypes.HatPtrOp<>(hatPtrTypeValue, fieldName);         \/\/ Create ptrOp to replace invokeOp\n+                    Op.Result ptrResult = builder.op(hatPtrOp);\/\/ replace and capture the result of the invoke\n+                    if (invokeOpWrapper.operandCount() == 1) {                  \/\/ No args (operand(0)==containing iface))\n+                        \/*\n+                          this turns into a load\n+                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                              T foo();\n+                          }\n+                         *\/\n+                        if (hatPtrOp.hatPtrType == null) { \/\/ are we pointing to a primitive\n+                            OpsAndTypes.HatPtrLoadValue primitiveLoad = new OpsAndTypes.HatPtrLoadValue(iface.type(), ptrResult);\n+                            Op.Result replacedReturnValue = builder.op(primitiveLoad);\n+                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n+                        } else {                                                 \/\/ pointing to another iface mappable\n+                            builder.context().mapValue(invokeOp.result(), ptrResult);\n+                        }\n+                    } else if (invokeOpWrapper.operandCount() == 2) {\n+                         \/*\n+                          This turns into a store\n+                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                              void foo(T);\n+                          }\n+                         *\/\n+                        if (hatPtrOp.hatPtrType == null) { \/\/ are we pointing to a primitive\n+                            Value valueToStore = builder.context().getValue(invokeOpWrapper.operandNAsValue(1));\n+                            OpsAndTypes.HatPtrStoreValue primitiveStore = new OpsAndTypes.HatPtrStoreValue(iface.type(), ptrResult, valueToStore);\n+                            Op.Result replacedReturnValue = builder.op(primitiveStore);\n+                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n+                        } else {                                                 \/\/ pointing to another iface mappable\n+                            builder.context().mapValue(invokeOp.result(), ptrResult);\n+                        }\n+                    } else {\n+                        builder.op(op);\n+                    }\n+                } else {\n+                    builder.op(op);\n+                }\n+                return builder; \/\/ why? oh why?\n+            });\n+        });\n+    }\n+\n+\n+    public abstract static class HatOp extends Op {\n+        private final TypeElement type;\n+\n+        HatOp(String opName, TypeElement type, List<Value> operands) {\n+            super(opName, operands);\n+            this.type = type;\n+        }\n+\n+        HatOp(HatOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.type = that.type;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return type;\n+        }\n+    }\n+\n+\n+    public final static class HatKernelContextOp extends HatOp {\n+        public final static String NAME = \"hat.kc.op\";\n+        public final String fieldName;\n+\n+        public HatKernelContextOp(String fieldName, TypeElement typeElement, List<Value> operands) {\n+            super(NAME + \".\" + fieldName, typeElement, operands);\n+            this.fieldName = fieldName;\n+        }\n+\n+        public HatKernelContextOp(String fieldName, FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME + \".\" + fieldName, replacer.currentResultType(), replacer.currentOperandValues());\n+            this.fieldName = fieldName;\n+\n+        }\n+\n+        public HatKernelContextOp(String fieldName, TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME + \".\" + fieldName, typeElement, replacer.currentOperandValues());\n+            this.fieldName = fieldName;\n+        }\n+\n+        public HatKernelContextOp(HatKernelContextOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.fieldName = that.fieldName;\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new HatKernelContextOp(this, cc);\n+        }\n+    }\n+\n+\n+    public abstract sealed static class HatType implements TypeElement permits HatPtrType {\n+        String name;\n+\n+        HatType(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    public static final class HatPtrType<T extends MappableIface> extends HatType {\n+        static final String NAME = \"ptrType\";\n+\n+        public final BoundSchema.BoundSchemaNode<?> boundSchemaNode;\n+        public final Class<T> mappableIface;\n+        final MemoryLayout layout;\n+        final JavaType referringType;\n+\n+        public HatPtrType(Class<T> mappableIface, BoundSchema.BoundSchemaNode<?> boundSchemaNode) {\n+            super(NAME);\n+            this.mappableIface = mappableIface;\n+            this.boundSchemaNode = boundSchemaNode;\n+            this.layout = boundSchemaNode.memoryLayouts.getFirst();\n+            if (layout instanceof StructLayout structLayout) {\n+                this.referringType = JavaType.type(boundSchemaNode.ifaceType.iface);\n+            } else if (layout instanceof ValueLayout valueLayout) {\n+                var referringTypeClassDesc = valueLayout.carrier();\n+                this.referringType = JavaType.type(referringTypeClassDesc);\n+            } else if (layout instanceof SequenceLayout sequenceLayout) {\n+                var referringTypeClassDesc = ClassDesc.of(sequenceLayout.name().orElseThrow());\n+                this.referringType = JavaType.type(referringTypeClassDesc);\n+            } else {\n+                throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n+            }\n+        }\n+\n+        public JavaType referringType() {\n+            return referringType;\n+        }\n+\n+        public MemoryLayout layout() {\n+            return layout;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            HatPtrType<T> hatPtrType = (HatPtrType<T>) o;\n+            return Objects.equals(layout, hatPtrType.layout);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(layout);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of(referringType.externalize()));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return externalize().toString();\n+        }\n+    }\n+\n+\n+    @OpFactory.OpDeclaration(HatPtrOp.NAME)\n+    public static final class HatPtrOp<T extends MappableIface> extends ExternalizableOp {\n+        public static final String NAME = \"ptr.to.member\";\n+        public static final String ATTRIBUTE_OFFSET = \"offset\";\n+        public final OpsAndTypes.HatPtrType<T> hatPtrType;\n+        public final TypeElement resultType;\n+        public final String simpleMemberName;\n+        public final long memberOffset;\n+\n+\n+        HatPtrOp(HatPtrOp<T> that, CopyContext cc) {\n+            super(that, cc);\n+            this.hatPtrType = that.hatPtrType;\n+            this.resultType = that.resultType;\n+            this.simpleMemberName = that.simpleMemberName;\n+            this.memberOffset = that.memberOffset;\n+\n+        }\n+\n+        @Override\n+        public HatPtrOp<T> transform(CopyContext cc, OpTransformer ot) {\n+            return new HatPtrOp<T>(this, cc);\n+        }\n+\n+        public HatPtrOp(Value ptr, String simpleMemberName) {\n+            super(NAME, List.of(ptr));\n+            this.simpleMemberName = simpleMemberName;\n+            if (ptr.type() instanceof OpsAndTypes.HatPtrType<?> hatPtrType) {\n+                this.hatPtrType = (OpsAndTypes.HatPtrType<T>) hatPtrType;\n+                var boundSchemaNode = hatPtrType.boundSchemaNode;\n+                var boundIfaceType = boundSchemaNode.ifaceType;\n+                if (boundIfaceType instanceof Schema.IfaceType.Struct || boundIfaceType instanceof Schema.IfaceType.Union) {\n+                    MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(simpleMemberName);\n+                    var layout = hatPtrType.layout();\n+                    if (layout instanceof GroupLayout) {\n+                        this.memberOffset = hatPtrType.layout().byteOffset(memberPathElement);\n+                        MemoryLayout memberLayout = hatPtrType.layout().select(memberPathElement);\n+                        System.out.println(memberLayout);\n+                        this.resultType = new OpsAndTypes.HatPtrType<>((Class<T>) boundIfaceType.iface, boundSchemaNode.children.get(0));\n+                    } else {\n+                        throw new IllegalStateException(\"Where did this layout come from\");\n+                    }\n+                } else {\n+                    throw new IllegalArgumentException(\"Pointer type layout is not struct  union struct  \" + hatPtrType.layout());\n+                }\n+            } else {\n+                this.resultType = ptr.type();\n+                this.memberOffset = 0;\n+                this.hatPtrType = null;\n+                \/\/ this.resultType = null;\/\/new HatPtr.HatPtrType<>((Class<T>) hatPtrType.mappableIface,boundSchemaNode.children.get(0));\n+                \/\/  throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+        }\n+\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+            attrs.put(\"\", simpleMemberName);\n+            attrs.put(ATTRIBUTE_OFFSET, memberOffset);\n+            return attrs;\n+        }\n+    }\n+\n+\n+    public static abstract class HatPtrAccessValue extends Op {\n+        final String name;\n+        final TypeElement resultType;\n+        final TypeElement typeElement;\n+\n+        HatPtrAccessValue(String name, TypeElement typeElement, HatPtrAccessValue that, CopyContext cc) {\n+            super(that, cc);\n+            this.name = name;\n+            this.typeElement = typeElement;\n+            this.resultType = that.resultType;\n+        }\n+\n+        public HatPtrAccessValue(String name, TypeElement typeElement, TypeElement resultType, List<Value> values) {\n+            super(name, values);\n+            this.name = name;\n+            this.typeElement = typeElement;\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(HatPtrLoadValue.NAME)\n+    public static final class HatPtrLoadValue extends HatPtrAccessValue {\n+        public static final String NAME = \"ptr.load.value\";\n+\n+        HatPtrLoadValue(TypeElement typeElement, HatPtrLoadValue that, CopyContext cc) {\n+            super(NAME, typeElement, that, cc);\n+        }\n+\n+        public HatPtrLoadValue(TypeElement typeElement, Value ptr) {\n+            super(NAME, typeElement, ((OpsAndTypes.HatPtrType<?>) ptr.type()).referringType(), List.of(ptr));\n+        }\n+        public HatPtrLoadValue(TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n+        }\n+\n+        @Override\n+        public HatPtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n+            return new HatPtrLoadValue(typeElement, this, cc);\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(HatPtrStoreValue.NAME)\n+    public static final class HatPtrStoreValue extends HatPtrAccessValue {\n+        public static final String NAME = \"ptr.store.value\";\n+\n+        public HatPtrStoreValue(TypeElement typeElement, HatPtrStoreValue that, CopyContext cc) {\n+            super(NAME, typeElement, that, cc);\n+        }\n+\n+        public HatPtrStoreValue(TypeElement typeElement, PrimitiveType resultType, List<Value> operandValues) {\n+            super(NAME, typeElement, resultType, operandValues);\n+        }\n+\n+        public HatPtrStoreValue(TypeElement typeElement, Value ptr, Value arg1) {\n+            super(NAME, typeElement, JavaType.VOID, List.of(ptr, arg1));\n+        }\n+\n+        public HatPtrStoreValue(TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n+        }\n+\n+\n+        @Override\n+        public HatPtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n+            return new HatPtrStoreValue(typeElement, this, cc);\n+        }\n+    }\n+\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/OpsAndTypes.java","additions":421,"deletions":0,"binary":false,"changes":421,"status":"added"},{"patch":"@@ -78,1 +78,1 @@\n-        Set<Schema.SchemaNode.IfaceType> already = new LinkedHashSet<>();\n+        Set<Schema.IfaceType> already = new LinkedHashSet<>();\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/C99NativeBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-import hat.HatPtr;\n+import hat.OpsAndTypes;\n@@ -132,1 +132,1 @@\n-                FunctionType functionType = HatPtr.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n+                FunctionType functionType = OpsAndTypes.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n@@ -137,1 +137,1 @@\n-                CoreOp.FuncOp ssaPtrForm = HatPtr.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n+                CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -111,4 +111,8 @@\n-            case ExtendedOp.JavaConditionalAndOp o -> 10;\n-            case ExtendedOp.JavaConditionalOrOp o -> 11;\n-            case ExtendedOp.JavaConditionalExpressionOp o -> 12;\n-            case CoreOp.ReturnOp o -> 12;\n+\n+            case CoreOp.AndOp o -> 11;\n+            case CoreOp.XorOp o -> 12;\n+            case CoreOp.OrOp o -> 13;\n+            case ExtendedOp.JavaConditionalAndOp o -> 14;\n+            case ExtendedOp.JavaConditionalOrOp o -> 15;\n+            case ExtendedOp.JavaConditionalExpressionOp o -> 18;\n+            case CoreOp.ReturnOp o -> 19;\n@@ -208,0 +212,3 @@\n+            case CoreOp.AndOp o -> ampersand();\n+            case CoreOp.OrOp o -> bar();\n+            case CoreOp.XorOp o -> hat();\n@@ -419,2 +426,2 @@\n-    public T typedef(BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceType ifaceType) {\n-        typedefKeyword().space().structOrUnion(ifaceType instanceof Schema.SchemaNode.Struct)\n+    public T typedef(BoundSchema<?> boundSchema, Schema.IfaceType ifaceType) {\n+        typedefKeyword().space().structOrUnion(ifaceType instanceof Schema.IfaceType.Struct)\n@@ -427,1 +434,1 @@\n-                        if (field instanceof Schema.SchemaNode.AbstractPrimitiveField primitiveField) {\n+                        if (field instanceof Schema.FieldNode.AbstractPrimitiveField primitiveField) {\n@@ -430,2 +437,2 @@\n-                            if (primitiveField instanceof Schema.SchemaNode.PrimitiveArray array) {\n-                                if (array instanceof Schema.SchemaNode.PrimitiveFieldControlledArray fieldControlledArray) {\n+                            if (primitiveField instanceof Schema.FieldNode.PrimitiveArray array) {\n+                                if (array instanceof Schema.FieldNode.PrimitiveFieldControlledArray fieldControlledArray) {\n@@ -446,1 +453,1 @@\n-                                } else if (array instanceof Schema.SchemaNode.PrimitiveFixedArray fixed) {\n+                                } else if (array instanceof Schema.FieldNode.PrimitiveFixedArray fixed) {\n@@ -452,2 +459,2 @@\n-                        } else if (field instanceof Schema.SchemaNode.AbstractIfaceField ifaceField) {\n-                            suffix_t(ifaceField.type.iface.getSimpleName());\n+                        } else if (field instanceof Schema.FieldNode.AbstractIfaceField ifaceField) {\n+                            suffix_t(ifaceField.ifaceType.iface.getSimpleName());\n@@ -455,2 +462,2 @@\n-                            if (ifaceField instanceof Schema.SchemaNode.IfaceArray array) {\n-                                if (array instanceof Schema.SchemaNode.IfaceFieldControlledArray fieldControlledArray) {\n+                            if (ifaceField instanceof Schema.FieldNode.IfaceArray array) {\n+                                if (array instanceof Schema.FieldNode.IfaceFieldControlledArray fieldControlledArray) {\n@@ -471,1 +478,1 @@\n-                                } else if (array instanceof Schema.SchemaNode.IfaceFixedArray fixed) {\n+                                } else if (array instanceof Schema.FieldNode.IfaceFixedArray fixed) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatBuilder.java","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -6,0 +6,2 @@\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n@@ -7,0 +9,1 @@\n+import java.util.ArrayList;\n@@ -9,1 +12,6 @@\n-public sealed interface BoundSchema<T extends Buffer> permits BoundSchemaNode.BoundSchemaRootNode{\n+public class BoundSchema<T extends Buffer> {\n+    final private List<BoundArrayFieldLayout> boundArrayFields = new ArrayList<>();\n+    final private int[] arrayLengths;\n+    final private Schema<T> schema;\n+    final private GroupLayout groupLayout;\n+    BoundSchemaNode<?> rootBoundSchemaNode;\n@@ -11,1 +19,3 @@\n-    T allocate(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator);\n+    public static sealed class FieldLayout<T extends Schema.FieldNode> permits ArrayFieldLayout {\n+        public final T field;\n+        public MemoryLayout layout;\n@@ -13,1 +23,5 @@\n-    Schema<T> schema();\n+        FieldLayout(T field, MemoryLayout layout) {\n+            this.field = field;\n+            this.layout = layout;\n+        }\n+    }\n@@ -15,1 +29,109 @@\n-    List<BoundSchemaNode.BoundArrayFieldLayout> boundArrayFields();\n+    public sealed static class ArrayFieldLayout extends FieldLayout<Schema.FieldNode>\n+            permits BoundArrayFieldLayout {\n+        public final int len;\n+\n+        ArrayFieldLayout(Schema.FieldNode fieldControlledArray, MemoryLayout layout, int len) {\n+            super(fieldControlledArray, layout);\n+            this.len = len;\n+        }\n+    }\n+\n+    public static final class BoundArrayFieldLayout extends ArrayFieldLayout {\n+        public final int idx;\n+\n+        BoundArrayFieldLayout(Schema.FieldNode fieldControlledArray, MemoryLayout layout, int len, int idx) {\n+            super(fieldControlledArray, layout, len);\n+            this.idx = idx;\n+        }\n+    }\n+    public BoundSchema(Schema<T> schema, int... arrayLengths) {\n+        this.schema = schema;\n+        this.arrayLengths = arrayLengths;\n+        this.rootBoundSchemaNode = new BoundSchemaNode<>((BoundSchema<Buffer>) this, null, this.schema.rootIfaceType);\n+        this.groupLayout = schema.rootIfaceType.getBoundGroupLayout(rootBoundSchemaNode);\n+        this.rootBoundSchemaNode.memoryLayouts.add(this.groupLayout);\n+    }\n+\n+    int takeArrayLen() {\n+        return arrayLengths[boundArrayFields.size()];\n+    }\n+\n+    public T allocate(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator) {\n+        return bufferAllocator.allocate(SegmentMapper.of(lookup, schema.iface, groupLayout, this), this);\n+    }\n+\n+    public Schema<T> schema() {\n+        return schema;\n+    }\n+\n+    public List<BoundArrayFieldLayout> boundArrayFields() {\n+        return boundArrayFields;\n+    }\n+\n+    public GroupLayout groupLayout() {\n+        return groupLayout;\n+    }\n+\n+    public BoundSchemaNode<?> rootBoundSchemaNode() {\n+        return rootBoundSchemaNode;\n+    }\n+\n+\n+    FieldLayout<?> createFieldBinding(Schema.FieldNode fieldNode, MemoryLayout memoryLayout) {\n+        if (fieldNode instanceof Schema.FieldNode.IfaceFieldControlledArray\n+                || fieldNode instanceof Schema.FieldNode.PrimitiveFieldControlledArray) {\n+            int idx = boundArrayFields.size();\n+            var arraySizeBinding = new BoundArrayFieldLayout(fieldNode, memoryLayout, arrayLengths[idx], idx);\n+            boundArrayFields.add(arraySizeBinding);\n+            return arraySizeBinding;\n+        } else if (fieldNode instanceof Schema.FieldNode.IfaceFixedArray ifaceMapableFixedArray) {\n+            return new ArrayFieldLayout(fieldNode, memoryLayout, ifaceMapableFixedArray.len);\n+        } else if (fieldNode instanceof Schema.FieldNode.PrimitiveFixedArray primitiveFixedArray) {\n+            return new ArrayFieldLayout(fieldNode, memoryLayout, primitiveFixedArray.len);\n+        } else {\n+            return new FieldLayout<>(fieldNode, memoryLayout);\n+        }\n+    }\n+\n+    public static class BoundSchemaNode<T extends MappableIface> {\n+        final public  BoundSchema<Buffer> boundSchema;\n+        final public  BoundSchemaNode<T> parent;\n+        final public List<BoundSchemaNode<?>> children = new ArrayList<>();\n+        final public List<MemoryLayout> memoryLayouts = new ArrayList<>();\n+        final public List<FieldLayout<?>> fieldLayouts = new ArrayList<>();\n+        final public Schema.IfaceType ifaceType;\n+\n+        BoundSchemaNode(BoundSchema<Buffer> boundSchema, BoundSchemaNode<T> parent, Schema.IfaceType ifaceType) {\n+            this.boundSchema = boundSchema;\n+            this.parent = parent;\n+            this.ifaceType = ifaceType;\n+        }\n+\n+        int takeArrayLen() {\n+            return boundSchema.takeArrayLen();\n+        }\n+\n+\n+        FieldLayout<?> createFieldBinding(Schema.FieldNode fieldNode, MemoryLayout memoryLayout) {\n+            return boundSchema.createFieldBinding(fieldNode, memoryLayout);\n+        }\n+\n+        void bind(Schema.FieldNode fieldNode, MemoryLayout memoryLayout) {\n+            fieldLayouts.add(createFieldBinding(fieldNode, memoryLayout));\n+            memoryLayouts.add(memoryLayout);\n+        }\n+\n+        public MemoryLayout[] memoryLayoutListToArray() {\n+            return memoryLayouts.toArray(new MemoryLayout[0]);\n+        }\n+\n+        public BoundSchemaNode<T> createChild(Schema.IfaceType ifaceType) {\n+            var boundSchemaChildNode = new BoundSchemaNode<T>(boundSchema, this, ifaceType);\n+            children.add(boundSchemaChildNode);\n+            return boundSchemaChildNode;\n+        }\n+\n+        public FieldLayout<?> getBoundFieldChild(String fieldName) {\n+            return fieldLayouts.stream().filter(fieldLayout -> fieldLayout.field.name.equals(fieldName)).findFirst().orElseThrow();\n+        }\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/BoundSchema.java","additions":126,"deletions":4,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -1,136 +0,0 @@\n-package hat.ifacemapper;\n-\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import static hat.ifacemapper.Schema.SchemaNode.IfaceType;\n-\n-public abstract sealed class BoundSchemaNode\n-        permits  BoundSchemaNode.BoundSchemaChildNode, BoundSchemaNode.BoundSchemaRootNode {\n-\n-    static sealed class FieldLayout<T extends Schema.SchemaNode.FieldNode> permits ArrayFieldLayout {\n-        public final T field;\n-        public MemoryLayout layout;\n-        FieldLayout(T field, MemoryLayout layout) {\n-            this.field = field;\n-            this.layout = layout;\n-        }\n-    }\n-    public sealed static class ArrayFieldLayout extends FieldLayout<Schema.SchemaNode.FieldNode>\n-            permits BoundArrayFieldLayout {\n-        public final int len;\n-        ArrayFieldLayout(Schema.SchemaNode.FieldNode fieldControlledArray, MemoryLayout layout, int len) {\n-            super(fieldControlledArray, layout);\n-            this.len = len;\n-        }\n-    }\n-    public static final class BoundArrayFieldLayout extends ArrayFieldLayout {\n-        public final int idx;\n-        BoundArrayFieldLayout(Schema.SchemaNode.FieldNode fieldControlledArray, MemoryLayout layout, int len, int idx) {\n-            super(fieldControlledArray, layout, len);\n-            this.idx = idx;\n-        }\n-    }\n-\n-    final protected BoundSchemaNode parent;\n-    final List<BoundSchemaChildNode> children = new ArrayList<>();\n-    final List<MemoryLayout> memoryLayouts = new ArrayList<>();\n-    final List<FieldLayout<?>> fieldLayouts = new ArrayList<>();\n-    final Schema.SchemaNode.IfaceType ifaceType;\n-\n-    BoundSchemaNode(BoundSchemaNode parent, Schema.SchemaNode.IfaceType ifaceType) {\n-        this.parent = parent;\n-        this.ifaceType = ifaceType;\n-    }\n-\n-    abstract int takeArrayLen();\n-\n-    abstract FieldLayout<?> createFieldBinding(Schema.SchemaNode.FieldNode namedFieldNode, MemoryLayout memoryLayout);\n-\n-    void bind(Schema.SchemaNode.FieldNode fieldNode, MemoryLayout memoryLayout) {\n-        fieldLayouts.add(createFieldBinding(fieldNode, memoryLayout));\n-        memoryLayouts.add(memoryLayout);\n-    }\n-\n-    public MemoryLayout[] memoryLayoutListToArray() {\n-        return memoryLayouts.toArray(new MemoryLayout[0]);\n-    }\n-\n-    public BoundSchemaChildNode createChild(Schema.SchemaNode.IfaceType ifaceType) {\n-        var boundSchemaChildNode = new BoundSchemaChildNode(this, ifaceType);\n-        children.add(boundSchemaChildNode);\n-        return boundSchemaChildNode;\n-    }\n-\n-    public static final class BoundSchemaRootNode<T extends Buffer> extends BoundSchemaNode implements BoundSchema<T> {\n-        final private List<BoundArrayFieldLayout> boundArrayFields=new ArrayList<>();\n-        final private int[] arrayLengths;\n-        final private Schema<T> schema;\n-        final private GroupLayout groupLayout;\n-\n-        public BoundSchemaRootNode(Schema<T> schema, int... arrayLengths) {\n-            super(null, schema.rootIfaceType);\n-            this.schema = schema;\n-            this.arrayLengths = arrayLengths;\n-            this.groupLayout =ifaceType.getBoundGroupLayout(this);\n-            memoryLayouts.add(this.groupLayout);\n-        }\n-        @Override\n-        public T allocate(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator) {\n-            return bufferAllocator.allocate(SegmentMapper.of(lookup, schema.iface, groupLayout, this), this);\n-        }\n-\n-        @Override\n-        public Schema<T> schema(){\n-            return schema;\n-        }\n-\n-        @Override\n-        public List<BoundArrayFieldLayout> boundArrayFields() {\n-            return boundArrayFields;\n-        }\n-\n-        @Override\n-        int takeArrayLen() {\n-            return arrayLengths[boundArrayFields.size()];\n-        }\n-\n-        @Override\n-        FieldLayout<?> createFieldBinding(Schema.SchemaNode.FieldNode fieldNode, MemoryLayout memoryLayout) {\n-            if (fieldNode instanceof Schema.SchemaNode.IfaceFieldControlledArray\n-                    || fieldNode instanceof Schema.SchemaNode.PrimitiveFieldControlledArray) {\n-                int idx = boundArrayFields.size();\n-                var arraySizeBinding = new BoundArrayFieldLayout(fieldNode, memoryLayout, arrayLengths[idx], idx);\n-                boundArrayFields.add(arraySizeBinding);\n-                return arraySizeBinding;\n-            }else  if (fieldNode instanceof Schema.SchemaNode.IfaceFixedArray ifaceMapableFixedArray){\n-                return new ArrayFieldLayout(fieldNode, memoryLayout,  ifaceMapableFixedArray.len);\n-            }else  if (fieldNode instanceof Schema.SchemaNode.PrimitiveFixedArray primitiveFixedArray){\n-                return new ArrayFieldLayout(fieldNode, memoryLayout, primitiveFixedArray.len);\n-            }else{\n-                return new FieldLayout<>(fieldNode,memoryLayout);\n-            }\n-        }\n-    }\n-\n-    public static final class BoundSchemaChildNode extends BoundSchemaNode {\n-        BoundSchemaChildNode(BoundSchemaNode parent, Schema.SchemaNode.IfaceType ifaceType) {\n-            super(parent, ifaceType);\n-        }\n-        @Override\n-        int takeArrayLen() {\n-            return parent.takeArrayLen();\n-        }\n-\n-        @Override\n-        FieldLayout<?> createFieldBinding(Schema.SchemaNode.FieldNode namedFieldNode, MemoryLayout memoryLayout) {\n-            return parent.createFieldBinding(namedFieldNode, memoryLayout);\n-        }\n-    }\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/BoundSchemaNode.java","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -181,1 +181,1 @@\n-    static boolean isMappableIface(Class<?> clazz) {\n+    public static boolean isMappableIface(Class<?> clazz) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/MapperUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -20,1 +20,1 @@\n-    final public SchemaNode.IfaceType rootIfaceType;\n+    final public IfaceType rootIfaceType;\n@@ -23,2 +23,32 @@\n-    public static abstract sealed class SchemaNode permits SchemaNode.FieldNode, SchemaNode.IfaceType {\n-        public IfaceType parent;\n+    public static abstract class SchemaNode {\n+        public static final class Padding extends FieldNode {\n+            int len;\n+\n+            Padding(IfaceType parent, int len) {\n+                super(parent, AccessorInfo.Key.NONE, \"pad\" + len);\n+                this.len = len;\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"padding \" + len + \" bytes\");\n+            }\n+        }\n+    }\n+\n+    Schema(Class<T> iface, IfaceType rootIfaceType) {\n+        this.iface = iface;\n+        this.rootIfaceType = rootIfaceType;\n+    }\n+\n+\n+    public T allocate(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int... boundLengths) {\n+        BoundSchema<?> boundSchema = new BoundSchema<>(this, boundLengths);\n+        return (T) boundSchema.allocate(lookup, bufferAllocator);\n+    }\n+\n+    public static <T extends Buffer> Schema<T> of(Class<T> iface, Consumer<IfaceType> parentFieldConsumer) {\n+        var struct = new IfaceType.Struct(null, (Class<MappableIface>) (Object) iface); \/\/ why the need for this?\n+        parentFieldConsumer.accept(struct);\n+        return new Schema<>(iface, struct);\n+    }\n@@ -26,1 +56,22 @@\n-        SchemaNode(IfaceType parent) {\n+    public void toText(Consumer<String> stringConsumer) {\n+        rootIfaceType.toText(\"\", stringConsumer);\n+    }\n+\n+    public static abstract sealed class IfaceType\n+            permits IfaceType.Union, IfaceType.Struct {\n+        public final IfaceType parent;\n+        public List<FieldNode> fields = new ArrayList<>();\n+        public List<IfaceType> ifaceTypes = new ArrayList<>();\n+        public Class<MappableIface> iface;\n+\n+        <T extends FieldNode> T addField(T child) {\n+            fields.add(child);\n+            return child;\n+        }\n+\n+        <T extends IfaceType> T addIfaceTypeNode(T child) {\n+            ifaceTypes.add(child);\n+            return child;\n+        }\n+\n+        IfaceType(IfaceType parent, Class<MappableIface> iface) {\n@@ -28,0 +79,1 @@\n+            this.iface = iface;\n@@ -30,1 +82,47 @@\n-        public abstract void toText(String indent, Consumer<String> stringConsumer);\n+        IfaceType getChild(Class<?> iface) {\n+            Optional<IfaceType> ifaceTypeNodeOptional = ifaceTypes\n+                    .stream()\n+                    .filter(n -> n.iface.equals(iface))\n+                    .findFirst();\n+            if (ifaceTypeNodeOptional.isPresent()) {\n+                return ifaceTypeNodeOptional.get();\n+            } else {\n+                throw new IllegalStateException(\"no supported iface type\");\n+            }\n+        }\n+\n+        public void visitTypes(int depth, Consumer<IfaceType> ifaceTypeNodeConsumer) {\n+            ifaceTypes.forEach(t -> t.visitTypes(depth + 1, ifaceTypeNodeConsumer));\n+            ifaceTypeNodeConsumer.accept(this);\n+        }\n+\n+        public GroupLayout getBoundGroupLayout(BoundSchema.BoundSchemaNode parentBoundSchemaNode) {\n+\n+            BoundSchema.BoundSchemaNode<?> child = parentBoundSchemaNode.createChild(this);\n+            this.fields.forEach(fieldNode -> {\n+                        if (fieldNode instanceof SchemaNode.Padding field) {\n+                            child.bind(field, MemoryLayout.paddingLayout(field.len));\n+                        } else if (fieldNode instanceof FieldNode.AddressField field) {\n+                            child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n+                        } else if (fieldNode instanceof FieldNode.ArrayLen field) {\n+                            child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n+                        } else if (fieldNode instanceof FieldNode.AtomicField field) {\n+                            child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n+                        } else if (fieldNode instanceof FieldNode.IfaceField field) {\n+                            child.bind(field, field.parent.getBoundLayout(field.ifaceType.iface, child).withName(field.name));\n+                        } else if (fieldNode instanceof FieldNode.PrimitiveField field) {\n+                            child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n+                        } else if (fieldNode instanceof FieldNode.IfaceFixedArray field) {\n+                            child.bind(field, MemoryLayout.sequenceLayout(field.len,\n+                                    field.parent.getBoundLayout(field.ifaceType.iface, child).withName(field.ifaceType.iface.getSimpleName())\n+                            ).withName(field.name));\n+                        } else if (fieldNode instanceof FieldNode.PrimitiveFixedArray field) {\n+                            child.bind(field, MemoryLayout.sequenceLayout(field.len,\n+                                    field.parent.getBoundLayout(field.type, child).withName(field.type.getSimpleName())\n+                            ).withName(field.name));\n+                        } else if (fieldNode instanceof FieldNode.IfaceFieldControlledArray field) {\n+                            \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n+                            int size = field.stride; \/\/usually 1 but developer can define.\n+                            for (int i = 0; i < field.contributingDims; i++) {\n+                                size *= child.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n+                            }\n@@ -32,4 +130,22 @@\n-        public static abstract sealed class FieldNode extends SchemaNode\n-                permits AddressField, AbstractIfaceField, Padding, AbstractPrimitiveField {\n-            public final AccessorInfo.Key key;\n-            public final String name;\n+                            child.bind(field, MemoryLayout.sequenceLayout(size,\n+                                    field.parent.getBoundLayout(field.ifaceType.iface, child).withName(field.ifaceType.iface.getSimpleName())\n+                            ).withName(field.name));\n+                        } else if (fieldNode instanceof FieldNode.PrimitiveFieldControlledArray field) {\n+                            \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n+                            int size = field.stride; \/\/usually 1 but developer can define.\n+                            for (int i = 0; i < field.contributingDims; i++) {\n+                                size *= child.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n+                            }\n+\n+                            child.bind(field, MemoryLayout.sequenceLayout(size,\n+                                    field.parent.getBoundLayout(field.type, child).withName(field.type.getSimpleName())\n+                            ).withName(field.name));\n+                        } else {\n+                            throw new IllegalStateException(\"what is this?\");\n+                        }\n+                    }\n+            );\n+            return (MapperUtil.isUnion(this.iface)\n+                    ? MemoryLayout.unionLayout(child.memoryLayoutListToArray())\n+                    : MemoryLayout.structLayout(child.memoryLayoutListToArray())).withName(this.iface.getSimpleName());\n+        }\n@@ -37,4 +153,17 @@\n-            FieldNode(IfaceType parent, AccessorInfo.Key key, String name) {\n-                super(parent);\n-                this.key = key;\n-                this.name = name;\n+        \/**\n+         * Get a layout which describes the type.\n+         * <p>\n+         * If tyoe holds a primitive (int, float) then just map to JAVA_INT, JAVA_FLOAT value layouts\n+         * Otherwise we look through the parent's children.  Which should include a type node struct\/union matching the type.\n+         *\n+         * @param type\n+         * @param boundSchemaNode\n+         * @return\n+         *\/\n+        MemoryLayout getBoundLayout(Class<?> type, BoundSchema.BoundSchemaNode boundSchemaNode) {\n+            if (type.isPrimitive()) {\n+                return MapperUtil.primitiveToLayout(type);\n+            } else if (MapperUtil.isMemorySegment(type)) {\n+                return ValueLayout.ADDRESS;\n+            } else {\n+                return getChild(type).getBoundGroupLayout(boundSchemaNode);\n@@ -42,1 +171,0 @@\n-            public abstract void toText(String indent, Consumer<String> stringConsumer);\n@@ -45,5 +173,66 @@\n-        public static final class Padding extends FieldNode {\n-            int len;\n-            Padding(IfaceType parent, int len) {\n-                super(parent, AccessorInfo.Key.NONE, \"pad\"+len);\n-                this.len = len;\n+        public IfaceType struct(String name, Consumer<IfaceType> parentSchemaNodeConsumer) {\n+            parentSchemaNodeConsumer.accept(addIfaceTypeNode(new Struct(this, (Class<MappableIface>) MapperUtil.typeOf(iface, name))));\n+            return this;\n+        }\n+\n+        public IfaceType union(String name, Consumer<IfaceType> parentSchemaNodeConsumer) {\n+            parentSchemaNodeConsumer.accept(addIfaceTypeNode(new Union(this, (Class<MappableIface>) MapperUtil.typeOf(iface, name))));\n+            return this;\n+        }\n+\n+        public IfaceType field(String name) {\n+            var key = AccessorInfo.Key.of(iface, name);\n+            var typeOf = MapperUtil.typeOf(iface, name);\n+            addField(MapperUtil.isMemorySegment(typeOf)\n+                    ? new FieldNode.AddressField(this, key, (Class<MemorySegment>) typeOf, name)\n+                    : MapperUtil.isMappableIface(typeOf)\n+                    ? new FieldNode.IfaceField(this, key, this.getChild(typeOf), name)\n+                    : new FieldNode.PrimitiveField(this, key, typeOf, name));\n+            return this;\n+        }\n+\n+        public IfaceType atomic(String name) {\n+            addField(new FieldNode.AtomicField(this, AccessorInfo.Key.of(iface, name), MapperUtil.typeOf(iface, name), name));\n+            return this;\n+        }\n+\n+        public IfaceType pad(int len) {\n+            addField(new SchemaNode.Padding(this, len));\n+            return this;\n+        }\n+\n+        public IfaceType field(String name, Consumer<IfaceType> parentSchemaNodeConsumer) {\n+            AccessorInfo.Key fieldKey = AccessorInfo.Key.of(iface, name);\n+            Class<MappableIface> fieldType = (Class<MappableIface>) MapperUtil.typeOf(iface, name);\n+            IfaceType structOrUnion = MapperUtil.isStruct(fieldType) ? new Struct(this, fieldType) : new Union(this, fieldType);\n+            addIfaceTypeNode(structOrUnion);\n+            addField(new FieldNode.IfaceField(this, fieldKey, structOrUnion, name));\n+            parentSchemaNodeConsumer.accept(structOrUnion);\n+            return this;\n+        }\n+\n+        public IfaceType fields(String name1, String name2, Consumer<IfaceType> parentSchemaNodeConsumer) {\n+            AccessorInfo.Key fieldKey1 = AccessorInfo.Key.of(iface, name1);\n+            AccessorInfo.Key fieldKey2 = AccessorInfo.Key.of(iface, name2);\n+            if (!fieldKey1.equals(fieldKey2)) {\n+                throw new IllegalStateException(\"fields \" + name1 + \" and \" + name2 + \" have different keys\");\n+            }\n+            Class<MappableIface> structOrUnionType = (Class<MappableIface>) MapperUtil.typeOf(iface, name1);\n+            Class<?> fieldTypeCheck = MapperUtil.typeOf(iface, name2);\n+            if (!structOrUnionType.equals(fieldTypeCheck)) {\n+                throw new IllegalStateException(\"fields \" + name1 + \" and \" + name2 + \" have different types\");\n+            }\n+            IfaceType ifaceType = MapperUtil.isStruct(iface)\n+                    ? new Struct(this, structOrUnionType)\n+                    : new Union(this, structOrUnionType);\n+            addIfaceTypeNode(ifaceType);\n+            addField(new FieldNode.IfaceField(this, fieldKey1, ifaceType, name1));\n+            addField(new FieldNode.IfaceField(this, fieldKey2, ifaceType, name2));\n+\n+            parentSchemaNodeConsumer.accept(ifaceType);\n+            return this;\n+        }\n+\n+        public IfaceType fields(String... names) {\n+            for (var name : names) {\n+                field(name);\n@@ -51,3 +240,71 @@\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"padding \" + len + \" bytes\");\n+            return this;\n+        }\n+\n+        public IfaceType array(String name, int len) {\n+            AccessorInfo.Key arrayKey = AccessorInfo.Key.of(iface, name);\n+            var typeof = MapperUtil.typeOf(iface, name);\n+            addField(arrayKey.valueType().equals(ValueType.INTERFACE)\n+                    ? new FieldNode.IfaceFixedArray(this, arrayKey, this.getChild(typeof), name, len)\n+                    : new FieldNode.PrimitiveFixedArray(this, arrayKey, typeof, name, len));\n+            return this;\n+        }\n+\n+        public IfaceType array(String name, int len, Consumer<IfaceType> parentFieldConsumer) {\n+            AccessorInfo.Key arrayKey = AccessorInfo.Key.of(iface, name);\n+            Class<MappableIface> structOrUnionType = (Class<MappableIface>) MapperUtil.typeOf(iface, name);\n+            IfaceType ifaceType = MapperUtil.isStruct(iface)\n+                    ? new Struct(this, structOrUnionType)\n+                    : new Union(this, structOrUnionType);\n+            parentFieldConsumer.accept(ifaceType);\n+            addIfaceTypeNode(ifaceType);\n+            addField(new FieldNode.IfaceFixedArray(this, arrayKey, ifaceType, name, len));\n+            return this;\n+        }\n+\n+        private IfaceType fieldControlledArray(String name, List<FieldNode.ArrayLen> arrayLenFields, int stride) {\n+            AccessorInfo.Key arrayKey = AccessorInfo.Key.of(iface, name);\n+            var typeOf = MapperUtil.typeOf(iface, name);\n+            addField(arrayKey.valueType().equals(ValueType.INTERFACE)\n+                    ? new FieldNode.IfaceFieldControlledArray(this, arrayKey, this.getChild(typeOf), name, arrayLenFields, stride)\n+                    : new FieldNode.PrimitiveFieldControlledArray(this, arrayKey, typeOf, name, arrayLenFields, stride));\n+            return this;\n+        }\n+\n+        public static class ArrayBuildState {\n+            IfaceType ifaceType;\n+            List<FieldNode.ArrayLen> arrayLenFields;\n+            int padding = 0;\n+            int stride = 1;\n+\n+            public IfaceType array(String name) {\n+                return ifaceType.fieldControlledArray(name, arrayLenFields, stride);\n+            }\n+\n+            public ArrayBuildState stride(int stride) {\n+                this.stride = stride;\n+                return this;\n+            }\n+\n+            public ArrayBuildState pad(int padding) {\n+                this.padding = padding;\n+                var paddingField = new SchemaNode.Padding(ifaceType, padding);\n+                ifaceType.addField(paddingField);\n+                return this;\n+            }\n+\n+            public IfaceType array(String name, Consumer<IfaceType> parentFieldConsumer) {\n+                Class<MappableIface> arrayType = (Class<MappableIface>) MapperUtil.typeOf(this.ifaceType.iface, name);\n+                IfaceType ifaceType = MapperUtil.isStruct(arrayType)\n+                        ? new Struct(this.ifaceType, arrayType)\n+                        : new Union(this.ifaceType, arrayType);\n+                parentFieldConsumer.accept(ifaceType);\n+                this.ifaceType.addIfaceTypeNode(ifaceType);\n+                this.ifaceType.fieldControlledArray(name, arrayLenFields, stride);\n+\n+\n+                return this.ifaceType;\n+            }\n+\n+            ArrayBuildState(IfaceType ifaceType, List<FieldNode.ArrayLen> arrayLenFields) {\n+                this.ifaceType = ifaceType;\n+                this.arrayLenFields = arrayLenFields;\n@@ -57,6 +314,19 @@\n-        public static abstract sealed class AbstractPrimitiveField extends FieldNode\n-                permits PrimitiveArray, ArrayLen, AtomicField, PrimitiveField {\n-            public Class<?> type;\n-            AbstractPrimitiveField(IfaceType parent, AccessorInfo.Key key, Class<?> type, String name) {\n-                super(parent,key,  name);\n-                this.type = type;\n+        public ArrayBuildState arrayLen(String... arrayLenFieldNames) {\n+            List<FieldNode.ArrayLen> arrayLenFields = new ArrayList<>();\n+            Arrays.stream(arrayLenFieldNames).forEach(arrayLenFieldName -> {\n+                var arrayLenField = new FieldNode.ArrayLen(this, AccessorInfo.Key.of(iface, arrayLenFieldName), MapperUtil.typeOf(iface, arrayLenFieldName), arrayLenFieldName);\n+                addField(arrayLenField);\n+                arrayLenFields.add(arrayLenField);\n+            });\n+            return new ArrayBuildState(this, arrayLenFields);\n+        }\n+\n+\n+        public void toText(String indent, Consumer<String> stringConsumer) {\n+            stringConsumer.accept(indent);\n+            if (MapperUtil.isUnion(iface)) {\n+                stringConsumer.accept(\"union\");\n+            } else if (MapperUtil.isStructOrBuffer(iface)) {\n+                stringConsumer.accept(\"struct\");\n+            } else {\n+                throw new IllegalStateException(\"Oh my \");\n@@ -64,0 +334,13 @@\n+            stringConsumer.accept(\" \" + iface + \"{\");\n+            stringConsumer.accept(\"\\n\");\n+            ifaceTypes.forEach(ifaceType -> {\n+                ifaceType.toText(indent + \" TYPE: \", stringConsumer);\n+                stringConsumer.accept(\"\\n\");\n+            });\n+            fields.forEach(field -> {\n+                field.toText(indent + \" FIELD: \", stringConsumer);\n+                stringConsumer.accept(\"\\n\");\n+            });\n+\n+            stringConsumer.accept(indent);\n+            stringConsumer.accept(\"}\");\n@@ -66,6 +349,9 @@\n-        public static abstract sealed class AbstractIfaceField extends FieldNode\n-                permits IfaceArray, IfaceField {\n-            public IfaceType type;\n-            AbstractIfaceField(IfaceType parent, AccessorInfo.Key key, IfaceType type, String name) {\n-                super(parent,key, name);\n-                this.type = type;\n+        public static final class Struct extends IfaceType {\n+            Struct(IfaceType parent, Class<MappableIface> type) {\n+                super(parent, type);\n+            }\n+        }\n+\n+        public static final class Union extends IfaceType {\n+            Union(IfaceType parent, Class<MappableIface> type) {\n+                super(parent, type);\n@@ -74,0 +360,17 @@\n+    }\n+\n+    public static abstract sealed class FieldNode\n+            permits FieldNode.AddressField, FieldNode.AbstractIfaceField, SchemaNode.Padding, FieldNode.AbstractPrimitiveField {\n+        public IfaceType parent;\n+        public final AccessorInfo.Key key;\n+        public final String name;\n+\n+        FieldNode(IfaceType parent, AccessorInfo.Key key, String name) {\n+            this.parent = parent;\n+            this.key = key;\n+            this.name = name;\n+        }\n+\n+        public abstract void toText(String indent, Consumer<String> stringConsumer);\n+\n+\n@@ -76,0 +379,1 @@\n+\n@@ -86,0 +390,11 @@\n+\n+        public static abstract sealed class AbstractPrimitiveField extends FieldNode\n+                permits ArrayLen, AtomicField, PrimitiveArray, PrimitiveField {\n+            public Class<?> type;\n+\n+            AbstractPrimitiveField(IfaceType parent, AccessorInfo.Key key, Class<?> type, String name) {\n+                super(parent, key, name);\n+                this.type = type;\n+            }\n+        }\n+\n@@ -108,6 +423,0 @@\n-        public static final class IfaceField extends AbstractIfaceField {\n-\n-            IfaceField(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name) {\n-                super(parent, key, ifaceType,name);\n-\n-            }\n@@ -115,5 +424,0 @@\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"mappable field \" + key + \":\" + type.iface);\n-            }\n-        }\n@@ -121,1 +425,0 @@\n-\n@@ -132,5 +435,2 @@\n-        public abstract static sealed class IfaceArray extends AbstractIfaceField permits IfaceFieldControlledArray, IfaceFixedArray {\n-            IfaceArray(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name) {\n-                super(parent, key, ifaceType, name);\n-            }\n-        }\n+\n+\n@@ -142,2 +442,0 @@\n-        public static final class IfaceFixedArray extends IfaceArray {\n-            public int len;\n@@ -145,4 +443,0 @@\n-            IfaceFixedArray(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name, int len) {\n-                super(parent, key, ifaceType, name);\n-                this.len = len;\n-            }\n@@ -150,6 +444,0 @@\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"array [\" + len + \"]\");\n-            }\n-\n-        }\n@@ -170,17 +458,0 @@\n-        public static final class IfaceFieldControlledArray extends IfaceArray {\n-            List<ArrayLen> arrayLenFields;\n-            int stride;\n-            int contributingDims;\n-\n-            IfaceFieldControlledArray(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name, List<ArrayLen> arrayLenFields, int stride) {\n-                super(parent, key, ifaceType,name);\n-                this.arrayLenFields = arrayLenFields;\n-                this.stride = stride;\n-                this.contributingDims = arrayLenFields.size();\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + name + \"[\" + key + \":\" + type.iface + \"] where len defined by \" + arrayLenFields);\n-            }\n-        }\n@@ -205,124 +476,3 @@\n-        public static abstract sealed class IfaceType extends SchemaNode\n-                permits Union, Struct {\n-            public List<FieldNode> fields = new ArrayList<>();\n-            public List<IfaceType> ifaceTypes = new ArrayList<>();\n-            public Class<MappableIface> iface;\n-\n-            <T extends FieldNode> T addField(T child) {\n-                fields.add(child);\n-                return child;\n-            }\n-\n-            <T extends IfaceType> T addIfaceTypeNode(T child) {\n-                ifaceTypes.add(child);\n-                return child;\n-            }\n-\n-            IfaceType(IfaceType parent, Class<MappableIface> iface) {\n-                super(parent);\n-                this.iface = iface;\n-            }\n-\n-            IfaceType getChild(Class<?> iface){\n-                Optional<IfaceType> ifaceTypeNodeOptional = ifaceTypes\n-                        .stream()\n-                        .filter(n->n.iface.equals(iface))\n-                        .findFirst();\n-                if (ifaceTypeNodeOptional.isPresent()){\n-                    return ifaceTypeNodeOptional.get();\n-                }else {\n-                    throw new IllegalStateException(\"no supported iface type\");\n-                }\n-            }\n-\n-            public void visitTypes(int depth, Consumer<IfaceType> ifaceTypeNodeConsumer) {\n-                ifaceTypes.forEach(t->t.visitTypes(depth+1,ifaceTypeNodeConsumer));\n-                ifaceTypeNodeConsumer.accept(this);\n-            }\n-\n-            public GroupLayout getBoundGroupLayout( BoundSchemaNode parentBoundSchemaNode){\n-\n-                BoundSchemaNode child =parentBoundSchemaNode.createChild(this);\n-                this.fields.forEach(fieldNode -> {\n-                            if (fieldNode instanceof Padding field) {\n-                                child.bind(field, MemoryLayout.paddingLayout(field.len));\n-                            }else if (fieldNode instanceof AddressField field) {\n-                                child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n-                            }else if (fieldNode instanceof ArrayLen field) {\n-                                child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n-                            }else if (fieldNode instanceof AtomicField field) {\n-                                child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n-                            }else if (fieldNode instanceof IfaceField field) {\n-                                child.bind(field, field.parent.getBoundLayout(field.type.iface, child).withName(field.name));\n-                            }else if (fieldNode instanceof PrimitiveField field) {\n-                                child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n-                            }else if (fieldNode instanceof IfaceFixedArray field) {\n-                                child.bind(field, MemoryLayout.sequenceLayout(field.len,\n-                                        field.parent.getBoundLayout(field.type.iface, child).withName(field.type.iface.getSimpleName())\n-                                ).withName(field.name));\n-                            }else if (fieldNode instanceof PrimitiveFixedArray field) {\n-                                child.bind(field, MemoryLayout.sequenceLayout(field.len,\n-                                        field.parent.getBoundLayout(field.type, child).withName(field.type.getSimpleName())\n-                                ).withName(field.name));\n-                            }else if (fieldNode instanceof IfaceFieldControlledArray field) {\n-\n-                                \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n-                                int size = field.stride; \/\/usually 1 but developer can define.\n-                                for (int i = 0; i < field.contributingDims; i++) {\n-                                    size *= child.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n-                                }\n-\n-                                child.bind(field, MemoryLayout.sequenceLayout(size,\n-                                        field.parent.getBoundLayout(field.type.iface, child).withName(field.type.iface.getSimpleName())\n-                                ).withName(field.name));\n-                            }else if (fieldNode instanceof PrimitiveFieldControlledArray field){\n-\n-                                    \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n-                                    int size = field.stride; \/\/usually 1 but developer can define.\n-                                    for (int i = 0; i < field.contributingDims; i++) {\n-                                        size *= child.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n-                                    }\n-\n-                                    child.bind(field, MemoryLayout.sequenceLayout(size,\n-                                            field.parent.getBoundLayout(field.type, child).withName(field.type.getSimpleName())\n-                                    ).withName(field.name));\n-\n-                            }else {\n-                                throw new IllegalStateException(\"what is this?\");\n-                            }\n-                        }\n-                );\n-                return (MapperUtil.isUnion(this.iface)\n-                        ? MemoryLayout.unionLayout(child.memoryLayoutListToArray())\n-                        : MemoryLayout.structLayout(child.memoryLayoutListToArray())).withName(this.iface.getSimpleName());\n-            }\n-\n-            \/**\n-             * Get a layout which describes the type.\n-             * <p>\n-             * If tyoe holds a primitive (int, float) then just map to JAVA_INT, JAVA_FLOAT value layouts\n-             * Otherwise we look through the parent's children.  Which should include a type node struct\/union matching the type.\n-             *\n-             * @param type\n-             * @param boundSchemaNode\n-             * @return\n-             *\/\n-            MemoryLayout getBoundLayout(Class<?> type, BoundSchemaNode boundSchemaNode) {\n-                if (type.isPrimitive()) {\n-                    return MapperUtil.primitiveToLayout(type);\n-                }else if (MapperUtil.isMemorySegment(type)) {\n-                    return ValueLayout.ADDRESS;\n-                } else {\n-                   return  getChild(type).getBoundGroupLayout( boundSchemaNode);\n-                }\n-            }\n-\n-            public IfaceType struct(String name, Consumer<IfaceType> parentSchemaNodeConsumer) {\n-                parentSchemaNodeConsumer.accept(addIfaceTypeNode(new Struct(this, (Class<MappableIface>)MapperUtil.typeOf(iface, name))));\n-                return this;\n-            }\n-\n-            public IfaceType union(String name, Consumer<IfaceType> parentSchemaNodeConsumer) {\n-                parentSchemaNodeConsumer.accept(addIfaceTypeNode(new Union(this, (Class<MappableIface>) MapperUtil.typeOf(iface, name))));\n-                return this;\n-            }\n+        public static abstract sealed class AbstractIfaceField extends FieldNode\n+                permits FieldNode.IfaceArray, FieldNode.IfaceField {\n+            public IfaceType ifaceType;\n@@ -330,9 +480,3 @@\n-            public IfaceType field(String name) {\n-                var key = AccessorInfo.Key.of(iface, name);\n-                var typeOf = MapperUtil.typeOf(iface, name);\n-                addField(MapperUtil.isMemorySegment(typeOf)\n-                        ? new AddressField(this, key, (Class<MemorySegment>)typeOf, name)\n-                        : MapperUtil.isMappableIface(typeOf)\n-                           ? new IfaceField(this, key, this.getChild(typeOf), name)\n-                           : new PrimitiveField(this, key, typeOf, name));\n-                return this;\n+            AbstractIfaceField(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name) {\n+                super(parent, key, name);\n+                this.ifaceType = ifaceType;\n@@ -340,0 +484,1 @@\n+        }\n@@ -341,4 +486,0 @@\n-            public IfaceType atomic(String name) {\n-                addField(new AtomicField(this, AccessorInfo.Key.of(iface, name), MapperUtil.typeOf(iface, name), name));\n-                return this;\n-            }\n@@ -346,4 +487,1 @@\n-            public IfaceType pad(int len) {\n-                addField(new Padding(this, len));\n-                return this;\n-            }\n+        public static final class IfaceField extends AbstractIfaceField {\n@@ -351,9 +489,2 @@\n-            public IfaceType field(String name, Consumer<IfaceType> parentSchemaNodeConsumer) {\n-                AccessorInfo.Key fieldKey = AccessorInfo.Key.of(iface, name);\n-                Class<MappableIface> fieldType = (Class<MappableIface>)MapperUtil.typeOf(iface, name);\n-                IfaceType structOrUnion= MapperUtil.isStruct(fieldType) ? new Struct(this, fieldType) : new Union(this, fieldType);\n-                addIfaceTypeNode(structOrUnion);\n-                addField(new IfaceField(this, fieldKey, structOrUnion,name));\n-                parentSchemaNodeConsumer.accept(structOrUnion);\n-                return this;\n-            }\n+            IfaceField(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name) {\n+                super(parent, key, ifaceType, name);\n@@ -361,20 +492,0 @@\n-            public IfaceType fields(String name1, String name2, Consumer<IfaceType> parentSchemaNodeConsumer) {\n-                AccessorInfo.Key fieldKey1 = AccessorInfo.Key.of(iface, name1);\n-                AccessorInfo.Key fieldKey2 = AccessorInfo.Key.of(iface, name2);\n-                if (!fieldKey1.equals(fieldKey2)) {\n-                    throw new IllegalStateException(\"fields \" + name1 + \" and \" + name2 + \" have different keys\");\n-                }\n-                Class<MappableIface> structOrUnionType = (Class<MappableIface>) MapperUtil.typeOf(iface, name1);\n-                Class<?> fieldTypeCheck = MapperUtil.typeOf(iface, name2);\n-                if (!structOrUnionType.equals(fieldTypeCheck)) {\n-                    throw new IllegalStateException(\"fields \" + name1 + \" and \" + name2 + \" have different types\");\n-                }\n-                IfaceType ifaceType = MapperUtil.isStruct(iface)\n-                        ? new Struct(this, structOrUnionType)\n-                        : new Union(this, structOrUnionType);\n-                addIfaceTypeNode(ifaceType);\n-                addField(new IfaceField(this, fieldKey1, ifaceType,name1));\n-                addField(new IfaceField(this, fieldKey2, ifaceType,name2));\n-\n-                parentSchemaNodeConsumer.accept(ifaceType);\n-                return this;\n@@ -383,5 +494,3 @@\n-            public IfaceType fields(String... names) {\n-                for (var name : names) {\n-                    field(name);\n-                }\n-                return this;\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"mappable field \" + key + \":\" + ifaceType.iface);\n@@ -389,0 +498,1 @@\n+        }\n@@ -390,8 +500,0 @@\n-            public IfaceType array(String name, int len) {\n-                AccessorInfo.Key arrayKey = AccessorInfo.Key.of(iface, name);\n-                var typeof = MapperUtil.typeOf(iface,name);\n-                addField(arrayKey.valueType().equals(ValueType.INTERFACE)\n-                        ?new IfaceFixedArray( this,arrayKey,this.getChild(typeof),name, len)\n-                        :new PrimitiveFixedArray(this, arrayKey, typeof, name, len));\n-                return this;\n-            }\n@@ -399,10 +501,3 @@\n-            public IfaceType array(String name, int len, Consumer<IfaceType> parentFieldConsumer) {\n-                AccessorInfo.Key arrayKey = AccessorInfo.Key.of(iface, name);\n-                Class<MappableIface> structOrUnionType = (Class<MappableIface>)MapperUtil.typeOf(iface, name);\n-                IfaceType ifaceType = MapperUtil.isStruct(iface)\n-                        ? new Struct(this, structOrUnionType)\n-                        : new Union(this, structOrUnionType);\n-                parentFieldConsumer.accept(ifaceType);\n-                addIfaceTypeNode(ifaceType);\n-                addField(new IfaceFixedArray(this, arrayKey, ifaceType, name, len));\n-                return this;\n+        public abstract static sealed class IfaceArray extends AbstractIfaceField permits IfaceFieldControlledArray, IfaceFixedArray {\n+            IfaceArray(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name) {\n+                super(parent, key, ifaceType, name);\n@@ -410,0 +505,1 @@\n+        }\n@@ -411,8 +507,2 @@\n-            private IfaceType fieldControlledArray(String name, List<ArrayLen> arrayLenFields, int stride) {\n-                AccessorInfo.Key arrayKey = AccessorInfo.Key.of(iface, name);\n-                var typeOf = MapperUtil.typeOf(iface, name);\n-                addField(arrayKey.valueType().equals(ValueType.INTERFACE)\n-                        ?new IfaceFieldControlledArray(this, arrayKey, this.getChild(typeOf),name,  arrayLenFields, stride)\n-                        :new PrimitiveFieldControlledArray(this, arrayKey, typeOf, name,  arrayLenFields, stride));\n-                return this;\n-            }\n+        public static final class IfaceFixedArray extends IfaceArray {\n+            public int len;\n@@ -420,47 +510,3 @@\n-            public static class ArrayBuildState {\n-                IfaceType ifaceType;\n-                List<ArrayLen> arrayLenFields;\n-                int padding =0;\n-                int stride = 1;\n-\n-                public IfaceType array(String name) {\n-                    return ifaceType.fieldControlledArray(name, arrayLenFields, stride);\n-                }\n-\n-                public ArrayBuildState stride(int stride) {\n-                    this.stride = stride;\n-                    return this;\n-                }\n-                public ArrayBuildState pad(int padding) {\n-                    this.padding = padding;\n-                    var paddingField = new Padding(ifaceType, padding);\n-                    ifaceType.addField(paddingField);\n-                    return this;\n-                }\n-                public IfaceType array(String name, Consumer<IfaceType> parentFieldConsumer) {\n-                    Class<MappableIface> arrayType = (Class<MappableIface>) MapperUtil.typeOf(this.ifaceType.iface, name);\n-                    IfaceType ifaceType = MapperUtil.isStruct(arrayType)\n-                            ? new Struct(this.ifaceType, arrayType)\n-                            : new Union(this.ifaceType, arrayType);\n-                    parentFieldConsumer.accept(ifaceType);\n-                    this.ifaceType.addIfaceTypeNode(ifaceType);\n-                    this.ifaceType.fieldControlledArray(name, arrayLenFields, stride);\n-\n-\n-                    return this.ifaceType;\n-                }\n-\n-                ArrayBuildState(IfaceType ifaceType, List<ArrayLen> arrayLenFields) {\n-                    this.ifaceType = ifaceType;\n-                    this.arrayLenFields = arrayLenFields;\n-                }\n-            }\n-\n-            public ArrayBuildState arrayLen(String... arrayLenFieldNames) {\n-                List<ArrayLen> arrayLenFields = new ArrayList<>();\n-                Arrays.stream(arrayLenFieldNames).forEach(arrayLenFieldName -> {\n-                    var arrayLenField = new ArrayLen(this, AccessorInfo.Key.of(iface, arrayLenFieldName), MapperUtil.typeOf(iface, arrayLenFieldName), arrayLenFieldName);\n-                    addField(arrayLenField);\n-                    arrayLenFields.add(arrayLenField);\n-                });\n-                return new ArrayBuildState(this, arrayLenFields);\n+            IfaceFixedArray(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name, int len) {\n+                super(parent, key, ifaceType, name);\n+                this.len = len;\n@@ -471,21 +517,1 @@\n-                stringConsumer.accept(indent);\n-                if (MapperUtil.isUnion(iface)) {\n-                    stringConsumer.accept(\"union\");\n-                } else if (MapperUtil.isStructOrBuffer(iface)) {\n-                    stringConsumer.accept(\"struct\");\n-                } else {\n-                    throw new IllegalStateException(\"Oh my \");\n-                }\n-                stringConsumer.accept(\" \" + iface + \"{\");\n-                stringConsumer.accept(\"\\n\");\n-                ifaceTypes.forEach(c -> {\n-                    c.toText(indent + \" TYPE: \", stringConsumer);\n-                    stringConsumer.accept(\"\\n\");\n-                });\n-                fields.forEach(c -> {\n-                    c.toText(indent + \" FIELD: \", stringConsumer);\n-                    stringConsumer.accept(\"\\n\");\n-                });\n-\n-                stringConsumer.accept(indent);\n-                stringConsumer.accept(\"}\");\n+                stringConsumer.accept(indent + \"array [\" + len + \"]\");\n@@ -495,3 +521,10 @@\n-        public static final class Struct extends IfaceType {\n-            Struct(IfaceType parent, Class<MappableIface> type) {\n-                super(parent, type);\n+        public static final class IfaceFieldControlledArray extends IfaceArray {\n+            List<ArrayLen> arrayLenFields;\n+            int stride;\n+            int contributingDims;\n+\n+            IfaceFieldControlledArray(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name, List<ArrayLen> arrayLenFields, int stride) {\n+                super(parent, key, ifaceType, name);\n+                this.arrayLenFields = arrayLenFields;\n+                this.stride = stride;\n+                this.contributingDims = arrayLenFields.size();\n@@ -499,1 +532,0 @@\n-        }\n@@ -501,3 +533,3 @@\n-        public static final class Union extends IfaceType {\n-            Union(IfaceType parent, Class<MappableIface> type) {\n-                super(parent, type);\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + name + \"[\" + key + \":\" + ifaceType.iface + \"] where len defined by \" + arrayLenFields);\n@@ -507,7 +539,0 @@\n-    }\n-\n-    Schema(Class<T> iface, SchemaNode.IfaceType rootIfaceType) {\n-        this.iface = iface;\n-        this.rootIfaceType = rootIfaceType;\n-    }\n-\n@@ -515,13 +540,0 @@\n-    public T allocate(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator, int... boundLengths) {\n-        BoundSchema<?> boundSchema = new BoundSchemaNode.BoundSchemaRootNode<>(this, boundLengths);\n-        return (T) boundSchema.allocate(lookup,bufferAllocator);\n-    }\n-\n-    public static <T extends Buffer> Schema<T> of(Class<T> iface,  Consumer<SchemaNode.IfaceType> parentFieldConsumer) {\n-        var struct = new SchemaNode.Struct(null, (Class<MappableIface>)(Object)iface); \/\/ why the need for this?\n-        parentFieldConsumer.accept(struct);\n-        return new Schema<>(iface,struct);\n-    }\n-\n-    public void toText(Consumer<String> stringConsumer) {\n-        rootIfaceType.toText(\"\", stringConsumer);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":388,"deletions":376,"binary":false,"changes":764,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.HatPtr;\n+import hat.OpsAndTypes;\n@@ -226,1 +226,1 @@\n-    public BiMap<Block.Parameter, HatPtr.HatPtrOp> parameterHatPtrOpMap = new BiMap<>();\n+    public BiMap<Block.Parameter, OpsAndTypes.HatPtrOp> parameterHatPtrOpMap = new BiMap<>();\n@@ -238,1 +238,1 @@\n-                }else if (resultOp instanceof HatPtr.HatPtrOp hatPtrOp) {\n+                }else if (resultOp instanceof OpsAndTypes.HatPtrOp hatPtrOp) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-            --class-path hat\/target\/hat-1.0.jar:${example_jar}:${backend_jar} \\\n+            --class-path maven-build\/hat-1.0.jar:${example_jar}:${backend_jar} \\\n@@ -32,1 +32,0 @@\n-\n","filename":"hat\/hatrun.bash","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/life.iml\" filepath=\"$PROJECT_DIR$\/life.iml\" \/>\n","filename":"hat\/intellij\/.idea\/modules.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,16 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/hattricks\/life\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/hattricks\/life\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/hattricks\/life\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_opencl\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_cuda\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_spirv\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/life.iml","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"}]}