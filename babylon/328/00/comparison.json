{"files":[{"patch":"@@ -4,1 +4,2 @@\n-import java.nio.ByteBuffer;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n@@ -268,1 +269,1 @@\n-    static ByteBuffer buildFuncModel(FuncOp model) {\n+    static MemorySegment buildFuncModel(FuncOp model) {\n@@ -303,1 +304,1 @@\n-    static ByteBuffer buildModel(List<Input> inputs, List<OpNode> ops, List<String> outputNames) {\n+    static MemorySegment buildModel(List<Input> inputs, List<OpNode> ops, List<String> outputNames) {\n@@ -319,1 +320,1 @@\n-        return ByteBuffer.allocateDirect(bytes.length).put(bytes).asReadOnlyBuffer();\n+        return Arena.ofAuto().allocate(bytes.length).copyFrom(MemorySegment.ofArray(bytes)).asReadOnly();\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -6,2 +6,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n@@ -14,1 +12,0 @@\n-import java.util.Optional;\n@@ -20,1 +17,0 @@\n-import oracle.code.onnx.ir.OnnxOp;\n@@ -107,1 +103,1 @@\n-    public Session createSession(ByteBuffer model) {\n+    public Session createSession(MemorySegment model) {\n@@ -111,2 +107,2 @@\n-    private Session createSession(ByteBuffer model, SessionOptions options) {\n-        return new Session(retAddr(OrtApi.CreateSessionFromArray(runtimeAddress, envAddress, MemorySegment.ofBuffer(model.rewind()), model.limit(), options.sessionOptionsAddress, ret)));\n+    private Session createSession(MemorySegment model, SessionOptions options) {\n+        return new Session(retAddr(OrtApi.CreateSessionFromArray(runtimeAddress, envAddress, model, model.byteSize(), options.sessionOptionsAddress, ret)));\n@@ -191,1 +187,1 @@\n-    public ByteBuffer tensorBuffer(MemorySegment tensorAddr) {\n+    public MemorySegment tensorData(MemorySegment tensorAddr) {\n@@ -196,2 +192,1 @@\n-                .reinterpret(size)\n-                .asByteBuffer().order(ByteOrder.nativeOrder());\n+                .reinterpret(size);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.nio.ByteBuffer;\n@@ -96,1 +95,1 @@\n-        return new Tensor(data, ElementType.UINT8, shape);\n+        return new Tensor<>(data, ElementType.UINT8, shape);\n@@ -101,1 +100,1 @@\n-        return new Tensor(data, ElementType.INT64, shape);\n+        return new Tensor<>(data, ElementType.INT64, shape);\n@@ -106,1 +105,1 @@\n-        return new Tensor(data, ElementType.FLOAT, shape);\n+        return new Tensor<>(data, ElementType.FLOAT, shape);\n@@ -109,1 +108,1 @@\n-    \/\/ Mandatory reference to dataAddr to avoid its garbage colletion\n+    \/\/ Mandatory reference to dataAddr to avoid its garbage collection\n@@ -126,2 +125,2 @@\n-    public ByteBuffer asByteBuffer() {\n-        return OnnxRuntime.getInstance().tensorBuffer(tensorAddr);\n+    public MemorySegment data() {\n+        return OnnxRuntime.getInstance().tensorData(tensorAddr);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -43,0 +44,1 @@\n+import java.nio.ByteOrder;\n@@ -324,1 +326,1 @@\n-    static void printImage(int imageIndex, ByteBuffer bb) {\n+    static void printImage(int imageIndex, MemorySegment ms) {\n@@ -329,1 +331,1 @@\n-                System.out.print(GREY_SCALE.charAt(GREY_SCALE.length() * (0xff & bb.get(offset + y * 28 + x)) \/ 256));\n+                System.out.print(GREY_SCALE.charAt(GREY_SCALE.length() * (0xff & ms.get(ValueLayout.JAVA_BYTE, offset + y * 28 + x)) \/ 256));\n@@ -337,1 +339,2 @@\n-            return new Tensor(file.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length(), ARENA), Tensor.ElementType.FLOAT, shape);\n+            return new Tensor<>(file.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length(), ARENA),\n+                    Tensor.ElementType.FLOAT, shape);\n@@ -400,2 +403,5 @@\n-            ByteBuffer imagesIn = imagesF.getChannel().map(FileChannel.MapMode.READ_ONLY, IMAGES_HEADER_SIZE, imagesF.length() - IMAGES_HEADER_SIZE);\n-            ByteBuffer labelsIn = labelsF.getChannel().map(FileChannel.MapMode.READ_ONLY, LABELS_HEADER_SIZE, labelsF.length() - LABELS_HEADER_SIZE);\n+            MemorySegment imagesIn = imagesF.getChannel().map(FileChannel.MapMode.READ_ONLY,\n+                    IMAGES_HEADER_SIZE, imagesF.length() - IMAGES_HEADER_SIZE, ARENA);\n+            MemorySegment labelsIn = labelsF.getChannel().map(FileChannel.MapMode.READ_ONLY,\n+                    LABELS_HEADER_SIZE, labelsF.length() - LABELS_HEADER_SIZE, ARENA);\n+            ByteBuffer labelsInBuffer = labelsIn.asByteBuffer().order(ByteOrder.nativeOrder());\n@@ -403,3 +409,3 @@\n-            Tensor<Byte> inputImage = new Tensor(MemorySegment.ofBuffer(imagesIn), Tensor.ElementType.UINT8, new long[]{imagesF.length() - IMAGES_HEADER_SIZE});\n-\n-            FloatBuffer result = executor.apply(inputImage).asByteBuffer().asFloatBuffer();\n+            Tensor<Byte> inputImage = new Tensor<>(imagesIn, Tensor.ElementType.UINT8,\n+                    new long[]{imagesF.length() - IMAGES_HEADER_SIZE});\n+            MemorySegment result = executor.apply(inputImage).data();\n@@ -407,0 +413,1 @@\n+            FloatBuffer resultBuffer = result.asByteBuffer().order(ByteOrder.nativeOrder()).asFloatBuffer();\n@@ -408,3 +415,3 @@\n-            while (result.remaining() > 0) {\n-                int expected = labelsIn.get();\n-                int actual = nextBestMatch(result);\n+            while (resultBuffer.remaining() > 0) {\n+                int expected = labelsInBuffer.get();\n+                int actual = nextBestMatch(resultBuffer);\n@@ -414,1 +421,1 @@\n-                    int imageIndex = labelsIn.position() - 1;\n+                    int imageIndex = labelsInBuffer.position() - 1;\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+\n+import java.lang.foreign.Arena;\n@@ -34,3 +36,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.FloatBuffer;\n@@ -52,2 +51,4 @@\n-        return MemorySegment.ofArray(MNISTDemo.class.getResourceAsStream(resource).readAllBytes())\n-                .toArray(ValueLayout.JAVA_FLOAT_UNALIGNED);\n+        try (InputStream in = MNISTDemo.class.getResourceAsStream(resource)) {\n+            return MemorySegment.ofArray(in.readAllBytes())\n+                    .toArray(ValueLayout.JAVA_FLOAT_UNALIGNED);\n+        }\n@@ -124,1 +125,1 @@\n-                                Op.ofMethod(MNISTDemo.class.getDeclaredMethod(\"cnn\", Tensor.class)).get())));\n+                                Op.ofMethod(MNISTDemo.class.getDeclaredMethod(\"cnn\", Tensor.class)).orElseThrow())));\n@@ -129,2 +130,2 @@\n-        var scaledImageDataBuffer = ByteBuffer.allocateDirect(IMAGE_SIZE * IMAGE_SIZE * 4).order(ByteOrder.LITTLE_ENDIAN).asFloatBuffer();\n-        var inputArguments = List.of(new Tensor(MemorySegment.ofBuffer(scaledImageDataBuffer), FLOAT, 1, 1, IMAGE_SIZE, IMAGE_SIZE).tensorAddr);\n+        var scaledImageData = Arena.ofAuto().allocate(IMAGE_SIZE * IMAGE_SIZE * 4);\n+        var inputArguments = List.of(new Tensor<Float>(scaledImageData, FLOAT, 1, 1, IMAGE_SIZE, IMAGE_SIZE).tensorAddr);\n@@ -161,2 +162,2 @@\n-                    scaledImageDataBuffer.put(0, scaledImage.getData().getSamples(0, 0, IMAGE_SIZE, IMAGE_SIZE, 0, sampleArray));\n-                    FloatBuffer result = OnnxRuntime.getInstance().tensorBuffer(modelRuntimeSession.run(inputArguments).getFirst()).asFloatBuffer();\n+                    scaledImageData.copyFrom(MemorySegment.ofArray(scaledImage.getData().getSamples(0, 0, IMAGE_SIZE, IMAGE_SIZE, 0, sampleArray)));\n+                    MemorySegment result = OnnxRuntime.getInstance().tensorData(modelRuntimeSession.run(inputArguments).getFirst());\n@@ -165,1 +166,1 @@\n-                        var w = result.get(i);\n+                        var w = result.getAtIndex(ValueLayout.JAVA_FLOAT_UNALIGNED, i);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/MNISTDemo.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -5,3 +6,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.DoubleBuffer;\n-import java.nio.FloatBuffer;\n@@ -134,1 +132,1 @@\n-        var expectedBB = rt.tensorBuffer(expectedTensorAddr);\n+        var expectedData = rt.tensorData(expectedTensorAddr);\n@@ -138,1 +136,1 @@\n-        var actualBB = rt.tensorBuffer(actualTensorAddr);\n+        var actualData = rt.tensorData(actualTensorAddr);\n@@ -146,1 +144,1 @@\n-                assertEquals(expectedBB, actualBB);\n+                assertEquals(ValueLayout.JAVA_BYTE, expectedData, actualData);\n@@ -148,1 +146,1 @@\n-                assertEquals(expectedBB.asFloatBuffer(), actualBB.asFloatBuffer());\n+                assertEquals(ValueLayout.JAVA_FLOAT_UNALIGNED, expectedData, actualData);\n@@ -150,1 +148,1 @@\n-                assertEquals(expectedBB.asDoubleBuffer(), actualBB.asDoubleBuffer());\n+                assertEquals(ValueLayout.JAVA_DOUBLE_UNALIGNED, expectedData, actualData);\n@@ -156,18 +154,19 @@\n-    static void assertEquals(ByteBuffer expectedData, ByteBuffer actualData) {\n-        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n-        for (int i = 0; i < expectedData.capacity(); i++) {\n-            Assertions.assertEquals(expectedData.get(i), actualData.get(i));\n-        }\n-    }\n-\n-    static void assertEquals(FloatBuffer expectedData, FloatBuffer actualData) {\n-        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n-        for (int i = 0; i < expectedData.capacity(); i++) {\n-            Assertions.assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n-        }\n-    }\n-\n-    static void assertEquals(DoubleBuffer expectedData, DoubleBuffer actualData) {\n-        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n-        for (int i = 0; i < expectedData.capacity(); i++) {\n-            Assertions.assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n+    static void assertEquals(ValueLayout l, MemorySegment expectedData, MemorySegment actualData) {\n+        Assertions.assertEquals(expectedData.byteSize(), actualData.byteSize());\n+        switch (l) {\n+            case ValueLayout.OfByte ofByte -> {\n+                for (int i = 0; i < expectedData.byteSize(); i++) {\n+                    Assertions.assertEquals(expectedData.get(ofByte, i), actualData.get(ofByte, i));\n+                }\n+            }\n+            case ValueLayout.OfDouble ofDouble -> {\n+                for (int i = 0; i < expectedData.byteSize() \/ ofDouble.byteSize(); i++) {\n+                    Assertions.assertEquals(expectedData.getAtIndex(ofDouble, i), actualData.getAtIndex(ofDouble, i), 1e-6f);\n+                }\n+            }\n+            case ValueLayout.OfFloat ofFloat -> {\n+                for (int i = 0; i < expectedData.byteSize() \/ ofFloat.byteSize(); i++) {\n+                    Assertions.assertEquals(expectedData.getAtIndex(ofFloat, i), actualData.getAtIndex(ofFloat, i), 1e-6f);\n+                }\n+            }\n+            default -> throw new UnsupportedOperationException(l.toString());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":25,"deletions":26,"binary":false,"changes":51,"status":"modified"}]}