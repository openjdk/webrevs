{"files":[{"patch":"@@ -194,2 +194,2 @@\n-        Quoted<JavaOp.LambdaOp> quoted = Op.ofLambda(compute).orElseThrow();\n-        JavaOp.LambdaOp lambda = quoted.op();\n+        Quoted quoted = Op.ofLambda(compute).orElseThrow();\n+        JavaOp.LambdaOp lambda = (JavaOp.LambdaOp) quoted.op();\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-        Quoted<JavaOp.LambdaOp> quoted = Op.ofLambda(kernel).orElseThrow();\n+        Quoted quoted = Op.ofLambda(kernel).orElseThrow();\n@@ -162,1 +162,1 @@\n-            JavaOp.LambdaOp lambdaOp = quoted.op();\n+            JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) quoted.op();\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -736,1 +736,1 @@\n-            if (invoke.isInstance() && invoke.operandCount() == 1 && invoke.returnsInt() && invoke.named(atomicIncRegex)) {\n+            if (invoke instanceof Invoke.Virtual && invoke.operandCount() == 1 && invoke.returnsInt() && invoke.named(atomicIncRegex)) {\n@@ -742,1 +742,1 @@\n-            } else if (invoke.isInstance() && invoke.resultFromOperandNOrThrow(0) instanceof Op.Result instance) {\n+            } else if (invoke instanceof Invoke.Virtual && invoke.resultFromOperandNOrThrow(0) instanceof Op.Result instance) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-import optkl.InvokeQuery;\n-import optkl.InvokeQuery.Match;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.OpHelper;\n@@ -38,0 +38,2 @@\n+import static optkl.OpHelper.Invoke.invoke;\n+\n@@ -42,8 +44,6 @@\n-         var invokeQuery = InvokeQuery.create(lookup());\n-         return Trxfmr.of(this,funcOp).transform(c-> {\n-                         if (invokeQuery.matches(c.op(), $->\/\/\n-                                 $.isInstanceAccessedViaVarAccess()                  \/\/ we are called via var kc such as kc->XX()\n-                              && $.named(HATBarrierOp.NAME)) instanceof Match match  \/\/ and the method name is `barrier`\n-                              && match.helper().instanceVarAccess().op() instanceof CoreOp.VarAccessOp varAccess\n-                         ){\n-                             removeMe.add(varAccess);\n+        \/\/ var invokeQuery = InvokeQuery.create(lookup());\n+         return Trxfmr.of(this,funcOp).transform(ce->ce instanceof JavaOp.InvokeOp, c-> {\n+                         if (invoke(lookup(),c.op()) instanceof OpHelper.Invoke.Virtual  virtual &&\n+                                  virtual.isInstanceAccessedViaVarAccess()                  \/\/ we are called via var kc such as kc->XX()\n+                              && virtual.named(HATBarrierOp.NAME)){\n+                             removeMe.add(virtual.instanceVarAccess().op());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -228,0 +228,2 @@\n+                .filter(invoke->invoke instanceof Invoke.Static)\n+                .map(invoke->(Invoke.Static)invoke)\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.KernelContext;\n@@ -36,1 +37,1 @@\n-import hat.phases.KernelContextThreadIdFieldAccessQuery.Match;\n+import optkl.util.Regex;\n@@ -41,0 +42,2 @@\n+import static optkl.OpHelper.FieldAccess.fieldAccess;\n+\n@@ -45,1 +48,1 @@\n-        var query = KernelContextThreadIdFieldAccessQuery.create(lookup()); \/\/ This Query matches kc->[glb][is][xyz] calls\n+     \/\/   var query = KernelContextThreadIdFieldAccessQuery.create(lookup()); \/\/ This Query matches kc->[glb][is][xyz] calls\n@@ -48,1 +51,2 @@\n-                    if (query.matches(c) instanceof Match match && match.helper() instanceof FieldAccess fieldAccess){\n+                    if (fieldAccess(lookup(),c.op()) instanceof FieldAccess.Instance fieldAccess\n+                        && fieldAccess.refType(KernelContext.class) && fieldAccess.named(Regex.of(\"[glb][is][xyz]\"))){\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.KernelContext;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.OpHelper.FieldAccess;\n-import optkl.Query;\n-import optkl.util.BiMap;\n-import optkl.util.Regex;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.function.Predicate;\n-\n-public interface KernelContextThreadIdFieldAccessQuery extends Query<JavaOp.FieldAccessOp, FieldAccess, KernelContextThreadIdFieldAccessQuery> {\n-    Regex threadIdRegex = Regex.of(\"[glb][is][xyz]\");\n-    interface Match extends SimpleMatch<JavaOp.FieldAccessOp, FieldAccess, KernelContextThreadIdFieldAccessQuery> {\n-         String id();\n-    }\n-    record Impl(MethodHandles.Lookup lookup) implements KernelContextThreadIdFieldAccessQuery {\n-        @Override\n-        public Res<JavaOp.FieldAccessOp,FieldAccess, KernelContextThreadIdFieldAccessQuery> matches(CodeElement<?, ?> ce, Predicate<FieldAccess> predicate) {\n-            if (FieldAccess.fieldAccess(lookup, ce) instanceof FieldAccess fieldAccess && predicate.test(fieldAccess)\n-                && fieldAccess.isInstance() && fieldAccess.refType(KernelContext.class) && fieldAccess.named(threadIdRegex)){\n-                    record MatchImpl(KernelContextThreadIdFieldAccessQuery query, FieldAccess helper, String id) implements Match{\n-                        @Override\n-                        public SimpleMatch<JavaOp.FieldAccessOp, FieldAccess, KernelContextThreadIdFieldAccessQuery> remap(BiMap<CodeElement<?, ?>, CodeElement<?, ?>> biMap) {\n-                            return new MatchImpl(MatchImpl.this.query, FieldAccess.fieldAccess(query().lookup(), biMap.getTo(MatchImpl.this.helper.op())),MatchImpl.this.id);\n-                        }\n-                    }\n-                    return new MatchImpl(this, fieldAccess, fieldAccess.name() );\n-                }\n-            return Query.FAILED;\n-        }\n-    }\n-    static KernelContextThreadIdFieldAccessQuery create(MethodHandles.Lookup lookup) {\n-         return new Impl(lookup);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/KernelContextThreadIdFieldAccessQuery.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -170,1 +170,1 @@\n-                .transform(\"usingAbs\", ce -> invoke(lookup,ce) instanceof Invoke $\n+                .transform(\"usingAbs\", ce -> invoke(lookup,ce) instanceof Invoke.Static $\n@@ -172,1 +172,0 @@\n-                        && $.isStatic()\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import optkl.MappedIfaceBufferInvokeQuery;\n-import optkl.MappedIfaceBufferInvokeQuery.Match;\n@@ -55,0 +53,1 @@\n+import static optkl.OpHelper.Invoke.invoke;\n@@ -98,4 +97,0 @@\n-\n-        public String describe(Value value) {\n-            return  (mutates(value) ? \"mutates \" : \"\") + (accessesAndMutates(value) ? \"and \" : \"\") + (accesses(value) ? \"accesses \" : \"\");\n-        }\n@@ -137,1 +132,1 @@\n-        var mappedIfaceBufferInvokeQuery = MappedIfaceBufferInvokeQuery.create(lookup);\n+       \/\/ var mappedIfaceBufferInvokeQuery = MappedIfaceBufferInvokeQuery.create(lookup);\n@@ -142,4 +137,6 @@\n-                if (mappedIfaceBufferInvokeQuery.matches(opInStatement) instanceof Match match) {\n-                    statementSpan.put(match.helper().instance(), match.mutatesBuffer());\n-                } else if (Invoke.invoke(lookup, opInStatement) instanceof Invoke invoke\n-                        && invoke.isInstance() && !invoke.refIs(ComputeContext.class) && invoke.operandCount() > 0) {\n+                if (invoke(lookup,opInStatement) instanceof Invoke.Virtual virtual\n+                        &&  (virtual.refIs(MappableIface.class) || virtual.returnsPrimitive())\n+                ) {\n+                    statementSpan.put(virtual.instance(), !virtual.returnsVoid());\n+                } else if (invoke(lookup, opInStatement) instanceof Invoke.Virtual invoke\n+                        && !invoke.refIs(ComputeContext.class) && invoke.operandCount() > 0) {\n@@ -154,1 +151,0 @@\n-var spinCounter = Mutable.of(0);\n@@ -171,2 +167,2 @@\n-                                    .map(o -> Invoke.invoke(lookup, o))\n-                                    .filter(invoke -> invoke!=null && invoke.isInstance() && invoke.refIs(MappableIface.class))\n+                                    .filter(o -> invoke(lookup, o) instanceof Invoke.Virtual virtual && virtual.refIs(MappableIface.class))\n+                                    .map(o -> (Invoke.Virtual) invoke(lookup, o))\n@@ -197,6 +193,1 @@\n-                                var constant= CoreOp.constant(JavaType.J_L_STRING, msg);\n-                                System.out.println(\"spin \"+msg+\" \"+spinCounter.get()+\" \"+constant.resultType());\n-                                spinCounter.set(spinCounter.get()+1);\n-                                boolean useCursorAdd = false;\n-                                var msgStringResult = useCursorAdd?c.add(constant):c.builder().op(constant);\n-                                c.add(JavaOp.invoke(JavaType.VOID, Println, msgStringResult));\n+                                c.add(JavaOp.invoke(JavaType.VOID, Println, c.add(CoreOp.constant(JavaType.J_L_STRING, msg))));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InjectBufferTracking.java","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import optkl.InvokeQuery;\n@@ -39,1 +38,2 @@\n-\n+import static optkl.OpHelper.Invoke.invoke;\n+import static optkl.OpHelper.Invoke.Virtual;\n@@ -124,1 +124,0 @@\n-        var binaryOpQuery = InvokeQuery.create(lookup);\n@@ -127,8 +126,3 @@\n-                .transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n-                    if (binaryOpQuery.matches(c, $ ->\/\/ trivially look for a fluent style binary Op such as  S32x2.add(S32x2 rhs)\n-                            $.isInstance() && $.returns(S32x2.class) &&  $.receives( S32x2.class)\n-                    ) instanceof InvokeQuery.Match match) {\n-                        c.replace(\n-                                createBinaryOp(match.helper(), c.mappedOperand(0), c.mappedOperand(1))\n-                        );\n-                    }\n+                .transform(ce -> invoke(lookup,ce) instanceof Virtual v && v.returns(S32x2.class) && v.receives(S32x2.class), c -> {\n+                        c.replace(createBinaryOp(invoke(lookup,c.op()), c.mappedOperand(0), c.mappedOperand(1)));\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LanewiseBinaryOpExtraction.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.MappedIfaceBufferInvokeQuery;\n-import optkl.Query;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-\n-import static optkl.OpHelper.Invoke;\n-\n-public class Queries {\n-    @Reflect\n-    static int m(int a, int b) {\n-        a += 2;\n-        b += 2;\n-        \/\/ Group these\n-        System.out.println(a);\n-        System.out.println(b);\n-        return a + b;\n-    }\n-\n-    public static void main(String[] args) throws Throwable {\n-        var lookup = MethodHandles.lookup();\n-        Method m = Queries.class.getDeclaredMethod(\"m\", int.class, int.class);\n-        CoreOp.FuncOp mModel = Op.ofMethod(m).orElseThrow();\n-\n-        var query = MappedIfaceBufferInvokeQuery.create(lookup);\n-        Invoke.stream(lookup,mModel).forEach(invoke->{\n-            if (query.matches(invoke.op()) instanceof Query.SimpleMatch<JavaOp.InvokeOp,Invoke, MappedIfaceBufferInvokeQuery> match){\n-                System.out.println(match.helper().name());\n-            }\n-        });\n-\n-    }\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Queries.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -76,2 +76,2 @@\n-            if (invoke(lookup,op) instanceof Invoke ih\n-                    && ih.named(Regex.of(\"sqrt\")) && ih.isStatic() && ih.returns(double.class) && ih.receives(double.class)){\n+            if (invoke(lookup,op) instanceof Invoke.Static ih\n+                    && ih.named(Regex.of(\"sqrt\")) &&  ih.returns(double.class) && ih.receives(double.class)){\n@@ -96,1 +96,1 @@\n-                .transform(\"usingAbs\",ce-> invoke(lookup,ce) instanceof Invoke $\n+                .transform(\"usingAbs\", ce-> invoke(lookup,ce) instanceof Invoke.Static $\n@@ -98,1 +98,0 @@\n-                                && $.isStatic()\n@@ -102,3 +101,1 @@\n-                        c.replace(\n-                                JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, c.mappedOperand( 0))\n-                        )\n+                        c.replace(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, c.mappedOperand( 0)))\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import optkl.InvokeQuery;\n+import optkl.OpHelper;\n@@ -35,0 +35,3 @@\n+import static optkl.OpHelper.Invoke.invoke;\n+import optkl.OpHelper.Invoke.Virtual;\n+\n@@ -47,1 +50,1 @@\n-         var mathOperatorQuery = InvokeQuery.create(lookup);\n+\n@@ -53,2 +56,1 @@\n-                    if (mathOperatorQuery.matches(c, \/\/ $ here is an Invoke helper...\n-                            $ -> $.named(Regex.of(\"(add|mul|div|mod|sub)\"))) instanceof InvokeQuery.Match match) {\n+                    if (invoke(lookup,c.op()) instanceof Virtual v && v.named(Regex.of(\"(add|mul|div|mod|sub)\"))) {\n@@ -57,1 +59,1 @@\n-                        c.replace(switch (match.helper().name()) { \/\/ we replace the call with one of ....\n+                        c.replace(switch (v.name()) { \/\/ we replace the call with one of ....\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/UnpackingFluentBinaryOps.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.util.BiMap;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.function.Predicate;\n-\n-import optkl.OpHelper.Invoke;\n-\n-public interface InvokeQuery extends Query<JavaOp.InvokeOp,Invoke,InvokeQuery> {\n-    interface Match extends SimpleMatch<JavaOp.InvokeOp, Invoke, InvokeQuery> {\n-\n-    }\n-    record Impl(MethodHandles.Lookup lookup) implements InvokeQuery {\n-        @Override\n-        public Res<JavaOp.InvokeOp,Invoke,InvokeQuery> matches(CodeElement<?, ?> ce, Predicate<Invoke> predicate) {\n-            if (Invoke.invoke(lookup,ce) instanceof Invoke invoke && predicate.test(invoke)) {\n-                record  MatchImpl (InvokeQuery query, Invoke helper) implements Match {\n-                    @Override\n-                    public SimpleMatch<JavaOp.InvokeOp,Invoke,InvokeQuery> remap(BiMap<CodeElement<?, ?>, CodeElement<?, ?>> biMap) {\n-                        return  new MatchImpl(MatchImpl.this.query,Invoke.invoke(query().lookup(), biMap.getTo(MatchImpl.this.helper.op())));\n-                    }\n-                }\n-                return new  MatchImpl(this,invoke);\n-            } else {\n-                return Query.FAILED;\n-            }\n-        }\n-    }\n-    static InvokeQuery create(MethodHandles.Lookup lookup) {\n-         return new Impl(lookup);\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/InvokeQuery.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.OpHelper.Invoke;\n-import optkl.util.BiMap;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.function.Predicate;\n-\n-public interface MappedIfaceBufferInvokeQuery extends Query<JavaOp.InvokeOp,Invoke, MappedIfaceBufferInvokeQuery> {\n-    interface Match extends SimpleMatch<JavaOp.InvokeOp, Invoke, MappedIfaceBufferInvokeQuery> {\n-         boolean mutatesBuffer();\n-    }\n-    record Impl(MethodHandles.Lookup lookup) implements MappedIfaceBufferInvokeQuery {\n-        @Override\n-        public Res<JavaOp.InvokeOp,Invoke, MappedIfaceBufferInvokeQuery> matches(CodeElement<?, ?> ce, Predicate<Invoke> predicate) {\n-            if (Invoke.invoke(lookup, ce) instanceof Invoke invoke && predicate.test(invoke)\n-                    && invoke.isInstance() && (invoke.returns(MappedIfaceBufferInvokeQuery.class) || invoke.returnsPrimitive())){\n-                    record MatchImpl(MappedIfaceBufferInvokeQuery query, Invoke helper, boolean mutatesBuffer) implements Match{\n-                        @Override\n-                        public SimpleMatch<JavaOp.InvokeOp, Invoke, MappedIfaceBufferInvokeQuery> remap(BiMap<CodeElement<?, ?>, CodeElement<?, ?>> biMap) {\n-                            return new MatchImpl(MatchImpl.this.query, Invoke.invoke(query().lookup(), biMap.getTo(MatchImpl.this.helper.op())),MatchImpl.this.mutatesBuffer);\n-                        }\n-                    }\n-                    return new MatchImpl(this, invoke, invoke.returnsVoid());\n-                }\n-\n-            return Query.FAILED;\n-        }\n-    }\n-    static MappedIfaceBufferInvokeQuery create(MethodHandles.Lookup lookup) {\n-         return new Impl(lookup);\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/MappedIfaceBufferInvokeQuery.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -67,2 +67,1 @@\n-        permits OpHelper.Binary, OpHelper.Lambda, OpHelper.LoadOrStore, OpHelper.Named,\n-        OpHelper.StaticOrInstance, OpHelper.Ternary {\n+        permits OpHelper.Binary, OpHelper.Lambda, OpHelper.LoadOrStore, OpHelper.Named, OpHelper.Ternary {\n@@ -285,29 +284,0 @@\n-    sealed interface StaticOrInstance<T extends Op> extends OpHelper<T> {\n-        boolean isStatic();\n-\n-        boolean isInstance();\n-\n-        default Op.Result instance() {\n-            if (isInstance()) {\n-                return (Op.Result) op().operands().getFirst();\n-            } else {\n-                return null;\n-            }\n-        }\n-\n-        default Op instanceOp() {\n-            return instance() instanceof Op.Result result ? result.op() : null;\n-        }\n-\n-        default VarAccess instanceVarAccess() {\n-            return instanceOp() instanceof CoreOp.VarAccessOp varAccessOp && VarAccess.varAccess(lookup(), varAccessOp) instanceof VarAccess varAccess ? varAccess : null;\n-        }\n-\n-        default boolean isInstanceAccessedViaVarAccess() {\n-            return instanceVarAccess() != null;\n-        }\n-\n-        default Class<?> refClass() {\n-            return (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup(), (ClassType) op().operands().getFirst().type());\n-        }\n-    }\n@@ -360,4 +330,0 @@\n-      \/\/  default <T> boolean of(Class<T> clazz) {\n-        \/\/    return isAssignable((JavaType) op().resultType(), clazz);\n-       \/\/ }\n-\n@@ -407,1 +373,1 @@\n-    sealed interface FieldAccess extends Named<JavaOp.FieldAccessOp>, StaticOrInstance<JavaOp.FieldAccessOp> {\n+    sealed interface FieldAccess extends Named<JavaOp.FieldAccessOp> permits FieldAccess.Instance, FieldAccess.Static {\n@@ -414,10 +380,0 @@\n-        @Override\n-        default boolean isStatic() {\n-            return operandCount() == 0;\n-        }\n-\n-        @Override\n-        default boolean isInstance() {\n-            return !isStatic();\n-        }\n-\n@@ -468,5 +424,6 @@\n-        record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements FieldAccess {\n-        }\n-\n-        static FieldAccess fieldAccess(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n-            return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp ? new FieldAccess.Impl(lookup, fieldAccessOp) : null;\n+        static <F extends FieldAccess> F fieldAccess(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+            return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp\n+                    ? fieldAccessOp.operands().isEmpty()\n+                    ?(F)new Static.Impl(lookup, fieldAccessOp)\n+                    :(F)new Instance.Impl(lookup, fieldAccessOp)\n+                    : null;\n@@ -478,6 +435,3 @@\n-    }\n-\n-    sealed interface Func extends Named<CoreOp.FuncOp>, StaticOrInstance<CoreOp.FuncOp> {\n-        @Override\n-        default boolean isStatic() {\n-            throw new RuntimeException(\"implement Func.isStatic\");\n+        sealed interface Static extends FieldAccess{\n+            record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements Static {\n+            }\n@@ -485,0 +439,15 @@\n+        sealed interface Instance extends FieldAccess{\n+            record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements Instance {\n+            }\n+            default Op.Result instance() {\n+                    return (Op.Result) op().operands().getFirst();\n+            }\n+\n+            default Op instanceOp() {\n+                return instance() instanceof Op.Result result ? result.op() : null;\n+            }\n+\n+\n+            default VarAccess instanceVarAccess() {\n+                return instanceOp() instanceof CoreOp.VarAccessOp varAccessOp && VarAccess.varAccess(lookup(), varAccessOp) instanceof VarAccess varAccess ? varAccess : null;\n+            }\n@@ -486,3 +455,0 @@\n-        @Override\n-        default boolean isInstance() {\n-            throw new RuntimeException(\"implement Func.isInstance\");\n@@ -490,0 +456,1 @@\n+    }\n@@ -491,0 +458,1 @@\n+    sealed interface Func extends Named<CoreOp.FuncOp> {\n@@ -511,2 +479,0 @@\n-\n-\n@@ -515,1 +481,1 @@\n-    sealed interface Invoke extends Named<JavaOp.InvokeOp>, StaticOrInstance<JavaOp.InvokeOp> {\n+    sealed interface Invoke extends Named<JavaOp.InvokeOp> permits  Invoke.Static, Invoke.Virtual {\n@@ -524,4 +490,0 @@\n-        @Override\n-        default boolean isStatic() {\n-            return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n-        }\n@@ -529,4 +491,0 @@\n-        @Override\n-        default boolean isInstance() {\n-            return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n-        }\n@@ -539,1 +497,1 @@\n-        default <T> boolean returns(Class<T> clazz) {\n+        default  boolean returns(Class<?> clazz) {\n@@ -545,1 +503,1 @@\n-            int adj = isInstance() ? 1 : 0;\/\/ for instance we compare op().operands(1..N) (0..N) for static\n+            int adj = (this instanceof Virtual) ? 1 : 0;\/\/ for instance we compare op().operands(1..N) (0..N) for static\n@@ -570,1 +528,0 @@\n-\n@@ -651,1 +608,1 @@\n-            int firstParam = isInstance() ? 1 : 0; \/\/ if virtual\n+            int firstParam = (this instanceof Virtual) ? 1 : 0; \/\/ if virtual\n@@ -680,7 +637,6 @@\n-\n-\n-        record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Invoke {\n-        }\n-\n-        static Invoke invoke(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n-            return codeElement instanceof JavaOp.InvokeOp invokeOp ? new Impl(lookup, invokeOp) : null;\n+        static <I extends Invoke>I invoke(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+            return codeElement instanceof JavaOp.InvokeOp invokeOp ?\n+                    invokeOp.invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC)\n+                            ? (I)new Static.Impl(lookup,invokeOp)\n+                            : (I) new Virtual.Impl(lookup, invokeOp)\n+                    : null;\n@@ -694,1 +650,1 @@\n-            return lambdaOp.body().entryBlock().ops().stream()\n+            return (Invoke) lambdaOp.body().entryBlock().ops().stream()\n@@ -697,2 +653,3 @@\n-                    .filter(Invoke::isStatic)\n-                    .filter(invoke -> OpHelper.isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n+                 \/\/   .filter(invoke->invoke instanceof Invoke.Static)\n+                  \/\/  .map(invoke->(Invoke.Static)invoke)\n+                    .filter(invoke -> OpHelper.isAssignable(lookup, ((Invoke)invoke).op().operands().getFirst().type(), classes))\n@@ -702,0 +659,31 @@\n+\n+        sealed interface Virtual extends Invoke{\n+            default Op.Result instance() {\n+                    return (Op.Result) op().operands().getFirst();\n+            }\n+\n+            default Op instanceOp() {\n+                return instance() instanceof Op.Result result ? result.op() : null;\n+            }\n+\n+            default VarAccess instanceVarAccess() {\n+                return instanceOp() instanceof CoreOp.VarAccessOp varAccessOp && VarAccess.varAccess(lookup(), varAccessOp) instanceof VarAccess varAccess ? varAccess : null;\n+            }\n+\n+            default boolean isInstanceAccessedViaVarAccess() {\n+                return instanceVarAccess() != null;\n+            }\n+\n+            record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Virtual {\n+            }\n+           \/\/ static Virtual invokeVirtual(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+             \/\/   return codeElement instanceof JavaOp.InvokeOp invokeOp ? new Impl(lookup, invokeOp) : null;\n+           \/\/ }\n+        }\n+        sealed interface Static extends Invoke{\n+            record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Static {\n+            }\n+           \/\/ static Static invokeStatic(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+             \/\/   return codeElement instanceof JavaOp.InvokeOp invokeOp ? new Impl(lookup, invokeOp) : null;\n+           \/\/ }\n+        }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":73,"deletions":85,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.Op;\n-import optkl.util.BiMap;\n-import optkl.util.carriers.LookupCarrier;\n-\n-import java.util.function.Predicate;\n-\n-public interface  Query<O extends Op, OH extends OpHelper<O>, Q extends Query<O,OH,Q>> extends LookupCarrier {\n-\n-    interface Res<O extends Op, OH extends OpHelper<O>, Q extends Query<O,OH,Q>> {\n-    }\n-    default Res<O,OH,Q> matches(CodeElement<?,?> ce){\n-        return matches(ce, _->true);\n-    }\n-    default Res<O,OH,Q> matches(Trxfmr.Cursor cursor){\n-        return matches(cursor.op(), _->true);\n-    }\n-    Res<O,OH,Q> matches(CodeElement<?,?> ce, Predicate<OH> predicate);\n-    default Res<O,OH,Q> matches(Trxfmr.Cursor cursor, Predicate<OH> predicate){\n-        return matches(cursor.op(), predicate);\n-    }\n-    interface Fail<O extends Op, OH extends OpHelper<O>, Q extends Query<O,OH,Q>> extends Res<O,OH,Q>{\n-    }\n-    record  FailImpl() implements Fail{\n-    }\n-    Fail FAILED= new FailImpl();\n-\n-    interface SimpleMatch<O extends Op, OH extends OpHelper<O>, Q extends Query<O,OH,Q>> extends Res<O,OH,Q>{\n-        Q query();\n-        OH helper();\n-        SimpleMatch<O,OH,Q> remap(BiMap<CodeElement<?,?>, CodeElement<?,?>> biMap);\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Query.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -187,1 +187,1 @@\n-            \/\/ This could be a record if we did ot have to mutate action and handled. Maybe a Set?\n+            \/\/ This could be a record if we did not have to mutate action and handled. Maybe a Set?\n@@ -262,1 +262,2 @@\n-                        mapperConsumer.accept(Mapper.of(this).map(op().result(), result));\n+                     \/\/   System.out.println(\"sidestepping txfrme add mapping \");\n+                   \/\/     mapperConsumer.accept(Mapper.of(this).map(op().result(), result));\n@@ -392,6 +393,0 @@\n-                    if (cursorOp instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp){\n-                        \/\/System.out.println(\"Is it this one? \"+varLoadOp.varType());\n-                        if (varLoadOp.varType().valueType() instanceof PrimitiveType primitiveType){\n-                          \/\/  System.out.println(\"It seems to be this primitive \"+primitiveType);\n-                        }\n-                    }\n@@ -402,1 +397,0 @@\n-                    t = t;\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"}]}