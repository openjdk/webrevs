{"files":[{"patch":"@@ -898,7 +898,2 @@\n-    \/**\n-     * The switch expression operation, that can model Java language switch expressions.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaSwitchExpressionOp.NAME)\n-    public static final class JavaSwitchExpressionOp extends ExtendedOp\n-            implements Op.Nested, Op.Lowerable, JavaExpression {\n-        public static final String NAME = \"java.switch.expression\";\n+    public abstract static sealed class JavaSwitchOp extends ExtendedOp implements Op.Nested, Op.Lowerable\n+            permits JavaSwitchStatementOp, JavaSwitchExpressionOp {\n@@ -906,1 +901,0 @@\n-        final TypeElement resultType;\n@@ -909,1 +903,1 @@\n-        public JavaSwitchExpressionOp(ExternalizedOp def) {\n+        public JavaSwitchOp(ExternalizedOp def) {\n@@ -917,1 +911,0 @@\n-\n@@ -919,1 +912,0 @@\n-            this.resultType = def.resultType();\n@@ -922,1 +914,1 @@\n-        JavaSwitchExpressionOp(JavaSwitchExpressionOp that, CopyContext cc, OpTransformer ot) {\n+        JavaSwitchOp(JavaSwitchOp that, CopyContext cc, OpTransformer ot) {\n@@ -928,1 +920,0 @@\n-            this.resultType = that.resultType;\n@@ -931,178 +922,2 @@\n-        @Override\n-        public JavaSwitchExpressionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaSwitchExpressionOp(this, cc, ot);\n-        }\n-\n-        JavaSwitchExpressionOp(TypeElement resultType, Value target, List<Body.Builder> bodyCs) {\n-            super(NAME, List.of(target));\n-\n-            \/\/ Each case is modelled as a contiguous pair of bodies\n-            \/\/ The first body models the case labels, and the second models the case expression or statements\n-            \/\/ The labels body has a parameter whose type is target operand's type and returns a boolean value\n-            \/\/ The statements\/expression body has no parameters and returns the result whose type is the result of\n-            \/\/ the switch expression\n-            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n-            \/\/ @@@ when resultType is null, we assume statements\/expressions bodies have the same yieldType\n-            this.resultType = resultType == null ? bodies.get(1).yieldType() : resultType;\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return bodies;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-\n-        private boolean haveNullCase() {\n-            \/*\n-            case null is modeled like this:\n-            (%4 : T)boolean -> {\n-                %5 : java.lang.Object = constant @null;\n-                %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n-                yield %6;\n-            }\n-            * *\/\n-            for (int i = 0; i < bodies().size() - 2; i+=2) {\n-                Body labelBody = bodies().get(i);\n-                if (labelBody.blocks().size() != 1) {\n-                    continue; \/\/ we skip, for now\n-                }\n-                Op terminatingOp = bodies().get(i).entryBlock().terminatingOp();\n-                \/\/@@@ when op pattern matching is ready, we can use it\n-                if (terminatingOp instanceof YieldOp yieldOp &&\n-                        yieldOp.yieldValue() instanceof Op.Result opr &&\n-                        opr.op() instanceof InvokeOp invokeOp &&\n-                        invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class)) &&\n-                        invokeOp.operands().stream().anyMatch(o -> o instanceof Op.Result r && r.op() instanceof ConstantOp cop && cop.value() == null)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-\n-            Value selectorExpression = b.context().getValue(operands().get(0));\n-\n-            if (!(selectorExpression.type() instanceof PrimitiveType) && !haveNullCase()) {\n-                Block.Builder throwBlock = b.block();\n-                throwBlock.op(_throw(\n-                        throwBlock.op(_new(FunctionType.functionType(JavaType.type(NullPointerException.class))))\n-                ));\n-\n-                Block.Builder continueBlock = b.block();\n-\n-                Result p = b.op(invoke(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                        selectorExpression, b.op(constant(J_L_OBJECT, null))));\n-                b.op(conditionalBranch(p, throwBlock.successor(), continueBlock.successor()));\n-\n-                b = continueBlock;\n-            }\n-\n-            final int n = bodies().size();\n-\n-            List<Block.Builder> blocks = new ArrayList<>();\n-            for (int i = 0; i < n; i++) {\n-                Block.Builder bb = b.block();\n-                if (i == 0) {\n-                    bb = b;\n-                }\n-                blocks.add(bb);\n-            }\n-\n-            Block.Builder exit;\n-            if (bodies().isEmpty()) {\n-                exit = b;\n-            } else {\n-                exit = b.block(resultType());\n-                exit.context().mapValue(result(), exit.parameters().get(0));\n-            }\n-\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n-            \/\/ map expr body to nextExprBlock\n-            \/\/ this mapping will be used for lowering SwitchFallThroughOp\n-            for (int i = 1; i < n - 2; i+=2) {\n-                setBranchTarget(b.context(), bodies().get(i), new BranchTarget(null, blocks.get(i + 2)));\n-            }\n-\n-            for (int i = 0; i < n; i++) {\n-                boolean isLabelBody = i % 2 == 0;\n-                Block.Builder curr = blocks.get(i);\n-                if (isLabelBody) {\n-                    Block.Builder expression = blocks.get(i + 1);\n-                    boolean isLastLabel = i == n - 2;\n-                    Block.Builder nextLabel = isLastLabel ? null : blocks.get(i + 2);\n-                    curr.transformBody(bodies().get(i), List.of(selectorExpression), opT.andThen((block, op) -> {\n-                        switch (op) {\n-                            case YieldOp yop -> {\n-                                if (isLastLabel) {\n-                                    block.op(branch(expression.successor()));\n-                                } else {\n-                                    block.op(conditionalBranch(\n-                                            block.context().getValue(yop.yieldValue()),\n-                                            expression.successor(),\n-                                            nextLabel.successor()\n-                                    ));\n-                                }\n-                            }\n-                            case Lowerable lop -> block = lop.lower(block);\n-                            default -> block.op(op);\n-                        }\n-                        return block;\n-                    }));\n-                } else { \/\/ expression body\n-                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n-                        switch (op) {\n-                            case YieldOp yop -> block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n-                            case Lowerable lop -> block = lop.lower(block);\n-                            default -> block.op(op);\n-                        }\n-                        return block;\n-                    }));\n-                }\n-            }\n-\n-            return exit;\n-        }\n-    }\n-\n-    \/**\n-     * The switch statement operation, that can model Java language switch statement.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaSwitchStatementOp.NAME)\n-    public static final class JavaSwitchStatementOp extends ExtendedOp\n-            implements Op.Nested, JavaStatement, Op.Lowerable {\n-        public static final String NAME = \"java.switch.statement\";\n-\n-        final List<Body> bodies;\n-\n-        public JavaSwitchStatementOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 1) {\n-                throw new IllegalStateException(\"Operation must have one operand\");\n-            }\n-\n-            \/\/ @@@ Validate\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-        }\n-\n-        JavaSwitchStatementOp(JavaSwitchStatementOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            \/\/ Copy body\n-            this.bodies = that.bodies.stream()\n-                    .map(b -> b.transform(cc, ot).build(this)).toList();\n-        }\n-\n-        @Override\n-        public JavaSwitchStatementOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaSwitchStatementOp(this, cc, ot);\n-        }\n-\n-        JavaSwitchStatementOp(Value target, List<Body.Builder> bodyCs) {\n-            super(NAME, List.of(target));\n+        JavaSwitchOp(String name, Value target, List<Body.Builder> bodyCs) {\n+            super(name, List.of(target));\n@@ -1122,5 +937,0 @@\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-\n@@ -1159,1 +969,1 @@\n-            if (bodies.isEmpty()) {\n+            if (bodies().isEmpty()) {\n@@ -1162,1 +972,4 @@\n-                exit = b.block();\n+                exit = b.block(resultType());\n+                if (resultType() != VOID) {\n+                    exit.context().mapValue(result(), exit.parameters().get(0));\n+                }\n@@ -1195,1 +1008,2 @@\n-                            case YieldOp yop -> block.op(branch(exit.successor()));\n+                            case YieldOp yop when this instanceof JavaSwitchStatementOp -> block.op(branch(exit.successor()));\n+                            case YieldOp yop when this instanceof JavaSwitchExpressionOp -> block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n@@ -1207,1 +1021,1 @@\n-        private boolean haveNullCase() {\n+        boolean haveNullCase() {\n@@ -1235,0 +1049,70 @@\n+    \/**\n+     * The switch expression operation, that can model Java language switch expressions.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaSwitchExpressionOp.NAME)\n+    public static final class JavaSwitchExpressionOp extends JavaSwitchOp\n+            implements JavaExpression {\n+        public static final String NAME = \"java.switch.expression\";\n+\n+        final TypeElement resultType;\n+\n+        public JavaSwitchExpressionOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.resultType = def.resultType();\n+        }\n+\n+        JavaSwitchExpressionOp(JavaSwitchExpressionOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public JavaSwitchExpressionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchExpressionOp(this, cc, ot);\n+        }\n+\n+        JavaSwitchExpressionOp(TypeElement resultType, Value target, List<Body.Builder> bodyCs) {\n+            super(NAME, target, bodyCs);\n+\n+            this.resultType = resultType == null ? bodies.get(1).yieldType() : resultType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The switch statement operation, that can model Java language switch statement.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaSwitchStatementOp.NAME)\n+    public static final class JavaSwitchStatementOp extends JavaSwitchOp\n+            implements JavaStatement {\n+        public static final String NAME = \"java.switch.statement\";\n+\n+        public JavaSwitchStatementOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        JavaSwitchStatementOp(JavaSwitchStatementOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+        }\n+\n+        @Override\n+        public JavaSwitchStatementOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchStatementOp(this, cc, ot);\n+        }\n+\n+        JavaSwitchStatementOp(Value target, List<Body.Builder> bodyCs) {\n+            super(NAME, target, bodyCs);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":84,"deletions":200,"binary":false,"changes":284,"status":"modified"}]}