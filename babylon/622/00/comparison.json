{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import hat.annotations.Kernel;\n+import hat.annotations.TypeDef;\n@@ -49,0 +51,1 @@\n+import java.lang.annotation.Annotation;\n@@ -145,0 +148,3 @@\n+\n+\n+\n@@ -160,39 +166,8 @@\n-        List<TypeElement> localIFaceList = new ArrayList<>();\n-\n-        kernelCallGraph.getModuleOp()\n-                .elements()\n-                .filter(c->Objects.requireNonNull(c) instanceof HATMemoryOp)\n-                .map(c->((HATMemoryOp)c).invokeType())\n-                .forEach(localIFaceList::add);\n-\n-       kernelCallGraph.entrypoint.funcOp()\n-                .elements()\n-                .filter(c->Objects.requireNonNull(c) instanceof HATMemoryOp)\n-                .map(c->((HATMemoryOp)c).invokeType())\n-                .forEach(localIFaceList::add);\n-\n-        \/\/ Dynamically build the schema for the user data type we are creating within the kernel.\n-        \/\/ This is because no allocation was done from the host. This is kernel code, and it is reflected\n-        \/\/ using the code reflection API\n-        \/\/ 1. Add for struct for iface objects\n-        for (TypeElement typeElement : localIFaceList) {\n-            \/\/ 1.1 Load the class dynamically\n-            try {\n-               Class<?> clazz = (Class<?>)((ClassType)typeElement).resolve(kernelCallGraph.computeContext.accelerator.lookup);\/\/Class.forName(typeElement.toString());\n-                \/\/System.out.println(\"!!!!!!For  \"+clazz);\n-                \/\/ TODO: Contract between the Java interface and the user. We require a method called `create` in order for this to work.\n-                \/\/ 1.2 Obtain the create method\n-                Method method = clazz.getMethod(\"create\", hat.Accelerator.class);\n-                method.setAccessible(true);\n-                Buffer invoke = (Buffer) method.invoke(null, kernelCallGraph.computeContext.accelerator);\n-\n-                \/\/ code gen of the struct\n-                BoundSchema<?> boundSchema = Buffer.getBoundSchema(invoke);\n-                boundSchema.schema().rootIfaceType.visitTypes(0, t -> {\n-                    if (!already.contains(t)) {\n-                        builder.typedef(boundSchema, t);\n-                        already.add(t);\n-                    }\n-                });\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n+        var annotation = kernelCallGraph.entrypoint.method.getAnnotation(Kernel.class);\n+\n+        if (annotation!=null){\n+            builder.lineComment(\"Preformatted from annotation\");\n+\n+            var typedef = kernelCallGraph.entrypoint.method.getAnnotation(TypeDef.class);\n+            if (typedef!=null){\n+                builder.preformatted(typedef.value());\n@@ -200,1 +175,4 @@\n-        }\n+          \/\/  System.out.println(annotation.value());\n+            builder.preformatted(annotation.value());\n+        }else {\n+            List<TypeElement> localIFaceList = new ArrayList<>();\n@@ -202,3 +180,5 @@\n-        ScopedCodeBuilderContext buildContext =\n-                new ScopedCodeBuilderContext(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator.lookup,\n-                        kernelCallGraph.entrypoint.funcOp());\n+            kernelCallGraph.getModuleOp()\n+                    .elements()\n+                    .filter(c -> Objects.requireNonNull(c) instanceof HATMemoryOp)\n+                    .map(c -> ((HATMemoryOp) c).invokeType())\n+                    .forEach(localIFaceList::add);\n@@ -206,6 +186,5 @@\n-        \/\/ Sorting by rank ensures we don't need forward declarations\n-        kernelCallGraph.getModuleOp().functionTable()\n-                .forEach((_, funcOp) -> {\n-                    \/\/ TODO: did we just trash the callgraph sidetables?\n-                    HATFinalDetectionPhase finals = new HATFinalDetectionPhase(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n-                    finals.apply(funcOp);\n+            kernelCallGraph.entrypoint.funcOp()\n+                    .elements()\n+                    .filter(c -> Objects.requireNonNull(c) instanceof HATMemoryOp)\n+                    .map(c -> ((HATMemoryOp) c).invokeType())\n+                    .forEach(localIFaceList::add);\n@@ -213,4 +192,14 @@\n-                    \/\/ Update the build context for this method to use the right constants-map\n-                    buildContext.setFinals(finals.getFinalVars());\n-                    builder.nl().kernelMethod(buildContext, funcOp).nl();\n-                });\n+            \/\/ Dynamically build the schema for the user data type we are creating within the kernel.\n+            \/\/ This is because no allocation was done from the host. This is kernel code, and it is reflected\n+            \/\/ using the code reflection API\n+            \/\/ 1. Add for struct for iface objects\n+            for (TypeElement typeElement : localIFaceList) {\n+                \/\/ 1.1 Load the class dynamically\n+                try {\n+                    Class<?> clazz = (Class<?>) ((ClassType) typeElement).resolve(kernelCallGraph.computeContext.accelerator.lookup);\/\/Class.forName(typeElement.toString());\n+                    \/\/System.out.println(\"!!!!!!For  \"+clazz);\n+                    \/\/ TODO: Contract between the Java interface and the user. We require a method called `create` in order for this to work.\n+                    \/\/ 1.2 Obtain the create method\n+                    Method method = clazz.getMethod(\"create\", hat.Accelerator.class);\n+                    method.setAccessible(true);\n+                    Buffer invoke = (Buffer) method.invoke(null, kernelCallGraph.computeContext.accelerator);\n@@ -218,5 +207,12 @@\n-        \/\/ Update the constants-map for the main kernel\n-        HATFinalDetectionPhase hatFinalDetectionPhase = new HATFinalDetectionPhase(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n-        hatFinalDetectionPhase.apply(kernelCallGraph.entrypoint.funcOp());\n-        buildContext.setFinals(hatFinalDetectionPhase.getFinalVars());\n-        builder.nl().kernelEntrypoint(buildContext, args).nl();\n+                    \/\/ code gen of the struct\n+                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(invoke);\n+                    boundSchema.schema().rootIfaceType.visitTypes(0, t -> {\n+                        if (!already.contains(t)) {\n+                            builder.typedef(boundSchema, t);\n+                            already.add(t);\n+                        }\n+                    });\n+                } catch (ReflectiveOperationException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n@@ -224,7 +220,30 @@\n-        if (config().showKernelModel()) {\n-            IO.println(\"Original\");\n-            IO.println(kernelCallGraph.entrypoint.funcOp().toText());\n-        }\n-        if (config().showLoweredKernelModel()){\n-            IO.println(\"Lowered\");\n-            IO.println(OpTk.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n+            ScopedCodeBuilderContext buildContext =\n+                    new ScopedCodeBuilderContext(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator.lookup,\n+                            kernelCallGraph.entrypoint.funcOp());\n+\n+            \/\/ Sorting by rank ensures we don't need forward declarations\n+            kernelCallGraph.getModuleOp().functionTable()\n+                    .forEach((_, funcOp) -> {\n+                        \/\/ TODO: did we just trash the callgraph sidetables?\n+                        HATFinalDetectionPhase finals = new HATFinalDetectionPhase(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n+                        finals.apply(funcOp);\n+\n+                        \/\/ Update the build context for this method to use the right constants-map\n+                        buildContext.setFinals(finals.getFinalVars());\n+                        builder.nl().kernelMethod(buildContext, funcOp).nl();\n+                    });\n+\n+            \/\/ Update the constants-map for the main kernel\n+            HATFinalDetectionPhase hatFinalDetectionPhase = new HATFinalDetectionPhase(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n+            hatFinalDetectionPhase.apply(kernelCallGraph.entrypoint.funcOp());\n+            buildContext.setFinals(hatFinalDetectionPhase.getFinalVars());\n+            builder.nl().kernelEntrypoint(buildContext, args).nl();\n+\n+            if (config().showKernelModel()) {\n+                IO.println(\"Original\");\n+                IO.println(kernelCallGraph.entrypoint.funcOp().toText());\n+            }\n+            if (config().showLoweredKernelModel()) {\n+                IO.println(\"Lowered\");\n+                IO.println(OpTk.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n+            }\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":84,"deletions":65,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+\n@@ -33,1 +34,1 @@\n-public @interface Kernel {\n+public @interface TypeDef {\n","filename":"hat\/core\/src\/main\/java\/hat\/annotations\/TypeDef.java","additions":2,"deletions":1,"binary":false,"changes":3,"previous_filename":"hat\/core\/src\/main\/java\/hat\/annotations\/Kernel.java","status":"copied"},{"patch":"@@ -71,0 +71,4 @@\n+        public void preformatted(String text){\n+            stringBuilder.append(text);\n+        }\n+\n@@ -133,0 +137,5 @@\n+    public T preformatted(String text){\n+        state.preformatted(text);\n+        return self();\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/TextBuilder.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.annotations.TypeDef;\n@@ -208,1 +209,7 @@\n-    @CodeReflection @Kernel(\"\"\"\n+    @CodeReflection\n+    @TypeDef(\"\"\"\n+            typedef struct SharedS32x256Array_s{\n+                int array[32];\n+            }SharedS32x256Array_t;\n+            \"\"\")\n+    @Kernel(\"\"\"\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}