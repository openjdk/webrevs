{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.code.Block;\n@@ -41,0 +40,1 @@\n+import optkl.util.ops.VarLikeOp;\n@@ -46,0 +46,2 @@\n+import static optkl.OpHelper.opFromFirstOperandOrThrow;\n+import static optkl.OpHelper.resultFromFirstOperandOrNull;\n@@ -62,1 +64,1 @@\n-                        if (isHatVectorBinaryOperation(invoke)) {\n+                        if (invoke.namedIgnoreCase(\"add\",\"sub\",\"mull\",\"div\")) {\n@@ -66,1 +68,2 @@\n-                                    varNameFromInvokeFirstUse(invoke),\n+                                    invoke.varOpFromFirstUseOrThrow().varName(),\n+                                   \/\/ varNameFromInvokeFirstUseOrThrow(invoke),\n@@ -77,1 +80,1 @@\n-                            bufferVarLoads.put((firstOperandAsResultOrNull(result.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) result.op());\n+                            bufferVarLoads.put((resultFromFirstOperandOrNull(result.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) result.op());\n@@ -80,1 +83,1 @@\n-                            \/\/ or else\n+                            \/\/ we do get here.\n@@ -84,1 +87,2 @@\n-                        if (isBufferInitialize(varOp) && firstOperand(varOp) instanceof Op.Result result) { \/\/ makes sure we don't process a new int[] for example\n+                        if (isBufferInitialize(varOp) && OpHelper.resultFromFirstOperandOrThrow(varOp) instanceof Op.Result result) {\n+                            \/\/ makes sure we don't process a new int[] for example\n@@ -86,1 +90,1 @@\n-                            replaced.put(varOp.result(), firstOperandAsResultOrNull(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n+                            replaced.put(varOp.result(), resultFromFirstOperandOrNull(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n@@ -89,1 +93,0 @@\n-                            List<Value> operands = (varOp.operands().isEmpty()) ? List.of() : List.of(firstOperand(varOp));\n@@ -96,1 +99,1 @@\n-                                   context.getValues(operands)\n+                                   context.getValues(OpHelper.firstOperandAsListOrEmpty(varOp))\n@@ -101,1 +104,1 @@\n-                            \/\/ or else\n+                            \/\/ we do get here.\n@@ -105,1 +108,1 @@\n-                        if ((isBufferInitialize(varLoadOp)) && firstOperand(varLoadOp) instanceof Op.Result r) {\n+                        if ((isBufferInitialize(varLoadOp)) && OpHelper.resultFromFirstOperandOrThrow(varLoadOp) instanceof Op.Result r) {\n@@ -107,2 +110,2 @@\n-                                Op.Result replacement = (notGlobalVarOp(varLoadOp)) ?\n-                                        firstOperandAsResultOrNull((firstOperandAsResultOrNull(r.op())).op()) :\n+                                Op.Result replacement = (isLocalSharedOrPrivate(varLoadOp)) ?\n+                                        resultFromFirstOperandOrNull((resultFromFirstOperandOrNull(r.op())).op()) :\n@@ -114,1 +117,4 @@\n-                                        CoreOp.VarAccessOp.varLoad(getValue(blockBuilder, replaced.get(r))));\n+                                        CoreOp.VarAccessOp.varLoad(\n+                                                blockBuilder.context().getValueOrDefault(replaced.get(r), replaced.get(r)))\n+                                             \/\/   getValue(blockBuilder, replaced.get(r)))\n+                                );\n@@ -121,1 +127,1 @@\n-                            \/\/ or else\n+                           \/\/ we do get here\n@@ -125,1 +131,1 @@\n-                        if (isBufferArray(arrayLoadOp) && firstOperand(arrayLoadOp) instanceof Op.Result r) {\n+                        if (isBufferArray(arrayLoadOp) && resultFromFirstOperandOrNull(arrayLoadOp) instanceof Op.Result r) {\n@@ -128,1 +134,1 @@\n-                                Op vop = (firstOperandAsResultOrNull(buffer.op())).op();\n+                                Op vop = opFromFirstOperandOrThrow(buffer.op());\/\/resultFromFirstOperandOrNull(buffer.op())).op();\n@@ -131,2 +137,1 @@\n-                                    case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n-                                    case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n+                                    case VarLikeOp varLikeOp -> varLikeOp.varName();\/\/   HATMemoryVarOp.HATLocalVarOp &&  HATMemoryVarOp.HATPrivateVarOp\n@@ -138,2 +143,2 @@\n-                                        CoreType.varType(((ArrayType) firstOperand(arrayLoadOp).type()).componentType()),\n-                                        hatVectorMetaData.vectorTypeElement(),\n+                                        CoreType.varType(((ArrayType) OpHelper.firstOperandOrThrow(arrayLoadOp).type()).componentType()),\n+                                        hatVectorMetaData.vectorTypeElement(), \/\/ seems like we might pass the hatVectorMetaData here...?\n@@ -141,1 +146,1 @@\n-                                        notGlobalVarOp(arrayLoadOp),\n+                                        isLocalSharedOrPrivate(arrayLoadOp),\n@@ -145,1 +150,1 @@\n-                            } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                            } else if (OpHelper.firstOperandOrThrow(op).type() instanceof ArrayType arrayType && arrayType.dimensions() == 1) { \/\/ we only use the last array load\n@@ -148,1 +153,0 @@\n-\n@@ -155,0 +159,2 @@\n+                            }else{\n+                                \/\/ or else\n@@ -162,1 +168,1 @@\n-                        if (isBufferArray(arrayStoreOp) && firstOperand(arrayStoreOp) instanceof Op.Result r) {\n+                        if (isBufferArray(arrayStoreOp) && OpHelper.resultFromFirstOperandOrThrow(arrayStoreOp) instanceof Op.Result r) {\n@@ -165,1 +171,3 @@\n-                                Op varOp = findVarOpOrHATVarOP(((Op.Result) arrayStoreOp.operands().getLast()).op());\n+                                Op varOp =\n+                                        findOpInResultFromFirstOperandsOrThrow(((Op.Result) arrayStoreOp.operands().getLast()).op(), CoreOp.VarOp.class, HATVectorOp.HATVectorVarOp.class);\n+                                       \/\/ findVarOpOrHATVarOP(((Op.Result) arrayStoreOp.operands().getLast()).op());\n@@ -172,1 +180,1 @@\n-                                var classType = ((ClassType) ((ArrayType) firstOperand(arrayStoreOp).type()).componentType());\n+                                var classType = ((ClassType) ((ArrayType) OpHelper.firstOperandOrThrow(arrayStoreOp).type()).componentType());\n@@ -179,1 +187,1 @@\n-                                        notGlobalVarOp(arrayStoreOp),\n+                                        isLocalSharedOrPrivate(arrayStoreOp),\n@@ -183,1 +191,1 @@\n-                            } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                            } else if (((ArrayType) OpHelper.firstOperandOrThrow(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n@@ -201,2 +209,2 @@\n-                    case JavaOp.ArrayLengthOp arrayLengthOp -> {\n-                        if (isBufferArray(arrayLengthOp) && firstOperand(arrayLengthOp) instanceof Op.Result) {\n+                    case JavaOp.ArrayLengthOp arrayLengthOp  when\n+                        isBufferArray(arrayLengthOp) && OpHelper.resultFromFirstOperandOrThrow(arrayLengthOp) instanceof Op.Result ->{\n@@ -211,3 +219,0 @@\n-                        }else{\n-                            \/\/ or else\n-                        }\n@@ -257,1 +262,1 @@\n-            buffer = replaced.get((Op.Result) firstOperand(buffer.op()));\n+            buffer = replaced.get(resultFromFirstOperandOrNull(buffer.op()));\n@@ -307,12 +312,0 @@\n-\n-    private boolean isHatVectorBinaryOperation(Invoke invoke) {\n-        \/\/ no! lets not compare strings what if we refactor the class names?  This is brittle\n-        return invoke.returnType().toString().startsWith(\"hat.buffer.Float\")\n-                   && invoke.name().toLowerCase() instanceof String name\n-                   &&(name.equals(\"add\")|| name.equals(\"sub\")||name.equals(\"mul\")||name.equals(\"div\"));\n-    }\n-\n-    private Op findVarOpOrHATVarOP(Op op) {\n-        return searchForOpOrNull(op, CoreOp.VarOp.class, HATVectorOp.HATVectorVarOp.class);\n-    }\n-\n@@ -321,1 +314,1 @@\n-           TypeElement type = firstOperand(op).type();\n+           TypeElement type = OpHelper.firstOperandOrThrow(op).type();\n@@ -336,11 +329,0 @@\n-    public static Op.Result firstOperandAsResultOrNull(Op op) {\n-        return (firstOperand(op) instanceof Op.Result result) ? result : null;\n-    }\n-\n-    public static Value firstOperand(Op op) {\n-        return op.operands().getFirst();\n-    }\n-\n-    public static Value getValue(Block.Builder bb, Value value) {\n-        return bb.context().getValueOrDefault(value, value);\n-    }\n@@ -349,1 +331,1 @@\n-        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOpOrNull(op, JavaOp.InvokeOp.class);\n+        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) findOpInResultFromFirstOperandsOrThrow(op, JavaOp.InvokeOp.class);\n@@ -353,2 +335,2 @@\n-    public boolean notGlobalVarOp(Op op) {\n-        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOpOrNull(op, JavaOp.InvokeOp.class);\n+    public boolean isLocalSharedOrPrivate(Op op) {\n+        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) findOpInResultFromFirstOperandsOrThrow(op, JavaOp.InvokeOp.class);\n@@ -360,1 +342,1 @@\n-    public Op searchForOpOrNull(Op op, Class<?> ...classes) {\n+    public Op findOpInResultFromFirstOperandsOrNull(Op op, Class<?> ...classes) {\n@@ -363,1 +345,1 @@\n-            if (!op.operands().isEmpty() && firstOperand(op) instanceof Op.Result result) {\n+            if (resultFromFirstOperandOrNull(op) instanceof Op.Result result) {\n@@ -371,0 +353,7 @@\n+    public Op findOpInResultFromFirstOperandsOrThrow(Op op, Class<?> ...classes) {\n+          if (findOpInResultFromFirstOperandsOrNull(op,classes) instanceof Op found){\n+              return found;\n+          }else{\n+              throw new RuntimeException(\"Expecting to find one of \"+List.of(classes));\n+          }\n+    }\n@@ -385,11 +374,0 @@\n-\n-    private String varNameFromInvokeFirstUse(Invoke invoke) {\n-        var uses= invoke.op().result().uses();\n-        if (!uses.isEmpty()) {\n-            Op.Result result = uses.stream().toList().getFirst();\n-            if (result.op() instanceof CoreOp.VarOp varOp) {\n-                return varOp.varName();\n-            }\n-        }\n-        return invoke.op().externalizeOpName();\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":53,"deletions":75,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -50,2 +51,1 @@\n-        System.out.print(b);\n-        System.out.printf(\"%d\",b);\n+        System.out.println(b);\n@@ -55,1 +55,10 @@\n-    static CoreOp.FuncOp group(MethodHandles.Lookup lookup,CoreOp.FuncOp f) {\n+\n+    public static void main(String[] args) throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        Method m = BlockGroup.class.getDeclaredMethod(\"m\", int.class, int.class);\n+        CoreOp.FuncOp mModel = Op.ofMethod(m).orElseThrow();\n+\n+       \/\/ System.out.println(\"From Code Model             -\\n\"+ OpCodeBuilder.toText(mModel));\n+        System.out.println(\"From Approx Jave Source ------\\n\"+JavaCodeBuilder.toText(lookup,mModel));\n+\n+        BytecodeGenerator.generate(lookup, mModel).invoke(1,2);\n@@ -58,1 +67,2 @@\n-        Invoke.stream(lookup,f.body().entryBlock()) \/\/ So this yields a stream of Invoke helpers\n+\n+        Invoke.stream(lookup,mModel.body().entryBlock()) \/\/ So this yields a stream of Invoke helpers\n@@ -61,2 +71,2 @@\n-                        && invoke.named(Regex.of(\"print(ln|)\"))\n-                        && invoke.returns(void.class))\n+                                && invoke.named(Regex.of(\"print(ln|)\"))\n+                                && invoke.returns(void.class))\n@@ -64,4 +74,4 @@\n-                            invoke.opFromOperandNOrThrow(0),\/\/ instead of op.operands().get(0).result().op()\n-                            invoke.opFromOperandNOrThrow(1),\n-                            invoke.op())\n-                    )\n+                                invoke.opFromOperandNOrThrow(0),\/\/ instead of op.operands().get(0).result().op()\n+                                invoke.opFromOperandNOrThrow(1),\n+                                invoke.op())\n+                        )\n@@ -70,22 +80,7 @@\n-        return Trxfmr.of(lookup,f).transform(opsToGroup::contains, c->{ \/\/ Here we use a HAT style transformer\n-                if (opsToGroup.getLast() == c.op()) {\n-                    \/\/ Create a new body builder connected as a child\n-                    \/\/ Use a child of the code context so values can be shared ???? what does this mean\n-                    Body.Builder groupBodyBuilder = Body.Builder.of(\n-                            c.builder().parentBody(), CoreType.FUNCTION_TYPE_VOID,\n-                            CodeContext.create(c.builder().context()));\n-\n-                    \/\/ Add ops to the entry block\n-                    Block.Builder groupBlockBuilder = groupBodyBuilder.entryBlock();\n-                    opsToGroup.forEach(groupBlockBuilder::op); \/\/ transfers all to this builder?\n-                    groupBlockBuilder.op(CoreOp.core_yield());\n-\n-                    c.replace(JavaOp.block(groupBodyBuilder)); \/\/ Replace all those added ops with the block op\n-                }else{\n-                    c.remove(); \/\/ Unlike regular trasnformers we must actively remove\n-                }\n-                \/\/ But we dont have to deal with anything we dont care about\n-                \/\/ no do we return the builder\n-        }).funcOp();\n-\n-    }\n+         var mGroupModel=  Trxfmr.of(lookup,mModel).transform(opsToGroup::contains, c->{ \/\/ Here we use a HAT style transformer\n+            if (opsToGroup.getLast() == c.op()) {\n+                \/\/ Create a new body builder connected as a child\n+                \/\/ Use a child of the code context so values can be shared ???? what does this mean\n+                Body.Builder groupBodyBuilder = Body.Builder.of(\n+                        c.builder().parentBody(), CoreType.FUNCTION_TYPE_VOID,\n+                        CodeContext.create(c.builder().context()));\n@@ -93,0 +88,4 @@\n+                \/\/ Add ops to the entry block\n+                Block.Builder groupBlockBuilder = groupBodyBuilder.entryBlock();\n+                opsToGroup.forEach(groupBlockBuilder::op); \/\/ transfers all to this builder?\n+                groupBlockBuilder.op(CoreOp.core_yield());\n@@ -94,0 +93,7 @@\n+                c.replace(JavaOp.block(groupBodyBuilder)); \/\/ Replace all those added ops with the block op\n+            }else{\n+                c.remove(); \/\/ Unlike regular trasnformers we must actively remove\n+            }\n+            \/\/ But we don't' have to deal with anything we don't care about\n+            \/\/ no do we return the builder\n+        }).funcOp();\n@@ -95,7 +101,0 @@\n-    public static void main(String[] args) throws Exception {\n-        var lookup = MethodHandles.lookup();\n-        Method m = BlockGroup.class.getDeclaredMethod(\"m\", int.class, int.class);\n-        CoreOp.FuncOp mModel = Op.ofMethod(m).orElseThrow();\n-       \/\/ System.out.println(\"From Code Model             -\\n\"+ OpCodeBuilder.toText(mModel));\n-        System.out.println(\"From Approx Jave Source ------\\n\"+JavaCodeBuilder.toText(lookup,mModel));\n-        CoreOp.FuncOp mGroupModel = group(lookup,mModel);\n@@ -105,0 +104,2 @@\n+        \/\/ make sure we didnt break anything\n+       BytecodeGenerator.generate(lookup, mGroupModel).invoke(1,2);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/BlockGroup.java","additions":40,"deletions":39,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.NDRange;\n+import hat.buffer.S32Array;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.MappedIfaceBufferInvokeQuery;\n+import optkl.OpHelper;\n+import optkl.Trxfmr;\n+import optkl.ifacemapper.AccessType;\n+import optkl.ifacemapper.MappableIface;\n+import optkl.ifacemapper.MappableIface.RO;\n+import optkl.ifacemapper.MappableIface.RW;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+\n+import static hat.ComputeContext.WRAPPER.ACCESS;\n+import static hat.ComputeContext.WRAPPER.MUTATE;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+\n+public class InjectBufferTracking {\n+\n+    @Reflect\n+    public static void inc(@RO KernelContext kc, @RW S32Array s32Array, int len) {\n+        if (kc.gix < kc.gsx) {\n+            s32Array.array(kc.gix, s32Array.array(kc.gix) + 1);\n+        }\n+    }\n+\n+    @Reflect\n+    public static void add(ComputeContext cc, @RW S32Array s32Array, int len, int n) {\n+\n+        int l = s32Array.length();\n+\n+        System.out.println(\"l = \" + l);\n+\n+        for (int i = 0; i < n; i++) {\n+            cc.dispatchKernel(NDRange.of1D(len), kc -> inc(kc, s32Array, len));\n+            System.out.println(i);\/\/s32Array.array(0));\n+        }\n+    }\n+\n+    static Block.Parameter getFuncParamOrNull(Op op, int n) {\n+        while (op != null && !(op instanceof CoreOp.FuncOp)) {\n+            System.out.println(op);\n+            op = op.ancestorOp();\n+        }\n+        if (op instanceof CoreOp.FuncOp funcOp) {\n+            return funcOp.bodies().get(0).entryBlock().parameters().get(n);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static Block.Parameter getFuncParamOrThrow(Op op, int n) {\n+        if (getFuncParamOrNull(op, n) instanceof Block.Parameter parameter) {\n+            return parameter;\n+        } else {\n+            throw new IllegalStateException(\"cant find func parameter parameter \" + n);\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) throws NoSuchMethodException {\n+        var lookup = MethodHandles.lookup();\n+        var mappedIfaceBufferInvokeQuery = MappedIfaceBufferInvokeQuery.create(lookup);\n+        var addMethod = Op.ofMethod(\n+                InjectBufferTracking.class.getDeclaredMethod(\"add\", ComputeContext.class, S32Array.class, int.class, int.class)\n+        ).orElseThrow();\n+        Trxfmr.of(lookup, addMethod)\n+                .toText(\"COMPUTE before injecting buffer tracking...\")\n+                .toJava(\"COMPUTE (Java) before injecting buffer tracking...\")\n+                .transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n+                    if (mappedIfaceBufferInvokeQuery.test(c.op()) instanceof MappedIfaceBufferInvokeQuery.OK match) {\n+                       Value computeContext = c.getValue(getFuncParamOrThrow(match.helper().op(), 0));\n+                       Value ifaceMappedBuffer = c.mappedOperand(0);\n+                       c.add(JavaOp.invoke(match.mutatesBuffer()? MUTATE.pre : ACCESS.pre, computeContext, ifaceMappedBuffer));\n+                       c.retain();\n+                       c.add(JavaOp.invoke(match.mutatesBuffer()? MUTATE.post : ACCESS.post, computeContext, ifaceMappedBuffer));\n+                    } else if (Invoke.invoke(lookup, c.op()) instanceof Invoke invoke && !invoke.refIs(ComputeContext.class) && invoke.operandCount() > 0) {\n+                        List<AccessType.TypeAndAccess> typeAndAccesses = invoke.paramaterAccessList();\n+                        Value computeContext = c.getValue(getFuncParamOrThrow(invoke.op(), 0));\/\/ c.getValue(invoke.op().operands().getFirst());\n+                        typeAndAccesses.stream()\n+                                .filter(typeAndAccess -> typeAndAccess.isIface(lookup))\n+                                .forEach(typeAndAccess ->\n+                                        c.add(JavaOp.invoke(\n+                                                typeAndAccess.ro() ? ACCESS.pre : MUTATE.pre,\n+                                                computeContext, c.getValue(typeAndAccess.value()))\n+                                        )\n+                                );\n+                        c.retain();\n+                        typeAndAccesses.stream()\n+                                .filter(typeAndAccess -> OpHelper.isAssignable(lookup, typeAndAccess.javaType(), MappableIface.class))\n+                                .forEach(typeAndAccess ->\n+                                        c.add(JavaOp.invoke(\n+                                                typeAndAccess.ro() ? ACCESS.post : MUTATE.post,\n+                                                computeContext, c.getValue(typeAndAccess.value()))\n+                                        )\n+                                );\n+                    }\n+                })\n+                .toText(\"COMPUTE after injecting buffer tracking...\")\n+                .toJava();\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InjectBufferTracking.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.MappedIfaceBufferInvokeQuery;\n+import optkl.Query;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+\n+public class Queries {\n+    @Reflect\n+    static int m(int a, int b) {\n+        a += 2;\n+        b += 2;\n+        \/\/ Group these\n+        System.out.println(a);\n+        System.out.println(b);\n+        return a + b;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        Method m = Queries.class.getDeclaredMethod(\"m\", int.class, int.class);\n+        CoreOp.FuncOp mModel = Op.ofMethod(m).orElseThrow();\n+\n+        var query = MappedIfaceBufferInvokeQuery.create(lookup);\n+        Invoke.stream(lookup,mModel).forEach(invoke->{\n+            if (query.test(invoke.op()) instanceof Query.Match<JavaOp.InvokeOp,Invoke, MappedIfaceBufferInvokeQuery> match){\n+                System.out.println(match.helper().name());\n+            }\n+        });\n+\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Queries.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.util.BiMap;\n+\n+import java.lang.invoke.MethodHandles;\n+import optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+\n+public interface InvokeQuery extends Query<JavaOp.InvokeOp,Invoke,InvokeQuery> {\n+    record Impl(MethodHandles.Lookup lookup) implements InvokeQuery {\n+        @Override\n+        public Res<JavaOp.InvokeOp,Invoke,InvokeQuery> test(CodeElement<?, ?> ce) {\n+            if (Invoke.invoke(lookup,ce) instanceof Invoke invoke) {\n+                record  MatchImpl (InvokeQuery query, Invoke helper) implements Match<JavaOp.InvokeOp,Invoke,InvokeQuery>{\n+                    @Override\n+                    public Match<JavaOp.InvokeOp,Invoke,InvokeQuery> remap(BiMap<CodeElement<?, ?>, CodeElement<?, ?>> biMap) {\n+                        return  new MatchImpl(MatchImpl.this.query,Invoke.invoke(query().lookup(), biMap.getTo(MatchImpl.this.helper.op())));\n+                    }\n+                }\n+                return new  MatchImpl(this,invoke);\n+            } else {\n+                return Query.FAILED;\n+            }\n+        }\n+    }\n+    static InvokeQuery create(MethodHandles.Lookup lookup) {\n+         return new Impl(lookup);\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/InvokeQuery.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import optkl.util.BiMap;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public interface MappedIfaceBufferInvokeQuery extends Query<JavaOp.InvokeOp,Invoke, MappedIfaceBufferInvokeQuery> {\n+    interface OK extends Match<JavaOp.InvokeOp, Invoke, MappedIfaceBufferInvokeQuery>{\n+         boolean mutatesBuffer();\n+    }\n+    record Impl(MethodHandles.Lookup lookup) implements MappedIfaceBufferInvokeQuery {\n+        @Override\n+        public Res<JavaOp.InvokeOp,Invoke, MappedIfaceBufferInvokeQuery> test(CodeElement<?, ?> ce) {\n+            if (Invoke.invoke(lookup, ce) instanceof Invoke invoke) {\n+                if (invoke.isInstance() && invoke.returns(MappedIfaceBufferInvokeQuery.class) || invoke.returnsPrimitive()){\n+                    record MatchImpl(MappedIfaceBufferInvokeQuery query, Invoke helper, boolean mutatesBuffer) implements OK{\n+                        @Override\n+                        public Match<JavaOp.InvokeOp, Invoke, MappedIfaceBufferInvokeQuery> remap(BiMap<CodeElement<?, ?>, CodeElement<?, ?>> biMap) {\n+                            return new MatchImpl(MatchImpl.this.query, Invoke.invoke(query().lookup(), biMap.getTo(MatchImpl.this.helper.op())),MatchImpl.this.mutatesBuffer);\n+                        }\n+                    }\n+                    return new MatchImpl(this, invoke, invoke.returnsVoid());\n+                }\n+            }\n+            return Query.FAILED;\n+        }\n+    }\n+    static MappedIfaceBufferInvokeQuery create(MethodHandles.Lookup lookup) {\n+         return new Impl(lookup);\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/MappedIfaceBufferInvokeQuery.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -60,0 +60,1 @@\n+import java.util.stream.Collectors;\n@@ -68,0 +69,19 @@\n+    static Value firstOperandOrNull(Op op) {\n+        if (!op.operands().isEmpty()){\n+            return op.operands().getFirst();\n+        }else {\n+           return null;\n+        }\n+    }\n+\n+    static Value firstOperandOrThrow(Op op) {\n+        if (!op.operands().isEmpty()){\n+            return op.operands().getFirst();\n+        }else {\n+            throw new RuntimeException(\"Op has no operands\");\n+        }\n+    }\n+\n+    static List<Value> firstOperandAsListOrEmpty(Op op) {\n+        return op.operands().isEmpty() ? List.of() : List.of(op.operands().getFirst());\n+    }\n@@ -116,0 +136,3 @@\n+\n+\n+\n@@ -123,0 +146,4 @@\n+    static Op opFromOperandNOrNull(Op op,int i){\n+        return resultFromOperandN(op, i) instanceof Op.Result result && result.op() instanceof Op op2 ?op2:null;\n+    }\n+\n@@ -129,0 +156,7 @@\n+    static Op opFromOperandNOrThrow(Op op, int i){\n+        if ( opFromOperandNOrNull(op, i)  instanceof Op op1){\n+            return op1;\n+        }else {\n+            throw new IllegalStateException(\"Expecting operand \"+i+\" to be a result which yields an Op \");\n+        }\n+    }\n@@ -136,0 +170,7 @@\n+    static Op opFromFirstOperandOrNull(Op op){\n+        return opFromOperandNOrNull(op, 0);\n+    }\n+\n+    static Op opFromFirstOperandOrThrow(Op op){\n+        return opFromOperandNOrThrow(op, 0);\n+    }\n@@ -160,3 +201,0 @@\n-    static Op.Result resultFromOperandN(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n-        return codeElement instanceof Op op && op.operands().size() > n && op.operands().get(n) instanceof Op.Result result ? result : null;\n-    }\n@@ -167,0 +205,14 @@\n+    static Op.Result resultFromOperandN(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n+        return codeElement instanceof Op op && op.operands().size() > n && op.operands().get(n) instanceof Op.Result result ? result : null;\n+    }\n+    static Op.Result resultFromFirstOperandOrNull(jdk.incubator.code.CodeElement<?, ?> codeElement) {\n+        return resultFromOperandN(codeElement,0);\n+    }\n+    static Op.Result resultFromFirstOperandOrThrow(jdk.incubator.code.CodeElement<?, ?> codeElement) {\n+        if ( resultFromFirstOperandOrNull(codeElement) instanceof Op.Result result){\n+            return result;\n+        }else {\n+            throw new RuntimeException(\"Expected result as first operand\");\n+        }\n+    }\n+\n@@ -204,0 +256,3 @@\n+        default boolean namedIgnoreCase( String...names){\n+            return Set.of(names).stream().map(String::toLowerCase).collect(Collectors.toSet()).contains(name().toLowerCase());\n+        }\n@@ -464,0 +519,9 @@\n+                default CoreOp.VarOp varOpFromFirstUseOrThrow(){\n+                    var iterator= op().result().uses().iterator();\n+                    if (iterator.hasNext() && iterator.next().op() instanceof CoreOp.VarOp varOp) {\n+                        return varOp;\n+                    }else {\n+                        throw new RuntimeException(\"Expecting first use of invoke to be VarOp\");\n+                    }\n+                }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":67,"deletions":3,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.util.BiMap;\n+import optkl.util.carriers.LookupCarrier;\n+\n+public interface  Query<O extends Op, OH extends OpHelper<O>, Q extends Query<O,OH,Q>> extends LookupCarrier {\n+\n+    interface Res<O extends Op, OH extends OpHelper<O>, Q extends Query<O,OH,Q>> {\n+    }\n+    Res<O,OH,Q> test(CodeElement<?,?> ce);\n+\n+    interface Fail extends Res{\n+    }\n+    record  FailImpl() implements Fail{\n+    }\n+    Fail FAILED= new FailImpl();\n+\n+    interface Match<O extends Op, OH extends OpHelper<O>, Q extends Query<O,OH,Q>> extends Res<O,OH,Q>{\n+        Q query();\n+        OH helper();\n+        Match<O,OH,Q> remap(BiMap<CodeElement<?,?>, CodeElement<?,?>> biMap);\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Query.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -94,0 +94,1 @@\n+    T concatOp(SB buildContext, JavaOp.ConcatOp concatOp);\n@@ -126,0 +127,1 @@\n+            case JavaOp.ConcatOp $ -> concatOp(buildContext,$);\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/BabylonOpDispatcher.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -490,0 +490,8 @@\n+    @Override\n+    public T concatOp(ScopedCodeBuilderContext buildContext, JavaOp.ConcatOp concatOp) {\n+        return\n+                recurse(buildContext, ((Op.Result)concatOp.operands().get(0)).op()).\n+        add().recurse(buildContext, ((Op.Result)concatOp.operands().get(1)).op());\n+      \/\/  blockInlineComment(\"concat\");\n+    }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaOrC99StyleCodeBuilder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}