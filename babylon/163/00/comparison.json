{"files":[{"patch":"@@ -0,0 +1,37 @@\n+\n+\n+# Notes and Links\n+\n+----\n+\n+* [Contents](hat-00.md)\n+* House Keeping\n+    * [Project Layout](hat-01-01-project-layout.md)\n+    * [Building Babylon](hat-01-02-building-babylon.md)\n+    * [Maven and CMake](hat-01-03-maven-cmake.md)\n+* Programming Model\n+    * [Programming Model](hat-03-programming-model.md)\n+* Interface Mapping\n+    * [Interface Mapping Overview](hat-04-01-interface-mapping.md)\n+    * [Cascade Interface Mapping](hat-04-02-cascade-interface-mapping.md)\n+* Implementation Detail\n+    * [Walkthrough Of Accelerator.compute()](hat-accelerator-compute.md)\n+\n+---\n+\n+# Notes and Links\n+\n+### Deep Learning\n+* [Amazons Deep Learning Java](http:\/\/djl.ai\/)\n+\n+### Manchester University TornadoVM\n+* [Tornado VM](https:\/\/github.com\/beehive-lab\/TornadoVM)\n+* [SPIRV Toolkit]()https:\/\/github.com\/beehive-lab\/beehive-spirv-toolkit\n+\n+### Other JAVA GPU\n+* [Aparapi](https:\/\/github.com\/Syncleus\/aparapi)\n+\n+### Github repos\n+* [Babylon OpenJDK](https:\/\/github.com\/openjdk\/babylon)\n+* [JTREG](https:\/\/github.com\/openjdk\/jtreg)\n+* [jexctract](https:\/\/github.com\/openjdk\/jextract)\n","filename":"hat\/docs\/hat-notes-and-links.md","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.Schema;\n+import hat.buffer.Buffer;\n+\n+import java.util.Random;\n+\n+public interface Mesh extends Buffer {\n+    interface Point3D extends StructChild {\n+        int x();void x(int x);\n+        int y();void y(int y);\n+        int z();void z(int z);\n+    }\n+\n+    int points();void points(int points);\n+    Point3D point(long idx);\n+\n+    interface Vertex3D extends StructChild {\n+        int from();void from(int id);\n+        int to();void to(int id);\n+    }\n+\n+    int vertices(); void vertices(int vertices);\n+    Vertex3D vertex(long idx);\n+\n+    Schema<Mesh> schema = Schema.of(Mesh.class, cascade -> cascade\n+            .arrayLen(\"points\").array(\"point\", p -> p.fields(\"x\",\"y\",\"z\"))\n+            .arrayLen(\"vertices\").array(\"vertex\", v -> v.fields(\"from\",\"to\"))\n+    );\n+\n+    public static void main(String[] args) {\n+        Mesh.schema.toText(t -> System.out.print(t));\n+        var mesh = Mesh.schema.allocate( 100, 10);\n+        mesh.points(100);\n+        mesh.vertices(10);\n+        Random random = new Random(System.currentTimeMillis());\n+        for (int p=0; p< mesh.points(); p++){\n+            var point3D = mesh.point(p);\n+            point3D.x(random.nextInt(100));\n+            point3D.y(random.nextInt(100));\n+            point3D.z(random.nextInt(100));\n+        }\n+        for (int v=0; v< mesh.vertices(); v++){\n+            var vertex3D = mesh.vertex(v);\n+            vertex3D.from(random.nextInt(mesh.points()));\n+            vertex3D.to(random.nextInt(mesh.points()));\n+        }\n+        System.out.println(Buffer.getLayout(mesh));\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.foreign.GroupLayout;\n@@ -63,1 +62,1 @@\n-        Schema.BoundLayout boundLayout = ResultTable.schema.collectLayouts(1000);\n+        var boundLayout = new Schema.BoundSchema<>(ResultTable.schema, 1000);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ResultTable.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.Schema;\n@@ -56,1 +57,1 @@\n-        var boundLayout = Cascade.schema.collectLayouts(10,10,10);\n+        var boundLayout = new Schema.BoundSchema<>(Cascade.schema,10,10,10);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SchemaLayoutTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    public static int square(int v) {\n+    public static int squareit(int v) {\n@@ -47,1 +47,1 @@\n-           s32Array.array(kc.x, square(value));  \/\/ arr[cc.x]=value*value\n+           s32Array.array(kc.x, squareit(value));  \/\/ arr[cc.x]=value*value\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Squares.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n-import hat.ifacemapper.HatData;\n@@ -11,1 +10,0 @@\n-import java.lang.foreign.SequenceLayout;\n@@ -16,1 +14,0 @@\n-import java.util.HashMap;\n@@ -18,2 +15,0 @@\n-import java.util.Map;\n-import java.util.Stack;\n@@ -32,1 +27,1 @@\n-    AbstractField.ParentField field;\n+    SchemaNode.TypeSchemaNode schemaRootField;\n@@ -34,3 +29,9 @@\n-    public final static BufferAllocator GlobalArenaAllocator = new BufferAllocator() {\n-        public <T extends Buffer> T allocate(SegmentMapper<T> s) {\n-            return s.allocate(Arena.global());\n+\n+    static abstract sealed class LayoutToBoundFieldTreeNode permits ChildLayoutToBoundFieldTreeNode, BoundSchema {\n+        static class FieldLayoutBinding<T extends SchemaNode> {\n+            final T field;\n+            MemoryLayout layout;\n+            FieldLayoutBinding(T field, MemoryLayout layout) {\n+                this.field = field;\n+                this.layout = layout;\n+            }\n@@ -38,8 +39,10 @@\n-    };\n-    static class ArraySizeBinding{\n-        int idx;\n-        int len;\n-        AbstractField.FieldControlledArray fieldControlledArray;\n-        ArraySizeBinding(int idx, int len) {\n-            this.idx = idx;\n-            this.len = len;\n+\n+        static class FieldControlledArrayBinding extends FieldLayoutBinding<SchemaNode.FieldControlledArray> {\n+            final int idx;\n+            final int len;\n+\n+            FieldControlledArrayBinding(int idx, int len, SchemaNode.FieldControlledArray fieldControlledArray) {\n+                super(fieldControlledArray, null);\n+                this.idx = idx;\n+                this.len = len;\n+            }\n@@ -47,1 +50,0 @@\n-    }\n@@ -49,8 +51,7 @@\n-    public static class BoundLayout<T extends Buffer>{\n-        Schema<T> schema;\n-        List<ArraySizeBinding> arraySizeBindings ;\n-       public  GroupLayout groupLayout;\n-        BoundLayout(Schema<T> schema, List<ArraySizeBinding> arraySizeBindings, GroupLayout groupLayout) {\n-            this.schema = schema;\n-            this.arraySizeBindings = arraySizeBindings;\n-            this.groupLayout = groupLayout;\n+        final protected LayoutToBoundFieldTreeNode parent;\n+        final List<ChildLayoutToBoundFieldTreeNode> children = new ArrayList<>();\n+        final List<MemoryLayout> memoryLayouts = new ArrayList<>();\n+        final List<FieldLayoutBinding> fieldToLayoutBindings = new ArrayList<>();\n+\n+        LayoutToBoundFieldTreeNode(LayoutToBoundFieldTreeNode parent) {\n+            this.parent = parent;\n@@ -58,8 +59,11 @@\n-    }\n-    static class LayoutCollector{\n-        private Stack<List<MemoryLayout>> stack = new Stack<>();\n-        private List<ArraySizeBinding> arraySizeBindings = new ArrayList<>();\n-        private int idx;\n-        LayoutCollector(int[] arrayLengths){\n-            for(int i=0; i<arrayLengths.length; i++){\n-                arraySizeBindings.add(new ArraySizeBinding(i, arrayLengths[i]));\n+\n+        abstract int takeArrayLen();\n+\n+        abstract FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout);\n+\n+        void bind(SchemaNode field, MemoryLayout memoryLayout) {\n+            FieldLayoutBinding fieldLayoutBinding = null;\n+            if (field instanceof SchemaNode.FieldControlledArray fieldControlledArray) {\n+                fieldLayoutBinding = createFieldControlledArrayBinding(fieldControlledArray, memoryLayout);\n+            } else {\n+                fieldLayoutBinding = new FieldLayoutBinding(field, memoryLayout);\n@@ -67,0 +71,2 @@\n+            fieldToLayoutBindings.add(fieldLayoutBinding);\n+            memoryLayouts.add(memoryLayout);\n@@ -68,6 +74,3 @@\n-        GroupLayout groupLayout = null;\n-        void pop(){\n-            if (stack.size()==1){\n-                groupLayout =  (GroupLayout) stack.peek().getFirst();;\n-            }\n-            stack.pop();\n+\n+        public MemoryLayout[] array() {\n+            return memoryLayouts.toArray(new MemoryLayout[0]);\n@@ -75,2 +78,5 @@\n-        void push(){\n-            stack.push(new ArrayList<>());\n+\n+        public ChildLayoutToBoundFieldTreeNode createChild() {\n+            var childLayoutCollector = new ChildLayoutToBoundFieldTreeNode(this);\n+            children.add(childLayoutCollector);\n+            return childLayoutCollector;\n@@ -78,2 +84,19 @@\n-        void add(MemoryLayout memoryLayout){\n-            stack.peek().add(memoryLayout);\n+    }\n+\n+    public static final class BoundSchema<T extends Buffer> extends LayoutToBoundFieldTreeNode {\n+        final private List<FieldControlledArrayBinding> arraySizeBindings;\n+        final private int[] arrayLengths;\n+        final Schema<T> schema;\n+        final public GroupLayout groupLayout;\n+        public BoundSchema(Schema<T> schema, int ...arrayLengths) {\n+            super(null);\n+            this.schema = schema;\n+            this.arrayLengths = arrayLengths;\n+            this.arraySizeBindings = new ArrayList<>();\n+            LayoutToBoundFieldTreeNode scope = createChild();\n+            schema.schemaRootField.fields.forEach(c -> c.collectLayouts(scope));\n+            MemoryLayout memoryLayout = isUnion(schema.schemaRootField.nameTypeAndMode.type)\n+                    ?MemoryLayout.unionLayout(scope.array())\n+                    :MemoryLayout.structLayout(scope.array());\n+            bind(schema.schemaRootField, memoryLayout.withName(schema.iface.getSimpleName()));\n+            this.groupLayout = (GroupLayout) memoryLayouts.getFirst();\n@@ -81,2 +104,5 @@\n-        ArraySizeBinding getIdx(){\n-            return arraySizeBindings.get(idx++);\n+\n+        public T allocate(BufferAllocator bufferAllocator) {\n+            System.out.println(groupLayout);\n+            var segmentMapper = SegmentMapper.of(MethodHandles.lookup(), schema.iface, groupLayout);\n+            return bufferAllocator.allocate(segmentMapper);\n@@ -84,2 +110,4 @@\n-        public MemoryLayout[] array() {\n-            return stack.peek().toArray(new MemoryLayout[0]);\n+\n+        @Override\n+        int takeArrayLen() {\n+            return arrayLengths[arraySizeBindings.size()];\n@@ -88,0 +116,6 @@\n+        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout) {\n+            int idx = arraySizeBindings.size();\n+            var arraySizeBinding = new FieldControlledArrayBinding(idx, arrayLengths[idx], fieldControlledArray);\n+            arraySizeBindings.add(arraySizeBinding);\n+            return arraySizeBinding;\n+        }\n@@ -89,7 +123,0 @@\n-    public BoundLayout<T> collectLayouts(int... arrayLengths) {\n-        LayoutCollector layoutCollector = new LayoutCollector(arrayLengths);\n-        layoutCollector.push();\n-        field.collectLayouts(layoutCollector);\n-        layoutCollector.pop();\n-        return new BoundLayout<T>(this,layoutCollector.arraySizeBindings, layoutCollector.groupLayout.withName(iface.getSimpleName()));\n-    }\n@@ -97,0 +124,14 @@\n+    public static final class ChildLayoutToBoundFieldTreeNode extends LayoutToBoundFieldTreeNode {\n+        ChildLayoutToBoundFieldTreeNode(LayoutToBoundFieldTreeNode parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        int takeArrayLen() {\n+            return parent.takeArrayLen();\n+        }\n+\n+        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout) {\n+            return parent.createFieldControlledArrayBinding(fieldControlledArray, memoryLayout);\n+        }\n+    }\n@@ -98,1 +139,1 @@\n-    static class AccessStyle {\n+    public static class NameTypeAndMode {\n@@ -100,22 +141,9 @@\n-            ROOT(false, false, false, false, false),\n-            PRIMITIVE_GETTER_AND_SETTER(false, true, false, true, true),\n-            PRIMITIVE_GETTER(false, true, false, false, true),\n-            PRIMITIVE_SETTER(false, true, false, true, false),\n-            IFACE_GETTER(false, false, true, false, true),\n-            PRIMITIVE_ARRAY_SETTER(true, true, false, true, false),\n-            PRIMITIVE_ARRAY_GETTER(true, true, false, false, true),\n-            PRIMITIVE_ARRAY_GETTER_AND_SETTER(true, true, false, true, true),\n-            IFACE_ARRAY_GETTER(true, false, true, false, true);\n-            boolean array;\n-            boolean primitive;\n-            boolean iface;\n-            boolean setter;\n-            boolean getter;\n-\n-            Mode(boolean array, boolean primitive, boolean iface, boolean setter, boolean getter) {\n-                this.array = array;\n-                this.primitive = primitive;\n-                this.iface = iface;\n-                this.getter = getter;\n-                this.setter = setter;\n-            }\n+            ROOT,\n+            PRIMITIVE_GETTER_AND_SETTER,\n+            PRIMITIVE_GETTER,\n+            PRIMITIVE_SETTER,\n+            IFACE_GETTER,\n+            PRIMITIVE_ARRAY_SETTER,\n+            PRIMITIVE_ARRAY_GETTER,\n+            PRIMITIVE_ARRAY_GETTER_AND_SETTER,\n+            IFACE_ARRAY_GETTER;\n@@ -124,1 +152,2 @@\n-             * From the iface mapper\n+             * From the iface mapper we get these mappings\n+             *\n@@ -154,12 +183,0 @@\n-\n-            Mode possiblyPromote(Mode mode) {\n-                if ((this.equals(PRIMITIVE_ARRAY_GETTER) && mode.equals(PRIMITIVE_ARRAY_SETTER))\n-                        || (this.equals(PRIMITIVE_ARRAY_SETTER) && mode.equals(PRIMITIVE_ARRAY_GETTER))) {\n-                    return Mode.PRIMITIVE_ARRAY_GETTER_AND_SETTER;\n-                } else if ((this.equals(PRIMITIVE_GETTER) && mode.equals(Mode.PRIMITIVE_SETTER))\n-                        || (this.equals(PRIMITIVE_SETTER) && mode.equals(Mode.PRIMITIVE_GETTER))) {\n-                    return Mode.PRIMITIVE_GETTER_AND_SETTER;\n-                } else {\n-                    return this;\n-                }\n-            }\n@@ -171,2 +188,2 @@\n-        List<Method> methods = new ArrayList<>();\n-        AccessStyle(Mode mode, Class<?> type, String name) {\n+\n+        NameTypeAndMode(Mode mode, Class<?> type, String name) {\n@@ -211,2 +228,2 @@\n-        static AccessStyle of(Class<?> iface, String name) {\n-            AccessStyle accessStyle = new AccessStyle(null, null, name);\n+        static NameTypeAndMode of(Class<?> iface, String name) {\n+            NameTypeAndMode accessStyle = new NameTypeAndMode(null, null, name);\n@@ -215,1 +232,1 @@\n-                AccessStyle.Mode mode = AccessStyle.Mode.of(matchingMethod);\n+                NameTypeAndMode.Mode mode = NameTypeAndMode.Mode.of(matchingMethod);\n@@ -217,1 +234,0 @@\n-                accessStyle.methods.add(matchingMethod);\n@@ -224,2 +240,13 @@\n-                \/\/  The enum knows how to promote GETTER to GETTER_AND_SETTER if prev mode was GETTER and this SETTER and vice versa\n-                accessStyle.mode = (accessStyle.mode == null) ? mode : accessStyle.mode.possiblyPromote(mode);\n+                if (accessStyle.mode == null){\n+                    \/\/ We don't have one already\n+                    accessStyle.mode = mode;\n+                } else if ((accessStyle.mode.equals(Mode.PRIMITIVE_ARRAY_GETTER) && mode.equals(Mode.PRIMITIVE_ARRAY_SETTER))\n+                        || (accessStyle.mode.equals(Mode.PRIMITIVE_ARRAY_SETTER) && mode.equals(Mode.PRIMITIVE_ARRAY_GETTER))) {\n+                    \/\/ mode was already an array getter or setter and is now a GETTER_AND_SETTER\n+                    accessStyle.mode = Mode.PRIMITIVE_ARRAY_GETTER_AND_SETTER;\n+                } else if ((accessStyle.mode.equals(Mode.PRIMITIVE_GETTER) && mode.equals(Mode.PRIMITIVE_SETTER))\n+                        || (accessStyle.mode.equals(Mode.PRIMITIVE_SETTER) && mode.equals(Mode.PRIMITIVE_GETTER))) {\n+                    \/\/ mode was already a primitive getter or setter and is now a GETTER_AND_SETTER\n+                    accessStyle.mode= Mode.PRIMITIVE_GETTER_AND_SETTER;\n+                }\n+\n@@ -252,8 +279,3 @@\n-    static boolean isMappable(Class<?> clazz) {\n-        return isStruct(clazz) || isBuffer(clazz) || isUnion(clazz);\n-    }\n-\n-    public static abstract class AbstractField {\n-        ParentField parent;\n-\n-        AbstractField(ParentField parent) {\n+    public static abstract class SchemaNode {\n+        TypeSchemaNode parent;\n+        SchemaNode(TypeSchemaNode parent) {\n@@ -262,1 +284,0 @@\n-\n@@ -265,2 +286,7 @@\n-        public static class Padding extends AbstractField {\n-            int len;\n+        public static abstract sealed class FieldSchemaNode extends SchemaNode permits Array, ArrayLen, AtomicField, Field, Padding {\n+            FieldSchemaNode(TypeSchemaNode parent) {\n+                super(parent);\n+            }\n+            public abstract void toText(String indent, Consumer<String> stringConsumer);\n+            abstract void collectLayouts(LayoutToBoundFieldTreeNode layoutCollector);\n+        }\n@@ -268,1 +294,3 @@\n-            Padding(ParentField parent, int len) {\n+        public static final class Padding extends FieldSchemaNode {\n+            int len;\n+            Padding(TypeSchemaNode parent, int len) {\n@@ -279,54 +307,2 @@\n-            void collectLayouts(LayoutCollector layoutCollector) {\n-                layoutCollector.add(MemoryLayout.paddingLayout(len));\n-            }\n-        }\n-\n-        \/**\n-         * Get a layout which describes the accessStyle.\n-         *\n-         * If accessStyle holds a primitive (int, float) then just map to JAVA_INT, JAVA_FLOAT value layouts\n-         * Otherwise we look through the parent's children.  Which should include a struct\/union matching the type.\n-         * @param accessStyle\n-         * @param layoutCollector\n-         * @return\n-         *\/\n-      \/\/  MemoryLayout getLayout(AccessStyle accessStyle, LinkedList<Integer> lengthsToBind, List<FieldControlledArray> boundArrays) {\n-        MemoryLayout getLayout(AccessStyle accessStyle, LayoutCollector layoutCollector) {\n-            MemoryLayout memoryLayout = null;\n-            if (accessStyle.type == Integer.TYPE) {\n-                memoryLayout = JAVA_INT;\n-            } else if (accessStyle.type == Float.TYPE) {\n-                memoryLayout = JAVA_FLOAT;\n-            } else if (accessStyle.type == Long.TYPE) {\n-                memoryLayout = JAVA_LONG;\n-            } else if (accessStyle.type == Double.TYPE) {\n-                memoryLayout = JAVA_DOUBLE;\n-            } else if (accessStyle.type == Short.TYPE) {\n-                memoryLayout = JAVA_SHORT;\n-            } else if (accessStyle.type == Character.TYPE) {\n-                memoryLayout = JAVA_CHAR;\n-            } else if (accessStyle.type == Byte.TYPE) {\n-                memoryLayout = JAVA_BYTE;\n-            } else if (accessStyle.type == Boolean.TYPE) {\n-                memoryLayout = JAVA_BOOLEAN;\n-            } else {\n-                ParentField o = parent.childFields.stream().filter(c -> c instanceof ParentField).map(c -> (ParentField) c)\n-                        .filter(p -> p.accessStyle.type.equals(accessStyle.type)).findFirst().get();\n-                layoutCollector.push();\n-\n-                o.childFields.forEach(c -> {\n-                    if (!(c instanceof AbstractField.ParentField)) {\n-\n-                        c.collectLayouts(layoutCollector);\n-                    }\n-                });\n-\n-                MemoryLayout[] childLayoutsAsArray = layoutCollector.array();\n-                layoutCollector.pop();\n-                if (isUnion(o.accessStyle.type)) {\n-                    memoryLayout = MemoryLayout.unionLayout(childLayoutsAsArray);\n-                } else if (isStructOrBuffer(o.accessStyle.type)) {\n-                    memoryLayout = MemoryLayout.structLayout(childLayoutsAsArray);\n-                } else {\n-                    throw new IllegalStateException(\"Recursing through layout collections and came across  \"+o.accessStyle.type);\n-                }\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, MemoryLayout.paddingLayout(len));\n@@ -334,1 +310,0 @@\n-            return memoryLayout;\n@@ -337,2 +312,2 @@\n-        public static class ArrayLen extends AbstractField {\n-            AccessStyle accessStyle;\n+        public static final class ArrayLen extends FieldSchemaNode {\n+            NameTypeAndMode nameTypeAndMode;\n@@ -340,1 +315,1 @@\n-            ArrayLen(ParentField parent, AccessStyle accessStyle) {\n+            ArrayLen(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n@@ -342,1 +317,1 @@\n-                this.accessStyle = accessStyle;\n+                this.nameTypeAndMode = nameTypeAndMode;\n@@ -347,1 +322,1 @@\n-                stringConsumer.accept(indent + \"arrayLen \" + accessStyle);\n+                stringConsumer.accept(indent + \"arrayLen \" + nameTypeAndMode);\n@@ -351,2 +326,2 @@\n-            void collectLayouts(LayoutCollector layoutCollector) {\n-                 layoutCollector.add(getLayout(accessStyle, layoutCollector).withName(accessStyle.name));\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, parent.getLayout(nameTypeAndMode, layoutToFieldBindingNode).withName(nameTypeAndMode.name));\n@@ -356,2 +331,2 @@\n-        public static class AtomicField extends AbstractField {\n-            AccessStyle accessStyle;\n+        public static final class AtomicField extends FieldSchemaNode {\n+            NameTypeAndMode nameTypeAndMode;\n@@ -359,1 +334,1 @@\n-            AtomicField(ParentField parent, AccessStyle accessStyle) {\n+            AtomicField(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n@@ -361,1 +336,1 @@\n-                this.accessStyle = accessStyle;\n+                this.nameTypeAndMode = nameTypeAndMode;\n@@ -366,1 +341,1 @@\n-                stringConsumer.accept(indent + \"atomic \" + accessStyle);\n+                stringConsumer.accept(indent + \"atomic \" + nameTypeAndMode);\n@@ -368,0 +343,1 @@\n+\n@@ -369,2 +345,2 @@\n-            void collectLayouts(LayoutCollector layoutCollector) {\n-                 layoutCollector.add(getLayout(accessStyle, layoutCollector).withName(accessStyle.name));\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, parent.getLayout(nameTypeAndMode, layoutToFieldBindingNode).withName(nameTypeAndMode.name));\n@@ -374,2 +350,2 @@\n-        public static class Field extends AbstractField {\n-            AccessStyle accessStyle;\n+        public static final class Field extends FieldSchemaNode {\n+            NameTypeAndMode nameTypeAndMode;\n@@ -377,1 +353,1 @@\n-            Field(ParentField parent, AccessStyle accessStyle) {\n+            Field(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n@@ -379,1 +355,1 @@\n-                this.accessStyle = accessStyle;\n+                this.nameTypeAndMode = nameTypeAndMode;\n@@ -384,1 +360,1 @@\n-                stringConsumer.accept(indent + \"field \" + accessStyle);\n+                stringConsumer.accept(indent + \"field \" + nameTypeAndMode);\n@@ -386,0 +362,1 @@\n+\n@@ -387,2 +364,2 @@\n-            void collectLayouts(LayoutCollector layoutCollector) {\n-                layoutCollector.add(getLayout(accessStyle, layoutCollector).withName(accessStyle.name));\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, parent.getLayout(nameTypeAndMode, layoutToFieldBindingNode).withName(nameTypeAndMode.name));\n@@ -390,1 +367,0 @@\n-\n@@ -393,6 +369,11 @@\n-        public static abstract class ParentField extends AbstractField {\n-            private List<AbstractField> childFields = new ArrayList<>();\n-            Map<Class<?>,AbstractField> typeMap = new HashMap<>();\n-            AccessStyle accessStyle;\n-            <T extends AbstractField> T addChildField(T child) {\n-                childFields.add(child);\n+        public static abstract sealed class TypeSchemaNode extends SchemaNode permits Union,Struct {\n+            private List<FieldSchemaNode> fields = new ArrayList<>();\n+            private List<TypeSchemaNode> types = new ArrayList<>();\n+            NameTypeAndMode nameTypeAndMode;\n+\n+            <T extends FieldSchemaNode> T addField(T child) {\n+                fields.add(child);\n+                return child;\n+            }\n+            <T extends TypeSchemaNode> T addType(T child) {\n+                types.add(child);\n@@ -401,1 +382,2 @@\n-            ParentField(ParentField parent, AccessStyle accessStyle) {\n+\n+            TypeSchemaNode(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n@@ -403,1 +385,1 @@\n-                this.accessStyle = accessStyle;\n+                this.nameTypeAndMode = nameTypeAndMode;\n@@ -405,0 +387,47 @@\n+            \/**\n+             * Get a layout which describes the NameTypeAndMode.\n+             * <p>\n+             * If NameTypeAndMode holds a primitive (int, float) then just map to JAVA_INT, JAVA_FLOAT value layouts\n+             * Otherwise we look through the parent's children.  Which should include a type node struct\/union matching the type.\n+             *\n+             * @param nameTypeAndMode\n+             * @param layoutToFieldBindingNode\n+             * @return\n+             *\/\n+             MemoryLayout getLayout(NameTypeAndMode nameTypeAndMode, LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                MemoryLayout memoryLayout = null;\n+                if (nameTypeAndMode.type == Integer.TYPE) {\n+                    memoryLayout = JAVA_INT;\n+                } else if (nameTypeAndMode.type == Float.TYPE) {\n+                    memoryLayout = JAVA_FLOAT;\n+                } else if (nameTypeAndMode.type == Long.TYPE) {\n+                    memoryLayout = JAVA_LONG;\n+                } else if (nameTypeAndMode.type == Double.TYPE) {\n+                    memoryLayout = JAVA_DOUBLE;\n+                } else if (nameTypeAndMode.type == Short.TYPE) {\n+                    memoryLayout = JAVA_SHORT;\n+                } else if (nameTypeAndMode.type == Character.TYPE) {\n+                    memoryLayout = JAVA_CHAR;\n+                } else if (nameTypeAndMode.type == Byte.TYPE) {\n+                    memoryLayout = JAVA_BYTE;\n+                } else if (nameTypeAndMode.type == Boolean.TYPE) {\n+                    memoryLayout = JAVA_BOOLEAN;\n+                } else {\n+                    TypeSchemaNode o = types.stream()\n+                            .filter(p -> p.nameTypeAndMode.type.equals(nameTypeAndMode.type)).findFirst().get();\n+                    LayoutToBoundFieldTreeNode scope = layoutToFieldBindingNode.createChild();\n+                    o.fields.stream()\n+                            .forEach(fieldSchemaNode -> {\n+                                fieldSchemaNode.collectLayouts(scope);\n+                            });\n+                    if (isUnion(o.nameTypeAndMode.type)) {\n+                        memoryLayout = MemoryLayout.unionLayout(scope.array());\n+                    } else if (isStructOrBuffer(o.nameTypeAndMode.type)) {\n+                        memoryLayout = MemoryLayout.structLayout(scope.array());\n+                    } else {\n+                        throw new IllegalStateException(\"Recursing through layout collections and came across  \" + o.nameTypeAndMode.type);\n+                    }\n+                }\n+                return memoryLayout;\n+            }\n+\n@@ -406,5 +435,2 @@\n-            public ParentField struct(String name, Consumer<ParentField> fb) {\n-                var struct = new Struct(this, AccessStyle.of(accessStyle.type, name));\n-                addChildField(struct);\n-                typeMap.put(accessStyle.type,struct);\n-                fb.accept(struct);\n+            public TypeSchemaNode struct(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n+                parentSchemaNodeConsumer.accept(addType(new Struct(this, NameTypeAndMode.of(nameTypeAndMode.type, name))));\n@@ -414,5 +440,2 @@\n-            public ParentField union(String name, Consumer<ParentField> fb) {\n-                var union = new Union(this, AccessStyle.of(accessStyle.type, name));\n-                addChildField(union);\n-                typeMap.put(accessStyle.type,union);\n-                fb.accept(union);\n+            public TypeSchemaNode union(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n+                parentSchemaNodeConsumer.accept(addType(new Union(this, NameTypeAndMode.of(nameTypeAndMode.type, name))));\n@@ -422,2 +445,2 @@\n-            public ParentField field(String name) {\n-                addChildField(new Field(this, AccessStyle.of(accessStyle.type, name)));\n+            public TypeSchemaNode field(String name) {\n+                addField(new Field(this, NameTypeAndMode.of(nameTypeAndMode.type, name)));\n@@ -427,2 +450,2 @@\n-            public ParentField atomic(String name) {\n-                addChildField(new AtomicField(this, AccessStyle.of(accessStyle.type, name)));\n+            public TypeSchemaNode atomic(String name) {\n+                addField(new AtomicField(this, NameTypeAndMode.of(nameTypeAndMode.type, name)));\n@@ -432,2 +455,2 @@\n-            public ParentField pad(int len) {\n-                addChildField(new Padding(this, len));\n+            public TypeSchemaNode pad(int len) {\n+                addField(new Padding(this, len));\n@@ -437,14 +460,5 @@\n-            public ParentField field(String name, Consumer<ParentField> parentFieldConsumer) {\n-                AccessStyle newAccessStyle = AccessStyle.of(accessStyle.type, name);\n-                addChildField(new Field(this, newAccessStyle));\n-                ParentField field;\n-                if (isStruct(newAccessStyle.type)) {\n-                    field = new AbstractField.Struct(this, newAccessStyle);\n-                } else if (isUnion(newAccessStyle.type)) {\n-                    field = new AbstractField.Union(this, newAccessStyle);\n-                } else {\n-                    throw new IllegalArgumentException(\"Unsupported field type: \" + newAccessStyle.type);\n-                }\n-                parentFieldConsumer.accept(field);\n-                addChildField(field);\n-                typeMap.put(newAccessStyle.type,field);\n+            public TypeSchemaNode field(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n+                NameTypeAndMode newAccessStyle = NameTypeAndMode.of(nameTypeAndMode.type, name);\n+                addField(new Field(this, newAccessStyle));\n+                TypeSchemaNode field = isStruct(newAccessStyle.type)?new SchemaNode.Struct(this, newAccessStyle):new SchemaNode.Union(this, newAccessStyle);\n+                parentSchemaNodeConsumer.accept(addType(field));\n@@ -454,16 +468,9 @@\n-            public ParentField fields(String name1, String name2, Consumer<ParentField> parentFieldConsumer) {\n-                AccessStyle newAccessStyle1 = AccessStyle.of(accessStyle.type, name1);\n-                AccessStyle newAccessStyle2 = AccessStyle.of(accessStyle.type, name2);\n-                addChildField(new Field(this, newAccessStyle1));\n-                addChildField(new Field(this, newAccessStyle2));\n-\n-                ParentField field;\n-                if (isStruct(newAccessStyle1.type)) {\n-                    field = new AbstractField.Struct(this, newAccessStyle1);\n-                } else if (isUnion(newAccessStyle1.type)) {\n-                    field = new AbstractField.Union(this, newAccessStyle2);\n-                } else {\n-                    throw new IllegalArgumentException(\"Unsupported array type: \" + newAccessStyle2.type);\n-                }\n-                parentFieldConsumer.accept(field);\n-                addChildField(field);\n+            public TypeSchemaNode fields(String name1, String name2, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n+                NameTypeAndMode newAccessStyle1 = NameTypeAndMode.of(nameTypeAndMode.type, name1);\n+                NameTypeAndMode newAccessStyle2 = NameTypeAndMode.of(nameTypeAndMode.type, name2);\n+                addField(new Field(this, newAccessStyle1));\n+                addField(new Field(this, newAccessStyle2));\n+                TypeSchemaNode typeSchemaNode=isStruct(newAccessStyle1.type)\n+                        ? new SchemaNode.Struct(this, newAccessStyle1)\n+                        :new SchemaNode.Union(this, newAccessStyle2);\n+                parentSchemaNodeConsumer.accept(addType(typeSchemaNode));\n@@ -473,1 +480,1 @@\n-            public ParentField fields(String... names) {\n+            public TypeSchemaNode fields(String... names) {\n@@ -480,2 +487,2 @@\n-            public ParentField array(String name, int len) {\n-                addChildField(new FixedArray(this, name, AccessStyle.of(accessStyle.type, name), len));\n+            public TypeSchemaNode array(String name, int len) {\n+                addField(new FixedArray(this, name, NameTypeAndMode.of(nameTypeAndMode.type, name), len));\n@@ -485,17 +492,8 @@\n-            public static ParentField createStructOrUnion(ParentField parent, AccessStyle accessStyle) {\n-                if (isStruct(accessStyle.type)) {\n-                    return new AbstractField.Struct(parent, accessStyle);\n-                } else if (isUnion(accessStyle.type)) {\n-                    return new AbstractField.Union(parent, accessStyle);\n-                }\n-                throw new IllegalArgumentException(\"Unsupported array type: \" + accessStyle.type);\n-\n-            }\n-\n-            public ParentField array(String name, int len, Consumer<ParentField> parentFieldConsumer) {\n-                AccessStyle newAccessStyle = AccessStyle.of(accessStyle.type, name);\n-                ParentField field = createStructOrUnion(this, newAccessStyle);\n-                parentFieldConsumer.accept(field);\n-                addChildField(field);\n-                typeMap.put(accessStyle.type,field);\n-                addChildField(new FixedArray(this, name, AccessStyle.of(accessStyle.type, name), len));\n+            public TypeSchemaNode array(String name, int len, Consumer<TypeSchemaNode> parentFieldConsumer) {\n+                NameTypeAndMode newAccessStyle = NameTypeAndMode.of(nameTypeAndMode.type, name);\n+                TypeSchemaNode typeSchemaNode = isStruct(nameTypeAndMode.type)\n+                                ?new SchemaNode.Struct(this, newAccessStyle)\n+                                :new SchemaNode.Union(this, newAccessStyle);\n+                parentFieldConsumer.accept(typeSchemaNode);\n+                addType(typeSchemaNode);\n+                addField(new FixedArray(this, name, NameTypeAndMode.of(nameTypeAndMode.type, name), len));\n@@ -505,2 +503,2 @@\n-            private ParentField fieldControlledArray(String name, ArrayLen arrayLen) {\n-                addChildField(new FieldControlledArray(this, name, AccessStyle.of(accessStyle.type, name), arrayLen));\n+            private TypeSchemaNode fieldControlledArray(String name, ArrayLen arrayLen) {\n+                addField(new FieldControlledArray(this, name, NameTypeAndMode.of(nameTypeAndMode.type, name), arrayLen));\n@@ -510,1 +508,0 @@\n-\n@@ -512,1 +509,1 @@\n-                ParentField parentField;\n+                TypeSchemaNode typeSchemaNode;\n@@ -515,2 +512,2 @@\n-                public ParentField array(String name) {\n-                    return parentField.fieldControlledArray(name, arrayLenField);\n+                public TypeSchemaNode array(String name) {\n+                    return typeSchemaNode.fieldControlledArray(name, arrayLenField);\n@@ -519,8 +516,9 @@\n-                public ParentField array(String name, Consumer<ParentField> parentFieldConsumer) {\n-                    AccessStyle newAccessStyle = AccessStyle.of(parentField.accessStyle.type, name);\n-                    parentField.fieldControlledArray(name, arrayLenField);\n-                    ParentField field = createStructOrUnion(parentField, newAccessStyle);\n-                    parentFieldConsumer.accept(field);\n-                    parentField.addChildField(field);\n-                    parentField.typeMap.put(parentField.accessStyle.type,field);\n-                    return parentField;\n+                public TypeSchemaNode array(String name, Consumer<TypeSchemaNode> parentFieldConsumer) {\n+                    NameTypeAndMode newAccessStyle = NameTypeAndMode.of(typeSchemaNode.nameTypeAndMode.type, name);\n+                    this.typeSchemaNode.fieldControlledArray(name, arrayLenField);\n+                    TypeSchemaNode typeSchemaNode =isStruct(newAccessStyle.type)\n+                            ?new SchemaNode.Struct(this.typeSchemaNode, newAccessStyle)\n+                            :new SchemaNode.Union(this.typeSchemaNode, newAccessStyle);\n+                    parentFieldConsumer.accept(typeSchemaNode);\n+                    this.typeSchemaNode.addType(typeSchemaNode);\n+                    return this.typeSchemaNode;\n@@ -529,2 +527,2 @@\n-                ArrayBuildState(ParentField parentField, ArrayLen arrayLenField) {\n-                    this.parentField = parentField;\n+                ArrayBuildState(TypeSchemaNode typeSchemaNode, ArrayLen arrayLenField) {\n+                    this.typeSchemaNode = typeSchemaNode;\n@@ -536,2 +534,2 @@\n-                var arrayLenField = new ArrayLen(this, AccessStyle.of(accessStyle.type, arrayLenFieldName));\n-                addChildField(arrayLenField);\n+                var arrayLenField = new ArrayLen(this, NameTypeAndMode.of(nameTypeAndMode.type, arrayLenFieldName));\n+                addField(arrayLenField);\n@@ -542,1 +540,1 @@\n-                addChildField(new FlexArray(this, name, null));\n+                addField(new FlexArray(this, name, null));\n@@ -545,19 +543,0 @@\n-            @Override\n-            void collectLayouts(LayoutCollector layoutCollector) {\n-                layoutCollector.push();\n-                childFields.forEach(c -> {\n-                    if (!(c instanceof ParentField)) {\n-                        c.collectLayouts(layoutCollector);\n-                    }\n-                });\n-                MemoryLayout memoryLayout = null;\n-                if (isUnion(accessStyle.type)) {\n-                    memoryLayout =MemoryLayout.unionLayout(layoutCollector.array());\n-                } else if (isStructOrBuffer(accessStyle.type)) {\n-                    memoryLayout = MemoryLayout.structLayout(layoutCollector.array());\n-                } else {\n-                    throw new IllegalStateException(\"Oh my \");\n-                }\n-                layoutCollector.pop();\n-                layoutCollector.add(memoryLayout);\n-            }\n@@ -568,1 +547,1 @@\n-                if (isUnion(accessStyle.type)) {\n+                if (isUnion(nameTypeAndMode.type)) {\n@@ -570,1 +549,1 @@\n-                } else if (isStructOrBuffer(accessStyle.type)) {\n+                } else if (isStructOrBuffer(nameTypeAndMode.type)) {\n@@ -575,1 +554,1 @@\n-                stringConsumer.accept(\" \" + accessStyle + \"{\");\n+                stringConsumer.accept(\" \" + nameTypeAndMode + \"{\");\n@@ -577,2 +556,6 @@\n-                childFields.forEach(c -> {\n-                    c.toText(indent + \" \", stringConsumer);\n+                types.forEach(c -> {\n+                    c.toText(indent + \" TYPE: \", stringConsumer);\n+                    stringConsumer.accept(\"\\n\");\n+                });\n+                fields.forEach(c -> {\n+                    c.toText(indent + \" FIELD: \", stringConsumer);\n@@ -581,0 +564,1 @@\n+\n@@ -586,3 +570,3 @@\n-        public static class Struct extends ParentField {\n-            Struct(ParentField parent, AccessStyle accessStyle) {\n-                super(parent, accessStyle);\n+        public static final class Struct extends TypeSchemaNode {\n+            Struct(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n+                super(parent, nameTypeAndMode);\n@@ -592,3 +576,3 @@\n-        public static class Union extends ParentField {\n-            Union(ParentField parent, AccessStyle accessStyle) {\n-                super(parent, accessStyle);\n+        public static final class Union extends TypeSchemaNode {\n+            Union(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n+                super(parent, nameTypeAndMode);\n@@ -598,1 +582,1 @@\n-        public abstract static class Array extends AbstractField {\n+        public abstract static sealed class Array extends FieldSchemaNode permits FieldControlledArray, FixedArray, FlexArray {\n@@ -600,3 +584,2 @@\n-            AccessStyle elementAccessStyle;\n-\n-            Array(ParentField parent, String name, AccessStyle elementAccessStyle) {\n+            NameTypeAndMode elementAccessStyle;\n+            Array(TypeSchemaNode parent, String name, NameTypeAndMode elementAccessStyle) {\n@@ -607,2 +590,0 @@\n-\n-\n@@ -611,1 +592,1 @@\n-        public static class FixedArray extends Array {\n+        public static final class FixedArray extends Array {\n@@ -614,1 +595,1 @@\n-            FixedArray(ParentField parent, String name, AccessStyle elementAccessStyle, int len) {\n+            FixedArray(TypeSchemaNode parent, String name, NameTypeAndMode elementAccessStyle, int len) {\n@@ -625,4 +606,4 @@\n-            void collectLayouts(LayoutCollector layoutCollector) {\n-                MemoryLayout elementLayout = getLayout(elementAccessStyle, layoutCollector).withName(elementAccessStyle.type.getSimpleName());;\n-                SequenceLayout sequenceLayout = MemoryLayout.sequenceLayout(len, elementLayout).withName(elementAccessStyle.name);\n-                layoutCollector.add(sequenceLayout);\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(len,\n+                        parent.getLayout(elementAccessStyle, layoutToFieldBindingNode).withName(elementAccessStyle.type.getSimpleName())\n+                ).withName(elementAccessStyle.name));\n@@ -632,2 +613,2 @@\n-        public static class FlexArray extends Array {\n-            FlexArray(ParentField parent, String name, AccessStyle elementAccessStyle) {\n+        public static final  class FlexArray extends Array {\n+            FlexArray(TypeSchemaNode parent, String name, NameTypeAndMode elementAccessStyle) {\n@@ -642,4 +623,5 @@\n-            void collectLayouts(LayoutCollector layoutCollector) {\n-                MemoryLayout elementLayout = getLayout(elementAccessStyle, layoutCollector).withName(elementAccessStyle.type.getSimpleName());;\n-                SequenceLayout sequenceLayout = MemoryLayout.sequenceLayout(0, elementLayout).withName(elementAccessStyle.name);\n-                layoutCollector.add(sequenceLayout);\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this,\n+                        MemoryLayout.sequenceLayout(0,\n+                                parent.getLayout(elementAccessStyle, layoutToFieldBindingNode).withName(elementAccessStyle.type.getSimpleName())\n+                        ).withName(elementAccessStyle.name));\n@@ -649,1 +631,1 @@\n-        public static class FieldControlledArray extends Array {\n+        public static final class FieldControlledArray extends Array {\n@@ -652,1 +634,1 @@\n-            FieldControlledArray(ParentField parent, String name, AccessStyle elementAccessStyle, ArrayLen arrayLen) {\n+            FieldControlledArray(TypeSchemaNode parent, String name, NameTypeAndMode elementAccessStyle, ArrayLen arrayLen) {\n@@ -659,1 +641,1 @@\n-                stringConsumer.accept(indent + elementAccessStyle.name + \"[\" + elementAccessStyle + \"] where len defined by \" + arrayLen.accessStyle);\n+                stringConsumer.accept(indent + elementAccessStyle.name + \"[\" + elementAccessStyle + \"] where len defined by \" + arrayLen.nameTypeAndMode);\n@@ -663,6 +645,5 @@\n-            void collectLayouts(LayoutCollector layoutCollector) {\n-                MemoryLayout elementLayout = getLayout(elementAccessStyle, layoutCollector).withName(elementAccessStyle.type.getSimpleName());;\n-                var arraySizeBinding = layoutCollector.getIdx();\n-                SequenceLayout sequenceLayout = MemoryLayout.sequenceLayout(arraySizeBinding.idx, elementLayout).withName(elementAccessStyle.name);\n-                layoutCollector.add(sequenceLayout);\n-                arraySizeBinding.fieldControlledArray=this;\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(\n+                        layoutToFieldBindingNode.takeArrayLen(),\n+                        parent.getLayout(elementAccessStyle, layoutToFieldBindingNode).withName(elementAccessStyle.type.getSimpleName())\n+                ).withName(elementAccessStyle.name));\n@@ -671,1 +652,0 @@\n-      abstract void collectLayouts(LayoutCollector layoutCollector);\n@@ -674,2 +654,1 @@\n-\n-    Schema(Class<T> iface, AbstractField.ParentField field) {\n+    Schema(Class<T> iface, SchemaNode.TypeSchemaNode schemaRootField) {\n@@ -677,1 +656,1 @@\n-        this.field = field;\n+        this.schemaRootField = schemaRootField;\n@@ -680,6 +659,7 @@\n-\n-\n-    public T allocate(BufferAllocator bufferAllocator, int... boundLengths) {\n-        var boundLayout = collectLayouts(boundLengths);\n-        var segmentMapper = SegmentMapper.of(MethodHandles.lookup(),iface, boundLayout.groupLayout);\n-        return bufferAllocator.allocate(segmentMapper);\n+    public final static BufferAllocator GlobalArenaAllocator = new BufferAllocator() {\n+        public <T extends Buffer> T allocate(SegmentMapper<T> s) {\n+            return s.allocate(Arena.global());\n+        }\n+    };\n+    public T allocate(BufferAllocator bufferAllocator,int... boundLengths) {\n+        return new BoundSchema<>(this, boundLengths).allocate(bufferAllocator);\n@@ -687,3 +667,2 @@\n-\n-    public T allocate( int... boundLengths) {\n-        return allocate(GlobalArenaAllocator, boundLengths);\n+    public T allocate(int... boundLengths) {\n+        return allocate(GlobalArenaAllocator,boundLengths);\n@@ -692,3 +671,3 @@\n-    public static <T extends Buffer> Schema<T> of(Class<T> iface, Consumer<AbstractField.ParentField> parentFieldConsumer) {\n-        AccessStyle accessStyle = AccessStyle.of(iface, iface.getSimpleName());\n-        var struct = new AbstractField.Struct(null, accessStyle);\n+    public static <T extends Buffer> Schema<T> of(Class<T> iface, Consumer<SchemaNode.TypeSchemaNode> parentFieldConsumer) {\n+        NameTypeAndMode nameTypeAndMode = NameTypeAndMode.of(iface, iface.getSimpleName());\n+        var struct = new SchemaNode.Struct(null, nameTypeAndMode);\n@@ -698,1 +677,0 @@\n-\n@@ -700,1 +678,1 @@\n-        field.toText(\"\", stringConsumer);\n+        schemaRootField.toText(\"\", stringConsumer);\n@@ -702,1 +680,0 @@\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/Schema.java","additions":334,"deletions":357,"binary":false,"changes":691,"status":"modified"},{"patch":"@@ -88,4 +88,4 @@\n-       \/\/ System.out.println(\"Original\");\n-       \/\/ System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op().toText());\n-       \/\/ System.out.println(\"Lowered\");\n-       \/\/ System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op().toText());\n+        System.out.println(\"Original\");\n+        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op().toText());\n+        System.out.println(\"Lowered\");\n+        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op().toText());\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/C99NativeBackend.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}