{"files":[{"patch":"@@ -7,1 +7,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -18,1 +17,0 @@\n-import  hat.HatPtr;\n@@ -21,1 +19,1 @@\n-import hat.ifacemapper.Schema;\n+import hat.ifacemapper.BoundSchema;\n@@ -46,1 +44,1 @@\n-            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema) {\n+            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n@@ -51,2 +49,0 @@\n-        System.out.println(PointyHat.ColoredWeightedPoint.LAYOUT);\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InvokeToPtr.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.ifacemapper.BoundSchemaNode;\n@@ -34,1 +35,0 @@\n-import hat.ifacemapper.SegmentMapper;\n@@ -144,1 +144,1 @@\n-        var boundSchema = new Schema.BoundSchema<>(MeshData.schema, 100, 10);\n+        var boundSchema = new BoundSchemaNode.BoundSchemaRootNode<>(MeshData.schema, 100, 10);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+import hat.HatPtr;\n@@ -8,0 +9,2 @@\n+import hat.NDRange;\n+import hat.backend.BackendAdaptor;\n@@ -9,0 +12,1 @@\n+import hat.callgraph.KernelCallGraph;\n@@ -10,1 +14,1 @@\n-import hat.backend.DebugBackend;\n+\n@@ -12,1 +16,0 @@\n-import hat.ifacemapper.SegmentMapper;\n@@ -14,3 +17,0 @@\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -18,0 +18,4 @@\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.FunctionType;\n@@ -24,1 +28,0 @@\n-\n@@ -32,6 +35,0 @@\n-\n-                GroupLayout LAYOUT = MemoryLayout.structLayout(\n-\n-                        ValueLayout.JAVA_INT.withName(\"x\"),\n-                        ValueLayout.JAVA_INT.withName(\"y\")\n-                );\n@@ -45,5 +42,0 @@\n-\n-           GroupLayout LAYOUT = MemoryLayout.structLayout(\n-                    ValueLayout.JAVA_FLOAT.withName(\"weight\"),\n-                    Point.LAYOUT.withName(\"point\")\n-            );\n@@ -58,7 +50,0 @@\n-        GroupLayout LAYOUT = MemoryLayout.structLayout(\n-                WeightedPoint.LAYOUT.withName(\"weightedPoint\"),\n-                ValueLayout.JAVA_INT.withName(\"color\")\n-        ).withName(ColoredWeightedPoint.class.getSimpleName());\n-\n-\n-\n@@ -67,1 +52,2 @@\n-                        .field(\"weight\", point->point\n+                        .field(\"weight\")\n+                        .field(\"point\", point->point\n@@ -75,1 +61,0 @@\n-            System.out.println(LAYOUT);\n@@ -80,2 +65,1 @@\n-    static class Compute {\n-\n+    public static class Compute {\n@@ -84,1 +68,1 @@\n-        static void testMethodKernel(KernelContext kc, ColoredWeightedPoint coloredWeightedPoint) {\n+        public static void testMethodKernel(KernelContext kc, ColoredWeightedPoint coloredWeightedPoint) {\n@@ -100,1 +84,1 @@\n-        static void compute(ComputeContext cc, ColoredWeightedPoint coloredWeightedPoint) {\n+        public static void compute(ComputeContext cc, ColoredWeightedPoint coloredWeightedPoint) {\n@@ -108,4 +92,27 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new DebugBackend(\n-                DebugBackend.HowToRunCompute.REFLECT,\n-                DebugBackend.HowToRunKernel.LOWER_TO_SSA_AND_MAP_PTRS)\n-        );\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new BackendAdaptor() {\n+            @Override\n+            public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+                var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n+                System.out.println(\"Initial code model\");\n+                System.out.println(highLevelForm.toText());\n+                System.out.println(\"------------------\");\n+                CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n+                System.out.println(\"Lowered form which maintains original invokes and args\");\n+                System.out.println(loweredForm.toText());\n+                System.out.println(\"-------------- ----\");\n+                \/\/ highLevelForm.lower();\n+                CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n+                System.out.println(\"SSA form which maintains original invokes and args\");\n+                System.out.println(ssaInvokeForm.toText());\n+                System.out.println(\"------------------\");\n+\n+                FunctionType functionType = HatPtr.transformTypes(MethodHandles.lookup(), ssaInvokeForm, args);\n+                System.out.println(\"SSA form with types transformed args\");\n+                System.out.println(ssaInvokeForm.toText());\n+                System.out.println(\"------------------\");\n+\n+                CoreOp.FuncOp ssaPtrForm = HatPtr.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n+                System.out.println(\"SSA form with invokes replaced by ptrs\");\n+                System.out.println(ssaPtrForm.toText());\n+            }\n+        });\n@@ -113,0 +120,10 @@\n+\n+        int color = coloredWeightedPoint.color();\n+        \/\/ s1 -> *s2\n+        ColoredWeightedPoint.WeightedPoint weightedPoint = coloredWeightedPoint.weightedPoint();\n+        \/\/ s2 -> i\n+        ColoredWeightedPoint.WeightedPoint.Point point = weightedPoint.point();\n+        color += point.x();\n+        coloredWeightedPoint.color(color);\n+        \/\/ s2 -> f\n+        float weight = weightedPoint.weight();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":51,"deletions":34,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+import hat.HatPtr;\n@@ -8,0 +9,3 @@\n+import hat.NDRange;\n+import hat.backend.Backend;\n+import hat.backend.BackendAdaptor;\n@@ -9,0 +13,2 @@\n+import hat.callgraph.KernelCallGraph;\n+import hat.callgraph.KernelEntrypoint;\n@@ -14,0 +20,1 @@\n+import java.lang.foreign.Arena;\n@@ -18,0 +25,5 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.FunctionType;\n@@ -67,1 +79,1 @@\n-    static class Compute {\n+    public static class Compute {\n@@ -71,1 +83,1 @@\n-        static void testMethodKernel(KernelContext kc, PointArray pointArray) {\n+         public static void testMethodKernel(KernelContext kc, PointArray pointArray) {\n@@ -81,1 +93,1 @@\n-        static void compute(ComputeContext cc, PointArray pointArray) {\n+        public static void compute(ComputeContext cc, PointArray pointArray) {\n@@ -89,2 +101,27 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new DebugBackend(\n-                DebugBackend.HowToRunCompute.REFLECT,DebugBackend.HowToRunKernel.LOWER_TO_SSA_AND_MAP_PTRS));\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new BackendAdaptor() {\n+            @Override\n+            public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+                var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n+                System.out.println(\"Initial code model\");\n+                System.out.println(highLevelForm.toText());\n+                System.out.println(\"------------------\");\n+                CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n+                System.out.println(\"Lowered form which maintains original invokes and args\");\n+                System.out.println(loweredForm.toText());\n+                System.out.println(\"-------------- ----\");\n+                \/\/ highLevelForm.lower();\n+                CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n+                System.out.println(\"SSA form which maintains original invokes and args\");\n+                System.out.println(ssaInvokeForm.toText());\n+                System.out.println(\"------------------\");\n+\n+                FunctionType functionType = HatPtr.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n+                System.out.println(\"SSA form with types transformed args\");\n+                System.out.println(ssaInvokeForm.toText());\n+                System.out.println(\"------------------\");\n+\n+                CoreOp.FuncOp ssaPtrForm = HatPtr.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n+                System.out.println(\"SSA form with invokes replaced by ptrs\");\n+                System.out.println(ssaPtrForm.toText());\n+            }\n+        });\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHatArray.java","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.ifacemapper.Schema;\n+import hat.ifacemapper.BoundSchema;\n@@ -41,1 +41,1 @@\n-            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema) {\n+            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S08x3ImageTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.ifacemapper.Schema;\n+import hat.ifacemapper.BoundSchema;\n@@ -34,1 +34,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -42,1 +41,1 @@\n-            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema) {\n+            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32ArrayTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.ifacemapper.Schema;\n+import hat.ifacemapper.BoundSchema;\n@@ -107,1 +107,1 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundShema) {\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundShema) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/Accelerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-import hat.ifacemapper.Schema;\n+import hat.ifacemapper.BoundSchema;\n@@ -125,1 +125,1 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema) {\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/ComputeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+import hat.buffer.Buffer;\n+import hat.ifacemapper.BoundSchema;\n@@ -4,0 +6,1 @@\n+import hat.ifacemapper.Schema;\n@@ -34,4 +37,7 @@\n-        public static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement) {\n-            return getMappableClassOrNull(lookup, typeElement) instanceof Class<?> clazz\n-                    ? new HatPtr.HatPtrType<>((Class<T>) clazz, getLayout((Class<T>) clazz))\n-                    : typeElement;\n+        public static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement, BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n+            if (getMappableClassOrNull(lookup, typeElement) instanceof Class<?> clazz){\n+               \/\/ MemoryLayout layout = boundSchema.getLayout(clazz);\n+                return new HatPtr.HatPtrType<>((Class<T>) clazz, getLayout((Class<T>) clazz));\n+            }else{\n+                return typeElement;\n+            }\n@@ -58,1 +64,1 @@\n-        public static FunctionType transformTypes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        public static FunctionType transformTypes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp, Object ...args) {\n@@ -60,2 +66,10 @@\n-            for (Block.Parameter parameter : funcOp.parameters()) {\n-                transformedTypeElements.add(convertToPtrTypeIfPossible(lookup, parameter.type()));\n+            for (int i = 0; i < args.length; i++) {\n+                Block.Parameter parameter = funcOp.parameters().get(i);\n+                TypeElement parameterTypeElement=null;\n+                if (args[i] instanceof Buffer buffer) {\n+                    var boundSchema = Buffer.getBoundSchema(buffer);\n+                    parameterTypeElement=convertToPtrTypeIfPossible(lookup, parameter.type(), boundSchema,boundSchema.schema().rootIfaceTypeNode);\n+                }else{\n+                    parameterTypeElement =parameter.type();\n+                }\n+                transformedTypeElements.add(parameterTypeElement);\n@@ -63,1 +77,2 @@\n-            return FunctionType.functionType(convertToPtrTypeIfPossible(lookup, funcOp.invokableType().returnType()), transformedTypeElements);\n+            TypeElement returnTypeElement = convertToPtrTypeIfPossible(lookup, funcOp.invokableType().returnType(),null, null);\n+            return FunctionType.functionType(returnTypeElement, transformedTypeElements);\n","filename":"hat\/hat\/src\/main\/java\/hat\/HatPtr.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+package hat.backend;\n+\n+import hat.ComputeContext;\n+import hat.NDRange;\n+import hat.buffer.Buffer;\n+import hat.callgraph.KernelCallGraph;\n+import hat.callgraph.KernelEntrypoint;\n+import hat.ifacemapper.BoundSchema;\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public abstract class BackendAdaptor implements Backend {\n+    @Override\n+    public void computeContextHandoff(ComputeContext computeContext) {\n+\n+    }\n+\n+    @Override\n+    public void dispatchCompute(ComputeContext computeContext, Object... args) {\n+        try {\n+            computeContext.computeCallGraph.entrypoint.method.invoke(null, args);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+        KernelEntrypoint kernelEntrypoint = kernelCallGraph.entrypoint;\n+        for (ndRange.kid.x = 0; ndRange.kid.x < ndRange.kid.maxX; ndRange.kid.x++) {\n+            try {\n+                args[0] = ndRange.kid;\n+                kernelEntrypoint.method.invoke(null, args);\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            } catch (InvocationTargetException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n+        return segmentMapper.allocate(Arena.global(), boundSchema);\n+    }\n+\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/BackendAdaptor.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import hat.ifacemapper.BoundSchema;\n@@ -82,2 +83,2 @@\n-                    Schema.BoundSchema<?> boundSchema = Buffer.getBoundSchema(ifaceBuffer);\n-                    boundSchema.schema.rootIfaceTypeNode.visitTypes(0, t -> {\n+                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(ifaceBuffer);\n+                    boundSchema.schema().rootIfaceTypeNode.visitTypes(0, t -> {\n@@ -90,9 +91,0 @@\n-\/*\n-            Map<String, Typedef> scope = new LinkedHashMap<>();\n-            Arrays.stream(args)\n-                    .filter(arg -> arg instanceof Buffer)\n-                    .map(arg -> (Buffer) arg)\n-                    .forEach(ifaceBuffer -> builder.typedef(scope, ifaceBuffer));\n-\n-*\/\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/C99NativeBackend.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -6,1 +6,0 @@\n-import hat.buffer.Buffer;\n@@ -9,4 +8,0 @@\n-import hat.ifacemapper.Schema;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.Arena;\n@@ -22,1 +17,1 @@\n-public class DebugBackend implements Backend {\n+public class DebugBackend extends BackendAdaptor {\n@@ -32,4 +27,0 @@\n-    @Override\n-    public void computeContextHandoff(ComputeContext computeContext) {\n-    }\n-\n@@ -38,1 +29,0 @@\n-\n@@ -152,7 +142,0 @@\n-\n-\n-    }\n-\n-    @Override\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema) {\n-        return segmentMapper.allocate(Arena.global(), boundSchema);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.ifacemapper.Schema;\n+import hat.ifacemapper.BoundSchema;\n@@ -42,1 +42,1 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema){\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema){\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/JavaBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.ifacemapper.Schema;\n+import hat.ifacemapper.BoundSchema;\n@@ -48,1 +48,1 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema){\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema){\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.buffer.Buffer;\n+import hat.ifacemapper.BoundSchema;\n@@ -67,1 +67,0 @@\n-import java.util.Map;\n@@ -419,40 +418,0 @@\n-    public T typedef(Map<String, Typedef> scope, Buffer instance) {\n-        return typedef(scope, Typedef.of(instance));\n-    }\n-\n-\n-    public T typedef(Map<String, Typedef> scope, Typedef typeDef) {\n-        if (!scope.containsKey(typeDef.name())) {\n-            \/\/ Do the dependencies first, so we get them in the right order\n-\n-            typeDef.nameAndTypes.stream().filter(nameAndType -> nameAndType.typeDef != null).forEach(nameAndType -> {\n-                typedef(scope, nameAndType.typeDef).nl();\n-            });\n-            typedefKeyword().space().structOrUnion(typeDef.isStruct)\n-                    .space().suffix_s(typeDef.iface.getSimpleName()).braceNlIndented(_ -> {\n-                        StreamCounter.of(typeDef.nameAndTypes, (c, nameAndType) -> {\n-                            nlIf(c.isNotFirst());\n-                            if (nameAndType.type.isPrimitive()) {\n-                                typeName(nameAndType.type.getSimpleName());\n-                            } else {\n-                                suffix_t(nameAndType.type.getSimpleName());\n-                            }\n-                            space().typeName(nameAndType.name);\n-                            if (nameAndType instanceof Typedef.NameAndArrayOfType nameAndArrayOfType) {\n-                                sbrace(_ -> {\n-                                    if (nameAndArrayOfType.arraySize > 0) {\n-                                        literal(nameAndArrayOfType.arraySize);\n-                                    } else {\n-                                        literal(1);\n-                                    }\n-                                });\n-                            }\n-                            semicolon();\n-                        });\n-                    }).suffix_t(typeDef.iface.getSimpleName()).semicolon().nl().nl();\n-\n-\n-            scope.put(typeDef.name(), typeDef);\n-        }\n-        return self();\n-    }\n@@ -460,1 +419,1 @@\n-    public T typedef(Schema.BoundSchema<?> boundSchema,Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n+    public T typedef(BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n@@ -463,1 +422,1 @@\n-                    System.out.println(ifaceTypeNode);\n+                    \/\/System.out.println(ifaceTypeNode);\n@@ -477,1 +436,1 @@\n-                                        boundSchema.arraySizeBindings.forEach(a->{\n+                                        boundSchema.boundArrayFields().forEach(a->{\n@@ -482,1 +441,0 @@\n-                                            \/\/System.out.println(a);\n@@ -503,1 +461,1 @@\n-                                        boundSchema.arraySizeBindings.forEach(a -> {\n+                                        boundSchema.boundArrayFields().forEach(a -> {\n@@ -508,1 +466,0 @@\n-                                            \/\/System.out.println(a);\n@@ -534,1 +491,1 @@\n-        throw new IllegalStateException(\"atimicInc not implemented\");\n+        throw new IllegalStateException(\"atomicInc not implemented\");\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatBuilder.java","additions":6,"deletions":49,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1,210 +0,0 @@\n-package hat.backend.c99codebuilders;\n-\n-import hat.buffer.Buffer;\n-import hat.ifacemapper.Schema;\n-import hat.util.StreamCounter;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.PaddingLayout;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-\n-import static hat.ifacemapper.MapperUtil.SECRET_BOUND_SCHEMA_METHOD_NAME;\n-import static hat.ifacemapper.MapperUtil.SECRET_LAYOUT_METHOD_NAME;\n-import static hat.ifacemapper.MapperUtil.SECRET_OFFSET_METHOD_NAME;\n-import static hat.ifacemapper.MapperUtil.SECRET_SEGMENT_METHOD_NAME;\n-\n-public class Typedef {\n-    public int rank;\n-    final boolean isStruct;\n-    boolean isIncomplete = false;\n-\n-    public String name() {\n-        return iface.getSimpleName();\n-    }\n-\n-    public static abstract class AbstractNameAndType {\n-        public int index;\n-        public final Typedef containingTypedef;\n-\n-        public Typedef typeDef;\n-\n-        public final String name;\n-\n-        public final Class<?> type;\n-\n-        public MemoryLayout layout;\n-\n-        public AbstractNameAndType(Typedef containingTypedef, String name, Class<?> type) {\n-            this.index = -1;\n-            this.containingTypedef = containingTypedef;\n-            this.name = name;\n-            this.type = type;\n-        }\n-\n-        boolean isPrimitive() {\n-            return this.type.isPrimitive();\n-        }\n-    }\n-\n-    public static class NameAndType extends Typedef.AbstractNameAndType {\n-        public NameAndType(Typedef containingTypedef, String name, Class<?> type) {\n-            super(containingTypedef, name, type);\n-        }\n-    }\n-\n-    public static class NameAndArrayOfType extends Typedef.AbstractNameAndType {\n-        public long arraySize;\n-        public boolean isFlexible;\n-\n-        public NameAndArrayOfType(Typedef containingTypedef, String name, Class<?> type, long arraySize) {\n-            super(containingTypedef, name, type);\n-            this.arraySize = arraySize;\n-            this.isFlexible = false;\n-        }\n-    }\n-\n-    public final MemoryLayout memoryLayout;\n-    public final Class<?> iface;\n-\n-    public List<AbstractNameAndType> nameAndTypes = new ArrayList<>();\n-\n-    public Typedef(Class<?> iface, MemoryLayout memoryLayout, Schema.BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n-        Map<String, AbstractNameAndType> nameToFieldNameAndType = new LinkedHashMap<>();\n-\n-        this.iface = iface;\n-      \/\/  if (iface != boundSchema.schema.rootTypeSchemaNode.type) {\n-        \/\/    throw new IllegalStateException(\"bad\");\n-       \/\/ }\n-        this.memoryLayout = memoryLayout;\n-\n-        Arrays.stream(iface.getMethods()).forEach(method -> {\n-\n-            \/\/ This is replicating th schema info\n-            if (Modifier.isStatic(method.getModifiers())) {\n-                \/\/ forgetaboutit\n-            } else if (method.isDefault()) {\n-                \/\/ forgetaboutit\n-            } else {\n-                String name = method.getName();\n-                if (nameToFieldNameAndType.containsKey(name)\n-                        || name.equals(\"equals\")\n-                        || name.equals(\"toString\")\n-                        || name.equals(\"hashCode\")\n-                        || name.equals(SECRET_OFFSET_METHOD_NAME)\n-                        || name.equals(SECRET_SEGMENT_METHOD_NAME)\n-                        || name.equals(SECRET_LAYOUT_METHOD_NAME)\n-                        || name.equals(SECRET_BOUND_SCHEMA_METHOD_NAME)\n-                        || name.equals(\"notify\")\n-                        || name.equals(\"notifyAll\")\n-                ) {\n-                    \/\/ forgetaboutit\n-                } else {\n-                    var returnType = method.getReturnType();\n-                    var parameterCount = method.getParameterCount();\n-                    var parameterTypes = method.getParameterTypes();\n-                    if (returnType.equals(Void.TYPE)) {\n-                        if (parameterCount == 0) {\n-                            throw new IllegalStateException(\"paramcount ==0 or  >2 arg iface setter with void return \");\n-                        }\n-                        if (parameterCount == 1) {\n-                            nameToFieldNameAndType.put(name, new Typedef.NameAndType(this, name, parameterTypes[0]));\n-                        } else {\n-                            nameToFieldNameAndType.put(name, new Typedef.NameAndArrayOfType(this, name, parameterTypes[1], -1));\n-                        }\n-                    } else {\n-                        if (parameterCount > 1) {\n-                            throw new IllegalStateException(\" >1 arg iface getter with non void return \");\n-                        }\n-                        if (parameterCount == 0) {\n-                            nameToFieldNameAndType.put(name, new Typedef.NameAndType(this, name, returnType));\n-                        } else {\n-                            nameToFieldNameAndType.put(name, new Typedef.NameAndArrayOfType(this, name, returnType, -1));\n-                        }\n-                    }\n-\n-                }\n-            }\n-        });\n-        this.isStruct = memoryLayout instanceof StructLayout;\n-\n-        \/\/ We know everything but the order ;)\n-        \/\/ We can get the order from the layout\n-        if (memoryLayout instanceof GroupLayout groupLayout) {\n-            if (groupLayout.memberLayouts().size() == 0) {\n-                throw new IllegalStateException(\"How\");\n-            }\n-            StreamCounter.of(groupLayout.memberLayouts().stream().filter(layout -> !(layout instanceof PaddingLayout)), (c, layout) -> {\n-                Optional<String> optionalLayoutFieldName = layout.name();\n-                if (optionalLayoutFieldName.isEmpty()) {\n-                    throw new IllegalStateException(\"how 2\");\n-                }\n-                String layoutFieldName = optionalLayoutFieldName.orElseThrow();\n-                if (nameToFieldNameAndType.containsKey(layoutFieldName)) {\n-                    var nameAndType = nameToFieldNameAndType.get(layoutFieldName);\n-                    nameAndType.index = c.value();\n-                    nameAndType.layout = layout;\n-                    nameAndTypes.add(nameAndType);\n-                    if (layout instanceof SequenceLayout sequenceLayout) {\n-                        if (nameAndType instanceof Typedef.NameAndArrayOfType nameAndArrayOfType) {\n-                            nameAndArrayOfType.arraySize = sequenceLayout.elementCount();\n-                        } else {\n-                            throw new IllegalStateException(\"not an array type?\");\n-                        }\n-                    }\n-                } else {\n-                    throw new IllegalStateException(\"Hmm \" + layoutFieldName);\n-                }\n-            });\n-        } else {\n-            throw new IllegalStateException(\"a buffer is alwyas a grouplayout!\");\n-        }\n-        nameAndTypes.sort((lhs, rhs) -> Integer.compare(lhs.index, rhs.index));\n-\n-        if (isIncomplete()) {\n-            \/\/ Above we captured the actual size of all arrays.  Of course only now do we know which of the fields is last\n-            \/\/ So if we are an incomplete type (i.e. last array is [0]) then tag the last element as flexible\n-            if (nameAndTypes.getLast() instanceof Typedef.NameAndArrayOfType nameAndArrayOfType) {\n-                nameAndArrayOfType.isFlexible = true;\n-                nameAndArrayOfType.arraySize = 0;\n-            } else {\n-                throw new IllegalStateException(\"last element is not sequence layout!\");\n-            }\n-        }\n-\n-        nameAndTypes.forEach(nameAndType -> {\n-            if (nameAndType.type.isInterface()) {\n-                if (nameAndType.layout instanceof GroupLayout gl) {\n-                    nameAndType.typeDef = new Typedef(nameAndType.type, gl, boundSchema, ifaceTypeNode);\n-                } else if (nameAndType.layout instanceof SequenceLayout sl && sl.elementLayout() instanceof GroupLayout slgl) {\n-                    nameAndType.typeDef = new Typedef(nameAndType.type, slgl, boundSchema, ifaceTypeNode);\n-                }\n-            }\n-        });\n-\n-\n-    }\n-\n-    private Typedef(Buffer instance, Schema.BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n-        this(instance.getClass().getInterfaces()[0], Buffer.getLayout(instance), boundSchema, ifaceTypeNode);\n-    }\n-\n-    static <T extends Buffer> Typedef of(T instance) {\n-        Schema.BoundSchema<T> boundSchema = (Schema.BoundSchema<T>) Buffer.getBoundSchema(instance);\n-        return new Typedef(instance, boundSchema, boundSchema.schema.rootIfaceTypeNode);\n-    }\n-\n-    public boolean isIncomplete() {\n-        return isIncomplete;\n-    }\n-\n-}\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/Typedef.java","additions":0,"deletions":210,"binary":false,"changes":210,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ifacemapper.BoundSchema;\n@@ -29,1 +30,0 @@\n-import hat.ifacemapper.Schema;\n@@ -56,1 +56,1 @@\n-    static <T extends Buffer> Schema.BoundSchema getBoundSchema(T buffer) {\n+    static <T extends Buffer> BoundSchema getBoundSchema(T buffer) {\n@@ -58,1 +58,1 @@\n-            return (Schema.BoundSchema<?>) buffer.getClass().getDeclaredMethod(SECRET_BOUND_SCHEMA_METHOD_NAME).invoke(buffer);\n+            return (BoundSchema<?>) buffer.getClass().getDeclaredMethod(SECRET_BOUND_SCHEMA_METHOD_NAME).invoke(buffer);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-import hat.ifacemapper.Schema;\n+import hat.ifacemapper.BoundSchema;\n@@ -6,3 +6,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.invoke.MethodHandles;\n-\n@@ -11,1 +8,1 @@\n-    <T extends Buffer>T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> buffer);\n+    <T extends Buffer>T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> buffer);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/BufferAllocator.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import hat.ifacemapper.accessor.ValueType;\n-import hat.ifacemapper.accessor.AccessorInfo;\n@@ -36,2 +34,0 @@\n-import java.lang.reflect.Method;\n-import java.util.List;\n@@ -49,1 +45,1 @@\n-    private final Schema.BoundSchema<?> boundSchema;\n+    private final BoundSchema<?> boundSchema;\n@@ -58,1 +54,1 @@\n-                                    Schema.BoundSchema<?> boundSchema,\n+                                    BoundSchema<?> boundSchema,\n@@ -91,1 +87,1 @@\n-    public final Schema.BoundSchema boundSchema() {\n+    public final BoundSchema<?> boundSchema() {\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/AbstractSegmentMapper.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,16 @@\n+package hat.ifacemapper;\n+\n+import hat.buffer.Buffer;\n+import hat.buffer.BufferAllocator;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+\n+public sealed interface BoundSchema<T extends Buffer> permits BoundSchemaNode.BoundSchemaRootNode{\n+\n+    T allocate(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator);\n+\n+    Schema<T> schema();\n+\n+    List<BoundSchemaNode.BoundArrayFieldLayout> boundArrayFields();\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/BoundSchema.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+package hat.ifacemapper;\n+\n+import hat.buffer.Buffer;\n+import hat.buffer.BufferAllocator;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public abstract sealed class BoundSchemaNode permits  BoundSchemaNode.BoundSchemaChildNode, BoundSchemaNode.BoundSchemaRootNode {\n+\n+    static sealed class FieldLayout<T extends Schema.SchemaNode.FieldNode> permits ArrayFieldLayout {\n+        public final T field;\n+        public MemoryLayout layout;\n+        FieldLayout(T field, MemoryLayout layout) {\n+            this.field = field;\n+            this.layout = layout;\n+        }\n+    }\n+    public sealed static class ArrayFieldLayout extends FieldLayout<Schema.SchemaNode.FieldNode> permits BoundArrayFieldLayout {\n+        public final int len;\n+        ArrayFieldLayout(Schema.SchemaNode.FieldNode fieldControlledArray, MemoryLayout layout, int len) {\n+            super(fieldControlledArray, layout);\n+            this.len = len;\n+        }\n+    }\n+    public static final class BoundArrayFieldLayout extends ArrayFieldLayout {\n+        public final int idx;\n+        BoundArrayFieldLayout(Schema.SchemaNode.FieldNode fieldControlledArray, MemoryLayout layout, int len, int idx) {\n+            super(fieldControlledArray, layout, len);\n+            this.idx = idx;\n+        }\n+    }\n+\n+    final protected BoundSchemaNode parent;\n+    final List<BoundSchemaChildNode> children = new ArrayList<>();\n+    final List<MemoryLayout> memoryLayouts = new ArrayList<>();\n+    final List<FieldLayout<?>> fieldLayouts = new ArrayList<>();\n+    final Schema.SchemaNode.IfaceTypeNode ifaceTypeNode;\n+\n+    BoundSchemaNode(BoundSchemaNode parent, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n+        this.parent = parent;\n+        this.ifaceTypeNode = ifaceTypeNode;\n+    }\n+\n+    abstract int takeArrayLen();\n+\n+    abstract FieldLayout<?> createFieldBinding(Schema.SchemaNode.FieldNode namedFieldNode, MemoryLayout memoryLayout);\n+\n+    void bind(Schema.SchemaNode.FieldNode fieldNode, MemoryLayout memoryLayout) {\n+        fieldLayouts.add(createFieldBinding(fieldNode, memoryLayout));\n+        memoryLayouts.add(memoryLayout);\n+    }\n+\n+    public MemoryLayout[] memoryLayoutListToArray() {\n+        return memoryLayouts.toArray(new MemoryLayout[0]);\n+    }\n+\n+    public BoundSchemaChildNode createChild(Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n+        var boundSchemaChildNode = new BoundSchemaChildNode(this, ifaceTypeNode);\n+        children.add(boundSchemaChildNode);\n+        return boundSchemaChildNode;\n+    }\n+\n+    public static final class BoundSchemaRootNode<T extends Buffer> extends BoundSchemaNode implements BoundSchema<T> {\n+        final private List<BoundArrayFieldLayout> boundArrayFields;\n+        final private int[] arrayLengths;\n+        final private Schema<T> schema;\n+        final private GroupLayout groupLayout;\n+\n+        public BoundSchemaRootNode(Schema<T> schema, int... arrayLengths) {\n+            super(null, schema.rootIfaceTypeNode);\n+            this.schema = schema;\n+            this.arrayLengths = arrayLengths;\n+            this.boundArrayFields = new ArrayList<>();\n+            BoundSchemaNode scope = createChild(schema.rootIfaceTypeNode);\n+            schema.rootIfaceTypeNode.fields.forEach(c ->\n+                    c.collectLayouts(scope)\n+            );\n+            this.groupLayout = MemoryLayout.structLayout(scope.memoryLayoutListToArray()).withName(schema.iface.getSimpleName());\n+            memoryLayouts.add(this.groupLayout);\n+        }\n+        @Override\n+        public T allocate(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator) {\n+            return bufferAllocator.allocate(SegmentMapper.of(lookup, schema.iface, groupLayout, this), this);\n+        }\n+\n+        @Override\n+        public Schema<T> schema(){\n+            return schema;\n+        }\n+\n+        @Override\n+        public List<BoundArrayFieldLayout> boundArrayFields() {\n+            return boundArrayFields;\n+        }\n+\n+        @Override\n+        int takeArrayLen() {\n+            return arrayLengths[boundArrayFields.size()];\n+        }\n+\n+        @Override\n+        FieldLayout<?> createFieldBinding(Schema.SchemaNode.FieldNode fieldNode, MemoryLayout memoryLayout) {\n+            if (fieldNode instanceof Schema.SchemaNode.IfaceMapableFieldControlledArray\n+                    || fieldNode instanceof Schema.SchemaNode.PrimitiveFieldControlledArray) {\n+                int idx = boundArrayFields.size();\n+                var arraySizeBinding = new BoundArrayFieldLayout(fieldNode, memoryLayout, arrayLengths[idx], idx);\n+                boundArrayFields.add(arraySizeBinding);\n+                return arraySizeBinding;\n+            }else  if (fieldNode instanceof Schema.SchemaNode.IfaceMapableFixedArray ifaceMapableFixedArray){\n+                return new ArrayFieldLayout(fieldNode, memoryLayout,  ifaceMapableFixedArray.len);\n+            }else  if (fieldNode instanceof Schema.SchemaNode.PrimitiveFixedArray primitiveFixedArray){\n+                return new ArrayFieldLayout(fieldNode, memoryLayout, primitiveFixedArray.len);\n+            }else{\n+                return new FieldLayout<>(fieldNode,memoryLayout);\n+            }\n+        }\n+    }\n+\n+    public static final class BoundSchemaChildNode extends BoundSchemaNode {\n+        BoundSchemaChildNode(BoundSchemaNode parent, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n+            super(parent, ifaceTypeNode);\n+        }\n+        @Override\n+        int takeArrayLen() {\n+            return parent.takeArrayLen();\n+        }\n+\n+        @Override\n+        FieldLayout<?> createFieldBinding(Schema.SchemaNode.FieldNode namedFieldNode, MemoryLayout memoryLayout) {\n+            return parent.createFieldBinding(namedFieldNode, memoryLayout);\n+        }\n+    }\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/BoundSchemaNode.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -88,1 +88,1 @@\n-    private static final ClassDesc BOUND_SCHEMA_CLASS_DESC = desc(Schema.BoundSchema.class);\n+    private static final ClassDesc BOUND_SCHEMA_CLASS_DESC = desc(BoundSchema.class);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/ByteCodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                        method.getReturnType() == Schema.BoundSchema.class && method.getName().equals(\"boundSchema\") ||\n+                        method.getReturnType() == BoundSchema.class && method.getName().equals(\"boundSchema\") ||\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/MapperUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,0 @@\n-import java.lang.foreign.GroupLayout;\n@@ -24,113 +23,0 @@\n-    public static abstract sealed class LayoutToBoundFieldTreeNode permits ChildLayoutToBoundFieldTreeNode, BoundSchema {\n-        static class FieldToLayoutBinding<T extends SchemaNode.FieldNode> {\n-            public final T field;\n-            public MemoryLayout layout;\n-            FieldToLayoutBinding(T field, MemoryLayout layout) {\n-                this.field = field;\n-                this.layout = layout;\n-            }\n-        }\n-\n-       public  static class FieldControlledArrayBinding extends FieldToLayoutBinding<SchemaNode.FieldNode> {\n-            public final int idx;\n-            public final int len;\n-            FieldControlledArrayBinding(int idx, int len, SchemaNode.FieldNode fieldControlledArray) {\n-                super(fieldControlledArray, null);\n-                this.idx = idx;\n-                this.len = len;\n-            }\n-        }\n-\n-        final protected LayoutToBoundFieldTreeNode parent;\n-        final List<ChildLayoutToBoundFieldTreeNode> children = new ArrayList<>();\n-        final List<MemoryLayout> memoryLayouts = new ArrayList<>();\n-        final List<FieldToLayoutBinding<?>> fieldToLayoutBindings = new ArrayList<>();\n-\n-        LayoutToBoundFieldTreeNode(LayoutToBoundFieldTreeNode parent) {\n-            this.parent = parent;\n-        }\n-\n-        abstract int takeArrayLen();\n-\n-        abstract FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.NamedFieldNode fieldControlledArray, MemoryLayout memoryLayout);\n-\n-        void bind(SchemaNode.FieldNode field, MemoryLayout memoryLayout) {\n-            FieldToLayoutBinding<?> fieldToLayoutBinding = null;\n-            if (field instanceof SchemaNode.IfaceMapableFieldControlledArray fieldControlledArray) {\n-                fieldToLayoutBinding = createFieldControlledArrayBinding(fieldControlledArray, memoryLayout);\n-            }else if (field instanceof SchemaNode.PrimitiveFieldControlledArray fieldControlledArray) {\n-                fieldToLayoutBinding = createFieldControlledArrayBinding(fieldControlledArray, memoryLayout);\n-            } else {\n-                fieldToLayoutBinding = new FieldToLayoutBinding<>(field, memoryLayout);\n-            }\n-            fieldToLayoutBindings.add(fieldToLayoutBinding);\n-            memoryLayouts.add(memoryLayout);\n-        }\n-\n-        public MemoryLayout[] memoryLayoutListToArray() {\n-            return memoryLayouts.toArray(new MemoryLayout[0]);\n-        }\n-\n-        public ChildLayoutToBoundFieldTreeNode createChild() {\n-            var childLayoutCollector = new ChildLayoutToBoundFieldTreeNode(this);\n-            children.add(childLayoutCollector);\n-            return childLayoutCollector;\n-        }\n-\n-\n-    }\n-\n-    public static final class BoundSchema<T extends Buffer> extends LayoutToBoundFieldTreeNode {\n-        final public List<FieldControlledArrayBinding> arraySizeBindings;\n-        final public int[] arrayLengths;\n-        final public Schema<T> schema;\n-        final public GroupLayout groupLayout;\n-\n-        public BoundSchema(Schema<T> schema, int... arrayLengths) {\n-            super(null);\n-            this.schema = schema;\n-            this.arrayLengths = arrayLengths;\n-            this.arraySizeBindings = new ArrayList<>();\n-            LayoutToBoundFieldTreeNode scope = createChild();\n-            schema.rootIfaceTypeNode.fields.forEach(c ->\n-                    c.collectLayouts(scope)\n-            );\n-            this.groupLayout = MemoryLayout.structLayout(scope.memoryLayoutListToArray()).withName(schema.iface.getSimpleName());\n-            memoryLayouts.add(this.groupLayout);\n-        }\n-\n-        public T allocate(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator) {\n-            return bufferAllocator.allocate(SegmentMapper.of(lookup, schema.iface,groupLayout, this),this);\n-        }\n-\n-        @Override\n-        int takeArrayLen() {\n-            return arrayLengths[arraySizeBindings.size()];\n-        }\n-\n-        @Override\n-        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.NamedFieldNode fieldControlledArray, MemoryLayout memoryLayout) {\n-            int idx = arraySizeBindings.size();\n-            var arraySizeBinding = new FieldControlledArrayBinding(idx, arrayLengths[idx], fieldControlledArray);\n-            arraySizeBindings.add(arraySizeBinding);\n-            return arraySizeBinding;\n-        }\n-\n-\n-    }\n-\n-    public static final class ChildLayoutToBoundFieldTreeNode extends LayoutToBoundFieldTreeNode {\n-        ChildLayoutToBoundFieldTreeNode(LayoutToBoundFieldTreeNode parent) {\n-            super(parent);\n-        }\n-\n-        @Override\n-        int takeArrayLen() {\n-            return parent.takeArrayLen();\n-        }\n-@Override\n-        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.NamedFieldNode fieldControlledArray, MemoryLayout memoryLayout) {\n-            return parent.createFieldControlledArrayBinding(fieldControlledArray, memoryLayout);\n-        }\n-    }\n-\n@@ -194,1 +80,1 @@\n-    public static abstract class SchemaNode {\n+    public static abstract sealed class SchemaNode permits SchemaNode.FieldNode, SchemaNode.IfaceTypeNode {\n@@ -208,1 +94,1 @@\n-            public abstract void collectLayouts(LayoutToBoundFieldTreeNode layoutCollector);\n+            public abstract void collectLayouts(BoundSchemaNode layoutCollector);\n@@ -225,1 +111,1 @@\n-            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+            public void collectLayouts(BoundSchemaNode layoutToFieldBindingNode) {\n@@ -248,2 +134,2 @@\n-            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, parent.getLayout(this.type, layoutToFieldBindingNode).withName(name));\n+            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n+                boundSchemaNode.bind(this, parent.getLayout(this.type, boundSchemaNode).withName(name));\n@@ -257,1 +143,1 @@\n-                this.ifaceTypeNode = parent.types.stream().filter(n->n.iface.isAssignableFrom(iface)).findFirst().orElseThrow();\n+                this.ifaceTypeNode = parent.ifaceTypeNodes.stream().filter(n->n.iface.isAssignableFrom(iface)).findFirst().orElseThrow();\n@@ -260,2 +146,2 @@\n-            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, parent.getLayout(this.ifaceTypeNode.iface, layoutToFieldBindingNode).withName(name));\n+            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n+                boundSchemaNode.bind(this, parent.getLayout(this.ifaceTypeNode.iface, boundSchemaNode).withName(name));\n@@ -278,2 +164,2 @@\n-            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, parent.getLayout(type, layoutToFieldBindingNode).withName(name));\n+            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n+                boundSchemaNode.bind(this, parent.getLayout(type, boundSchemaNode).withName(name));\n@@ -334,2 +220,2 @@\n-            public List<IfaceTypeNode> types = new ArrayList<>();\n-            public Class<?> iface;\n+            public List<IfaceTypeNode> ifaceTypeNodes = new ArrayList<>();\n+            public Class<MappableIface> iface;\n@@ -342,2 +228,2 @@\n-            <T extends IfaceTypeNode> T addType(T child) {\n-                types.add(child);\n+            <T extends IfaceTypeNode> T addIfaceTypeNode(T child) {\n+                ifaceTypeNodes.add(child);\n@@ -347,1 +233,1 @@\n-            IfaceTypeNode(IfaceTypeNode parent, Class<?> iface) {\n+            IfaceTypeNode(IfaceTypeNode parent, Class<MappableIface> iface) {\n@@ -353,1 +239,1 @@\n-                types.forEach(t->t.visitTypes(depth+1,ifaceTypeNodeConsumer));\n+                ifaceTypeNodes.forEach(t->t.visitTypes(depth+1,ifaceTypeNodeConsumer));\n@@ -364,1 +250,1 @@\n-             * @param layoutToFieldBindingNode\n+             * @param boundSchemaNode\n@@ -367,1 +253,1 @@\n-            MemoryLayout getLayout(Class<?> type, LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+            MemoryLayout getLayout(Class<?> type, BoundSchemaNode boundSchemaNode) {\n@@ -373,7 +259,5 @@\n-                    Optional<IfaceTypeNode> optionalTypeSchemaKeyMatchingType = types.stream()\n-                            .filter(ifaceTypeNode -> ifaceTypeNode.iface.equals(type))\n-                            .findFirst();\n-                    if (optionalTypeSchemaKeyMatchingType.isPresent()) {\n-                        var typeSchemaKeyMatchingType = optionalTypeSchemaKeyMatchingType.get();\n-                        LayoutToBoundFieldTreeNode scope = layoutToFieldBindingNode.createChild();\n-                        typeSchemaKeyMatchingType.fields.forEach(fieldNode ->\n+                    IfaceTypeNode ifaceTypeNode = ifaceTypeNodes.stream()\n+                            .filter(i -> i.iface.equals(type))\n+                            .findFirst().orElseThrow();\n+                        BoundSchemaNode scope = boundSchemaNode.createChild(ifaceTypeNode);\n+                        ifaceTypeNode.fields.forEach(fieldNode ->\n@@ -382,1 +266,1 @@\n-                        return isUnion(typeSchemaKeyMatchingType.iface)\n+                        return isUnion(ifaceTypeNode.iface)\n@@ -385,3 +269,0 @@\n-                    }else{\n-                        throw new IllegalStateException(\"Why no type\");\n-                    }\n@@ -392,1 +273,1 @@\n-                parentSchemaNodeConsumer.accept(addType(new Struct(this, typeOf(iface, name))));\n+                parentSchemaNodeConsumer.accept(addIfaceTypeNode(new Struct(this, (Class<MappableIface>)typeOf(iface, name))));\n@@ -397,1 +278,1 @@\n-                parentSchemaNodeConsumer.accept(addType(new Union(this, typeOf(iface, name))));\n+                parentSchemaNodeConsumer.accept(addIfaceTypeNode(new Union(this, (Class<MappableIface>) typeOf(iface, name))));\n@@ -426,1 +307,1 @@\n-                addType(structOrUnion);\n+                addIfaceTypeNode(structOrUnion);\n@@ -446,1 +327,1 @@\n-                addType(ifaceTypeNode);\n+                addIfaceTypeNode(ifaceTypeNode);\n@@ -476,1 +357,1 @@\n-                addType(ifaceTypeNode);\n+                addIfaceTypeNode(ifaceTypeNode);\n@@ -510,1 +391,1 @@\n-                    Class<?> arrayType = typeOf(this.ifaceTypeNode.iface, name);\n+                    Class<MappableIface> arrayType = (Class<MappableIface>) typeOf(this.ifaceTypeNode.iface, name);\n@@ -515,1 +396,1 @@\n-                    this.ifaceTypeNode.addType(ifaceTypeNode);\n+                    this.ifaceTypeNode.addIfaceTypeNode(ifaceTypeNode);\n@@ -550,1 +431,1 @@\n-                types.forEach(c -> {\n+                ifaceTypeNodes.forEach(c -> {\n@@ -565,1 +446,1 @@\n-            Struct(IfaceTypeNode parent, Class<?> type) {\n+            Struct(IfaceTypeNode parent, Class<MappableIface> type) {\n@@ -571,1 +452,1 @@\n-            Union(IfaceTypeNode parent, Class<?> type) {\n+            Union(IfaceTypeNode parent, Class<MappableIface> type) {\n@@ -599,3 +480,3 @@\n-            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(len,\n-                        parent.getLayout(ifaceTypeNode.iface, layoutToFieldBindingNode).withName(ifaceTypeNode.iface.getSimpleName())\n+            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n+                boundSchemaNode.bind(this, MemoryLayout.sequenceLayout(len,\n+                        parent.getLayout(ifaceTypeNode.iface, boundSchemaNode).withName(ifaceTypeNode.iface.getSimpleName())\n@@ -619,3 +500,3 @@\n-            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(len,\n-                        parent.getLayout(type, layoutToFieldBindingNode).withName(type.getSimpleName())\n+            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n+                boundSchemaNode.bind(this, MemoryLayout.sequenceLayout(len,\n+                        parent.getLayout(type, boundSchemaNode).withName(type.getSimpleName())\n@@ -644,1 +525,1 @@\n-            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n@@ -648,1 +529,1 @@\n-                    size *= layoutToFieldBindingNode.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n+                    size *= boundSchemaNode.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n@@ -651,2 +532,2 @@\n-                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(size,\n-                        parent.getLayout(ifaceTypeNode.iface, layoutToFieldBindingNode).withName(ifaceTypeNode.iface.getSimpleName())\n+                boundSchemaNode.bind(this, MemoryLayout.sequenceLayout(size,\n+                        parent.getLayout(ifaceTypeNode.iface, boundSchemaNode).withName(ifaceTypeNode.iface.getSimpleName())\n@@ -674,1 +555,1 @@\n-            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n@@ -678,1 +559,1 @@\n-                    size *= layoutToFieldBindingNode.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n+                    size *= boundSchemaNode.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n@@ -681,2 +562,2 @@\n-                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(size,\n-                        parent.getLayout(type, layoutToFieldBindingNode).withName(type.getSimpleName())\n+                boundSchemaNode.bind(this, MemoryLayout.sequenceLayout(size,\n+                        parent.getLayout(type, boundSchemaNode).withName(type.getSimpleName())\n@@ -696,1 +577,1 @@\n-        BoundSchema<?> boundSchema = new BoundSchema<>(this, boundLengths);\n+        BoundSchema<?> boundSchema = new BoundSchemaNode.BoundSchemaRootNode<>(this, boundLengths);\n@@ -701,1 +582,1 @@\n-        var struct = new SchemaNode.Struct(null, iface);\n+        var struct = new SchemaNode.Struct(null, (Class<MappableIface>)(Object)iface); \/\/ why the need for this?\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":50,"deletions":169,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-                                   Schema.BoundSchema<?> boundSchema,\n+                                   BoundSchema<?> boundSchema,\n@@ -160,1 +160,1 @@\n-            var ctor = lookup().findConstructor(implClass, MethodType.methodType(void.class, MemorySegment.class, GroupLayout.class, Schema.BoundSchema.class,\n+            var ctor = lookup().findConstructor(implClass, MethodType.methodType(void.class, MemorySegment.class, GroupLayout.class, BoundSchema.class,\n@@ -424,1 +424,1 @@\n-                                                       Schema.BoundSchema<?> boundSchema) {\n+                                                       BoundSchema<?> boundSchema) {\n@@ -445,1 +445,1 @@\n-            @Override Schema.BoundSchema<?> boundSchema,\n+            @Override BoundSchema<?> boundSchema,\n@@ -464,1 +464,1 @@\n-               Schema.BoundSchema<?> boundSchema,\n+               BoundSchema<?> boundSchema,\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentInterfaceMapper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-    Schema.BoundSchema<?> boundSchema();\n+    BoundSchema<?> boundSchema();\n@@ -322,1 +322,1 @@\n-    default T allocate(Arena arena, Schema.BoundSchema<?> boundSchema) {\n+    default T allocate(Arena arena, BoundSchema<?> boundSchema) {\n@@ -367,1 +367,1 @@\n-    default T get(MemorySegment segment, GroupLayout groupLayout, Schema.BoundSchema<?> boundSchema) {\n+    default T get(MemorySegment segment, GroupLayout groupLayout, BoundSchema<?> boundSchema) {\n@@ -431,1 +431,1 @@\n-    default T get(MemorySegment segment, GroupLayout layout, Schema.BoundSchema<?> boundSchema, long offset) {\n+    default T get(MemorySegment segment, GroupLayout layout, BoundSchema<?> boundSchema, long offset) {\n@@ -684,1 +684,1 @@\n-    static <T extends Buffer> SegmentMapper<T> of(MethodHandles.Lookup lookup, Class<T> type, GroupLayout layout, Schema.BoundSchema<?> boundSchema) {\n+    static <T extends Buffer> SegmentMapper<T> of(MethodHandles.Lookup lookup, Class<T> type, GroupLayout layout, BoundSchema<?> boundSchema) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}