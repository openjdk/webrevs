{"files":[{"patch":"@@ -209,1 +209,1 @@\n-public void compute(Compute compute) {\n+    public void compute(Compute compute) {\n@@ -212,2 +212,2 @@\n-    Method method = OpTk.methodOrThrow(lookup,OpTk.getQuotableTargetInvokeOpWrapper(lambda));\n-    \/\/ Create (or get cached) a compute context which closes over compute entryppint and reachable kernels.\n+    Method method = getTargetInvoke(this.lookup,lambda, ComputeContext.class).resolveMethodOrThrow();\n+    \/\/ Create (or get cached) a compute context which closes over compute entrypoint and reachable kernels.\n@@ -219,1 +219,1 @@\n-    Object[] args = OpTk.getQuotableCapturedValues(lambda, quoted, method);\n+    Object[] args = lambda(lookup,lambda).getQuotedCapturedValues( quoted, method);\n","filename":"hat\/docs\/hat-05-accelerator-compute.md","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,12 +49,0 @@\n-        @Reflect\n-        interface QuotableIntUnaryOperator extends IntUnaryOperator {\n-        }\n-\n-        @Reflect\n-        interface QuotableFunction<T, R> extends Function<T, R> {\n-        }\n-\n-        @Reflect\n-        interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R> {\n-        }\n-\n@@ -71,1 +59,2 @@\n-            QuotableIntUnaryOperator f1 = TestLambdaMethodRef::m1;\n+            @Reflect\n+            IntUnaryOperator f1 = TestLambdaMethodRef::m1;\n@@ -84,1 +73,2 @@\n-            QuotableIntUnaryOperator f2 = TestLambdaMethodRef::m2;\n+            @Reflect\n+            IntUnaryOperator f2 = TestLambdaMethodRef::m2;\n@@ -97,1 +87,2 @@\n-            QuotableFunction<Integer, Integer> f3 = TestLambdaMethodRef::m1;\n+            @Reflect\n+            Function<Integer, Integer> f3 = TestLambdaMethodRef::m1;\n@@ -108,1 +99,2 @@\n-            QuotableFunction<Integer, Integer> f4 = TestLambdaMethodRef::m2;\n+            @Reflect\n+            Function<Integer, Integer> f4 = TestLambdaMethodRef::m2;\n@@ -119,1 +111,2 @@\n-            QuotableIntUnaryOperator f5 = this::m3;\n+            @Reflect\n+            IntUnaryOperator f5 = this::m3;\n@@ -134,1 +127,2 @@\n-            QuotableBiFunction<TestLambdaMethodRef, Integer, Integer> f6 = TestLambdaMethodRef::m4;\n+            @Reflect\n+            BiFunction<TestLambdaMethodRef, Integer, Integer> f6 = TestLambdaMethodRef::m4;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/TestQuoted.java","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -943,1 +943,1 @@\n-                            if (op.isQuotable()) {\n+                            if (op.isReflectable()) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-            final boolean isQuotable;\n+            final boolean isReflectable;\n@@ -174,1 +174,1 @@\n-                this.isQuotable = false;\n+                this.isReflectable = false;\n@@ -178,1 +178,1 @@\n-                    boolean isQuotable) {\n+                    boolean isReflectable) {\n@@ -182,1 +182,1 @@\n-                this.isQuotable = isQuotable;\n+                this.isReflectable = isReflectable;\n@@ -188,1 +188,1 @@\n-                return new LambdaOp(functionalInterface, body, isQuotable);\n+                return new LambdaOp(functionalInterface, body, isReflectable);\n@@ -197,1 +197,1 @@\n-        static final String ATTRIBUTE_LAMBDA_IS_QUOTABLE = NAME + \".isQuotable\";\n+        static final String ATTRIBUTE_LAMBDA_IS_REFLECTABLE = NAME + \".isReflectable\";\n@@ -201,1 +201,1 @@\n-        final boolean isQuotable;\n+        final boolean isReflectable;\n@@ -204,1 +204,1 @@\n-            boolean isQuotable = def.extractAttributeValue(ATTRIBUTE_LAMBDA_IS_QUOTABLE,\n+            boolean isReflectable = def.extractAttributeValue(ATTRIBUTE_LAMBDA_IS_REFLECTABLE,\n@@ -210,1 +210,1 @@\n-            this(def.resultType(), def.bodyDefinitions().get(0), isQuotable);\n+            this(def.resultType(), def.bodyDefinitions().get(0), isReflectable);\n@@ -218,1 +218,1 @@\n-            this.isQuotable = that.isQuotable;\n+            this.isReflectable = that.isReflectable;\n@@ -226,1 +226,1 @@\n-        LambdaOp(TypeElement functionalInterface, Body.Builder bodyC, boolean isQuotable) {\n+        LambdaOp(TypeElement functionalInterface, Body.Builder bodyC, boolean isReflectable) {\n@@ -231,1 +231,1 @@\n-            this.isQuotable = isQuotable;\n+            this.isReflectable = isReflectable;\n@@ -265,2 +265,2 @@\n-        public boolean isQuotable() {\n-            return isQuotable;\n+        public boolean isReflectable() {\n+            return isReflectable;\n@@ -271,1 +271,1 @@\n-            return Map.of(ATTRIBUTE_LAMBDA_IS_QUOTABLE, isQuotable);\n+            return Map.of(ATTRIBUTE_LAMBDA_IS_REFLECTABLE, isReflectable);\n@@ -5138,1 +5138,1 @@\n-     * @param isQuotable          true if the lambda is quotable\n+     * @param isReflectable       true if the lambda is reflectable\n@@ -5141,2 +5141,2 @@\n-    public static LambdaOp lambda(TypeElement functionalInterface, Body.Builder body, boolean isQuotable) {\n-        return new LambdaOp(functionalInterface, body, isQuotable);\n+    public static LambdaOp lambda(TypeElement functionalInterface, Body.Builder body, boolean isReflectable) {\n+        return new LambdaOp(functionalInterface, body, isReflectable);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-import static com.sun.tools.javac.code.TypeTag.ARRAY;\n@@ -468,1 +467,1 @@\n-        private final boolean isQuoted;\n+        private final boolean isLambdaReflectable;\n@@ -474,1 +473,1 @@\n-            this.isQuoted = false;\n+            this.isLambdaReflectable = false;\n@@ -507,1 +506,1 @@\n-            this.isQuoted = true;\n+            this.isLambdaReflectable = true;\n@@ -509,2 +508,2 @@\n-            QuotableLambdaCaptureScanner lambdaCaptureScanner =\n-                    new QuotableLambdaCaptureScanner(tree);\n+            ReflectableLambdaCaptureScanner lambdaCaptureScanner =\n+                    new ReflectableLambdaCaptureScanner(tree);\n@@ -552,1 +551,1 @@\n-         * Compute the set of local variables captured by a quotable lambda expression.\n+         * Compute the set of local variables captured by a reflectable lambda expression.\n@@ -555,1 +554,1 @@\n-        class QuotableLambdaCaptureScanner extends CaptureScanner {\n+        class ReflectableLambdaCaptureScanner extends CaptureScanner {\n@@ -560,1 +559,1 @@\n-            QuotableLambdaCaptureScanner(JCLambda ownerTree) {\n+            ReflectableLambdaCaptureScanner(JCLambda ownerTree) {\n@@ -1035,1 +1034,1 @@\n-                        Assert.check(isQuoted);\n+                        Assert.check(isLambdaReflectable);\n@@ -1474,3 +1473,3 @@\n-            \/\/ a quotable lambda is going to have its model wrapped in QuotedOp\n-            \/\/ only when we are producing the model of the lambda, thus the condition (isQuoted ...)\n-            \/\/ also, a lambda contained in a quotable lambda, will not have its model wrapped in QuotedOp,\n+            \/\/ a reflectable lambda is going to have its model wrapped in QuotedOp\n+            \/\/ only when we are producing the model of the lambda, thus the condition (isReflectable ...)\n+            \/\/ also, a lambda contained in a reflectable lambda, will not have its model wrapped in QuotedOp,\n@@ -1478,2 +1477,1 @@\n-            \/\/ @@@ better name for isQuoted ?\n-            boolean toQuote = (isQuoted && this.tree == tree);\n+            boolean toQuote = (isLambdaReflectable && this.tree == tree);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-            if (lo.isQuotable()) {\n+            if (lo.isReflectable()) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,0 @@\n-import java.lang.constant.MethodHandleDesc;\n@@ -90,1 +89,1 @@\n-        DecodedName decodedName = findQuotableOpGetter(caller, interfaceMethodName);\n+        DecodedName decodedName = findReflectableOpGetter(caller, interfaceMethodName);\n@@ -227,1 +226,1 @@\n-        DecodedName decodedName = findQuotableOpGetter(caller, interfaceMethodName);\n+        DecodedName decodedName = findReflectableOpGetter(caller, interfaceMethodName);\n@@ -235,1 +234,1 @@\n-    private static DecodedName findQuotableOpGetter(MethodHandles.Lookup lookup, String interfaceMethodName) throws LambdaConversionException {\n+    private static DecodedName findReflectableOpGetter(MethodHandles.Lookup lookup, String interfaceMethodName) throws LambdaConversionException {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/runtime\/ReflectableLambdaMetafactory.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -152,3 +152,3 @@\n-    public void testQuotableModel() {\n-        Runnable quotable = (@Reflect Runnable) () -> {};\n-        Op qop = Op.ofLambda(quotable).get().op();\n+    public void testLambdaModel() {\n+        Runnable r = (@Reflect Runnable) () -> {};\n+        Op qop = Op.ofLambda(r).get().op();\n@@ -168,1 +168,1 @@\n-    public void testQuote() {\n+    public void testQuoted() {\n@@ -222,2 +222,2 @@\n-        IntUnaryOperator lambda = (@Reflect IntUnaryOperator) (d) -> {d += 2 * a + (b % 2) + (int) Math.exp(c); return d;};\n-        LambdaOp qop = (LambdaOp) Op.ofLambda(lambda).get().op();\n+        IntUnaryOperator f = (@Reflect IntUnaryOperator) (d) -> {d += 2 * a + (b % 2) + (int) Math.exp(c); return d;};\n+        LambdaOp qop = (LambdaOp) Op.ofLambda(f).get().op();\n@@ -226,1 +226,1 @@\n-        int lambdaRes = lambda.applyAsInt(1);\n+        int lambdaRes = f.applyAsInt(1);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n- * @run junit TestOpOfQuotable\n+ * @run junit TestOpOfLambda\n@@ -17,1 +17,1 @@\n-public class TestOpOfQuotable {\n+public class TestOpOfLambda {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOpOfLambda.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOpOfQuotable.java","status":"renamed"},{"patch":"@@ -378,1 +378,1 @@\n-    static int consumeQuotable(int i, IntUnaryOperator f) {\n+    static int consumeLambda(int i, IntUnaryOperator f) {\n@@ -386,2 +386,2 @@\n-    static int quotableLambda(int i) {\n-        return consumeQuotable(i, a -> -a);\n+    static int lambda(int i) {\n+        return consumeLambda(i, a -> -a);\n@@ -391,2 +391,2 @@\n-    static int quotableLambdaWithCapture(int i, String s) {\n-        return consumeQuotable(i, a -> a + s.length());\n+    static int lambdaWithCapture(int i, String s) {\n+        return consumeLambda(i, a -> a + s.length());\n@@ -396,2 +396,2 @@\n-    static int nestedQuotableLambdasWithCaptures(int i, int j, String s) {\n-        return consumeQuotable(i, a -> consumeQuotable(a, b -> a + b + j - s.length()) + s.length());\n+    static int nestedLambdasWithCaptures(int i, int j, String s) {\n+        return consumeLambda(i, a -> consumeLambda(a, b -> a + b + j - s.length()) + s.length());\n@@ -402,1 +402,1 @@\n-        return consumeQuotable(i, Math::negateExact);\n+        return consumeLambda(i, Math::negateExact);\n@@ -411,1 +411,1 @@\n-        return consumeQuotable(i, this::instanceMethod);\n+        return consumeLambda(i, this::instanceMethod);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-    static int consumeQuotable(int i, IntUnaryOperator f) {\n+    static int consumeLambda(int i, IntUnaryOperator f) {\n@@ -380,2 +380,2 @@\n-    static int quotableLambda(int i) {\n-        return consumeQuotable(i, a -> -a);\n+    static int lambda(int i) {\n+        return consumeLambda(i, a -> -a);\n@@ -385,2 +385,2 @@\n-    static int quotableLambdaWithCapture(int i, String s) {\n-        return consumeQuotable(i, a -> a + s.length());\n+    static int lambdaWithCapture(int i, String s) {\n+        return consumeLambda(i, a -> a + s.length());\n@@ -390,2 +390,2 @@\n-    static int nestedQuotableLambdasWithCaptures(int i, int j, String s) {\n-        return consumeQuotable(i, a -> consumeQuotable(a, b -> a + b + j - s.length()) + s.length());\n+    static int nestedLambdasWithCaptures(int i, int j, String s) {\n+        return consumeLambda(i, a -> consumeLambda(a, b -> a + b + j - s.length()) + s.length());\n@@ -396,1 +396,1 @@\n-        return consumeQuotable(i, Math::negateExact);\n+        return consumeLambda(i, Math::negateExact);\n@@ -405,1 +405,1 @@\n-        return consumeQuotable(i, this::instanceMethod);\n+        return consumeLambda(i, this::instanceMethod);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestBytecodeLift.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                    throw new IllegalArgumentException(\"Quotable operation captures values\");\n+                    throw new IllegalArgumentException(\"Reflectable lambda captures values\");\n@@ -188,1 +188,1 @@\n-                throw new IllegalArgumentException(\"Quotable consumer captures values\");\n+                throw new IllegalArgumentException(\"Reflectable consumer captures values\");\n@@ -215,1 +215,1 @@\n-                throw new IllegalArgumentException(\"Quotable supplier captures values\");\n+                throw new IllegalArgumentException(\"Reflectable supplier captures values\");\n@@ -221,1 +221,1 @@\n-                throw new IllegalArgumentException(\"Quotable accumulator captures values\");\n+                throw new IllegalArgumentException(\"Reflectable accumulator captures values\");\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isReflectable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/BlockTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Integer\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.Integer\" -> {\n@@ -284,1 +284,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Integer\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.Integer\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/BoxingConversionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                        %9 : java.type:\"java.util.function.Supplier<java.lang.Double>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Double\" -> {\n+                        %9 : java.type:\"java.util.function.Supplier<java.lang.Double>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.Double\" -> {\n@@ -115,1 +115,1 @@\n-                        %13 : java.type:\"java.util.function.Supplier<java.lang.Double>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Double\" -> {\n+                        %13 : java.type:\"java.util.function.Supplier<java.lang.Double>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.Double\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConditionalExpressionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-                        %5 : java.type:\"java.util.function.Predicate<java.lang.String>\" = lambda @lambda.isQuotable=true (%6 : java.type:\"java.lang.String\")java.type:\"boolean\" -> {\n+                        %5 : java.type:\"java.util.function.Predicate<java.lang.String>\" = lambda @lambda.isReflectable=true (%6 : java.type:\"java.lang.String\")java.type:\"boolean\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/ForLoopTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-                %1 : java.type:\"java.util.function.LongSupplier\" = lambda @lambda.isQuotable=true ()java.type:\"long\" -> {\n+                %1 : java.type:\"java.util.function.LongSupplier\" = lambda @lambda.isReflectable=true ()java.type:\"long\" -> {\n@@ -200,1 +200,1 @@\n-                %1 : java.type:\"java.util.function.LongSupplier\" = lambda @lambda.isQuotable=true ()java.type:\"long\" -> {\n+                %1 : java.type:\"java.util.function.LongSupplier\" = lambda @lambda.isReflectable=true ()java.type:\"long\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                %4 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %4 : java.type:\"java.lang.Runnable\" = lambda @lambda.isReflectable=true ()java.type:\"void\" -> {\n@@ -111,1 +111,1 @@\n-                %10 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %10 : java.type:\"java.lang.Runnable\" = lambda @lambda.isReflectable=true ()java.type:\"void\" -> {\n@@ -120,1 +120,1 @@\n-                %16 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %16 : java.type:\"java.lang.Runnable\" = lambda @lambda.isReflectable=true ()java.type:\"void\" -> {\n@@ -248,1 +248,1 @@\n-                %10 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %10 : java.type:\"java.lang.Runnable\" = lambda @lambda.isReflectable=true ()java.type:\"void\" -> {\n@@ -257,1 +257,1 @@\n-                %16 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %16 : java.type:\"java.lang.Runnable\" = lambda @lambda.isReflectable=true ()java.type:\"void\" -> {\n@@ -266,1 +266,1 @@\n-                %22 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %22 : java.type:\"java.lang.Runnable\" = lambda @lambda.isReflectable=true ()java.type:\"void\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/IntersectionTypeTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isReflectable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n@@ -66,1 +66,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.String\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.String\" -> {\n@@ -87,1 +87,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.String\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.String\" -> {\n@@ -104,1 +104,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.String\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.String\" -> {\n@@ -125,1 +125,1 @@\n-                %7 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Integer\" -> {\n+                %7 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.Integer\" -> {\n@@ -128,1 +128,1 @@\n-                    %10 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Integer\" -> {\n+                    %10 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.Integer\" -> {\n@@ -173,1 +173,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Integer\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.Integer\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/LambdaTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<LocalClassTest::Inner>\" = lambda @lambda.isQuotable=true ()java.type:\"LocalClassTest::Inner\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<LocalClassTest::Inner>\" = lambda @lambda.isReflectable=true ()java.type:\"LocalClassTest::Inner\" -> {\n@@ -209,1 +209,1 @@\n-                %3 : java.type:\"java.util.function.Supplier<LocalClassTest::Inner>\" = lambda @lambda.isQuotable=true ()java.type:\"LocalClassTest::Inner\" -> {\n+                %3 : java.type:\"java.util.function.Supplier<LocalClassTest::Inner>\" = lambda @lambda.isReflectable=true ()java.type:\"LocalClassTest::Inner\" -> {\n@@ -225,1 +225,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<LocalClassTest::$1L>\" = lambda @lambda.isQuotable=true ()java.type:\"LocalClassTest::$1L\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<LocalClassTest::$1L>\" = lambda @lambda.isReflectable=true ()java.type:\"LocalClassTest::$1L\" -> {\n@@ -241,1 +241,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.Object>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Object\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.Object>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.Object\" -> {\n@@ -261,1 +261,1 @@\n-                %3 : java.type:\"java.util.function.Supplier<LocalClassTest::$3L>\" = lambda @lambda.isQuotable=true ()java.type:\"LocalClassTest::$3L\" -> {\n+                %3 : java.type:\"java.util.function.Supplier<LocalClassTest::$3L>\" = lambda @lambda.isReflectable=true ()java.type:\"LocalClassTest::$3L\" -> {\n@@ -285,1 +285,1 @@\n-                %3 : java.type:\"java.util.function.Supplier<java.lang.Object>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Object\" -> {\n+                %3 : java.type:\"java.util.function.Supplier<java.lang.Object>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.Object\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalClassTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isReflectable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n@@ -64,1 +64,1 @@\n-                %1 : java.type:\"java.util.function.BiConsumer<MethodReferenceTest, java.lang.String>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"MethodReferenceTest\", %3 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.BiConsumer<MethodReferenceTest, java.lang.String>\" = lambda @lambda.isReflectable=true (%2 : java.type:\"MethodReferenceTest\", %3 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n@@ -83,1 +83,1 @@\n-                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isReflectable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n@@ -109,1 +109,1 @@\n-                %4 : java.type:\"java.util.function.Function<java.lang.String, java.lang.String>\" = lambda @lambda.isQuotable=true (%5 : java.type:\"java.lang.String\")java.type:\"java.lang.String\" -> {\n+                %4 : java.type:\"java.util.function.Function<java.lang.String, java.lang.String>\" = lambda @lambda.isReflectable=true (%5 : java.type:\"java.lang.String\")java.type:\"java.lang.String\" -> {\n@@ -129,1 +129,1 @@\n-                %3 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isQuotable=true (%4 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %3 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isReflectable=true (%4 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n@@ -151,1 +151,1 @@\n-                %1 : java.type:\"java.util.function.Function<java.lang.Integer, MethodReferenceTest$X>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"java.lang.Integer\")java.type:\"MethodReferenceTest$X\" -> {\n+                %1 : java.type:\"java.util.function.Function<java.lang.Integer, MethodReferenceTest$X>\" = lambda @lambda.isReflectable=true (%2 : java.type:\"java.lang.Integer\")java.type:\"MethodReferenceTest$X\" -> {\n@@ -169,1 +169,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<MethodReferenceTest::A<java.lang.String>>\" = lambda @lambda.isQuotable=true ()java.type:\"MethodReferenceTest::A<java.lang.String>\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<MethodReferenceTest::A<java.lang.String>>\" = lambda @lambda.isReflectable=true ()java.type:\"MethodReferenceTest::A<java.lang.String>\" -> {\n@@ -184,1 +184,1 @@\n-                %1 : java.type:\"java.util.function.IntFunction<MethodReferenceTest::A<java.lang.String>[]>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"MethodReferenceTest::A<java.lang.String>[]\" -> {\n+                %1 : java.type:\"java.util.function.IntFunction<MethodReferenceTest::A<java.lang.String>[]>\" = lambda @lambda.isReflectable=true (%2 : java.type:\"int\")java.type:\"MethodReferenceTest::A<java.lang.String>[]\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodReferenceTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.String\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isReflectable=true ()java.type:\"java.lang.String\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/NullTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-                %0 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Runnable\" = lambda @lambda.isReflectable=true ()java.type:\"void\" -> {\n@@ -53,1 +53,1 @@\n-                %0 : java.type:\"java.util.function.IntSupplier\" = lambda @lambda.isQuotable=true ()java.type:\"int\" -> {\n+                %0 : java.type:\"java.util.function.IntSupplier\" = lambda @lambda.isReflectable=true ()java.type:\"int\" -> {\n@@ -64,1 +64,1 @@\n-                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n+                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isReflectable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n@@ -76,1 +76,1 @@\n-                %0 : java.type:\"java.util.function.IntBinaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\", %2 : java.type:\"int\")java.type:\"int\" -> {\n+                %0 : java.type:\"java.util.function.IntBinaryOperator\" = lambda @lambda.isReflectable=true (%1 : java.type:\"int\", %2 : java.type:\"int\")java.type:\"int\" -> {\n@@ -91,1 +91,1 @@\n-                %0 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Runnable\" = lambda @lambda.isReflectable=true ()java.type:\"void\" -> {\n@@ -104,1 +104,1 @@\n-                %1 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n+                %1 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isReflectable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n@@ -130,1 +130,1 @@\n-                %1 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n+                %1 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isReflectable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n@@ -148,1 +148,1 @@\n-                %2 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%3 : java.type:\"int\")java.type:\"int\" -> {\n+                %2 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isReflectable=true (%3 : java.type:\"int\")java.type:\"int\" -> {\n@@ -168,1 +168,1 @@\n-                %1 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n+                %1 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isReflectable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n@@ -190,1 +190,1 @@\n-                %0 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Runnable\" = lambda @lambda.isReflectable=true ()java.type:\"void\" -> {\n@@ -205,1 +205,1 @@\n-                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n+                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isReflectable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n@@ -218,1 +218,1 @@\n-                %0 : java.type:\"java.util.function.IntFunction<int[]>\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int[]\" -> {\n+                %0 : java.type:\"java.util.function.IntFunction<int[]>\" = lambda @lambda.isReflectable=true (%1 : java.type:\"int\")java.type:\"int[]\" -> {\n@@ -241,1 +241,1 @@\n-                %1 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n+                %1 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isReflectable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/ReflectableLambdaTest.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Smoke test for captured values in quotable lambdas.\n- * @modules jdk.incubator.code\n- * @run junit TestCaptureQuotable\n- *\/\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.dialect.core.CoreOp.Var;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.function.IntSupplier;\n-import java.util.function.IntUnaryOperator;\n-import java.util.function.ToIntFunction;\n-import java.util.stream.IntStream;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-public class TestCaptureQuotable {\n-\n-    @ParameterizedTest\n-    @MethodSource(\"ints\")\n-    public void testCaptureIntParam(int x) {\n-        IntUnaryOperator quotable = (@Reflect IntUnaryOperator) y -> x + y;\n-        Quoted quoted = Op.ofLambda(quotable).get();\n-        assertEquals(1, quoted.capturedValues().size());\n-        assertEquals(x, ((Var)quoted.capturedValues().values().iterator().next()).value());\n-        List<Object> arguments = new ArrayList<>();\n-        arguments.add(1);\n-        arguments.addAll(quoted.capturedValues().values());\n-        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n-                arguments);\n-        assertEquals(x + 1, res);\n-    }\n-\n-    @Test\n-    public void testCaptureThisRefAndIntConstant() {\n-        final int x = 100;\n-        String hello = \"hello\";\n-        ToIntFunction<Number> quotable = (@Reflect ToIntFunction<Number>)y -> y.intValue() + hashCode() + hello.length() + x;\n-        Quoted quoted = Op.ofLambda(quotable).get();\n-        assertEquals(3, quoted.capturedValues().size());\n-        Iterator<Object> it = quoted.capturedValues().values().iterator();\n-        assertEquals(this, it.next());\n-        assertEquals(hello, ((Var)it.next()).value());\n-        assertEquals(x, ((Var)it.next()).value());\n-        List<Object> arguments = new ArrayList<>();\n-        arguments.add(1);\n-        arguments.addAll(quoted.capturedValues().values());\n-        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n-                arguments);\n-        assertEquals(x + 1 + hashCode() + hello.length(), res);\n-    }\n-\n-    @Test\n-    public void testCaptureThisInInvocationArg() {\n-        ToIntFunction<Number> quotable = (@Reflect ToIntFunction<Number>)y -> y.intValue() + Integer.valueOf(hashCode());\n-        Quoted quoted = Op.ofLambda(quotable).get();\n-        assertEquals(1, quoted.capturedValues().size());\n-        Iterator<Object> it = quoted.capturedValues().values().iterator();\n-        assertEquals(this, it.next());\n-        List<Object> arguments = new ArrayList<>();\n-        arguments.add(1);\n-        arguments.addAll(quoted.capturedValues().values());\n-        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n-                arguments);\n-        assertEquals(1 + hashCode(), res);\n-    }\n-\n-    record R(int i) {}\n-\n-    @Test\n-    public void testCaptureThisInNewArg() {\n-        ToIntFunction<Number> quotable = (@Reflect ToIntFunction<Number>)y -> y.intValue() + new R(hashCode()).i;\n-        Quoted quoted = Op.ofLambda(quotable).get();\n-        assertEquals(1, quoted.capturedValues().size());\n-        Iterator<Object> it = quoted.capturedValues().values().iterator();\n-        assertEquals(this, it.next());\n-        List<Object> arguments = new ArrayList<>();\n-        arguments.add(1);\n-        arguments.addAll(quoted.capturedValues().values());\n-        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n-                arguments);\n-        assertEquals(1 + hashCode(), res);\n-    }\n-\n-    @Test\n-    public void testCaptureMany() {\n-        int[] ia = new int[8];\n-        int i1 = ia[0] = 0;\n-        int i2 = ia[1] = 1;\n-        int i3 = ia[2] = 2;\n-        int i4 = ia[3] = 3;\n-        int i5 = ia[4] = 4;\n-        int i6 = ia[5] = 5;\n-        int i7 = ia[6] = 6;\n-        int i8 = ia[7] = 7;\n-\n-        IntSupplier quotable = (@Reflect IntSupplier) () -> i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8;\n-        Quoted quoted = Op.ofLambda(quotable).get();\n-        assertEquals(ia.length, quoted.capturedValues().size());\n-        assertEquals(new ArrayList<>(quoted.capturedValues().keySet()), quoted.op().capturedValues());\n-        Iterator<Object> it = quoted.capturedValues().values().iterator();\n-        int i = 0;\n-        while (it.hasNext()) {\n-            int actual = (int) ((Var)it.next()).value();\n-            assertEquals(ia[i++], actual);\n-        }\n-    }\n-\n-    static class Context {\n-        final int x;\n-\n-        Context(int x) {\n-            this.x = x;\n-        }\n-\n-        IntUnaryOperator quotable() {\n-            return (@Reflect IntUnaryOperator) y -> x + y;\n-        }\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"ints\")\n-    public void testCaptureIntField(int x) {\n-        Context context = new Context(x);\n-        IntUnaryOperator quotable = context.quotable();\n-        Quoted quoted = Op.ofLambda(quotable).get();\n-        assertEquals(1, quoted.capturedValues().size());\n-        assertEquals(context, quoted.capturedValues().values().iterator().next());\n-        List<Object> arguments = new ArrayList<>();\n-        arguments.add(1);\n-        arguments.addAll(quoted.capturedValues().values());\n-        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n-                arguments);\n-        assertEquals(x + 1, res);\n-    }\n-\n-    public static IntStream ints() {\n-        return IntStream.range(0, 50);\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"ints\")\n-    public void testCaptureReferenceReceiver(int i) {\n-        int prevCount = Box.count;\n-        IntUnaryOperator quotable = (@Reflect IntUnaryOperator)new Box(i)::add;\n-        Quoted quoted = Op.ofLambda(quotable).get();\n-        assertEquals(prevCount + 1, Box.count); \/\/ no duplicate receiver computation!\n-        assertEquals(1, quoted.capturedValues().size());\n-        assertEquals(i, ((Box)((Var)quoted.capturedValues().values().iterator().next()).value()).i);\n-        List<Object> arguments = new ArrayList<>();\n-        arguments.add(1);\n-        arguments.addAll(quoted.capturedValues().values());\n-        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n-                arguments);\n-        assertEquals(i + 1, res);\n-    }\n-\n-    record Box(int i) {\n-\n-        static int count = 0;\n-\n-        Box {\n-           count++; \/\/ keep track of side-effects\n-        }\n-\n-        int add(int i) {\n-            return i + this.i;\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestCaptureQuotable.java","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -65,8 +65,5 @@\n-            \"SuperTest.java\",                   \/\/ @@@ Might be issue referencing auxiliary interface\n-                                                \/\/ in method superInterfaceMethodInvocation\n-            \"LocalClassTest.java\",              \/\/ name of local classes is not stable at annotation processing time\n-            \"TestLocalCapture.java\",            \/\/ plain junit test\n-            \"TestCaptureQuoted.java\",           \/\/ plain junit test\n-            \"TestCaptureQuotable.java\",         \/\/ plain junit test\n-            \"QuotedSameInstanceTest.java\",      \/\/ plain junit test\n-            \"CodeModelSameInstanceTest.java\"    \/\/ plain junit test\n+            \"LocalClassTest.java\",                      \/\/ name of local classes is not stable at annotation processing time\n+            \"TestLocalCapture.java\",                    \/\/ plain junit test\n+            \"TestLambdaCapture.java\",                   \/\/ plain junit test\n+            \"ReflectableLambdaSameInstanceTest.java\",   \/\/ plain junit test\n+            \"CodeModelSameInstanceTest.java\"            \/\/ plain junit test\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestIRFromAnnotation.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for captured values in reflectable lambdas.\n+ * @modules jdk.incubator.code\n+ * @run junit TestLambdaCapture\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.dialect.core.CoreOp.Var;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.IntSupplier;\n+import java.util.function.IntUnaryOperator;\n+import java.util.function.ToIntFunction;\n+import java.util.stream.IntStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class TestLambdaCapture {\n+\n+    @ParameterizedTest\n+    @MethodSource(\"ints\")\n+    public void testCaptureIntParam(int x) {\n+        IntUnaryOperator quotable = (@Reflect IntUnaryOperator) y -> x + y;\n+        Quoted quoted = Op.ofLambda(quotable).get();\n+        assertEquals(1, quoted.capturedValues().size());\n+        assertEquals(x, ((Var)quoted.capturedValues().values().iterator().next()).value());\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                arguments);\n+        assertEquals(x + 1, res);\n+    }\n+\n+    @Test\n+    public void testCaptureThisRefAndIntConstant() {\n+        final int x = 100;\n+        String hello = \"hello\";\n+        ToIntFunction<Number> f = (@Reflect ToIntFunction<Number>)y -> y.intValue() + hashCode() + hello.length() + x;\n+        Quoted quoted = Op.ofLambda(f).get();\n+        assertEquals(3, quoted.capturedValues().size());\n+        Iterator<Object> it = quoted.capturedValues().values().iterator();\n+        assertEquals(this, it.next());\n+        assertEquals(hello, ((Var)it.next()).value());\n+        assertEquals(x, ((Var)it.next()).value());\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                arguments);\n+        assertEquals(x + 1 + hashCode() + hello.length(), res);\n+    }\n+\n+    @Test\n+    public void testCaptureThisInInvocationArg() {\n+        ToIntFunction<Number> f = (@Reflect ToIntFunction<Number>)y -> y.intValue() + Integer.valueOf(hashCode());\n+        Quoted quoted = Op.ofLambda(f).get();\n+        assertEquals(1, quoted.capturedValues().size());\n+        Iterator<Object> it = quoted.capturedValues().values().iterator();\n+        assertEquals(this, it.next());\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                arguments);\n+        assertEquals(1 + hashCode(), res);\n+    }\n+\n+    record R(int i) {}\n+\n+    @Test\n+    public void testCaptureThisInNewArg() {\n+        ToIntFunction<Number> f = (@Reflect ToIntFunction<Number>)y -> y.intValue() + new R(hashCode()).i;\n+        Quoted quoted = Op.ofLambda(f).get();\n+        assertEquals(1, quoted.capturedValues().size());\n+        Iterator<Object> it = quoted.capturedValues().values().iterator();\n+        assertEquals(this, it.next());\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                arguments);\n+        assertEquals(1 + hashCode(), res);\n+    }\n+\n+    @Test\n+    public void testCaptureMany() {\n+        int[] ia = new int[8];\n+        int i1 = ia[0] = 0;\n+        int i2 = ia[1] = 1;\n+        int i3 = ia[2] = 2;\n+        int i4 = ia[3] = 3;\n+        int i5 = ia[4] = 4;\n+        int i6 = ia[5] = 5;\n+        int i7 = ia[6] = 6;\n+        int i8 = ia[7] = 7;\n+\n+        IntSupplier f = (@Reflect IntSupplier) () -> i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8;\n+        Quoted quoted = Op.ofLambda(f).get();\n+        assertEquals(ia.length, quoted.capturedValues().size());\n+        assertEquals(new ArrayList<>(quoted.capturedValues().keySet()), quoted.op().capturedValues());\n+        Iterator<Object> it = quoted.capturedValues().values().iterator();\n+        int i = 0;\n+        while (it.hasNext()) {\n+            int actual = (int) ((Var)it.next()).value();\n+            assertEquals(ia[i++], actual);\n+        }\n+    }\n+\n+    static class Context {\n+        final int x;\n+\n+        Context(int x) {\n+            this.x = x;\n+        }\n+\n+        IntUnaryOperator quotable() {\n+            return (@Reflect IntUnaryOperator) y -> x + y;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"ints\")\n+    public void testCaptureIntField(int x) {\n+        Context context = new Context(x);\n+        IntUnaryOperator f = context.quotable();\n+        Quoted quoted = Op.ofLambda(f).get();\n+        assertEquals(1, quoted.capturedValues().size());\n+        assertEquals(context, quoted.capturedValues().values().iterator().next());\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                arguments);\n+        assertEquals(x + 1, res);\n+    }\n+\n+    public static IntStream ints() {\n+        return IntStream.range(0, 50);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"ints\")\n+    public void testCaptureReferenceReceiver(int i) {\n+        int prevCount = Box.count;\n+        IntUnaryOperator f = (@Reflect IntUnaryOperator)new Box(i)::add;\n+        Quoted quoted = Op.ofLambda(f).get();\n+        assertEquals(prevCount + 1, Box.count); \/\/ no duplicate receiver computation!\n+        assertEquals(1, quoted.capturedValues().size());\n+        assertEquals(i, ((Box)((Var)quoted.capturedValues().values().iterator().next()).value()).i);\n+        List<Object> arguments = new ArrayList<>();\n+        arguments.add(1);\n+        arguments.addAll(quoted.capturedValues().values());\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                arguments);\n+        assertEquals(i + 1, res);\n+    }\n+\n+    record Box(int i) {\n+\n+        static int count = 0;\n+\n+        Box {\n+           count++; \/\/ keep track of side-effects\n+        }\n+\n+        int add(int i) {\n+            return i + this.i;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestLambdaCapture.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -104,1 +104,1 @@\n-                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n+                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isReflectable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n@@ -178,1 +178,1 @@\n-                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n+                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isReflectable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/UnreachableTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}