{"files":[{"patch":"@@ -290,1 +290,0 @@\n-            \/\/ Sorting by rank ensures we don't need forward declarations\n@@ -295,1 +294,1 @@\n-                        HATFinalDetector finals = new HATFinalDetector(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator());\n+                        HATFinalDetector finals = new HATFinalDetector(kernelCallGraph);\n@@ -303,2 +302,1 @@\n-            HATFinalDetector hatFinalDetector = new HATFinalDetector(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator());\n-           \/\/ hatFinalDetectionPhase.apply(kernelCallGraph.entrypoint.funcOp());\n+            HATFinalDetector hatFinalDetector = new HATFinalDetector(kernelCallGraph);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.util.regex.Pattern;\n+import optkl.Regex;\n@@ -82,2 +82,2 @@\n-        Pattern szPattern = Pattern.compile(\"ls([xyz])\");\n-        Pattern idxPattern = Pattern.compile(\"li([xyz])\");\n+        Regex szRegex = Regex.of(\"ls([xyz])\");\n+        Regex idxRegex = Regex.of(\"li([xyz])\");\n@@ -90,1 +90,1 @@\n-        Pattern idxPattern = Pattern.compile(\"bi([xyz])\");\n+        Regex idxRegex = Regex.of(\"bi([xyz])\");\n@@ -94,2 +94,2 @@\n-        Pattern idxPattern = Pattern.compile(\"(gi[xyz])\");\n-        Pattern szPattern = Pattern.compile(\"(gs[xyz])\");\n+        Regex idxRegex = Regex.of(\"(gi[xyz])\");\n+        Regex szRegex = Regex.of(\"(gs[xyz])\");\n","filename":"hat\/core\/src\/main\/java\/hat\/NDRange.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import optkl.Regex;\n@@ -53,3 +54,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n@@ -354,1 +352,1 @@\n-    static Pattern atomicInc = Pattern.compile(\"(atomic.*)Inc\");\n+    static Regex atomicInc = Regex.of(\"(atomic.*)Inc\");\n@@ -362,1 +360,1 @@\n-                    && atomicInc.matcher(OpTkl.funcName(invokeOp)) instanceof Matcher matcher && matcher.matches()\n+                    && atomicInc.is(OpTkl.funcName(invokeOp)) instanceof Regex.Match matcher\n@@ -365,1 +363,1 @@\n-                    atomicInc(buildContext, instanceResult, matcher.group(1));\n+                    atomicInc(buildContext, instanceResult, matcher.stringOf(1));\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import optkl.Regex;\n@@ -36,1 +37,0 @@\n-import java.util.regex.Pattern;\n@@ -52,1 +52,1 @@\n-    public final static  Pattern pattern = NDRange.Block.idxPattern;\n+    public final static Regex regex = NDRange.Block.idxRegex;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATBlockThreadIdOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import optkl.Regex;\n@@ -36,2 +37,0 @@\n-import java.util.Map;\n-import java.util.regex.Pattern;\n@@ -53,1 +52,1 @@\n-    static final public  Pattern pattern= NDRange.Global.szPattern;\n+    static final public Regex regex= NDRange.Global.szRegex;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalSizeOp.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import optkl.Regex;\n@@ -36,2 +37,0 @@\n-import java.util.Map;\n-import java.util.regex.Pattern;\n@@ -54,1 +53,1 @@\n-    public static final Pattern pattern= NDRange.Global.idxPattern;\n+    public static final Regex regex= NDRange.Global.idxRegex;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalThreadIdOp.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import optkl.Regex;\n@@ -36,2 +37,0 @@\n-import java.util.Map;\n-import java.util.regex.Pattern;\n@@ -54,1 +53,1 @@\n-    public static Pattern  pattern= NDRange.Local.szPattern;\n+    public static Regex regex= NDRange.Local.szRegex;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalSizeOp.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import optkl.Regex;\n@@ -36,2 +37,0 @@\n-import java.util.Map;\n-import java.util.regex.Pattern;\n@@ -54,1 +53,1 @@\n-    static public  final Pattern pattern= NDRange.Local.idxPattern;\n+    static public  final Regex regex = NDRange.Local.idxRegex;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalThreadIdOp.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.Regex;\n@@ -49,1 +50,0 @@\n-import java.util.regex.Pattern;\n@@ -100,2 +100,2 @@\n-    static JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Pattern pattern) {\n-        return asKernelContextFieldAccessOrNull(lookup,ce,fieldAccessOp->pattern.matcher(fieldAccessOp.fieldDescriptor().name()).matches());\n+    static JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Regex regex) {\n+        return asKernelContextFieldAccessOrNull(lookup,ce,fieldAccessOp->regex.matches(fieldAccessOp.fieldDescriptor().name()));\n@@ -103,2 +103,2 @@\n-    default JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull( CodeElement<?,?> ce, Pattern pattern) {\n-        return asKernelContextFieldAccessOrNull(lookup(),ce,fieldAccessOp->pattern.matcher(fieldAccessOp.fieldDescriptor().name()).matches());\n+    default JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull( CodeElement<?,?> ce, Regex regex) {\n+        return asKernelContextFieldAccessOrNull(lookup(),ce,fieldAccessOp->regex.matches(fieldAccessOp.fieldDescriptor().name()));\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        MethodHandles.Lookup l = lookup();\n+\n@@ -154,1 +154,1 @@\n-                                    (Class<?>) classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                                    (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) info.buffer().type()),\n@@ -193,1 +193,1 @@\n-                                    (Class<?>) classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                                    (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) info.buffer().type()),\n@@ -209,1 +209,1 @@\n-                                (Class<?>) classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                                (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) info.buffer().type()),\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import optkl.Regex;\n@@ -43,1 +44,0 @@\n-import java.util.regex.Pattern;\n@@ -61,1 +61,1 @@\n-    protected abstract Pattern pattern();\n+    protected abstract Regex regex();\n@@ -67,1 +67,1 @@\n-                ce->OpTk.asNamedKernelContextFieldAccessOrNull(lookup(),ce,pattern())!=null,(s,o)->\n+                ce->OpTk.asNamedKernelContextFieldAccessOrNull(lookup(),ce,regex())!=null,(s,o)->\n@@ -87,2 +87,2 @@\n-        @Override protected Pattern pattern(){\n-            return HATBlockThreadIdOp.pattern;\n+        @Override protected Regex regex(){\n+            return HATBlockThreadIdOp.regex;\n@@ -101,2 +101,2 @@\n-        @Override protected Pattern pattern(){\n-            return HATGlobalThreadIdOp.pattern;\n+        @Override protected Regex regex(){\n+            return HATGlobalThreadIdOp.regex;\n@@ -114,2 +114,2 @@\n-        @Override protected Pattern pattern(){\n-            return HATGlobalSizeOp.pattern;\n+        @Override protected Regex regex(){\n+            return HATGlobalSizeOp.regex;\n@@ -127,2 +127,2 @@\n-        @Override protected Pattern pattern(){\n-            return HATLocalThreadIdOp.pattern;\n+        @Override protected Regex regex(){\n+            return HATLocalThreadIdOp.regex;\n@@ -140,2 +140,2 @@\n-        @Override public Pattern pattern(){\n-           return HATLocalSizeOp.pattern;\n+        @Override public Regex regex(){\n+           return HATLocalSizeOp.regex;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import optkl.Regex;\n@@ -44,1 +45,0 @@\n-import java.util.regex.Pattern;\n@@ -48,0 +48,1 @@\n+import static optkl.OpTkl.asOpFromResultOrNull;\n@@ -52,1 +53,1 @@\n-    static Pattern xyzw = Pattern.compile(\"[xyzw]\");\n+    static Regex xyzw = Regex.of(\"[xyzw]\");\n@@ -55,1 +56,1 @@\n-        return isMethod(invokeOp, n->xyzw.matcher(n).matches());\n+        return isMethod(invokeOp, n->xyzw.matches(n));\n@@ -70,1 +71,1 @@\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        if (OpTkl.asOpFromResultOrNull(v) instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n@@ -72,1 +73,1 @@\n-        } else if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp vectorViewOp) {\n+        } else if (OpTkl.asOpFromResultOrNull(v)  instanceof HATVectorOp vectorViewOp) {\n@@ -82,1 +83,1 @@\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        if (asOpFromResultOrNull(v) instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n@@ -84,1 +85,1 @@\n-        } else if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n+        } else if (asOpFromResultOrNull(v) instanceof CoreOp.VarOp varOp) {\n@@ -87,1 +88,1 @@\n-        return null;\/\/throw new IllegalStateException(\"recurse fail findVarOp\");\n+        return null;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Accelerator;\n+import hat.callgraph.KernelCallGraph;\n@@ -32,1 +32,0 @@\n-import hat.optools.OpTk;\n@@ -47,1 +46,1 @@\n-public record HATFinalDetector(LookupCarrier lookupCarrier){\n+public record HATFinalDetector(KernelCallGraph kernelCallGraph){\n@@ -61,12 +60,2 @@\n-                TypeElement typeElement = varOp.resultType().valueType();\n-                boolean isMappableType = false;\n-                if (typeElement instanceof JavaType javaType) {\n-                    isMappableType = isAssignable(MethodHandles.lookup(), javaType, MappableIface.class);\n-                    if (!isMappableType) {\n-                        \/\/ Special types?\n-                        isMappableType = isAssignable(MethodHandles.lookup(), javaType, F16.class);\n-                        isMappableType |= isAssignable(MethodHandles.lookup(), javaType, BF16.class);\n-                    }\n-                }\n-\n-                if (!isMappableType) {\n+                if (!isAssignable(kernelCallGraph.lookup(), varOp.resultType().valueType(),\n+                        MappableIface.class, F16.class, BF16.class)) {\n@@ -75,4 +64,3 @@\n-                        Op op = use.op();\n-                        switch (op) {\n-                            case CoreOp.VarAccessOp.VarStoreOp storeOp -> {\n-                                if (storeOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n+                        switch (use.op()) {\n+                            case CoreOp.VarAccessOp.VarStoreOp storeOp when\n+                                (storeOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) ->\n@@ -80,4 +68,2 @@\n-                                }\n-                            }\n-                            case CoreOp.YieldOp yieldOp -> {\n-                                if (yieldOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n+                            case CoreOp.YieldOp yieldOp when\n+                                 (yieldOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) ->\n@@ -85,2 +71,0 @@\n-                                }\n-                            }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetector.java","additions":9,"deletions":25,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package experiments;\n+\n+\n+import jdk.incubator.code.CodeContext;\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import optkl.CallSite;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static jdk.incubator.code.dialect.core.CoreType.FUNCTION_TYPE_VOID;\n+import static optkl.OpTkl.transform;\n+\n+\n+       import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+    \/**\n+     * Demonstrates how to dynamically build a new function using the code reflection API.\n+     * <p>\n+     * This example creates an <code>rsqrt<\/code> function, which computes the inverse of a square root.\n+     * The function takes one argument of type <code>double<\/code> and returns a <code>double<\/code>.\n+     * The implementation uses {@link Math#sqrt(double)} for the square root calculation.\n+     * <\/p>\n+     *\n+     * <p>\n+     * In this example, you will learn how to:\n+     * <ol>\n+     *   <li>Create a function dynamically<\/li>\n+     *   <li>Append new Op nodes in the builder<\/li>\n+     *   <li>Compose operations in the code tree<\/li>\n+     *   <li>Create nodes to call static methods<\/li>\n+     *   <li>Evaluate the composed method in the interpreter<\/li>\n+     * <\/ol>\n+     * <\/p>\n+     *\n+     * <p>\n+     * After building the code model for the function, it will be executed both in the code reflection interpreter and in the bytecode interpreter.\n+     * <\/p>\n+     *\n+     * <p>\n+     * <b>How to run:<\/b><br>\n+     * <code>\n+     * java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DynamicFunctionBuild\n+     * <\/code>\n+     * <\/p>\n+     *\/\n+    public class CreateFuncOp {\n+        @Reflect\n+        public  static void main(String[] args) {\n+            MethodRef MathSqrt = MethodRef.method(Math.class, \"sqrt\", double.class, double.class);\n+            CoreOp.FuncOp rsqrtFuncOp = CoreOp.func(\"rsqrt\", CoreType.functionType(JavaType.DOUBLE, JavaType.DOUBLE))\n+                    .body(builder -> {\n+                                \/\/ double rsqrt(double arg){\n+                                \/\/      return 1 \/ Math.sqrt(qrg)\n+                                \/\/}\n+\n+                        var block = builder.block(JavaType.INT);\n+                        var c=block.context();\n+\n+\n+                      \/\/  builder.op(block);\n+                        var arg = builder.parameters().getFirst();\n+                        \/\/ Add an invoke of Math.sqrt\n+                        Op.Result invokeResult = builder.op(\n+                                JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathSqrt, arg)\/\/ we pass the first param of our rsqrt to Math.sqrt\n+                        );\n+\n+                        \/\/ Add divisionOp (1f,invokeResult)\n+                        Op.Result divResult = builder.op(JavaOp.div(builder.op(CoreOp.constant(JavaType.DOUBLE, 1.0)), invokeResult));\n+\n+                        builder.op(CoreOp.return_(divResult));\n+                    });\n+\n+            \/\/ Print the code model for the function we have just created\n+            System.out.println(rsqrtFuncOp.toText());\n+\n+            \/\/ Run in the Java Bytecode interpreter\n+            MethodHandle rsqrt = BytecodeGenerator.generate(MethodHandles.lookup(), rsqrtFuncOp);\n+            try {\n+                System.out.println(\"Evaluation in the Java Bytecode Interpreter: 1\/sqrt(100) = \" +  rsqrt.invoke(100));\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package experiments;\n+\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.invoke.MethodHandles;\n+\n+public class JavaPMe {\n+    @Reflect\n+    public static void main(String[] args) throws ReflectiveOperationException {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        CoreOp.FuncOp.ofMethod(\n+                MethodRef.method(JavaPMe.class, \"main\", void.class, String[].class)\n+                        .resolveToMethod(lookup)).ifPresent(mainFuncOp -> {\n+            System.out.print(mainFuncOp.toText());\n+            System.out.println(ClassFile.of().parse(BytecodeGenerator.generateClassData(lookup, \"Mine\", mainFuncOp)).toDebugString());\n+\n+        });\n+    }\n+}\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/JavaPMe.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -146,0 +146,2 @@\n+                   \/\/ builder.body(op.bodies().getFirst(),List.of(), this);\n+                    builder.op(op);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-\n-    \/\/static Pattern varPattern = Pattern.compile(\"\\\\$\\\\{([^}]*)\\\\}\");\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Intellij.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/CallSite.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import optkl.annotations.Kernel;\n@@ -340,0 +339,3 @@\n+   static Op asOpFromResultOrNull(Value operand) {\n+      return asResultOrNull(operand) instanceof Op.Result r && r.op() instanceof Op op?op:null;\n+   }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        static Regex locPattern = Regex.of(\"\\\"([0-9]+):([0-9]+)[^\\\"]*\\\"\");\n+        static Regex locRegex = Regex.of(\"\\\"([0-9]+):([0-9]+)[^\\\"]*\\\"\");\n@@ -84,1 +84,1 @@\n-            if (locPattern.is(r.asString()) instanceof Regex.Match m && m.count() > 1) {\n+            if (locRegex.is(r.asString()) instanceof Regex.Match m && m.count() > 1) {\n@@ -104,1 +104,1 @@\n-        static Regex locFilePattern = Regex.of(\"\\\"([0-9]+):([0-9]+):file:([^\\\"]*)\\\"\");\n+        static Regex locFileRegex = Regex.of(\"\\\"([0-9]+):([0-9]+):file:([^\\\"]*)\\\"\");\n@@ -108,1 +108,1 @@\n-            return locFilePattern.is(fileLocString) instanceof Regex.Match m && m.count() > 2\n+            return locFileRegex.is(fileLocString) instanceof Regex.Match m && m.count() > 2\n@@ -290,1 +290,1 @@\n-                                && StringLiteral.isA(t4, $ -> $.matches(BabylonFileLocationAttribute.locFilePattern))\n+                                && StringLiteral.isA(t4, $ -> $.matches(BabylonFileLocationAttribute.locFileRegex))\n@@ -299,1 +299,1 @@\n-                                && StringLiteral.isA(t4, $ -> $.matches(BabylonLocationAttribute.locPattern))\n+                                && StringLiteral.isA(t4, $ -> $.matches(BabylonLocationAttribute.locRegex))\n@@ -343,1 +343,1 @@\n-                    && BabylonFileLocationAttribute.locFilePattern.is(sl.asString()) instanceof Regex.Match m\n+                    && BabylonFileLocationAttribute.locFileRegex.is(sl.asString()) instanceof Regex.Match m\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/textmodel\/BabylonTextModel.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}