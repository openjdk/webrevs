{"files":[{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.constant.DynamicConstantDesc;\n@@ -105,1 +106,1 @@\n-            hcl = l.defineHiddenClass(classBytes, true, MethodHandles.Lookup.ClassOption.NESTMATE);\n+            hcl = l.defineHiddenClassWithClassData(classBytes, l, true, MethodHandles.Lookup.ClassOption.NESTMATE);\n@@ -433,0 +434,2 @@\n+            \/\/ InvokeOp SUPER\n+            case InvokeOp op when op.invokeKind() == InvokeOp.InvokeKind.SUPER -> false;\n@@ -794,0 +797,19 @@\n+                        \/\/ Resolve referenced class to determine if interface\n+                        MethodRef md = op.invokeDescriptor();\n+                        JavaType refType = (JavaType)md.refType();\n+                        ClassDesc specialCaller = lookup.lookupClass().describeConstable().get();\n+                        MethodTypeDesc mDesc = MethodRef.toNominalDescriptor(md.type());\n+                        if (op.invokeKind() == InvokeOp.InvokeKind.SUPER) {\n+                            \/\/ constructs method handle via lookup.findSpecial using the lookup's class as the specialCaller\n+                            \/\/ original lookup is stored in class data\n+                            \/\/ @@@ performance can be improved by storing a list of the resolved method handles instead\n+                            cob.ldc(DynamicConstantDesc.of(BSM_CLASS_DATA))\n+                               .checkcast(CD_MethodHandles_Lookup)\n+                               .ldc(refType.toNominalDescriptor())\n+                               .ldc(md.name())\n+                               .ldc(mDesc)\n+                               .ldc(specialCaller)\n+                               .invokevirtual(CD_MethodHandles_Lookup,\n+                                              \"findSpecial\",\n+                                              MethodTypeDesc.of(CD_MethodHandle, CD_Class, CD_String, CD_MethodType, CD_Class));\n+                        }\n@@ -817,3 +839,0 @@\n-                        \/\/ Resolve referenced class to determine if interface\n-                        MethodRef md = op.invokeDescriptor();\n-                        JavaType refType = (JavaType)md.refType();\n@@ -826,1 +845,0 @@\n-                        \/\/ Determine invoke opcode\n@@ -828,1 +846,1 @@\n-                        Opcode invokeOpcode = switch (op.invokeKind()) {\n+                        switch (op.invokeKind()) {\n@@ -830,1 +848,4 @@\n-                                    Opcode.INVOKESTATIC;\n+                                    cob.invokestatic(refType.toNominalDescriptor(),\n+                                                     md.name(),\n+                                                     mDesc,\n+                                                     isInterface);\n@@ -832,1 +853,5 @@\n-                                    isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL;\n+                                    cob.invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL,\n+                                               refType.toNominalDescriptor(),\n+                                               md.name(),\n+                                               mDesc,\n+                                               isInterface);\n@@ -834,16 +859,4 @@\n-                                    \/\/ @@@ We cannot generate an invokespecial as it will result in a verify error,\n-                                    \/\/     since the owner is not assignable to generated hidden class\n-                                    \/\/ @@@ Construct method handle via lookup.findSpecial\n-                                    \/\/     using the lookup's class as the specialCaller and\n-                                    \/\/     add that method handle to the to be defined hidden class's constant data\n-                                    \/\/     Use and ldc+constant dynamic to access the class data,\n-                                    \/\/     extract the method handle and then invoke it\n-                                    throw new UnsupportedOperationException(\"invoke super unsupported: \" + op.invokeDescriptor());\n-                        };\n-                        MethodTypeDesc mDesc = MethodRef.toNominalDescriptor(md.type());\n-                        cob.invoke(\n-                                invokeOpcode,\n-                                refType.toNominalDescriptor(),\n-                                md.name(),\n-                                mDesc,\n-                                isInterface);\n+                                    cob.invokevirtual(CD_MethodHandle,\n+                                                      \"invoke\",\n+                                                      mDesc.insertParameterTypes(0, specialCaller));\n+                        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":37,"deletions":24,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import jdk.incubator.code.CodeTransformer;\n@@ -36,1 +35,0 @@\n-import org.junit.jupiter.api.Disabled;\n@@ -67,1 +65,0 @@\n-    @Disabled\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestInvokeSuper.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}