{"files":[{"patch":"@@ -97,0 +97,5 @@\n+        @CodeReflection\n+        public static int val(CellGrid grid, int from, int w, int x, int y) {\n+            return grid.cell( ((long) y * w)  + x +from)&1;\n+        }\n+\n@@ -103,0 +108,1 @@\n+                int to = control.to();\n@@ -106,11 +112,11 @@\n-                if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n-                    int count = 0;\n-                    for (int dx = -1; dx <= 1; dx++) {\n-                        for (int dy = -1; dy <= 1; dy++) {\n-                            if (!(dx == 0 && dy == 0)) {\n-                                int offset = from + y * w + dy * w + x + dx;\n-                                count += cellGrid.cell(offset) & 1;\n-                            }\n-                        }\n-                    }\n-                    cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n+                if (x>0 && x<(w-1) && y>0 && y<(h-1)) { \/\/ passports please\n+                    int count =\n+                            val(cellGrid,from,w,x-1,y-1)\n+                            +val(cellGrid,from,w,x-1,y+0)\n+                            +val(cellGrid,from,w,x-1,y+1)\n+                            +val(cellGrid,from,w,x+0,y-1)\n+                            +val(cellGrid,from,w,x+0,y+1)\n+                            +val(cellGrid,from,w,x+1,y+0)\n+                            +val(cellGrid,from,w,x+1,y-1)\n+                            +val(cellGrid,from,w,x+1,y+1);\n+                    cell =  ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n@@ -118,1 +124,1 @@\n-                cellGrid.cell(kc.x + control.to(), cell);\n+                cellGrid.cell(kc.x + to, cell);\n@@ -127,1 +133,0 @@\n-\n@@ -132,5 +137,1 @@\n-\n-                \/\/swap from\/to\n-                int to = control.from();\n-                control.from(control.to());\n-                control.to(to);\n+                int to = control.from();control.from(control.to());control.to(to); \/\/swap from\/to\n@@ -138,1 +139,1 @@\n-               \/\/ if (generation % 50 == 0) {\n+             \/\/   if (generation % 50 == 0) {\n@@ -140,1 +141,1 @@\n-               \/\/ }\n+              \/\/  }\n@@ -142,2 +143,0 @@\n-\n-\n@@ -151,1 +150,1 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), \/*Backend.JAVA_MULTITHREADED);\/\/*\/Backend.FIRST);\n@@ -157,2 +156,3 @@\n-                (((patternData.getMetaData().getWidth() + 2) \/ 16) + 1) * 16,\n-                (((patternData.getMetaData().getHeight() + 2) \/ 16) + 1) * 16\n+                  patternData.getMetaData().getWidth() + 2,\n+                patternData.getMetaData().getHeight() + 2\n+\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Life.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-        this.generationsPerSecond.setText(String.format(\"%5.2f\",ms\/generation));\n+        this.generationsPerSecond.setText(String.format(\"%5.2f\",(generation*1000)\/ms));\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Viewer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,13 +67,9 @@\n-\n-    public static final MethodRef M_CC_PRE_MUTATE = MethodRef.method(ComputeContext.class, \"preMutate\",\n-            void.class, Buffer.class);\n-    public static final MethodRef M_CC_POST_MUTATE = MethodRef.method(ComputeContext.class, \"postMutate\",\n-            void.class, Buffer.class);\n-    public static final MethodRef M_CC_PRE_ACCESS = MethodRef.method(ComputeContext.class, \"preAccess\",\n-            void.class, Buffer.class);\n-    public static final MethodRef M_CC_POST_ACCESS = MethodRef.method(ComputeContext.class, \"postAccess\",\n-            void.class, Buffer.class);\n-    public static final MethodRef M_CC_PRE_ESCAPE = MethodRef.method(ComputeContext.class, \"preEscape\",\n-            void.class, Buffer.class);\n-    public static final MethodRef M_CC_POST_ESCAPE = MethodRef.method(ComputeContext.class, \"postEscape\",\n-            void.class, Buffer.class);\n+    public  enum WRAPPER {\n+        MUTATE(\"Mutate\"), ACCESS(\"Access\"), ESCAPE(\"Escape\");\n+        final public MethodRef pre;\n+        final public MethodRef post;\n+        WRAPPER(String name){\n+            this.pre = MethodRef.method(ComputeContext.class, \"pre\"+name, void.class, Buffer.class);\n+            this.post = MethodRef.method(ComputeContext.class, \"post\"+name, void.class, Buffer.class);\n+        }\n+    }\n@@ -157,1 +153,1 @@\n-        \/\/System.out.println(\"postMutate \" + b);\n+       \/\/ System.out.println(\"postMutate \" + b);\n@@ -162,1 +158,1 @@\n-        \/\/System.out.println(\"preAccess \" + b);\n+       \/\/ System.out.println(\"preAccess \" + b);\n@@ -173,2 +169,1 @@\n-        \/\/System.out.println(\"preEscape \" + b);\n-\n+       \/\/ System.out.println(\"preEscape \" + b);\n@@ -180,1 +175,1 @@\n-        \/\/System.out.println(\"postEscape \" + b);\n+       \/\/ System.out.println(\"postEscape \" + b);\n@@ -191,1 +186,0 @@\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/ComputeContext.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.reflect.code.Block;\n@@ -43,2 +44,4 @@\n-import java.util.ArrayList;\n-import java.util.List;\n+\n+import static hat.ComputeContext.WRAPPER.ACCESS;\n+import static hat.ComputeContext.WRAPPER.ESCAPE;\n+import static hat.ComputeContext.WRAPPER.MUTATE;\n@@ -60,1 +63,0 @@\n-\n@@ -83,43 +85,37 @@\n-    static FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall resolvedMethodCall) {\n-        FuncOpWrapper originalFuncOpWrapper = resolvedMethodCall.funcOpWrapper();\n-        originalFuncOpWrapper.op().writeTo(System.out);\n-        var transformed = originalFuncOpWrapper.transformInvokes((builder, invokeOpWrapper) -> {\n-                    CopyContext cc = builder.context();\n-                    \/\/We know that the first arg to a compute method is indeed a computeContext\n-                    \/\/ so map the value\n-                    Value computeContext = cc.getValue(originalFuncOpWrapper.parameter(0));\n-                    if (invokeOpWrapper.isIfaceBufferMethod()) {\n-                        Value receiver = cc.getValue(invokeOpWrapper.operandNAsValue(0));\n-                        if (invokeOpWrapper.isIfaceMutator()) {\n-                            builder.op(CoreOp.invoke(ComputeContext.M_CC_PRE_MUTATE, computeContext, receiver));\n-                            builder.op(invokeOpWrapper.op());\n-                            builder.op(CoreOp.invoke(ComputeContext.M_CC_POST_MUTATE, computeContext, receiver));\n-                        } else if (invokeOpWrapper.isIfaceAccessor()) {\n-                            builder.op(CoreOp.invoke(ComputeContext.M_CC_PRE_ACCESS, computeContext, receiver));\n-                            builder.op(invokeOpWrapper.op());\n-                            builder.op(CoreOp.invoke(ComputeContext.M_CC_POST_ACCESS, computeContext, receiver));\n-                        } else {\n-                            builder.op(invokeOpWrapper.op());\n-                        }\n-                    } else if (invokeOpWrapper.isComputeContextMethod()) { \/\/dispatchKernel\n-                        builder.op(invokeOpWrapper.op());\n-                    } else if (invokeOpWrapper.isRawKernelCall()) {        \/\/static, void and first arg is KernelContext\n-                        builder.op(invokeOpWrapper.op());\n-                    } else {\n-                        for (int i=0; i<invokeOpWrapper.operandCount();i++ ){\n-                            if (invokeOpWrapper.operandNAsValue(i) instanceof Value value\n-                                    && value.type() instanceof JavaType javaType\n-                                    && InvokeOpWrapper.isIface(javaType)){\n-                                builder.op(CoreOp.invoke(ComputeContext.M_CC_PRE_ESCAPE, computeContext, cc.getValue(value)));\n-                            }\n-                        }\n-                        builder.op(invokeOpWrapper.op());\n-                        for (int i=0; i<invokeOpWrapper.operandCount();i++ ){\n-                            if (invokeOpWrapper.operandNAsValue(i) instanceof Value value\n-                                    && value.type() instanceof JavaType javaType\n-                                    && InvokeOpWrapper.isIface(javaType)){\n-                                builder.op(CoreOp.invoke(ComputeContext.M_CC_POST_ESCAPE, computeContext, cc.getValue(value)));\n-                            }\n-                        }\n-                    }\n-                    return builder;\n+    static void wrapInvoke(InvokeOpWrapper iow, Block.Builder bldr, ComputeContext.WRAPPER wrapper, Value cc, Value iface) {\n+        bldr.op(CoreOp.invoke(wrapper.pre, cc, iface));\n+        bldr.op(iow.op());\n+        bldr.op(CoreOp.invoke(wrapper.post, cc, iface));\n+    }\n+\n+    static FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n+        FuncOpWrapper prevFOW = computeMethod.funcOpWrapper();\n+        FuncOpWrapper returnFOW = prevFOW;\n+        boolean transform = true;\n+        if (transform) {\n+            System.out.println(\"COMPUTE entrypoint before injecting buffer tracking...\");\n+            returnFOW.op().writeTo(System.out);\n+            returnFOW = prevFOW.transformInvokes((bldr, invokeOW) -> {\n+                CopyContext bldrCntxt = bldr.context();\n+                \/\/Map compute method's first param (computeContext) value to transformed model\n+                Value cc = bldrCntxt.getValue(prevFOW.parameter(0));\n+                if (invokeOW.isIfaceMutator()) {                    \/\/ iface.v(newV)\n+                    Value iface = bldrCntxt.getValue(invokeOW.operandNAsValue(0));\n+                    bldr.op(CoreOp.invoke(MUTATE.pre, cc, iface));  \/\/ cc->preMutate(iface);\n+                    bldr.op(invokeOW.op());                         \/\/ iface.v(newV);\n+                    bldr.op(CoreOp.invoke(MUTATE.post, cc, iface)); \/\/ cc->postMutate(iface)\n+                } else if (invokeOW.isIfaceAccessor()) {            \/\/ iface.v()\n+                    Value iface = bldrCntxt.getValue(invokeOW.operandNAsValue(0));\n+                    bldr.op(CoreOp.invoke(ACCESS.pre, cc, iface));  \/\/ cc->preAccess(iface);\n+                    bldr.op(invokeOW.op());                         \/\/ iface.v();\n+                    bldr.op(CoreOp.invoke(ACCESS.post, cc, iface)); \/\/ cc->postAccess(iface) } else {\n+                } else if (invokeOW.isComputeContextMethod() || invokeOW.isRawKernelCall()) { \/\/dispatchKernel\n+                    bldr.op(invokeOW.op());\n+                } else {\n+                    invokeOW.op().operands().stream()\n+                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(javaType))\n+                            .forEach(value -> CoreOp.invoke(ESCAPE.pre, cc, bldrCntxt.getValue(value)));\n+                    bldr.op(invokeOW.op());\n+                    invokeOW.op().operands().stream()\n+                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(javaType))\n+                            .forEach(value -> CoreOp.invoke(ESCAPE.post, cc, bldrCntxt.getValue(value)));\n@@ -127,4 +123,7 @@\n-        );\n-        transformed.op().writeTo(System.out);\n-        resolvedMethodCall.funcOpWrapper(transformed);\n-        return transformed;\n+                return bldr;\n+            });\n+            System.out.println(\"COMPUTE entrypoint after injecting buffer tracking...\");\n+            returnFOW.op().writeTo(System.out);\n+        }\n+        computeMethod.funcOpWrapper(returnFOW);\n+        return returnFOW;\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeBackend.java","additions":49,"deletions":50,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.code.Block;\n@@ -34,1 +35,0 @@\n-import java.lang.reflect.code.type.ClassType;\n@@ -37,1 +37,0 @@\n-import java.lang.reflect.code.type.PrimitiveType;\n@@ -63,1 +62,1 @@\n-        boolean isRawKernelCall= (operandCount()>1 && operandNAsValue(0) instanceof Value value\n+        boolean isRawKernelCall = (operandCount() > 1 && operandNAsValue(0) instanceof Value value\n@@ -69,0 +68,1 @@\n+\n@@ -73,0 +73,1 @@\n+\n@@ -77,0 +78,1 @@\n+\n@@ -102,1 +104,1 @@\n-        if (nonDeclaredMethod.isPresent()){\n+        if (nonDeclaredMethod.isPresent()) {\n@@ -104,1 +106,1 @@\n-        }else {\n+        } else {\n@@ -106,1 +108,0 @@\n-            \/\/return nonDeclaredMethod.get();\n@@ -111,1 +112,1 @@\n-        return hasReceiver()?operandNAsValue(0):null;\n+        return hasReceiver() ? operandNAsValue(0) : null;\n@@ -113,0 +114,1 @@\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"}]}