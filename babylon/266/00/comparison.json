{"files":[{"patch":"@@ -34,1 +34,1 @@\n-   withExpectedDirectory(hatDir.path(), \"hat\", hatProjectDir -> {\n+   withExpectedDirectory(hatDir.subDir(\"hat\"), hatProjectDir -> {\n@@ -46,1 +46,1 @@\n-      withExpectedDirectory(hatDir.path(), \"backends\", backendsDir -> {\n+      withExpectedDirectory(hatDir.subDir(\"backends\"), backendsDir -> {\n@@ -63,1 +63,1 @@\n-      withExpectedDirectory(hatDir.path(), \"examples\", examplesDir ->\n+      withExpectedDirectory(hatDir.subDir(\"examples\"), examplesDir ->\n@@ -70,1 +70,1 @@\n-      withOptionalDirectory(hatDir.path(), \"hattricks\", hattricksDir -> {\n+      withOptionalDirectory(hatDir.subDir(\"hattricks\"), hattricksDir -> {\n@@ -77,1 +77,1 @@\n-             withOptionalDirectory(hattricksDir, \"nbody\", nbody -> {\n+             withOptionalDirectory(hattricksDir.resolve(\"nbody-extracted-cl\"),nbodyExtractedCl -> {\n@@ -82,0 +82,1 @@\n+                   println(\"Extracting OpenCL API\");\n@@ -84,1 +85,1 @@\n-                      .cwd(nbody)\n+                      .cwd(nbodyExtractedCl)\n@@ -87,4 +88,4 @@\n-                      .when(os.isMac(), $$$ -> $$$\n-                         .compile_flag(\"-F\" + os.macAppLibFrameworks())\n-                         .library(os.macFramework(\"OpenCL.framework\/OpenCL\"))\n-                         .header(os.macFrameworkHeaderFile(\"OpenCL.framework\/Headers\/opencl.h\"))\n+                      .when(os instanceof OS.Mac,  $$$ -> $$$\n+                         .compile_flag(\"-F\" + ((OS.Mac)os).appLibFrameworks())\n+                         .library(((OS.Mac)os).frameworkLibrary(\"OpenCL\"))\n+                         .header(((OS.Mac)os).frameworkHeader(\"OpenCL\", \"opencl.h\"))\n@@ -97,0 +98,1 @@\n+                   println(\"Extracting OpenGL API\");\n@@ -99,1 +101,1 @@\n-                      .cwd(nbody)\n+                      .cwd(nbodyExtractedCl)\n@@ -102,7 +104,7 @@\n-                      .when(os.isMac(), $$$ -> $$$\n-                         .compile_flag(\"-F\" + os.macAppLibFrameworks())\n-                         .library(\n-                             os.macFramework(\"GLUT.framework\/GLUT\"),\n-                             os.macFramework(\"OpenGL.framework\/OpenGL\")\n-                         )\n-                         .header(os.macFrameworkHeaderFile(\"GLUT.framework\/Headers\/glut.h\"))\n+                      .when(os instanceof OS.Mac, $$$ -> $$$\n+                          .compile_flag(\"-F\" + ((OS.Mac)os).libFrameworks())\n+                          .library(\n+                              ((OS.Mac)os).frameworkLibrary(\"GLUT\"),\n+                              ((OS.Mac)os).frameworkLibrary(\"OpenGL\")\n+                              )\n+                          .header(((OS.Mac)os).frameworkHeader(\"GLUT\",\"glut.h\"))\n@@ -110,0 +112,2 @@\n+                      .when(os instanceof OS.Linux, $$$ -> {\n+                      })\n@@ -113,3 +117,4 @@\n-                jar($ -> $\n-                   .jar(hatDir.buildDir().resolve(\"hat-example-nbody-1.0.jar\"))\n-                   .path_list(nbody.resolve(\"src\/main\/resources\"))\n+                println(\"Building nbody-extracted-cl\");\n+                var nbodyJar =jar($ -> $\n+                   .jar(hatDir.buildDir().resolve(\"hat-example-nbody-extracted-cl-1.0.jar\"))\n+                   .path_list(nbodyExtractedCl.resolve(\"src\/main\/resources\"))\n@@ -117,1 +122,1 @@\n-                       .source_path(nbody.resolve(\"src\/main\/java\"), extractedOpenCLCode, extractedOpenGLCode)\n+                       .source_path(nbodyExtractedCl.resolve(\"src\/main\/java\"), extractedOpenCLCode, extractedOpenGLCode)\n@@ -120,0 +125,11 @@\n+\n+                java($ -> $\n+                   .vmopts(\n+                       \"--enable-preview\",\n+                       \"--enable-native-access=ALL-UNNAMED\",\n+                       \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+                       \"-XstartOnFirstThread\"\n+                    )\n+                    .class_path(nbodyJar.jar)\n+                    .main_class(\"nbody.Main\")\n+                );\n","filename":"hat\/bld","additions":38,"deletions":22,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.io.BufferedReader;\n@@ -48,0 +49,1 @@\n+import java.io.InputStreamReader;\n@@ -87,1 +89,1 @@\n-    interface TargetDirProvider extends PathHolder {\n+    public interface TargetDirProvider extends PathHolder {\n@@ -91,1 +93,1 @@\n-    interface JavaSourceDirProvider {\n+    public interface JavaSourceDirProvider {\n@@ -95,1 +97,1 @@\n-    interface ResourceDirProvider {\n+    public interface ResourceDirProvider {\n@@ -100,0 +102,3 @@\n+        public default Path subDir(String subdir){\n+            return path().resolve(subdir);\n+        }\n@@ -111,0 +116,3 @@\n+    public record BuildDir(Path path) implements ClassPathEntry, DirPathHolder {\n+    }\n+\n@@ -117,1 +125,2 @@\n-    public interface SourceFile extends FilePathHolder {\n+    public interface TextFile extends FilePathHolder{\n+\n@@ -120,1 +129,23 @@\n-    public record JavaSourceFile(Path path) implements SourceFile {\n+    public interface SourceFile extends TextFile {\n+    }\n+\n+    public static class JavaSourceFile extends SimpleJavaFileObject implements SourceFile {\n+         Path path;\n+\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                try {\n+                    return Files.readString(Path.of(toUri()));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+        JavaSourceFile(Path path) {\n+         super(path.toUri(), JavaFileObject.Kind.SOURCE);\n+\n+        }\n+\n+        @Override\n+        public Path path() {\n+            return null;\n+        }\n@@ -126,1 +157,1 @@\n-    public record HeaderSourceFile(Path path) implements SourceFile {\n+    public record CppHeaderSourceFile(Path path) implements SourceFile {\n@@ -136,1 +167,1 @@\n-    public record XMLFile(Path path) implements FilePathHolder {\n+    public record XMLFile(Path path) implements TextFile {\n@@ -139,1 +170,0 @@\n-\n@@ -141,0 +171,5 @@\n+\n+        private final String repoBase = \"https:\/\/repo1.maven.org\/maven2\/\";\n+        private final String searchBase = \"https:\/\/search.maven.org\/solrsearch\/\";\n+        private Path path;\n+\n@@ -171,3 +206,0 @@\n-        private final String repoBase = \"https:\/\/repo1.maven.org\/maven2\/\";\n-        private final String searchBase = \"https:\/\/search.maven.org\/solrsearch\/\";\n-        private Path path;\n@@ -260,6 +292,0 @@\n-\n-        \/\/ https:\/\/search.maven.org\/solrsearch\/select?q=a:aparapi&core=gav&wt=xml\n-        \/\/https:\/\/search.maven.org\/solrsearch\/select?q=aparapi&wt=xml\n-        \/\/https:\/\/repo1.maven.org\/maven2\/com\/aparapi\/aparapi-jni\/1.0.0\/aparapi-jni-1.0.0.pom\n-        \/\/https:\/\/repo1.maven.org\/maven2\/com\/aparapi\/aparapi-jni\/maven-metadata.xml\n-        \/\/\n@@ -268,1 +294,7 @@\n-    public record OS(String arch, String name, String version) {\n+    public interface OS {\n+        String arch();\n+\n+        String name();\n+\n+        String version();\n+\n@@ -271,1 +303,2 @@\n-        public String nameArchTuple() {\n+\n+        default String nameArchTuple() {\n@@ -278,2 +311,1 @@\n-        public boolean isMac() {\n-            return name().equals(MacName);\n+        record Linux(String arch, String name, String version) implements OS {\n@@ -282,3 +314,5 @@\n-        public boolean isLinux() {\n-            return name().equals(LinuxName);\n-        }\n+        record Mac(String arch, String name, String version) implements OS {\n+            public Path appLibFrameworks() {\n+                return Path.of(\"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/\"\n+                        + \"MacOSX.sdk\/System\/Library\/Frameworks\");\n+            }\n@@ -286,4 +320,3 @@\n-        public Path macAppLibFrameworks() {\n-            return Path.of(\"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/\"\n-                    + \"MacOSX.sdk\/System\/Library\/Frameworks\");\n-        }\n+            public Path frameworkHeader(String frameworkName, String headerFileName) {\n+                return appLibFrameworks().resolve(frameworkName + \".framework\/Headers\/\" + headerFileName);\n+            }\n@@ -291,3 +324,3 @@\n-        public Path macFrameworkHeaderFile(String resolveMe) {\n-            return macAppLibFrameworks().resolve(resolveMe);\n-        }\n+            public Path libFrameworks() {\n+                return Path.of(\"\/System\/Library\/Frameworks\");\n+            }\n@@ -295,2 +328,3 @@\n-        public Path macLibFrameworks() {\n-            return Path.of(\"\/System\/Library\/Frameworks\");\n+            public Path frameworkLibrary(String frameworkName) {\n+                return libFrameworks().resolve(frameworkName + \".framework\/\" + frameworkName);\n+            }\n@@ -299,2 +333,10 @@\n-        public Path macFramework(String resolveMe) {\n-            return macLibFrameworks().resolve(resolveMe);\n+        static OS get() {\n+            String arch = System.getProperty(\"os.arch\");\n+            String name = System.getProperty(\"os.name\");\n+            String version = System.getProperty(\"os.version\");\n+            return switch (name) {\n+\n+                case \"Mac OS X\" -> new Mac(arch, name, version);\n+                case \"Linux\" -> new Linux(arch, name, version);\n+                default -> throw new IllegalStateException(\"No os mapping for \" + name);\n+            };\n@@ -304,1 +346,2 @@\n-    public static OS os = new OS(System.getProperty(\"os.arch\"), System.getProperty(\"os.name\"), System.getProperty(\"os.version\"));\n+\n+    public static OS os = OS.get();\n@@ -546,2 +589,2 @@\n-    public static Stream<TextFile> findTextFiles(Path dir, String... suffixes) {\n-        return findFiles(dir).map(TextFile::new).filter(textFile -> textFile.hasSuffix(suffixes));\n+    public static Stream<SearchableTextFile> findTextFiles(Path dir, String... suffixes) {\n+        return findFiles(dir).map(SearchableTextFile::new).filter(searchableTextFile -> searchableTextFile.hasSuffix(suffixes));\n@@ -596,0 +639,28 @@\n+    public static abstract class ExecBuilder<T extends ExecBuilder<T>> extends Builder<T> {\n+        abstract public List<String> execOpts();\n+\n+        public void execInheritIO(Path path) {\n+            try {\n+                var processBuilder = new ProcessBuilder();\n+\n+                if (path != null) {\n+                    processBuilder.directory(path.toFile());\n+                }\n+                processBuilder\n+                        .inheritIO()\n+                        .command(execOpts());\n+                var process = processBuilder\n+                        .start();\n+                process.waitFor();\n+            } catch (InterruptedException ie) {\n+                System.out.println(ie);\n+            } catch (IOException ioe) {\n+                System.out.println(ioe);\n+            }\n+        }\n+\n+        public void execInheritIO() {\n+            execInheritIO(null);\n+        }\n+    }\n+\n@@ -598,1 +669,1 @@\n-        public List<Path> sourcePath;\n+        public List<Path> sourcePath ;\n@@ -623,1 +694,1 @@\n-            this.sourcePath = this.sourcePath==null?new ArrayList<>():this.sourcePath;\n+            this.sourcePath = this.sourcePath == null ? new ArrayList<>() : this.sourcePath;\n@@ -629,1 +700,1 @@\n-            this.classPath = this.classPath==null?new ArrayList<>():this.classPath;\n+            this.classPath = this.classPath == null ? new ArrayList<>() : this.classPath;\n@@ -667,2 +738,5 @@\n-            var src = new ArrayList<Path>();\n-            javacBuilder.sourcePath.forEach(entry -> findFiles(entry, file -> file.toString().endsWith(\".java\")).forEach(src::add));\n+            var compilationUnits = new ArrayList<JavaSourceFile>();\n+            javacBuilder.sourcePath.forEach(entry ->\n+                    findFiles(entry, file -> file.toString().endsWith(\".java\"))\n+                            .map(JavaSourceFile::new)\n+                            .forEach(compilationUnits::add));\n@@ -677,1 +751,1 @@\n-         \/\/   List<RootAndPath> pathsToJar = new ArrayList<>();\n+            \/\/   List<RootAndPath> pathsToJar = new ArrayList<>();\n@@ -679,10 +753,0 @@\n-            var compilationUnits = src.stream().map(path ->\n-                    new SimpleJavaFileObject(path.toUri(), JavaFileObject.Kind.SOURCE) {\n-                        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                            try {\n-                                return Files.readString(Path.of(toUri()));\n-                            } catch (IOException e) {\n-                                throw new RuntimeException(e);\n-                            }\n-                        }\n-                    }).toList();\n@@ -700,1 +764,1 @@\n-                    \/\/.forEach(fileObject -> pathsToJar.add(new RootAndPath(javacBuilder.classesDir, Path.of(fileObject.toUri()))));\n+            \/\/.forEach(fileObject -> pathsToJar.add(new RootAndPath(javacBuilder.classesDir, Path.of(fileObject.toUri()))));\n@@ -794,1 +858,335 @@\n-    public static class CMakeBuilder extends Builder<CMakeBuilder> {\n+    public static class JavaBuilder extends ExecBuilder<JavaBuilder> {\n+        public Path jdk = Path.of(System.getProperty(\"java.home\"));\n+        public String mainClass;\n+        public List<Path> classPath;\n+        public List<String> vmopts = new ArrayList<>();\n+        public List<String> args = new ArrayList<>();\n+\n+        public JavaBuilder vmopts(List<String> opts) {\n+            this.vmopts.addAll(opts);\n+            return self();\n+        }\n+\n+        public JavaBuilder vmopts(String... opts) {\n+            vmopts(Arrays.asList(opts));\n+            return self();\n+        }\n+\n+\n+        public JavaBuilder args(List<String> opts) {\n+            this.args.addAll(opts);\n+            return self();\n+        }\n+\n+        public JavaBuilder args(String... opts) {\n+            args(Arrays.asList(opts));\n+            return self();\n+        }\n+\n+\n+        public JavaBuilder basedOn(JavaBuilder stem) {\n+            super.basedOn(stem);\n+            if (stem != null) {\n+                vmopts.addAll(stem.vmopts);\n+                args.addAll(stem.args);\n+                if (stem.mainClass != null) {\n+                    this.mainClass = stem.mainClass;\n+                }\n+                if (stem.jdk != null) {\n+                    this.jdk = stem.jdk;\n+                }\n+                if (stem.classPath != null) {\n+                    this.classPath = new ArrayList<>(stem.classPath);\n+                }\n+\n+                opts.addAll(stem.opts);\n+\n+            }\n+            return this;\n+        }\n+\n+        public JavaBuilder main_class(String mainClass) {\n+            this.mainClass = mainClass;\n+            return this;\n+        }\n+\n+        public JavaBuilder jdk(Path jdk) {\n+            this.jdk = jdk;\n+            return this;\n+        }\n+\n+        public JavaBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n+            JavacBuilder javacBuilder = new JavacBuilder();\n+            javacBuilderConsumer.accept(javacBuilder);\n+            var result = Bldr.javac(javacBuilder);\n+            classPath = (classPath == null) ? new ArrayList<>() : classPath;\n+            classPath.add(result.classesDir);\n+            return this;\n+        }\n+        public JavaBuilder class_path(List<Path> classPathEntries) {\n+            this.classPath = (this.classPath == null) ? new ArrayList<>() : this.classPath;\n+            this.classPath.addAll(classPathEntries);\n+            return this;\n+        }\n+\n+        public JavaBuilder class_path(Path... classPathEntries) {\n+            return this.class_path(List.of(classPathEntries));\n+        }\n+\n+        @Override\n+        public List<String> execOpts() {\n+            List<String> execOpts = new ArrayList<>();\n+            execOpts.add(jdk.resolve(\"bin\/java\").toString());\n+            execOpts.addAll(vmopts);\n+            if (classPath != null) {\n+                execOpts.addAll(List.of(\"--class-path\", pathCharSeparated(classPath)));\n+            }\n+            execOpts.add(mainClass);\n+            execOpts.addAll(args);\n+            return execOpts;\n+        }\n+    }\n+    public static JavaBuilder java(JavaBuilder javaBuilder) {\n+        javaBuilder.execInheritIO();\n+        return javaBuilder;\n+    }\n+\n+    public static JavaBuilder java(Consumer<JavaBuilder> javaBuilderConsumer) {\n+        JavaBuilder javaBuilder = new JavaBuilder();\n+        javaBuilderConsumer.accept(javaBuilder);\n+        return java(javaBuilder);\n+    }\n+\n+\n+    public static class CMake {\n+        record Regex(Pattern pattern) {\n+            Regex(String regex) {\n+                this(Pattern.compile(regex));\n+            }\n+\n+            boolean matches(String text, Consumer<Matcher> matcherConsumer) {\n+                if (pattern().matcher(text) instanceof Matcher matcher && matcher.matches()) {\n+                    matcherConsumer.accept(matcher);\n+                    return true;\n+                } else {\n+                    return false;\n+                }\n+            }\n+\n+        }\n+\n+        public interface CMakeVar {\n+            String name();\n+\n+            String value();\n+        }\n+\n+        public record CMakeTypedVar(String name, String type, String value, String comment) implements CMakeVar {\n+            static final Regex regex = new Regex(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+):([^=]*)=(.*)$\");\n+\n+            CMakeTypedVar(Matcher matcher, String comment) {\n+                this(\"CMAKE_\" + matcher.group(1).trim(), matcher.group(2).trim(), matcher.group(3).trim(), comment.substring(2).trim());\n+            }\n+\n+            static boolean onMatch(String line, String comment, Consumer<CMakeTypedVar> consumer) {\n+                return regex.matches(line, matcher -> consumer.accept(new CMakeTypedVar(matcher, comment)));\n+            }\n+        }\n+\n+        public record CMakeSimpleVar(String name, String value) implements CMakeVar {\n+            static final Regex regex = new Regex(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n+\n+            CMakeSimpleVar(Matcher matcher) {\n+                this(\"CMAKE_\" + matcher.group(1).trim(), (matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim());\n+            }\n+\n+            static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n+                return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n+            }\n+        }\n+\n+        public record CMakeContentVar(String name, String value) implements CMakeVar {\n+            static final Regex startRegex = new Regex(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)$\");\n+            static final Regex endRegex = new Regex(\"^(.*)\\\\}>\\\\}$\");\n+\n+        }\n+\n+        public record CMakeRecipeVar(String name, String value) implements CMakeVar {\n+            static final Regex varPattern = new Regex(\"<([^>]*)>\");\n+            static final Regex regex = new Regex(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{<(.*)>\\\\}>\\\\}$\");\n+\n+            CMakeRecipeVar(Matcher matcher) {\n+                this(\"CMAKE_\" + matcher.group(1).trim(), \"<\" + ((matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim()) + \">\");\n+            }\n+\n+            public String expandRecursively(Map<String, CMakeVar> varMap, String value) { \/\/ recurse\n+                String result = value;\n+                if (varPattern.pattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n+                    var v = matcher.group(1);\n+                    if (varMap.containsKey(v)) {\n+                        String replacement = varMap.get(v).value();\n+                        result = expandRecursively(varMap,\n+                                value.substring(0, matcher.start()) + replacement + value.substring(matcher.end()));\n+                    }\n+                }\n+                return result;\n+            }\n+\n+\n+            public String expand(Map<String, CMakeVar> vars) {\n+                return expandRecursively(vars, value());\n+            }\n+\n+            static boolean onMatch(String line, String comment, Consumer<CMakeRecipeVar> consumer) {\n+                return regex.matches(line, matcher -> consumer.accept(new CMakeRecipeVar(matcher)));\n+            }\n+        }\n+\n+        Path dir;\n+        String[] packages;\n+        Map<String, CMakeVar> varMap = new HashMap<>();\n+\n+        CMake(Path _dir, String... packages) {\n+            this.dir = _dir.resolve(\"cmakeprobe\");\n+            mkdir(rmdir(this.dir));\n+            this.packages = packages;\n+\n+            try {\n+                Files.createDirectories(this.dir);\n+                var CMakeListsTxt = new StringBuilder(\n+                        \"\"\"\n+                                cmake_minimum_required(VERSION 3.21)\n+                                project(cmakeprobe)\n+                                set(CMAKE_CXX_STANDARD 14)\n+\n+                                get_cmake_property(VarNames VARIABLES)\n+                                #set(VARS_FILE ${CMAKE_SOURCE_DIR}\/vars.txt)\n+\n+                                #file(WRITE ${VARS_FILE} \"\")\n+                                foreach(VarName ${VarNames})\n+                                    message(\"${VarName}={<{${${VarName}}}>}\\n\")\n+                                endforeach()\n+                                \"\"\");\n+\n+                Stream.of(packages).forEach(p ->\n+                        CMakeListsTxt.append(\"find_package(\").append(p).append(\")\\n\"));\n+                Files.writeString(this.dir.resolve(\"CMakeLists.txt\"), CMakeListsTxt.toString());\n+                var cmakeProcessBuilder = new ProcessBuilder()\n+                        .directory(this.dir.toFile())\n+                        .redirectErrorStream(true)\n+                        .command(\"cmake\", \"-LAH\")\n+                        .start();\n+                List<String> lines = new BufferedReader(new InputStreamReader(cmakeProcessBuilder.getInputStream())).lines().toList();\n+\n+                String comment = null;\n+                String contentName = null;\n+                StringBuilder content = null;\n+\n+                for (String line : lines) {\n+                    if (line.startsWith(\"\/\/\")) {\n+                        comment = line;\n+                        content = null;\n+\n+                    } else if (comment != null) {\n+                        if (CMakeTypedVar.onMatch(line, comment, v -> {\n+                            if (varMap.containsKey(v.name())) {\n+                                var theVar = varMap.get(v.name());\n+                                if (theVar.value().equals(v.value())) {\n+                                    println(\"replacing duplicate variable with typed variant with the name same value\" + v + theVar);\n+                                } else {\n+                                    throw new IllegalStateException(\"Duplicate variable name different value: \" + v + theVar);\n+                                }\n+                                varMap.put(v.name(), v);\n+                            } else {\n+                                varMap.put(v.name(), v);\n+                            }\n+                        })) {\n+                        } else {\n+                            println(\"failed to parse \" + line);\n+                        }\n+                        comment = null;\n+                        content = null;\n+                        contentName = null;\n+                    } else if (!line.isEmpty()) {\n+                        if (content != null) {\n+                            if (CMakeContentVar.endRegex.pattern().matcher(line) instanceof Matcher matcher && matcher.matches()) {\n+                                content.append(\"\\n\").append(matcher.group(1));\n+                                var v = new CMakeContentVar(contentName, content.toString());\n+                                contentName = null;\n+                                content = null;\n+                                varMap.put(v.name(), v);\n+                            } else {\n+                                content.append(\"\\n\").append(line);\n+                            }\n+                        } else if (!line.endsWith(\"}>}\") && CMakeContentVar.startRegex.pattern().matcher(line) instanceof Matcher matcher && matcher.matches()) {\n+                            contentName = \"CMAKE_\" + matcher.group(1);\n+                            content = new StringBuilder(matcher.group(2));\n+                        } else if (CMakeRecipeVar.regex.pattern().matcher(line) instanceof Matcher matcher && matcher.matches()) {\n+                            CMakeVar v = new CMakeRecipeVar(matcher);\n+                            if (varMap.containsKey(v.name())) {\n+                                var theVar = varMap.get(v.name());\n+                                if (theVar.value().equals(v.value())) {\n+                                    println(\"Skipping duplicate variable name different value: \" + v + theVar);\n+                                } else {\n+                                    throw new IllegalStateException(\"Duplicate variable name different value: \" + v + theVar);\n+                                }\n+                                varMap.put(v.name(), v);\n+                            } else {\n+                                varMap.put(v.name(), v);\n+                            }\n+                        } else if (CMakeSimpleVar.regex.pattern().matcher(line) instanceof Matcher matcher && matcher.matches()) {\n+                            CMakeVar v = new CMakeSimpleVar(matcher);\n+                            if (varMap.containsKey(v.name())) {\n+                                var theVar = varMap.get(v.name());\n+                                if (theVar.value().equals(v.value())) {\n+                                    println(\"Skipping duplicate variable name different value: \" + v + theVar);\n+                                } else {\n+                                    throw new IllegalStateException(\"Duplicate variable name vifferent vars: \" + v + theVar);\n+                                }\n+                                \/\/ note we don't replace a Typed with a Simple\n+                            } else {\n+                                varMap.put(v.name(), v);\n+                            }\n+                        } else {\n+                            println(\"Skipping \" + line);\n+                        }\n+                    }\n+                }\n+\n+            } catch (IOException ioe) {\n+                throw new RuntimeException(ioe);\n+            }\n+        }\n+\n+        Path cxxCompileObject(Path target, Path source, List<String> frameworks) {\n+            CMakeRecipeVar compileObject = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_COMPILE_OBJECT\");\n+            Map<String, CMakeVar> localVars = new HashMap<>(varMap);\n+            localVars.put(\"DEFINES\", new CMakeSimpleVar(\"DEFINES\", \"\"));\n+            localVars.put(\"INCLUDES\", new CMakeSimpleVar(\"INCLUDES\", \"\"));\n+            localVars.put(\"FLAGS\", new CMakeSimpleVar(\"FLAGS\", \"\"));\n+            localVars.put(\"OBJECT\", new CMakeSimpleVar(\"OBJECT\", target.toString()));\n+            localVars.put(\"SOURCE\", new CMakeSimpleVar(\"SOURCE\", source.toString()));\n+            String executable = compileObject.expand(localVars);\n+            println(executable);\n+            return target;\n+        }\n+\n+        Path cxxLinkExecutable(Path target, List<Path> objFiles, List<String> frameworks) {\n+            CMakeRecipeVar linkExecutable = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_LINK_EXECUTABLE\");\n+            Map<String, CMakeVar> localVars = new HashMap<>(varMap);\n+            String executable = linkExecutable.expand(localVars);\n+            println(executable);\n+            return target;\n+        }\n+\n+        Path cxxcreateSharedLibrary(Path target, List<Path> objFiles, List<String> frameworks) {\n+            CMakeRecipeVar createSharedLibrary = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_CREATE_SHARED_LIBRARY\");\n+            Map<String, CMakeVar> localVars = new HashMap<>(varMap);\n+            String executable = createSharedLibrary.expand(localVars);\n+            println(executable);\n+            return target;\n+        }\n+\n+    }\n+\n+    public static class CMakeBuilder extends ExecBuilder<CMakeBuilder> {\n@@ -798,1 +1196,0 @@\n-        \/\/ public Path cwd;\n@@ -814,3 +1211,0 @@\n-                \/\/  if (stem.cwd != null) {\n-                \/\/    this.cwd = stem.cwd;\n-                \/\/ }\n@@ -845,6 +1239,4 @@\n-        \/\/  public CMakeBuilder cwd(Path cwd) {\n-        \/\/     this.cwd = cwd;\n-        \/\/    return this;\n-        \/\/ }\n-\n-\n+        @Override\n+        public List<String> execOpts() {\n+            return opts;\n+        }\n@@ -857,0 +1249,1 @@\n+\n@@ -859,9 +1252,1 @@\n-            \/\/System.out.println(cmakeConfig.opts);\n-            var cmakeProcessBuilder = new ProcessBuilder()\n-                    \/\/ .directory(cmakeBuilder.cwd.toFile())\n-                    .inheritIO()\n-                    .command(cmakeBuilder.opts)\n-                    .start();\n-            cmakeProcessBuilder.waitFor();\n-        } catch (InterruptedException ie) {\n-            System.out.println(ie);\n+            cmakeBuilder.execInheritIO();\n@@ -869,1 +1254,1 @@\n-            System.out.println(ioe);\n+            throw new IllegalStateException(ioe);\n@@ -873,1 +1258,32 @@\n-    public static class JExtractBuilder extends Builder<JExtractBuilder> {\n+\n+    static Path unzip(Path in, Path dir) {\n+        try {\n+            Files.createDirectories(dir);\n+            ZipFile zip = new ZipFile(in.toFile());\n+            zip.entries().asIterator().forEachRemaining(entry -> {\n+                try {\n+                    String currentEntry = entry.getName();\n+\n+                    Path destFile = dir.resolve(currentEntry);\n+                    \/\/destFile = new File(newPath, destFile.getName());\n+                    Path destinationParent = destFile.getParent();\n+                    Files.createDirectories(destinationParent);\n+                    \/\/ create the parent directory structure if needed\n+\n+\n+                    if (!entry.isDirectory()) {\n+                        zip.getInputStream(entry).transferTo(Files.newOutputStream(destFile));\n+                    }\n+                } catch (IOException ioe) {\n+                    throw new RuntimeException(ioe);\n+                }\n+            });\n+            zip.close();\n+\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return dir;\n+    }\n+\n+    public static class JExtractBuilder extends ExecBuilder<JExtractBuilder> {\n@@ -959,10 +1375,0 @@\n-    }\n-\n-\n-    static Path unzip(Path in, Path dir) {\n-        try {\n-            Files.createDirectories(dir);\n-            ZipFile zip = new ZipFile(in.toFile());\n-            zip.entries().asIterator().forEachRemaining(entry -> {\n-                try {\n-                    String currentEntry = entry.getName();\n@@ -970,18 +1376,3 @@\n-                    Path destFile = dir.resolve(currentEntry);\n-                    \/\/destFile = new File(newPath, destFile.getName());\n-                    Path destinationParent = destFile.getParent();\n-                    Files.createDirectories(destinationParent);\n-                    \/\/ create the parent directory structure if needed\n-\n-\n-                    if (!entry.isDirectory()) {\n-                        zip.getInputStream(entry).transferTo(Files.newOutputStream(destFile));\n-                    }\n-                } catch (IOException ioe) {\n-                    throw new RuntimeException(ioe);\n-                }\n-            });\n-            zip.close();\n-\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n+        @Override\n+        public List<String> execOpts() {\n+            return opts;\n@@ -989,1 +1380,0 @@\n-        return dir;\n@@ -1001,1 +1391,0 @@\n-\n@@ -1003,6 +1392,1 @@\n-            var jextractProcessBuilder = new ProcessBuilder()\n-                    .directory(extractConfig.cwd.toFile())\n-                    .inheritIO()\n-                    .command(extractConfig.opts)\n-                    .start();\n-            jextractProcessBuilder.waitFor();\n+            extractConfig.execInheritIO(extractConfig.cwd);\n@@ -1012,2 +1396,0 @@\n-        } catch (InterruptedException ie) {\n-            System.out.println(ie);\n@@ -1025,1 +1407,1 @@\n-    public record TextFile(Path path) {\n+    public record SearchableTextFile(Path path) implements TextFile {\n@@ -1388,3 +1770,1 @@\n-    public static void withExpectedDirectory(Path parent, String subDirName, Consumer<Path> pathConsumer) {\n-        withExpectedDirectory(parent.resolve(subDirName), pathConsumer);\n-    }\n+    public record Root(Path path) implements DirPathHolder {\n@@ -1392,3 +1772,0 @@\n-    public static boolean withOptionalDirectory(Path parent, String subDirName, Consumer<Path> pathConsumer) {\n-        return withOptionalDirectory(parent.resolve(subDirName), pathConsumer);\n-    }\n@@ -1396,1 +1773,0 @@\n-    public record Root(Path path) {\n@@ -1398,1 +1774,1 @@\n-            return mkdir(path.resolve(\"build\"));\n+            return mkdir(subDir(\"build\"));\n@@ -1402,1 +1778,1 @@\n-            return mkdir(path.resolve(\"thirdparty\"));\n+            return mkdir(subDir(\"thirdparty\"));\n@@ -1406,1 +1782,1 @@\n-            return mkdir(path.resolve(\"repoDir\"));\n+            return mkdir(subDir(\"repoDir\"));\n@@ -1468,5 +1844,5 @@\n-                        .forEach(textFile -> {\n-                            if (!textFile.hasSuffix(\"md\")\n-                                    && !textFile.path().startsWith(rleParserDir)\n-                                    && !textFile.grep(Pattern.compile(\"^.*Copyright.*202[4-9].*(Intel|Oracle).*$\"))) {\n-                                System.err.println(\"ERR MISSING LICENSE \" + textFile.path());\n+                        .forEach(searchableTextFile -> {\n+                            if (!searchableTextFile.path().getFileName().toString().equals(\"Makefile\") && !searchableTextFile.hasSuffix(\"md\")\n+                                    && !searchableTextFile.path().startsWith(rleParserDir)\n+                                    && !searchableTextFile.grep(Pattern.compile(\"^.*Copyright.*202[4-9].*(Intel|Oracle).*$\"))) {\n+                                System.err.println(\"ERR MISSING LICENSE \" + searchableTextFile.path());\n@@ -1474,3 +1850,3 @@\n-                            textFile.lines().forEach(line -> {\n-                                if (line.grep(Pattern.compile(\"^.*\\\\t.*\"))) {\n-                                    System.err.println(\"ERR TAB \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n+                            searchableTextFile.lines().forEach(line -> {\n+                                if (!searchableTextFile.path().getFileName().toString().startsWith(\"Makefile\") && line.grep(Pattern.compile(\"^.*\\\\t.*\"))) {\n+                                    System.err.println(\"ERR TAB \" + searchableTextFile.path() + \":\" + line.line() + \"#\" + line.num());\n@@ -1479,1 +1855,1 @@\n-                                    System.err.println(\"ERR TRAILING WHITESPACE \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n+                                    System.err.println(\"ERR TRAILING WHITESPACE \" + searchableTextFile.path() + \":\" + line.line() + \"#\" + line.num());\n@@ -1486,0 +1862,8 @@\n+    public static <T> T assertOrThrow(T testme, Predicate<T> predicate, String message){\n+        if (predicate.test(testme)) {\n+            return testme;\n+        }else{\n+            throw new IllegalStateException(\"FAILED: \"+message+\" \"+testme);\n+        }\n+    }\n+\n@@ -1489,0 +1873,14 @@\n+\n+        \/\/ varMap.entrySet().forEach(value->println(\"+\"+value) );\n+        var cmake = new CMake(hatDir.buildDir(), \"OpenCL\", \"CUDAToolkit\", \"OpenGL\", \"GLUT\");\n+        var clinfoObj = cmake.cxxCompileObject(\n+                hatDir.buildDir().resolve(\"clinfo.cpp.o\"),\n+                hatDir.path().resolve(\"backends\/opencl\/cpp\/clinfo.cpp\"),\n+                List.of(\"OpenCL\")\n+        );\n+        var clinfo = cmake.cxxLinkExecutable(\n+                hatDir.buildDir().resolve(\"clinfo\"),\n+                List.of(clinfoObj),\n+                List.of(\"OpenCL\")\n+        );\n+        \/\/ System.exit(1);\n@@ -1519,1 +1917,1 @@\n-        withExpectedDirectory(hatDir.path(), \"hat\", hatProjectDir -> {\n+        withExpectedDirectory(hatDir.subDir(\"hat\"), hatProjectDir -> {\n@@ -1531,1 +1929,1 @@\n-            withExpectedDirectory(hatDir.path(), \"backends\", backendsDir -> {\n+            withExpectedDirectory(hatDir.subDir(\"backends\"), backendsDir -> {\n@@ -1553,0 +1951,1 @@\n+            assertOrThrow(hatDir.path.resolve(\"examples\"), Files::isDirectory, \"Examples Dir\" );\n@@ -1554,1 +1953,1 @@\n-            withExpectedDirectory(hatDir.path, \"examples\", examplesDir ->\n+            withExpectedDirectory(hatDir.subDir(\"examples\"), examplesDir ->\n@@ -1561,1 +1960,1 @@\n-            withOptionalDirectory(hatDir.path, \"hattricks\", hattricksDir -> {\n+            withOptionalDirectory(hatDir.subDir(\"hattricks\"), hattricksDir -> {\n@@ -1568,1 +1967,1 @@\n-                withOptionalDirectory(hattricksDir, \"nbody\", nbody -> {\n+                withOptionalDirectory(hattricksDir.resolve(\"nbody\"), nbody -> {\n@@ -1578,4 +1977,4 @@\n-                                .when(os.isMac(), $$$ -> $$$\n-                                        .compile_flag(\"-F\" + os.macAppLibFrameworks())\n-                                        .library(os.macFramework(\"OpenCL.framework\/OpenCL\"))\n-                                        .header(os.macFrameworkHeaderFile(\"OpenCL.framework\/Headers\/opencl.h\"))\n+                                .when(os instanceof OS.Mac, $$$ -> $$$\n+                                        .compile_flag(\"-F\" + ((OS.Mac) os).appLibFrameworks())\n+                                        .library(((OS.Mac) os).frameworkLibrary(\"OpenCL\"))\n+                                        .header(((OS.Mac) os).frameworkHeader(\"OpenCL\", \"opencl.h\"))\n@@ -1593,2 +1992,2 @@\n-                                .when(os.isMac(), $$$ -> $$$\n-                                        .compile_flag(\"-F\" + os.macAppLibFrameworks())\n+                                .when(os instanceof OS.Mac, $$$ -> $$$\n+                                        .compile_flag(\"-F\" + ((OS.Mac) os).libFrameworks())\n@@ -1596,2 +1995,2 @@\n-                                                os.macFramework(\"GLUT.framework\/GLUT\"),\n-                                                os.macFramework(\"OpenGL.framework\/OpenGL\")\n+                                                ((OS.Mac) os).frameworkLibrary(\"GLUT\"),\n+                                                ((OS.Mac) os).frameworkLibrary(\"OpenGL\")\n@@ -1599,1 +1998,1 @@\n-                                        .header(os.macFrameworkHeaderFile(\"GLUT.framework\/Headers\/glut.h\"))\n+                                        .header(((OS.Mac) os).frameworkHeader(\"GLUT\", \"glut.h\"))\n@@ -1601,0 +2000,3 @@\n+                                .when(os instanceof OS.Linux, $$$ -> {\n+\n+                                })\n@@ -1604,1 +2006,1 @@\n-                    jar($ -> $\n+                    var nbodyJar = jar($ -> $\n@@ -1611,0 +2013,12 @@\n+\n+                    java($ -> $\n+                            .jdk(Path.of(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/build\/macosx-aarch64-server-release\/jdk\"))\n+                            .vmopts(\n+                                    \"--enable-preview\",\n+                                    \"--enable-native-access=ALL-UNNAMED\",\n+                                    \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+                                    \"-XstartOnFirstThread\"\n+                            )\n+                            .class_path(nbodyJar.jar)\n+                            .main_class(\"nbody.Main\")\n+                    );\n","filename":"hat\/bldr\/src\/main\/java\/bldr\/Bldr.java","additions":564,"deletions":150,"binary":false,"changes":714,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-   # We just bail if it was not sourced.. We want to set PATH and JAVA_HOME...\n+   # We just bail if it was not sourced.. We want to set AND export PATH and JAVA_HOME...\n@@ -37,1 +37,1 @@\n-   exit 1;  # this is ok because we were sourced \n+   exit 1;  # this is ok because we were not sourced \n@@ -39,1 +39,3 @@\n-  # Don't exit below here or you will trash the users shell ;)\n+\n+  # We were indeed sourced so don't exit below here or we will trash the users shell ;)\n+  #    possibly loging them out \n@@ -64,1 +66,4 @@\n-    # We expect the user to provide a value for BABYLON_JDK_HOME or we can locate one using ${PWD}\/..\n+    # We expect either \n+    #   The user provided a value for BABYLON_JDK_HOME\n+    # or\n+    #   We can locate one because we are a subdir of BABYLON using ${PWD}\/..\n@@ -66,1 +71,0 @@\n-    # below is a verbose version of \n@@ -70,1 +74,1 @@\n-       echo \"No user supplied BABYLON_JDK_HOME var, we will try \\${PWD}\/.. = $(realpath ${PWD}\/..)\"\n+       echo \"No user provided BABYLON_JDK_HOME var, we will try \\${PWD}\/.. = $(realpath ${PWD}\/..)\"\n@@ -78,1 +82,1 @@\n-      echo \"\\${BABYLON_JDK_HOME}\/build seems ok!\"\n+      #echo \"\\${BABYLON_JDK_HOME}\/build seems ok!\"\n@@ -80,1 +84,1 @@\n-      echo \"exporting JAVA_HOME=${JAVA_HOME}\"\n+      #echo \"exporting JAVA_HOME=${JAVA_HOME}\"\n@@ -82,1 +86,1 @@\n-         echo \"PATH already contains \\${JAVA_HOME}\/bin\"\n+         #echo \"PATH already contains \\${JAVA_HOME}\/bin\"\n@@ -89,2 +93,6 @@\n-      # Our java source launcher based build system needs bldr.bldr.jar so we create it here if needed. \n-      if [[ -f bldr\/bldr.jar ]]; then \n+      if [[ ${1} = \"clean\" ]]; then \n+         rm -rf bldr\/bldr.classes bldr\/bldr.jar build maven-build thirdparty repoDir\n+      fi \n+\n+      # Our java source launcher based build system needs bldr\/bldr.jar so we create it here if needed. \n+      if [[ ${1} != \"clean\" && -f bldr\/bldr.jar ]]; then \n@@ -94,1 +102,1 @@\n-         echo \"Bootrapping bldr.jar\"\n+         echo \"Bootrapping a build of bldr.jar\"\n","filename":"hat\/env.bash","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/\/usr\/bin\/env java --enable-preview --source 24 --class-path bldr\/bldr.jar \"$0\" \"$@\"; exit $?\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static bldr.Bldr.*;           \/\/ all the helpers are here \n+import static java.nio.file.Files.*; \/\/ so we can use isDirectory(path);\n+\n+void main(String[] args) {\n+   var hatDir = new Root();\n+   if (args.length==0){\n+      println(\"\"\"\n+              usage:\n+                 hatrun [headless] backend package args ...\n+                 headless : Optional passes -Dheadless=true to app\n+                 backend  : opencl|cuda|spirv|ptx|mock\n+                 package  : the examples package (and dirname under hat\/examples)\n+                 Class name is assumed to be package.Main \n+              \"\"\");\n+      System.exit(1);\n+   } else{\n+     var buildDir = assertOrThrow(hatDir.buildDir(), Files::isDirectory, \"Build Directory\");\n+     \n+     int argc=0;\n+     boolean headless = args[argc].equals(\"headless\");\n+     if (headless){\n+        argc++;\n+     }\n+     if (argc<args.length \n+           && hatDir.path().resolve(\"backends\") instanceof Path backendsDir && Files.isDirectory(backendsDir)){\n+        var classPath = new ArrayList<>(List.of(buildDir.resolve(\"hat-1.0.jar\")));\n+        var backendDir = backendsDir.resolve(args[argc++]);\n+        if (argc<args.length && (Files.isDirectory(backendDir) || backendDir.getFileName().toString().equals(\"java\"))){\n+           if (Files.isDirectory(backendDir)){\n+              classPath.add(assertOrThrow(buildDir.resolve(\"hat-backend-\"+backendDir.getFileName()+\"-1.0.jar\"), Files::isRegularFile,\" backend dir\"));\n+           }else{\n+              classPath.add(assertOrThrow(backendsDir.resolve(\"shared\/src\/main\/resources\"), Files::isDirectory, \"backend dir\"));\n+           }\n+           if (argc<args.length &&\n+                assertOrThrow(hatDir.path().resolve(\"examples\"), Files::isDirectory, \"Examples Dir\") instanceof Path examplesDir){\n+              var exampleDir = assertOrThrow(examplesDir.resolve(args[argc++]), Files::isDirectory, \"Example dir\");\n+              classPath.add(assertOrThrow(buildDir.resolve(\"hat-example-\"+exampleDir.getFileName()+\"-1.0.jar\"), Files::isRegularFile,\" example jar \"));\n+              final int finalArgc = argc; \/\/sigh\n+              \n+              java($->$\n+                 .vmopts(\n+                   \"--enable-preview\",\n+                   \"--enable-native-access=ALL-UNNAMED\",\n+                   \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+                   \"-Djava.library.path=build:\/usr\/local\/lib\"\n+                 )\n+                 .when(headless, $$->$$\n+                    .vmopts(\"-Dheadless=true\")\n+                 )\n+                 .class_path(classPath)\n+                 .main_class(exampleDir.getFileName() + \".Main\")\n+                 .args(Arrays.copyOfRange(args, finalArgc, args.length))\n+              );\n+ \n+           }else{\n+              println(\"no example\");\n+           }\n+        }else{\n+           println(\"no backend\");\n+        }\n+     }else{\n+        println(\"junk\");\n+     }\n+\n+   }\n+}\n","filename":"hat\/hatrun","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+#!\/bin\/bash \n@@ -28,29 +29,0 @@\n-function example(){\n-   echo $*\n-   headless=$1\n-   backend=$2\n-   example=$3\n-   shift 3\n-   if test -d build; then\n-      echo using build dir\n-      build_dir=build\n-   else\n-      echo no build dir!\n-      exit 1\n-   fi\n-   if test \"${backend}\" =  \"java\"; then\n-       backend_jar=backends\/shared\/src\/main\/resources\n-   else\n-       backend_jar=${build_dir}\/hat-backend-${backend}-1.0.jar\n-   fi\n-   echo checking backend_jar = ${backend_jar}\n-   if test -f ${backend_jar} -o -d ${backend_jar} ;then\n-      example_jar=${build_dir}\/hat-example-${example}-1.0.jar\n-      case ${example} in\n-        nbody)\n-           extraVmOpts=-XstartOnFirstThread;;\n-      esac\n-      case ${backend} in\n-        spirv)\n-           extraJars=:${build_dir}\/levelzero.jar:${build_dir}\/beehive-spirv-lib-0.0.4.jar;;\n-      esac\n@@ -58,25 +30,0 @@\n-      echo checking example_jar = ${example_jar}\n-      if test -f ${example_jar} ; then\n-         echo ${JAVA_HOME}\/bin\/java \\\n-            --enable-preview --enable-native-access=ALL-UNNAMED \\\n-            ${extraVmOpts} \\\n-            --class-path ${build_dir}\/hat-1.0.jar:${example_jar}:${backend_jar}${extraJars} \\\n-            --add-exports=java.base\/jdk.internal=ALL-UNNAMED \\\n-            -Djava.library.path=${build_dir}:\/usr\/local\/lib \\\n-            -Dheadless=${headless} \\\n-            ${example}.Main $*\n-         ${JAVA_HOME}\/bin\/java \\\n-            --enable-preview --enable-native-access=ALL-UNNAMED \\\n-            ${extraVmOpts} \\\n-            --class-path ${build_dir}\/hat-1.0.jar:${example_jar}:${backend_jar}${extraJars} \\\n-            --add-exports=java.base\/jdk.internal=ALL-UNNAMED \\\n-            -Djava.library.path=${build_dir}:\/usr\/local\/lib \\\n-            -Dheadless=${headless} \\\n-            ${example}.Main $*\n-      else\n-         echo no such example example_jar = ${example_jar}\n-      fi\n-   else\n-      echo no such backend backend_jar = ${backend_jar}\n-   fi\n-}\n@@ -88,1 +35,0 @@\n-   echo '       package  : the examples package (and dirname under hat\/examples)'\n@@ -90,0 +36,1 @@\n+   echo '       package  : the examples package (and dirname under hat\/examples)'\n@@ -91,3 +38,38 @@\n-else\n-   if [ $1 == headless ]; then\n-      echo headless!\n+elif [[ -d build ]] ; then\n+   export OPTS=\"\" \n+   export VMOPTS=\"\"\n+   export JARS=\"\" \n+\n+   export VMOPTS=\"${VMOPTS} --enable-preview\"\n+   export VMOPTS=\"${VMOPTS} --enable-native-access=ALL-UNNAMED\"\n+   export VMOPTS=\"${VMOPTS} --add-exports=java.base\/jdk.internal=ALL-UNNAMED\"\n+\n+   export HEADLESS=\"${1}\"\n+   if [[ \"${HEADLESS}\" = \"headless\" ]] ; then\n+      echo HEADLESS=${HEADLESS}\n+      shift 1  \n+      export OPTS=\"${OPTS} -Dheadless=true\"\n+   else \n+      echo \"Not headless\"\n+   fi\n+\n+   export BACKEND=\"${1}\"\n+   echo BACKEND=${BACKEND}\n+   if [[ -d backends\/$1 || \"$1\" = \"java\" ]] ; then\n+      export JARS=build\/hat-1.0.jar\n+      if [[ \"$1\" = \"java\" ]] ; then \n+         export BACKEND_JAR_or_DIR=backends\/shared\/src\/main\/resources\n+         echo BACKEND_JAR_or_DIR=${BACKEND_JAR_or_DIR}\n+      else\n+         export BACKEND_JAR_or_DIR=build\/hat-backend-${BACKEND}-1.0.jar\n+         echo BACKEND_JAR_or_DIR=${BACKEND_JAR_or_DIR}\n+         if [[ ! -f ${BACKEND_JAR_or_DIR} ]] ;then\n+            echo \"no backend ${BACKEND_JAR_or_DIR}\"\n+            exit 1\n+         fi\n+      fi\n+      export JARS=${JARS}:${BACKEND_JAR_or_DIR}\n+      if [[ \"$1\" = \"spirv\" ]] ;then \n+         export JARS=${JARS}:build\/levelzero.jar:build\/beehive-spirv-lib-0.0.4.jar;\n+      fi\n+      export OPTS=\"${OPTS} -Djava.library.path=build:\/usr\/local\/lib\"\n@@ -95,3 +77,0 @@\n-      example true $*\n-   else\n-      example false $*\n@@ -99,1 +78,0 @@\n-fi\n@@ -101,0 +79,20 @@\n+   export EXAMPLE=\"${1}\"\n+   echo EXAMPLE=${EXAMPLE}\n+   export EXAMPLE_JAR=build\/hat-example-${EXAMPLE}-1.0.jar\n+   if [[  -f ${EXAMPLE_JAR} ]] ;then\n+      export JARS=${JARS}:${EXAMPLE_JAR}\n+      shift 1\n+   else\n+      echo \"no example build\/${EXAMPLE_JAR}\"\n+      exit 1\n+   fi  \n+   echo JARS=${JARS}\n+   echo VMOPTS=${VMOPTS}\n+   echo OPTS=${OPTS}\n+   echo java \\${VMOPTS} \\${OPTS} --class-path \\${JARS} \\${EXAMPLE}.Main $*\n+   echo java ${VMOPTS} ${OPTS} --class-path ${JARS} ${EXAMPLE}.Main $*\n+   java ${VMOPTS} ${OPTS} --class-path ${JARS} ${EXAMPLE}.Main $*\n+else\n+   echo No build dir\n+   exit 1\n+fi\n","filename":"hat\/hatrun.bash","additions":60,"deletions":62,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-     subDirStream(hatDir.path(), \"hat\", \"examples\", \"backends\", \"docs\")\n+     subDirStream(hatDir.path(), \"hat\", \"examples\", \"backends\", \"docs\", \"bldr\")\n","filename":"hat\/sanity","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}