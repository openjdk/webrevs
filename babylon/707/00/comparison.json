{"files":[{"patch":"@@ -205,10 +205,0 @@\n-\n-            @Override\n-            boolean allowIntersectionTypes() {\n-                return true;\n-            }\n-\n-            @Override\n-            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n-                return allowIntersectionTypes ? this : UPWARDS_NO_INTERSECTION;\n-            }\n@@ -221,42 +211,0 @@\n-\n-            @Override\n-            boolean allowIntersectionTypes() {\n-                return true;\n-            }\n-\n-            @Override\n-            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n-                return allowIntersectionTypes ? this : DOWNWARDS_NO_INTERSECTION;\n-            }\n-        },\n-        UPWARDS_NO_INTERSECTION() {\n-            @Override\n-            ProjectionKind complement() {\n-                return DOWNWARDS_NO_INTERSECTION;\n-            }\n-\n-            @Override\n-            boolean allowIntersectionTypes() {\n-                return false;\n-            }\n-\n-            @Override\n-            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n-                return allowIntersectionTypes ? UPWARDS : this;\n-            }\n-        },\n-        DOWNWARDS_NO_INTERSECTION() {\n-            @Override\n-            ProjectionKind complement() {\n-                return UPWARDS_NO_INTERSECTION;\n-            }\n-\n-            @Override\n-            boolean allowIntersectionTypes() {\n-                return false;\n-            }\n-\n-            @Override\n-            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n-                return allowIntersectionTypes ? DOWNWARDS : this;\n-            }\n@@ -266,2 +214,0 @@\n-        abstract boolean allowIntersectionTypes();\n-        abstract ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes);\n@@ -306,12 +252,5 @@\n-            if (t.isUnion() || t.isIntersection()) {\n-                if (pkind.allowIntersectionTypes()) {\n-                    List<Type> components = directSupertypes(t);\n-                    List<Type> components1 = components.map(c -> c.map(this, pkind));\n-                    if (components == components1) return t;\n-                    else return makeIntersectionType(components1);\n-                } else if (t.isIntersection()) {\n-                    return visit(((IntersectionClassType)t).getExplicitComponents().head, pkind);\n-                } else {\n-                    Assert.check(t.isUnion());\n-                    return visit(((UnionClassType)t).getLub(), pkind);\n-                }\n+            if (t.isCompound()) {\n+                List<Type> components = directSupertypes(t);\n+                List<Type> components1 = components.map(c -> c.map(this, pkind));\n+                if (components == components1) return t;\n+                else return makeIntersectionType(components1);\n@@ -372,1 +311,0 @@\n-                            case UPWARDS_NO_INTERSECTION:\n@@ -376,1 +314,0 @@\n-                            case DOWNWARDS_NO_INTERSECTION:\n@@ -391,1 +328,1 @@\n-                    return (pkind == ProjectionKind.UPWARDS || pkind == ProjectionKind.UPWARDS_NO_INTERSECTION) ?\n+                    return pkind == ProjectionKind.UPWARDS ?\n@@ -400,1 +337,1 @@\n-            return (t.containsAny(vars) || (!pkind.allowIntersectionTypes() && !chk.checkDenotable(t))) ?\n+            return t.containsAny(vars) ?\n@@ -418,1 +355,1 @@\n-                if (pkind == ProjectionKind.DOWNWARDS || pkind == ProjectionKind.DOWNWARDS_NO_INTERSECTION) {\n+                if (pkind == ProjectionKind.DOWNWARDS) {\n@@ -422,1 +359,1 @@\n-                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS.withIntersectionTypes(pkind.allowIntersectionTypes()));\n+                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);\n@@ -432,1 +369,1 @@\n-                } else if (!lower.hasTag(BOT) && (!lower.isIntersection() || pkind.allowIntersectionTypes())) {\n+                } else if (!lower.hasTag(BOT)) {\n@@ -455,2 +392,2 @@\n-                        bound = wt.type.map(TypeProjection.this, pkind.withIntersectionTypes(true).complement());\n-                        if (bound.hasTag(BOT) || (bound.isIntersection() && !pkind.allowIntersectionTypes())) {\n+                        bound = wt.type.map(TypeProjection.this, pkind.complement());\n+                        if (bound.hasTag(BOT)) {\n@@ -484,14 +421,1 @@\n-        return upward(t, true, vars);\n-    }\n-\n-    \/**\n-     * Computes an upward projection of given type, and vars. See {@link TypeProjection}.\n-     *\n-     * @param t the type to be projected\n-     * @param allowIntersection whether intersection types should be allowed in the projection\n-     * @param vars the set of type variables to be mapped\n-     * @return the type obtained as result of the projection\n-     *\/\n-    public Type upward(Type t, boolean allowIntersection, List<Type> vars) {\n-        return t.map(new TypeProjection(vars),\n-                allowIntersection ? ProjectionKind.UPWARDS : ProjectionKind.UPWARDS_NO_INTERSECTION);\n+        return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":13,"deletions":89,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.tools.javac.code.Symbol.TypeVariableSymbol;\n@@ -40,0 +41,3 @@\n+import com.sun.tools.javac.code.Type.StructuralTypeMapping;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.code.Type.UnionClassType;\n@@ -2705,1 +2709,1 @@\n-        t = types.upward(t, false, types.captures(t));\n+        t = asDenotable(t);\n@@ -2834,0 +2838,47 @@\n+\n+    Type asDenotable(Type t) {\n+        \/\/ The goal of this type mapping is to replace occurrences of intersection and union types\n+        \/\/ with fresh type variables with appropriate upper bounds. For instance, consider the generic type\n+        \/\/ Foo<A & B & C>. We need to:\n+        \/\/ 1. replace A & B & C with a fresh type variable, so this becomes Foo<#1>, #1 <: A\n+        \/\/ 2. add #1 to the set of type-variables to be projected\n+        \/\/ 3. run upward projection on Foo<#1>, which gives Foo<? extends A>\n+        \/\/ In other words, by replacing intersection types with fresh type variables we make sure that the output\n+        \/\/ of this method is a type that is fully denotable -- e.g. can be fully represented in terms of the\n+        \/\/ TypeElement API.\n+        class DenotableProjection extends StructuralTypeMapping<Void> {\n+            final ListBuffer<Type> tvars = new ListBuffer<>();\n+            final Type t;\n+\n+            DenotableProjection(Type t) {\n+                tvars.appendList(types.captures(t));\n+                this.t = t;\n+            }\n+\n+            Type asDenotable() {\n+                return types.upward(apply(t), tvars.toList());\n+            }\n+\n+            @Override\n+            public Type visitClassType(Type.ClassType t, Void unused) {\n+                if (t.isIntersection()) {\n+                    Type bound = visit(((IntersectionClassType) t).getExplicitComponents().head, null);\n+                    return addTypeVar(bound, t.tsym);\n+                } else if (t.isUnion()) {\n+                    Type bound = visit(((UnionClassType)t).getLub(), null);\n+                    return addTypeVar(bound, t.tsym);\n+                } else {\n+                    return super.visitClassType(t, null);\n+                }\n+            }\n+\n+            Type addTypeVar(Type bound, Symbol owner) {\n+                var tvsym = new TypeVariableSymbol(0, names.empty, null, owner);\n+                tvsym.type = new TypeVar(tvsym, bound, syms.botType);\n+                tvars.append(tvsym.type);\n+                return tvsym.type;\n+            }\n+        }\n+\n+        return new DenotableProjection(t).asDenotable();\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -232,0 +232,193 @@\n+\n+    static <Z> List<Z> pickInv(Z z1, Z z2) { return null; }\n+    static <Z> List<? extends Z> pickExt(Z z1, Z z2) { return null; }\n+    static <Z> List<? super Z> pickSup(Z z1, Z z2) { return null; }\n+\n+    \/\/ test intersections\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"test11\" ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Object\" = constant @null;\n+                %1 : java.type:\"DenotableTypesTest$C\" = cast %0 @java.type:\"DenotableTypesTest$C\";\n+                %2 : java.type:\"java.lang.Object\" = constant @null;\n+                %3 : java.type:\"DenotableTypesTest$D\" = cast %2 @java.type:\"DenotableTypesTest$D\";\n+                %4 : java.type:\"java.util.List<? extends DenotableTypesTest$A>\" = invoke %1 %3 @java.ref:\"DenotableTypesTest::pickInv(java.lang.Object, java.lang.Object):java.util.List\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test11() {\n+        pickInv((C)null, (D)null);\n+    }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"test12\" ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Object\" = constant @null;\n+                %1 : java.type:\"DenotableTypesTest$C\" = cast %0 @java.type:\"DenotableTypesTest$C\";\n+                %2 : java.type:\"java.lang.Object\" = constant @null;\n+                %3 : java.type:\"DenotableTypesTest$D\" = cast %2 @java.type:\"DenotableTypesTest$D\";\n+                %4 : java.type:\"java.util.List<? extends DenotableTypesTest$A>\" = invoke %1 %3 @java.ref:\"DenotableTypesTest::pickExt(java.lang.Object, java.lang.Object):java.util.List\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test12() {\n+        pickExt((C)null, (D)null);\n+    }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"test13\" ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Object\" = constant @null;\n+                %1 : java.type:\"DenotableTypesTest$C\" = cast %0 @java.type:\"DenotableTypesTest$C\";\n+                %2 : java.type:\"java.lang.Object\" = constant @null;\n+                %3 : java.type:\"DenotableTypesTest$D\" = cast %2 @java.type:\"DenotableTypesTest$D\";\n+                %4 : java.type:\"java.util.List<?>\" = invoke %1 %3 @java.ref:\"DenotableTypesTest::pickSup(java.lang.Object, java.lang.Object):java.util.List\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test13() {\n+        pickSup((C)null, (D)null);\n+    }\n+\n+    static <Z> List<Z[]> pickInvArr(Z z1, Z z2) { return null; }\n+    static <Z> List<? extends Z[]> pickExtArr(Z z1, Z z2) { return null; }\n+    static <Z> List<? super Z[]> pickSupArr(Z z1, Z z2) { return null; }\n+\n+    \/\/ test arrays of intersections\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"test14\" ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Object\" = constant @null;\n+                %1 : java.type:\"DenotableTypesTest$C\" = cast %0 @java.type:\"DenotableTypesTest$C\";\n+                %2 : java.type:\"java.lang.Object\" = constant @null;\n+                %3 : java.type:\"DenotableTypesTest$D\" = cast %2 @java.type:\"DenotableTypesTest$D\";\n+                %4 : java.type:\"java.util.List<? extends DenotableTypesTest$A[]>\" = invoke %1 %3 @java.ref:\"DenotableTypesTest::pickInvArr(java.lang.Object, java.lang.Object):java.util.List\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test14() {\n+        pickInvArr((C)null, (D)null);\n+    }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"test15\" ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Object\" = constant @null;\n+                %1 : java.type:\"DenotableTypesTest$C\" = cast %0 @java.type:\"DenotableTypesTest$C\";\n+                %2 : java.type:\"java.lang.Object\" = constant @null;\n+                %3 : java.type:\"DenotableTypesTest$D\" = cast %2 @java.type:\"DenotableTypesTest$D\";\n+                %4 : java.type:\"java.util.List<? extends DenotableTypesTest$A[]>\" = invoke %1 %3 @java.ref:\"DenotableTypesTest::pickExtArr(java.lang.Object, java.lang.Object):java.util.List\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test15() {\n+        pickExtArr((C)null, (D)null);\n+    }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"test16\" ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Object\" = constant @null;\n+                %1 : java.type:\"DenotableTypesTest$C\" = cast %0 @java.type:\"DenotableTypesTest$C\";\n+                %2 : java.type:\"java.lang.Object\" = constant @null;\n+                %3 : java.type:\"DenotableTypesTest$D\" = cast %2 @java.type:\"DenotableTypesTest$D\";\n+                %4 : java.type:\"java.util.List<?>\" = invoke %1 %3 @java.ref:\"DenotableTypesTest::pickSupArr(java.lang.Object, java.lang.Object):java.util.List\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test16() {\n+        pickSupArr((C)null, (D)null);\n+    }\n+\n+    interface F<X> { }\n+    interface G<X> { }\n+    static class H<X> implements F<X>, G<X> { }\n+    static class I<X> implements F<X>, G<X> { }\n+\n+    static <Z> H<Z> pickH(Z z1, Z z2) { return null; }\n+    static <Z> I<Z> pickI(Z z1, Z z2) { return null; }\n+\n+    \/\/ test intersections of intersections\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"test17\" ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Object\" = constant @null;\n+                %1 : java.type:\"DenotableTypesTest$C\" = cast %0 @java.type:\"DenotableTypesTest$C\";\n+                %2 : java.type:\"java.lang.Object\" = constant @null;\n+                %3 : java.type:\"DenotableTypesTest$D\" = cast %2 @java.type:\"DenotableTypesTest$D\";\n+                %4 : java.type:\"DenotableTypesTest$H<? extends DenotableTypesTest$A>\" = invoke %1 %3 @java.ref:\"DenotableTypesTest::pickH(java.lang.Object, java.lang.Object):DenotableTypesTest$H\";\n+                %5 : Var<java.type:\"DenotableTypesTest$H<? extends DenotableTypesTest$A>\"> = var %4 @\"fst\";\n+                %6 : java.type:\"java.lang.Object\" = constant @null;\n+                %7 : java.type:\"DenotableTypesTest$C\" = cast %6 @java.type:\"DenotableTypesTest$C\";\n+                %8 : java.type:\"java.lang.Object\" = constant @null;\n+                %9 : java.type:\"DenotableTypesTest$D\" = cast %8 @java.type:\"DenotableTypesTest$D\";\n+                %10 : java.type:\"DenotableTypesTest$I<? extends DenotableTypesTest$A>\" = invoke %7 %9 @java.ref:\"DenotableTypesTest::pickI(java.lang.Object, java.lang.Object):DenotableTypesTest$I\";\n+                %11 : Var<java.type:\"DenotableTypesTest$I<? extends DenotableTypesTest$A>\"> = var %10 @\"snd\";\n+                %12 : java.type:\"DenotableTypesTest$H<? extends DenotableTypesTest$A>\" = var.load %5;\n+                %13 : java.type:\"DenotableTypesTest$I<? extends DenotableTypesTest$A>\" = var.load %11;\n+                %14 : java.type:\"java.util.List<? extends DenotableTypesTest$F<? extends DenotableTypesTest$A>>\" = invoke %12 %13 @java.ref:\"DenotableTypesTest::pickInv(java.lang.Object, java.lang.Object):java.util.List\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test17() {\n+        var fst = pickH((C)null, (D)null);\n+        var snd = pickI((C)null, (D)null);\n+        pickInv(fst, snd);\n+    }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"test18\" ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Object\" = constant @null;\n+                %1 : java.type:\"DenotableTypesTest$C\" = cast %0 @java.type:\"DenotableTypesTest$C\";\n+                %2 : java.type:\"java.lang.Object\" = constant @null;\n+                %3 : java.type:\"DenotableTypesTest$D\" = cast %2 @java.type:\"DenotableTypesTest$D\";\n+                %4 : java.type:\"DenotableTypesTest$H<? extends DenotableTypesTest$A>\" = invoke %1 %3 @java.ref:\"DenotableTypesTest::pickH(java.lang.Object, java.lang.Object):DenotableTypesTest$H\";\n+                %5 : Var<java.type:\"DenotableTypesTest$H<? extends DenotableTypesTest$A>\"> = var %4 @\"fst\";\n+                %6 : java.type:\"java.lang.Object\" = constant @null;\n+                %7 : java.type:\"DenotableTypesTest$C\" = cast %6 @java.type:\"DenotableTypesTest$C\";\n+                %8 : java.type:\"java.lang.Object\" = constant @null;\n+                %9 : java.type:\"DenotableTypesTest$D\" = cast %8 @java.type:\"DenotableTypesTest$D\";\n+                %10 : java.type:\"DenotableTypesTest$I<? extends DenotableTypesTest$A>\" = invoke %7 %9 @java.ref:\"DenotableTypesTest::pickI(java.lang.Object, java.lang.Object):DenotableTypesTest$I\";\n+                %11 : Var<java.type:\"DenotableTypesTest$I<? extends DenotableTypesTest$A>\"> = var %10 @\"snd\";\n+                %12 : java.type:\"DenotableTypesTest$H<? extends DenotableTypesTest$A>\" = var.load %5;\n+                %13 : java.type:\"DenotableTypesTest$I<? extends DenotableTypesTest$A>\" = var.load %11;\n+                %14 : java.type:\"java.util.List<? extends DenotableTypesTest$F<? extends DenotableTypesTest$A>>\" = invoke %12 %13 @java.ref:\"DenotableTypesTest::pickExt(java.lang.Object, java.lang.Object):java.util.List\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test18() {\n+        var fst = pickH((C)null, (D)null);\n+        var snd = pickI((C)null, (D)null);\n+        pickExt(fst, snd);\n+    }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"test19\" ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Object\" = constant @null;\n+                %1 : java.type:\"DenotableTypesTest$C\" = cast %0 @java.type:\"DenotableTypesTest$C\";\n+                %2 : java.type:\"java.lang.Object\" = constant @null;\n+                %3 : java.type:\"DenotableTypesTest$D\" = cast %2 @java.type:\"DenotableTypesTest$D\";\n+                %4 : java.type:\"DenotableTypesTest$H<? extends DenotableTypesTest$A>\" = invoke %1 %3 @java.ref:\"DenotableTypesTest::pickH(java.lang.Object, java.lang.Object):DenotableTypesTest$H\";\n+                %5 : Var<java.type:\"DenotableTypesTest$H<? extends DenotableTypesTest$A>\"> = var %4 @\"fst\";\n+                %6 : java.type:\"java.lang.Object\" = constant @null;\n+                %7 : java.type:\"DenotableTypesTest$C\" = cast %6 @java.type:\"DenotableTypesTest$C\";\n+                %8 : java.type:\"java.lang.Object\" = constant @null;\n+                %9 : java.type:\"DenotableTypesTest$D\" = cast %8 @java.type:\"DenotableTypesTest$D\";\n+                %10 : java.type:\"DenotableTypesTest$I<? extends DenotableTypesTest$A>\" = invoke %7 %9 @java.ref:\"DenotableTypesTest::pickI(java.lang.Object, java.lang.Object):DenotableTypesTest$I\";\n+                %11 : Var<java.type:\"DenotableTypesTest$I<? extends DenotableTypesTest$A>\"> = var %10 @\"snd\";\n+                %12 : java.type:\"DenotableTypesTest$H<? extends DenotableTypesTest$A>\" = var.load %5;\n+                %13 : java.type:\"DenotableTypesTest$I<? extends DenotableTypesTest$A>\" = var.load %11;\n+                %14 : java.type:\"java.util.List<?>\" = invoke %12 %13 @java.ref:\"DenotableTypesTest::pickSup(java.lang.Object, java.lang.Object):java.util.List\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test19() {\n+        var fst = pickH((C)null, (D)null);\n+        var snd = pickI((C)null, (D)null);\n+        pickSup(fst, snd);\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/DenotableTypesTest.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"modified"}]}