{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import hat.optools.IfaceBufferPattern;\n@@ -35,0 +34,1 @@\n+import optkl.Invoke;\n@@ -46,1 +46,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n@@ -55,0 +54,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -421,1 +421,1 @@\n-            invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+            invokedMethods.append(createFunction(kernelCallGraph.lookup(),new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n@@ -432,1 +432,1 @@\n-        out.append(createFunction(builder.nl().nl(), loweredPtx, true));\n+        out.append(createFunction(kernelCallGraph.lookup(),builder.nl().nl(), loweredPtx, true));\n@@ -445,3 +445,3 @@\n-            if (op instanceof JavaOp.InvokeOp invokeOp){\n-                if (IfaceBufferPattern.isInvokeOp(lookup,invokeOp)\n-                        && invokeOp.operands().getFirst() instanceof Op.Result invokeResult\n+            if (invokeOpHelper(lookup,op) instanceof Invoke invoke){\n+                if (invoke.isMappableIface()\n+                        && invoke.op().operands().getFirst() instanceof Op.Result invokeResult\n@@ -451,1 +451,1 @@\n-                    List<Value> inputOperands = invokeOp.operands();\n+                    List<Value> inputOperands = invoke.op().operands();\n@@ -453,1 +453,1 @@\n-                    Op.Result inputResult = invokeOp.result();\n+                   \/\/ Op.Result inputResult = invokeOp.result();\n@@ -455,1 +455,1 @@\n-                    PTXPtrOp ptxOp = new PTXPtrOp(inputResult.type(), invokeOp.invokeDescriptor().name(), outputOperands, boundSchema);\n+                    PTXPtrOp ptxOp = new PTXPtrOp(invoke.returnType(), invoke.name(), outputOperands, boundSchema);\n@@ -457,4 +457,4 @@\n-                    cc.mapValue(inputResult, outputResult);\n-                } else if (invokeOp.invokeDescriptor().refType().toString().equals(\"java.lang.Math\")\n-                        && mathFns.containsKey(invokeOp.invokeDescriptor().name() + \"_\" + invokeOp.resultType().toString())){\n-                    usedMathFns.add(invokeOp.invokeDescriptor().name() + \"_\" + invokeOp.resultType().toString());\n+                    cc.mapValue(invoke.op().result(), outputResult);\n+                } else if (invoke.refIs(Math.class)\n+                        && mathFns.containsKey(invoke.name() + \"_\" + invoke.returnType().toString())){\n+                    usedMathFns.add(invoke.name() + \"_\" + invoke.returnType().toString());\n@@ -472,1 +472,1 @@\n-    static public String createFunction(PTXHATKernelBuilder builder, CoreOp.FuncOp lowered, boolean entry) {\n+    static public String createFunction(MethodHandles.Lookup lookup,PTXHATKernelBuilder builder, CoreOp.FuncOp lowered, boolean entry) {\n@@ -488,1 +488,1 @@\n-                builder.blockBody(block, block.ops().stream()));\n+                builder.blockBody(lookup,block, block.ops().stream()));\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.optools.*;\n@@ -29,1 +28,1 @@\n-import optkl.OpTkl;\n+import optkl.Invoke;\n@@ -46,1 +45,3 @@\n-import static optkl.OpTkl.methodOrThrow;\n+import static optkl.FieldAccess.fieldAccessOpHelper;\n+import static optkl.Invoke.invokeOpHelper;\n+\n@@ -130,1 +131,1 @@\n-    public void blockBody(Block block, Stream<Op> ops) {\n+    public void blockBody(MethodHandles.Lookup lookup,Block block, Stream<Op> ops) {\n@@ -143,2 +144,2 @@\n-            if (op instanceof JavaOp.InvokeOp invoke && !IfaceBufferPattern.isInvokeOp(MethodHandles.lookup(),invoke)) {\n-                ptxIndent().convert(op).nl();\n+            if (invokeOpHelper(lookup,op) instanceof Invoke invoke && !invoke.isMappableIface()) {\n+                ptxIndent().convert(lookup,op).nl();\n@@ -146,1 +147,1 @@\n-                ptxIndent().convert(op).semicolon().nl();\n+                ptxIndent().convert(lookup,op).semicolon().nl();\n@@ -175,1 +176,1 @@\n-    public PTXHATKernelBuilder convert(Op op) {\n+    public PTXHATKernelBuilder convert(MethodHandles.Lookup lookup,Op op) {\n@@ -177,1 +178,1 @@\n-            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoad($);\n+            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoad(lookup,$);\n@@ -184,1 +185,1 @@\n-            case JavaOp.InvokeOp $ -> methodCall($);\n+            case JavaOp.InvokeOp $ -> methodCall(invokeOpHelper(lookup,$));\n@@ -220,2 +221,4 @@\n-    public void fieldLoad(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        if (OpTkl.fieldName(fieldLoadOp).equals(Field.KC_X.toString())) {\n+    public void fieldLoad(MethodHandles.Lookup lookup,JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+\n+        var fieldAccess = fieldAccessOpHelper(lookup,fieldLoadOp);\n+        if (fieldAccess.named(Field.KC_X.toString())) {\n@@ -227,1 +230,1 @@\n-        } else if (OpTkl.fieldName(fieldLoadOp).equals(Field.KC_MAXX.toString())) {\n+        } else if (fieldAccess.named(Field.KC_MAXX.toString())) {\n@@ -447,2 +450,3 @@\n-    public void methodCall(JavaOp.InvokeOp op) {\n-        switch (op.invokeDescriptor().toString()) {\n+    public void methodCall(Invoke invoke) {\n+       \/\/ Invoke invoke = Invoke.invokeOpHelper(MethodHandles.lookup(),invokeOp);\n+        switch (invoke.op().invokeDescriptor().toString()) {\n@@ -452,2 +456,2 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.operands().getFirst()).commaSpace().reg(op.operands().get(1)).ptxNl();\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(temp.name(), 4);\n+                add().s64().space().regName(temp).commaSpace().reg(invoke.op().operands().getFirst()).commaSpace().reg(invoke.op().operands().get(1)).ptxNl();\n+                ld().global().u32().space().resultReg(invoke.op(), PTXRegister.Type.U32).commaSpace().address(temp.name(), 4);\n@@ -457,2 +461,2 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.operands().getFirst()).commaSpace().reg(op.operands().get(1)).ptxNl();\n-                st().global().u32().space().address(temp.name(), 4).commaSpace().reg(op.operands().get(2));\n+                add().s64().space().regName(temp).commaSpace().reg(invoke.op().operands().getFirst()).commaSpace().reg(invoke.op().operands().get(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 4).commaSpace().reg(invoke.op().operands().get(2));\n@@ -461,1 +465,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operands().getFirst()).name());\n+                ld().global().u32().space().resultReg(invoke.op(), PTXRegister.Type.U32).commaSpace().address(getReg(invoke.op().operands().getFirst()).name());\n@@ -466,2 +470,2 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.operands().getFirst()).commaSpace().reg(op.operands().get(1)).ptxNl();\n-                st().global().u32().space().address(temp.name(), 8).commaSpace().reg(op.operands().get(2));\n+                add().s64().space().regName(temp).commaSpace().reg(invoke.op().operands().getFirst()).commaSpace().reg(invoke.op().operands().get(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 8).commaSpace().reg(invoke.op().operands().get(2));\n@@ -470,1 +474,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operands().getFirst()).name());\n+                ld().global().u32().space().resultReg(invoke.op(), PTXRegister.Type.U32).commaSpace().address(getReg(invoke.op().operands().getFirst()).name());\n@@ -473,1 +477,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operands().getFirst()).name(), 4);\n+                ld().global().u32().space().resultReg(invoke.op(), PTXRegister.Type.U32).commaSpace().address(getReg(invoke.op().operands().getFirst()).name(), 4);\n@@ -477,1 +481,1 @@\n-                sqrt().rn().f64().space().resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operands().getFirst()).semicolon();\n+                sqrt().rn().f64().space().resultReg(invoke.op(), PTXRegister.Type.F64).commaSpace().reg(invoke.op().operands().getFirst()).semicolon();\n@@ -481,3 +485,3 @@\n-                for (int i = 0; i < op.operands().size(); i++) {\n-                    dot().param().space().paramType(op.operands().get(i).type()).space().param().intVal(i).ptxNl();\n-                    st().dot().param().paramType(op.operands().get(i).type()).space().osbrace().param().intVal(i).csbrace().commaSpace().reg(op.operands().get(i)).ptxNl();\n+                for (int i = 0; i < invoke.op().operands().size(); i++) {\n+                    dot().param().space().paramType(invoke.op().operands().get(i).type()).space().param().intVal(i).ptxNl();\n+                    st().dot().param().paramType(invoke.op().operands().get(i).type()).space().osbrace().param().intVal(i).csbrace().commaSpace().reg(invoke.op().operands().get(i)).ptxNl();\n@@ -485,2 +489,2 @@\n-                dot().param().space().paramType(op.resultType()).space().retVal().ptxNl();\n-                call().uni().space().oparen().retVal().cparen().commaSpace().identifier(methodOrThrow(MethodHandles.lookup(),op).getName()).commaSpace();\n+                dot().param().space().paramType(invoke.op().resultType()).space().retVal().ptxNl();\n+                call().uni().space().oparen().retVal().cparen().commaSpace().identifier(invoke.name()).commaSpace();\n@@ -490,1 +494,1 @@\n-                                op.operands(),\n+                                invoke.op().operands(),\n@@ -494,1 +498,1 @@\n-                ld().dot().param().paramType(op.resultType()).space().resultReg(op, getResultType(op.resultType())).commaSpace().osbrace().retVal().csbrace();\n+                ld().dot().param().paramType(invoke.op().resultType()).space().resultReg(invoke.op(), getResultType(invoke.op().resultType())).commaSpace().osbrace().retVal().csbrace();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":36,"deletions":32,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -226,4 +226,0 @@\n-                    bool hasImplicitFunctionDeclError = (strstr(log, \"error: implicit declaration of function\") != nullptr);\n-                    if (hasImplicitFunctionDeclError) {\n-                        std::cerr << \"Did you miss @Reflect annotation on the above function?\" << std::endl;\n-                    }\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/native\/cpp\/opencl_backend.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,3 +30,1 @@\n-import hat.optools.ComputeContextPattern;\n-import hat.optools.IfaceBufferPattern;\n-import hat.optools.KernelContextPattern;\n+import hat.KernelContext;\n@@ -34,0 +32,1 @@\n+import optkl.Invoke;\n@@ -35,1 +34,0 @@\n-import optkl.OpTkl;\n@@ -46,1 +44,0 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -57,0 +54,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -59,2 +57,0 @@\n-import static optkl.OpTkl.javaReturnType;\n-import static optkl.OpTkl.methodOrThrow;\n@@ -141,1 +137,1 @@\n-                if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                if (invokeOpHelper(lookup(),op) instanceof Invoke invoke ) {\n@@ -143,2 +139,2 @@\n-                    if (IfaceBufferPattern.isInvokeOp(lookup(), invokeOp) && javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n-                        Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n+                    if (invoke.isMappableIface() && invoke.returnsVoid()) {                    \/\/ iface.v(newV)\n+                        Value iface = bldr.context().getValue(invoke.op().operands().getFirst());\n@@ -146,1 +142,1 @@\n-                        bldr.op(invokeOp);                                              \/\/ iface.v(newV);\n+                        bldr.op(invoke.op());                                              \/\/ iface.v(newV);\n@@ -148,1 +144,1 @@\n-                    } else if (IfaceBufferPattern.isInvokeOp(lookup(), invokeOp)\n+                    } else if (invoke.isMappableIface()\n@@ -150,2 +146,2 @@\n-                                    (javaReturnType(invokeOp) instanceof ClassType returnClassType)\n-                                            && classTypeToTypeOrThrow(lookup(), returnClassType) instanceof Class<?> type\n+                                    invoke.returnsClassType()\n+                                            && classTypeToTypeOrThrow(lookup(), (ClassType)invoke.returnType()) instanceof Class<?> type\n@@ -154,1 +150,1 @@\n-                                            (javaReturnType(invokeOp) instanceof PrimitiveType primitiveType)\n+                                            invoke.returnsPrimitive()\n@@ -158,1 +154,1 @@\n-                        Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n+                        Value iface = bldr.context().getValue(invoke.op().operands().getFirst());\n@@ -160,1 +156,1 @@\n-                        bldr.op(invokeOp);                                             \/\/ iface.v();\n+                        bldr.op(invoke.op());                                             \/\/ iface.v();\n@@ -162,2 +158,2 @@\n-                    } else if (ComputeContextPattern.isComputeContextMethod(lookup(),invokeOp) || KernelContextPattern.KernelContextInvokePattern.isKernelContextInvokeOp(lookup(),invokeOp,OpTkl.AnyInvoke)) { \/\/dispatchKernel\n-                        bldr.op(invokeOp);\n+                    } else if (invoke.refIs(ComputeContext.class,KernelContext.class)) { \/\/dispatchKernel\n+                        bldr.op(invoke.op());\n@@ -165,1 +161,1 @@\n-                        List<Value> list = invokeOp.operands();\n+                        List<Value> list = invoke.op().operands();\n@@ -169,1 +165,0 @@\n-                            var m = methodOrThrow(lookup(), invokeOp);\n@@ -171,1 +166,3 @@\n-                            Annotation[][] parameterAnnotations = m.getParameterAnnotations();\n+                            var method = invoke.resolveMethodOrThrow();\n+\n+                            Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n@@ -188,1 +185,1 @@\n-                            bldr.op(invokeOp);\n+                            bldr.op(invoke.op());\n@@ -199,1 +196,1 @@\n-                            bldr.op(invokeOp);\n+                            bldr.op(invoke.op());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import hat.optools.ComputeContextPattern;\n-import hat.optools.IfaceBufferPattern;\n-import hat.optools.KernelContextPattern;\n@@ -34,3 +31,0 @@\n-import optkl.util.CallSite;\n-import optkl.OpTkl;\n-import optkl.ifacemapper.Buffer;\n@@ -38,3 +32,0 @@\n-import optkl.ifacemapper.MappableIface;\n-import optkl.FuncOpParams;\n-import jdk.incubator.code.Value;\n@@ -43,3 +34,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -51,7 +39,0 @@\n-import static hat.ComputeContext.WRAPPER.ACCESS;\n-import static hat.ComputeContext.WRAPPER.MUTATE;\n-import static optkl.OpTkl.classTypeToTypeOrThrow;\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.javaReturnType;\n-import static optkl.OpTkl.transform;\n-\n@@ -65,1 +46,0 @@\n-        var here = CallSite.of(JExtractedBackend.class, \"dispatchCompuet\");\n@@ -90,43 +70,2 @@\n-        var lookup = computeMethod.callGraph.lookup();\n-        \/\/ TODO : can't we get this from somewhere maybe it should be capturein the compute method?\n-        var paramTable = new FuncOpParams(computeMethod.funcOp());\n-        var here = CallSite.of(JExtractedBackend.class, \"injectBufferTracking\");\n-        var transformedFuncOp = transform(here,computeMethod.funcOp(),_->true, (bldr, op) -> {\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                Value computeContext = bldr.context().getValue(paramTable.list().getFirst().parameter);\n-                if (IfaceBufferPattern.isInvokeOp(lookup, invokeOp) && javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n-                    Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n-                    bldr.op(JavaOp.invoke(MUTATE.pre, computeContext, iface));  \/\/ cc->preMutate(iface);\n-                    bldr.op(invokeOp);                                          \/\/ iface.v(newV);\n-                    bldr.op(JavaOp.invoke(MUTATE.post, computeContext, iface)); \/\/ cc->postMutate(iface)\n-                } else if (IfaceBufferPattern.isInvokeOp(lookup, invokeOp)\n-                        \/\/&& !OpTk.javaReturnType(invokeOp).equals(JavaType.VOID) not sure we need this\n-                        && javaReturnType(invokeOp) instanceof ClassType returnClassType\n-                        && classTypeToTypeOrThrow(lookup, returnClassType) instanceof Class<?> type\n-                        && Buffer.class.isAssignableFrom(type)\n-                ) {            \/\/ iface.v()\n-                    Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n-                    bldr.op(JavaOp.invoke(ACCESS.pre, computeContext, iface));  \/\/ cc->preAccess(iface);\n-                    bldr.op(invokeOp);                                          \/\/ iface.v();\n-                    bldr.op(JavaOp.invoke(ACCESS.post, computeContext, iface)); \/\/ cc->postAccess(iface) } else {\n-                } else if (ComputeContextPattern.isComputeContextMethod(lookup, invokeOp) || KernelContextPattern.KernelContextInvokePattern.isKernelContextInvokeOp(lookup, invokeOp,OpTkl.AnyInvoke)) { \/\/dispatchKernel\n-                    bldr.op(invokeOp);\n-                } else {\n-                    invokeOp.operands().stream()\n-                            .filter(val -> val.type() instanceof JavaType javaType && isAssignable(lookup, javaType, MappableIface.class))\n-                            .forEach(val -> bldr.op(JavaOp.invoke(MUTATE.pre, computeContext, bldr.context().getValue(val))));\n-                    bldr.op(invokeOp);\n-                    invokeOp.operands().stream()\n-                            .filter(val -> val.type() instanceof JavaType javaType && isAssignable(lookup, javaType, MappableIface.class))\n-                            .forEach(val -> bldr.op(JavaOp.invoke(MUTATE.post, computeContext, bldr.context().getValue(val))));\n-                }\n-                return bldr;\n-            } else {\n-                bldr.op(op);\n-            }\n-            return bldr;\n-        });\n-        System.out.println(\"COMPUTE entrypoint after injecting buffer tracking...\");\n-        System.out.println(transformedFuncOp.toText());\n-        computeMethod.funcOp(transformedFuncOp);\n-        return transformedFuncOp;\n+        throw new RuntimeException(\"implement inject buffer tracking \");\n+        \/\/return transformedFuncOp;\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":2,"deletions":63,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import static optkl.Invoke.getTargetInvoke;\n@@ -52,2 +53,0 @@\n-import static optkl.OpTkl.getTargetInvokeOp;\n-import static optkl.OpTkl.methodOrThrow;\n@@ -197,1 +196,1 @@\n-        Method method = methodOrThrow(lookup,getTargetInvokeOp(this.lookup,lambda, ComputeContext.class));\n+        Method method = getTargetInvoke(this.lookup,lambda, ComputeContext.class).resolveMethodOrThrow();\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import optkl.Invoke;\n+import optkl.ifacemapper.AccessType;\n@@ -37,0 +39,1 @@\n+import optkl.util.StreamMutable;\n@@ -41,1 +44,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -43,0 +45,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -44,1 +47,0 @@\n-import static optkl.OpTkl.lower;\n@@ -51,24 +53,0 @@\n-    public enum AccessType {\n-        NOT_BUFFER((byte)0),\n-        NA((byte)1),\n-        RO((byte)(1<<1)),\n-        WO((byte)(1<<2)),\n-        RW((byte) (RO.value|WO.value));\n-\n-        public final byte value;\n-        AccessType(byte i) {\n-            value = i;\n-        }\n-    }\n-\n-    public static String convertAccessType(int i) {\n-        switch (i) {\n-            case 0 -> {return \"NOT_BUFFER\";}\n-            case 1 -> {return \"NA\";}\n-            case 2 -> {return \"RO\";}\n-            case 4 -> {return \"WO\";}\n-            case 6 -> {return \"RW\";}\n-            default -> {return \"\";}\n-        }\n-    }\n-\n@@ -76,3 +54,3 @@\n-    public static ArrayList<AccessType> getAccessList(MethodHandles.Lookup l, CoreOp.FuncOp f) {\n-        CoreOp.FuncOp inlinedFunc = inlineLoop(l, f);\n-        buildAccessMap(l, inlinedFunc);\n+    public static ArrayList<AccessType> getAccessList(MethodHandles.Lookup lookup, Method methodOfFuncOp, CoreOp.FuncOp funcOp) {\n+        CoreOp.FuncOp inlinedFunc = inlineLoop(lookup, methodOfFuncOp, funcOp);\n+        buildAccessMap(lookup, inlinedFunc);\n@@ -83,1 +61,1 @@\n-            } else if (isAssignable(l, p.type(), MappableIface.class)) {\n+            } else if (isAssignable(lookup, p.type(), MappableIface.class)) {\n@@ -93,2 +71,1 @@\n-    public static CoreOp.FuncOp inlineLoop(MethodHandles.Lookup l, CoreOp.FuncOp f) {\n-\n+    public static CoreOp.FuncOp inlineLoop(MethodHandles.Lookup lookup, Method methodOfFuncOp, CoreOp.FuncOp funcOp) {\n@@ -96,2 +73,2 @@\n-        CoreOp.FuncOp ssaFunc =  SSA.transform(lower(here,f)) ;\/\/ OpTkl.SSATransformLower(here, f); \/\/ do we need this nesting?\n-        AtomicBoolean changed = new AtomicBoolean(true);\n+        CoreOp.FuncOp ssaFunc =  SSA.transform( funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER)) ;\n+        var changed  = StreamMutable.of(true);\n@@ -100,19 +77,26 @@\n-\n-            ssaFunc = OpTkl.transform(CallSite.of(BufferTagger.class, \"inlineLoop\"),ssaFunc,(bb, op) -> {\n-                if (op instanceof JavaOp.InvokeOp iop) {\n-                    MethodRef methodRef = iop.invokeDescriptor();\n-                    Method invokeOpCalledMethod;\n-                    try {\n-                        invokeOpCalledMethod = methodRef.resolveToMethod(l);\n-                    } catch (ReflectiveOperationException _) {\n-                        throw new IllegalStateException(\"Could not resolve invokeOp to method\");\n-                    }\n-                    if (invokeOpCalledMethod instanceof Method method) { \/\/ if method isn't a buffer access (is code reflected)\n-                        if (Op.ofMethod(method).isPresent()) {\n-                            CoreOp.FuncOp inline = Op.ofMethod(method).get(); \/\/ method to be inlined\n-                            CoreOp.FuncOp ssaInline =SSA.transform(lower(here,inline));\/\/OpTkl.SSATransformLower(here, inline);\n-                            Block.Builder exit = Inliner.inline(bb, ssaInline, bb.context().getValues(iop.operands()), (_, v) -> {\n-                                if (v != null) bb.context().mapValue(iop.result(), v);\n-                            });\n-                            if (!exit.parameters().isEmpty()) {\n-                                bb.context().mapValue(iop.result(), exit.parameters().getFirst());\n+            ssaFunc = OpTkl.transform(here, ssaFunc,(blockbuilder, op) -> {\n+                Invoke invoke  = invokeOpHelper(lookup, op);\n+                if (invoke != null) {\n+                    Method method = invoke.resolvedMethodOrNull();\n+                    if (method != null) {\n+                        Optional<CoreOp.FuncOp> optionalFuncOp = Op.ofMethod(method);\n+                        if (optionalFuncOp.isPresent())  {\n+                            if (optionalFuncOp.get() instanceof CoreOp.FuncOp inline) {\n+                                CoreOp.FuncOp ssaInline = SSA.transform(inline.transform(CodeTransformer.LOWERING_TRANSFORMER));\n+                                Block.Builder exit = Inliner.inline(\n+                                        blockbuilder, ssaInline,\n+                                        blockbuilder.context().getValues(invoke.op().operands()), (_, _value) -> {\n+                                            \/\/ intellij doesnt like value as var name so we use _value\n+                                        if (_value == null) {\n+                                        \/\/   What is special about TestArrayView.Compute.lifePerIdx? it reaches here\n+                                            \/\/ I think its because it is void ? no return type.\n+                                                \/\/   throw new IllegalStateException(\"inliner returned  null processing \"+method);\n+                                        }else{\n+                                            blockbuilder.context().mapValue(invoke.op().result(), _value);\n+                                        }\n+                                });\n+                                if (!exit.parameters().isEmpty()) {\n+                                    blockbuilder.context().mapValue(invoke.op().result(), exit.parameters().getFirst());\n+                                }\n+                                changed.set(true);\n+                                return exit.rebind(blockbuilder.context(), blockbuilder.transformer());  \n@@ -120,2 +104,6 @@\n-                            changed.set(true);\n-                            return exit.rebind(bb.context(), bb.transformer()); \/\/ return exit in same context as block\n+\n+                        } else if (method.getDeclaringClass().equals(methodOfFuncOp.getDeclaringClass())) {\n+                            \/\/ Expect @Reflect annotation to be present on all methods called from the kernel function \n+                            \/\/ that are defined in the same class as the kernel function.\n+                            throw new RuntimeException(\"Failed to inline \"+ method.getName() + \". Did you miss @Reflect annotation?\");\n+                        \n@@ -125,2 +113,2 @@\n-                bb.op(op);\n-                return bb;\n+                blockbuilder.op(op);\n+                return blockbuilder;\n@@ -133,1 +121,1 @@\n-    public static void buildAccessMap(MethodHandles.Lookup l, CoreOp.FuncOp f) {\n+    public static void buildAccessMap(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n@@ -135,3 +123,4 @@\n-        var here = CallSite.of(BufferTagger.class, \"buildAccessMap\");\n-        OpTkl.elements(here, f).filter(elem -> elem instanceof Block)\n-                .forEach(b -> blockParams.put((Block) b, ((Block) b).parameters()));\n+        funcOp.elements()\n+                .filter(elem -> elem instanceof Block)\n+                .map(elem->(Block)elem)\n+                .forEach(block -> blockParams.put(block, block.parameters()));\n@@ -139,1 +128,1 @@\n-        f.elements().forEach(op -> {\n+        funcOp.elements().forEach(op -> {\n@@ -141,3 +130,1 @@\n-                case CoreOp.BranchOp b -> {\n-                    mapBranch(l, b.branch());\n-                }\n+                case CoreOp.BranchOp b -> mapBranch(lookup, b.branch());\n@@ -145,2 +132,2 @@\n-                    mapBranch(l, cb.trueBranch()); \/\/ handle true branch\n-                    mapBranch(l, cb.falseBranch()); \/\/ handle false branch\n+                    mapBranch(lookup, cb.trueBranch()); \/\/ handle true branch\n+                    mapBranch(lookup, cb.falseBranch()); \/\/ handle false branch\n@@ -148,8 +135,6 @@\n-                case JavaOp.InvokeOp iop -> { \/\/ (almost) all the buffer accesses happen here\n-                    \/\/ actually now that we have arrayview we'll need to map the corresponding arrays too\n-                    if (isAssignable(l, iop.invokeDescriptor().refType(), MappableIface.class)) {\n-                        updateAccessType(getRootValue(iop), getAccessType(iop)); \/\/ update buffer access\n-                        if (isAssignable(l,  iop.invokeDescriptor().refType(), Buffer.class)\n-                                && iop.result() != null && !(iop.resultType() instanceof PrimitiveType)\n-                                && (isAssignable(l,  iop.resultType(), MappableIface.class)\n-                                    || iop.resultType() instanceof ArrayType)) {\n+                case JavaOp.InvokeOp invokeOp -> {\n+                    var ioh =  invokeOpHelper(lookup,invokeOp);\n+                    \/\/ we have to deal with  array views  too\n+                    if ( ioh.refIs(MappableIface.class)) {\n+                        updateAccessType(getRootValue(invokeOp), ioh.returnsVoid()? AccessType.WO : AccessType.RO); \/\/ update buffer access\n+                        if (ioh.refIs(Buffer.class) && (ioh.returns(MappableIface.class) || ioh.returnsArray())) {\n@@ -157,1 +142,1 @@\n-                            remappedVals.put(iop.result(), getRootValue(iop));\n+                            remappedVals.put(invokeOp.result(), getRootValue(invokeOp));\n@@ -162,1 +147,1 @@\n-                    if (isAssignable(l,  vop.resultType().valueType(), Buffer.class)) {\n+                    if (isAssignable(lookup,  vop.resultType().valueType(), Buffer.class)) {\n@@ -164,0 +149,2 @@\n+                    }else{\n+                        \/\/ or else maybe CoreOp.VarOp vop when ??? ->\n@@ -167,1 +154,1 @@\n-                    if (isAssignable(l,  flop.fieldDescriptor().refType(), KernelContext.class)) {\n+                    if (isAssignable(lookup,  flop.fieldDescriptor().refType(), KernelContext.class)) {\n@@ -169,0 +156,2 @@\n+                    }else{\n+                        \/\/ or else\n@@ -171,6 +160,2 @@\n-                case JavaOp.ArrayAccessOp.ArrayLoadOp alop -> {\n-                    updateAccessType(getRootValue(alop), AccessType.RO);\n-                }\n-                case JavaOp.ArrayAccessOp.ArrayStoreOp asop -> {\n-                    updateAccessType(getRootValue(asop), AccessType.WO);\n-                }\n+                case JavaOp.ArrayAccessOp.ArrayLoadOp alop -> updateAccessType(getRootValue(alop), AccessType.RO);\n+                case JavaOp.ArrayAccessOp.ArrayStoreOp asop -> updateAccessType(getRootValue(asop), AccessType.WO);\n@@ -183,2 +168,2 @@\n-    public static void mapBranch(MethodHandles.Lookup l, Block.Reference b) {\n-        List<Value> args = b.arguments();\n+    public static void mapBranch(MethodHandles.Lookup lookup, Block.Reference blockReference) {\n+        List<Value> args = blockReference.arguments();\n@@ -186,9 +171,8 @@\n-            Value key = blockParams.get(b.targetBlock()).get(i);\n-            Value val = args.get(i);\n-\n-            if (val instanceof Op.Result) {\n-                \/\/ either find root param or it doesnt exist (is a constant for example)\n-                if (isAssignable(l, val.type(), MappableIface.class)) {\n-                    val = getRootValue(((Op.Result) val).op());\n-                    if (val instanceof Block.Parameter) {\n-                        val = remappedVals.getOrDefault(val, val);\n+            Value key = blockParams.get(blockReference.targetBlock()).get(i);\n+            Value value = args.get(i);\n+            if (value instanceof Op.Result result) {\n+                \/\/ either find root param or it doesn't exist (is a constant for example)\n+                if (isAssignable(lookup, value.type(), MappableIface.class)) {\n+                    value = getRootValue(result.op());\n+                    if (value instanceof Block.Parameter) {\n+                        value = remappedVals.getOrDefault(value, value);\n@@ -196,0 +180,2 @@\n+                }else{\n+                    \/\/ or else\n@@ -197,0 +183,2 @@\n+            }else{\n+               \/\/ or else?\n@@ -198,1 +186,1 @@\n-            remappedVals.put(key, val);\n+            remappedVals.put(key, value);\n@@ -209,2 +197,3 @@\n-        while (op.operands().getFirst() instanceof Op.Result r) {\n-            op = r.op();\n+\n+        while (op.operands().getFirst() instanceof Op.Result result) { \/\/ Only first?\n+            op = result.op(); \/\/ we are changing our  par here I assume intended\n@@ -213,0 +202,2 @@\n+            }else{\n+                \/\/ or else\n@@ -218,5 +209,0 @@\n-    \/\/ retrieves accessType based on return value of InvokeOp\n-    public static AccessType getAccessType(JavaOp.InvokeOp iop) {\n-        return iop.invokeDescriptor().type().returnType().equals(JavaType.VOID) ? AccessType.WO : AccessType.RO;\n-    }\n-\n@@ -224,3 +210,3 @@\n-    public static void updateAccessType(Value val, AccessType curAccess) {\n-        Value remappedVal = remappedVals.getOrDefault(val, val);\n-        AccessType storedAccess = accessMap.get(remappedVal);\n+    public static void updateAccessType(Value value, AccessType currentAccess) {\n+        Value remappedValue = remappedVals.getOrDefault(value, value);\n+        AccessType storedAccess = accessMap.get(remappedValue);\n@@ -228,3 +214,5 @@\n-            accessMap.put(remappedVal, curAccess);\n-        } else if (curAccess != storedAccess && storedAccess != AccessType.RW) {\n-            accessMap.put(remappedVal, AccessType.RW);\n+            accessMap.put(remappedValue, currentAccess);\n+        } else if (currentAccess != storedAccess && storedAccess != AccessType.RW) {\n+            accessMap.put(remappedValue, AccessType.RW);\n+        } else {\n+            \/\/ or else\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":97,"deletions":109,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import static optkl.Invoke.getTargetInvoke;\n@@ -51,1 +52,0 @@\n-import static optkl.OpTkl.getTargetInvokeOp;\n@@ -163,1 +163,1 @@\n-            MethodRef methodRef = getTargetInvokeOp(this.lookup(), lambdaOp, KernelContext.class).invokeDescriptor();\n+            MethodRef methodRef = getTargetInvoke(this.lookup(), lambdaOp, KernelContext.class).op().invokeDescriptor();\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.BufferTagger;\n+import optkl.ifacemapper.AccessType;\n@@ -37,3 +37,0 @@\n-import java.util.List;\n-\n-import static hat.buffer.ArgArray.Arg.Value.Buf.UNKNOWN_BYTE;\n@@ -41,0 +38,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -46,4 +44,0 @@\n-                 byte UNKNOWN_BYTE=(byte)0;\n-                 byte RO_BYTE =(byte)1<<1;\n-                 byte WO_BYTE =(byte)1<<2;\n-                 byte RW_BYTE =RO_BYTE|WO_BYTE;\n@@ -109,21 +103,12 @@\n-            switch (variant()) {\n-                case '&':\n-                    return Long.toHexString(u64());\n-                case 'F':\n-                    return Float.toString(f32());\n-                case 'I':\n-                    return Integer.toString(s32());\n-                case 'J':\n-                    return Long.toString(s64());\n-                case 'D':\n-                    return Double.toString(f64());\n-                case 'Z':\n-                    return Boolean.toString(z1());\n-                case 'B':\n-                    return Byte.toString(s8());\n-                case 'S':\n-                    return Short.toString(s16());\n-                case 'C':\n-                    return Character.toString(u16());\n-            }\n-            throw new IllegalStateException(\"what is this\");\n+            return switch (variant()) {\n+                case '&'-> Long.toHexString(u64());\n+                case 'F'-> Float.toString(f32());\n+                case 'I'-> Integer.toString(s32());\n+                case 'J'-> Long.toString(s64());\n+                case 'D'-> Double.toString(f64());\n+                case 'Z'-> Boolean.toString(z1());\n+                case 'B'-> Byte.toString(s8());\n+                case 'S'-> Short.toString(s16());\n+                case 'C'-> Character.toString(u16());\n+                default-> throw new IllegalStateException(\"what is this\");\n+            };\n@@ -224,0 +209,1 @@\n+\n@@ -225,9 +211,10 @@\n-            .arrayLen(\"argc\").pad(12).array(\"arg\", arg->arg\n-                            .fields(\"idx\", \"variant\")\n-                            .pad(11\/*(int)(16 - JAVA_INT.byteSize() - JAVA_BYTE.byteSize())*\/)\n-                            .field(\"value\", val->val\n-                                            .fields(\"z1\",\"s8\",\"u16\",\"s16\",\"s32\",\"u32\",\"f32\",\"s64\",\"u64\",\"f64\")\n-                                                    .field(\"buf\", buf->buf\n-                                                            .fields(\"address\",\"bytes\",\/*\"vendorPtr\",*\/\"access\")\n-                                                            .pad((int)(16 - JAVA_BYTE.byteSize()\/* - JAVA_BYTE.byteSize()*\/))\n-                                                    )\n+            .arrayLen(\"argc\")\n+            .pad((int)(16-JAVA_INT.byteSize()))\n+            .array(\"arg\", arg->arg\n+                    .fields(\"idx\", \"variant\")\n+                    .pad((int)(16-JAVA_INT.byteSize()-JAVA_BYTE.byteSize()))\n+                    .field(\"value\", val->val\n+                            .fields(\"z1\",\"s8\",\"u16\",\"s16\",\"s32\",\"u32\",\"f32\",\"s64\",\"u64\",\"f64\")\n+                            .field(\"buf\", buf->buf\n+                                    .fields(\"address\",\"bytes\",\"access\")\n+                                    .pad((int)(16 - JAVA_BYTE.byteSize()))\n@@ -236,1 +223,3 @@\n-            .arrayLen(\"schemaLen\").array(\"schemaBytes\")\n+            )\n+            .arrayLen(\"schemaLen\")\n+            .array(\"schemaBytes\")\n@@ -240,1 +229,0 @@\n-\n@@ -277,1 +265,1 @@\n-         List<BufferTagger.AccessType> bufferAccessList = kernelCallGraph.traits.bufferAccessList;\n+        var bufferAccessList = kernelCallGraph.traits.bufferAccessList;\n@@ -293,1 +281,1 @@\n-                    byte accessByte = UNKNOWN_BYTE;\n+                    AccessType accessType = AccessType.NA;\n@@ -296,6 +284,1 @@\n-                            accessByte = switch (annotation) {\n-                                case RO ro-> Arg.Value.Buf.RO_BYTE;\n-                                case RW rw -> Arg.Value.Buf.RW_BYTE;\n-                                case WO wo -> Arg.Value.Buf.WO_BYTE;\n-                                default -> throw new IllegalStateException(\"Unexpected value: \" + annotation);\n-                            };\n+                            accessType = AccessType.of(annotation);\n@@ -303,1 +286,1 @@\n-                    }else{\n+                    } else {\n@@ -312,1 +295,6 @@\n-                    buf.access(accessByte);\n+                    buf.access(accessType.value);\n+                    assert bufferAccessList.get(i).value == accessType.value: \"buffer tagging mismatch: \"\n+                                + kernelCallGraph.entrypoint.getMethod().getParameters()[i].toString()\n+                                + \" in \" + kernelCallGraph.entrypoint.getMethod().getName()\n+                                + \" annotated as \" + AccessType.of(accessType.value)\n+                                + \" but tagged as \" + bufferAccessList.get(i).name();\n@@ -314,5 +302,0 @@\n-                    assert bufferAccessList.get(i).value == accessByte: \"buffer tagging mismatch: \"\n-                            + kernelCallGraph.entrypoint.getMethod().getParameters()[i].toString()\n-                            + \" in \" + kernelCallGraph.entrypoint.getMethod().getName()\n-                            + \" annotated as \" + BufferTagger.convertAccessType(accessByte)\n-                            + \" but tagged as \" + bufferAccessList.get(i).name();\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":38,"deletions":55,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.Invoke;\n@@ -49,0 +50,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -50,1 +52,0 @@\n-import static optkl.OpTkl.javaRefClassOrThrow;\n@@ -83,2 +84,2 @@\n-            if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                Class<?> javaRefTypeClass = javaRefClassOrThrow(lookup(), invokeOp);\n+            if (invokeOpHelper(lookup,codeElement) instanceof Invoke invoke) {\n+                Class<?> javaRefTypeClass = invoke.classOrThrow();\n@@ -86,1 +87,1 @@\n-                    var method = invokeOp.invokeDescriptor().resolveToMethod(lookup);\n+                    var method = invoke.op().invokeDescriptor().resolveToMethod(lookup);\n@@ -90,2 +91,2 @@\n-                    if (f != null && !filterCalls(f, invokeOp, method, invokeOp.invokeDescriptor(), javaRefTypeClass)) {\n-                        work.push(new RefAndFunc(invokeOp.invokeDescriptor(),  f));\n+                    if (f != null && !filterCalls(f, invoke.op(), method, invoke.op().invokeDescriptor(), javaRefTypeClass)) {\n+                        work.push(new RefAndFunc(invoke.op().invokeDescriptor(),  f));\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -45,1 +46,0 @@\n-import static optkl.OpTkl.javaRefClassOrThrow;\n@@ -140,3 +140,4 @@\n-    public boolean filterCalls(CoreOp.FuncOp f, JavaOp.InvokeOp invokeOp, Method method, MethodRef methodRef, Class<?> javaRefTypeClass) {\n-        if (entrypoint.method.getDeclaringClass().equals(javaRefClassOrThrow(computeContext.lookup(),invokeOp))\n-                && isValidKernelDispatch(computeContext.lookup(),method, f)) {\n+    public boolean filterCalls(CoreOp.FuncOp funcOp, JavaOp.InvokeOp invokeOp, Method method, MethodRef methodRef, Class<?> javaRefTypeClass) {\n+        var invoke = invokeOpHelper(computeContext.lookup(),invokeOp);\n+        if (entrypoint.method.getDeclaringClass().equals(invoke.classOrThrow())\n+                && isValidKernelDispatch(computeContext.lookup(),method, funcOp)) {\n@@ -145,1 +146,1 @@\n-                    new KernelCallGraph(this, methodRef, method, f)\n+                    new KernelCallGraph(this, methodRef, method, funcOp)\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import optkl.ifacemapper.AccessType;\n@@ -42,1 +43,1 @@\n-        public final List<BufferTagger.AccessType> bufferAccessList;\n+        public final List<AccessType> bufferAccessList;\n@@ -44,1 +45,1 @@\n-        Traits(List<BufferTagger.AccessType> bufferAccessList){\n+        Traits(List<AccessType> bufferAccessList){\n@@ -84,1 +85,1 @@\n-        this.traits = new Traits(BufferTagger.getAccessList(computeContext.lookup(), entrypoint.funcOp()));\n+        this.traits = new Traits(BufferTagger.getAccessList(computeContext.lookup(), entrypoint.getMethod(), entrypoint.funcOp()));\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import hat.optools.IfaceBufferPattern;\n-import hat.optools.RefactorMe;\n@@ -34,0 +32,1 @@\n+import optkl.FieldAccess;\n@@ -35,0 +34,1 @@\n+import optkl.Invoke;\n@@ -37,0 +37,1 @@\n+import optkl.ifacemapper.MappableIface;\n@@ -42,1 +43,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n@@ -45,1 +45,0 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -50,0 +49,2 @@\n+import static optkl.FieldAccess.fieldAccessOpHelper;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -52,1 +53,0 @@\n-import static optkl.OpTkl.getStaticFinalPrimitiveValue;\n@@ -54,2 +54,0 @@\n-import static optkl.OpTkl.javaReturnType;\n-import static optkl.OpTkl.javaReturnTypeIsVoid;\n@@ -59,1 +57,0 @@\n-import static optkl.OpTkl.needExtraParenthesis;\n@@ -61,1 +58,0 @@\n-import static optkl.OpTkl.resultOrNull;\n@@ -69,0 +65,1 @@\n+\n@@ -91,0 +88,2 @@\n+        \/\/ TODO: each of these is delegating to varName().... maybe varName should be handling these types.\n+\n@@ -95,8 +94,7 @@\n-            case CoreOp.VarOp varOp -> varName(varOp).equals();\n-            case HATF16Op.HATF16VarOp hatf16VarOp -> varName(hatf16VarOp).equals();\n-            case HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp).equals();\n-            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp).equals();\n-            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp).equals();\n-            case HATVectorOp.HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp).equals();\n-            case null, default -> {\n-            }\n+            case CoreOp.VarOp varOp -> varName(varOp);\n+            case HATF16Op.HATF16VarOp hatf16VarOp -> varName(hatf16VarOp);\n+            case HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp);\n+            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp);\n+            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp);\n+            case HATVectorOp.HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp);\n+            case null, default -> throw new IllegalStateException(\"What type of varStoreOp is this?\");\n@@ -104,1 +102,1 @@\n-        parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n+        equals().parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n@@ -133,3 +131,4 @@\n-    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n-            Object value = getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n+    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp1) {\n+        if (fieldAccessOpHelper(buildContext.lookup,fieldLoadOp1) instanceof FieldAccess fieldAccess\n+              &&  fieldAccess.operandCount()==0 && fieldAccess.isPrimitive() ) {\n+            Object value = fieldAccess.getStaticFinalPrimitiveValue();\n@@ -138,1 +137,1 @@\n-            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOp);\n+            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOp1);\n@@ -145,1 +144,2 @@\n-        return self();\n+        throw new IllegalStateException(\"What is this field store ?\" + fieldStoreOp);\n+       \/\/ return self();\n@@ -182,0 +182,1 @@\n+        \/\/ TODO: I think we need to work out how to handle doubles. If I remove this OpenCL on MAC complains (no FP64)\n@@ -349,1 +350,1 @@\n-    static Regex atomicInc = Regex.of(\"(atomic.*)Inc\");\n+    static Regex atomicIncRegex = Regex.of(\"(atomic.*)Inc\");\n@@ -353,10 +354,7 @@\n-        if (IfaceBufferPattern.isInvokeOp(buildContext.lookup, invokeOp)\n-                || RefactorMe.isInvokeDescriptorSubtypeOfAnyMatch(buildContext.lookup,invokeOp, HAType.class, DeviceType.class)) {\n-            if (invokeOp.operands().size() == 1\n-                   \/\/ && OpTk.funcName(invokeOp) instanceof String funcName\n-                    && atomicInc.is(OpTkl.funcName(invokeOp)) instanceof Regex.Match matcher\n-                    && javaReturnType(invokeOp).equals(JavaType.INT)) {\n-                if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n-                    atomicInc(buildContext, instanceResult, matcher.stringOf(1));\n-                } else {\n-                    throw new IllegalStateException(\"bad atomic\");\n+        var invoke = invokeOpHelper(buildContext.lookup,invokeOp);\n+        if ( invoke.refIs(MappableIface.class,HAType.class,DeviceType.class)) {\n+            if (invoke.isInstance() && invoke.operandCount() == 1 && invoke.returnsInt() && invoke.named(atomicIncRegex)) {\n+                if (invoke.operandNAsResultOrThrow(0) instanceof Op.Result instanceResult) {\n+                    atomicInc(buildContext, instanceResult,\n+                            ((Regex.Match)atomicIncRegex.is(invoke.name())).stringOf(1) \/\/ atomicXXInc -> atomicXX\n+                    );\n@@ -364,93 +362,37 @@\n-            } else {\n-\n-               if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n-                \/*\n-                We have three types of returned values from an ifaceBuffer\n-                A primitive\n-                    int id = stage.firstTreeId(); -> stage->firstTreeId;\n-\n-                Or a sub interface from an array\n-                     Tree tree = cascade.tree(treeIdx); -> Tree_t * tree = &cascade->tree[treeIdx]\n-                                                        ->               = cascade->tree + treeIdx;\n-\n-                Or a sub interface from a field\n-\n-                var left = feature.left();              ->  LinkOrValue_t * left= &feature->left\n-\n-                                -\n-                    if (left.hasValue()) {                  left->hasValue\n-                        sum += left.anon().value();         left->anon.value;\n-                        feature = null; \/\/ loop ends\n-                    } else {\n-                        feature = cascade.feature(tree.firstFeatureId() + left.anon().featureId());\n-                    }\n-                 sumOfThisStage += left.anon().value();\n-\n-\n-                For a primitive we know that the accessor refers to a field so we just  map\n-                         stage.firstTreeId() -> stage->firstTreeId;\n-\n-                For the sub interface we need to treat the call\n-                          cascade.tree(treeIdx);\n-\n-                As an array index into cascade->tree[] that returns a typedef of Tree_t\n-                so we need to prefix with an & to return a Tree_t ptr\n-                          &cascade->tree[treeIdx]\n-\n-                 of course we could return\n-                          cascade->tree + treeIdx;\n-                 *\/\n-\n-                   \/\/ TODO: extra parenthesis to be removed if we have a dialect to express iface memory access\n-                   boolean needExtraParenthesis = needExtraParenthesis(invokeOp);\n-                   when(needExtraParenthesis, _ -> oparen());\n-\n-                   if (javaReturnType(invokeOp) instanceof ClassType) { \/\/ isAssignable?\n-                       ampersand();\n-                        \/* This is way more complicated I think we need to determine the expression type.\n-                         * sumOfThisStage=sumOfThisStage+&left->anon->value; from    sumOfThisStage += left.anon().value();\n-                         *\/\n-                   }\n-\n-                   recurse(buildContext, instanceResult.op());\n-\n-                   \/\/ TODO: extra parenthesis to be removed if we have a dialect to express iface memory access\n-                   when(needExtraParenthesis, _ -> cparen());\n-\n-                    \/\/ Check if the varOpLoad that could follow corresponds to a local\/private type\n-                    boolean isLocalOrPrivateDS = false;\n-                    if (instanceResult.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n-                        \/\/if (localDataStructures.contains(resolve)) {\n-                        if (resolve instanceof HATMemoryVarOp) {\n-                            isLocalOrPrivateDS = true;\n-                        }\n-                    }\n-\n-                    either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n-\n-                    funcName(invokeOp);\n-\n-                    if (javaReturnTypeIsVoid(invokeOp)) {\n-                        \/\/   setter\n-                        switch (invokeOp.operands().size()) {\n-                            case 2: {\n-                                if (invokeOp.operands().get(1) instanceof Op.Result result1) {\n-                                    equals().recurse(buildContext, result1.op());\n-                                } else {\n-                                    throw new IllegalStateException(\"How \");\n-                                }\n-                                break;\n-                            }\n-                            case 3: {\n-                                if (invokeOp.operands().get(1) instanceof Op.Result result1\n-                                        && invokeOp.operands().get(2) instanceof Op.Result result2) {\n-                                    sbrace(_ -> recurse(buildContext, result1.op()));\n-                                    equals().recurse(buildContext, result2.op());\n-                                } else {\n-                                    throw new IllegalStateException(\"How \");\n-                                }\n-                                break;\n-                            }\n-                            default: {\n-                                throw new IllegalStateException(\"How \");\n+            } else if (invoke.isInstance() && invoke.operandNAsResultOrThrow(0) instanceof Op.Result instance) {\n+                parenWhen(\n+                   \/\/ When we have patterns like:\n+                   \/\/\n+                   \/\/ myiFaceArray.array().value(storeAValue);\n+                   \/\/\n+                   \/\/ We need to generate extra parenthesis to make the struct pointer accessor \"->\" correct.\n+                   \/\/ This is a common pattern when we have a IFace type that contains a subtype based on\n+                   \/\/ struct or union.\n+                   \/\/ An example of this is for the type F16Array.\n+                   \/\/ The following expression checks that the current invokeOp has at least 2 operands:\n+                    \/\/ Why 2?\n+                    \/\/ - The first one is another invokeOp to load the inner struct from an IFace data structure.\n+                    \/\/   The first operand is also assignable.\n+                    \/\/ - The second one is the store value, but this depends on the semantics and definition\n+                    \/\/   of the user code.\n+                    invoke.operandCount() > 1\n+                                && invokeOpHelper(buildContext.lookup,instance.op()) instanceof Invoke invoke0\n+                                && invoke0.returnsClassType()\n+                        , _->{\n+                    when(invoke.returnsClassType(), _ -> ampersand());\n+                    recurse(buildContext, instance.op());\n+                });\n+\n+                \/\/ Check if the varOpLoad that could follow corresponds to a local\/private type\n+                boolean isLocalOrPrivateDS = (instance.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                        && buildContext.scope.resolve(varLoadOp.operands().getFirst()) instanceof HATMemoryVarOp);\n+\n+                either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n+\n+                funcName(invoke.op());\n+\n+                if (invoke.returnsVoid()) {\/\/   setter\n+                    switch (invoke.operandCount()) {\n+                        case 2-> {\n+                            if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n+                                equals().recurse(buildContext, op);\n@@ -459,5 +401,5 @@\n-                    } else {\n-                        if (resultOrNull(invokeOp,1) instanceof Op.Result result1) {\n-                            sbrace(_ -> recurse(buildContext, result1.op()));\n-                        } else {\n-                            \/\/ This is a simple usage.   So scaleTable->multiScaleAccumRange\n+                        case 3-> {\n+                            if ( invoke.opFromOperandNAsResultOrThrow(1) instanceof Op op1\n+                                 && invoke.opFromOperandNAsResultOrThrow(2) instanceof Op op2) {\n+                                 sbrace(_ -> recurse(buildContext, op1)).equals().recurse(buildContext, op2);\n+                            }\n@@ -465,0 +407,1 @@\n+                        default -> throw new IllegalStateException(\"How \");\n@@ -467,1 +410,5 @@\n-                    throw new IllegalStateException(\"[Illegal] Expected a parameter for the InvokOpWrapper Node\");\n+                    if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n+                        sbrace(_ -> recurse(buildContext, op));\n+                    }else{\n+                            \/\/ this is just call.\n+                    }\n@@ -470,4 +417,3 @@\n-        } else {\n-            \/\/ General case\n-            funcName(invokeOp).paren(_ ->\n-                    commaSpaceSeparated(invokeOp.operands(),\n+        } else {\/\/ General case\n+            funcName(invoke.op()).paren(_ ->\n+                    commaSpaceSeparated(invoke.op().operands(),\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":83,"deletions":137,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import static optkl.FieldAccess.fieldAccessOpHelper;\n@@ -52,1 +53,0 @@\n-import static optkl.OpTkl.getStaticFinalPrimitiveValue;\n@@ -355,2 +355,3 @@\n-        if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n-            literal(getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp).toString());\n+        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldLoadOp);\n+        if (fieldAccess.operandCount()==0 && fieldAccess.isPrimitive()) {\n+            literal(fieldAccess.getStaticFinalPrimitiveValue().toString());\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.KernelContext;\n@@ -29,0 +30,1 @@\n+import optkl.FieldAccess;\n@@ -40,2 +42,1 @@\n-import static hat.optools.KernelContextPattern.KernelContextFieldAccessPattern.asKernelContextFieldAccessOrNull;\n-import static optkl.OpTkl.getStaticFinalPrimitiveValue;\n+import static optkl.FieldAccess.fieldAccessOpHelper;\n@@ -53,1 +54,2 @@\n-        if (asKernelContextFieldAccessOrNull(buildContext.lookup,fieldLoadOp, _->true)!=null) {\n+        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldLoadOp);\n+        if ( fieldAccess.refType(KernelContext.class)) {\n@@ -56,1 +58,1 @@\n-            var value = getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n+            var value = fieldAccess.getStaticFinalPrimitiveValue();\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/JavaHATCodeBuilder.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+    public HATBarrierOp() {\n+        super(List.of());\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATBarrierOp.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.CodeElement;\n-\n-import java.util.Set;\n-\n-public interface CodeModelPattern {\n-    Set<CodeElement<?, ?>> codeElements();\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/CodeModelPattern.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import hat.ComputeContext;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.javaRefType;\n-\n-public interface ComputeContextPattern extends CodeModelPattern {\n-\n-    static boolean isComputeContextMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return isAssignable(lookup, javaRefType(invokeOp), ComputeContext.class);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ComputeContextPattern.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import hat.device.DeviceType;\n-import hat.types.HAType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.ifacemapper.MappableIface;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.function.Predicate;\n-\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.isAssignableTo;\n-import static optkl.OpTkl.isMethod;\n-import static optkl.OpTkl.javaRefType;\n-\n-public interface IfaceBufferPattern extends CodeModelPattern {\n-\n-    static boolean isInvokeOp(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return (isAssignable(lookup, javaRefType(invokeOp), MappableIface.class));\n-    }\n-\n-    static boolean isIfaceBufferInvokeOpWithName(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n-        return isInvokeOp(lookup, invokeOp) && isMethod(invokeOp, namePredicate)\n-                || isAssignableTo(lookup, javaRefType(invokeOp), DeviceType.class, MappableIface.class, HAType.class)\n-                && isMethod(invokeOp, namePredicate);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/IfaceBufferPattern.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import hat.KernelContext;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.util.Regex;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.function.Predicate;\n-\n-import static optkl.OpTkl.AnyFieldAccess;\n-import static optkl.OpTkl.isAssignable;\n-\n-public interface KernelContextPattern extends CodeModelPattern {\n-\n-    private static boolean isKernelContext(MethodHandles.Lookup lookup, TypeElement typeElement) {\n-        return isAssignable(lookup, typeElement, KernelContext.class);\n-    }\n-\n-\n-    interface KernelContextFieldAccessPattern extends KernelContextPattern {\n-\n-        static JavaOp.FieldAccessOp asKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Predicate<JavaOp.FieldAccessOp> predicate) {\n-            if (ce instanceof JavaOp.FieldAccessOp fieldAccessOp\n-                    && KernelContextPattern.isKernelContext(lookup, fieldAccessOp.fieldDescriptor().refType())) {\n-                return predicate.test(fieldAccessOp) ? fieldAccessOp : null;\n-            }\n-            return null;\n-        }\n-\n-        static KernelContextFieldAccessPattern matches(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement, Predicate<JavaOp.FieldAccessOp> fieldAccessOpPredicate) {\n-            if (codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp) {\n-                if (KernelContextPattern.isKernelContext(lookup, fieldAccessOp.fieldDescriptor().refType()) && fieldAccessOpPredicate.test(fieldAccessOp)) {\n-                    try {\n-                        Field field = fieldAccessOp.fieldDescriptor().resolveToField(lookup);\n-                        record KernelContextFieldAccessPatternImpl(Set<CodeElement<?, ?>> codeElements,\n-                                                                   JavaOp.FieldAccessOp fieldAccessOp,\n-                                                                   Field field, String fieldName,\n-                                                                   TypeElement typeElement) implements KernelContextFieldAccessPattern {\n-                        }\n-                        return new KernelContextFieldAccessPatternImpl(Set.of(fieldAccessOp), fieldAccessOp, field, fieldAccessOp.fieldDescriptor().name(), fieldAccessOp.fieldDescriptor().refType());\n-                    } catch (ReflectiveOperationException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            }\n-            return null;\n-        }\n-\n-    }\n-\n-    interface KernelContextInvokePattern extends KernelContextPattern {\n-\n-        static JavaOp.InvokeOp asKernelContextInvokeOpOrNull(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Predicate<JavaOp.InvokeOp> predicate) {\n-            return ce instanceof JavaOp.InvokeOp invokeOp\n-                    && KernelContextPattern.isKernelContext(lookup, invokeOp.invokeDescriptor().refType())\n-                    && predicate.test(invokeOp)\n-                    ? invokeOp\n-                    : null;\n-        }\n-\n-        static boolean isKernelContextInvokeOp(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Predicate<JavaOp.InvokeOp> predicate) {\n-            return Objects.nonNull(asKernelContextInvokeOpOrNull(lookup, ce, predicate));\n-        }\n-\n-\n-        static KernelContextInvokePattern matches(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement, Predicate<JavaOp.InvokeOp> invokeOpPredicate) {\n-            record KernelContextInvokePatternImpl(\n-                    Set<CodeElement<?, ?>> codeElements,\n-                    JavaOp.InvokeOp invokeOp,\n-                    Method method,\n-                    String methodName,\n-                    TypeElement typeElement) implements KernelContextInvokePattern {\n-            }\n-\n-            if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                if (KernelContextPattern.isKernelContext(lookup, invokeOp.invokeDescriptor().refType()) && invokeOpPredicate.test(invokeOp)) {\n-                    try {\n-                        Method method = invokeOp.invokeDescriptor().resolveToMethod(lookup);\n-                        return new KernelContextInvokePatternImpl(Set.of(invokeOp), invokeOp, method, invokeOp.invokeDescriptor().name(), invokeOp.invokeDescriptor().refType());\n-                    } catch (ReflectiveOperationException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/KernelContextPattern.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -42,0 +42,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -43,1 +44,0 @@\n-import static optkl.OpTkl.isMethod;\n@@ -71,1 +71,1 @@\n-    public static boolean  isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n+    public  static boolean  isVectorOperation(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n@@ -80,1 +80,17 @@\n-            return interfaces.contains(_V.class) && isMethod(invokeOp, namePredicate);\n+            return interfaces.contains(_V.class) && invokeOpHelper(lookup, invokeOp).named( namePredicate);\n+        }\n+        return false;\n+    }\n+    public static boolean isAMethod(JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n+        return namePredicate.test(invokeOp.invokeDescriptor().name());\n+    }\n+    public  static boolean  isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n+        if (OpTkl.asResultOrNull(varValue) instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            TypeElement typeElement = varLoadOp.resultType();\n+            Set<Class<?>> interfaces = Set.of();\n+            try {\n+                Class<?> aClass = Class.forName(typeElement.toString());\n+                interfaces = inspectAllInterfaces(aClass);\n+            } catch (ClassNotFoundException _) {\n+            }\n+            return interfaces.contains(_V.class) && isAMethod(invokeOp, namePredicate);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/RefactorMe.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.CodeElement;\n@@ -31,1 +32,1 @@\n-import optkl.InvokeOpHelper;\n+import optkl.Invoke;\n@@ -35,1 +36,0 @@\n-import java.util.List;\n@@ -37,1 +37,0 @@\n-import java.util.stream.Collectors;\n@@ -39,1 +38,1 @@\n-import static optkl.InvokeOpHelper.invokeOpHelper;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -43,18 +42,12 @@\n-    public CoreOp.FuncOp apply(CoreOp.FuncOp fromFuncOp) {\n-         Set<CoreOp.VarAccessOp.VarLoadOp> varLoadOpSet = new HashSet<>();\n-         var trxfmr = Trxfmr.of(fromFuncOp);\n-         trxfmr.transform(\n-                 \/* predicate *\/     ce-> invokeOpHelper(lookup(),ce) instanceof InvokeOpHelper $&&$ .named(HATBarrierOp.NAME),\n-                 \/* transformation *\/c-> {\n-                     varLoadOpSet.add((CoreOp.VarAccessOp.VarLoadOp) ((Op.Result)c.op().operands().getFirst()).op());\n-                     c.replace(new HATBarrierOp(List.of()));\n-                 });\n-         var newSet=     varLoadOpSet.stream().map(varLoadOp ->trxfmr.biMap.getTo(varLoadOp)).collect(Collectors.toSet());\n-         trxfmr.transform(\n-                \/* predicate *\/   ce-> ce instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n-                         \/\/&& trxfmr.biMap.containsFrom(varLoadOp),\n-                         && newSet.contains(varLoadOp),\n-                \/* transformation *\/c-> c.remove()\n-        );\n-\n-         return trxfmr.funcOp();\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+         Set<CodeElement<?,?>> removeMe = new HashSet<>();\n+         return Trxfmr.of(funcOp)\n+                 .transform(\n+                     ce-> invokeOpHelper(lookup(),ce) instanceof Invoke $ && $.named(HATBarrierOp.NAME), \/* predicate *\/\n+                     c-> {\n+                        removeMe.add(((Op.Result)c.op().operands().getFirst()).op());\n+                        c.replace(new HATBarrierOp());\n+                    })\n+                 .remap(removeMe) \/\/ replaced varOps with new identities\n+                 .remove(removeMe::contains)\n+                 .funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.incubator.code.dialect.core.VarType;\n@@ -42,1 +41,2 @@\n-import optkl.util.CallSite;\n+import optkl.Invoke;\n+import optkl.util.Regex;\n@@ -44,0 +44,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -45,0 +46,1 @@\n+import java.util.HashSet;\n@@ -48,2 +50,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -51,2 +51,2 @@\n-\/\/import static hat.dialect.HATPhaseUtils.findF16IsLocal;\n-import static optkl.OpTkl.isMethod;\n+import static optkl.Invoke.invokeOpHelper;\n+import static optkl.Trxfmr.copyLocation;\n@@ -56,0 +56,1 @@\n+    \/\/recursive\n@@ -60,0 +61,1 @@\n+    \/\/recursive\n@@ -61,9 +63,47 @@\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findF16IsLocal(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATF16Op.HATF16VarOp hatf16VarOp) {\n-                return true;\n-            }\n-            return false;\n-        }\n+        return v instanceof Op.Result r && switch (r.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findF16IsLocal(varLoadOp); \/\/recurse\n+            case HATF16Op.HATF16VarOp hatf16VarOp -> true;\n+            default -> false;\n+        };\n+    }\n+\n+\/\/recursive\n+    private static boolean findReference(MethodHandles.Lookup lookup,CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findReference(lookup,varLoadOp.operands().getFirst());\n+    }\n+\/\/recursive\n+    private static boolean findReference(MethodHandles.Lookup lookup,Value v) {\n+        return v instanceof Op.Result result && switch (result.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findReference(lookup,varLoadOp); \/\/ recurse\n+            case CoreOp.VarOp varOp ->\n+                    varOp.operands().getFirst() instanceof Op.Result varOpResult\n+                            && invokeOpHelper(lookup,varOpResult.op()) instanceof Invoke invoke && invoke.named(\"array\");\n+            default -> false;\n+        };\n+    }\n+\n+    \/\/recursive\n+    private static boolean isOperandF32(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return isOperandF32(varLoadOp.operands().getFirst());\n+    }\n+\n+    \/\/recursive\n+    private static boolean isOperandF32(Value v) {\n+        return v instanceof Op.Result r && switch (r.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> isOperandF32(varLoadOp); \/\/recurse\n+            case CoreOp.VarOp varOp -> varOp.resultType().valueType() == JavaType.FLOAT;\n+            default -> false;\n+        };\n+    }\n+    \/\/ recursive\n+    private static String findNameOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameOrNull(varLoadOp.operands().getFirst());\n+    }\n+\n+    \/\/ recursive\n+    private static String findNameOrNull(Value v) {\n+        return  (v instanceof Op.Result r) ? switch (r.op()){\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp->findNameOrNull(varLoadOp); \/\/recurse\n+            case HATF16Op.HATF16VarOp hatf16VarOp -> hatf16VarOp.varName();\n+            default -> null;\n+        }:null;\n@@ -71,1 +111,1 @@\n-    private ReducedFloatType categorizeReducedFloat(JavaOp.InvokeOp invokeOp) {\n+    private static ReducedFloatType categorizeReducedFloat(JavaOp.InvokeOp invokeOp) {\n@@ -74,1 +114,1 @@\n-        if (invokeClassName.equals(F16.class.getName())) {\n+        if (invokeClassName.equals(F16.class.getName())) { \/\/ lets not compare strings here\n@@ -76,1 +116,1 @@\n-        } else if (invokeClassName.equals(BF16.class.getName())) {\n+        } else if (invokeClassName.equals(BF16.class.getName())) { \/\/ lets not compare strings here\n@@ -82,3 +122,3 @@\n-    private boolean is16BitFloatOperation(JavaOp.InvokeOp invokeOp, String methodName) {\n-        String invokeClassName = invokeOp.invokeDescriptor().refType().toString();\n-        invokeClassName = invokeClassName.replace(\"$\", \".\");\n+    private boolean is16BitFloat(Invoke invoke, Regex methodName) {\n+        String invokeClassName = invoke.refType().toString();\n+        invokeClassName = invokeClassName.replace(\"$\", \".\"); \/\/ lets not compare strings here\n@@ -89,34 +129,1 @@\n-                && invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\/\/recursive\n-    private boolean findReference(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findReference(varLoadOp.operands().get(0));\n-    }\n-\/\/recursive\n-    private boolean findReference(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findReference(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n-                Value first = varOp.operands().getFirst();\n-                return first instanceof Op.Result r2 && r2.op() instanceof JavaOp.InvokeOp invokeOp && invokeOp.invokeDescriptor().name().equals(\"array\");\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private boolean isOperandF32(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return isOperandF32(varLoadOp.operands().get(0));\n-    }\n-\n-    private boolean isOperandF32(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return isOperandF32(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n-                VarType varType = varOp.resultType();\n-                TypeElement typeElement = varType.valueType();\n-                return typeElement == JavaType.FLOAT;\n-            }\n-            return false;\n-        }\n+                && invoke.named(methodName);\/\/ lets not compare strings here\n@@ -126,15 +133,9 @@\n-        List<Value> operands = varOp.operands();\n-        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n-        HATF16Op.HATF16VarOp hatf16VarOp = new HATF16Op.HATF16VarOp(varOp.varName(), reducedFloatType, varOp.resultType(), outputOperands);\n-        Op.Result op1 = blockBuilder.op(hatf16VarOp);\n-        hatf16VarOp.setLocation(varOp.location());\n-        blockBuilder.context().mapValue(varOp.result(), op1);\n-    }\n-\n-    private void createF16ConvOP(JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n-        List<Value> operands = invokeOp.operands();\n-        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n-        HATF16Op.HATF16ConvOp convOp1 = new HATF16Op.HATF16ConvOp(JavaType.VOID, reducedFloatType, outputOperands);\n-        Op.Result op1 = blockBuilder.op(convOp1);\n-        convOp1.setLocation(invokeOp.location());\n-        blockBuilder.context().mapValue(invokeOp.result(), op1);\n+           blockBuilder.context().mapValue(varOp.result(),\n+                blockBuilder.op(copyLocation(varOp,\n+                       new HATF16Op.HATF16VarOp(\n+                               varOp.varName(),\n+                               reducedFloatType, varOp.resultType(),\n+                               blockBuilder.context().getValues(varOp.operands()))\n+                        )\n+                )\n+           );\n@@ -143,15 +144,10 @@\n-    private void createFloatFromF16(JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n-        List<Value> operands = invokeOp.operands();\n-        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n-        boolean isLocal = findF16IsLocal(operands.getFirst());\n-        boolean wasFloat = false;\n-        Value first = operands.getFirst();\n-        if (first instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            if  (varLoadOp.resultType().equals(JavaType.FLOAT)) {\n-                wasFloat = true;\n-            }\n-        }\n-        HATF16Op.HATF16ToFloatConvOp convOp1 = new HATF16Op.HATF16ToFloatConvOp(JavaType.FLOAT, reducedFloatType, isLocal, wasFloat, outputOperands);\n-        Op.Result op1 = blockBuilder.op(convOp1);\n-        convOp1.setLocation(invokeOp.location());\n-        blockBuilder.context().mapValue(invokeOp.result(), op1);\n+    private void createF16ConvOP(Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n+        blockBuilder.context().mapValue(invoke.op().result(),\n+                blockBuilder.op(copyLocation(invoke.op(),\n+                        new HATF16Op.HATF16ConvOp(\n+                                JavaType.VOID,\n+                                reducedFloatType,\n+                                blockBuilder.context().getValues(invoke.op().operands()))\n+                        )\n+                )\n+        );\n@@ -159,1 +155,0 @@\n-\n@@ -161,7 +156,26 @@\n-        List<Value> operands = varLoadOp.operands();\n-        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n-        String nameVar = findName(varLoadOp);\n-        HATF16Op.HATF16VarLoadOp hatf16VarLoadOp = new HATF16Op.HATF16VarLoadOp(nameVar, varLoadOp.varType(), outputOperands);\n-        Op.Result op1 = blockBuilder.op(hatf16VarLoadOp);\n-        hatf16VarLoadOp.setLocation(varLoadOp.location());\n-        blockBuilder.context().mapValue(varLoadOp.result(), op1);\n+        blockBuilder.context().mapValue(varLoadOp.result(),\n+                blockBuilder.op(copyLocation(varLoadOp,\n+                                new HATF16Op.HATF16VarLoadOp(\n+                                        findNameOrNull(varLoadOp),\n+                                        varLoadOp.varType(),\n+                                        blockBuilder.context().getValues(varLoadOp.operands()))\n+                        )\n+                )\n+        );\n+    }\n+    private void createFloatFromF16(Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n+        boolean wasFloat = invoke.op().operands().getFirst() instanceof Op.Result r\n+                && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                && varLoadOp.resultType().equals(JavaType.FLOAT);\n+\n+        blockBuilder.context().mapValue(invoke.op().result(),\n+                blockBuilder.op(copyLocation(invoke.op(),\n+                        new HATF16Op.HATF16ToFloatConvOp(\n+                                JavaType.FLOAT,\n+                                reducedFloatType,\n+                                findF16IsLocal(invoke.op().operands().getFirst()),\n+                                wasFloat,\n+                                blockBuilder.context().getValues(invoke.op().operands()))\n+                        )\n+                )\n+        );\n@@ -172,1 +186,0 @@\n-        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n@@ -177,2 +190,2 @@\n-        boolean isFirstOperandReference = findReference(invokeOp.operands().getFirst());\n-        boolean isSecondOperandReference = findReference(invokeOp.operands().get(1));\n+        boolean isFirstOperandReference = findReference(lookup(),invokeOp.operands().getFirst());\n+        boolean isSecondOperandReference = findReference(lookup(),invokeOp.operands().get(1));\n@@ -181,1 +194,1 @@\n-        if (!isFirstOperandReference && isOperandF32(invokeOp.operands().getFirst())) {\n+        if (!isFirstOperandReference && isOperandF32(invokeOp.operands().get(0))) {\n@@ -190,0 +203,2 @@\n+\n+        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n@@ -197,3 +212,1 @@\n-        Op.Result op1 = blockBuilder.op(binaryOp);\n-        binaryOp.setLocation(invokeOp.location());\n-        blockBuilder.context().mapValue(invokeOp.result(), op1);\n+        blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(copyLocation(invokeOp,binaryOp)));\n@@ -203,3 +216,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyF16Ops\");\n-        before(here, funcOp);\n-\n@@ -208,19 +218,11 @@\n-        Stream<CodeElement<?, ?>> halfOps = funcOp.elements()\n-                .mapMulti(((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (is16BitFloatOperation(invokeOp, binaryOpEnum.name().toLowerCase()) && invokeOp.resultType() != JavaType.VOID) {\n-                            Set<Op.Result> uses = invokeOp.result().uses();\n-                            consumer.accept(invokeOp);\n-                            ReducedFloatType category = categorizeReducedFloat(invokeOp);\n-                            reducedFloatsType.put(invokeOp, category);\n-                            for (Op.Result result : uses) {\n-                                if (result.op() instanceof CoreOp.VarOp varOp) {\n-                                    consumer.accept(varOp);\n-                                    reducedFloatsType.put(varOp, category);\n-                                    \/\/ The variable is created only once for a usage in the same scope\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }));\n+        Invoke.stream(lookup(),funcOp)\n+                .filter(invoke -> is16BitFloat(invoke, Regex.of(binaryOpEnum.name().toLowerCase())) && !invoke.returnsVoid())\n+                .forEach(invoke ->  {\n+                        ReducedFloatType category = categorizeReducedFloat(invoke.op());\n+                        reducedFloatsType.put(invoke.op(), category);\n+                        invoke.op().result().uses().stream()\n+                                .filter(result -> result.op() instanceof CoreOp.VarOp)\n+                                .map(result -> (CoreOp.VarOp)result.op())\n+                                .findFirst()\/\/ we expect one\n+                                .ifPresent(varOp->reducedFloatsType.put(varOp,category));\n+                });\n@@ -228,1 +230,0 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = halfOps.collect(Collectors.toSet());\n@@ -230,1 +231,1 @@\n-            if (!nodesInvolved.contains(op)) {\n+            if (!reducedFloatsType.containsKey(op)) {\n@@ -239,1 +240,0 @@\n-        after(here, funcOp);\n@@ -244,17 +244,8 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyF16Stores\");\n-        before(here, funcOp);\n-\n-        Stream<CodeElement<?, ?>> halfOps = funcOp.elements()\n-                .mapMulti(((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (is16BitFloatOperation(invokeOp, \"value\") &&\n-                                (invokeOp.resultType() == JavaType.SHORT || invokeOp.resultType() == JavaType.CHAR)) {\n-                            \/\/ This invoke only has one argument: the value to store\n-                            Value value = invokeOp.operands().getFirst();\n-                            if (value instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                Value valLoad = varLoadOp.operands().getFirst();\n-                                if (valLoad instanceof Op.Result r1 && r1.op() instanceof HATF16Op.HATF16VarOp) {\n-                                    consumer.accept(invokeOp);\n-                                    consumer.accept(varLoadOp);\n-                                }\n-                            }\n+        Set<CodeElement<?,?>> nodesInvolved = new HashSet<>();\n+        Invoke.stream(lookup(),funcOp)\n+                .filter(invoke-> is16BitFloat(invoke,Regex.of(\"value\")) && invoke.returns16BitValue())\n+                .forEach(invoke -> {\n+                    if(invoke.opFromFirstOperandAsResultOrNull() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                         && varLoadOp.operands().getFirst() instanceof Op.Result firstOperandsOpResult\n+                         && firstOperandsOpResult.op() instanceof HATF16Op.HATF16VarOp) {\n+                             nodesInvolved.addAll(Set.of(invoke.op(),varLoadOp));\n@@ -262,4 +253,1 @@\n-                    }\n-                }));\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = halfOps.collect(Collectors.toSet());\n+                });\n@@ -271,4 +259,2 @@\n-                blockBuilder.context().mapValue(\n-                        invokeOp.result(), \/\/\n-                        blockBuilder.context().getValue(invokeOp.operands().getFirst()) \/\/\n-                );\n+                var ctx = blockBuilder.context();\n+                ctx.mapValue(invokeOp.result(), ctx.getValue(invokeOp.operands().getFirst()));\n@@ -280,2 +266,0 @@\n-\n-        after(here, funcOp);\n@@ -285,5 +269,0 @@\n-    private boolean isInitMethodForF16(JavaOp.InvokeOp invokeOp) {\n-        return (is16BitFloatOperation(invokeOp, \"of\")\n-                || is16BitFloatOperation(invokeOp, \"floatToF16\")\n-                || is16BitFloatOperation(invokeOp, \"float2bfloat16\"));\n-    }\n@@ -292,3 +271,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyF16Init\");\n-        before(here, funcOp);\n-\n@@ -297,10 +273,9 @@\n-        Stream<CodeElement<?, ?>> halfOps = funcOp.elements()\n-                .mapMulti(((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isInitMethodForF16(invokeOp) && invokeOp.resultType() != JavaType.VOID) {\n-                            Set<Op.Result> uses = invokeOp.result().uses();\n-                            for (Op.Result result : uses) {\n-                            if (result.op() instanceof CoreOp.VarOp varOp) {\n-                                consumer.accept(varOp);\n-                                consumer.accept(invokeOp);\n-                                ReducedFloatType reducedFloatType = categorizeReducedFloat(invokeOp);\n+        Invoke.stream(lookup(),funcOp)\n+                .filter(invoke -> !invoke.returnsVoid() && is16BitFloat(invoke, Regex.of(\"(of|floatToF16|float2bfloat16)\")))\n+                .forEach(invoke ->\n+                    invoke.op().result().uses().stream()\n+                            .filter(result -> result.op() instanceof CoreOp.VarOp)\n+                            .map(result -> (CoreOp.VarOp) result.op() )\n+                            .findFirst()\n+                            .ifPresent(varOp -> { \/\/ is there only one?\n+                                ReducedFloatType reducedFloatType = categorizeReducedFloat(invoke.op());\n@@ -308,6 +283,3 @@\n-                                reducedFloatsType.put(invokeOp, reducedFloatType);\n-                            }\n-                        }\n-                        }\n-                    }\n-                }));\n+                                reducedFloatsType.put(invoke.op(), reducedFloatType);\n+                    })\n+                );\n@@ -315,1 +287,0 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = halfOps.collect(Collectors.toSet());\n@@ -317,1 +288,1 @@\n-            if (!nodesInvolved.contains(op)) {\n+            if (!reducedFloatsType.containsKey(op)) {\n@@ -320,1 +291,1 @@\n-                createF16ConvOP(invokeOp, blockBuilder, reducedFloatsType.get(invokeOp));\n+                createF16ConvOP(invokeOpHelper(lookup(),invokeOp), blockBuilder, reducedFloatsType.get(invokeOp));\n@@ -326,1 +297,0 @@\n-        after(here, funcOp);\n@@ -331,3 +301,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyF16ToFloat\");\n-        before(here, funcOp);\n-\n@@ -335,0 +302,6 @@\n+        funcOp.elements()\n+                .filter(ce->ce instanceof JavaOp.InvokeOp)\n+                .map(ce->invokeOpHelper(lookup(),ce))\n+                .filter(invoke->(invoke.named(\"f16ToFloat\")||invoke.named(\"bfloat162float\")) && invoke.returnsFloat())\n+                .findFirst() \/\/ only one?\n+                .ifPresent(invoke -> reducedFloatsType.put(invoke.op(), categorizeReducedFloat(invoke.op())));\n@@ -336,10 +309,0 @@\n-        Stream<CodeElement<?, ?>> halfOps = funcOp.elements()\n-                .mapMulti(((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if ((isMethod(invokeOp, n->n.equals(\"f16ToFloat\")||n.equals(\"bfloat162float\")))\n-                                && invokeOp.resultType() == JavaType.FLOAT) {\n-                            consumer.accept(invokeOp);\n-                            reducedFloatsType.put(invokeOp, categorizeReducedFloat(invokeOp));\n-                        }\n-                    }\n-                }));\n@@ -347,1 +310,0 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = halfOps.collect(Collectors.toSet());\n@@ -349,1 +311,1 @@\n-            if (!nodesInvolved.contains(op)) {\n+            if (!reducedFloatsType.containsKey(op)) {\n@@ -352,1 +314,1 @@\n-                createFloatFromF16(invokeOp, blockBuilder, reducedFloatsType.get(invokeOp));\n+                createFloatFromF16(invokeOpHelper(lookup(),invokeOp), blockBuilder, reducedFloatsType.get(invokeOp));\n@@ -356,1 +318,0 @@\n-        after(here, funcOp);\n@@ -360,14 +321,0 @@\n-    private String findName(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findName(varLoadOp.operands().get(0));\n-    }\n-\n-    private String findName(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findName(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATF16Op.HATF16VarOp hatf16VarOp) {\n-                return hatf16VarOp.varName();\n-            }\n-            return null;\n-        }\n-    }\n@@ -377,1 +324,1 @@\n-        for (BinaryOpEnum binaryOpEnum : BinaryOpEnum.values())\n+        for (BinaryOpEnum binaryOpEnum : BinaryOpEnum.values()) {\n@@ -380,1 +327,1 @@\n-\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":160,"deletions":213,"binary":false,"changes":373,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.optools.IfaceBufferPattern;\n@@ -33,0 +32,1 @@\n+import hat.types.HAType;\n@@ -39,2 +39,2 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n+import optkl.Invoke;\n+import optkl.ifacemapper.MappableIface;\n@@ -51,2 +51,1 @@\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.isMethod;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -54,0 +53,1 @@\n+import static optkl.Trxfmr.copyLocation;\n@@ -76,1 +76,1 @@\n-    protected abstract boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp);\n+    protected abstract boolean isIfaceBufferInvokeWithName(Invoke invoke);\n@@ -97,1 +97,1 @@\n-                                && isIfaceBufferInvokeWithName(invokeOp))\n+                                && isIfaceBufferInvokeWithName(invokeOpHelper(lookup(),invokeOp)))\n@@ -107,4 +107,3 @@\n-                invokeOp.result()\n-                        .uses()\n-                        .stream()\n-                        .filter(r->r.op() instanceof CoreOp.VarOp).map(r->(CoreOp.VarOp)r.op())\n+                invokeOp.result().uses().stream()\n+                        .filter(result->result.op() instanceof CoreOp.VarOp)\n+                        .map(r->(CoreOp.VarOp)r.op())\n@@ -115,1 +114,1 @@\n-                      blockBuilder.context().mapValue(varOp.result(), blockBuilder.context().getValue(varOp.operands().getFirst()));\n+                blockBuilder.context().mapValue(varOp.result(), blockBuilder.context().getValue(varOp.operands().getFirst()));\n@@ -132,7 +131,4 @@\n-        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp) {\n-            if (IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(), invokeOp, n->n.equals(HATMemoryVarOp.HATPrivateVarOp.INTRINSIC_NAME))) {\n-                return true;\n-            } else {\n-                return isMethod(invokeOp, n->n.equals(HATMemoryVarOp.HATPrivateVarOp.INTRINSIC_NAME))\n-                        && isAssignable(lookup(),invokeOp.invokeDescriptor().refType(),DeviceType.class);\n-            }\n+        protected boolean isIfaceBufferInvokeWithName(Invoke invoke) {\n+            return invoke.refIs( DeviceType.class, MappableIface.class, HAType.class)\n+                    && invoke.named(HATMemoryVarOp.HATPrivateVarOp.INTRINSIC_NAME);\n+\n@@ -156,1 +152,0 @@\n-\n@@ -162,8 +157,4 @@\n-        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n-            if (IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))) {\n-                return true;\n-            } else {\n-                return (isMethod(invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))\n-                        && invokeOp.resultType() instanceof JavaType javaType &&\n-                        isAssignable(lookup(),javaType,DeviceType.class));\n-            }\n+        protected boolean isIfaceBufferInvokeWithName(Invoke invoke){\n+            return invoke.refIs( DeviceType.class, MappableIface.class, HAType.class)\n+                    && invoke.named(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME);\n+\n@@ -174,1 +165,1 @@\n-            var op = new HATMemoryVarOp.HATLocalVarOp(\n+            return  copyLocation(varOp,new HATMemoryVarOp.HATLocalVarOp(\n@@ -180,3 +171,1 @@\n-            );\n-            op.setLocation(varOp.location());\n-            return op;\n+            ));\n@@ -193,5 +182,3 @@\n-        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n-            return IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))\n-               || (isMethod(invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))\n-                    && invokeOp.resultType() instanceof JavaType javaType &&\n-                    isAssignable(lookup(),javaType,DeviceType.class));\n+        protected boolean isIfaceBufferInvokeWithName(Invoke invoke){\n+            return invoke.refIs( DeviceType.class, MappableIface.class, HAType.class)\n+                 || invoke.named(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME);\n@@ -200,3 +187,0 @@\n-         private boolean isDeviceTypeReservedMethod(JavaOp.InvokeOp invokeOp){\n-            return reservedMethods.contains(invokeOp.invokeDescriptor().name());\n-        }\n@@ -204,5 +188,5 @@\n-        private boolean meetConditionsForMemoryLoadOp(JavaOp.InvokeOp invokeOp) {\n-            return RefactorMe.isInvokeDescriptorSubtypeOf(lookup(),invokeOp, DeviceType.class)\n-                    && (invokeOp.resultType() != JavaType.VOID)\n-                    && (!(invokeOp.resultType() instanceof PrimitiveType))\n-                    && (!isDeviceTypeReservedMethod(invokeOp));\n+        private boolean meetConditionsForMemoryLoadOp(Invoke invoke) {\n+            return RefactorMe.isInvokeDescriptorSubtypeOf(lookup(),invoke.op(), DeviceType.class)\n+                    && !invoke.returnsVoid()\n+                    && !invoke.returnsPrimitive()\n+                    && !reservedMethods.contains(invoke.name());\n@@ -218,3 +202,3 @@\n-                        if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                            if (meetConditionsForMemoryLoadOp(invokeOp)) {\n-                                Op.Result result = invokeOp.result();\n+                        if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke) {\n+                            if (meetConditionsForMemoryLoadOp(invoke)) {\n+                                Op.Result result = invoke.op().result();\n@@ -224,2 +208,2 @@\n-                                        varTable.put(varOp, invokeOp);\n-                                        consumer.accept(invokeOp);\n+                                        varTable.put(varOp, invoke.op());\n+                                        consumer.accept(invoke.op());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":34,"deletions":50,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.KernelContext;\n@@ -30,1 +31,1 @@\n-import hat.optools.KernelContextPattern;\n+import optkl.FieldAccess;\n@@ -40,0 +41,2 @@\n+\n+import static optkl.FieldAccess.fieldAccessOpHelper;\n@@ -69,2 +72,6 @@\n-                ce-> KernelContextPattern.KernelContextFieldAccessPattern.asKernelContextFieldAccessOrNull(\n-                        lookup(),ce,fieldAccessOp->fieldNameRegex.matches(fieldAccessOp.fieldDescriptor().name()))!=null,(s, o)->\n+                ce-> fieldAccessOpHelper(lookup(),ce) instanceof FieldAccess fieldAccess\n+                        && fieldAccess.refType(KernelContext.class)\n+                && fieldAccess.named(fieldNameRegex)\n+              \/\/  fieldAccessOpKernelContextPattern.asKernelContextFieldAccessOrNull(\n+        \/\/                lookup(),ce,fieldAccessOp->fieldNameRegex.matches(fieldAccessOp.fieldDescriptor().name()))!=null\n+        ,(s, o)->\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import optkl.Invoke;\n@@ -51,1 +52,0 @@\n-\/\/import static hat.dialect.HATPhaseUtils.findVectorTypeElement;\n@@ -53,0 +53,1 @@\n+import static hat.optools.RefactorMe.isAMethod;\n@@ -54,1 +55,0 @@\n-import static optkl.OpTkl.isMethod;\n@@ -139,1 +139,1 @@\n-                   && isMethod(invokeOp, n->n.equals(vectorOperation.methodName))\n+                   && isAMethod(invokeOp, n->n.equals(vectorOperation.methodName))\n@@ -144,1 +144,1 @@\n-        return findIsSharedOrPrivate(varLoadOp.operands().get(0));\n+        return findIsSharedOrPrivate(varLoadOp.operands().getFirst());\n@@ -149,8 +149,5 @@\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findIsSharedOrPrivate(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && (r.op() instanceof HATMemoryVarOp.HATLocalVarOp || r.op() instanceof HATMemoryVarOp.HATPrivateVarOp)) {\n-                return true;\n-            }\n-            return false;\n-        }\n+        return v instanceof Op.Result result && switch (result.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findIsSharedOrPrivate(varLoadOp); \/\/recurse\n+            case HATMemoryVarOp.HATLocalVarOp _, HATMemoryVarOp.HATPrivateVarOp _ -> true;\n+            default -> false;\n+        };\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -48,1 +49,0 @@\n-import static optkl.OpTkl.isMethod;\n@@ -55,1 +55,1 @@\n-        return isMethod(invokeOp, n->xyzw.matches(n));\n+        return invokeOpHelper(lookup(),invokeOp).named(xyzw);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-import static optkl.InvokeOpHelper.invokeOpHelper;\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import optkl.InvokeOpHelper;\n+import optkl.Invoke;\n@@ -32,1 +32,1 @@\n-import static optkl.InvokeOpHelper.invokeOpHelper;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -76,1 +76,1 @@\n-            if (invokeOpHelper(lookup,op) instanceof InvokeOpHelper ih\n+            if (invokeOpHelper(lookup,op) instanceof Invoke ih\n@@ -96,1 +96,1 @@\n-                .transform(ce-> InvokeOpHelper.invokeOpHelper(lookup,ce) instanceof InvokeOpHelper $\n+                .transform(ce-> Invoke.invokeOpHelper(lookup,ce) instanceof Invoke $\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+\n+import static optkl.OpTkl.classTypeToTypeOrThrow;\n+\n+public interface FieldAccess extends OpHelper<JavaOp.FieldAccessOp>{\n+\n+    @Override\n+    default  String name(){\n+        return op().fieldDescriptor().name();\n+    }\n+\n+    default boolean isPrimitive(){\n+        return op().result().type() instanceof PrimitiveType;\n+    }\n+\n+    default TypeElement refType(){\n+        return op().fieldDescriptor().refType();\n+    }\n+    default boolean refType(Class<?> ... classes){\n+        return OpTkl.isAssignable(lookup(),refType(),classes);\n+    }\n+    default  Object getStaticFinalPrimitiveValue() {\n+        if (refType() instanceof ClassType classType) {\n+            Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n+            try {\n+                Field field = clazz.getField(name());\n+                field.setAccessible(true);\n+                return field.get(null);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        throw new RuntimeException(\"Could not find field value\" + op());\n+    }\n+\n+    static FieldAccess fieldAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements FieldAccess {}\n+        return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp? new Impl(lookup,fieldAccessOp): null;\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/FieldAccess.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.core.VarType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.util.Regex;\n-import optkl.util.carriers.LookupCarrier;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public record FieldAccessOpHelper(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements LookupCarrier,OpHelper<JavaOp.FieldAccessOp> {\n-    @Override\n-    public boolean isStatic(){\n-        return true;\/\/fieldAccessOp.invokeKind().equals(JavaOp.FieldAccessOp.InvokeKind.STATIC);\n-    }\n-    @Override\n-    public boolean isInstance(){\n-        return true;\/\/fieldAccessOp.invokeKind().equals(JavaOp.FieldAccessOp.InvokeKind.INSTANCE);\n-    }\n-    @Override\n-    public String name(){\n-        return op.fieldDescriptor().name();\n-    }\n-\n-    public <T>boolean of(Class<T> clazz){\n-        return isAssignable(clazz,(JavaType) op.resultType());\n-    }\n-\n-    public static FieldAccessOpHelper fieldAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-        return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp? new FieldAccessOpHelper(lookup,fieldAccessOp): null;\n-\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/FieldAccessOpHelper.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.ArrayType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+import optkl.ifacemapper.MappableIface;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+\n+public interface Invoke extends OpHelper<JavaOp.InvokeOp>{\n+\n+    static Stream<Invoke> stream(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n+       return  funcOp.elements().filter(ce->ce instanceof JavaOp.InvokeOp).map(ce->invokeOpHelper(lookup,ce));\n+    }\n+\n+    default  boolean isStatic(){\n+        return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n+    }\n+     default  boolean isInstance(){\n+        return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n+    }\n+    @Override default String name(){\n+        return op().invokeDescriptor().name();\n+    }\n+    default <T>boolean returns(Class<T> clazz){\n+        return isAssignable((JavaType)op().resultType(),clazz);\n+    }\n+    default boolean receives(Class<?>... classes){\n+        boolean  assignable = true;\n+        for (int i=isStatic()?1:0; assignable && i< classes.length; i++) {\n+            var operand = op().operands().get(i);\n+            TypeElement resultType = operand.type() instanceof VarType varType?varType.valueType():null;\n+            assignable &= isAssignable((JavaType) resultType,classes[i-(isStatic()?1:0)]);\n+        }\n+        return assignable;\n+    }\n+\n+    default Method resolvedMethodOrNull(){\n+        try {\n+            return op().invokeDescriptor().resolveToMethod(lookup()) instanceof Method method ? method : null;\n+        }catch (ReflectiveOperationException rope){\n+            return null;\n+        }\n+    }\n+\n+     static Invoke invokeOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Invoke {}\n+\n+        return codeElement instanceof JavaOp.InvokeOp invokeOp? new Impl(lookup,invokeOp): null;\n+    }\n+\n+     default boolean refIs(Class<?> ...classes) {\n+        return OpTkl.isAssignable(lookup(), op().invokeDescriptor().refType(), classes);\n+    }\n+\n+     default boolean returnsArray() {\n+        return op().resultType() instanceof ArrayType;\n+    }\n+\n+     default boolean returnsVoid() {\n+        return op().invokeDescriptor().type().returnType().equals(JavaType.VOID);\n+    }\n+\n+     default   TypeElement returnType() {\n+        return op().invokeDescriptor().type().returnType();\n+    }\n+\n+    default boolean returnsInt(){\n+        return returnType().equals(JavaType.INT);\n+    }\n+\n+\n+\n+    default boolean returnsClassType(){\n+        return returnType() instanceof ClassType;\n+    }\n+\n+\n+    default TypeElement refType(){\n+        return op().invokeDescriptor().refType();\n+    }\n+\n+    default boolean returnsPrimitive(){\n+        return returnType() instanceof PrimitiveType ;\n+    }\n+    default boolean returnsFloat(){\n+        return returnType() == JavaType.FLOAT;\n+    }\n+    default boolean returnsChar(){\n+       return returnType() ==   JavaType.CHAR;\n+    }\n+    default boolean returnsShort(){\n+        return returnType() ==   JavaType.SHORT ;\n+    }\n+    default boolean returns16BitValue(){\n+        return returnsChar()||returnsShort();\n+    }\n+    default Method resolveMethodOrNull() {\n+        try {\n+            return op().invokeDescriptor().resolveToMethod(lookup());\n+        } catch (ReflectiveOperationException e) {\n+           return null;\n+        }\n+    }\n+    default Method resolveMethodOrThrow() {\n+        try {\n+            return op().invokeDescriptor().resolveToMethod(lookup());\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    default Class<?> classOrThrow() {\n+        if (refType() instanceof ClassType classType) {\n+            return (Class<?>) OpTkl.classTypeToTypeOrThrow(lookup(), classType);\n+        } else {\n+            throw new IllegalStateException(\" javaRef class is null\");\n+        }\n+    }\n+\n+    default boolean isMappableIface() {\n+        return refIs(MappableIface.class);\n+    }\n+    static Invoke getTargetInvoke(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n+        return lambdaOp.body().entryBlock().ops().stream()\n+                .filter(ce -> ce instanceof JavaOp.InvokeOp)\n+                .map(ce -> invokeOpHelper(lookup,ce))\n+                .filter(Invoke::isStatic)\n+                .filter(invoke -> OpTkl.isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n+                .findFirst()\n+                .orElseThrow();\n+    }\n+\n+\n+\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Invoke.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.core.VarType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.util.Regex;\n-import optkl.util.carriers.LookupCarrier;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public record InvokeOpHelper(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements LookupCarrier,OpHelper<JavaOp.InvokeOp>{\n-    @Override public boolean isStatic(){\n-        return op.invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n-    }\n-    @Override public boolean isInstance(){\n-        return op.invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n-    }\n-    @Override public String name(){\n-        return op.invokeDescriptor().name();\n-    }\n-    public <T>boolean returns(Class<T> clazz){\n-        return isAssignable(clazz,(JavaType)op.resultType());\n-    }\n-    public boolean receives(Class<?>... classes){\n-        boolean  assignable = true;\n-        for (int i=isStatic()?1:0; assignable && i< classes.length; i++) {\n-            var operand = op.operands().get(i);\n-            TypeElement resultType = operand.type() instanceof VarType varType?varType.valueType():null;\n-            assignable &= isAssignable(classes[i-(isStatic()?1:0)], (JavaType) resultType);\n-        }\n-        return assignable;\n-    }\n-\n-    public static InvokeOpHelper invokeOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-        return codeElement instanceof JavaOp.InvokeOp invokeOp? new InvokeOpHelper(lookup,invokeOp): null;\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/InvokeOpHelper.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.function.Predicate;\n+\n@@ -34,2 +36,1 @@\n-    boolean isStatic();\n-    boolean isInstance();\n+\n@@ -37,0 +38,1 @@\n+\n@@ -43,1 +45,4 @@\n-    default <C>boolean isAssignable( Class<C> clazz, JavaType javaType){\n+    default boolean named(Predicate<String> predicate){\n+        return predicate.test(name());\n+    }\n+    default <C>boolean isAssignable(JavaType javaType, Class<C> clazz){\n@@ -60,0 +65,37 @@\n+    default  int operandCount(){\n+        return op().operands().size();\n+    }\n+    default Op.Result operandNAsResultOrNull(int i){\n+        return OpTkl.operandAsResult(op(),i) instanceof Op.Result result?result:null;\n+    }\n+    default Op.Result firstOperandAsResultOrNull(int i){\n+        return operandNAsResultOrNull(0);\n+    }\n+    default Op.Result  operandNAsResultOrThrow(int i){\n+        if (operandNAsResultOrNull(i) instanceof Op.Result result){\n+            return result;\n+        }else {\n+            throw new IllegalStateException(\"Expecting operand \"+i+\" to be a result\");\n+        }\n+    }\n+    default Op.Result firstOperandAsResultOrThrow(){\n+        return operandNAsResultOrThrow(0);\n+    }\n+\n+    default Op opFromOperandNAsResultOrNull(int i){\n+        return operandNAsResultOrNull(i) instanceof Op.Result result && result.op() instanceof Op op ?op:null;\n+    }\n+    default Op opFromFirstOperandAsResultOrNull(){\n+        return opFromOperandNAsResultOrNull(0);\n+    }\n+    default Op opFromOperandNAsResultOrThrow(int i){\n+        if ( opFromOperandNAsResultOrNull(i)  instanceof Op op){\n+            return op;\n+        }else {\n+            throw new IllegalStateException(\"Expecting operand \"+i+\" to be a result which yields an Op \");\n+        }\n+    }\n+    default Op opFromFirstOperandAsResultOrThrow(){\n+        return opFromOperandNAsResultOrThrow(0);\n+    }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":45,"deletions":3,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.code.CodeContext;\n@@ -35,1 +34,0 @@\n-import jdk.incubator.code.analysis.SSA;\n@@ -42,1 +40,0 @@\n-import optkl.util.carriers.LookupCarrier;\n@@ -46,1 +43,0 @@\n-import java.lang.reflect.Field;\n@@ -52,1 +48,0 @@\n-import java.util.LinkedHashMap;\n@@ -60,266 +55,0 @@\n-public interface OpTkl{\n-   Predicate<JavaOp.FieldAccessOp> AnyFieldAccess = _->true;\n-   Predicate<JavaOp.InvokeOp> AnyInvoke = _->true;\n-static OpTkl impl(LookupCarrier lookupCarrier){\n-   record Impl(MethodHandles.Lookup lookup) implements LookupCarrier,OpTkl{}\n-   return new Impl(lookupCarrier.lookup());\n-}\n-\n-static <F extends Op, T extends Op> T copyLocation(F from, T to ){\n-   to.setLocation(from.location());\n-   return to;\n-}\n-\n-\n-static String fieldName(JavaOp.FieldAccessOp fieldAccessOp) {\n-   return fieldAccessOp.fieldDescriptor().name();\n-}\n-\n-static Object getStaticFinalPrimitiveValue(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-   if (fieldLoadOp.fieldDescriptor().refType() instanceof ClassType classType) {\n-      Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup, classType);\n-      try {\n-         Field field = clazz.getField(fieldName(fieldLoadOp));\n-         field.setAccessible(true);\n-         return field.get(null);\n-      } catch (NoSuchFieldException | IllegalAccessException e) {\n-         throw new RuntimeException(e);\n-      }\n-   }\n-   throw new RuntimeException(\"Could not find field value\" + fieldLoadOp);\n-}\n-\n-\n-static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n-   try {\n-      return classType.resolve(lookup);\n-   } catch (ReflectiveOperationException e) {\n-      throw new RuntimeException(e);\n-   }\n-}\n-\n-static boolean isAssignable(MethodHandles.Lookup lookup, TypeElement typeElement, Class<?>... classes) {\n-   if (typeElement instanceof ClassType classType) {\n-      Type type = classTypeToTypeOrThrow(lookup, classType);\n-      return Arrays.stream(classes).anyMatch(clazz -> clazz.isAssignableFrom((Class<?>) type));\n-   }\n-   return false;\n-\n-}\n-\n-static boolean isAssignableTo(MethodHandles.Lookup lookup, JavaType javaType, Class<?>... classes) {\n-   if (javaType instanceof ClassType classType) {\n-      Type type = classTypeToTypeOrThrow(lookup, classType);\n-      Class<?> evalKlass = (Class<?>) type;\n-      return Arrays.stream(classes).anyMatch(evalKlass::isAssignableFrom);\n-   }\n-   return false;\n-\n-}\n-\n-static JavaOp.InvokeOp getTargetInvokeOp(MethodHandles.Lookup lookup,JavaOp.LambdaOp lambdaOp, Class<?> ...classes) {\n-   return lambdaOp.body().entryBlock().ops().stream()\n-           .filter(op -> op instanceof JavaOp.InvokeOp)\n-           .map(op -> (JavaOp.InvokeOp) op)\n-           .filter(invokeOp -> invokeOp.invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC))\n-           .filter(invokeOp ->  OpTkl.isAssignable(lookup,invokeOp.operands().get(0).type(), classes))\n-           \/\/.filter(invokeOp -> invokeOp.operands().get(0).type() instanceof ClassType classType\n-             \/\/      && classType.toClassName() instanceof String name\n-               \/\/    && (name.equals(\"hat.ComputeContext\")||name.equals(\"hat.KernelContext\")))\n-           .findFirst()\n-           .orElseThrow();\n-}\n-\n-static Object[] getQuotedCapturedValues(JavaOp.LambdaOp lambdaOp, Quoted quoted, Method method) {\n-   var block = lambdaOp.body().entryBlock();\n-   var ops = block.ops();\n-   Object[] varLoadNames = ops.stream()\n-           .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n-           .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n-           .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n-           .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n-           .map(CoreOp.VarOp::varName).toArray();\n-   Map<String, Object> nameValueMap = new HashMap<>();\n-\n-   quoted.capturedValues().forEach((k, v) -> {\n-      if (k instanceof Op.Result result) {\n-         if (result.op() instanceof CoreOp.VarOp varOp) {\n-            nameValueMap.put(varOp.varName(), v);\n-         }\n-      }\n-   });\n-   Object[] args = new Object[method.getParameterCount()];\n-   if (args.length != varLoadNames.length) {\n-      throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n-   }\n-   for (int i = 1; i < args.length; i++) {\n-      args[i] = nameValueMap.get(varLoadNames[i].toString());\n-      if (args[i] instanceof CoreOp.Var varbox) {\n-         args[i] = varbox.value();\n-      }\n-   }\n-   return args;\n-}\n-\n-\n-static JavaType javaRefType(JavaOp.InvokeOp op) {\n-   return (JavaType) op.invokeDescriptor().refType();\n-}\n-\n-static JavaType javaReturnType(JavaOp.InvokeOp invokeOp) {\n-   return (JavaType) invokeOp.invokeDescriptor().type().returnType();\n-}\n-static boolean javaReturnTypeIsVoid(JavaOp.InvokeOp invokeOp) {\n-   return javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.isVoid();\n-}\n-\n-static Method methodOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n-   try {\n-      return op.invokeDescriptor().resolveToMethod(lookup);\n-   } catch (ReflectiveOperationException e) {\n-      throw new RuntimeException(e);\n-   }\n-}\n-   static boolean isMethod(JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n-      return namePredicate.test(invokeOp.invokeDescriptor().name());\n-   }\n-\n-\n-static Class<?> javaRefClassOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n-   if (javaRefType(op) instanceof ClassType classType) {\n-      return (Class<?>) classTypeToTypeOrThrow(lookup, classType);\n-   } else {\n-      throw new IllegalStateException(\" javaRef class is null\");\n-   }\n-}\n-\n-\n-static Op.Result lhsResult(JavaOp.BinaryOp binaryOp){\n-   return (Op.Result)binaryOp.operands().get(0);\n-}\n-\n-static Op.Result rhsResult(JavaOp.BinaryOp binaryOp){\n-   return (Op.Result)binaryOp.operands().get(1);\n-}\n-\n-static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx){\n-   return javaConditionalOp.bodies().get(idx).entryBlock().ops();\n-}\n-\n-static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n-   return ops(javaConditionalOp,0);\n-}\n-\n-static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n-   return ops(javaConditionalOp,1);\n-}\n-\n-static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx){\n-   return (Op.Result)binaryTestOp.operands().get(idx);\n-}\n-\n-static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp){\n-   return result(binaryTestOp,0);\n-}\n-\n-static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp){\n-   return result(binaryTestOp,1);\n-}\n-\n-static Op.Result result(JavaOp.ConvOp convOp){\n-   return (Op.Result)convOp.operands().getFirst();\n-}\n-\n-static Op.Result result(CoreOp.ReturnOp returnOp){\n-   return (Op.Result)returnOp.operands().getFirst();\n-}\n-\n-static Block block(JavaOp.ConditionalExpressionOp ternaryOp, int idx){\n-   return ternaryOp.bodies().get(idx).entryBlock();\n-}\n-\n-static Block condBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n-   return block(ternaryOp,0);\n-}\n-\n-static Block thenBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n-   return block(ternaryOp,1);\n-}\n-\n-static Block elseBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n-   return block(ternaryOp,2);\n-}\n-\n-static String funcName(JavaOp.InvokeOp invokeOp) {\n-   return invokeOp.invokeDescriptor().name();\n-}\n-\n-static Value operandOrNull(Op op, int idx) {\n-   return op.operands().size() > idx?op.operands().get(idx):null;\n-}\n-\n-static Op.Result resultOrNull(Op op, int idx) {\n-   return (operandOrNull(op,idx) instanceof Op.Result result)?result:null;\n-}\n-\n-static Block block(JavaOp.ForOp forOp, int idx){\n-   return forOp.bodies().get(idx).entryBlock();\n-}\n-\n-static Block mutateBlock(JavaOp.ForOp forOp){\n-   return block(forOp,2);\n-}\n-\n-static Block loopBlock(JavaOp.ForOp forOp){\n-   return block(forOp,3);\n-}\n-\n-static Block condBlock(JavaOp.ForOp forOp){\n-   return  forOp.cond().entryBlock();\n-}\n-\n-static Block initBlock(JavaOp.ForOp forOp){\n-   return  forOp.init().entryBlock();\n-}\n-\n-static Block block(JavaOp.WhileOp whileOp, int idx){\n-   return  whileOp.bodies().get(idx).entryBlock();\n-}\n-\n-static Block condBlock(JavaOp.WhileOp whileOp){\n-   return  block(whileOp,0);\n-}\n-\n-static Block loopBlock(JavaOp.WhileOp whileOp){\n-   return  block(whileOp,1);\n-}\n-\n-static Block blockOrNull(JavaOp.IfOp ifOp, int idx ){\n-   return ifOp.bodies().size() > idx?ifOp.bodies().get(idx).entryBlock():null;\n-}\n-\n-static JavaOp.FieldAccessOp fieldAccessOpNameMatches(jdk.incubator.code.CodeElement<?,?> codeElement, Predicate<String> namePredicate) {\n-   return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp\n-           && namePredicate.test(fieldName(fieldAccessOp))?fieldAccessOp:null;\n-}\n-\n-\n-static PrimitiveType asPrimitiveResultOrNull(Value v){\n-   if (v instanceof Op.Result r){\n-      if (r.op().resultType() instanceof PrimitiveType primitiveType){\n-         return primitiveType;\n-      }\n-   }\n-   return null;\n-}\n-static boolean isPrimitiveResult(Value v){\n-   return (asPrimitiveResultOrNull(v)!=null);\n-}\n-\n-static Op.Result asResultOrThrow(Value value) {\n-   if (value instanceof Op.Result r) {\n-      return r;\n-   }else{\n-      throw new RuntimeException(\"Value not a result\");\n-   }\n-}\n@@ -327,176 +56,302 @@\n-static Stream<Op.Result> operandsAsResults(jdk.incubator.code.CodeElement<?,?> codeElement) {\n-   return codeElement instanceof Op ?\n-           ((Op)codeElement).operands().stream().filter(o-> o instanceof Op.Result).map(o->(Op.Result)o)\n-           :Stream.of();\n-}\n-static Op.Result operandAsResult(jdk.incubator.code.CodeElement<?,?> codeElement, int n) {\n-   return codeElement instanceof Op op  && op.operands().size()>n && op.operands().get(n) instanceof Op.Result result?result:null;\n-}\n-static Op opFromOperandAsResult(jdk.incubator.code.CodeElement<?,?> codeElement, int n) {\n-   return operandAsResult(codeElement,n) instanceof Op.Result result?result.op():null;\n-}\n-\n-static Op.Result asResultOrNull(Value operand) {\n-   return operand instanceof Op.Result result?result:null;\n-}\n-   static Op asOpFromResultOrNull(Value operand) {\n-      return asResultOrNull(operand) instanceof Op.Result r && r.op() instanceof Op op?op:null;\n-   }\n-static boolean isResult(Value operand) {\n-   return Objects.nonNull(asResultOrNull(operand));\n-}\n-\n-static Op opOfResultOrNull(Op.Result result) {\n-   return result.op() instanceof Op op?op:null;\n-}\n-\n-static TypeElement resultTypeOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-   return varLoadOp.resultType() instanceof TypeElement typeElement?typeElement:null;\n-}\n-\n-static CoreOp.VarAccessOp.VarLoadOp asVarLoadOrNull(Op op) {\n-   return  op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp?varLoadOp:null;\n-}\n-\n-static boolean resultType(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp, Class<?>... classes) {\n-   return isAssignable(lookup, varLoadOp.resultType(), classes);\n-}\n-\n-   static Stream<Op> loopBodyStatements(Op.Loop op) {\n-       var list = new ArrayList<>(statements( op.loopBody().entryBlock()).toList());\n-       if (list.getLast() instanceof JavaOp.ContinueOp) {\n-           list.removeLast();\n-       }\n-       return list.stream();\n-   }\n-\n-   static  Op asStatementOpOrNull(CodeElement<?,?> ce){\n-       if (ce instanceof Op op){\n-              return (\n-                      (\n-                              (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n-                               || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n-                               || (op instanceof StatementLikeOp)\n-                      )\n-                      && !(op instanceof CoreOp.VarOp varOp && isParamVar(varOp))\/\/..ParamVar.of(varOp) != null)\n-                      && !(op instanceof CoreOp.YieldOp)\n-              )\n-                      ?op\n-                      :null;\n-       }else{\n-          return null;\n-       }\n-\n-   }\n-   static  boolean isStatementOp(CodeElement<?,?> ce){\n-       return Objects.nonNull(asStatementOpOrNull(ce));\n-   }\n-\n-   static Stream<Op> statements(Block block) {\n-       return block.ops().stream().filter(OpTkl::isStatementOp);\n-   }\n-\n-   static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-}\n-static Stream<jdk.incubator.code.CodeElement<?,?>> elements(CallSite callSite, CoreOp.FuncOp funcOp) {\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return funcOp.elements();\n-}\n-static <T extends Op> Stream<T> ops(CallSite callSite, CoreOp.FuncOp funcOp,\n-                                    Predicate<jdk.incubator.code.CodeElement<?,?>> predicate,\n-                                    Function<CodeElement<?,?>,T> mapper\n-) {\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return funcOp.elements().filter(predicate).map(mapper);\n-}\n-\n-\n-static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<Op> predicate, CodeTransformer CodeTransformer) {\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return funcOp.transform((blockBuilder, op) -> {\n-      if (predicate.test(op)){\n-         var builder = CodeTransformer.acceptOp(blockBuilder,op);\n-         if (builder != blockBuilder){\n-            throw new RuntimeException(\"Where does this builder come from \"+builder);\n-         }\n-      }else {\n-         blockBuilder.op(op);\n-      }\n-      return blockBuilder;\n-   });\n-}\n-\n-static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, CodeTransformer CodeTransformer) {\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return funcOp.transform(CodeTransformer);\n-}\n-\n-\n-\n-\/\/ IMPORTANT:\n-\/\/ When we have patterns like:\n-\/\/\n-\/\/ myiFaceArray.array().value(storeAValue);\n-\/\/\n-\/\/ We need to generate extra parenthesis to make the struct pointer accessor \"->\" correct.\n-\/\/ This is a common pattern when we have a IFace type that contains a subtype based on\n-\/\/ struct or union.\n-\/\/\n-\/\/ An example of this is for the type F16Array.\n-static boolean needExtraParenthesis(JavaOp.InvokeOp invokeOp) {\n-\n-   \/\/ The following expression checks that the current invokeOp has at least 2 operands:\n-   \/\/ Why 2?\n-   \/\/ - The first one is another invokeOp to load the inner struct from an IFace data structure.\n-   \/\/   The first operand is also assignable.\n-   \/\/ - The second one is the store value, but this depends on the semantics and definition\n-   \/\/   of the user code.\n-   return invokeOp.operands().size() >= 2 && invokeOp.operands().get(0) instanceof Op.Result r1\n-           && r1.op() instanceof JavaOp.InvokeOp invokeOp2\n-           && javaReturnType(invokeOp2) instanceof ClassType;\n-}\n-\n-\n-\n-static  Class<?> typeElementToClass(MethodHandles.Lookup lookup,TypeElement type) {\n-   class PrimitiveHolder {\n-      static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n-              JavaType.BYTE, byte.class,\n-              JavaType.SHORT, short.class,\n-              JavaType.INT, int.class,\n-              JavaType.LONG, long.class,\n-              JavaType.FLOAT, float.class,\n-              JavaType.DOUBLE, double.class,\n-              JavaType.CHAR, char.class,\n-              JavaType.BOOLEAN, boolean.class\n-      );\n-   }\n-   try {\n-      if (type instanceof PrimitiveType primitiveType) {\n-         return PrimitiveHolder.primitiveToClass.get(primitiveType);\n-      } else if (type instanceof ClassType classType) {\n-         return ((Class<?>) classType.resolve(lookup));\n-      } else {\n-         throw new IllegalArgumentException(\"given type cannot be converted to class\");\n-      }\n-   } catch (ReflectiveOperationException e) {\n-      throw new RuntimeException(\"given type cannot be converted to class\");\n-   }\n-}\n-   static boolean isParamVar(CoreOp.VarOp varOp) {\n-      return !varOp.isUninitialized()\n-              && varOp.operands().getFirst() instanceof Block.Parameter parameter\n-              && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp;\n-   }\n+public interface OpTkl {\n+\n+    static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n+        try {\n+            return classType.resolve(lookup);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static boolean isAssignable(MethodHandles.Lookup lookup, TypeElement typeElement, Class<?>... classes) {\n+        if (typeElement instanceof ClassType classType) {\n+            Type type = classTypeToTypeOrThrow(lookup, classType);\n+            return Arrays.stream(classes).anyMatch(clazz -> clazz.isAssignableFrom((Class<?>) type));\n+        }\n+        return false;\n+\n+    }\n+\n+\n+\n+    static Object[] getQuotedCapturedValues(JavaOp.LambdaOp lambdaOp, Quoted quoted, Method method) {\n+        var block = lambdaOp.body().entryBlock();\n+        var ops = block.ops();\n+        Object[] varLoadNames = ops.stream()\n+                .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n+                .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n+                .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n+                .map(CoreOp.VarOp::varName).toArray();\n+        Map<String, Object> nameValueMap = new HashMap<>();\n+\n+        quoted.capturedValues().forEach((k, v) -> {\n+            if (k instanceof Op.Result result) {\n+                if (result.op() instanceof CoreOp.VarOp varOp) {\n+                    nameValueMap.put(varOp.varName(), v);\n+                }\n+            }\n+        });\n+        Object[] args = new Object[method.getParameterCount()];\n+        if (args.length != varLoadNames.length) {\n+            throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n+        }\n+        for (int i = 1; i < args.length; i++) {\n+            args[i] = nameValueMap.get(varLoadNames[i].toString());\n+            if (args[i] instanceof CoreOp.Var varbox) {\n+                args[i] = varbox.value();\n+            }\n+        }\n+        return args;\n+    }\n+\n+\n+\n+    static Op.Result lhsResult(JavaOp.BinaryOp binaryOp) {\n+        return (Op.Result) binaryOp.operands().get(0);\n+    }\n+\n+    static Op.Result rhsResult(JavaOp.BinaryOp binaryOp) {\n+        return (Op.Result) binaryOp.operands().get(1);\n+    }\n+\n+    static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx) {\n+        return javaConditionalOp.bodies().get(idx).entryBlock().ops();\n+    }\n+\n+    static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n+        return ops(javaConditionalOp, 0);\n+    }\n+\n+    static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n+        return ops(javaConditionalOp, 1);\n+    }\n+\n+    static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx) {\n+        return (Op.Result) binaryTestOp.operands().get(idx);\n+    }\n+\n+    static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n+        return result(binaryTestOp, 0);\n+    }\n+\n+    static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n+        return result(binaryTestOp, 1);\n+    }\n+\n+    static Op.Result result(JavaOp.ConvOp convOp) {\n+        return (Op.Result) convOp.operands().getFirst();\n+    }\n+\n+    static Op.Result result(CoreOp.ReturnOp returnOp) {\n+        return (Op.Result) returnOp.operands().getFirst();\n+    }\n+\n+    static Block block(JavaOp.ConditionalExpressionOp ternaryOp, int idx) {\n+        return ternaryOp.bodies().get(idx).entryBlock();\n+    }\n+\n+    static Block condBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n+        return block(ternaryOp, 0);\n+    }\n+\n+    static Block thenBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n+        return block(ternaryOp, 1);\n+    }\n+\n+    static Block elseBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n+        return block(ternaryOp, 2);\n+    }\n+\n+\n+    static Value operandOrNull(Op op, int idx) {\n+        return op.operands().size() > idx ? op.operands().get(idx) : null;\n+    }\n+\n+    static Block block(JavaOp.ForOp forOp, int idx) {\n+        return forOp.bodies().get(idx).entryBlock();\n+    }\n+\n+    static Block mutateBlock(JavaOp.ForOp forOp) {\n+        return block(forOp, 2);\n+    }\n+\n+    static Block condBlock(JavaOp.ForOp forOp) {\n+        return forOp.cond().entryBlock();\n+    }\n+\n+    static Block initBlock(JavaOp.ForOp forOp) {\n+        return forOp.init().entryBlock();\n+    }\n+\n+    static Block block(JavaOp.WhileOp whileOp, int idx) {\n+        return whileOp.bodies().get(idx).entryBlock();\n+    }\n+\n+    static Block condBlock(JavaOp.WhileOp whileOp) {\n+        return block(whileOp, 0);\n+    }\n+\n+\n+    static PrimitiveType asPrimitiveResultOrNull(Value v) {\n+        return (v instanceof Op.Result r && r.op().resultType() instanceof PrimitiveType primitiveType)?primitiveType:null;\n+    }\n+\n+    static boolean isPrimitiveResult(Value v) {\n+        return (asPrimitiveResultOrNull(v) != null);\n+    }\n+\n+    static Op.Result asResultOrThrow(Value value) {\n+        if (value instanceof Op.Result r) {\n+            return r;\n+        } else {\n+            throw new RuntimeException(\"Value not a result\");\n+        }\n+    }\n+\n+    static Stream<Op.Result> operandsAsResults(jdk.incubator.code.CodeElement<?, ?> codeElement) {\n+        return codeElement instanceof Op ?\n+                ((Op) codeElement).operands().stream().filter(o -> o instanceof Op.Result).map(o -> (Op.Result) o)\n+                : Stream.of();\n+    }\n+\n+    static Op.Result operandAsResult(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n+        return codeElement instanceof Op op && op.operands().size() > n && op.operands().get(n) instanceof Op.Result result ? result : null;\n+    }\n+\n+    static Op.Result asResultOrNull(Value operand) {\n+        return operand instanceof Op.Result result ? result : null;\n+    }\n+\n+    static Op asOpFromResultOrNull(Value operand) {\n+        return asResultOrNull(operand) instanceof Op.Result r && r.op() instanceof Op op ? op : null;\n+    }\n+\n+    static Op opOfResultOrNull(Op.Result result) {\n+        return result.op() instanceof Op op ? op : null;\n+    }\n+\n+    static CoreOp.VarAccessOp.VarLoadOp asVarLoadOrNull(Op op) {\n+        return op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp ? varLoadOp : null;\n+    }\n+\n+    static boolean resultType(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp, Class<?>... classes) {\n+        return isAssignable(lookup, varLoadOp.resultType(), classes);\n+    }\n+\n+    static Stream<Op> loopBodyStatements(Op.Loop op) {\n+        var list = new ArrayList<>(statements(op.loopBody().entryBlock()).toList());\n+        if (list.getLast() instanceof JavaOp.ContinueOp) {\n+            list.removeLast();\n+        }\n+        return list.stream();\n+    }\n+\n+    static Op asStatementOpOrNull(CodeElement<?, ?> ce) {\n+        if (ce instanceof Op op) {\n+            return (\n+                    (\n+                            (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n+                                    || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n+                                    || (op instanceof StatementLikeOp)\n+                    )\n+                            && !(op instanceof CoreOp.VarOp varOp && isParamVar(varOp))\/\/..ParamVar.of(varOp) != null)\n+                            && !(op instanceof CoreOp.YieldOp)\n+            )\n+                    ? op\n+                    : null;\n+        } else {\n+            return null;\n+        }\n+\n+    }\n+\n+    static boolean isStatementOp(CodeElement<?, ?> ce) {\n+        return Objects.nonNull(asStatementOpOrNull(ce));\n+    }\n+\n+    static Stream<Op> statements(Block block) {\n+        return block.ops().stream().filter(OpTkl::isStatementOp);\n+    }\n+\n+    static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n+        if (callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        return funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER);\n+    }\n+\n+    static Stream<jdk.incubator.code.CodeElement<?, ?>> elements(CallSite callSite, CoreOp.FuncOp funcOp) {\n+        if (callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        return funcOp.elements();\n+    }\n+\n+    static <T extends Op> Stream<T> ops(CallSite callSite, CoreOp.FuncOp funcOp,\n+                                        Predicate<jdk.incubator.code.CodeElement<?, ?>> predicate,\n+                                        Function<CodeElement<?, ?>, T> mapper\n+    ) {\n+        if (callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        return funcOp.elements().filter(predicate).map(mapper);\n+    }\n+\n+\n+    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<Op> predicate, CodeTransformer CodeTransformer) {\n+        if (callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        return funcOp.transform((blockBuilder, op) -> {\n+            if (predicate.test(op)) {\n+                var builder = CodeTransformer.acceptOp(blockBuilder, op);\n+                if (builder != blockBuilder) {\n+                    throw new RuntimeException(\"Where does this builder come from \" + builder);\n+                }\n+            } else {\n+                blockBuilder.op(op);\n+            }\n+            return blockBuilder;\n+        });\n+    }\n+\n+    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, CodeTransformer CodeTransformer) {\n+        if (callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        return funcOp.transform(CodeTransformer);\n+    }\n+\n+\n+    static Class<?> typeElementToClass(MethodHandles.Lookup lookup, TypeElement type) {\n+        class PrimitiveHolder {\n+            static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n+                    JavaType.BYTE, byte.class,\n+                    JavaType.SHORT, short.class,\n+                    JavaType.INT, int.class,\n+                    JavaType.LONG, long.class,\n+                    JavaType.FLOAT, float.class,\n+                    JavaType.DOUBLE, double.class,\n+                    JavaType.CHAR, char.class,\n+                    JavaType.BOOLEAN, boolean.class\n+            );\n+        }\n+        try {\n+            if (type instanceof PrimitiveType primitiveType) {\n+                return PrimitiveHolder.primitiveToClass.get(primitiveType);\n+            } else if (type instanceof ClassType classType) {\n+                return ((Class<?>) classType.resolve(lookup));\n+            } else {\n+                throw new IllegalArgumentException(\"given type cannot be converted to class\");\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"given type cannot be converted to class\");\n+        }\n+    }\n+\n+    static boolean isParamVar(CoreOp.VarOp varOp) {\n+        return !varOp.isUninitialized()\n+                && varOp.operands().getFirst() instanceof Block.Parameter parameter\n+                && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp;\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":302,"deletions":447,"binary":false,"changes":749,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.HashMap;\n@@ -40,1 +39,0 @@\n-import java.util.Map;\n@@ -45,0 +43,1 @@\n+import java.util.stream.Collectors;\n@@ -46,1 +45,0 @@\n-import static optkl.OpTkl.copyLocation;\n@@ -56,0 +54,15 @@\n+    public static <F extends Op, T extends Op> T copyLocation(F from, T to) {\n+        to.setLocation(from.location());\n+        return to;\n+    }\n+\n+    public Trxfmr remove(Predicate<CodeElement<?,?>> codeElementPredicate) {\n+        return transform(codeElementPredicate, c-> c.remove());\n+    }\n+\n+    public Trxfmr remap(Set<CodeElement<?,?>> set) {\n+        var newSet =  set.stream().map(biMap::getTo).collect(Collectors.toSet());\n+        set.clear();\n+        set.addAll(newSet);\n+        return this;\n+    }\n@@ -64,1 +77,1 @@\n-    public interface  Walker extends TransformerCarrier {\n+  \/*  public interface  Walker extends TransformerCarrier {\n@@ -101,4 +114,4 @@\n-        static Walker of(Trxfmr trxfmr, CoreOp.FuncOp funcOp){\n-            return new Impl(trxfmr,funcOp);\n-        }\n-    }\n+      \/\/  static Walker of(Trxfmr trxfmr, CoreOp.FuncOp funcOp){\n+        \/\/    return new Impl(trxfmr,funcOp);\n+       \/\/ }\n+    } *\/\n@@ -106,1 +119,1 @@\n-    public interface  Cursor extends TransformerCarrier, Walker {\n+    public interface  Cursor extends TransformerCarrier {\n@@ -108,0 +121,4 @@\n+        void op(Op op);\n+        Op op();\n+       void funcOp(CoreOp.FuncOp funcOp);\n+        CoreOp.FuncOp funcOp();\n@@ -112,0 +129,3 @@\n+\n+        void trxfmr(Trxfmr trxfmr);\n+\n@@ -133,2 +153,7 @@\n-            class Impl extends Walker.Impl implements Cursor {\n-                private Action action;\n+\n+            \/\/ This could be a record if we did ot have to mutate action and handled. Maybe a Set?\n+            class Impl  implements Cursor {\n+                private CoreOp.FuncOp funcOp;\n+                private Op op;\n+                private Trxfmr trxfmr;\n+                private Action action=Action.NONE;\n@@ -137,0 +162,20 @@\n+                @Override public Op op(){\n+                    return op;\n+                }\n+                @Override public void op(Op op){\n+                    this.op = op;\n+                }\n+                @Override public void funcOp(CoreOp.FuncOp funcOp){\n+                    this.funcOp = funcOp;\n+                }\n+                @Override public CoreOp.FuncOp funcOp(){\n+                    return funcOp;\n+                }\n+             @Override\n+                public Trxfmr trxfmr() {\n+                    return trxfmr;\n+                }\n+                @Override\n+                public void trxfmr(Trxfmr trxfmr) {\n+                    this.trxfmr=trxfmr;\n+                }\n@@ -192,2 +237,3 @@\n-                Impl(Trxfmr hatTransformer, CoreOp.FuncOp funcOp, Block.Builder builder, Op op) {\n-                    super(hatTransformer,funcOp);\n+                Impl(Trxfmr trxfmr, CoreOp.FuncOp funcOp, Block.Builder builder, Op op) {\n+                    trxfmr(trxfmr);\n+                    funcOp(funcOp);\n@@ -253,1 +299,0 @@\n-   \/\/ public final Map<Op, Op> opmap = new HashMap<>();\n@@ -256,1 +301,1 @@\n-    public BiMap<Op,Op> biMap = new BiMap<>();\n+    public final BiMap<CodeElement<?,?>,CodeElement<?,?>> biMap = new BiMap<>();\n@@ -294,6 +339,0 @@\n-\n-\n-    \/\/private Op opToOp(Op from, Op to){\n-\n-      \/\/  return to;\n-    \/\/}\n@@ -302,1 +341,0 @@\n-        \/\/opToOp(from, result.op());\n@@ -306,0 +344,8 @@\n+    private boolean shouldTransform(Predicate<CodeElement<?,?>> predicate, Op op){\n+        boolean isEmpty = selected.isEmpty();\n+        boolean isInSelected = selected.contains(op);\n+        boolean isSelected = isEmpty|isInSelected;\n+        boolean passesPredicate = predicate.test(op);\n+        return isSelected && passesPredicate;\n+    }\n+\n@@ -311,10 +357,2 @@\n-            Cursor cursor = Cursor.of(this, funcOp, blockBuilder,op);\n-            cursor.builder(blockBuilder);\n-            cursor.op(op);\n-            cursor.handled(false);\n-            cursor.action(Cursor.Action.NONE);\n-            boolean isEmpty = selected.isEmpty();\n-            boolean isInSelected = selected.contains(op);\n-            boolean isSelected = isEmpty|isInSelected;\n-            boolean passesPredicate = predicate.test(op);\n-            if (isSelected && passesPredicate) {\n+            if (shouldTransform(predicate,op)){\n+                Cursor cursor = Cursor.of(this, funcOp, blockBuilder,op);\n@@ -323,2 +361,1 @@\n-                    biMap.add(op,cursor.builder().op(op).op());\n-                   \/\/ opToOp(op,cursor.builder().op(op).op());\n+                    biMap.add(op,blockBuilder.op(op).op());\n@@ -327,1 +364,1 @@\n-                biMap.add(op,cursor.builder().op(op).op());\n+                biMap.add(op,blockBuilder.op(op).op());\n@@ -333,1 +370,0 @@\n-       \/\/ opToOp(funcOp,newFuncOp);\n@@ -340,1 +376,1 @@\n-    public Trxfmr transform(Predicate<Op> predicate, CodeTransformer codeTransformer) {\n+    public Trxfmr transform(Predicate<CodeElement<?,?>> predicate, CodeTransformer codeTransformer) {\n@@ -344,5 +380,3 @@\n-        var currentFuncOp = funcOp();\n-        var newFuncOp = currentFuncOp.transform((blockBuilder, op) -> {\n-            Cursor cursor = Cursor.of(this,funcOp,blockBuilder,op);\n-            if ((selected.isEmpty() || selected.contains(op)) &&  predicate.test(op)) {\n-                codeTransformer.acceptOp(cursor.builder(),op);\n+        var newFuncOp = funcOp().transform((blockBuilder, op) -> {\n+            if (shouldTransform(predicate,op)){\n+                codeTransformer.acceptOp(blockBuilder,op);\n@@ -350,1 +384,1 @@\n-                biMap.add(op,cursor.builder().op(op).op());\n+                biMap.add(op,blockBuilder.op(op).op());\n@@ -352,1 +386,1 @@\n-            return cursor.builder();\n+            return blockBuilder;\n@@ -354,3 +388,1 @@\n-    \/\/    opmap.put(currentFuncOp, newFuncOp);\n-        funcOp(newFuncOp);\n-      \/\/  opmap.forEach((from, to) -> { selected.remove(from);selected.add(to);});\n+        funcOp(newFuncOp); \/\/swap the funcop for the next transform,\n@@ -369,36 +401,0 @@\n-    public interface Edge<F extends CodeElement<?,?>, T extends CodeElement<?,?>> {\n-        F f();\n-        T t();\n-        Set<Op> ops();\n-         class Selector<F extends CodeElement<?,?>, T extends CodeElement<?,?>> {\n-            Map<F, Edge<F, T>> fromMap = new HashMap<>();\n-            Map<T, Edge<F, T>> toMap = new HashMap<>();\n-\n-            public Selector<F, T> add(Edge<F, T> edge) {\n-                fromMap.put(edge.f(), edge);\n-                toMap.put(edge.t(), edge);\n-                return this;\n-            }\n-\n-            Edge<F, T> from(F f) {\n-                return fromMap.get(f);\n-            }\n-\n-            Edge<F, T> to(T t) {\n-                return toMap.get(t);\n-            }\n-\n-            Predicate<CodeElement<?,?>> predicate =ce->fromMap.containsKey((F) ce) || toMap.containsKey((T) ce);\n-\n-            public boolean contains(Op op) {\n-                return predicate.test(op);\n-            }\n-\n-             public CoreOp.FuncOp transform(CoreOp.FuncOp funcOp, Consumer<Cursor> c) {\n-                 return new Trxfmr(CallSite.of(this.getClass()), funcOp)\n-                         .transform(this.predicate,c).done().funcOp();\n-             }\n-         }\n-    }\n-\n-\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":79,"deletions":83,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+\n+import static optkl.OpTkl.classTypeToTypeOrThrow;\n+\n+public interface VarAccess extends OpHelper<CoreOp.VarAccessOp>{\n+\n+    @Override\n+    default  String name(){\n+        return op().varOp().varName();\n+    }\n+\n+    default boolean isPrimitive(){\n+        return op().result().type() instanceof PrimitiveType;\n+    }\n+\n+\n+    default  <T>boolean of(Class<T> clazz){\n+        return isAssignable((JavaType) op().resultType(),clazz);\n+    }\n+\n+    static VarAccess varAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+        record Impl(MethodHandles.Lookup lookup, CoreOp.VarAccessOp op) implements VarAccess {}\n+        return codeElement instanceof CoreOp.VarAccessOp varAccessOp? new Impl(lookup,varAccessOp): null;\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/VarAccess.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.ifacemapper;\n+\n+import java.lang.annotation.Annotation;\n+\n+public enum AccessType {\n+    NOT_BUFFER((byte) 0),\n+    NA((byte) 1),\n+    RO((byte) 2),\n+    WO((byte) 4),\n+    RW((byte) 6);\n+\n+    public final byte value;\n+\n+    AccessType(byte i) {\n+        value = i;\n+    }\n+\n+    public static AccessType of(byte i) {\n+        return switch (i) {\n+            case (byte)0 -> NOT_BUFFER;\n+            case (byte)1 -> NA;\n+            case (byte)2 -> RO;\n+            case (byte)4 -> WO;\n+            case (byte)6 -> RO;\n+            default -> throw new IllegalStateException(\"No access type for \" + i);\n+        };\n+    }\n+\n+    public static AccessType of(Annotation annotation) {\n+        return switch (annotation) {\n+            case MappableIface.RO ro -> RO;\n+            case MappableIface.RW rw -> RW;\n+            case MappableIface.WO wo -> WO;\n+            default -> NA;\n+        };\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/ifacemapper\/AccessType.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -140,1 +140,1 @@\n-    public static void testTransitiveMethoFromKernelWithoutReflectAnnotation() {\n+    public static void testTransitiveMethodFromKernelWithoutReflectAnnotation() {\n@@ -152,1 +152,1 @@\n-            HATAsserts.assertTrue(e.getMessage().contains(\"OpenCL program failed to compile\"));\n+            HATAsserts.assertTrue(e.getMessage().contains(\"Failed to inline squareitWithoutReflectAnnotation. Did you miss @Reflect annotation?\"));\n@@ -155,1 +155,1 @@\n-        throw new HATExpectedFailureException(\"OpenCL program failed to compile\");\n+        throw new HATExpectedFailureException(\"Failed to inline squareitWithoutReflectAnnotation. Did you miss @Reflect annotation?\");\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMissingReflectAnnotation.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+ * @run main Unreflect TestArrayCreation\n+ * @run junit TestArrayCreation\n@@ -85,0 +87,14 @@\n+    @Reflect\n+    public static String[][] f4() {\n+        return new String[][]{{\"one\", \"two\"}, {\"three\"}};\n+    }\n+\n+    @Test\n+    public void testf4() {\n+        CoreOp.FuncOp f = getFuncOp(\"f4\");\n+\n+        System.out.println(f.toText());\n+\n+        Assertions.assertArrayEquals(f4(), (Object[]) Interpreter.invoke(MethodHandles.lookup(), f));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayCreation.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestArrayTypes\n+ * @run junit TestArrayTypes\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayTypes.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestBinops\n+ * @run junit TestBinops\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBinops.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestBlockOp\n+ * @run junit TestBlockOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestBreakContinue\n+ * @run junit TestBreakContinue\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBreakContinue.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+ * @run main Unreflect TestConcat\n+ * @run junit TestConcat\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConcat.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestConditionalExpression\n+ * @run junit TestConditionalExpression\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalExpression.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+ * @run main Unreflect TestConditionalOp\n+ * @run junit TestConditionalOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestConstants\n+ * @run junit TestConstants\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConstants.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+ * @run main Unreflect TestEnhancedForOp\n+ * @run junit TestEnhancedForOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestEnhancedForOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestForOp\n+ * @run junit TestForOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestForOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestIfOp\n+ * @run junit TestIfOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestIfOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestInvokeSuper\n+ * @run junit TestInvokeSuper\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInvokeSuper.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestLambdaOps\n+ * @run junit TestLambdaOps\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+ * @run main Unreflect TestLocalTransformationsAdaption\n+ * @run junit TestLocalTransformationsAdaption\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLocalTransformationsAdaption.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestOverloads\n+ * @run junit TestOverloads\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOverloads.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestPatterns\n+ * @run junit TestPatterns\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,0 +18,2 @@\n+ * @run main Unreflect TestPatterns2\n+ * @run junit TestPatterns2\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns2.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestPrimitiveCast\n+ * @run junit TestPrimitiveCast\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveCast.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+ * @run main Unreflect TestSSA\n+ * @run junit TestSSA\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSSA.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestTry\n+ * @run junit TestTry\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTry.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestTryFinally\n+ * @run junit TestTryFinally\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryFinally.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestTryNested\n+ * @run junit TestTryNested\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryNested.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestVarArgsInvoke\n+ * @run junit TestVarArgsInvoke\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarArgsInvoke.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestWhileOp\n+ * @run junit TestWhileOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestWhileOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.instruction.InvokeDynamicInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.lang.invoke.LambdaConversionException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.runtime.ReflectableLambdaMetafactory;\n+\n+public final class Unreflect {\n+\n+    static final ClassDesc CD_Reflect = Reflect.class.describeConstable().get();\n+    static final ClassDesc CD_Unreflect = Unreflect.class.describeConstable().get();\n+    static final ClassDesc CD_ReflectableLambdaMetafactory = ReflectableLambdaMetafactory.class.describeConstable().get();\n+\n+    static boolean isReflective(MethodModel mm) {\n+        return mm.findAttribute(Attributes.runtimeVisibleAnnotations())\n+                 .map(aa -> aa.annotations().stream().anyMatch(a -> a.classSymbol().equals(CD_Reflect)))\n+                 .orElse(false);\n+    }\n+\n+    static byte[] transform(ClassModel clm) {\n+        return ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(clm, (clb, cle) -> {\n+            if (cle instanceof MethodModel mm) {\n+                if (isReflective(mm)) {\n+                    clb.transformMethod(mm, MethodTransform.dropping(me -> me instanceof CodeModel)\n+                            .andThen(MethodTransform.endHandler(mb -> mb.withCode(cob -> {\n+                                MethodTypeDesc mts = mm.methodTypeSymbol();\n+                                boolean hasReceiver = !mm.flags().has(AccessFlag.STATIC);\n+                                if (hasReceiver) {\n+                                    cob.aload(cob.receiverSlot());\n+                                }\n+                                for (int i = 0; i < mts.parameterCount(); i++) {\n+                                    cob.loadLocal(TypeKind.from(mts.parameterType(i)), cob.parameterSlot(i));\n+                                }\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        ConstantDescs.ofCallsiteBootstrap(CD_Unreflect, \"unreflect\", ConstantDescs.CD_CallSite),\n+                                        mm.methodName().stringValue(),\n+                                        hasReceiver ? mts.insertParameterTypes(0, clm.thisClass().asSymbol()) : mts));\n+                                cob.return_(TypeKind.from(mts.returnType()));\n+                            }))));\n+                } else {\n+                    clb.transformMethod(mm, MethodTransform.transformingCode((cob, coe) -> {\n+                        DirectMethodHandleDesc bsm;\n+                        if (coe instanceof InvokeDynamicInstruction i\n+                                && (bsm = i.bootstrapMethod()).owner().equals(CD_ReflectableLambdaMetafactory)) {\n+                            \/\/ redirect metafactory and altMetafactory\n+                            cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                    MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                              CD_Unreflect,\n+                                                              bsm.methodName(),\n+                                                              bsm.invocationType()),\n+                                    i.name().stringValue(),\n+                                    MethodTypeDesc.ofDescriptor(i.type().stringValue()),\n+                                    i.bootstrapArgs().toArray(ConstantDesc[]::new)));\n+                        } else {\n+                            cob.with(coe);\n+                        }\n+                    }));\n+                }\n+            } else {\n+                clb.with(cle);\n+            }\n+        });\n+    }\n+\n+    public static CallSite unreflect(MethodHandles.Lookup caller,\n+                                     String methodName,\n+                                     MethodType methodType) throws NoSuchMethodException {\n+        for (Method m : caller.lookupClass().getDeclaredMethods()) {\n+            int firstParam = (m.getModifiers() & Modifier.STATIC) == 0 ? 1 : 0;\n+            if (m.getName().equals(methodName)\n+                    && m.getReturnType() == methodType.returnType()\n+                    && m.getParameterCount() == methodType.parameterCount() - firstParam\n+                    && Arrays.equals(m.getParameterTypes(), 0, m.getParameterCount(),\n+                                     methodType.parameterArray(), firstParam, methodType.parameterCount())) {\n+                return new ConstantCallSite(BytecodeGenerator.generate(caller, Op.ofMethod(m).orElseThrow()));\n+            }\n+        }\n+        throw new NoSuchMethodException(caller.lookupClass().getName() + \".\" + methodName + methodType);\n+    }\n+\n+    public static CallSite metafactory(MethodHandles.Lookup caller,\n+                                       String interfaceMethodName,\n+                                       MethodType factoryType,\n+                                       MethodType interfaceMethodType,\n+                                       MethodHandle implementation,\n+                                       MethodType dynamicMethodType) throws LambdaConversionException {\n+        return ReflectableLambdaMetafactory.metafactory(caller,\n+                                                        interfaceMethodName,\n+                                                        factoryType,\n+                                                        interfaceMethodType,\n+                                                        unreflectLambdaImplementation(caller, interfaceMethodName),\n+                                                        dynamicMethodType);\n+    }\n+\n+    public static CallSite altMetafactory(MethodHandles.Lookup caller,\n+                                          String interfaceMethodName,\n+                                          MethodType factoryType,\n+                                          Object... args) throws LambdaConversionException {\n+        args[1] = unreflectLambdaImplementation(caller, interfaceMethodName);\n+        return ReflectableLambdaMetafactory.altMetafactory(caller,\n+                                                           interfaceMethodName,\n+                                                           factoryType,\n+                                                           args);\n+    }\n+\n+    static MethodHandle unreflectLambdaImplementation(MethodHandles.Lookup caller, String interfaceMethodName)\n+            throws LambdaConversionException {\n+        try {\n+            MethodHandle opHandle = caller.findStatic(caller.lookupClass(),\n+                                                      interfaceMethodName.split(\"=\")[1],\n+                                                      MethodType.methodType(Op.class));\n+            return BytecodeGenerator.generate(caller, unquoteLambda((CoreOp.FuncOp)opHandle.invoke()));\n+        } catch (Throwable t) {\n+            throw new LambdaConversionException(t);\n+        }\n+    }\n+\n+    \/\/ flat QuotedOp and LambdaOp\n+    static CoreOp.FuncOp unquoteLambda(CoreOp.FuncOp funcOp) {\n+        int capturedValues = funcOp.parameters().size();\n+        List<Op> ops = funcOp.body().entryBlock().ops();\n+        JavaOp.LambdaOp lambda = (JavaOp.LambdaOp)((CoreOp.QuotedOp)ops.get(ops.size() - 2)).quotedOp();\n+        return CoreOp.func(funcOp.funcName(), CoreType.functionType(\n+                lambda.body().yieldType(),\n+                Stream.of(funcOp.invokableType().parameterTypes(),\n+                          lambda.invokableType().parameterTypes()).flatMap(List::stream).toList())).body(bb -> {\n+            bb.context().mapBlock(funcOp.body().entryBlock(), bb.entryBlock());\n+            bb.context().mapValues(funcOp.parameters(), bb.parameters().subList(0, capturedValues));\n+            for (int i = 0; i < ops.size() - 2; i++) {\n+                Op o = ops.get(i);\n+                bb.context().mapValue(o.result(), bb.op(o));\n+            }\n+            bb.body(lambda.body(),\n+                    bb.parameters().subList(capturedValues, bb.parameters().size()),\n+                    bb.context(),\n+                    CodeTransformer.COPYING_TRANSFORMER);\n+        });\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ process class files from arguments\n+        var toUnreflect = new ArrayDeque<>(List.of(args));\n+        var done = new HashSet<String>();\n+        while (!toUnreflect.isEmpty()) {\n+            String arg = toUnreflect.pop();\n+            if (!arg.endsWith(\".class\")) arg += \".class\";\n+            if (done.add(arg)) {\n+                System.out.println(\"unreflecting \" + arg);\n+                Path clsFile = Path.of(Unreflect.class.getResource(arg).toURI());\n+                ClassModel clm = ClassFile.of().parse(Files.readAllBytes(clsFile));\n+                \/\/ unreflect all nest members\n+                clm.findAttribute(Attributes.nestMembers())\n+                        .ifPresent(nma -> toUnreflect.addAll(\n+                                nma.nestMembers().stream().map(ClassEntry::asInternalName).toList()));\n+                Files.write(clsFile, transform(clm));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/Unreflect.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestArrayCreation\n- *\/\n-\n-public class TestArrayCreation {\n-    @Reflect\n-    public static String[] f() {\n-        return new String[10];\n-    }\n-\n-    @Test\n-    public void testf() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f(), (String[]) mh.invoke());\n-    }\n-\n-    @Reflect\n-    public static String[][] f2() {\n-        return new String[10][];\n-    }\n-\n-    @Test\n-    public void testf2() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f2\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f2(), (String[][]) mh.invoke());\n-    }\n-\n-    @Reflect\n-    public static String[][] f3() {\n-        return new String[10][10];\n-    }\n-\n-    @Test\n-    public void testf3() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f3\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f3(), (String[][]) mh.invoke());\n-    }\n-\n-    @Reflect\n-    public static String[][] f4() {\n-        return new String[][]{{\"one\", \"two\"}, {\"three\"}};\n-    }\n-\n-    @Test\n-    public void testf4() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f4\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f4(), (String[][]) mh.invoke());\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestArrayCreation.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -34,1 +34,0 @@\n-import org.opentest4j.TestSkippedException;\n@@ -58,0 +57,3 @@\n+ * @library ..\/\n+ * @run junit\/othervm -Djdk.invoke.MethodHandle.dumpClassFiles=true TestBytecode\n+ * @run main Unreflect TestBytecode\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestInvokeSuper\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-public class TestInvokeSuper {\n-\n-    interface I {\n-        default String f() { return \"I\"; }\n-    }\n-    static class A {\n-        String f() { return \"A\"; }\n-    }\n-\n-    static class B extends A implements I {\n-        final boolean invokeClass;\n-\n-        public B(boolean invokeClass) {\n-            this.invokeClass = invokeClass;\n-        }\n-\n-        @Reflect\n-        public String f() {\n-            return invokeClass ? super.f() : I.super.f();\n-        }\n-    }\n-\n-    @Test\n-    public void testInvokeSuper() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(B.class, \"f\");\n-        MethodHandle mh = generate(f);\n-\n-        for (boolean invokeClass : new boolean[] {true, false}) {\n-            B b = new B(invokeClass);\n-            Assertions.assertEquals(b.f(), mh.invoke(b));\n-        }\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup().in(B.class), f);\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(Class<?> c, String name) {\n-        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestInvokeSuper.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -27,0 +27,3 @@\n+ * @library ..\/\n+ * @run junit TestNestedCapturingLambda\n+ * @run main Unreflect TestNestedCapturingLambda\n@@ -31,1 +34,0 @@\n-import jdk.incubator.code.CodeTransformer;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNestedCapturingLambda.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.code.CodeTransformer;\n@@ -41,0 +40,3 @@\n+ * @library ..\/\n+ * @run junit TestSlots\n+ * @run main Unreflect TestSlots\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+ * @library ..\/\n+ * @run junit TestSwitch\n+ * @run main Unreflect TestSwitch\n@@ -136,1 +139,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSwitch.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.code.CodeTransformer;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSynchronizedOp.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,289 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestTry\n- *\/\n-\n-public class TestTry {\n-\n-    @Reflect\n-    public static void catching(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            consume(e);\n-            c.accept(1);\n-            c.accept(-1);\n-        } catch (IllegalArgumentException e) {\n-            consume(e);\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatching() {\n-        CoreOp.FuncOp f = getFuncOp(\"catching\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTry::catching);\n-\n-        test.accept(i -> {\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new NullPointerException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-            if (i == 1) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalArgumentException();\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalStateException();\n-        });\n-    }\n-\n-    @Reflect\n-    public static void catchThrowable(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            consume(e);\n-            c.accept(1);\n-            c.accept(-1);\n-        } catch (Throwable e) {\n-            consume(e);\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchThrowable() {\n-        CoreOp.FuncOp f = getFuncOp(\"catchThrowable\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTry::catchThrowable);\n-\n-        test.accept(i -> {\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-            if (i == 1) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new RuntimeException();\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalStateException();\n-        });\n-    }\n-\n-\n-    @Reflect\n-    public static void catchNested(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-            try {\n-                c.accept(1);\n-                c.accept(-1);\n-            } catch (IllegalStateException e) {\n-                consume(e);\n-                c.accept(2);\n-                c.accept(-1);\n-            }\n-            c.accept(3);\n-            c.accept(-1);\n-        } catch (IllegalArgumentException e) {\n-            consume(e);\n-            c.accept(4);\n-            c.accept(-1);\n-        }\n-        c.accept(5);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchNested() {\n-        CoreOp.FuncOp f = getFuncOp(\"catchNested\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTry::catchNested);\n-\n-        test.accept(i -> {\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalStateException();\n-            if (i == 2) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalStateException();\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalArgumentException();\n-            if (i == 4) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 5) throw new RuntimeException();\n-        });\n-    }\n-\n-\n-    static void consume(Throwable e) {\n-    }\n-\n-    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n-        return c -> {\n-            List<Integer> actual = new ArrayList<>();\n-            IntConsumer actualC = actual::add;\n-            Throwable actualT = null;\n-            try {\n-                actualR.accept(actualC.andThen(c));\n-            } catch (Interpreter.InterpreterException e) {\n-                throw e;\n-            } catch (Throwable t) {\n-                actualT = t;\n-                if (t instanceof AssertionError) {\n-                    t.printStackTrace();\n-                }\n-            }\n-\n-            List<Integer> expected = new ArrayList<>();\n-            IntConsumer expectedC = expected::add;\n-            Throwable expectedT = null;\n-            try {\n-                expectedR.accept(expectedC.andThen(c));\n-            } catch (Throwable t) {\n-                expectedT = t;\n-            }\n-\n-            Assertions.assertEquals(\n-                    expectedT != null ? expectedT.getClass() : null, actualT != null ? actualT.getClass() : null\n-            );\n-            Assertions.assertEquals(expected, actual);\n-        };\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n-        return c -> {\n-            try {\n-                mh.invoke(c);\n-            } catch (Throwable e) {\n-                throw erase(e);\n-            }\n-        };\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <E extends Throwable> E erase(Throwable e) throws E {\n-        return (E) e;\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestTry.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":0,"deletions":289,"binary":false,"changes":289,"status":"deleted"},{"patch":"@@ -1,257 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestTryFinally\n- *\/\n-\n-public class TestTryFinally {\n-\n-    @Reflect\n-    public static void tryCatchFinally(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchFinally() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryCatchFinally\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::tryCatchFinally\n-        );\n-\n-        test(test);\n-    }\n-\n-\n-    @Reflect\n-    public static void tryReturn(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-            return;\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testTryReturn() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryReturn\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::tryReturn\n-                );\n-\n-        test(test);\n-    }\n-\n-\n-    @Reflect\n-    public static void catchThrow(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-            throw e;\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchThrow() {\n-        CoreOp.FuncOp f = getFuncOp(\"catchThrow\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::catchThrow\n-        );\n-\n-        test(test);\n-    }\n-\n-\n-    @Reflect\n-    public static void finallyReturn(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-            return;\n-        }\n-    }\n-\n-    @Test\n-    public void testFinallyReturn() {\n-        CoreOp.FuncOp f = getFuncOp(\"finallyReturn\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::finallyReturn\n-        );\n-\n-        test(test);\n-    }\n-\n-\n-    static void test(Consumer<IntConsumer> test) {\n-        test.accept(i -> {});\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-            if (i == 1) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new RuntimeException();\n-        });\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n-        return c -> {\n-            try {\n-                mh.invoke(c);\n-            } catch (Throwable e) {\n-                throw erase(e);\n-            }\n-        };\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <E extends Throwable> E erase(Throwable e) throws E {\n-        return (E) e;\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestTryFinally.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-\n-    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n-        return c -> {\n-            List<Integer> actual = new ArrayList<>();\n-            IntConsumer actualC = actual::add;\n-            Throwable actualT = null;\n-            try {\n-                actualR.accept(actualC.andThen(c));\n-            } catch (Interpreter.InterpreterException e) {\n-                throw e;\n-            } catch (Throwable t) {\n-                actualT = t;\n-                if (t instanceof AssertionError) {\n-                    t.printStackTrace();\n-                }\n-            }\n-\n-            List<Integer> expected = new ArrayList<>();\n-            IntConsumer expectedC = expected::add;\n-            Throwable expectedT = null;\n-            try {\n-                expectedR.accept(expectedC.andThen(c));\n-            } catch (Throwable t) {\n-                expectedT = t;\n-            }\n-\n-            Assertions.assertEquals(\n-                    expectedT != null ? expectedT.getClass() : null, actualT != null ? actualT.getClass() : null\n-            );\n-            Assertions.assertEquals(expected, actual);\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":0,"deletions":257,"binary":false,"changes":257,"status":"deleted"},{"patch":"@@ -1,256 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestTryFinallyNested\n- *\/\n-\n-public class TestTryFinallyNested {\n-    @Reflect\n-    public static void tryCatchFinally(IntConsumer c, int i) {\n-        try {\n-            try {\n-                if (i == 0) {\n-                    return;\n-                }\n-                c.accept(0);\n-            } catch (IllegalStateException e) {\n-                if (i == 1) {\n-                    return;\n-                }\n-                c.accept(1);\n-            } finally {\n-                if (i == 2) {\n-                    return;\n-                }\n-                c.accept(2);\n-            }\n-            if (i == 3) {\n-                return;\n-            }\n-            c.accept(3);\n-        } catch (IllegalStateException e) {\n-            if (i == 4) {\n-                return;\n-            }\n-            c.accept(4);\n-        } finally {\n-            if (i == 5) {\n-                return;\n-            }\n-            c.accept(5);\n-        }\n-        c.accept(6);\n-    }\n-\n-    @Test\n-    public void testCatchFinally() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryCatchFinally\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        for (int ra = -1; ra < 6; ra++) {\n-            int fra = ra;\n-\n-            Consumer<IntConsumer> test = testConsumer(\n-                    c -> invoke(mh, c, fra),\n-                    c -> tryCatchFinally(c, fra)\n-            );\n-\n-            test.accept(i -> {});\n-            for (int ea = 0; ea < 6; ea++) {\n-                int fea = ea;\n-                test.accept(i -> {\n-                    if (i == fea) throw new IllegalStateException();\n-                });\n-                test.accept(i -> {\n-                    if (i == fea) throw new RuntimeException();\n-                });\n-            }\n-        }\n-    }\n-\n-    @Reflect\n-    public static void tryForLoop(IntConsumer c) {\n-        for (int i = 0; i < 8; i++) {\n-            c.accept(0);\n-            try {\n-                if (i == 4) {\n-                    continue;\n-                } else if (i == 5) {\n-                    break;\n-                }\n-                c.accept(1);\n-            } finally {\n-                c.accept(2);\n-            }\n-            c.accept(3);\n-        }\n-        c.accept(4);\n-    }\n-\n-    @Test\n-    public void testTryForLoop() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryForLoop\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinallyNested::tryForLoop\n-        );\n-\n-        test.accept(i -> { });\n-    }\n-\n-\n-    @Reflect\n-    public static void tryLabeledForLoop(IntConsumer c) {\n-        a: for (int i = 0; i < 8; i++) {\n-            c.accept(0);\n-            b: {\n-                try {\n-                    if (i == 4) {\n-                        continue a;\n-                    } else if (i == 5) {\n-                        break b;\n-                    } else if (i == 6) {\n-                        break a;\n-                    }\n-                    c.accept(1);\n-                } finally {\n-                    c.accept(2);\n-                }\n-                c.accept(3);\n-            }\n-            c.accept(4);\n-        }\n-        c.accept(5);\n-    }\n-\n-    @Test\n-    public void testTryLabeledForLoop() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryLabeledForLoop\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinallyNested::tryLabeledForLoop\n-        );\n-\n-        test.accept(i -> { });\n-    }\n-\n-\n-    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n-        return c -> {\n-            List<Integer> actual = new ArrayList<>();\n-            IntConsumer actualC = actual::add;\n-            Throwable actualT = null;\n-            try {\n-                actualR.accept(actualC.andThen(c));\n-            } catch (Interpreter.InterpreterException e) {\n-                throw e;\n-            } catch (Throwable t) {\n-                actualT = t;\n-                if (t instanceof AssertionError) {\n-                    t.printStackTrace();\n-                }\n-            }\n-\n-            List<Integer> expected = new ArrayList<>();\n-            IntConsumer expectedC = expected::add;\n-            Throwable expectedT = null;\n-            try {\n-                expectedR.accept(expectedC.andThen(c));\n-            } catch (Throwable t) {\n-                expectedT = t;\n-            }\n-\n-            Assertions.assertEquals(\n-                    expectedT != null ? expectedT.getClass() : null, actualT != null ? actualT.getClass() : null\n-            );\n-            Assertions.assertEquals(expected, actual);\n-        };\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n-        return c -> {\n-            try {\n-                mh.invoke(c);\n-            } catch (Throwable e) {\n-                throw erase(e);\n-            }\n-        };\n-    }\n-\n-    static void invoke(MethodHandle mh, IntConsumer c, int i) {\n-        try {\n-            mh.invoke(c, i);\n-        } catch (Throwable e) {\n-            throw erase(e);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <E extends Throwable> E erase(Throwable e) throws E {\n-        return (E) e;\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestTryFinallyNested.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":0,"deletions":256,"binary":false,"changes":256,"status":"deleted"},{"patch":"@@ -3,1 +3,0 @@\n-import jdk.incubator.code.CodeTransformer;\n@@ -23,0 +22,3 @@\n+ * @library ..\/\n+ * @run junit TestVarArg\n+ * @run main Unreflect TestVarArg\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -14,0 +14,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestJavaVersionCheckerForLambdas.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -19,0 +19,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestJavaVersionCheckerForMethods.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}