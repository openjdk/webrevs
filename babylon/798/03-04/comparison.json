{"files":[{"patch":"@@ -34,1 +34,1 @@\n-import optkl.Invoke;\n+import optkl.Trxfmr;\n@@ -53,3 +53,2 @@\n-\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.transform;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -375,1 +374,1 @@\n-        injectBufferTracking(computeContext.computeEntrypoint());\n+        computeContext.computeEntrypoint().funcOp(injectBufferTracking(config(),lookup(),computeContext.computeEntrypoint().funcOp()));\n@@ -440,3 +439,2 @@\n-      static  public CoreOp.FuncOp transformPTXPtrs(MethodHandles.Lookup lookup,CoreOp.FuncOp func, HashMap<String, Object> argsMap, Set<String> usedMathFns) {\n-        var here = CallSite.of(CudaBackend.class, \"transformPTXPtrs\");\n-        return transform(here, func,_->true,(block, op) -> {\n+      static  public CoreOp.FuncOp transformPTXPtrs(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp, HashMap<String, Object> argsMap, Set<String> usedMathFns) {\n+        return Trxfmr.of(lookup,funcOp).transform(_->true,(block, op) -> {\n@@ -445,1 +443,1 @@\n-            if (invokeOpHelper(lookup,op) instanceof Invoke invoke){\n+            if (invoke(lookup,op) instanceof Invoke invoke){\n@@ -458,2 +456,1 @@\n-                } else if (invoke.refIs(Math.class)\n-                        && mathFns.containsKey(invoke.name() + \"_\" + invoke.returnType().toString())){\n+                } else if (invoke.refIs(Math.class) && mathFns.containsKey(invoke.name() + \"_\" + invoke.returnType().toString())){\n@@ -469,1 +466,1 @@\n-        });\n+        }).funcOp();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import optkl.Invoke;\n@@ -45,2 +44,4 @@\n-import static optkl.FieldAccess.fieldAccessOpHelper;\n-import static optkl.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -144,1 +145,1 @@\n-            if (invokeOpHelper(lookup,op) instanceof Invoke invoke && !invoke.isMappableIface()) {\n+            if (invoke(lookup,op) instanceof Invoke invoke && !invoke.isMappableIface()) {\n@@ -185,1 +186,1 @@\n-            case JavaOp.InvokeOp $ -> methodCall(invokeOpHelper(lookup,$));\n+            case JavaOp.InvokeOp $ -> methodCall(invoke(lookup,$));\n@@ -223,1 +224,1 @@\n-        var fieldAccess = fieldAccessOpHelper(lookup,fieldLoadOp);\n+        var fieldAccess = fieldAccess(lookup,fieldLoadOp);\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-        injectBufferTracking(computeContext.computeEntrypoint());\n+\n+        computeContext.computeEntrypoint().funcOp(injectBufferTracking(config(),lookup(),computeContext.computeEntrypoint().funcOp()));\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        injectBufferTracking(computeContext.computeEntrypoint());\n+        computeContext.computeEntrypoint().funcOp(injectBufferTracking(config(),lookup(),computeContext.computeEntrypoint().funcOp()));\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.code.CodeTransformer;\n@@ -34,1 +35,0 @@\n-import optkl.OpTkl;\n@@ -312,1 +312,1 @@\n-                IO.println(OpTkl.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n+                IO.println(kernelCallGraph.entrypoint.funcOp().transform(CodeTransformer.LOWERING_TRANSFORMER).toText());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.KernelContext;\n@@ -32,7 +31,0 @@\n-import optkl.Invoke;\n-import optkl.util.CallSite;\n-import optkl.ifacemapper.Buffer;\n-import hat.callgraph.CallGraph;\n-import optkl.ifacemapper.MappableIface;\n-import optkl.FuncOpParams;\n-import jdk.incubator.code.Value;\n@@ -40,4 +32,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -46,1 +34,0 @@\n-import java.lang.annotation.Annotation;\n@@ -49,9 +36,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import static hat.ComputeContext.WRAPPER.ACCESS;\n-import static hat.ComputeContext.WRAPPER.MUTATE;\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.classTypeToTypeOrThrow;\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.transform;\n@@ -61,2 +39,2 @@\n-    public FFIBackend(Arena arena,MethodHandles.Lookup lookup,String libName, Config config) {\n-        super(arena, lookup,libName, config);\n+    public FFIBackend(Arena arena, MethodHandles.Lookup lookup, String libName, Config config) {\n+        super(arena, lookup, libName, config);\n@@ -87,131 +65,0 @@\n-    record TypeAndAccess(Annotation[] annotations, Value value, JavaType javaType) {\n-        static TypeAndAccess of(Annotation[] annotations, Value value) {\n-            return new TypeAndAccess(annotations, value, (JavaType) value.type());\n-        }\n-        boolean isIface(MethodHandles.Lookup lookup) {\n-            return isAssignable(lookup, javaType,MappableIface.class);\n-        }\n-        boolean ro(){\n-            for (Annotation annotation : annotations) {\n-                if (  annotation instanceof MappableIface.RO){\n-                    System.out.println(\"MappableIface.RO\");\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-        boolean rw(){\n-            for (Annotation annotation : annotations) {\n-                if (  annotation instanceof MappableIface.RW){\n-                    System.out.println(\"MappableIface.RW\");\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-        boolean wo(){\n-            for (Annotation annotation : annotations) {\n-                if (  annotation instanceof MappableIface.WO){\n-                    System.out.println(\"MappableIface.WO\");\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-    }\n-\n-\n-\n-    \/\/ This code should be common with jextracted-shared probably should be pushed down into another lib?\n-    protected CoreOp.FuncOp injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n-        CoreOp.FuncOp transformedFuncOp = computeMethod.funcOp();\n-        var here = CallSite.of(FFIBackend.class,\"injectBufferTracking\");\n-        if (config().minimizeCopies()) {\n-            if (config().showComputeModel()) {\n-                System.out.println(\"COMPUTE entrypoint before injecting buffer tracking...\");\n-                System.out.println(transformedFuncOp.toText());\n-            }\n-            var paramTable = new FuncOpParams(computeMethod.funcOp());\n-\n-            transformedFuncOp = transform(here, computeMethod.funcOp(),_->true,(bldr, op) -> {\n-                if (invokeOpHelper(lookup(),op) instanceof Invoke invoke ) {\n-                    Value cc = bldr.context().getValue(paramTable.list().getFirst().parameter);\n-                    if (invoke.isMappableIface() && invoke.returnsVoid()) {                    \/\/ iface.v(newV)\n-                        Value iface = bldr.context().getValue(invoke.op().operands().getFirst());\n-                        bldr.op(JavaOp.invoke(MUTATE.pre, cc, iface));                  \/\/ cc->preMutate(iface);\n-                        bldr.op(invoke.op());                                              \/\/ iface.v(newV);\n-                        bldr.op(JavaOp.invoke(MUTATE.post, cc, iface));                 \/\/ cc->postMutate(iface)\n-                    } else if (invoke.isMappableIface()\n-                            && (\n-                                    invoke.returnsClassType()\n-                                            && classTypeToTypeOrThrow(lookup(), (ClassType)invoke.returnType()) instanceof Class<?> type\n-                                            && Buffer.class.isAssignableFrom(type)\n-                                ||\n-                                            invoke.returnsPrimitive()\n-                               )\n-                    ) {\n-                        \/\/ if this is accessing a width if an array we don't want to force the buffer back from the GPU.\n-                        Value iface = bldr.context().getValue(invoke.op().operands().getFirst());\n-                        bldr.op(JavaOp.invoke(ACCESS.pre, cc, iface));                 \/\/ cc->preAccess(iface);\n-                        bldr.op(invoke.op());                                             \/\/ iface.v();\n-                        bldr.op(JavaOp.invoke(ACCESS.post, cc, iface));                \/\/ cc->postAccess(iface)\n-                    } else if (invoke.refIs(ComputeContext.class,KernelContext.class)) { \/\/dispatchKernel\n-                        bldr.op(invoke.op());\n-                    } else {\n-                        List<Value> list = invoke.op().operands();\n-                        if (!list.isEmpty()) {\n-                          \/\/  System.out.println(\"Escape! with args \" +invokeOp.toText());\n-                            \/\/ We need to check\n-\n-                            var method = invoke.resolveMethodOrThrow();\n-\n-                            Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n-                            boolean isVirtual = list.size() > parameterAnnotations.length;\n-                            List<TypeAndAccess> typeAndAccesses = new ArrayList<>();\n-                            for (int i = isVirtual ? 1 : 0; i < list.size(); i++) {\n-                                typeAndAccesses.add(TypeAndAccess.of(\n-                                        parameterAnnotations[i - (isVirtual ? 1 : 0)],\n-                                        list.get(i)));\n-                            }\n-                            typeAndAccesses.stream()\n-                                    .filter(typeAndAccess -> typeAndAccess.isIface(lookup()))\/\/InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, typeAndAccess.javaType))\n-                                    .forEach(typeAndAccess -> {\n-                                        if (typeAndAccess.ro()) {\n-                                            bldr.op(JavaOp.invoke(ACCESS.pre, cc, bldr.context().getValue(typeAndAccess.value)));\n-                                        } else {\n-                                            bldr.op(JavaOp.invoke(MUTATE.pre, cc, bldr.context().getValue(typeAndAccess.value)));\n-                                        }\n-                                    });\n-                            bldr.op(invoke.op());\n-                            typeAndAccesses.stream()\n-                                    .filter(typeAndAccess -> isAssignable(lookup(), typeAndAccess.javaType, MappableIface.class))\n-                                    .forEach(typeAndAccess -> {\n-                                        if (typeAndAccess.ro()) {\n-                                            bldr.op(JavaOp.invoke(ACCESS.post, cc, bldr.context().getValue(typeAndAccess.value)));\n-                                        } else {\n-                                            bldr.op(JavaOp.invoke(MUTATE.post, cc, bldr.context().getValue(typeAndAccess.value)));\n-                                        }\n-                                    });\n-                        } else {\n-                            bldr.op(invoke.op());\n-                        }\n-                    }\n-                    return bldr;\n-                } else {\n-                    bldr.op(op);\n-                }\n-                return bldr;\n-            });\n-            if (config().showComputeModel()) {\n-                System.out.println(\"COMPUTE entrypoint after injecting buffer tracking...\");\n-                System.out.println(transformedFuncOp.toText());\n-            }\n-        }else{\n-            if (config().showComputeModel()) {\n-                System.out.println(\"COMPUTE entrypoint (we will not be injecting buffer tracking...)...\");\n-                System.out.println(transformedFuncOp.toText());\n-            }\n-        }\n-        computeMethod.funcOp(transformedFuncOp);\n-        return transformedFuncOp;\n-    }\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":2,"deletions":155,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-It was auto generated 2025-11-04 15:18:52.357 by hat.FFIConfigCreator\n+It was auto generated 2026-01-08 12:22:32.577 by hat.FFIConfigCreator\n@@ -33,1 +33,0 @@\n-\n@@ -57,0 +56,1 @@\n+    static constexpr int SHOW_COMPUTE_MODEL_JAVA_CODE_BIT = 1<<0x1e;\n@@ -82,0 +82,1 @@\n+    bool showComputeModelJavaCode;\n@@ -109,0 +110,1 @@\n+        showComputeModelJavaCode((configBits & SHOW_COMPUTE_MODEL_JAVA_CODE_BIT)==SHOW_COMPUTE_MODEL_JAVA_CODE_BIT),\n@@ -135,0 +137,1 @@\n+                std::cout << \"native showComputeModelJavaCode \" << showComputeModelJavaCode << std::endl;\n@@ -166,0 +169,1 @@\n+    \"SHOW_COMPUTE_MODEL_JAVA_CODE_BIT\",\n@@ -190,0 +194,1 @@\n+    \"Show java code view of compute model\",\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/include\/config.h","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.backend.Backend;\n@@ -64,1 +65,1 @@\n-        injectBufferTracking(computeContext.computeEntrypoint());\n+        computeContext.computeEntrypoint().funcOp(injectBufferTracking(config(),lookup(),computeContext.computeEntrypoint().funcOp()));\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLBackend.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import optkl.util.CallSite;\n-import optkl.OpTkl;\n@@ -83,2 +81,1 @@\n-        var here = CallSite.of(C99JExtractedBackend.class, \"createCode\");\n-        builder.defines().types();\n+         builder.defines().types();\n@@ -100,4 +97,0 @@\n-        \/\/ Sorting by rank ensures we don't need forward declarations\n-     \/\/   kernelCallGraph.kernelReachableResolvedStream().sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n-       \/\/         .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(buildContext,kernelReachableResolvedMethod.funcOp()).nl());\n-\n@@ -106,5 +99,0 @@\n-        System.out.println(\"Original\");\n-        System.out.println(kernelCallGraph.entrypoint.funcOp().toText());\n-        System.out.println(\"Lowered\");\n-        System.out.println(OpTkl.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n-\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -65,8 +65,0 @@\n-\n-    \/\/ This code should be common with ffi-shared probably should be pushed down into another lib?\n-    protected static CoreOp.FuncOp injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n-      \/\/  System.out.println(\"COMPUTE entrypoint before injecting buffer tracking...\");\n-       \/\/ System.out.println(computeMethod.funcOp().toText());\n-        throw new RuntimeException(\"implement inject buffer tracking \");\n-        \/\/return transformedFuncOp;\n-    }\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-import static optkl.Invoke.getTargetInvoke;\n-import static optkl.OpTkl.getQuotedCapturedValues;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.getTargetInvoke;\n+import static optkl.OpHelper.Lambda.lambdaOpHelper;\n@@ -203,1 +203,1 @@\n-        Object[] args = getQuotedCapturedValues(lambda, quoted, method);\n+        Object[] args = lambdaOpHelper(lookup,lambda).getQuotedCapturedValues( quoted, method);\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -31,2 +31,0 @@\n-import optkl.util.CallSite;\n-import optkl.OpTkl;\n@@ -44,3 +42,2 @@\n-\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.isAssignable;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -61,1 +58,1 @@\n-            } else if (isAssignable(lookup, p.type(), MappableIface.class)) {\n+            } else if (OpHelper.isAssignable(lookup, p.type(), MappableIface.class)) {\n@@ -72,1 +69,0 @@\n-        var here = CallSite.of(BufferTagger.class, \"inlineLoop\");\n@@ -77,2 +73,2 @@\n-            ssaFunc = OpTkl.transform(here, ssaFunc,(blockbuilder, op) -> {\n-                Invoke invoke  = invokeOpHelper(lookup, op);\n+            ssaFunc = ssaFunc.transform( (blockbuilder, op) -> {\n+                Invoke invoke  = invoke(lookup, op);\n@@ -85,2 +81,2 @@\n-                                CoreOp.FuncOp ssaInline = SSA.transform(inline.transform(CodeTransformer.LOWERING_TRANSFORMER));\n-                                Block.Builder exit = Inliner.inline(\n+                                var ssaInline =SSA.transform(inline.transform(CodeTransformer.LOWERING_TRANSFORMER));\n+                                var exitBlockBuilder = Inliner.inline(\n@@ -94,1 +90,1 @@\n-                                        }else{\n+                                        } else{\n@@ -98,2 +94,2 @@\n-                                if (!exit.parameters().isEmpty()) {\n-                                    blockbuilder.context().mapValue(invoke.op().result(), exit.parameters().getFirst());\n+                                if (!exitBlockBuilder.parameters().isEmpty()) {\n+                                    blockbuilder.context().mapValue(invoke.op().result(), exitBlockBuilder.parameters().getFirst());\n@@ -102,1 +98,1 @@\n-                                return exit.rebind(blockbuilder.context(), blockbuilder.transformer());\n+                                return exitBlockBuilder.rebind(blockbuilder.context(), blockbuilder.transformer());\n@@ -110,2 +106,0 @@\n-                    changed.set(true);\n-                    return exit.rebind(blockbuilder.context(), blockbuilder.transformer());\n@@ -136,1 +130,1 @@\n-                    var ioh =  invokeOpHelper(lookup,invokeOp);\n+                    var ioh = invoke(lookup,invokeOp);\n@@ -138,1 +132,1 @@\n-                    if ( ioh.refIs(MappableIface.class)) {\n+                    if (ioh.refIs(MappableIface.class)) {\n@@ -147,1 +141,1 @@\n-                    if (isAssignable(lookup,  vop.resultType().valueType(), Buffer.class)) {\n+                    if (OpHelper.isAssignable(lookup,  vop.resultType().valueType(), Buffer.class)) {\n@@ -149,1 +143,1 @@\n-                    }else{\n+                    } else {\n@@ -154,1 +148,1 @@\n-                    if (isAssignable(lookup,  flop.fieldDescriptor().refType(), KernelContext.class)) {\n+                    if (OpHelper.isAssignable(lookup,  flop.fieldDescriptor().refType(), KernelContext.class)) {\n@@ -156,1 +150,1 @@\n-                    }else{\n+                    } else {\n@@ -175,1 +169,1 @@\n-                if (isAssignable(lookup, value.type(), MappableIface.class)) {\n+                if (OpHelper.isAssignable(lookup, value.type(), MappableIface.class)) {\n@@ -180,1 +174,1 @@\n-                }else{\n+                } else {\n@@ -183,1 +177,1 @@\n-            }else{\n+            } else {\n@@ -202,1 +196,1 @@\n-            }else{\n+            } else {\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":22,"deletions":28,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-import static optkl.Invoke.getTargetInvoke;\n-import static optkl.OpTkl.getQuotedCapturedValues;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.getTargetInvoke;\n+import static optkl.OpHelper.Lambda.lambdaOpHelper;\n@@ -170,1 +170,1 @@\n-        Object[] args = getQuotedCapturedValues(kernelCallSite.lambdaOp,kernelCallSite.quoted, kernelCallSite.kernelCallGraph.entrypoint.method);\n+        Object[] args = lambdaOpHelper(lookup(),kernelCallSite.lambdaOp).getQuotedCapturedValues(kernelCallSite.quoted, kernelCallSite.kernelCallGraph.entrypoint.method);\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-    public record Bit(int index, int size, String name, String description) implements Comparable<Bit> {\n-        static Bit of(int index, int size, String name, String description){\n-            return new Bit(index,size,name,description);\n+    public record Bit(int index, int size, String name, String alt, String description) implements Comparable<Bit> {\n+        static Bit of(int index, int size, String name, String alt, String description){\n+            return new Bit(index,size,name, alt, description);\n@@ -38,2 +38,2 @@\n-        public static Bit of(int index, String name, String description){\n-            return new Bit(index,1,name,description);\n+        public static Bit of(int index, String name, String alt,  String description){\n+            return new Bit(index,1,name, alt,description);\n@@ -42,2 +42,2 @@\n-        public static Bit nextBit(Bit bit, int size, String name, String description){\n-            return new Bit(bit.index+bit.size,size,name, description);\n+        public static Bit nextBit(Bit bit, int size, String name, String alt,String description){\n+            return new Bit(bit.index+bit.size,size,name, alt, description);\n@@ -45,2 +45,2 @@\n-        public static Bit nextBit(Bit bit, String name, String description){\n-            return nextBit(bit, 1,name,description);\n+        public static Bit nextBit(Bit bit, String name, String alt, String description){\n+            return nextBit(bit, 1,name,alt, description);\n@@ -68,3 +68,3 @@\n-    public static final Bit PLATFORM =  Bit.of(0,4, \"PLATFORM\", \"FFI ONLY platform id (0-15)\");\n-    public static final Bit DEVICE = Bit.nextBit(PLATFORM, 4, \"DEVICE\",\"FFI ONLY device id (0-15)\");\n-    private static final Bit MINIMIZE_COPIES =  Bit.nextBit(DEVICE, \"MINIMIZE_COPIES\",\"FFI ONLY Try to minimize copies\");\n+    public static final Bit PLATFORM =  Bit.of(0,4, \"PLATFORM\",\"P\", \"FFI ONLY platform id (0-15)\");\n+    public static final Bit DEVICE = Bit.nextBit(PLATFORM, 4, \"DEVICE\",\"D\",\"FFI ONLY device id (0-15)\");\n+    private static final Bit MINIMIZE_COPIES =  Bit.nextBit(DEVICE, \"MINIMIZE_COPIES\",\"MC\",\"FFI ONLY Try to minimize copies\");\n@@ -74,3 +74,3 @@\n-    private static final Bit TRACE = Bit.nextBit(MINIMIZE_COPIES,\"TRACE\", \"FFI ONLY trace code\");\n-    private static final Bit PROFILE = Bit.nextBit(TRACE, \"PROFILE\", \"FFI ONLY Turn on profiling\");\n-    private static final Bit SHOW_CODE = Bit.nextBit(PROFILE,\"SHOW_CODE\",\"Show generated code (PTX\/OpenCL\/CUDA)\");\n+    private static final Bit TRACE = Bit.nextBit(MINIMIZE_COPIES,\"TRACE\", \"T\",\"FFI ONLY trace code\");\n+    private static final Bit PROFILE = Bit.nextBit(TRACE, \"PROFILE\", \"P\",\"FFI ONLY Turn on profiling\");\n+    private static final Bit SHOW_CODE = Bit.nextBit(PROFILE,\"SHOW_CODE\",\"SC\",\"Show generated code (PTX\/OpenCL\/CUDA)\");\n@@ -80,1 +80,1 @@\n-    private static final Bit SHOW_KERNEL_MODEL = Bit.nextBit(SHOW_CODE,\"SHOW_KERNEL_MODEL\", \"Show (via OpWriter) Kernel Model\");\n+    private static final Bit SHOW_KERNEL_MODEL = Bit.nextBit(SHOW_CODE,\"SHOW_KERNEL_MODEL\", \"SKM\",\"Show (via OpWriter) Kernel Model\");\n@@ -84,1 +84,1 @@\n-    private static final Bit SHOW_COMPUTE_MODEL = Bit.nextBit(SHOW_KERNEL_MODEL,\"SHOW_COMPUTE_MODEL\", \"Show (via OpWriter) Compute Model\");\n+    private static final Bit SHOW_COMPUTE_MODEL = Bit.nextBit(SHOW_KERNEL_MODEL,\"SHOW_COMPUTE_MODEL\", \"SCM\",\"Show (via OpWriter) Compute Model\");\n@@ -88,10 +88,10 @@\n-    private static final Bit SHOW_DEVICE_INFO = Bit.nextBit(SHOW_COMPUTE_MODEL, \"SHOW_DEVICE_INFO\", \"FFI show platform and device info\");\n-    public static final Bit INFO = Bit.nextBit(SHOW_DEVICE_INFO, \"INFO\", \"INFO level logging\");\n-    public static final Bit WARN = Bit.nextBit(INFO, \"WARN\", \"WARN(ing) level logging \");\n-    public static final Bit UNIT = Bit.nextBit(WARN, \"UNIT\", \"UNIT test level logging  \");\n-    private static final Bit TRACE_COPIES = Bit.nextBit(UNIT, \"TRACE_COPIES\", \"FFI ONLY trace copies\");\n-    private static final Bit TRACE_SKIPPED_COPIES = Bit.nextBit(TRACE_COPIES, \"TRACE_SKIPPED_COPIES\", \"FFI ONLY Trace skipped copies (see MINIMIZE_COPIES) \");\n-    private static final Bit TRACE_ENQUEUES = Bit.nextBit(TRACE_SKIPPED_COPIES,\"TRACE_ENQUEUES\", \"FFI ONLY trace enqueued tasks\");\n-    private static final Bit TRACE_CALLS= Bit.nextBit(TRACE_ENQUEUES, \"TRACE_CALLS\", \"FFI ONLY trace calls (enter\/leave)\");\n-    private static final Bit SHOW_WHY = Bit.nextBit(TRACE_CALLS, \"SHOW_WHY\", \"FFI ONLY show why we decided to copy buffer (H to D)\");\n-    private static final Bit SHOW_STATE = Bit.nextBit(SHOW_WHY, \"SHOW_STATE\", \"Show iface buffer state changes\");\n+    private static final Bit SHOW_DEVICE_INFO = Bit.nextBit(SHOW_COMPUTE_MODEL, \"SHOW_DEVICE_INFO\", \"SDI\",\"FFI show platform and device info\");\n+    public static final Bit INFO = Bit.nextBit(SHOW_DEVICE_INFO, \"INFO\", \"I\",\"INFO level logging\");\n+    public static final Bit WARN = Bit.nextBit(INFO, \"WARN\", \"W\",\"WARN(ing) level logging \");\n+    public static final Bit UNIT = Bit.nextBit(WARN, \"UNIT\", \"U\",\"UNIT test level logging  \");\n+    private static final Bit TRACE_COPIES = Bit.nextBit(UNIT, \"TRACE_COPIES\", \"TC\",\"FFI ONLY trace copies\");\n+    private static final Bit TRACE_SKIPPED_COPIES = Bit.nextBit(TRACE_COPIES,\"TRACE_SKIPPED_COPIES\", \"TSC\",  \"FFI ONLY Trace skipped copies (see MINIMIZE_COPIES) \");\n+    private static final Bit TRACE_ENQUEUES = Bit.nextBit(TRACE_SKIPPED_COPIES,\"TRACE_ENQUEUES\",\"TE\", \"FFI ONLY trace enqueued tasks\");\n+    private static final Bit TRACE_CALLS= Bit.nextBit(TRACE_ENQUEUES, \"TRACE_CALLS\", \"TCALLS\",\"FFI ONLY trace calls (enter\/leave)\");\n+    private static final Bit SHOW_WHY = Bit.nextBit(TRACE_CALLS, \"SHOW_WHY\", \"SW\",\"FFI ONLY show why we decided to copy buffer (H to D)\");\n+    private static final Bit SHOW_STATE = Bit.nextBit(SHOW_WHY, \"SHOW_STATE\", \"SS\",\"Show iface buffer state changes\");\n@@ -99,1 +99,1 @@\n-    private static final Bit PTX = Bit.nextBit(SHOW_STATE, \"PTX\", \"FFI (NVIDIA) ONLY pass PTX rather than C99 CUDA code\");\n+    private static final Bit PTX = Bit.nextBit(SHOW_STATE, \"PTX\", \"PTX\",\"FFI (NVIDIA) ONLY pass PTX rather than C99 CUDA code\");\n@@ -101,1 +101,1 @@\n-    private static final Bit INTERPRET = Bit.nextBit(PTX, \"INTERPRET\", \"Interpret the code model rather than converting to bytecode\");\n+    private static final Bit INTERPRET = Bit.nextBit(PTX, \"INTERPRET\", \"I\",\"Interpret the code model rather than converting to bytecode\");\n@@ -105,1 +105,1 @@\n-    private static final Bit HEADLESS = Bit.nextBit(INTERPRET, \"HEADLESS\", \"Don't show UI\");\n+    private static final Bit HEADLESS = Bit.nextBit(INTERPRET, \"HEADLESS\", \"H\",\"Don't show UI\");\n@@ -112,1 +112,1 @@\n-    private static final Bit SHOW_LOWERED_KERNEL_MODEL = Bit.nextBit(HEADLESS,\"SHOW_LOWERED_KERNEL_MODEL\", \"Show (via OpWriter) Lowered Kernel Model\");\n+    private static final Bit SHOW_LOWERED_KERNEL_MODEL = Bit.nextBit(HEADLESS,\"SHOW_LOWERED_KERNEL_MODEL\", \"SLKM\",\"Show (via OpWriter) Lowered Kernel Model\");\n@@ -116,1 +116,1 @@\n-    private static final Bit SHOW_COMPILATION_PHASES = Bit.nextBit(SHOW_LOWERED_KERNEL_MODEL, \"SHOW_COMPILATION_PHASES\", \"Show HAT compilation phases\");\n+    private static final Bit SHOW_COMPILATION_PHASES = Bit.nextBit(SHOW_LOWERED_KERNEL_MODEL, \"SHOW_COMPILATION_PHASES\",\"SCP\", \"Show HAT compilation phases\");\n@@ -120,1 +120,1 @@\n-    private static final Bit PROFILE_CUDA_KERNEL = Bit.nextBit(SHOW_COMPILATION_PHASES, \"PROFILE_CUDA_KERNEL\", \"Add -lineinfo to CUDA kernel compilation for profiling and debugging\");\n+    private static final Bit PROFILE_CUDA_KERNEL = Bit.nextBit(SHOW_COMPILATION_PHASES, \"PROFILE_CUDA_KERNEL\",\"PCK\", \"Add -lineinfo to CUDA kernel compilation for profiling and debugging\");\n@@ -122,1 +122,1 @@\n-    public boolean isProfileCUDAKernel() {\n+    public boolean profileCUDAKernel() {\n@@ -125,0 +125,5 @@\n+    private static final Bit SHOW_COMPUTE_MODEL_JAVA_CODE = Bit.nextBit(PROFILE_CUDA_KERNEL, \"SHOW_COMPUTE_MODEL_JAVA_CODE\",\"SCMJC\", \"Show java code view of compute model\");\n+\n+    public boolean showComputeModelJavaCode() {\n+        return SHOW_COMPUTE_MODEL_JAVA_CODE.isSet(this);\n+    }\n@@ -149,1 +154,2 @@\n-            PROFILE_CUDA_KERNEL\n+            PROFILE_CUDA_KERNEL,\n+            SHOW_COMPUTE_MODEL_JAVA_CODE\n@@ -188,0 +194,5 @@\n+        } else if (spec.equals(\"HELP\")) {\n+          bitList.forEach(bit -> System.out.println(bit.name+ \"\/\"+bit.alt+\" \".repeat(40-(bit.name.length()+bit.alt.length()))+(bit.index<10?\" \":\"\")+bit.index+((bit.size>1)?\"-\"+(bit.index+bit.size-1):\"  \")+ \" \"+bit.description));\n+          if(spec.equals(\"HELP\")){\n+              System.exit(0);\n+          }\n@@ -191,1 +202,1 @@\n-            returnValue=  bitList.stream().filter(bit->bit.name().equals(spec)).findFirst().map(b->fromIntBits(b.mask()));\n+            returnValue=  bitList.stream().filter(bit->bit.name().equals(spec)||bit.alt().equals(spec)).findFirst().map(b->fromIntBits(b.mask()));\n@@ -195,1 +206,1 @@\n-                var optBit = bitList.stream().filter(bit -> bit.name().equals(split[0])).findFirst();\n+                var optBit = bitList.stream().filter(bit -> bit.name().equals(split[0])||bit.alt().equals(split[0])).findFirst();\n","filename":"hat\/core\/src\/main\/java\/hat\/Config.java","additions":48,"deletions":37,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n@@ -50,69 +49,1 @@\n-        C99HATConfigBuilder cb = new C99HATConfigBuilder();\n-        cb.oracleCopyright();\n-        cb.blockComment(\"\"\"\n-                You probably should not edit this this file!!!\n-                It was auto generated\"\"\" + \" \" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date()) + \" by \" + FFIConfigCreator.class.getName()\n-        );\n-        cb.pragma(\"once\").nl();\n-        cb.includeSys(\"iostream\").nl();\n-        final int START_BIT_INDEX = Config.bitList.stream().filter(bit -> bit.size() == 1).findFirst().get().index();\n-\n-        cb.structKeyword().space().className().braceNlIndented((_) -> {\n-            var i = StreamMutable.of(START_BIT_INDEX);\n-            Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit -> {\n-                cb.staticConstIntShiftedOne(bit.name() + \"_BIT\", 32, i.get());\n-                i.set(i.get() + 1);\n-            });\n-            cb.constKeyword().space().staticKeyword().space().s08Type().space().asterisk().bitNamesVar().osbrace().csbrace().semicolon().space().lineComment(\"See below for initialization\");\n-            cb.constKeyword().space().staticKeyword().space().s08Type().space().asterisk().bitDescriptionsVar().osbrace().csbrace().semicolon().space().lineComment(\"See below for initialization\");\n-\n-            cb.s32Type().space().identifier(\"configBits\").semicolon().nl();\n-\n-            Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n-                    cb.identifier(\"bool\").space().camelExceptFirst(bit.name()).semicolon().nl()\n-            );\n-\n-            cb.s32Type().space().identifier(\"platform\").semicolon().nl();\n-            cb.s32Type().space().identifier(\"device\").semicolon().nl();\n-            cb.identifier(\"bool\").space().identifier(\"alwaysCopy\").semicolon().nl();\n-            \/\/Constructor\n-            cb.explicitKeyword().space().className().paren((_) -> cb.s32Type().space().configBitsVar()).colon().nl().indent((_) -> {\n-                cb.configBitsVar().paren((_) -> cb.configBitsVar()).comma().nl();\n-                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n-                        cb.camelExceptFirst(bit.name()).paren((_) -> cb.paren((_) -> cb.configBitsAndBitName(bit.name())).eq().identifier(bit.name() + \"_BIT\")).comma().nl()\n-                );\n-                cb.identifier(\"platform\").paren((_) -> cb.configBitsAnd().intHexValue(0xf)).comma().nl();\n-                cb.identifier(\"alwaysCopy\").paren(_ -> cb.pling().camelExceptFirst(\"MINIMIZE_COPIES\")).comma().nl();\n-                cb.identifier(\"device\").paren(_ ->\n-                        cb.paren(_ -> cb.configBitsAnd().intHexValue(0xf0)).space().rightShift().space().intValue(4)).braceNlIndented(_ ->\n-                        cb.ifKeyword().paren(_ -> cb.identifier(\"showDeviceInfo\")).braceNlIndented(_ -> {\n-                            cb.nlSeparated(\n-                                    Config.bitList.stream().filter(bit -> bit.size() == 1),\n-                                    bit -> cb.stdCout(\"native \" + cb.toCamelExceptFirst(bit.name()) + \" \").space().leftShift().space().camelExceptFirst(bit.name()).space().leftShift().space().stdEndl().semicolon()\n-                            );\n-                            cb.nl().stdCout(\"native platform \").space().leftShift().space().identifier(\"platform\").space().leftShift().space().stdEndl().semicolon();\n-                            cb.nl().stdCout(\"native device \").space().leftShift().space().identifier(\"device\").space().leftShift().space().stdEndl().semicolon();\n-                        })\n-                );\n-            }).nl();\n-\n-            cb.virtualKeyword().space().tilde().className().ocparen().equals().space().defaultKeyword().semicolon();\n-        }).semicolon().nl().nl();\n-\n-\n-        cb.hashIfdef(\"shared_cpp\", (_) -> {\n-            cb.constKeyword().space().s08Type().space().asterisk().className().colon().colon().bitNamesVar().ocsbrace().equals().brace((_) -> {\n-                cb.nl();\n-                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n-                        cb.dquote().identifier(bit.name() + \"_BIT\").dquote().comma().nl()\n-                );\n-            }).semicolon().nl();\n-            cb.constKeyword().space().s08Type().space().asterisk().className().colon().colon().bitDescriptionsVar().ocsbrace().equals().brace((_) -> {\n-                cb.nl();\n-                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n-                        cb.dquote().identifier(bit.description()).dquote().comma().nl()\n-                );\n-            }).semicolon().nl();\n-        });\n-\n-        Files.writeString(configDotH, cb.toString());\n+        Files.writeString(configDotH, C99HATConfigBuilder.create());\n","filename":"hat\/core\/src\/main\/java\/hat\/FFIConfigCreator.java","additions":1,"deletions":70,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -33,0 +33,7 @@\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.FuncOpParams;\n+import optkl.OpHelper;\n+import optkl.Trxfmr;\n+import optkl.ifacemapper.AccessType;\n@@ -35,0 +42,1 @@\n+import optkl.ifacemapper.MappableIface;\n@@ -39,0 +47,1 @@\n+import java.util.List;\n@@ -42,0 +51,4 @@\n+import static hat.ComputeContext.WRAPPER.ACCESS;\n+import static hat.ComputeContext.WRAPPER.MUTATE;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+\n@@ -91,0 +104,47 @@\n+\n+\n+    public static  CoreOp.FuncOp injectBufferTracking(Config config, MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        var transformer = Trxfmr.of(lookup,funcOp);\n+        if (config.minimizeCopies()) {\n+            var paramTable = new FuncOpParams(funcOp);\n+            return transformer\n+                    .when(config.showComputeModel(), trxfmr -> trxfmr.toText(\"COMPUTE before injecting buffer tracking...\"))\n+                    .when(config.showComputeModelJavaCode(), trxfmr -> trxfmr.toJava(\"COMPUTE (Java) before injecting buffer tracking...\"))\n+                    .transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n+                        var invoke = invoke(lookup, c.op());\n+                        if (invoke.isMappableIface() && (invoke.returns(MappableIface.class) || invoke.returnsPrimitive())) {\n+                            Value computeContext = c.getValue(paramTable.list().getFirst().parameter);\n+                            Value ifaceMappedBuffer = c.mappedOperand(0);\n+                            c.add(JavaOp.invoke(invoke.returnsVoid() ? MUTATE.pre : ACCESS.pre, computeContext, ifaceMappedBuffer));\n+                            c.retain();\n+                            c.add(JavaOp.invoke(invoke.returnsVoid() ? MUTATE.post : ACCESS.post, computeContext, ifaceMappedBuffer));\n+                        } else if (!invoke.refIs(ComputeContext.class) && invoke.operandCount() > 0) {\n+                            List<AccessType.TypeAndAccess> typeAndAccesses = invoke.paramaterAccessList();\n+                            Value computeContext = c.getValue(paramTable.list().getFirst().parameter);\n+                            typeAndAccesses.stream()\n+                                    .filter(typeAndAccess -> typeAndAccess.isIface(lookup))\n+                                    .forEach(typeAndAccess ->\n+                                            c.add(JavaOp.invoke(\n+                                                    typeAndAccess.ro() ? ACCESS.pre : MUTATE.pre,\n+                                                    computeContext, c.getValue(typeAndAccess.value()))\n+                                            )\n+                                    );\n+                            c.retain();\n+                            typeAndAccesses.stream()\n+                                    .filter(typeAndAccess -> OpHelper.isAssignable(lookup, typeAndAccess.javaType(), MappableIface.class))\n+                                    .forEach(typeAndAccess ->\n+                                            c.add(JavaOp.invoke(\n+                                                    typeAndAccess.ro() ? ACCESS.post : MUTATE.post,\n+                                                    computeContext, c.getValue(typeAndAccess.value()))\n+                                            )\n+                                    );\n+                        }\n+                    })\n+                    .when(config.showComputeModel(), trxfmr -> trxfmr.toText(\"COMPUTE after injecting buffer tracking...\"))\n+                    .funcOp();\n+        } else {\n+            return transformer.when(config.showComputeModel(), trxfmr -> trxfmr.toText(\"COMPUTE not injecting buffer tracking)\")).funcOp();\n+        }\n+    }\n+\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/Backend.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-import optkl.Invoke;\n-import optkl.util.CallSite;\n+import optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n@@ -36,1 +35,0 @@\n-import optkl.OpTkl;\n@@ -50,3 +48,0 @@\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.elements;\n-\n@@ -82,3 +77,3 @@\n-        var here = CallSite.of(OpTkl.class, \"createTransitiveInvokeModule\");\n-        elements(here, entry).forEach(codeElement -> {\n-            if (invokeOpHelper(lookup,codeElement) instanceof Invoke invoke) {\n+\n+        Invoke.stream(lookup,entry)\n+                .forEach(invoke -> {\n@@ -97,1 +92,0 @@\n-            }\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.OpHelper;\n@@ -44,2 +45,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.isAssignable;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -118,1 +118,1 @@\n-                        } else if (isAssignable(lookup,paramInfo.javaType, MappableIface.class)){\n+                        } else if (OpHelper.isAssignable(lookup,paramInfo.javaType, MappableIface.class)){\n@@ -141,1 +141,1 @@\n-        var invoke = invokeOpHelper(computeContext.lookup(),invokeOp);\n+        var invoke = invoke(computeContext.lookup(),invokeOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.dialect.*;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.ParamVar;\n-import optkl.codebuilders.BabylonCoreOpBuilder;\n-import optkl.codebuilders.ScopedCodeBuilderContext;\n-\n-\/* this should not be too C99 specific *\/\n-public interface BabylonKernelOpBuilder<T extends HATCodeBuilder<?>> extends BabylonCoreOpBuilder<T, ScopedCodeBuilderContext> {\n-\n-    T hatBarrierOp(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp);\n-\n-    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATLocalVarOp barrierOp);\n-\n-    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATPrivateVarOp hatLocalVarOp);\n-\n-    T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp hatGlobalThreadIdOp);\n-\n-    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp hatGlobalSizeOp);\n-\n-    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp hatLocalThreadIdOp);\n-\n-    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp);\n-\n-    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp);\n-\n-    T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarOp hatVectorVarOp);\n-\n-    T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorStoreView hatFloat4StoreOp);\n-\n-    T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp);\n-\n-    T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorLoadOp hatVectorLoadOp);\n-\n-    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectLoadOp hatVSelectLoadOp);\n-\n-    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectStoreOp hatVSelectStoreOp);\n-\n-    T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarLoadOp hatVectorVarLoadOp);\n-\n-    T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarOp hatF16VarOp);\n-\n-    T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatF16BinaryOp);\n-\n-    T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarLoadOp hatF16VarLoadOp);\n-\n-    T hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ConvOp hatF16ConvOp);\n-\n-    T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorOfOp hatVectorOp);\n-\n-    T hatVectorMakeOf(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorMakeOfOp hatVectorMakeOfOp);\n-\n-    T hatF16ToFloatConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ToFloatConvOp hatF16ToFloatConvOp);\n-\n-    T hatPrivateVarInitOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp);\n-\n-    T hatMemoryLoadOp(ScopedCodeBuilderContext buildContext, HATMemoryDefOp.HATMemoryLoadOp hatMemoryLoadOp);\n-\n-    T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLoadOp hatPtrLoadOp);\n-\n-    T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrStoreOp hatPtrStoreOp);\n-\n-    T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLengthOp hatPtrLengthOp);\n-\n-    default T recurse(ScopedCodeBuilderContext buildContext, Op op) {\n-        switch (op) {\n-            case CoreOp.VarAccessOp.VarLoadOp $ -> varLoadOp(buildContext, $);\n-            case CoreOp.VarAccessOp.VarStoreOp $ -> varStoreOp(buildContext, $);\n-            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoadOp(buildContext, $);\n-            case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStoreOp(buildContext, $);\n-            case JavaOp.ConvOp $ -> convOp(buildContext, $);\n-            case CoreOp.ConstantOp $ -> constantOp(buildContext, $);\n-            case CoreOp.YieldOp $ -> yieldOp(buildContext, $);\n-            case CoreOp.FuncCallOp $ -> funcCallOp(buildContext, $);\n-            case JavaOp.InvokeOp $ -> invokeOp(buildContext, $);\n-            case JavaOp.ConditionalExpressionOp $ -> conditionalExpressionOp(buildContext, $);\n-            case CoreOp.VarOp $ when ParamVar.of($) instanceof ParamVar paramVar -> varOp(buildContext, $,paramVar);\n-            case CoreOp.VarOp $ -> varOp(buildContext, $);\n-            case JavaOp.LambdaOp $ -> lambdaOp(buildContext, $);\n-            case CoreOp.TupleOp $ -> tupleOp(buildContext, $);\n-            case JavaOp.WhileOp $ -> whileOp(buildContext, $);\n-            case JavaOp.IfOp $ -> ifOp(buildContext, $);\n-            case JavaOp.ForOp $ -> forOp(buildContext, $);\n-            case CoreOp.ReturnOp $ -> returnOp(buildContext, $);\n-            case JavaOp.LabeledOp $ -> labeledOp(buildContext, $);\n-            case JavaOp.BreakOp $ -> breakOp(buildContext, $);\n-            case JavaOp.ContinueOp $ -> continueOp(buildContext, $);\n-            case JavaOp.BinaryTestOp $ -> binaryTestOp(buildContext, $);\n-            case JavaOp.BinaryOp $ -> binaryOp(buildContext, $);\n-            case JavaOp.JavaConditionalOp $ -> conditionalOp(buildContext, $);\n-            case JavaOp.UnaryOp $ -> unaryOp(buildContext, $);\n-            case HATBarrierOp $ -> hatBarrierOp(buildContext, $);\n-            case HATMemoryVarOp.HATLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n-            case HATMemoryVarOp.HATPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n-            case HATMemoryVarOp.HATPrivateInitVarOp $ -> hatPrivateVarInitOp(buildContext, $);\n-            case HATThreadOp.HATGlobalThreadIdOp $ -> hatGlobalThreadIdOp(buildContext, $);\n-            case HATThreadOp.HATGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n-            case HATThreadOp.HATLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n-            case HATThreadOp.HATLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n-            case HATThreadOp.HATBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n-            case HATVectorOp.HATVectorVarOp $ -> hatVectorVarOp(buildContext, $);\n-            case HATVectorOp.HATVectorStoreView $ -> hatVectorStoreOp(buildContext, $);\n-            case HATVectorOp.HATVectorBinaryOp $ -> hatBinaryVectorOp(buildContext, $);\n-            case HATVectorOp.HATVectorLoadOp $ -> hatVectorLoadOp(buildContext, $);\n-            case HATVectorOp.HATVectorSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n-            case HATVectorOp.HATVectorSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n-            case HATVectorOp.HATVectorVarLoadOp $ -> hatVectorVarLoadOp(buildContext, $);\n-            case HATVectorOp.HATVectorOfOp $ -> hatVectorOfOps(buildContext, $);\n-            case HATF16Op.HATF16VarOp $ -> hatF16VarOp(buildContext, $);\n-            case HATF16Op.HATF16BinaryOp $ -> hatF16BinaryOp(buildContext, $);\n-            case HATF16Op.HATF16VarLoadOp $ -> hatF16VarLoadOp(buildContext, $);\n-            case HATF16Op.HATF16ConvOp $ -> hatF16ConvOp(buildContext, $);\n-            case HATVectorOp.HATVectorMakeOfOp $ -> hatVectorMakeOf(buildContext, $);\n-            case HATPtrOp.HATPtrLoadOp $ -> hatPtrLoadOp(buildContext, $);\n-            case HATPtrOp.HATPtrStoreOp $ -> hatPtrStoreOp(buildContext, $);\n-            case HATPtrOp.HATPtrLengthOp $ -> hatPtrLengthOp(buildContext, $);\n-            case HATF16Op.HATF16ToFloatConvOp $ -> hatF16ToFloatConvOp(buildContext, $);\n-            case HATMemoryDefOp.HATMemoryLoadOp $ -> hatMemoryLoadOp(buildContext, $);\n-            default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n-        }\n-        return (T) this;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonKernelOpBuilder.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+\n@@ -27,1 +28,0 @@\n-import hat.dialect.HATMemoryVarOp;\n@@ -29,3 +29,4 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n-\n-import java.util.function.Consumer;\n+import hat.dialect.HATMemoryVarOp;\n+import optkl.codebuilders.BabylonOpDispatcher;\n+import optkl.codebuilders.C99CodeBuilder;\n+import optkl.codebuilders.ScopedCodeBuilderContext;\n@@ -33,1 +34,2 @@\n-public  class C99HATCodeBuilder<T extends C99HATCodeBuilder<T>> extends HATCodeBuilder<T> {\n+public abstract class C99HATCodeBuilder<T extends C99HATCodeBuilder<T>> extends C99CodeBuilder<T>\n+        implements BabylonOpDispatcher<T, ScopedCodeBuilderContext> {\n@@ -70,294 +72,0 @@\n-    public final T suffix_t(ClassType type){\n-        String name = type.toClassName();\n-        int dotIdx = name.lastIndexOf('.');\n-        int dollarIdx = name.lastIndexOf('$');\n-        int idx = Math.max(dotIdx, dollarIdx);\n-        if (idx > 0) {\n-            name = name.substring(idx + 1);\n-        }\n-        return suffix_t(name);\n-    }\n-\n-    public final T suffix_t(String name) {\n-        return identifier(name).identifier(\"_t\");\n-    }\n-\n-    public final T suffix_u(String name) {\n-        return identifier(name).identifier(\"_u\");\n-    }\n-\n-    public final T suffix_s(String name) {\n-        return identifier(name).identifier(\"_s\");\n-    }\n-\n-    public final T suffix_t(Class<?> klass) {\n-        return suffix_t(klass.getSimpleName());\n-    }\n-\n-    public final T suffix_u(Class<?> klass) {\n-        return suffix_u(klass.getSimpleName());\n-    }\n-\n-    public final T suffix_s(Class<?> klass) {\n-        return suffix_s(klass.getSimpleName());\n-    }\n-\n-    public final T structOrUnion(boolean isStruct) {\n-        return (isStruct ? structKeyword() : union());\n-    }\n-\n-    public final T typedefKeyword() {\n-        return keyword(\"typedef\");\n-    }\n-\n-    public final T structKeyword() {\n-        return keyword(\"struct\");\n-    }\n-\n-    public final T union() {\n-        return keyword(\"union\");\n-    }\n-\n-    public final T externC() {\n-        return externKeyword().space().dquote(\"C\");\n-    }\n-\n-    public final T hashDefineKeyword() {\n-        return hash().keyword(\"define\");\n-    }\n-\n-    public final T hashIfdefKeyword() {\n-        return hash().keyword(\"ifdef\");\n-    }\n-\n-    public final T hashIfndefKeyword() {\n-        return hash().keyword(\"ifndef\");\n-    }\n-\n-    public final T hashEndif() {\n-        return hash().keyword(\"endif\").nl();\n-    }\n-\n-    public final T hashIfdef(String value) {\n-        return hashIfdefKeyword().space().constant(value).nl();\n-    }\n-\n-    public final T hashIfndef(String value) {\n-        return hashIfndefKeyword().space().constant(value).nl();\n-    }\n-\n-    public final T hashIfdef(String value, Consumer<T> consumer) {\n-        return hashIfdef(value).accept(consumer).hashEndif();\n-    }\n-\n-    public final T hashIfndef(String value, Consumer<T> consumer) {\n-        return hashIfndef(value).accept(consumer).hashEndif();\n-    }\n-\n-    public final T pragmaKeyword() {\n-        return keyword(\"pragma\");\n-    }\n-\n-    public final T includeKeyword() {\n-        return keyword(\"include\");\n-    }\n-\n-    public final T hashDefine(String name, String... values) {\n-        hashDefineKeyword().space().identifier(name);\n-        for (String value : values) {\n-            space().constant(value);\n-        }\n-        return nl();\n-    }\n-\n-    public final T hashDefine(String name, Consumer<T> consumer) {\n-        hashDefineKeyword().space().identifier(name);\n-        space();\n-        consumer.accept(self());\n-        return nl();\n-    }\n-\n-    public final T pragma(String name, String... values) {\n-        hash().pragmaKeyword().space().identifier(name);\n-        for (String value : values) {\n-            space().constant(value);\n-        }\n-        return nl();\n-    }\n-\n-    public final T includeSys(String... values) {\n-        for (String value : values) {\n-            hash().includeKeyword().space().lt().identifier(value).gt().nl();\n-        }\n-        return self();\n-    }\n-\n-    public final T include(String... values) {\n-        for (String value : values) {\n-            hash().includeKeyword().space().dquote().identifier(value).dquote().nl();\n-        }\n-        return nl();\n-    }\n-\n-    public final T externKeyword() {\n-        return keyword(\"extern\");\n-    }\n-\n-    public final T u08Type() {\n-        return typeName(\"unsigned\").space().s08Type();\n-    }\n-\n-    public final T u08Type(String identifier) {\n-        return u08Type().space().identifier(identifier);\n-    }\n-\n-    public final T u08PtrType() {\n-        return u08Type().space().asterisk();\n-    }\n-\n-    public final T u08PtrType(String identifier) {\n-        return u08PtrType().identifier(identifier);\n-    }\n-\n-    public final T u32Type() {\n-        return typeName(\"unsigned\").space().s32Type();\n-    }\n-\n-    public final T u32Type(String identifier ) {\n-        return u32Type().space().identifier(identifier);\n-    }\n-\n-    public final T u64Type() {\n-        return typeName(\"unsigned\").space().s64Type();\n-    }\n-\n-    public final T u16Type() {\n-        return typeName(\"unsigned\").space().s16Type();\n-    }\n-\n-    public final T u16Type(String identifier) {\n-        return u16Type().space().identifier(identifier);\n-    }\n-\n-    public final T bfloat16Type(String identifier) {\n-        return suffix_t(\"BFLOAT16_UNION\").space().identifier(identifier);\n-    }\n-\n-    public final  T typedefStructOrUnion(boolean isStruct, Class<?> klass, Consumer<T> consumer) {\n-        return typedefKeyword()\n-                .space()\n-                .structOrUnion(isStruct)\n-                .space()\n-                .either(isStruct, _ -> suffix_s(klass), _ -> suffix_u(klass))\n-                .braceNlIndented(consumer)\n-                .suffix_t(klass).semicolonNl();\n-    }\n-\n-    public final T typedefStruct(String name, Consumer<T> consumer) {\n-        return typedefKeyword()\n-                .space()\n-                .structKeyword()\n-                .space()\n-                .suffix_s(name)\n-                .braceNlIndented(consumer)\n-                .suffix_t(name)\n-                .semicolonNl();\n-    }\n-\n-    public final T typedefUnion(String name, Consumer<T> consumer) {\n-        return typedefKeyword()\n-                .space()\n-                .union()\n-                .space()\n-                .suffix_s(name)\n-                .braceNlIndented(consumer)\n-                .suffix_t(name)\n-                .semicolonNl();\n-    }\n-\n-    public final T typedefStruct(Class<?>clazz, Consumer<T> consumer) {\n-        return typedefStruct(clazz.getSimpleName(), consumer);\n-    }\n-\n-    public final T typedefSingleValueStruct(String structName, String type) {\n-        return typedefStruct(structName,_-> typeName(type).space().identifier(\"value\").semicolon());\n-    }\n-\n-    public final T unionBfloat16() {\n-        return typedefUnion(\"BFLOAT16_UNION\", _ -> {\n-            typeName(\"float\").space().identifier(\"f\").semicolon().nl();\n-            u16Type(\"s\").sizeArray(2).semicolon();\n-        });\n-    }\n-\n-    public final T funcDef(Consumer<T> type, Consumer<T> name, Consumer<T> args, Consumer<T> body){\n-        type.accept(self());\n-        space();\n-        name.accept(self());\n-        paren(args);\n-        braceNlIndented(body);\n-        return nl();\n-    }\n-\n-    public final T assign(Consumer<T> lhs, Consumer<T> rhs){\n-        lhs.accept(self());\n-        space().equals().space();\n-        rhs.accept(self());\n-        return self();\n-    }\n-\n-    public final T cast(Consumer<T> type){\n-        return paren(_-> type.accept(self()));\n-    }\n-\n-    public final T returnKeyword(Consumer<T> exp){\n-        return returnKeyword().space().paren(_-> exp.accept(self())).semicolon();\n-    }\n-\n-    public final T call(Consumer<T> name,Consumer<T> ...args) {\n-        name.accept(self());\n-        return paren(_->commaSpaceSeparated(args));\n-    }\n-\n-    public final T call(String name,Consumer<T> ...args) {\n-        return call(_->identifier(name),args);\n-    }\n-\n-    public final T forLoop(Consumer<T> init, Consumer<T> test, Consumer<T>mutate, Consumer<T>body) {\n-        return  forKeyword()\n-                .paren(_->{\n-                    init.accept(self());\n-                    semicolon().space();\n-                    test.accept(self());\n-                    semicolon().space();mutate.accept(self());\n-                })\n-                .braceNlIndented(body::accept);\n-    }\n-\n-    public final T sizeof() {\n-        return emitText(\"sizeof\");\n-    }\n-\n-    public final T sizeof(String identifier) {\n-        return sizeof(_->identifier(identifier));\n-    }\n-\n-    public final T sizeof(Consumer<T> consumer) {\n-        return sizeof().paren(consumer);\n-    }\n-\n-    public final T voidPtrType() {\n-        return voidType().space().asterisk();\n-    }\n-\n-    public final T voidPtrType(String identifier) {\n-        return voidPtrType().identifier(identifier);\n-    }\n-\n-    public final T sizeType() {\n-        return typeName(\"size_t\");\n-    }\n-\n-    public final T sizeType(String identifier) {\n-        return sizeType().space().identifier(identifier);\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilder.java","additions":7,"deletions":299,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -1,477 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.dialect.HATF16Op;\n-import hat.dialect.HATVectorOp;\n-import hat.types.HAType;\n-import hat.device.DeviceType;\n-import hat.dialect.HATMemoryVarOp;\n-import optkl.FieldAccess;\n-import optkl.FuncOpParams;\n-import optkl.Invoke;\n-import optkl.OpTkl;\n-import optkl.ParamVar;\n-import optkl.ifacemapper.MappableIface;\n-import optkl.util.ops.Precedence;\n-import optkl.util.Regex;\n-import optkl.util.StreamMutable;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.codebuilders.BabylonCoreOpBuilder;\n-import optkl.codebuilders.CodeBuilder;\n-import optkl.codebuilders.ScopedCodeBuilderContext;\n-\n-import static optkl.FieldAccess.fieldAccessOpHelper;\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.condBlock;\n-import static optkl.OpTkl.elseBlock;\n-import static optkl.OpTkl.initBlock;\n-import static optkl.OpTkl.lhsOps;\n-import static optkl.OpTkl.lhsResult;\n-import static optkl.OpTkl.mutateBlock;\n-import static optkl.OpTkl.result;\n-import static optkl.OpTkl.rhsOps;\n-import static optkl.OpTkl.rhsResult;\n-import static optkl.OpTkl.thenBlock;\n-\n-public abstract class C99HATCodeBuilderContext<T extends C99HATCodeBuilderContext<T>> extends C99HATCodeBuilder<T>\n-        implements BabylonCoreOpBuilder<T, ScopedCodeBuilderContext> {\n-\n-\n-    @Override\n-    public final T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n-        switch (resolve) {\n-            case CoreOp.VarOp $ -> varName($);\n-            case HATMemoryVarOp $ -> varName($);\n-            case HATVectorOp.HATVectorVarOp $ -> varName($);\n-            case HATVectorOp.HATVectorLoadOp $ -> varName($);\n-            case HATVectorOp.HATVectorBinaryOp $ -> varName($);\n-            case HATF16Op.HATF16VarOp $ -> varName($);\n-            case null, default -> {\n-            }\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public final T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp) {\n-        Op op = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n-\n-        \/\/TODO see if VarLikeOp marker interface fixes this\n-\n-        \/\/ TODO: each of these is delegating to varName().... maybe varName should be handling these types.\n-\n-        \/\/ When the op is intended to operate as VarOp, then we need to include it in the following switch.\n-        \/\/ This is because HAT has its own dialect, and some of the Ops operate on HAT Types (not included in the Java\n-        \/\/ dialect). For instance, private data structures, local data structures, vector types, etc.\n-        switch (op) {\n-            case CoreOp.VarOp varOp -> varName(varOp);\n-            case HATF16Op.HATF16VarOp hatf16VarOp -> varName(hatf16VarOp);\n-            case HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp);\n-            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp);\n-            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp);\n-            case HATVectorOp.HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp);\n-            case null, default -> throw new IllegalStateException(\"What type of varStoreOp is this?\");\n-        }\n-        equals().parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n-        return self();\n-    }\n-\n-    private void varDeclarationWithInitialization(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n-        if (buildContext.isVarOpFinal(varOp)) {\n-            constKeyword().space();\n-        }\n-        type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp).space().equals().space();\n-        parenthesisIfNeeded(buildContext, varOp, ((Op.Result)varOp.operands().getFirst()).op());\n-    }\n-\n-    @Override\n-    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n-        if (varOp.isUninitialized()) {\n-            type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp);\n-        } else {\n-            varDeclarationWithInitialization(buildContext, varOp);\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, ParamVar paramVar) {\n-        varName(varOp);\n-        return self();\n-    }\n-\n-    @Override\n-    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp1) {\n-        if (fieldAccessOpHelper(buildContext.lookup,fieldLoadOp1) instanceof FieldAccess fieldAccess\n-              &&  fieldAccess.operandCount()==0 && fieldAccess.isPrimitive() ) {\n-            Object value = fieldAccess.getStaticFinalPrimitiveValue();\n-            literal(value.toString());\n-        } else {\n-            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOp1);\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T fieldStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp) {\n-        throw new IllegalStateException(\"What is this field store ?\" + fieldStoreOp);\n-       \/\/ return self();\n-    }\n-\n-\n-    @Override\n-    public T unaryOp(ScopedCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp) {\n-        symbol(unaryOp).parenthesisIfNeeded(buildContext, unaryOp, ((Op.Result)unaryOp.operands().getFirst()).op());\n-        return self();\n-    }\n-\n-    @Override\n-    public T binaryOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp) {\n-        parenthesisIfNeeded(buildContext, binaryOp, lhsResult(binaryOp).op());\n-        symbol(binaryOp);\n-        parenthesisIfNeeded(buildContext, binaryOp, rhsResult(binaryOp).op());\n-        return self();\n-    }\n-\n-\n-    @Override\n-    public T conditionalOp(ScopedCodeBuilderContext buildContext, JavaOp.JavaConditionalOp logicalOp) {\n-        lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n-        space().symbol(logicalOp).space();\n-        rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n-        return self();\n-    }\n-\n-    @Override\n-    public T binaryTestOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp) {\n-        parenthesisIfNeeded(buildContext, binaryTestOp, lhsResult(binaryTestOp).op());\n-        symbol(binaryTestOp);\n-        parenthesisIfNeeded(buildContext, binaryTestOp, rhsResult(binaryTestOp).op());\n-        return self();\n-    }\n-\n-    @Override\n-    public T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n-        \/\/ TODO: I think we need to work out how to handle doubles. If I remove this OpenCL on MAC complains (no FP64)\n-        if (convOp.resultType() == JavaType.DOUBLE) {\n-            paren(_ -> type(buildContext,JavaType.FLOAT)); \/\/ why double to float?\n-        } else {\n-            paren(_ -> type(buildContext,(JavaType)convOp.resultType()));\n-        }\n-        parenthesisIfNeeded(buildContext, convOp, result(convOp).op());\n-        return self();\n-    }\n-\n-    @Override\n-    public T constantOp(ScopedCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp) {\n-        if (constantOp.value() == null) {\n-            nullConst();\n-        } else {\n-            literal(constantOp.value().toString());\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T yieldOp(ScopedCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp) {\n-        if (yieldOp.operands().getFirst() instanceof Op.Result result) {\n-            recurse(buildContext, result.op());\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp) {\n-        return comment(\"\/*LAMBDA*\/\");\n-    }\n-\n-    @Override\n-    public T tupleOp(ScopedCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp) {\n-        commaSpaceSeparated(tupleOp.operands(),operand->{\n-            if (operand instanceof Op.Result result) {\n-                recurse(buildContext, result.op());\n-            } else {\n-                comment(\"\/*nothing to tuple*\/\");\n-            }\n-        });\n-        return self();\n-    }\n-\n-    @Override\n-    public T funcCallOp(ScopedCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp) {\n-        funcName(funcCallOp);\n-        paren(_ ->\n-            commaSpaceSeparated(\n-                    funcCallOp.operands().stream().filter(e->e instanceof Op.Result ).map(e->(Op.Result)e),\n-                    result -> recurse(buildContext,result.op())\n-            )\n-        );\n-        return self();\n-    }\n-\n-    @Override\n-    public T labeledOp(ScopedCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp) {\n-        var labelNameOp = labeledOp.bodies().getFirst().entryBlock().ops().getFirst();\n-        CoreOp.ConstantOp constantOp = (CoreOp.ConstantOp) labelNameOp;\n-        literal(constantOp.value().toString()).colon().nl();\n-        var forLoopOp = labeledOp.bodies().getFirst().entryBlock().ops().get(1);\n-        recurse(buildContext,forLoopOp);\n-        return self();\n-    }\n-\n-    @Override\n-    public T breakOp(ScopedCodeBuilderContext buildContext, JavaOp.BreakOp breakOp) {\n-        breakKeyword();\n-        if (!breakOp.operands().isEmpty() && breakOp.operands().getFirst() instanceof Op.Result result) {\n-            space();\n-            if (result.op() instanceof CoreOp.ConstantOp c) {\n-                literal(c.value().toString());\n-            }\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T continueOp(ScopedCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp) {\n-        if (!continueOp.operands().isEmpty()\n-                && continueOp.operands().getFirst() instanceof Op.Result result\n-                && result.op() instanceof CoreOp.ConstantOp c\n-        ) {\n-            continueKeyword().space().literal(c.value().toString());\n-        } else if (buildContext.scope.parent instanceof ScopedCodeBuilderContext.ForScope) {\n-            \/\/ nope\n-        } else {\n-            continueKeyword();\n-        }\n-\n-        return self();\n-    }\n-\n-    @Override\n-    public T ifOp(ScopedCodeBuilderContext buildContext, JavaOp.IfOp ifOp) {\n-        buildContext.ifScope(ifOp, () -> {\n-            var lastWasBody = StreamMutable.of(false);\n-            var i = StreamMutable.of(0);\n-            \/\/ We probably should just use a regular for loop here ;)\n-            ifOp.bodies().forEach(b->{\n-                int idx = i.get();\n-                if (b.yieldType() instanceof JavaType javaType && javaType == JavaType.VOID) {\n-                    if (ifOp.bodies().size() > idx && ifOp.bodies().get(idx).entryBlock().ops().size() > 1){\n-                        if (lastWasBody.get()) {\n-                            elseKeyword();\n-                        }\n-                        braceNlIndented(_ ->\n-                                        nlSeparated(OpTkl.statements(ifOp.bodies().get(idx).entryBlock()),\n-                                        root-> statement(buildContext,root)\n-                                        ));\n-                    }\n-                    lastWasBody.set(true);\n-                } else {\n-                    if (idx>0) {\n-                        elseKeyword().space();\n-                    }\n-                    ifKeyword().paren(_ ->\n-                            ifOp.bodies().get(idx).entryBlock()            \/\/ get the entryblock if bodies[c.value]\n-                                    .ops().stream().filter(o->o instanceof CoreOp.YieldOp) \/\/ we want all the yields\n-                                    .forEach((yield) -> recurse(buildContext, yield))\n-                    );\n-                    lastWasBody.set(false);\n-                }\n-                i.set(i.get()+1);\n-            });\n-        });\n-        return self();\n-    }\n-\n-    @Override\n-    public T whileOp(ScopedCodeBuilderContext buildContext, JavaOp.WhileOp whileOp) {\n-        whileKeyword().paren(_ ->\n-                condBlock(whileOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n-                        .forEach(o -> recurse(buildContext, o))\n-        );\n-        braceNlIndented(_ ->\n-                        nlSeparated(OpTkl.loopBodyStatements(whileOp),\n-                        statement->statement(buildContext,statement)\n-                )\n-        );\n-        return self();\n-    }\n-\n-    @Override\n-    public T forOp(ScopedCodeBuilderContext buildContext, JavaOp.ForOp forOp) {\n-        buildContext.forScope(forOp, () ->\n-                forKeyword().paren(_ -> {\n-                    initBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-                    semicolon().space();\n-                    condBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-                    semicolon().space();\n-                    commaSpaceSeparated(\n-                            OpTkl.statements(mutateBlock(forOp)),\n-                            op -> recurse(buildContext, op)\n-                    );\n-                }).braceNlIndented(_ ->\n-                            nlSeparated(OpTkl.loopBodyStatements(forOp),\n-                                    statement ->statement(buildContext,statement)\n-                        )\n-                )\n-        );\n-        return self();\n-    }\n-\n-    public abstract  T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name);\n-\n-    static Regex atomicIncRegex = Regex.of(\"(atomic.*)Inc\");\n-\n-    @Override\n-    public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n-        var invoke = invokeOpHelper(buildContext.lookup,invokeOp);\n-        if ( invoke.refIs(MappableIface.class,HAType.class,DeviceType.class)) {\n-            if (invoke.isInstance() && invoke.operandCount() == 1 && invoke.returnsInt() && invoke.named(atomicIncRegex)) {\n-                if (invoke.operandNAsResultOrThrow(0) instanceof Op.Result instanceResult) {\n-                    atomicInc(buildContext, instanceResult,\n-                            ((Regex.Match)atomicIncRegex.is(invoke.name())).stringOf(1) \/\/ atomicXXInc -> atomicXX\n-                    );\n-                }\n-            } else if (invoke.isInstance() && invoke.operandNAsResultOrThrow(0) instanceof Op.Result instance) {\n-                parenWhen(\n-                   \/\/ When we have patterns like:\n-                   \/\/\n-                   \/\/ myiFaceArray.array().value(storeAValue);\n-                   \/\/\n-                   \/\/ We need to generate extra parenthesis to make the struct pointer accessor \"->\" correct.\n-                   \/\/ This is a common pattern when we have a IFace type that contains a subtype based on\n-                   \/\/ struct or union.\n-                   \/\/ An example of this is for the type F16Array.\n-                   \/\/ The following expression checks that the current invokeOp has at least 2 operands:\n-                    \/\/ Why 2?\n-                    \/\/ - The first one is another invokeOp to load the inner struct from an IFace data structure.\n-                    \/\/   The first operand is also assignable.\n-                    \/\/ - The second one is the store value, but this depends on the semantics and definition\n-                    \/\/   of the user code.\n-                    invoke.operandCount() > 1\n-                                && invokeOpHelper(buildContext.lookup,instance.op()) instanceof Invoke invoke0\n-                                && invoke0.returnsClassType()\n-                        , _->{\n-                    when(invoke.returnsClassType(), _ -> ampersand());\n-                    recurse(buildContext, instance.op());\n-                });\n-\n-                \/\/ Check if the varOpLoad that could follow corresponds to a local\/private type\n-                boolean isLocalOrPrivateDS = (instance.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n-                        && buildContext.scope.resolve(varLoadOp.operands().getFirst()) instanceof HATMemoryVarOp);\n-\n-                either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n-\n-                funcName(invoke.op());\n-\n-                if (invoke.returnsVoid()) {\/\/   setter\n-                    switch (invoke.operandCount()) {\n-                        case 2-> {\n-                            if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n-                                equals().recurse(buildContext, op);\n-                            }\n-                        }\n-                        case 3-> {\n-                            if ( invoke.opFromOperandNAsResultOrThrow(1) instanceof Op op1\n-                                 && invoke.opFromOperandNAsResultOrThrow(2) instanceof Op op2) {\n-                                 sbrace(_ -> recurse(buildContext, op1)).equals().recurse(buildContext, op2);\n-                            }\n-                        }\n-                        default -> throw new IllegalStateException(\"How \");\n-                    }\n-                } else {\n-                    if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n-                        sbrace(_ -> recurse(buildContext, op));\n-                    }else{\n-                            \/\/ this is just call.\n-                    }\n-                }\n-            }\n-        } else {\/\/ General case\n-            funcName(invoke.op()).paren(_ ->\n-                    commaSpaceSeparated(invoke.op().operands(),\n-                            op -> {if (op instanceof Op.Result result) {recurse(buildContext, result.op());}\n-                    })\n-            );\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T conditionalExpressionOp(ScopedCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp) {\n-        condBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-        questionMark();\n-        thenBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-        colon();\n-        elseBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n-        return self();\n-    }\n-\n-    \/**\n-     * Wrap paren() of precedence of op is higher than parent.\n-     *\n-     * @param buildContext\n-     * @param parent\n-     * @param child\n-     *\/\n-    @Override\n-    public T parenthesisIfNeeded(ScopedCodeBuilderContext buildContext, Op parent, Op child) {\n-        return parenWhen(Precedence.needsParenthesis(parent,child), _ -> recurse(buildContext, child));\n-    }\n-\n-    @Override\n-    public T returnOp(ScopedCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp) {\n-        returnKeyword().when(!returnOp.operands().isEmpty(),\n-                        $-> $.space().parenthesisIfNeeded(buildContext, returnOp, OpTkl.result(returnOp).op())\n-                );\n-        return self();\n-    }\n-\n-    public T statement(ScopedCodeBuilderContext buildContext,Op op) {\n-        recurse(buildContext, op);\n-        if (switch (op){\n-                case JavaOp.ForOp _ -> false;\n-                case JavaOp.WhileOp _ -> false;\n-                case JavaOp.IfOp _ -> false;\n-                case JavaOp.LabeledOp _ -> false;\n-                case JavaOp.YieldOp _ -> false;\n-                case CoreOp.TupleOp _ ->false;\n-                default -> true;\n-            }\n-        ){\n-            semicolon();\n-        }\n-        return self();\n-    }\n-\n-    public T declareParam(ScopedCodeBuilderContext buildContext, FuncOpParams.Info param){\n-        return  type(buildContext,(JavaType) param.parameter.type()).space().varName(param.varOp);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":0,"deletions":477,"binary":false,"changes":477,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n-import optkl.OpTkl;\n+import optkl.OpHelper;\n@@ -32,1 +32,1 @@\n-public abstract class C99HATComputeBuilder<T extends C99HATComputeBuilder<T>> extends C99HATCodeBuilderContext<T> {\n+public abstract class C99HATComputeBuilder<T extends C99HATComputeBuilder<T>> extends C99HATCodeBuilder<T> {\n@@ -34,1 +34,1 @@\n-    public T computeDeclaration(TypeElement typeElement, String name) {\n+    public final T computeDeclaration(TypeElement typeElement, String name) {\n@@ -38,1 +38,1 @@\n-    public T compute(ScopedCodeBuilderContext buildContext) {\n+    public final  T compute(ScopedCodeBuilderContext buildContext) {\n@@ -49,1 +49,1 @@\n-                        OpTkl.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                        OpHelper.Statement.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import hat.FFIConfigCreator;\n+import optkl.codebuilders.C99CodeBuilder;\n+import optkl.util.StreamMutable;\n@@ -29,1 +32,2 @@\n-public  class C99HATConfigBuilder extends C99HATCodeBuilder<C99HATConfigBuilder> {\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n@@ -31,1 +35,3 @@\n-   public  C99HATConfigBuilder staticConstInt(String name, int padWidth, int value) {\n+public  class C99HATConfigBuilder extends C99CodeBuilder<C99HATConfigBuilder> {\n+\n+   public final  C99HATConfigBuilder staticConstInt(String name, int padWidth, int value) {\n@@ -36,1 +42,1 @@\n-    public C99HATConfigBuilder staticConstIntShiftedOne(String name, int padWidth, int shift) {\n+    public final C99HATConfigBuilder staticConstIntShiftedOne(String name, int padWidth, int shift) {\n@@ -41,1 +47,1 @@\n-    public C99HATConfigBuilder className() {\n+    public final C99HATConfigBuilder className() {\n@@ -45,1 +51,1 @@\n-    public C99HATConfigBuilder bitNamesVar() {\n+    public final C99HATConfigBuilder bitNamesVar() {\n@@ -49,1 +55,1 @@\n-    public C99HATConfigBuilder bitDescriptionsVar() {\n+    public final C99HATConfigBuilder bitDescriptionsVar() {\n@@ -53,1 +59,1 @@\n-    public C99HATConfigBuilder configBitsVar() {\n+    public final C99HATConfigBuilder configBitsVar() {\n@@ -57,1 +63,1 @@\n-    public C99HATConfigBuilder configBitsAnd() {\n+    public final C99HATConfigBuilder configBitsAnd() {\n@@ -61,1 +67,1 @@\n-    public C99HATConfigBuilder configBitsAndBitName(String bitName) {\n+    public final C99HATConfigBuilder configBitsAndBitName(String bitName) {\n@@ -65,1 +71,1 @@\n-    public C99HATConfigBuilder camelExceptFirst(String s) {\n+    public final C99HATConfigBuilder camelExceptFirst(String s) {\n@@ -69,1 +75,1 @@\n-    C99HATConfigBuilder std(String s) {\n+    public final C99HATConfigBuilder std(String s) {\n@@ -73,1 +79,1 @@\n-    public C99HATConfigBuilder stdEndl() {\n+    public final C99HATConfigBuilder stdEndl() {\n@@ -77,1 +83,1 @@\n-    public C99HATConfigBuilder stdCout(String s) {\n+    public final C99HATConfigBuilder stdCout(String s) {\n@@ -81,0 +87,73 @@\n+    public static String create(){\n+\n+        C99HATConfigBuilder cb = new C99HATConfigBuilder();\n+        cb.oracleCopyright();\n+        cb.blockComment(\"\"\"\n+                You probably should not edit this this file!!!\n+                It was auto generated\"\"\" + \" \" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date()) + \" by \" + FFIConfigCreator.class.getName()\n+        );\n+        cb.pragma(\"once\").nl();\n+        cb.includeSys(\"iostream\").nl();\n+        final int START_BIT_INDEX = Config.bitList.stream().filter(bit -> bit.size() == 1).findFirst().get().index();\n+\n+        cb.structKeyword().space().className().braceNlIndented((_) -> {\n+            var i = StreamMutable.of(START_BIT_INDEX);\n+            Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit -> {\n+                cb.staticConstIntShiftedOne(bit.name() + \"_BIT\", 32, i.get());\n+                i.set(i.get() + 1);\n+            });\n+            cb.constKeyword().space().staticKeyword().space().s08Type().space().asterisk().bitNamesVar().osbrace().csbrace().semicolon().space().lineComment(\"See below for initialization\");\n+            cb.constKeyword().space().staticKeyword().space().s08Type().space().asterisk().bitDescriptionsVar().osbrace().csbrace().semicolon().space().lineComment(\"See below for initialization\");\n+\n+            cb.s32Type().space().identifier(\"configBits\").semicolon().nl();\n+\n+            Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n+                    cb.identifier(\"bool\").space().camelExceptFirst(bit.name()).semicolon().nl()\n+            );\n+\n+            cb.s32Type().space().identifier(\"platform\").semicolon().nl();\n+            cb.s32Type().space().identifier(\"device\").semicolon().nl();\n+            cb.identifier(\"bool\").space().identifier(\"alwaysCopy\").semicolon().nl();\n+            \/\/Constructor\n+            cb.explicitKeyword().space().className().paren((_) -> cb.s32Type().space().configBitsVar()).colon().nl().indent((_) -> {\n+                cb.configBitsVar().paren((_) -> cb.configBitsVar()).comma().nl();\n+                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n+                        cb.camelExceptFirst(bit.name()).paren((_) -> cb.paren((_) -> cb.configBitsAndBitName(bit.name())).eq().identifier(bit.name() + \"_BIT\")).comma().nl()\n+                );\n+                cb.identifier(\"platform\").paren((_) -> cb.configBitsAnd().intHexValue(0xf)).comma().nl();\n+                cb.identifier(\"alwaysCopy\").paren(_ -> cb.pling().camelExceptFirst(\"MINIMIZE_COPIES\")).comma().nl();\n+                cb.identifier(\"device\").paren(_ ->\n+                        cb.paren(_ -> cb.configBitsAnd().intHexValue(0xf0)).space().rightShift().space().intValue(4)).braceNlIndented(_ ->\n+                        cb.ifKeyword().paren(_ -> cb.identifier(\"showDeviceInfo\")).braceNlIndented(_ -> {\n+                            cb.nlSeparated(\n+                                    Config.bitList.stream().filter(bit -> bit.size() == 1),\n+                                    bit -> cb.stdCout(\"native \" + cb.toCamelExceptFirst(bit.name()) + \" \").space().leftShift().space().camelExceptFirst(bit.name()).space().leftShift().space().stdEndl().semicolon()\n+                            );\n+                            cb.nl().stdCout(\"native platform \").space().leftShift().space().identifier(\"platform\").space().leftShift().space().stdEndl().semicolon();\n+                            cb.nl().stdCout(\"native device \").space().leftShift().space().identifier(\"device\").space().leftShift().space().stdEndl().semicolon();\n+                        })\n+                );\n+            }).nl();\n+\n+            cb.virtualKeyword().space().tilde().className().ocparen().equals().space().defaultKeyword().semicolon();\n+        }).semicolon().nl().nl();\n+\n+\n+        cb.hashIfdef(\"shared_cpp\", (_) -> {\n+            cb.constKeyword().space().s08Type().space().asterisk().className().colon().colon().bitNamesVar().ocsbrace().equals().brace((_) -> {\n+                cb.nl();\n+                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n+                        cb.dquote().identifier(bit.name() + \"_BIT\").dquote().comma().nl()\n+                );\n+            }).semicolon().nl();\n+            cb.constKeyword().space().s08Type().space().asterisk().className().colon().colon().bitDescriptionsVar().ocsbrace().equals().brace((_) -> {\n+                cb.nl();\n+                Config.bitList.stream().filter(bit -> bit.size() == 1).forEach(bit ->\n+                        cb.dquote().identifier(bit.description()).dquote().comma().nl()\n+                );\n+            }).semicolon().nl();\n+        });\n+        return cb.toString();\n+\n+    }\n+\n@@ -82,1 +161,1 @@\n-        var c = Config.fromSpec(\"INFO,SHOW_CODE,HEADLESS,NO_BUFFER_TAGGING,SHOW_KERNEL_MODEL,SHOW_COMPUTE_MODEL,PLATFORM:0,DEVICE:0\");\n+        var c = Config.fromSpec(\"INFO,SHOW_CODE,HEADLESS,SHOW_KERNEL_MODEL,SHOW_COMPUTE_MODEL,PLATFORM:0,DEVICE:0\");\n@@ -84,0 +163,1 @@\n+        System.out.println(create());\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATConfigBuilder.java","additions":94,"deletions":14,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.device.DeviceType;\n@@ -32,1 +33,2 @@\n-import optkl.OpTkl;\n+import hat.types.HAType;\n+import optkl.OpHelper;\n@@ -39,0 +41,1 @@\n+import optkl.util.Regex;\n@@ -44,1 +47,0 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -51,5 +53,0 @@\n-import static optkl.FieldAccess.fieldAccessOpHelper;\n-import static optkl.OpTkl.asResultOrThrow;\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.isPrimitiveResult;\n-import static optkl.OpTkl.statements;\n@@ -57,1 +54,3 @@\n-public abstract class C99HATKernelBuilder<T extends C99HATKernelBuilder<T>> extends C99HATCodeBuilderContext<T> implements BabylonKernelOpBuilder<T>  {\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -59,1 +58,3 @@\n-    public T HAT_KERNEL() {\n+public abstract class C99HATKernelBuilder<T extends C99HATKernelBuilder<T>> extends C99HATCodeBuilder<T> implements HATOpDispatcher<T> {\n+\n+    public final T HAT_KERNEL() {\n@@ -63,1 +64,1 @@\n-    public T HAT_FUNC() {\n+    public final T HAT_FUNC() {\n@@ -67,1 +68,1 @@\n-    public T HAT_GLOBAL_MEM() {\n+    public final T HAT_GLOBAL_MEM() {\n@@ -71,1 +72,1 @@\n-    public T HAT_LOCAL_MEM() {\n+    public final T HAT_LOCAL_MEM() {\n@@ -75,1 +76,1 @@\n-    public T HAT_BARRIER() {\n+    public final T HAT_BARRIER() {\n@@ -79,1 +80,1 @@\n-    public T HAT_GIX(){\n+    public final T HAT_GIX(){\n@@ -83,1 +84,1 @@\n-    public T HAT_GIY(){\n+    public final T HAT_GIY(){\n@@ -87,1 +88,1 @@\n-    public T HAT_GIZ(){\n+    public final T HAT_GIZ(){\n@@ -91,1 +92,1 @@\n-    public T HAT_GSX(){\n+    public final T HAT_GSX(){\n@@ -95,1 +96,1 @@\n-    public T HAT_GSY(){\n+    public final T HAT_GSY(){\n@@ -99,1 +100,1 @@\n-    public T HAT_GSZ(){\n+    public final T HAT_GSZ(){\n@@ -103,1 +104,1 @@\n-    public T HAT_LIX(){\n+    public final T HAT_LIX(){\n@@ -107,1 +108,1 @@\n-    public T HAT_LIY(){\n+    public final T HAT_LIY(){\n@@ -111,1 +112,1 @@\n-    public T HAT_LIZ(){\n+    public final T HAT_LIZ(){\n@@ -115,1 +116,1 @@\n-    public T HAT_LSX(){\n+    public final T HAT_LSX(){\n@@ -119,1 +120,1 @@\n-    public T HAT_LSY(){\n+    public final T HAT_LSY(){\n@@ -123,1 +124,1 @@\n-    public T HAT_LSZ(){\n+    public final T HAT_LSZ(){\n@@ -128,1 +129,1 @@\n-    public T HAT_BIX(){\n+    public final T HAT_BIX(){\n@@ -132,1 +133,1 @@\n-    public T HAT_BIY(){\n+    public final T HAT_BIY(){\n@@ -136,1 +137,1 @@\n-    public T HAT_BIZ(){\n+    public final T HAT_BIZ(){\n@@ -142,1 +143,1 @@\n-    public T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp globalThreadIdOp) {\n+    public final T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp globalThreadIdOp) {\n@@ -153,1 +154,1 @@\n-    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp globalSizeOp) {\n+    public final T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp globalSizeOp) {\n@@ -164,1 +165,1 @@\n-    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp localThreadIdOp) {\n+    public final T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp localThreadIdOp) {\n@@ -175,1 +176,1 @@\n-    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp) {\n+    public final T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp) {\n@@ -185,1 +186,1 @@\n-    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp) {\n+    public final T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp) {\n@@ -194,1 +195,1 @@\n-    public T kernelDeclaration(CoreOp.FuncOp funcOp) {\n+    public final T kernelDeclaration(CoreOp.FuncOp funcOp) {\n@@ -198,1 +199,1 @@\n-    public T functionDeclaration(ScopedCodeBuilderContext codeBuilderContext, JavaType javaType, CoreOp.FuncOp funcOp) {\n+    public final  T functionDeclaration(ScopedCodeBuilderContext codeBuilderContext, JavaType javaType, CoreOp.FuncOp funcOp) {\n@@ -303,1 +304,1 @@\n-    final  T identifierWithRandomSuffix(String prefix, final int len) {\n+    public  final  T identifierWithRandomSuffix(String prefix, final int len) {\n@@ -330,1 +331,1 @@\n-    public T hatBarrierOp(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp) {\n+    public final T hatBarrierOp(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp) {\n@@ -346,1 +347,1 @@\n-    public T types() {\n+    public final  T types() {\n@@ -354,2 +355,2 @@\n-    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldLoadOp);\n+    public final T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        var fieldAccess = fieldAccess(buildContext.lookup,fieldLoadOp);\n@@ -365,2 +366,2 @@\n-    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n-        if (javaType instanceof ClassType classType && isAssignable(buildContext.lookup, javaType, MappableIface.class)) {\n+    public final  T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n+        if (javaType instanceof ClassType classType && OpHelper.isAssignable(buildContext.lookup, javaType, MappableIface.class)) {\n@@ -368,1 +369,1 @@\n-        } else if (OpTkl.isAssignable(buildContext.lookup, javaType,KernelContext.class)) {\n+        } else if (OpHelper.isAssignable(buildContext.lookup, javaType,KernelContext.class)) {\n@@ -370,1 +371,1 @@\n-        } else if (OpTkl.isAssignable(buildContext.lookup, javaType,F16.class)) {\/\/ TODO: update this with a custom op, to avoid direct use of Impls\n+        } else if (OpHelper.isAssignable(buildContext.lookup, javaType,F16.class)) {\/\/ TODO: update this with a custom op, to avoid direct use of Impls\n@@ -372,1 +373,1 @@\n-        } else if (OpTkl.isAssignable(buildContext.lookup, javaType,BF16.class)) {\/\/ TODO: update this with a custom op, to avoid direct use of Impls\n+        } else if (OpHelper.isAssignable(buildContext.lookup, javaType,BF16.class)) {\/\/ TODO: update this with a custom op, to avoid direct use of Impls\n@@ -380,1 +381,2 @@\n-    public T kernelMethod(ScopedCodeBuilderContext buildContext,CoreOp.FuncOp funcOp) {\n+\n+    public final  T kernelMethod(ScopedCodeBuilderContext buildContext,CoreOp.FuncOp funcOp) {\n@@ -393,1 +395,1 @@\n-                        statements(funcOp.bodies().getFirst().entryBlock()),\n+                        OpHelper.Statement.statements(funcOp.bodies().getFirst().entryBlock()),\n@@ -401,1 +403,1 @@\n-    public T kernelEntrypoint(ScopedCodeBuilderContext buildContext) {\n+    public final  T kernelEntrypoint(ScopedCodeBuilderContext buildContext) {\n@@ -410,1 +412,1 @@\n-                    statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                    OpHelper.Statement.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n@@ -420,1 +422,1 @@\n-    public T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarLoadOp hatVectorVarLoadOp) {\n+    public final T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarLoadOp hatVectorVarLoadOp) {\n@@ -433,1 +435,1 @@\n-    public T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarOp hatF16VarOp) {\n+    public final T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarOp hatF16VarOp) {\n@@ -441,1 +443,1 @@\n-                _->recurse(buildContext, asResultOrThrow(hatF16VarOp.operands().getFirst()).op()));\n+                _->recurse(buildContext, OpHelper.asResultOrThrow(hatF16VarOp.operands().getFirst()).op()));\n@@ -460,1 +462,1 @@\n-    private T binaryOperationsForBfloat16(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatf16BinaryOp) {\n+    private final T binaryOperationsForBfloat16(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatf16BinaryOp) {\n@@ -470,1 +472,1 @@\n-                recurse(buildContext, asResultOrThrow(hatf16BinaryOp.operands().getFirst()).op());\n+                recurse(buildContext, OpHelper.asResultOrThrow(hatf16BinaryOp.operands().getFirst()).op());\n@@ -475,1 +477,1 @@\n-                } else if (!isPrimitiveResult(hatf16BinaryOp.operands().getFirst())) {\n+                } else if (!OpHelper.isPrimitiveResult(hatf16BinaryOp.operands().getFirst())) {\n@@ -490,1 +492,1 @@\n-                recurse(buildContext, asResultOrThrow(hatf16BinaryOp.operands().get(1)).op());\n+                recurse(buildContext, OpHelper.asResultOrThrow(hatf16BinaryOp.operands().get(1)).op());\n@@ -493,1 +495,1 @@\n-                } else if (!isPrimitiveResult(hatf16BinaryOp.operands().get(1))) {\n+                } else if (!OpHelper.isPrimitiveResult(hatf16BinaryOp.operands().get(1))) {\n@@ -516,1 +518,1 @@\n-                recurse(buildContext, asResultOrThrow(hatF16BinaryOp.operands().getFirst()).op());\n+                recurse(buildContext, OpHelper.asResultOrThrow(hatF16BinaryOp.operands().getFirst()).op());\n@@ -519,1 +521,1 @@\n-                } else if (!isPrimitiveResult(hatF16BinaryOp.operands().getFirst())) {\n+                } else if (!OpHelper.isPrimitiveResult(hatF16BinaryOp.operands().getFirst())) {\n@@ -525,1 +527,1 @@\n-                recurse(buildContext, asResultOrThrow(hatF16BinaryOp.operands().get(1)).op());\n+                recurse(buildContext, OpHelper.asResultOrThrow(hatF16BinaryOp.operands().get(1)).op());\n@@ -528,1 +530,1 @@\n-                } else if (!isPrimitiveResult(hatF16BinaryOp.operands().get(1))) {\n+                } else if (!OpHelper.isPrimitiveResult(hatF16BinaryOp.operands().get(1))) {\n@@ -538,1 +540,1 @@\n-    public T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarLoadOp hatF16VarLoadOp) {\n+    public final T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarLoadOp hatF16VarLoadOp) {\n@@ -543,1 +545,1 @@\n-    public T hatVectorMakeOf(ScopedCodeBuilderContext builderContext, HATVectorOp.HATVectorMakeOfOp hatVectorMakeOfOp) {\n+    public final T hatVectorMakeOf(ScopedCodeBuilderContext builderContext, HATVectorOp.HATVectorMakeOfOp hatVectorMakeOfOp) {\n@@ -550,1 +552,1 @@\n-    public T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorOfOp hatVectorOp) {\n+    public final T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorOfOp hatVectorOp) {\n@@ -554,1 +556,1 @@\n-                        operand -> recurse(buildContext, asResultOrThrow(operand).op()))\n+                        operand -> recurse(buildContext, OpHelper.asResultOrThrow(operand).op()))\n@@ -559,1 +561,1 @@\n-    public T hatPrivateVarInitOp(ScopedCodeBuilderContext builderContext, HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp) {\n+    public final T hatPrivateVarInitOp(ScopedCodeBuilderContext builderContext, HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp) {\n@@ -563,1 +565,1 @@\n-                        _->recurse(builderContext,asResultOrThrow(hatPrivateInitVarOp.operands().getFirst()).op()));\n+                        _->recurse(builderContext,OpHelper.asResultOrThrow(hatPrivateInitVarOp.operands().getFirst()).op()));\n@@ -567,2 +569,2 @@\n-    public T hatMemoryLoadOp(ScopedCodeBuilderContext builderContext, HATMemoryDefOp.HATMemoryLoadOp hatMemoryLoadOp) {\n-        return recurse(builderContext, asResultOrThrow(hatMemoryLoadOp.operands().getFirst()).op())\n+    public final T hatMemoryLoadOp(ScopedCodeBuilderContext builderContext, HATMemoryDefOp.HATMemoryLoadOp hatMemoryLoadOp) {\n+        return recurse(builderContext, OpHelper.asResultOrThrow(hatMemoryLoadOp.operands().getFirst()).op())\n@@ -571,1 +573,1 @@\n-                   sbrace(_-> recurse(builderContext, asResultOrThrow(hatMemoryLoadOp.operands().get(1)).op()))\n+                   sbrace(_-> recurse(builderContext, OpHelper.asResultOrThrow(hatMemoryLoadOp.operands().get(1)).op()))\n@@ -575,1 +577,1 @@\n-    public T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLoadOp hatPtrLoadOp) {\n+    public final T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLoadOp hatPtrLoadOp) {\n@@ -581,1 +583,1 @@\n-    public T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrStoreOp hatPtrStoreOp) {\n+    public final T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrStoreOp hatPtrStoreOp) {\n@@ -587,1 +589,1 @@\n-    public T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLengthOp hatPtrLengthOp) {\n+    public final  T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLengthOp hatPtrLengthOp) {\n@@ -592,1 +594,1 @@\n-    T ptrAccess(ScopedCodeBuilderContext builderContext, HATPtrOp hatPtrOp) {\n+    public final T ptrAccess(ScopedCodeBuilderContext builderContext, HATPtrOp hatPtrOp) {\n@@ -606,1 +608,1 @@\n-            boolean finalIsLocalOrPrivateDS = isLocalOrPrivateDS;\n+            boolean finalIsLocalOrPrivateDS = isLocalOrPrivateDS;\/\/ ?\n@@ -624,1 +626,1 @@\n-    public String hatPtrName(HATPtrOp hatPtrOp) {\n+    public final String hatPtrName(HATPtrOp hatPtrOp) {\n@@ -681,0 +683,134 @@\n+\n+\n+    @Override\n+    public final T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n+        switch (resolve) {\n+            case CoreOp.VarOp $ -> varName($);\n+            case HATMemoryVarOp $ -> varName($);\n+            case HATVectorOp.HATVectorVarOp $ -> varName($);\n+            case HATVectorOp.HATVectorLoadOp $ -> varName($);\n+            case HATVectorOp.HATVectorBinaryOp $ -> varName($);\n+            case HATF16Op.HATF16VarOp $ -> varName($);\n+            case null, default -> {\n+            }\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp) {\n+        Op op = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n+\n+        \/\/TODO see if VarLikeOp marker interface fixes this\n+\n+        \/\/ TODO: each of these is delegating to varName().... maybe varName should be handling these types.\n+\n+        \/\/ When the op is intended to operate as VarOp, then we need to include it in the following switch.\n+        \/\/ This is because HAT has its own dialect, and some of the Ops operate on HAT Types (not included in the Java\n+        \/\/ dialect). For instance, private data structures, local data structures, vector types, etc.\n+        switch (op) {\n+            case CoreOp.VarOp varOp -> varName(varOp);\n+            case HATF16Op.HATF16VarOp hatf16VarOp -> varName(hatf16VarOp);\n+            case HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp);\n+            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp);\n+            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp);\n+            case HATVectorOp.HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp);\n+            case null, default -> throw new IllegalStateException(\"What type of varStoreOp is this?\");\n+        }\n+        equals().parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public final  T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n+        \/\/ TODO: I think we need to work out how to handle doubles. If I remove this OpenCL on MAC complains (no FP64)\n+        if (convOp.resultType() == JavaType.DOUBLE) {\n+            paren(_ -> type(buildContext,JavaType.FLOAT)); \/\/ why double to float?\n+        } else {\n+            paren(_ -> type(buildContext,(JavaType)convOp.resultType()));\n+        }\n+        parenthesisIfNeeded(buildContext, convOp, ((Op.Result) convOp.operands().getFirst()).op());\n+        return self();\n+    }\n+\n+    public abstract  T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name);\n+\n+    static Regex atomicIncRegex = Regex.of(\"(atomic.*)Inc\");\n+\n+    @Override\n+    public final T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n+        var invoke = invoke(buildContext.lookup,invokeOp);\n+        if ( invoke.refIs(MappableIface.class, HAType.class, DeviceType.class)) { \/\/ we need a common type\n+            if (invoke.isInstance() && invoke.operandCount() == 1 && invoke.returnsInt() && invoke.named(atomicIncRegex)) {\n+                if (invoke.operandNAsResultOrThrow(0) instanceof Op.Result instanceResult) {\n+                    atomicInc(buildContext, instanceResult,\n+                            ((Regex.Match)atomicIncRegex.is(invoke.name())).stringOf(1) \/\/ atomicXXInc -> atomicXX\n+                    );\n+                }\n+            } else if (invoke.isInstance() && invoke.operandNAsResultOrThrow(0) instanceof Op.Result instance) {\n+                parenWhen(\n+                        invoke.operandCount() > 1\n+                                && invoke(buildContext.lookup,instance.op()) instanceof Invoke invoke0\n+                                && invoke0.returnsClassType()\n+                        ,\n+                        \/\/ When we have patterns like:\n+                        \/\/\n+                        \/\/ myiFaceArray.array().value(storeAValue);\n+                        \/\/\n+                        \/\/ We need to generate extra parenthesis to make the struct pointer accessor \"->\" correct.\n+                        \/\/ This is a common pattern when we have a IFace type that contains a subtype based on\n+                        \/\/ struct or union.\n+                        \/\/ An example of this is for the type F16Array.\n+                        \/\/ The following expression checks that the current invokeOp has at least 2 operands:\n+                        \/\/ Why 2?\n+                        \/\/ - The first one is another invokeOp to load the inner struct from an IFace data structure.\n+                        \/\/   The first operand is also assignable.\n+                        \/\/ - The second one is the store value, but this depends on the semantics and definition\n+                        \/\/   of the user code.\n+                        _->{\n+                            when(invoke.returnsClassType(), _ -> ampersand());\n+                            recurse(buildContext, instance.op());\n+                        });\n+\n+                \/\/ Check if the varOpLoad that could follow corresponds to a local\/private type\n+                boolean isLocalOrPrivateDS = (instance.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                        && buildContext.scope.resolve(varLoadOp.operands().getFirst()) instanceof HATMemoryVarOp);\n+\n+                either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n+\n+                funcName(invoke.op());\n+\n+                if (invoke.returnsVoid()) {\/\/   setter\n+                    switch (invoke.operandCount()) {\n+                        case 2 -> {\n+                            if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n+                                equals().recurse(buildContext, op);\n+                            }\n+                        }\n+                        case 3-> {\n+                            if ( invoke.opFromOperandNAsResultOrThrow(1) instanceof Op op1\n+                                    && invoke.opFromOperandNAsResultOrThrow(2) instanceof Op op2) {\n+                                sbrace(_ -> recurse(buildContext, op1)).equals().recurse(buildContext, op2);\n+                            }\n+                        }\n+                        default -> throw new IllegalStateException(\"How \");\n+                    }\n+                } else {\n+                    if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n+                        sbrace(_ -> recurse(buildContext, op));\n+                    }else{\n+                        \/\/ this is just call.\n+                    }\n+                }\n+            }\n+        } else {\/\/ General case\n+            funcName(invoke.op()).paren(_ ->\n+                    commaSpaceSeparated(invoke.op().operands(),\n+                            op -> {if (op instanceof Op.Result result) {recurse(buildContext, result.op());}\n+                            })\n+            );\n+        }\n+        return self();\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":212,"deletions":76,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import optkl.codebuilders.CodeBuilder;\n-\n-public abstract class HATCodeBuilder<T extends HATCodeBuilder<T>> extends CodeBuilder<T> {\n-\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.codebuilders;\n+\n+import hat.dialect.*;\n+import jdk.incubator.code.Op;\n+import optkl.codebuilders.BabylonOpDispatcher;\n+import optkl.codebuilders.JavaOrC99StyleCodeBuilder;\n+import optkl.codebuilders.ScopedCodeBuilderContext;\n+\n+\/* this should not be too C99 specific but can reference HAT ops.  *\/\n+public interface HATOpDispatcher<T extends JavaOrC99StyleCodeBuilder<T>> extends BabylonOpDispatcher<T, ScopedCodeBuilderContext> {\n+\n+    T hatBarrierOp(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp);\n+\n+    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATLocalVarOp barrierOp);\n+\n+    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATPrivateVarOp hatLocalVarOp);\n+\n+    T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp hatGlobalThreadIdOp);\n+\n+    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp hatGlobalSizeOp);\n+\n+    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp hatLocalThreadIdOp);\n+\n+    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp);\n+\n+    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp);\n+\n+    T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarOp hatVectorVarOp);\n+\n+    T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorStoreView hatFloat4StoreOp);\n+\n+    T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorBinaryOp hatVectorBinaryOp);\n+\n+    T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorLoadOp hatVectorLoadOp);\n+\n+    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectLoadOp hatVSelectLoadOp);\n+\n+    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorSelectStoreOp hatVSelectStoreOp);\n+\n+    T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorVarLoadOp hatVectorVarLoadOp);\n+\n+    T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarOp hatF16VarOp);\n+\n+    T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16BinaryOp hatF16BinaryOp);\n+\n+    T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16VarLoadOp hatF16VarLoadOp);\n+\n+    T hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ConvOp hatF16ConvOp);\n+\n+    T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorOfOp hatVectorOp);\n+\n+    T hatVectorMakeOf(ScopedCodeBuilderContext buildContext, HATVectorOp.HATVectorMakeOfOp hatVectorMakeOfOp);\n+\n+    T hatF16ToFloatConvOp(ScopedCodeBuilderContext buildContext, HATF16Op.HATF16ToFloatConvOp hatF16ToFloatConvOp);\n+\n+    T hatPrivateVarInitOp(ScopedCodeBuilderContext buildContext, HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp);\n+\n+    T hatMemoryLoadOp(ScopedCodeBuilderContext buildContext, HATMemoryDefOp.HATMemoryLoadOp hatMemoryLoadOp);\n+\n+    T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLoadOp hatPtrLoadOp);\n+\n+    T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrStoreOp hatPtrStoreOp);\n+\n+    T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrOp.HATPtrLengthOp hatPtrLengthOp);\n+\n+    @Override\n+    default T recurse(ScopedCodeBuilderContext buildContext, Op op) {\n+        if (op instanceof HATOp hatOp) {\n+            switch (hatOp) {\n+                case HATBarrierOp $ -> hatBarrierOp(buildContext, $);\n+                case HATMemoryVarOp.HATLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n+                case HATMemoryVarOp.HATPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n+                case HATMemoryVarOp.HATPrivateInitVarOp $ -> hatPrivateVarInitOp(buildContext, $);\n+                case HATThreadOp.HATGlobalThreadIdOp $ -> hatGlobalThreadIdOp(buildContext, $);\n+                case HATThreadOp.HATGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n+                case HATThreadOp.HATLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n+                case HATThreadOp.HATLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n+                case HATThreadOp.HATBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n+                case HATVectorOp.HATVectorVarOp $ -> hatVectorVarOp(buildContext, $);\n+                case HATVectorOp.HATVectorStoreView $ -> hatVectorStoreOp(buildContext, $);\n+                case HATVectorOp.HATVectorBinaryOp $ -> hatBinaryVectorOp(buildContext, $);\n+                case HATVectorOp.HATVectorLoadOp $ -> hatVectorLoadOp(buildContext, $);\n+                case HATVectorOp.HATVectorSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n+                case HATVectorOp.HATVectorSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n+                case HATVectorOp.HATVectorVarLoadOp $ -> hatVectorVarLoadOp(buildContext, $);\n+                case HATVectorOp.HATVectorOfOp $ -> hatVectorOfOps(buildContext, $);\n+                case HATF16Op.HATF16VarOp $ -> hatF16VarOp(buildContext, $);\n+                case HATF16Op.HATF16BinaryOp $ -> hatF16BinaryOp(buildContext, $);\n+                case HATF16Op.HATF16VarLoadOp $ -> hatF16VarLoadOp(buildContext, $);\n+                case HATF16Op.HATF16ConvOp $ -> hatF16ConvOp(buildContext, $);\n+                case HATVectorOp.HATVectorMakeOfOp $ -> hatVectorMakeOf(buildContext, $);\n+                case HATPtrOp.HATPtrLoadOp $ -> hatPtrLoadOp(buildContext, $);\n+                case HATPtrOp.HATPtrStoreOp $ -> hatPtrStoreOp(buildContext, $);\n+                case HATPtrOp.HATPtrLengthOp $ -> hatPtrLengthOp(buildContext, $);\n+                case HATF16Op.HATF16ToFloatConvOp $ -> hatF16ToFloatConvOp(buildContext, $);\n+                case HATMemoryDefOp.HATMemoryLoadOp $ -> hatMemoryLoadOp(buildContext, $);\n+                default -> throw new IllegalStateException(\"handle nesting of hat op \" + op);\n+            }\n+        }else{\n+            BabylonOpDispatcher.super.recurse(buildContext, op);\n+        }\n+\n+        return (T) this;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATOpDispatcher.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.codebuilders;\n-\n-import hat.KernelContext;\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import optkl.FieldAccess;\n-import optkl.OpTkl;\n-import optkl.codebuilders.BabylonCoreOpBuilder;\n-import optkl.codebuilders.ScopedCodeBuilderContext;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import static optkl.FieldAccess.fieldAccessOpHelper;\n-\n-public class JavaHATCodeBuilder<T extends JavaHATCodeBuilder<T>> extends C99HATCodeBuilderContext<T> implements BabylonCoreOpBuilder<T,ScopedCodeBuilderContext> {\n-\n-\n-    @Override\n-    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n-        return typeName(javaType.toString());\n-    }\n-\n-    @Override\n-    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldLoadOp);\n-        if ( fieldAccess.refType(KernelContext.class)) {\n-            identifier(\"kc\").dot().fieldName(fieldLoadOp);\n-        } else if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) { \/\/ only primitve fields\n-            var value = fieldAccess.getStaticFinalPrimitiveValue();\n-            literal(value.toString());\n-        } else {\n-            throw new IllegalStateException(\"An instance field? I guess - we dont get those in HAT \" +fieldLoadOp);\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n-        return null;\n-    }\n-\n-    @Override\n-     public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n-        if (invokeOp.invokeKind()== JavaOp.InvokeOp.InvokeKind.STATIC) {\n-            identifier(invokeOp.invokeDescriptor().refType().toString());\n-     \/\/   }else if (!invokeOp.operands().isEmpty() && invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n-       \/\/     recurse(buildContext, instanceResult.op());\n-        }else{\n-            throw new IllegalStateException(\"Unexpected invokeOp ... in code builder\");\n-        }\n-        dot().identifier(invokeOp.invokeDescriptor().name());\n-        paren(_ ->\n-                \/\/ why did we have a sublist before? is this static vs instance?\n-            commaSpaceSeparated(  invokeOp.operands()\/*.subList(0,invokeOp.operands().size()-1)*\/, o-> {\n-                if (o instanceof Op.Result result) {\n-                    recurse(buildContext, result.op());\n-                } else if (o instanceof Block.Parameter parameter) {\n-                    identifier(\"param$\"+parameter.index());\n-                }else {\n-                    throw new IllegalStateException(\"What have we here \");\n-                }\n-            })\n-        );\n-        return self();\n-    }\n-\n-    public T createJava(ScopedCodeBuilderContext buildContext) {\n-        buildContext.funcScope(buildContext.funcOp, () -> {\n-            typeName(buildContext.funcOp.resultType().toString()).space().funcName(buildContext.funcOp);\n-            parenNlIndented(_ ->\n-                    commaNlSeparated(\n-                            buildContext.paramTable.list(),\n-                            param -> declareParam(buildContext, param)\n-                    )\n-            );\n-            braceNlIndented(_ -> nlSeparated(\n-                    OpTkl.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n-                    statement -> statement(buildContext, statement)\n-                    )\n-            );\n-        });\n-        return nl();\n-    }\n-    private final ScopedCodeBuilderContext scopedCodeBuilderContext;\n-    public JavaHATCodeBuilder(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp){\n-        super();\n-        scopedCodeBuilderContext= new ScopedCodeBuilderContext(lookup,funcOp);\n-    }\n-\n-    public String toText() {\n-        return createJava(scopedCodeBuilderContext).getText();\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/JavaHATCodeBuilder.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.codebuilders.C99HATCodeBuilder;\n+import optkl.codebuilders.C99CodeBuilder;\n@@ -45,1 +45,1 @@\n-    private final C99HATCodeBuilder<?> representationBuilder = new C99HATCodeBuilder<>();\n+    private final C99CodeBuilder<?> representationBuilder = new C99CodeBuilder<>();\n@@ -107,4 +107,2 @@\n-    private void materialize(C99HATCodeBuilder<?> builder, Class<?> klass) {\n-        try {\n-            Class<?> aClass = Class.forName(klass.getName());\n-            Method[] declaredMethods = aClass.getDeclaredMethods();\n+    private void materialize(C99CodeBuilder<?> builder, Class<?> klass) {\n+            Method[] declaredMethods = klass.getDeclaredMethods();\n@@ -126,1 +124,1 @@\n-                            C99HATCodeBuilder<?> depsBuilder = new C99HATCodeBuilder<>();\n+                            C99CodeBuilder<?> depsBuilder = new C99CodeBuilder<>();\n@@ -162,4 +160,0 @@\n-\n-        } catch (ClassNotFoundException e) {\n-            IO.println(\"Error during materialization of DeviceType: \" + e.getMessage());\n-        }\n","filename":"hat\/core\/src\/main\/java\/hat\/device\/DeviceSchema.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.dialect.java.ClassType;\n@@ -33,0 +34,1 @@\n+import optkl.OpHelper;\n@@ -34,0 +36,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -45,1 +48,1 @@\n-    public static VectorMetaData getVectorTypeInfo(JavaOp.InvokeOp invokeOp, int param) {\n+    public static VectorMetaData getVectorTypeInfo(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, int param) {\n@@ -48,1 +51,1 @@\n-            return getVectorTypeInfoWithCodeReflection(varLoadOp.resultType());\n+            return getVectorTypeInfoWithCodeReflection(lookup,varLoadOp.resultType());\n@@ -53,2 +56,2 @@\n-    public static VectorMetaData getVectorTypeInfo(JavaOp.InvokeOp invokeOp) {\n-        return getVectorTypeInfoWithCodeReflection(invokeOp.resultType());\n+    public static VectorMetaData getVectorTypeInfo(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp) {\n+        return getVectorTypeInfoWithCodeReflection(lookup,invokeOp.resultType());\n@@ -80,9 +83,3 @@\n-    public static VectorMetaData getVectorTypeInfoWithCodeReflection(TypeElement typeElement) {\n-        Class<?> aClass;\n-        try {\n-            aClass = Class.forName(typeElement.toString());\n-        } catch (ClassNotFoundException e) {\n-            \/\/ TODO: Add control for exceptions in HAT (HATExceptions Handler)\n-            throw new RuntimeException(e);\n-        }\n-        CoreOp.FuncOp codeModelType = buildCodeModelFor(aClass, \"type\");\n+    public static VectorMetaData getVectorTypeInfoWithCodeReflection(MethodHandles.Lookup lookup,TypeElement typeElement) {\n+        Class<?> clazz = (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup, (ClassType) typeElement);\n+        CoreOp.FuncOp codeModelType = buildCodeModelFor(clazz, \"type\");\n@@ -101,1 +98,1 @@\n-        CoreOp.FuncOp codeModelWidth = buildCodeModelFor(aClass, \"width\");\n+        CoreOp.FuncOp codeModelWidth = buildCodeModelFor(clazz, \"width\");\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPhaseUtils.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -329,2 +330,0 @@\n-\n-      \/\/  private final TypeElement elementType;\n@@ -334,3 +333,2 @@\n-        public HATVectorSelectStoreOp(String varName, TypeElement resultType, int lane, CoreOp.VarOp resultVarOp, List<Value> operands) {\n-            super(varName, resultType, resultType, -1, operands);\n-          \/\/  this.elementType = typeElement;\n+        public HATVectorSelectStoreOp(String varName,  int lane, CoreOp.VarOp resultVarOp, List<Value> operands) {\n+            super(varName, JavaType.VOID, JavaType.VOID, -1, operands);\n@@ -343,1 +341,0 @@\n-         \/\/   this.elementType = that.elementType;\n@@ -352,6 +349,0 @@\n-\n-      \/\/  @Override\n-        \/\/public TypeElement resultType() {\n-          \/\/  return elementType;\n-       \/\/ }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorOp.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,142 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import hat.types._V;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.OpTkl;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.function.Predicate;\n-\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.isAssignable;\n-\n-\/**\n- * This class needs refactoring\n- *\n- * It seems to be a reimplementation of Optkl isAssignable\n- *\/\n-public class RefactorMe {\n-    private static void inspectNewLevel(Class<?> interfaceClass, Set<Class<?>> interfaceSet) {\n-        if (interfaceClass != null && interfaceSet.add(interfaceClass)) {\n-            \/\/ only if we add a new interface class, we inspect all interfaces that extends the current inspected class\n-            Arrays.stream(interfaceClass.getInterfaces())\n-                    .forEach(superInterface -> inspectNewLevel(superInterface, interfaceSet));\n-        }\n-    }\n-\n-\n-    public static Set<Class<?>> inspectAllInterfaces(Class<?> klass) {\n-        Set<Class<?>> interfaceSet = new HashSet<>();\n-        while (klass != null) {\n-            Arrays.stream(klass.getInterfaces())\n-                    .forEach(interfaceClass -> RefactorMe.inspectNewLevel(interfaceClass, interfaceSet));\n-            klass = klass.getSuperclass();\n-        }\n-        return interfaceSet;\n-    }\n-\n-\n-    public  static boolean  isVectorOperation(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n-        if (OpTkl.asResultOrNull(varValue) instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            TypeElement typeElement = varLoadOp.resultType();\n-            Set<Class<?>> interfaces = Set.of();\n-            try {\n-                Class<?> aClass = Class.forName(typeElement.toString());\n-                interfaces = inspectAllInterfaces(aClass);\n-            } catch (ClassNotFoundException _) {\n-            }\n-            return interfaces.contains(_V.class) && invokeOpHelper(lookup, invokeOp).named( namePredicate);\n-        }\n-        return false;\n-    }\n-    public static boolean isAMethod(JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n-        return namePredicate.test(invokeOp.invokeDescriptor().name());\n-    }\n-    public  static boolean  isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n-        if (OpTkl.asResultOrNull(varValue) instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            TypeElement typeElement = varLoadOp.resultType();\n-            Set<Class<?>> interfaces = Set.of();\n-            try {\n-                Class<?> aClass = Class.forName(typeElement.toString());\n-                interfaces = inspectAllInterfaces(aClass);\n-            } catch (ClassNotFoundException _) {\n-            }\n-            return interfaces.contains(_V.class) && isAMethod(invokeOp, namePredicate);\n-        }\n-        return false;\n-    }\n-    public static boolean isInvokeDescriptorSubtypeOf(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Class<?> klass) {\n-\n-        var wouldReturn = (invokeOp.resultType() instanceof JavaType jt && isAssignable(lookup, jt, klass));\n-\n-        TypeElement typeElement = invokeOp.invokeDescriptor().refType();\n-        Set<Class<?>> interfaces = Set.of();\n-        try {\n-            Class<?> aClass = Class.forName(typeElement.toString());\n-            interfaces = inspectAllInterfaces(aClass);\n-        } catch (ClassNotFoundException _) {\n-        }\n-        var butReturns = interfaces.contains(klass);\n-        if (butReturns != wouldReturn) {\n-            \/\/ System.out.print(\"isInvokeDescriptorSubtypeOf\");\n-        }\n-        return butReturns;\n-\n-    }\n-\n-    public static boolean isInvokeDescriptorSubtypeOfAnyMatch(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Class<?>... klasses) {\n-\n-        boolean wouldReturn = (invokeOp.resultType() instanceof JavaType jt && isAssignable(lookup, jt, klasses));\n-        boolean butReturns = false;\n-        TypeElement typeElement = invokeOp.invokeDescriptor().refType();\n-        Set<Class<?>> interfaces = Set.of();\n-        try {\n-            Class<?> aClass = Class.forName(typeElement.toString());\n-            interfaces = inspectAllInterfaces(aClass);\n-        } catch (ClassNotFoundException _) {\n-        }\n-        for (Class<?> klass : klasses) {\n-            if (interfaces.contains(klass)) {\n-                butReturns = true;\n-            }\n-        }\n-        if (butReturns != wouldReturn) {\n-            \/\/   System.out.print(\"isInvokeDescriptorSubtypeOfAnyMatch\");\n-        }\n-        return butReturns;\n-    }\n-\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/RefactorMe.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"},{"patch":"@@ -30,1 +30,2 @@\n-import optkl.util.CallSite;\n+import optkl.OpHelper;\n+import optkl.Trxfmr;\n@@ -42,4 +43,3 @@\n-\n-import static optkl.OpTkl.classTypeToTypeOrThrow;\n-import static optkl.OpTkl.elements;\n-import static optkl.OpTkl.isAssignable;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.copyLocation;\n@@ -49,4 +49,0 @@\n-    @Override\n-    public CoreOp.FuncOp apply(CoreOp.FuncOp entry) {\n-\n-        if (!isArrayView(entry)) return entry;\n@@ -54,2 +50,7 @@\n-        Map<Op.Result, Op.Result> replaced = new HashMap<>(); \/\/ maps a result to the result it should be replaced by\n-        Map<Op, CoreOp.VarAccessOp.VarLoadOp> bufferVarLoads = new HashMap<>();\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        if (Invoke.stream(lookup(), funcOp).anyMatch(invoke ->\n+                            invoke.returnsArray()\n+                        && invoke.refIs(MappableIface.class,DeviceType.class))) {\n+            Map<Op.Result, Op.Result> replaced = new HashMap<>(); \/\/ maps a result to the result it should be replaced by\n+            Map<Op, CoreOp.VarAccessOp.VarLoadOp> bufferVarLoads = new HashMap<>();\n@@ -57,22 +58,24 @@\n-        return entry.transform(entry.funcName(), (bb, op) -> {\n-            switch (op) {\n-                case JavaOp.InvokeOp invokeOp -> {\n-                    if (isVectorBinaryOperation(invokeOp)) {\n-                        \/\/ catching HATVectorBinaryOps not stored in VarOps\n-                        HATVectorOp.HATVectorBinaryOp vBinaryOp = buildVectorBinaryOp(\n-                                invokeOp.invokeDescriptor().name(),\n-                                obtainVarNameFromInvoke(invokeOp),\n-                                invokeOp.resultType(),\n-                                bb.context().getValues(invokeOp.operands())\n-                        );\n-                        vBinaryOp.setLocation(invokeOp.location());\n-                        Op.Result res = bb.op(vBinaryOp);\n-                        bb.context().mapValue(invokeOp.result(), res);\n-                        replaced.put(invokeOp.result(), res);\n-                        return bb;\n-                    } else if (isBufferArray(invokeOp) &&\n-                            firstOperand(invokeOp) instanceof Op.Result r) { \/\/ ensures we can use iop as key for replaced vvv\n-                        replaced.put(invokeOp.result(), r);\n-                        \/\/ map buffer VarOp to its corresponding VarLoadOp\n-                        bufferVarLoads.put((firstOperandAsRes(r.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) r.op());\n-                        return bb;\n+            return Trxfmr.of(this,funcOp).transform( (blockBuilder, op) -> {\n+                var context = blockBuilder.context();\n+                switch (op) {\n+                    case JavaOp.InvokeOp $ when invoke(lookup(), $) instanceof Invoke invoke -> {\n+                        if (isHatVectorBinaryOperation(invoke)) {\n+                            \/\/ catching HATVectorBinaryOps not stored in VarOps\n+                            var hatVectorBinaryOp = invoke.copyLocationTo(buildVectorBinaryOp(\n+                                    invoke.name(),\n+                                    varNameFromInvokeFirstUse(invoke),\n+                                    invoke.returnType(),\n+                                    blockBuilder.context().getValues(invoke.op().operands())\n+                            ));\n+                            Op.Result binaryResult = blockBuilder.op(hatVectorBinaryOp);\n+                           context.mapValue(invoke.returnResult(), binaryResult);\n+                            replaced.put(invoke.returnResult(), binaryResult);\n+                            return blockBuilder;\n+                        } else if (isBufferArray(invoke.op()) && invoke.firstOperandAsResultOrNull() instanceof Op.Result result) { \/\/ ensures we can use iop as key for replaced vvv\n+                            replaced.put(invoke.returnResult(), result);\n+                            \/\/ map buffer VarOp to its corresponding VarLoadOp\n+                            bufferVarLoads.put((firstOperandAsResultOrNull(result.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) result.op());\n+                            return blockBuilder;\n+                        } else{\n+                            \/\/ or else\n+                        }\n@@ -80,21 +83,20 @@\n-                }\n-                case CoreOp.VarOp varOp -> {\n-                    if (isBufferInitialize(varOp) &&\n-                            firstOperand(varOp) instanceof Op.Result r) { \/\/ makes sure we don't process a new int[] for example\n-                        Op bufferLoad = replaced.get(r).op(); \/\/ gets VarLoadOp associated w\/ og buffer\n-                        replaced.put(varOp.result(), firstOperandAsRes(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n-                        return bb;\n-                    } else if (isVectorOp(varOp)) {\n-                        List<Value> operands = (varOp.operands().isEmpty()) ? List.of() : List.of(firstOperand(varOp));\n-                        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(varOp.resultType().valueType());\n-                        HATVectorOp.HATVectorVarOp vVarOp = new HATVectorOp.HATVectorVarOp(\n-                                varOp.varName(),\n-                                varOp.resultType(),\n-                                md.vectorTypeElement(),\n-                                md.lanes(),\n-                                bb.context().getValues(operands)\n-                        );\n-                        vVarOp.setLocation(varOp.location());\n-                        Op.Result res = bb.op(vVarOp);\n-                        bb.context().mapValue(varOp.result(), res);\n-                        return bb;\n+                    case CoreOp.VarOp varOp -> {\n+                        if (isBufferInitialize(varOp) && firstOperand(varOp) instanceof Op.Result result) { \/\/ makes sure we don't process a new int[] for example\n+                            Op bufferLoad = replaced.get(result).op(); \/\/ gets VarLoadOp associated w\/ og buffer\n+                            replaced.put(varOp.result(), firstOperandAsResultOrNull(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n+                            return blockBuilder;\n+                        } else if (isVectorOp(varOp)) {\n+                            List<Value> operands = (varOp.operands().isEmpty()) ? List.of() : List.of(firstOperand(varOp));\n+                            var vectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),varOp.resultType().valueType());\n+                            var hatVectorVarOp = copyLocation(varOp,new HATVectorOp.HATVectorVarOp(\n+                                    varOp.varName(),\n+                                    varOp.resultType(),\n+                                    vectorMetaData.vectorTypeElement(),\n+                                    vectorMetaData.lanes(),\n+                                   context.getValues(operands)\n+                            ));\n+                            context.mapValue(varOp.result(), blockBuilder.op(hatVectorVarOp));\n+                            return blockBuilder;\n+                        }else{\n+                            \/\/ or else\n+                        }\n@@ -102,16 +104,18 @@\n-                }\n-                case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> {\n-                    if ((isBufferInitialize(varLoadOp)) &&\n-                            firstOperand(varLoadOp) instanceof Op.Result r) {\n-                        if (r.op() instanceof CoreOp.VarOp) { \/\/ if this is the VarLoadOp after the .arrayView() InvokeOp\n-                            Op.Result replacement = (notGlobalVarOp(varLoadOp)) ?\n-                                    firstOperandAsRes((firstOperandAsRes(r.op())).op()) :\n-                                    bufferVarLoads.get(replaced.get(r).op()).result();\n-                            replaced.put(varLoadOp.result(), replacement);\n-                        } else { \/\/ if this is a VarLoadOp loading the buffer\n-                            Value loaded = getValue(bb, replaced.get(r));\n-                            CoreOp.VarAccessOp.VarLoadOp newVarLoad = CoreOp.VarAccessOp.varLoad(loaded);\n-                            newVarLoad.setLocation(varLoadOp.location());\n-                            Op.Result res = bb.op(newVarLoad);\n-                            bb.context().mapValue(varLoadOp.result(), res);\n-                            replaced.put(varLoadOp.result(), res);\n+                    case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> {\n+                        if ((isBufferInitialize(varLoadOp)) && firstOperand(varLoadOp) instanceof Op.Result r) {\n+                            if (r.op() instanceof CoreOp.VarOp) { \/\/ if this is the VarLoadOp after the .arrayView() InvokeOp\n+                                Op.Result replacement = (notGlobalVarOp(varLoadOp)) ?\n+                                        firstOperandAsResultOrNull((firstOperandAsResultOrNull(r.op())).op()) :\n+                                        bufferVarLoads.get(replaced.get(r).op()).result();\n+                                replaced.put(varLoadOp.result(), replacement);\n+                            } else { \/\/ if this is a VarLoadOp loading the buffer\n+                                \/\/ is this not just bb.op(varLoadOp)?\n+                                CoreOp.VarAccessOp.VarLoadOp newVarLoad = copyLocation(varLoadOp,\n+                                        CoreOp.VarAccessOp.varLoad(getValue(blockBuilder, replaced.get(r))));\n+                                Op.Result res = blockBuilder.op(newVarLoad);\n+                                context.mapValue(varLoadOp.result(), res);\n+                                replaced.put(varLoadOp.result(), res);\n+                            }\n+                            return blockBuilder;\n+                        }else{\n+                            \/\/ or else\n@@ -119,1 +123,0 @@\n-                        return bb;\n@@ -121,38 +124,34 @@\n-                }\n-                case JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp -> {\n-                    if (isBufferArray(arrayLoadOp) &&\n-                            firstOperand(arrayLoadOp) instanceof Op.Result r) {\n-                        Op.Result buffer = replaced.getOrDefault(r, r);\n-                        if (isVectorOp(arrayLoadOp)) {\n-                            Op vop = (firstOperandAsRes(buffer.op())).op();\n-                            String name = switch (vop) {\n-                                case CoreOp.VarOp varOp -> varOp.varName();\n-                                case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n-                                case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n-                                default -> throw new IllegalStateException(\"Unexpected value: \" + vop);\n-                            };\n-                            HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(arrayLoadOp.resultType());\n-                            HATVectorOp.HATVectorLoadOp vLoadOp = new HATVectorOp.HATVectorLoadOp(\n-                                    name,\n-                                    CoreType.varType(((ArrayType) firstOperand(arrayLoadOp).type()).componentType()),\n-                                    md.vectorTypeElement(),\n-                                    md.lanes(),\n-                                    notGlobalVarOp(arrayLoadOp),\n-                                    bb.context().getValues(List.of(buffer, arrayLoadOp.operands().getLast()))\n-                            );\n-                            vLoadOp.setLocation(arrayLoadOp.location());\n-                            Op.Result res = bb.op(vLoadOp);\n-                            bb.context().mapValue(arrayLoadOp.result(), res);\n-                        } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n-                            ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n-                            List<Value> operands = new ArrayList<>();\n-                            operands.add(info.buffer);\n-                            operands.addAll(info.indices);\n-                            HATPtrOp.HATPtrLoadOp ptrLoadOp = new HATPtrOp.HATPtrLoadOp(\n-                                    arrayLoadOp.resultType(),\n-                                    (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) info.buffer().type()),\n-                                    bb.context().getValues(operands)\n-                            );\n-                            ptrLoadOp.setLocation(arrayLoadOp.location());\n-                            Op.Result res = bb.op(ptrLoadOp);\n-                            bb.context().mapValue(arrayLoadOp.result(), res);\n+                    case JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp -> {\n+                        if (isBufferArray(arrayLoadOp) && firstOperand(arrayLoadOp) instanceof Op.Result r) {\n+                            Op.Result buffer = replaced.getOrDefault(r, r);\n+                            if (isVectorOp(arrayLoadOp)) {\n+                                Op vop = (firstOperandAsResultOrNull(buffer.op())).op();\n+                                String name = switch (vop) {\n+                                    case CoreOp.VarOp varOp -> varOp.varName();\n+                                    case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n+                                    case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n+                                    default -> throw new IllegalStateException(\"Unexpected value: \" + vop);\n+                                };\n+                                var  hatVectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),arrayLoadOp.resultType());\n+                                HATVectorOp.HATVectorLoadOp vLoadOp = copyLocation(arrayLoadOp,new HATVectorOp.HATVectorLoadOp(\n+                                        name,\n+                                        CoreType.varType(((ArrayType) firstOperand(arrayLoadOp).type()).componentType()),\n+                                        hatVectorMetaData.vectorTypeElement(),\n+                                        hatVectorMetaData.lanes(),\n+                                        notGlobalVarOp(arrayLoadOp),\n+                                        context.getValues(List.of(buffer, arrayLoadOp.operands().getLast()))\n+                                ));\n+                                context.mapValue(arrayLoadOp.result(), blockBuilder.op(vLoadOp));\n+                            } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                                var arrayAccessInfo = arrayAccessInfo(op.result(), replaced);\n+                                var operands = arrayAccessInfo.bufferAndIndicesAsValues();\n+\n+                                var hatPtrLoadOp = copyLocation(arrayLoadOp,new HATPtrOp.HATPtrLoadOp(\n+                                        arrayLoadOp.resultType(),\n+                                        (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n+                                        context.getValues(operands)\n+                                ));\n+                                context.mapValue(arrayLoadOp.result(), blockBuilder.op(hatPtrLoadOp));\n+                            }\n+                        } else {\n+                            \/\/ or else?\n@@ -160,0 +159,1 @@\n+                        return blockBuilder;\n@@ -161,37 +161,37 @@\n-                    return bb;\n-                }\n-                case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n-                    if (isBufferArray(arrayStoreOp) &&\n-                            firstOperand(arrayStoreOp) instanceof Op.Result r) {\n-                        Op.Result buffer = replaced.getOrDefault(r, r);\n-                        if (isVectorOp(arrayStoreOp)) {\n-                            Op varOp = findVarOpOrHATVarOP(((Op.Result) arrayStoreOp.operands().getLast()).op());\n-                            String name = (varOp instanceof HATVectorOp.HATVectorVarOp) ? ((HATVectorOp.HATVectorVarOp) varOp).varName() : ((CoreOp.VarOp) varOp).varName();\n-                            TypeElement resultType = (varOp instanceof HATVectorOp.HATVectorVarOp) ? (varOp).resultType() : ((CoreOp.VarOp) varOp).resultType();\n-                            ClassType classType = ((ClassType) ((ArrayType) firstOperand(arrayStoreOp).type()).componentType());\n-                            HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(classType);\n-                            HATVectorOp.HATVectorStoreView vStoreOp = new HATVectorOp.HATVectorStoreView(\n-                                    name,\n-                                    resultType,\n-                                    md.lanes(),\n-                                    md.vectorTypeElement(),\n-                                    notGlobalVarOp(arrayStoreOp),\n-                                    bb.context().getValues(List.of(buffer, arrayStoreOp.operands().getLast(), arrayStoreOp.operands().get(1)))\n-                            );\n-                            vStoreOp.setLocation(arrayStoreOp.location());\n-                            Op.Result res = bb.op(vStoreOp);\n-                            bb.context().mapValue(arrayStoreOp.result(), res);\n-                        } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n-                            ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n-                            List<Value> operands = new ArrayList<>();\n-                            operands.add(info.buffer());\n-                            operands.addAll(info.indices);\n-                            operands.add(arrayStoreOp.operands().getLast());\n-                            HATPtrOp.HATPtrStoreOp ptrLoadOp = new HATPtrOp.HATPtrStoreOp(\n-                                    arrayStoreOp.resultType(),\n-                                    (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) info.buffer().type()),\n-                                    bb.context().getValues(operands)\n-                            );\n-                            ptrLoadOp.setLocation(arrayStoreOp.location());\n-                            Op.Result res = bb.op(ptrLoadOp);\n-                            bb.context().mapValue(arrayStoreOp.result(), res);\n+                    case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n+                        if (isBufferArray(arrayStoreOp) && firstOperand(arrayStoreOp) instanceof Op.Result r) {\n+                            Op.Result buffer = replaced.getOrDefault(r, r);\n+                            if (isVectorOp(arrayStoreOp)) {\n+                                Op varOp = findVarOpOrHATVarOP(((Op.Result) arrayStoreOp.operands().getLast()).op());\n+                                var name = (varOp instanceof HATVectorOp.HATVectorVarOp)\n+                                        ? ((HATVectorOp.HATVectorVarOp) varOp).varName()\n+                                        : ((CoreOp.VarOp) varOp).varName();\n+                                var resultType = (varOp instanceof HATVectorOp.HATVectorVarOp)\n+                                        ? (varOp).resultType()\n+                                        : ((CoreOp.VarOp) varOp).resultType();\n+                                var classType = ((ClassType) ((ArrayType) firstOperand(arrayStoreOp).type()).componentType());\n+                                var vectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),classType);\n+                                HATVectorOp.HATVectorStoreView vStoreOp = copyLocation(arrayStoreOp,new HATVectorOp.HATVectorStoreView(\n+                                        name,\n+                                        resultType,\n+                                        vectorMetaData.lanes(),\n+                                        vectorMetaData.vectorTypeElement(),\n+                                        notGlobalVarOp(arrayStoreOp),\n+                                        context.getValues(List.of(buffer, arrayStoreOp.operands().getLast(), arrayStoreOp.operands().get(1)))\n+                                ));\n+                                context.mapValue(arrayStoreOp.result(), blockBuilder.op(vStoreOp));\n+                            } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                                var arrayAccessInfo = arrayAccessInfo(op.result(), replaced);\n+                                var operands = arrayAccessInfo.bufferAndIndicesAsValues();\n+                                operands.add(arrayStoreOp.operands().getLast());\n+                                HATPtrOp.HATPtrStoreOp ptrLoadOp = copyLocation(arrayStoreOp,new HATPtrOp.HATPtrStoreOp(\n+                                        arrayStoreOp.resultType(),\n+                                        (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n+                                        context.getValues(operands)\n+                                ));\n+                                context.mapValue(arrayStoreOp.result(), blockBuilder.op(ptrLoadOp));\n+                            }else{\n+                                \/\/ or else\n+                            }\n+                        }else{\n+                            \/\/ or else?\n@@ -199,0 +199,1 @@\n+                        return blockBuilder;\n@@ -200,15 +201,15 @@\n-                    return bb;\n-                }\n-                case JavaOp.ArrayLengthOp arrayLengthOp -> {\n-                    if (isBufferArray(arrayLengthOp) &&\n-                            firstOperand(arrayLengthOp) instanceof Op.Result r) {\n-                        ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n-                        HATPtrOp.HATPtrLengthOp ptrLengthOp = new HATPtrOp.HATPtrLengthOp(\n-                                arrayLengthOp.resultType(),\n-                                (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) info.buffer().type()),\n-                                bb.context().getValues(List.of(info.buffer()))\n-                        );\n-                        ptrLengthOp.setLocation(arrayLengthOp.location());\n-                        Op.Result res = bb.op(ptrLengthOp);\n-                        bb.context().mapValue(arrayLengthOp.result(), res);\n-                        return bb;\n+                    case JavaOp.ArrayLengthOp arrayLengthOp -> {\n+                        if (isBufferArray(arrayLengthOp) && firstOperand(arrayLengthOp) instanceof Op.Result) {\n+                            var arrayAccessInfo = arrayAccessInfo(op.result(), replaced);\n+                            var hatPtrLengthOp = copyLocation(arrayLengthOp,new HATPtrOp.HATPtrLengthOp(\n+                                    arrayLengthOp.resultType(),\n+                                    (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n+                                    context.getValues(List.of(arrayAccessInfo.buffer()))\n+                            ));\n+                            context.mapValue(arrayLengthOp.result(), blockBuilder.op(hatPtrLengthOp));\n+                            return blockBuilder;\n+                        }else{\n+                            \/\/ or else\n+                        }\n+                    }\n+                    default -> {\n@@ -217,6 +218,6 @@\n-                default -> {\n-                }\n-            }\n-            bb.op(op);\n-            return bb;\n-        });\n+                blockBuilder.op(op);\n+                return blockBuilder;\n+            }).funcOp();\n+        }else {\n+            return funcOp;\n+        }\n@@ -225,1 +226,7 @@\n-    record ArrayAccessInfo(Op.Result buffer, List<Op.Result> indices) {};\n+    record ArrayAccessInfo(Op.Result buffer, List<Op.Result> indices) {\n+        public List<Value> bufferAndIndicesAsValues() {\n+            List<Value> operands = new ArrayList<>(List.of(buffer));\n+            operands.addAll(indices);\n+            return operands;\n+        }\n+    };\n@@ -229,2 +236,2 @@\n-            List<Node<T>> wl = new ArrayList<>();\n-            Set<Node<T>> seen = new HashSet<>();\n+            List<Node<T>> nodeList = new ArrayList<>(List.of(this));\n+            Set<Node<T>> handled = new HashSet<>();\n@@ -233,6 +240,5 @@\n-            wl.add(this);\n-            while (!wl.isEmpty()) {\n-                Node<T> cur = wl.removeFirst();\n-                seen.add(cur);\n-                if (cur.value instanceof Op.Result res) {\n-                    if (res.op() instanceof JavaOp.ArrayAccessOp || res.op() instanceof JavaOp.ArrayLengthOp) {\n+            while (!nodeList.isEmpty()) {\n+                Node<T> node = nodeList.removeFirst();\n+                handled.add(node);\n+                if (node.value instanceof Op.Result res &&\n+                        (res.op() instanceof JavaOp.ArrayAccessOp || res.op() instanceof JavaOp.ArrayLengthOp)) {\n@@ -241,1 +247,1 @@\n-                    }\n+\n@@ -243,3 +249,6 @@\n-                if (!cur.edges().isEmpty()) {\n-                    Node<T> next = cur.edges().getFirst();\n-                    if (!seen.contains(next)) wl.add(next);\n+                \/\/ I think we need to comment this.  Not so obvious.\n+                if (!node.edges().isEmpty()) {\n+                    Node<T> next = node.edges().getFirst();\n+                    if (!handled.contains(next)) {\n+                        nodeList.add(next);\n+                    }\n@@ -269,0 +278,2 @@\n+\n+        \/\/ looks like\n@@ -270,1 +281,5 @@\n-            if (operand instanceof Op.Result res && res.op() instanceof JavaOp.InvokeOp iop && iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\")) continue;\n+            if (operand instanceof Op.Result res &&\n+                    res.op() instanceof JavaOp.InvokeOp iop\n+                    && iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\")){\n+                continue;\n+            }\n@@ -283,1 +298,1 @@\n-        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(resultType);\n+        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),resultType);\n@@ -293,8 +308,5 @@\n-    private boolean isVectorBinaryOperation(JavaOp.InvokeOp invokeOp) {\n-        TypeElement typeElement = invokeOp.resultType();\n-        boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\n-        return isHatVectorType\n-                && (invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"add\")\n-                || invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"sub\")\n-                || invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"mul\")\n-                || invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"div\"));\n+    private boolean isHatVectorBinaryOperation(Invoke invoke) {\n+        \/\/ no! lets not compare strings what if we refactor the class names?  This is brittle\n+        return invoke.returnType().toString().startsWith(\"hat.buffer.Float\")\n+                   && invoke.name().toLowerCase() instanceof String name\n+                   &&(name.equals(\"add\")|| name.equals(\"sub\")||name.equals(\"mul\")||name.equals(\"div\"));\n@@ -304,1 +316,1 @@\n-        return searchForOp(op, Set.of(CoreOp.VarOp.class, HATVectorOp.HATVectorVarOp.class));\n+        return searchForOpOrNull(op, CoreOp.VarOp.class, HATVectorOp.HATVectorVarOp.class);\n@@ -308,9 +320,12 @@\n-        if (op.operands().isEmpty()) return false;\n-        TypeElement type = firstOperand(op).type();\n-        if (type instanceof ArrayType at) type = at.componentType();\n-        if (type instanceof ClassType ct) {\n-            try {\n-                return _V.class.isAssignableFrom((Class<?>) ct.resolve(lookup()));\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n+        if (!op.operands().isEmpty()) {\n+           TypeElement type = firstOperand(op).type();\n+           if (type instanceof ArrayType at) {\n+               type = at.componentType();\n+           }\n+           if (type instanceof ClassType ct) {\n+               try {\n+                   return _V.class.isAssignableFrom((Class<?>) ct.resolve(lookup()));\n+               } catch (ReflectiveOperationException e) {\n+                   throw new RuntimeException(e);\n+              }\n+           }\n@@ -321,2 +336,2 @@\n-    public static Op.Result firstOperandAsRes(Op op) {\n-        return (firstOperand(op) instanceof Op.Result res) ? res : null;\n+    public static Op.Result firstOperandAsResultOrNull(Op op) {\n+        return (firstOperand(op) instanceof Op.Result result) ? result : null;\n@@ -334,1 +349,1 @@\n-        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOp(op, Set.of(JavaOp.InvokeOp.class));\n+        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOpOrNull(op, JavaOp.InvokeOp.class);\n@@ -339,1 +354,1 @@\n-        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOp(op, Set.of(JavaOp.InvokeOp.class));\n+        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOpOrNull(op, JavaOp.InvokeOp.class);\n@@ -345,4 +360,5 @@\n-    public Op searchForOp(Op op, Set<Class<?>> opClasses) {\n-        while (!(opClasses.contains(op.getClass()))) {\n-            if (!op.operands().isEmpty() && firstOperand(op) instanceof Op.Result r) {\n-                op = r.op();\n+    public Op searchForOpOrNull(Op op, Class<?> ...classes) {\n+        Set<Class<?>> set =Set.of(classes);\n+        while (!(set.contains(op.getClass()))) {\n+            if (!op.operands().isEmpty() && firstOperand(op) instanceof Op.Result result) {\n+                op = result.op();\n@@ -359,1 +375,3 @@\n-            if (!(vop.varValueType() instanceof ArrayType)) return false;\n+            if (!(vop.varValueType() instanceof ArrayType)){\n+                return false;\n+            }\n@@ -361,36 +379,2 @@\n-            if (!(op.resultType() instanceof ArrayType)) return false;\n-        }\n-\n-        return isBufferArray(op);\n-    }\n-\n-    public boolean isArrayView(CoreOp.FuncOp entry) {\n-        var here = CallSite.of(HATArrayViewPhase.class, \"isArrayView\");\n-        return elements(here, entry).anyMatch((element) -> (\n-                element instanceof JavaOp.InvokeOp iop &&\n-                        iop.resultType() instanceof ArrayType &&\n-                        iop.invokeDescriptor().refType() instanceof JavaType javaType &&\n-                        (isAssignable(lookup(), javaType, MappableIface.class)\n-                                || isAssignable(lookup(), javaType, DeviceType.class))));\n-    }\n-\n-    public Class<?> typeElementToClass(TypeElement type) {\n-        class PrimitiveHolder {\n-            static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n-                    JavaType.BYTE, byte.class,\n-                    JavaType.SHORT, short.class,\n-                    JavaType.INT, int.class,\n-                    JavaType.LONG, long.class,\n-                    JavaType.FLOAT, float.class,\n-                    JavaType.DOUBLE, double.class,\n-                    JavaType.CHAR, char.class,\n-                    JavaType.BOOLEAN, boolean.class\n-            );\n-        }\n-        try {\n-            if (type instanceof PrimitiveType primitiveType) {\n-                return PrimitiveHolder.primitiveToClass.get(primitiveType);\n-            } else if (type instanceof ClassType classType) {\n-                return ((Class<?>) classType.resolve(lookup()));\n-            } else {\n-                throw new IllegalArgumentException(\"given type cannot be converted to class\");\n+            if (!(op.resultType() instanceof ArrayType)) {\n+                return false;\n@@ -398,2 +382,0 @@\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(\"given type cannot be converted to class\");\n@@ -401,0 +383,1 @@\n+        return isBufferArray(op);\n@@ -403,5 +386,5 @@\n-    private String obtainVarNameFromInvoke(JavaOp.InvokeOp invokeOp) {\n-        Op.Result invokeResult = invokeOp.result();\n-        if (!invokeResult.uses().isEmpty()) {\n-            Op.Result r = invokeResult.uses().stream().toList().getFirst();\n-            if (r.op() instanceof CoreOp.VarOp varOp) {\n+    private String varNameFromInvokeFirstUse(Invoke invoke) {\n+        var uses= invoke.op().result().uses();\n+        if (!uses.isEmpty()) {\n+            Op.Result result = uses.stream().toList().getFirst();\n+            if (result.op() instanceof CoreOp.VarOp varOp) {\n@@ -411,1 +394,1 @@\n-        return invokeOp.externalizeOpName();\n+        return invoke.op().externalizeOpName();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":236,"deletions":253,"binary":false,"changes":489,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.code.Op;\n@@ -32,1 +31,0 @@\n-import optkl.Invoke;\n@@ -37,2 +35,2 @@\n-\n-import static optkl.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -44,6 +42,8 @@\n-         return Trxfmr.of(funcOp)\n-                 .transform(\n-                     ce-> invokeOpHelper(lookup(),ce) instanceof Invoke $ && $.named(HATBarrierOp.NAME), \/* predicate *\/\n-                     c-> {\n-                        removeMe.add(((Op.Result)c.op().operands().getFirst()).op());\n-                        c.replace(new HATBarrierOp());\n+         return Trxfmr.of(this,funcOp).transform(c-> {\n+                         if (invoke(lookup(),c.op()) instanceof Invoke invoke\n+                                 && invoke.isInstanceAccessedViaVarAccess()\n+                                 && invoke.named(HATBarrierOp.NAME)\n+                         ){\n+                             removeMe.add(invoke.instanceVarAccess().op());\n+                             c.replace(new HATBarrierOp());\n+                         }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import optkl.Invoke;\n+import optkl.Trxfmr;\n@@ -50,3 +50,3 @@\n-\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.Trxfmr.copyLocation;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.copyLocation;\n@@ -80,1 +80,1 @@\n-                            && invokeOpHelper(lookup,varOpResult.op()) instanceof Invoke invoke && invoke.named(\"array\");\n+                            && invoke(lookup,varOpResult.op()) instanceof Invoke invoke && invoke.named(\"array\");\n@@ -85,6 +85,0 @@\n-    \/\/recursive\n-    private static boolean isOperandF32(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return isOperandF32(varLoadOp.operands().getFirst());\n-    }\n-\n-    \/\/recursive\n@@ -93,1 +87,1 @@\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> isOperandF32(varLoadOp); \/\/recurse\n+            case CoreOp.VarAccessOp varLoadOp -> varLoadOp.varType().valueType() ==JavaType.FLOAT; \/\/recurse\n@@ -146,2 +140,1 @@\n-                blockBuilder.op(copyLocation(invoke.op(),\n-                        new HATF16Op.HATF16ConvOp(\n+                blockBuilder.op(invoke.copyLocationTo(new HATF16Op.HATF16ConvOp(\n@@ -172,2 +165,1 @@\n-                blockBuilder.op(copyLocation(invoke.op(),\n-                        new HATF16Op.HATF16ToFloatConvOp(\n+                blockBuilder.op(invoke.copyLocationTo(new HATF16Op.HATF16ToFloatConvOp(\n@@ -190,1 +182,1 @@\n-        boolean isFirstOperandReference = findReference(lookup(),invokeOp.operands().getFirst());\n+        boolean isFirstOperandReference = findReference(lookup(),invokeOp.operands().get(0));\n@@ -230,4 +222,2 @@\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            if (!reducedFloatsType.containsKey(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+        return Trxfmr.of(this,funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n@@ -239,2 +229,1 @@\n-        });\n-        return funcOp;\n+        }).funcOp();\n@@ -255,6 +244,3 @@\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                var ctx = blockBuilder.context();\n-                ctx.mapValue(invokeOp.result(), ctx.getValue(invokeOp.operands().getFirst()));\n+        return  Trxfmr.of(this,funcOp).transform(ce->nodesInvolved.contains(ce),(blockBuilder, op) -> {\n+           if (op instanceof JavaOp.InvokeOp invokeOp) {\n+               blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.context().getValue(invokeOp.operands().getFirst()));\n@@ -265,2 +251,1 @@\n-        });\n-        return funcOp;\n+        }).funcOp();\n@@ -287,5 +272,3 @@\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            if (!reducedFloatsType.containsKey(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                createF16ConvOP(invokeOpHelper(lookup(),invokeOp), blockBuilder, reducedFloatsType.get(invokeOp));\n+        return Trxfmr.of(this,funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                createF16ConvOP(invoke(lookup(),invokeOp), blockBuilder, reducedFloatsType.get(invokeOp));\n@@ -296,2 +279,1 @@\n-        });\n-        return funcOp;\n+        }).funcOp();\n@@ -301,1 +283,1 @@\n-        Map<Op, ReducedFloatType> reducedFloatsType = new HashMap<>();\n+        Map<JavaOp.InvokeOp, ReducedFloatType> reducedFloatsType = new HashMap<>();\n@@ -304,1 +286,1 @@\n-                .map(ce->invokeOpHelper(lookup(),ce))\n+                .map(ce-> invoke(lookup(),ce))\n@@ -310,5 +292,3 @@\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            if (!reducedFloatsType.containsKey(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                createFloatFromF16(invokeOpHelper(lookup(),invokeOp), blockBuilder, reducedFloatsType.get(invokeOp));\n+        return Trxfmr.of(this,funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n+            if (op instanceof JavaOp.InvokeOp $ && invoke(lookup(),$) instanceof Invoke invoke) {\n+                createFloatFromF16(invoke, blockBuilder, reducedFloatsType.get(invoke.op()));\n@@ -317,2 +297,1 @@\n-        });\n-        return funcOp;\n+        }).funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":26,"deletions":47,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.OpHelper;\n@@ -40,2 +41,0 @@\n-import static optkl.OpTkl.isAssignable;\n-\n@@ -56,1 +55,1 @@\n-                if (!isAssignable(kernelCallGraph.lookup(), varOp.resultType().valueType(),\n+                if (!OpHelper.isAssignable(kernelCallGraph.lookup(), varOp.resultType().valueType(),\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetector.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.optools.RefactorMe;\n@@ -39,1 +38,1 @@\n-import optkl.Invoke;\n+import optkl.Trxfmr;\n@@ -41,1 +40,0 @@\n-import optkl.util.CallSite;\n@@ -51,3 +49,3 @@\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.transform;\n-import static optkl.Trxfmr.copyLocation;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.copyLocation;\n@@ -84,2 +82,0 @@\n-        var here = CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase\");\n-        before(here,funcOp);\n@@ -96,2 +92,2 @@\n-                                && result.op() instanceof JavaOp.InvokeOp invokeOp\n-                                && isIfaceBufferInvokeWithName(invokeOpHelper(lookup(),invokeOp)))\n+                                && invoke(lookup(),result.op()) instanceof Invoke invoke\n+                                && isIfaceBufferInvokeWithName(invoke))\n@@ -105,3 +101,3 @@\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n-            if (op instanceof JavaOp.InvokeOp invokeOp && mapMe.contains(invokeOp)) {\n-                invokeOp.result().uses().stream()\n+        return Trxfmr.of(this,funcOp).transform(ce->mapMe.contains(ce)||removeMe.contains(ce), (blockBuilder, op) -> {\n+            if (invoke(lookup(),op) instanceof Invoke invoke && mapMe.contains(invoke.op())) {\n+                invoke.op().result().uses().stream()\n@@ -111,1 +107,1 @@\n-                            blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(factory(blockBuilder, varOp, invokeOp)))\n+                            blockBuilder.context().mapValue(invoke.op().result(), blockBuilder.op(factory(blockBuilder, varOp, invoke.op())))\n@@ -119,3 +115,1 @@\n-        });\n-        after(here,funcOp );\n-        return funcOp;\n+        }).funcOp();\n@@ -187,8 +181,0 @@\n-\n-        private boolean meetConditionsForMemoryLoadOp(Invoke invoke) {\n-            return RefactorMe.isInvokeDescriptorSubtypeOf(lookup(),invoke.op(), DeviceType.class)\n-                    && !invoke.returnsVoid()\n-                    && !invoke.returnsPrimitive()\n-                    && !reservedMethods.contains(invoke.name());\n-        }\n-\n@@ -197,2 +183,0 @@\n-            var here = CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase - memoryLoadOp\");\n-            before(here, funcOp);\n@@ -202,2 +186,5 @@\n-                        if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke) {\n-                            if (meetConditionsForMemoryLoadOp(invoke)) {\n+                        if (invoke(lookup(),codeElement) instanceof Invoke invoke\n+                             && invoke.refIs(DeviceType.class)\n+                                    && !invoke.returnsVoid()\n+                                    && !invoke.returnsPrimitive()\n+                                    && !reservedMethods.contains(invoke.name())) {\n@@ -213,1 +200,1 @@\n-                            }\n+\n@@ -218,5 +205,10 @@\n-            funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n-                if (!nodesInvolved.contains(op)) {\n-                    blockBuilder.op(op);\n-                } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                    insertHatMemoryLoadOp(blockBuilder, invokeOp);\n+            return Trxfmr.of(this,funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+               if (invoke(lookup(),op) instanceof Invoke invoke) {\n+                   blockBuilder.context().mapValue(invoke.op().result(),\n+                           blockBuilder.op(invoke.copyLocationTo(\n+                                   new HATMemoryDefOp.HATMemoryLoadOp(invoke.returnType(),\n+                                           invoke.refType(),\n+                                           invoke.name(),\n+                                           blockBuilder.context().getValues(invoke.op().operands())))\n+                           )\n+                   );\n@@ -224,2 +216,1 @@\n-                    JavaOp.InvokeOp invokeOp = varTable.get(varOp);\n-                    factory(blockBuilder, varOp, invokeOp);\n+                    factory(blockBuilder, varOp, varTable.get(varOp));\n@@ -227,1 +218,0 @@\n-\n@@ -229,3 +219,1 @@\n-            });\n-            after(here, funcOp);\n-            return funcOp;\n+            }).funcOp();\n@@ -233,11 +221,0 @@\n-\n-        private void insertHatMemoryLoadOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp) {\n-            HATMemoryDefOp.HATMemoryLoadOp loadOp = new HATMemoryDefOp.HATMemoryLoadOp(invokeOp.resultType(),\n-                    invokeOp.invokeDescriptor().refType(),\n-                    invokeOp.invokeDescriptor().name(),\n-                    blockBuilder.context().getValues(invokeOp.operands()));\n-            Op.Result resultLoad = blockBuilder.op(loadOp);\n-            loadOp.setLocation(invokeOp.location());\n-            blockBuilder.context().mapValue(invokeOp.result(), resultLoad);\n-        }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":29,"deletions":52,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import optkl.util.CallSite;\n@@ -38,2 +37,0 @@\n-\n-\n@@ -41,1 +38,0 @@\n-\n@@ -45,16 +41,0 @@\n-\n-    default boolean tracing(){\n-            return kernelCallGraph().config().showCompilationPhases();\n-    }\n-\n-    default void before(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (tracing()) {\n-            IO.println(\"[INFO] Code model before [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \"  + System.lineSeparator() + funcOp.toText());\n-        }\n-    }\n-\n-    default void after(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (tracing()) {\n-            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \" + System.lineSeparator() + funcOp.toText());\n-        }\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATPhase.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import optkl.FieldAccess;\n+import jdk.incubator.code.CodeElement;\n@@ -36,2 +36,0 @@\n-import optkl.util.CallSite;\n-import optkl.OpTkl;\n@@ -40,1 +38,2 @@\n-import java.util.Objects;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -42,2 +41,3 @@\n-import static optkl.FieldAccess.fieldAccessOpHelper;\n-import static optkl.OpTkl.operandsAsResults;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n+import static optkl.OpHelper.Named.VarAccess;\n@@ -61,0 +61,2 @@\n+\n+\n@@ -63,1 +65,0 @@\n-        var txfmr = new Trxfmr(CallSite.of(this.getClass()),funcOp);\n@@ -71,33 +72,21 @@\n-        return txfmr.select(\n-                ce-> fieldAccessOpHelper(lookup(),ce) instanceof FieldAccess fieldAccess\n-                        && fieldAccess.refType(KernelContext.class)\n-                && fieldAccess.named(fieldNameRegex)\n-              \/\/  fieldAccessOpKernelContextPattern.asKernelContextFieldAccessOrNull(\n-        \/\/                lookup(),ce,fieldAccessOp->fieldNameRegex.matches(fieldAccessOp.fieldDescriptor().name()))!=null\n-        ,(s, o)->\n-                   operandsAsResults(o)\n-                     .map(OpTkl::opOfResultOrNull)\n-                     .map(OpTkl::asVarLoadOrNull)\n-                     .filter(Objects::nonNull) \/\/ ((Result)operand).op()) instanceof VarLoad varload && varload is KernelContext.class\n-                     .findFirst()\n-                     .ifPresent(varLoadOp -> s.select(o,varLoadOp))\n-                ).transform(txfmr.selected::contains, c->{\n-                   switch (c.op()){\n-                      case JavaOp.FieldAccessOp.FieldLoadOp $  -> {\n-                          String name = $.fieldDescriptor().name();\n-                          int dimIdx = name.length()==3 ?name.charAt(2)-'x' :-1;\n-                          if (dimIdx <0||dimIdx>3){\n-                              throw new IllegalStateException();\/\/'x'=1,'y'=2....\n-                          }\n-                          c.replace(switch (HATThreadsPhase.this){\n-                              case BlockPhase _-> HATThreadOp.HATBlockThreadIdOp.of(dimIdx, $.resultType());\n-                              case GlobalIdPhase _-> HATThreadOp.HATGlobalThreadIdOp.of(dimIdx, $.resultType());\n-                              case GlobalSizePhase _-> HATThreadOp.HATGlobalSizeOp.of(dimIdx, $.resultType());\n-                              case LocalIdPhase _-> HATThreadOp.HATLocalThreadIdOp.of(dimIdx, $.resultType());\n-                              case LocalSizePhase _-> HATThreadOp.HATLocalSizeOp.of(dimIdx,$.resultType());\n-                          });\n-                      }\n-                      case CoreOp.VarAccessOp.VarLoadOp _ -> c.remove();\n-                      default -> {}\n-                }\n-        }).funcOp();\n+        Set<CodeElement<?,?>> removeMe= new HashSet<>();\n+        return Trxfmr.of(this,funcOp).transform(ce->ce instanceof JavaOp.FieldAccessOp, c->{\n+                    if (fieldAccess(lookup(),c.op()) instanceof FieldAccess fieldAccess\n+                            && fieldAccess.refType(KernelContext.class)\n+                            && fieldAccess.isLoad()\n+                            && fieldAccess.named(fieldNameRegex)\n+                            && fieldAccess.instanceVarAccess() instanceof VarAccess varAccess) {\n+                                    removeMe.add(varAccess.op()); \/\/ We will need to remove this\n+                                    int dimIdx = fieldAccess.name().charAt(2) - 'x';\n+                                    c.replace(switch (HATThreadsPhase.this) {\n+                                        case BlockPhase _ -> HATThreadOp.HATBlockThreadIdOp.of(dimIdx, fieldAccess.resultType());\n+                                        case GlobalIdPhase _ -> HATThreadOp.HATGlobalThreadIdOp.of(dimIdx, fieldAccess.resultType());\n+                                        case GlobalSizePhase _ -> HATThreadOp.HATGlobalSizeOp.of(dimIdx, fieldAccess.resultType());\n+                                        case LocalIdPhase _ -> HATThreadOp.HATLocalThreadIdOp.of(dimIdx, fieldAccess.resultType());\n+                                        case LocalSizePhase _ -> HATThreadOp.HATLocalSizeOp.of(dimIdx, fieldAccess.resultType());\n+                                    });\n+                                }\n+                })\n+                .remap(removeMe)\n+                .remove(removeMe::contains)\n+                .funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":29,"deletions":40,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -39,3 +39,2 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.Invoke;\n-import optkl.util.CallSite;\n+import optkl.OpHelper;\n+import optkl.Trxfmr;\n@@ -53,3 +52,3 @@\n-import static hat.optools.RefactorMe.isAMethod;\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.transform;\n+\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -66,2 +65,2 @@\n-\n-    public static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+    \/\/ recursive\n+    private static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n@@ -70,1 +69,1 @@\n-\n+    \/\/ recursive\n@@ -73,1 +72,1 @@\n-            return findVectorTypeElement(varLoadOp);\n+            return findVectorTypeElement(varLoadOp); \/\/ recurse\n@@ -83,2 +82,3 @@\n-    public static String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().getFirst());\n+    \/\/recursive\n+    public static int getWidth(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return getWidth(varLoadOp.operands().getFirst());\n@@ -86,1 +86,1 @@\n-\n+    \/\/recursive\n@@ -98,2 +98,17 @@\n-    public static int getWidth(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return getWidth(varLoadOp.operands().getFirst());\n+    \/\/recursive\n+    private boolean findIsSharedOrPrivate(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findIsSharedOrPrivate(varLoadOp.operands().getFirst());\n+    }\n+\n+    \/\/recursive\n+    private boolean findIsSharedOrPrivate(Value v) {\n+        return v instanceof Op.Result result && switch (result.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findIsSharedOrPrivate(varLoadOp); \/\/recurse\n+            case HATMemoryVarOp.HATLocalVarOp _, HATMemoryVarOp.HATPrivateVarOp _ -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    \/\/ recursive\n+    public static String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().getFirst());\n@@ -101,0 +116,2 @@\n+\n+    \/\/ recursive\n@@ -135,21 +152,0 @@\n-\n-    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp) {\n-           return (invokeOp.resultType() instanceof JavaType jt\n-                   && isAssignable(lookup(), jt, _V.class)\n-                   && isAMethod(invokeOp, n->n.equals(vectorOperation.methodName))\n-           );\n-    }\n-    \/\/recursive\n-    private boolean findIsSharedOrPrivate(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findIsSharedOrPrivate(varLoadOp.operands().getFirst());\n-    }\n-\n-    \/\/recursive\n-    private boolean findIsSharedOrPrivate(Value v) {\n-        return v instanceof Op.Result result && switch (result.op()) {\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findIsSharedOrPrivate(varLoadOp); \/\/recurse\n-            case HATMemoryVarOp.HATLocalVarOp _, HATMemoryVarOp.HATPrivateVarOp _ -> true;\n-            default -> false;\n-        };\n-    }\n-\n@@ -169,1 +165,1 @@\n-        VectorMetaData metaData = getVectorTypeInfo(invokeOp);\n+        VectorMetaData metaData = getVectorTypeInfo(lookup(),invokeOp);\n@@ -176,1 +172,1 @@\n-    private void inertVectorVarOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, Map<Op, VectorMetaData> vectorMetaData) {\n+    private void insertVectorVarOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, Map<Op, VectorMetaData> vectorMetaData) {\n@@ -215,1 +211,1 @@\n-        VectorMetaData vectorMetaData = getVectorTypeInfo(invokeOp);\n+        VectorMetaData vectorMetaData = getVectorTypeInfo(lookup(),invokeOp);\n@@ -246,1 +242,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyVectorLoad\");\n@@ -248,32 +243,15 @@\n-        before(here, funcOp);\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof CoreOp.VarOp varOp) {\n-                        List<Value> inputOperandsVarOp = varOp.operands();\n-                        for (Value inputOperand : inputOperandsVarOp) {\n-                            if (inputOperand instanceof Op.Result result) {\n-                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n-                                    if (isVectorOperation(invokeOp)) {\n-                                        \/\/ Associate both ops to the vectorTypeInfo for easy\n-                                        \/\/ access to type and lanes\n-                                        VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n-                                        vectorMetaData.put(invokeOp, vectorTypeInfo);\n-                                        vectorMetaData.put(varOp, vectorTypeInfo);\n-                                        consumer.accept(invokeOp);\n-                                        consumer.accept(varOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                \/\/ Don't insert the invoke node\n-                Op.Result result = invokeOp.result();\n-                List<Op.Result> collect = result.uses().stream().toList();\n+        OpHelper.Named.Var.stream(lookup(),funcOp)\n+                 .forEach(var-> var.op().operands().stream()\n+                      .filter(operand->operand instanceof Op.Result result && result.op() instanceof JavaOp.InvokeOp)\n+                      .map(operand-> invoke(lookup(),((Op.Result)operand).op()))\n+                      .filter(invoke ->  invoke.returns(_V.class) && invoke.named(vectorOperation.methodName))\n+                      .forEach(invoke -> {\n+                           \/\/ Associate both ops to the vectorTypeInfo for easy access to type and lanes\n+                            VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(), invoke.op());\n+                            vectorMetaData.put(invoke.op(), vectorTypeInfo);\n+                            vectorMetaData.put(var.op(), vectorTypeInfo);\n+                      })\n+                );\n+\n+        return Trxfmr.of(this,funcOp).transform(vectorMetaData::containsKey, (blockBuilder, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n@@ -281,0 +259,1 @@\n+                List<Op.Result> collect = invokeOp.result().uses().stream().toList();\n@@ -287,1 +266,1 @@\n-                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -290,3 +269,1 @@\n-        });\n-        after(here, funcOp);\n-        return funcOp;\n+        }).funcOp();\n@@ -296,1 +273,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyVectorOf\");\n@@ -298,1 +274,0 @@\n-        before(here, funcOp);\n@@ -301,4 +276,4 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp)) {\n-                            consumer.accept(invokeOp);\n-                            Set<Op.Result> uses = invokeOp.result().uses();\n+                    if (invoke(lookup(),codeElement) instanceof Invoke invoke\n+                         &&invoke.returns(_V.class) && invoke.named(vectorOperation.methodName) ) {\n+                            consumer.accept(invoke.op());\n+                            Set<Op.Result> uses = invoke.op().result().uses();\n@@ -308,2 +283,2 @@\n-                                    VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n-                                    vectorMetaData.put(invokeOp, vectorTypeInfo);\n+                                    VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(),invoke.op());\n+                                    vectorMetaData.put(invoke.op(), vectorTypeInfo);\n@@ -314,1 +289,1 @@\n-                    }\n+\n@@ -319,1 +294,1 @@\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(_->true, (blockBuilder, op) -> {\n@@ -325,1 +300,1 @@\n-                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -328,3 +303,1 @@\n-        });\n-        after(here, funcOp);\n-        return funcOp;\n+        }).funcOp();\n@@ -334,2 +307,1 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyVectorBinaryOps\");\n-        before(here, funcOp);\n+\n@@ -345,6 +317,6 @@\n-                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n-                                    if (isVectorOperation(invokeOp)) {\n-                                        BinaryOpEnum binaryOpType = BinaryOpEnum.of(invokeOp);\n-                                        binaryOperation.put(invokeOp, binaryOpType);\n-                                        VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n-                                        vectorMetaData.put(invokeOp, vectorTypeInfo);\n+                                if (invoke(lookup(),result.op()) instanceof Invoke invoke ) {\n+                                    if (invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)) {\n+                                        BinaryOpEnum binaryOpType = BinaryOpEnum.of(invoke.op());\n+                                        binaryOperation.put(invoke.op(), binaryOpType);\n+                                        VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(),invoke.op());\n+                                        vectorMetaData.put(invoke.op(), vectorTypeInfo);\n@@ -352,1 +324,1 @@\n-                                        consumer.accept(invokeOp);\n+                                        consumer.accept(invoke.op());\n@@ -363,1 +335,1 @@\n-        funcOp = transform(here, funcOp, nodesInvolved::contains, (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform( nodesInvolved::contains, (blockBuilder, op) -> {\n@@ -374,1 +346,1 @@\n-                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -377,3 +349,1 @@\n-        });\n-        after(here, funcOp);\n-        return funcOp;\n+        }).funcOp();\n@@ -383,2 +353,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyMutableOf\");\n-        before(here, funcOp);\n@@ -388,6 +356,6 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp)) {\n-                            consumer.accept(invokeOp);\n-                            VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n-                            vectorMetaData.put(invokeOp, vectorTypeInfo);\n-                            Set<Op.Result> uses = invokeOp.result().uses();\n+                    if (invoke(lookup(),codeElement) instanceof Invoke invoke) {\n+                        if (invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)) {\n+                            consumer.accept(invoke.op());\n+                            VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(),invoke.op());\n+                            vectorMetaData.put(invoke.op(), vectorTypeInfo);\n+                            Set<Op.Result> uses = invoke.op().result().uses();\n@@ -406,1 +374,1 @@\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n+        funcOp = Trxfmr.of(this,funcOp).transform(_->true, (blockBuilder, op) -> {\n@@ -412,1 +380,1 @@\n-                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -415,2 +383,1 @@\n-        });\n-        after(here, funcOp);\n+        }).funcOp();\n@@ -421,2 +388,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyBinaryWithConcatenation\");\n-        before(here, funcOp);\n@@ -426,3 +391,3 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp)) {\n-                            List<Value> inputOperandsInvoke = invokeOp.operands();\n+                    if (invoke(lookup(),codeElement) instanceof Invoke invoke) {\n+                        if (invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)) {\n+                            List<Value> inputOperandsInvoke = invoke.op().operands();\n@@ -431,2 +396,2 @@\n-                                    BinaryOpEnum binaryOpType = BinaryOpEnum.of(invokeOp);\n-                                    binaryOperation.put(invokeOp, binaryOpType);\n+                                    BinaryOpEnum binaryOpType = BinaryOpEnum.of(invoke.op());\n+                                    binaryOperation.put(invoke.op(), binaryOpType);\n@@ -434,1 +399,1 @@\n-                                    consumer.accept(invokeOp);\n+                                    consumer.accept(invoke.op());\n@@ -449,2 +414,9 @@\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n+        if (!nodesInvolved.isEmpty()) {\n+            funcOp = Trxfmr.of(this,funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+                 if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                    insertVectorBinaryOp(blockBuilder, invokeOp, binaryOperation);\n+                } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                    insertVectorVarLoadOp(blockBuilder, varLoadOp);\n+                }\n+                return blockBuilder;\n+            }).funcOp();\n@@ -452,11 +424,0 @@\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                insertVectorBinaryOp(blockBuilder, invokeOp, binaryOperation);\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                insertVectorVarLoadOp(blockBuilder, varLoadOp);\n-            }\n-            return blockBuilder;\n-        });\n-        after(here, funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":98,"deletions":137,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.code.CodeElement;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.code.CodeElement;\n@@ -33,0 +33,1 @@\n+import jdk.incubator.code.TypeElement;\n@@ -36,4 +37,2 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.util.CallSite;\n-import optkl.OpTkl;\n-import optkl.util.Regex;\n+import optkl.OpHelper;\n+import optkl.Trxfmr;\n@@ -41,4 +40,2 @@\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -46,4 +43,3 @@\n-import static hat.optools.RefactorMe.inspectAllInterfaces;\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.asOpFromResultOrNull;\n-import static optkl.OpTkl.transform;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.copyLocation;\n@@ -52,25 +48,0 @@\n-    private static final Regex xyzw = Regex.of(\"[xyzw]\");\n-\n-    private boolean isVectorLane(JavaOp.InvokeOp invokeOp) {\n-        return invokeOpHelper(lookup(),invokeOp).named(xyzw);\n-    }\n-    static boolean isVectorOperation(JavaOp.InvokeOp invokeOp, boolean laneOk) {\n-        String typeElement = invokeOp.invokeDescriptor().refType().toString();\n-        Set<Class<?>> interfaces;\n-        try {\n-            Class<?> aClass = Class.forName(typeElement); \/\/ WHY?\n-            interfaces = inspectAllInterfaces(aClass);\n-        } catch (ClassNotFoundException _) {\n-            return false;\n-        }\n-        return interfaces.contains(_V.class) && laneOk;\n-    }\n-    int getLane(String fieldName) {\n-        return switch (fieldName) {\n-            case \"x\" -> 0;\n-            case \"y\" -> 1;\n-            case \"z\" -> 2;\n-            case \"w\" -> 3;\n-            default -> -1;\n-        };\n-    }\n@@ -78,68 +49,32 @@\n-    \/\/ recursive\n-    private String findNameVector(Value v) {\n-        if (OpTkl.asOpFromResultOrNull(v) instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findNameVector(varLoadOp.operands().getFirst());\n-        } else if (OpTkl.asOpFromResultOrNull(v)  instanceof HATVectorOp vectorViewOp) {\n-            return vectorViewOp.varName();\n-        }\n-        throw new IllegalStateException(\"recurse fail findNameVector\");\n-\n-    }\n-\n-\n-    \/\/recursive\n-    private CoreOp.VarOp findVarOp(Value v) {\n-        if (asOpFromResultOrNull(v) instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findVarOp(varLoadOp.operands().getFirst());\n-        } else if (asOpFromResultOrNull(v) instanceof CoreOp.VarOp varOp) {\n-            return varOp;\n-        }\n-        return null;\n-\n-    }\n-\n-    \/\/ Code Model Pattern:\n-    \/\/  %16 : java.type:\"hat.types.Float4\" = var.load %15 @loc=\"63:28\";\n-    \/\/  %17 : java.type:\"float\" = invoke %16 @loc=\"63:28\" @java.ref:\"hat.types.Float4::x():float\";\n-    private CoreOp.FuncOp vloadSelectPhase(CoreOp.FuncOp funcOp) {\n-        var here = CallSite.of(this.getClass(), \"vloadSelectPhase\");\n-        before(here, funcOp);\n-        Stream<CodeElement<?, ?>> vectorSelectOps = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp, isVectorLane(invokeOp)) && (invokeOp.resultType() != JavaType.VOID)) {\n-                            Value inputOperand = invokeOp.operands().getFirst();\n-                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                consumer.accept(invokeOp);\n-                                consumer.accept(varLoadOp);\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = vectorSelectOps.collect(Collectors.toSet());\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n-            CodeContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                List<Value> inputInvokeOp = invokeOp.operands();\n-                for (Value v : inputInvokeOp) {\n-                    if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                        List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n-                        int lane = getLane(invokeOp.invokeDescriptor().name());\n-                        HATVectorOp vSelectOp;\n-                        String name = findNameVector(varLoadOp.operands().getFirst());\n-                        if (invokeOp.resultType() != JavaType.VOID) {\n-                            vSelectOp = new HATVectorOp.HATVectorSelectLoadOp(name, invokeOp.resultType(), lane, outputOperandsInvokeOp);\n-                        } else {\n-                            throw new RuntimeException(\"VSelect Load Op must return a value!\");\n-                        }\n-                        Op.Result hatSelectResult = blockBuilder.op(vSelectOp);\n-                        vSelectOp.setLocation(invokeOp.location());\n-                        context.mapValue(invokeOp.result(), hatSelectResult);\n-                    }\n-                }\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ Pass the value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        record InvokeVar(JavaOp.InvokeOp invokeOp, CoreOp.VarAccessOp.VarLoadOp varLoadOp){\n+            \/\/ recursive\n+            static String vectorNameOrThrow(Value v) {\n+                return switch (OpHelper.asOpFromResultOrNull(v)){\n+                    case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->vectorNameOrThrow(varLoadOp.operands().getFirst()); \/\/ recurse\n+                    case HATVectorOp vectorOp ->vectorOp.varName();\n+                    case null -> null;\n+                    default -> throw new IllegalStateException(\"failed to find vector name\");\n+                };\n+            }\n+            String name(){\n+                return vectorNameOrThrow(varLoadOp.operands().getFirst());\n+            }\n+            \/\/recursive\n+            private CoreOp.VarOp findVarOpOrNull(Value v) {\n+                return switch (OpHelper.asOpFromResultOrNull(v)){\n+                    case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->findVarOpOrNull(varLoadOp.operands().getFirst()); \/\/recurse\n+                    case CoreOp.VarOp varOp->varOp;\n+                    case null -> null;\n+                    default ->  null;\n+                };\n+            }\n+            public CoreOp.VarOp varOpFromOperand(int idx){\n+                return findVarOpOrNull(invokeOp.operands().get(idx));\n+            }\n+            public TypeElement returnType() {\n+                return invokeOp.resultType();\n+            }\n+            int laneIdx() {\n+                return \"xyzw\".indexOf(invokeOp.invokeDescriptor().name().charAt(0));\n@@ -147,2 +82,0 @@\n-            return blockBuilder;\n-        });\n@@ -150,3 +83,1 @@\n-        after(here, funcOp);\n-        return funcOp;\n-    }\n+        }\n@@ -154,20 +85,12 @@\n-    \/\/ Pattern from the code mode:\n-    \/\/ %20 : java.type:\"hat.types.Float4\" = var.load %15 @loc=\"64:13\";\n-    \/\/ %21 : java.type:\"float\" = var.load %19 @loc=\"64:18\";\n-    \/\/ invoke %20 %21 @loc=\"64:13\" @java.ref:\"hat.types.Float4::x(float):void\";\n-    private CoreOp.FuncOp vstoreSelectPhase(CoreOp.FuncOp funcOp) {\n-        var here = CallSite.of(this.getClass(), \"vstoreSelectPhase\");\n-        before(here, funcOp);\n-        \/\/TODO is this side table safe?\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = OpTkl.elements(here, funcOp)\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp, isVectorLane(invokeOp))) {\n-                            List<Value> inputOperandsInvoke = invokeOp.operands();\n-                            Value inputOperand = inputOperandsInvoke.getFirst();\n-                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                consumer.accept(invokeOp);\n-                                consumer.accept(varLoadOp);\n-                            }\n-                        }\n-                    }\n+        Map<CodeElement<?,?>, InvokeVar> ceToInvokeVar = new HashMap<>();\n+        Invoke.stream(lookup(),funcOp)\n+                .filter(invoke ->\n+                        invoke.named(\"x\",\"y\",\"z\",\"w\")\n+                                && invoke.refIs(_V.class)\n+                                && invoke.opFromFirstOperandAsResultOrThrow() instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                .map(invoke ->\n+                        new InvokeVar(invoke.op(),invoke.varLoadOpFromFirstOperandAsResultOrNull())\n+                )\n+                .forEach(invokeVar ->{\n+                    ceToInvokeVar.put(invokeVar.invokeOp,invokeVar);\n+                    ceToInvokeVar.put(invokeVar.varLoadOp,invokeVar);\n@@ -176,2 +99,1 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(ceToInvokeVar::containsKey,(blockBuilder, op) -> {\n@@ -179,24 +101,28 @@\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                List<Value> inputInvokeOp = invokeOp.operands();\n-                Value v = inputInvokeOp.getFirst();\n-\n-                if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                    List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n-                    int lane = getLane(invokeOp.invokeDescriptor().name());\n-                    HATVectorOp vSelectOp;\n-                    String name = findNameVector(varLoadOp.operands().getFirst());\n-                    if (invokeOp.resultType() == JavaType.VOID) {\n-                        \/\/ The operand 1 in the store is the address (lane)\n-                        \/\/ The operand 1 in the store is the storeValue\n-                        CoreOp.VarOp resultOp = findVarOp(outputOperandsInvokeOp.get(1));\n-                        vSelectOp = new HATVectorOp.HATVectorSelectStoreOp(name, invokeOp.resultType(), lane, resultOp, outputOperandsInvokeOp);\n-                    } else {\n-                        throw new RuntimeException(\"VSelect Store Op must return a value!\");\n-                    }\n-                    Op.Result resultVStore = blockBuilder.op(vSelectOp);\n-                    vSelectOp.setLocation(invokeOp.location());\n-                    context.mapValue(invokeOp.result(), resultVStore);\n-                }\n-\n+            if (invoke(lookup(),op) instanceof Invoke invoke\n+                    && ceToInvokeVar.get(invoke.op()) instanceof InvokeVar invokeVar) {\n+                Op newOp = invoke.returnsVoid()\n+                        ?\n+                        \/\/ Code Model Pattern:\n+                        \/\/  %16 : java.type:\"hat.types.Float4\" = var.load %15 @loc=\"63:28\";\n+                        \/\/  %17 : java.type:\"float\" = invoke %16 @loc=\"63:28\" @java.ref:\"hat.types.Float4::x():float\";\n+\n+                        new HATVectorOp.HATVectorSelectStoreOp(\n+                                invokeVar.name(),\n+                                invokeVar.laneIdx(),\n+                                invokeVar.varOpFromOperand(1),\n+                                context.getValues(invokeVar.invokeOp.operands())\n+                        )\n+                        :\n+                        \/\/ Pattern from the code mode:\n+                        \/\/ %20 : java.type:\"hat.types.Float4\" = var.load %15 @loc=\"64:13\";\n+                        \/\/ %21 : java.type:\"float\" = var.load %19 @loc=\"64:18\";\n+                        \/\/ invoke %20 %21 @loc=\"64:13\" @java.ref:\"hat.types.Float4::x(float):void\";\n+                        new HATVectorOp.HATVectorSelectLoadOp(\n+                                invokeVar.name(),\n+                                invokeVar.returnType(),\n+                                invokeVar.laneIdx(),\n+                                context.getValues(invokeVar.invokeOp.operands())\n+                        );\n+\n+                context.mapValue(invokeVar.invokeOp.result(), blockBuilder.op(\n+                        copyLocation(invokeVar.invokeOp, newOp)));\n@@ -204,1 +130,0 @@\n-                \/\/ Pass the value\n@@ -208,11 +133,1 @@\n-        });\n-\n-        after(here, funcOp);\n-        return funcOp;\n-    }\n-\n-    @Override\n-    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n-        funcOp = vloadSelectPhase(funcOp);\n-        funcOp = vstoreSelectPhase(funcOp);\n-        return funcOp;\n+        }).funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":84,"deletions":169,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.optools.RefactorMe;\n+import hat.types._V;\n@@ -39,1 +39,2 @@\n-import optkl.util.CallSite;\n+import optkl.OpHelper;\n+import optkl.Trxfmr;\n@@ -45,1 +46,2 @@\n-import static optkl.OpTkl.transform;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -78,2 +80,0 @@\n-\n-\n@@ -82,6 +82,1 @@\n-        var here = CallSite.of(this.getClass(), \"apply\");\n-        String vectorOperation = switch (this) {\n-            case Float2StorePhase _ -> \"storeFloat2View\";\n-            case Float4StorePhase _ -> \"storeFloat4View\";\n-        };\n-        before(here,funcOp);\n+\n@@ -90,4 +85,11 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp\n-                        && (invokeOp.operands().size() >= 3) &&\n-                            (RefactorMe.isVectorOperation(invokeOp, invokeOp.operands().get(1), n->n.equals(vectorOperation)))) {\n-                            consumer.accept(invokeOp);\n+                    if (invoke(lookup(),codeElement)instanceof Invoke invoke\n+                            && (invoke.op().operands().size() >2)\n+                            && invoke.named(\n+                            switch (HATVectorStorePhase.this) {\n+                               case Float2StorePhase _ -> \"storeFloat2View\";\n+                               case Float4StorePhase _ -> \"storeFloat4View\";\n+                            })\n+                            && OpHelper.asResultOrNull(invoke.op().operands().get(1)) instanceof Op.Result result\n+                            && result.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                            && OpHelper.isAssignable(lookup(),varLoadOp.resultType(), _V.class)){\n+                            consumer.accept(invoke.op());\n@@ -98,1 +100,1 @@\n-           funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n+           return Trxfmr.of(this,funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n@@ -100,3 +102,1 @@\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n@@ -108,1 +108,1 @@\n-                HATPhaseUtils.VectorMetaData vectorMetaData  = HATPhaseUtils.getVectorTypeInfo(invokeOp, 1);\n+                HATPhaseUtils.VectorMetaData vectorMetaData  = HATPhaseUtils.getVectorTypeInfo(lookup(),invokeOp, 1);\n@@ -120,3 +120,1 @@\n-        });\n-        after(here, funcOp);\n-        return funcOp;\n+        }).funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":21,"deletions":23,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package experiments;\n+\n+\n+import hat.ComputeContext;\n+import hat.buffer.S32Array;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import optkl.Trxfmr;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+\n+\n+public class AddArbitraryBlock {\n+\n+    @Reflect\n+    static void hackMe(ComputeContext cc, S32Array s32Array){\n+        System.out.println(\"Ignore this\");\n+        System.out.printf(\"        But wrap this\\n\");\n+        System.out.println(\"Also ignore\");\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        var hackMeMethodRef= MethodRef.method(AddArbitraryBlock.class, \"hackMe\", void.class, ComputeContext.class, S32Array.class);\n+        var lookup = MethodHandles.lookup();\n+        var hackMeFuncOp = CoreOp.FuncOp.ofMethod(hackMeMethodRef.resolveToMethod(lookup)).get();\n+        MethodRef Println = MethodRef.method(IO.class, \"println\", void.class, Object.class);\n+        Trxfmr.of(lookup,hackMeFuncOp)\n+                .toJava(\"Before injecting\")\n+                .transform(\"withNewBlock\", ce -> invoke(lookup,ce) instanceof Invoke $ && $.named(\"printf\"), c -> {\n+                    var beforeString = c.builder().op(CoreOp.constant(JavaType.J_L_STRING, \"Before ....\"));\n+                    var afterString = c.builder().op(CoreOp.constant(JavaType.J_L_STRING, \"After ....\"));\n+                    c.add(JavaOp.if_(c.builder().parentBody()).if_(b -> {\n+                        b.op(CoreOp.core_yield(b.op(CoreOp.constant(JavaType.BOOLEAN, true))));\n+                    }).then(b -> {\n+                        b.op(JavaOp.invoke( JavaType.VOID, Println, beforeString));\n+                        b.op(CoreOp.core_yield());\n+                    }).else_(e->\n+                            e.op(CoreOp.core_yield()))\n+                    );\n+                    c.retain();\n+                    c.add(JavaOp.if_(c.builder().parentBody()).if_(b -> {\n+                        b.op(CoreOp.core_yield(b.op(CoreOp.constant(JavaType.BOOLEAN, true))));\n+                    }).then(b -> {\n+                        b.op(JavaOp.invoke( JavaType.VOID, Println, afterString));\n+                        b.op(CoreOp.core_yield());\n+                    }).else_(e->\n+                            e.op(CoreOp.core_yield()))\n+                    );\n+                })\n+                .toJava( \"After injecting\")\n+                .run(txfmr-> {\n+                    try {\n+                        BytecodeGenerator.generate(txfmr.lookup(), txfmr.funcOp()).invoke(null, null);\n+                    } catch (Throwable throwable) {\n+                        throw new RuntimeException(throwable);\n+                    }\n+                });\n+\n+    }\n+}\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/AddArbitraryBlock.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -29,2 +29,0 @@\n-import hat.codebuilders.JavaHATCodeBuilder;\n-import optkl.Trxfmr;\n@@ -43,0 +41,1 @@\n+import optkl.Trxfmr;\n@@ -48,0 +47,2 @@\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -155,1 +156,1 @@\n-                   \/\/ var arg = builder.parameters().getFirst();\n+                    \/\/ var arg = builder.parameters().getFirst();\n@@ -166,1 +167,1 @@\n-        System.out.println( OpCodeBuilder.toText(rsqrtFuncOp));\n+        System.out.println(OpCodeBuilder.toText(rsqrtFuncOp));\n@@ -168,32 +169,42 @@\n-        var trxfmr = new Trxfmr(rsqrtFuncOp);\n-        trxfmr.transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n-            c.add(JavaOp.if_(c.builder().parentBody()).if_(b -> {\n-                var lhs = b.op(CoreOp.constant(JavaType.BOOLEAN, false));\n-                var rhs = b.op(CoreOp.constant(JavaType.BOOLEAN, true));\n-                b.op(CoreOp.core_yield(b.op(JavaOp.or(lhs, rhs))));\n-            }).then(b -> {\n-                var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Then\"));\n-                b.op(new Pre(List.of()));\n-                b.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.VOID, Println, msg));\n-                b.op(new Post(List.of()));\n-                b.op(CoreOp.core_yield());\n-            }).else_(b -> {\n-                var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Else\"));\n-                b.op(new Pre(List.of()));\n-                b.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.VOID, Println, msg));\n-                b.op(new Post(List.of()));\n-                b.op(CoreOp.core_yield());\n-            }));\n-             c.add(new Pre(List.of()));\n-             c.replace(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, c.mappedOperand(0)));\n-             c.add(new Post(List.of()));\n-        });\n-        System.out.println( OpCodeBuilder.toText(trxfmr.funcOp()));\n-\n-        \/\/ We need to remove our injected ops from the model to execute\n-        trxfmr.transform(ce -> ce instanceof Inject, c -> c.remove()).funcOp();\n-\n-        var javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,trxfmr.funcOp());\n-        System.out.println(javaCodeBuilder.toText());\n-        System.out.println( OpCodeBuilder.toText(trxfmr.funcOp()));\n-        System.out.println(\" 1\/abs(100) = \" + BytecodeGenerator.generate(lookup, trxfmr.funcOp()).invoke(100));\n+        Trxfmr.of(lookup,rsqrtFuncOp)\n+                .transform(\"usingAbs\", ce -> invoke(lookup,ce) instanceof Invoke $\n+                        && $.named(\"sqrt\")\n+                        && $.isStatic()\n+                        && $.returns(double.class)\n+                        && $.receives(double.class), c -> {\n+                    c.add(JavaOp.if_(c.builder().parentBody()).if_(b -> {\n+                        var lhs = b.op(CoreOp.constant(JavaType.BOOLEAN, false));\n+                        var rhs = b.op(CoreOp.constant(JavaType.BOOLEAN, true));\n+                        b.op(CoreOp.core_yield(b.op(JavaOp.or(lhs, rhs))));\n+                    }).then(b -> {\n+                        var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Then \\\"With this text\\\"\"));\n+                        b.op(new Pre(List.of()));\n+                        b.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.VOID, Println, msg));\n+                        b.op(new Post(List.of()));\n+                        b.op(CoreOp.core_yield());\n+                    }).else_(b -> {\n+                        var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Else\"));\n+                        b.op(new Pre(List.of()));\n+                        b.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.VOID, Println, msg));\n+                        b.op(new Post(List.of()));\n+                        b.op(CoreOp.core_yield());\n+                    }));\n+                    c.add(new Pre(List.of()));\n+                    c.replace(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, c.mappedOperand(0)));\n+                    c.add(new Post(List.of()));\n+                })\n+                .toText()\n+                \/\/ We need to remove our injected ops from the model to execute\n+                .transform(ce -> ce instanceof Inject, c -> c.remove())\n+                .toText()\n+                .run(trxfmr -> {\n+                    trxfmr.toJava();\n+                    System.out.println(OpCodeBuilder.toText(trxfmr.funcOp()));\n+                    try {\n+                        System.out.println(\" 1\/abs(100) = \" + BytecodeGenerator.generate(lookup, trxfmr.funcOp()).invoke(100));\n+                    } catch (Throwable throwable) {\n+                        throw new RuntimeException(throwable);\n+                    }\n+                });\n+\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":47,"deletions":36,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package experiments;\n-\n-import java.lang.reflect.Method;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.util.CallSite;\n-\n-import java.util.List;\n-\n-import static optkl.OpTkl.transform;\n-\n-public class DNA {\n-    static int myFunc(int i) {\n-        return 0;\n-    }\n-\n-    @Reflect\n-    public static void addMul(int add, int mul) {\n-        int len = myFunc(add);\n-    }\n-\n-    public static class DNAOp extends Op { \/\/ externalized\n-        private final String opName;\n-        private final TypeElement type;\n-\n-        DNAOp(String opName, TypeElement type, List<Value> operands) {\n-            super(operands);\n-            this.opName = opName;\n-            this.type = type;\n-        }\n-\n-        @Override\n-        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-            throw new IllegalStateException(\"in transform\");\n-            \/\/  return null;\n-        }\n-\n-\n-        @Override\n-        public TypeElement resultType() {\n-            System.out.println(\"in result type\");\n-            return type;\n-        }\n-    }\n-\n-\n-    static public void main(String[] args) throws Exception {\n-        Method method = DNA.class.getDeclaredMethod(\"addMul\", int.class, int.class);\n-        var funcOp = Op.ofMethod(method).get();\n-        var here = CallSite.of(DNA.class, \"main\");\n-        var transformed = transform(here, funcOp,_->true,(builder, op) -> {\n-            CodeContext cc = builder.context();\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-               \/\/ List<Value> operands = new ArrayList<>();\n-                \/\/builder.op(new DNAOp(\"dna\", JavaType.INT, operands));\n-                List<Value> inputOperands = invokeOp.operands();\n-                List<Value> outputOperands = cc.getValues(inputOperands);\n-                Op.Result inputResult = invokeOp.result();\n-                Op.Result outputResult = builder.op(new DNAOp(\"dna\", JavaType.INT, outputOperands));\n-                cc.mapValue(inputResult, outputResult);\n-            } else {\n-                builder.op(op);\n-            }\n-            return builder;\n-        });\n-\n-\n-        System.out.println(transformed.toText());\n-\n-    }\n-}\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DNA.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -36,0 +36,5 @@\n+import hat.device.DeviceSchema;\n+import hat.device.DeviceType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import optkl.codebuilders.JavaCodeBuilder;\n@@ -46,0 +51,1 @@\n+import java.util.Map;\n@@ -57,1 +63,1 @@\n-    private interface SharedS32x256Array extends Buffer {\n+    private interface SharedS32x256Array extends DeviceType {\n@@ -62,1 +68,1 @@\n-        Schema<SharedS32x256Array> schema = Schema.of(SharedS32x256Array.class, $ -> $.array(\"array\", 32));\n+        DeviceSchema<SharedS32x256Array> schema = DeviceSchema.of(SharedS32x256Array.class, $ -> $.withArray(\"array\", 32));\n@@ -65,1 +71,1 @@\n-            return schema.allocate(accelerator); \/\/ Why would we get here?\n+           return null;\/\/ return schema.allocate(accelerator); \/\/ Why would we get here?\n@@ -369,2 +375,1 @@\n-    public static void main(String[] args) {\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+    public static void main(String[] args) throws ReflectiveOperationException {\n@@ -372,0 +377,6 @@\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var methodRef= MethodRef.method(PrefixSum.class, \"compute\", void.class, ComputeContext.class,S32Array.class);\n+        var funcOp = CoreOp.FuncOp.ofMethod(methodRef.resolveToMethod(MethodHandles.lookup())).get();\n+       Backend.injectBufferTracking(accelerator.config(),accelerator.lookup(),funcOp);\n+        JavaCodeBuilder jc = new JavaCodeBuilder(accelerator.lookup(),funcOp);\n+        System.out.println(jc.toText());\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-import hat.codebuilders.JavaHATCodeBuilder;\n-import optkl.Invoke;\n+import optkl.codebuilders.JavaCodeBuilder;\n@@ -32,1 +31,2 @@\n-import static optkl.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -67,1 +67,1 @@\n-        var javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,rsqrt);\n+        var javaCodeBuilder = new JavaCodeBuilder<>(lookup,rsqrt);\n@@ -75,2 +75,2 @@\n-        var abs = rsqrt.transform((builder,op)->{\n-            if (invokeOpHelper(lookup,op) instanceof Invoke ih\n+        var abs = rsqrt.transform(\"usingAbs\", (builder,op)->{\n+            if (invoke(lookup,op) instanceof Invoke ih\n@@ -90,1 +90,1 @@\n-        javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,abs);\n+        javaCodeBuilder = new JavaCodeBuilder<>(lookup,abs);\n@@ -95,3 +95,3 @@\n-        var newAbs =Trxfmr.of(rsqrt)\n-                .transform(ce-> Invoke.invokeOpHelper(lookup,ce) instanceof Invoke $\n-                                && $.named(Regex.of(\"sqrt\"))\n+        var newAbs =Trxfmr.of(lookup,rsqrt)\n+                .transform(\"usingAbs\",ce-> invoke(lookup,ce) instanceof Invoke $\n+                                && $.named(\"sqrt\")\n@@ -100,1 +100,2 @@\n-                                && $.receives(double.class), c->\n+                                && $.receives(double.class)\n+                        , c->\n@@ -109,1 +110,1 @@\n-        javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,newAbs);\n+        javaCodeBuilder = new JavaCodeBuilder<>(lookup,newAbs);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package experiments;\n-\n-\n-import java.lang.reflect.Method;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.MethodRef;\n-import optkl.util.CallSite;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-import static jdk.incubator.code.dialect.core.CoreType.FUNCTION_TYPE_VOID;\n-import static optkl.OpTkl.transform;\n-\n-public class Transform {\n-        @Reflect\n-        public static void removeMe(int size, int x, int y) {\n-\n-        }\n-\n-        @Reflect\n-        public static void matrixMultiply(float[] a, float[] b, float[] c, int size) {\n-            for (int i = 0; i < size; i++) {\n-                for (int j = 0; j < size; j++) {\n-                    float sum = 0f;\n-                    for (int k = 0; k < size; k++) {\n-                        sum += a[i * size + k] * b[k * size + j];\n-                    }\n-                    removeMe(1, 2, 3);\n-\n-                    c[i * size + j] = sum;\n-\n-                }\n-            }\n-        }\n-\n-        public static abstract class MyOp extends Op {\n-            private final String opName;\n-            private final TypeElement type;\n-\n-            MyOp(String opName) {\n-                super(List.of());\n-                this.opName = opName;\n-                this.type = FUNCTION_TYPE_VOID;\n-            }\n-\n-            MyOp(String opName, TypeElement type, List<Value> operands) {\n-                super(operands);\n-                this.opName = opName;\n-                this.type = type;\n-            }\n-\n-            MyOp(String opName, TypeElement type, List<Value> operands, Map<String, Object> attributes) {\n-                super(operands);\n-                this.opName = opName;\n-                this.type = type;\n-            }\n-\n-            MyOp(MyOp that, CodeContext cc) {\n-                super(that, cc);\n-                this.opName = that.opName;\n-                this.type = that.type;\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return type;\n-            }\n-        }\n-\n-\n-        public static class RootOp extends MyOp {\n-            public RootOp() {\n-                super(\"Root\");\n-            }\n-\n-            public RootOp(MyOp that, CodeContext cc) {\n-                super(that, cc);\n-            }\n-\n-            @Override\n-            public Op transform(CodeContext cc, CodeTransformer ot) {\n-                return new RootOp(this, cc);\n-            }\n-        }\n-\n-        public static void pre() {\n-        }\n-\n-        ;\n-\n-        public static void post() {\n-        }\n-\n-        ;\n-\n-        public static final MethodRef PRE = MethodRef.method(Transform.class, \"pre\", void.class);\n-        public static final MethodRef POST = MethodRef.method(Transform.class, \"post\", void.class);\n-\n-        static public void main(String[] args) throws Exception {\n-            String methodName = \"matrixMultiply\";\n-            Method method = Transform.class.getDeclaredMethod(methodName, float[].class, float[].class, float[].class, int.class);\n-\n-            CoreOp.FuncOp javaFunc = Op.ofMethod(method).get();\n-\n-            var here = CallSite.of(Transform.class, \"main\");\n-            CoreOp.FuncOp transformed = transform(here, javaFunc,_->true,(builder, op) -> {\n-                if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                    \/\/  CodeContext cc = builder.context();\n-                    \/\/  Block.Builder bb = builder;\n-                    \/\/ var invokePre = CoreOp.invoke(PRE);\n-                    RootOp rootOp = new RootOp();\n-                   \/\/ builder.body(op.bodies().getFirst(),List.of(), this);\n-                    builder.op(op);\n-                    \/\/ builder.op(rootOp);\n-                    \/\/  builder.op(invokeOp);\n-                    \/\/  builder.op(CoreOp.invoke(POST));\n-                } else {\n-                    builder.op(op);\n-                }\n-                return builder;\n-            });\n-\n-            System.out.println(transformed.toText());\n-\n-        }\n-}\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -308,1 +308,1 @@\n-    static F32Array2D createF32Array2D(ComputeContext cc, int width, int height) {\n+    public static F32Array2D createF32Array2D(ComputeContext cc, int width, int height) {\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Field;\n-\n-import static optkl.OpTkl.classTypeToTypeOrThrow;\n-\n-public interface FieldAccess extends OpHelper<JavaOp.FieldAccessOp>{\n-\n-    @Override\n-    default  String name(){\n-        return op().fieldDescriptor().name();\n-    }\n-\n-    default boolean isPrimitive(){\n-        return op().result().type() instanceof PrimitiveType;\n-    }\n-\n-    default TypeElement refType(){\n-        return op().fieldDescriptor().refType();\n-    }\n-    default boolean refType(Class<?> ... classes){\n-        return OpTkl.isAssignable(lookup(),refType(),classes);\n-    }\n-    default  Object getStaticFinalPrimitiveValue() {\n-        if (refType() instanceof ClassType classType) {\n-            Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n-            try {\n-                Field field = clazz.getField(name());\n-                field.setAccessible(true);\n-                return field.get(null);\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-        throw new RuntimeException(\"Could not find field value\" + op());\n-    }\n-\n-    static FieldAccess fieldAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-        record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements FieldAccess {}\n-        return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp? new Impl(lookup,fieldAccessOp): null;\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/FieldAccess.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.core.VarType;\n-import jdk.incubator.code.dialect.java.ArrayType;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-import optkl.ifacemapper.MappableIface;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n-\n-\n-public interface Invoke extends OpHelper<JavaOp.InvokeOp>{\n-\n-    static Stream<Invoke> stream(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n-       return  funcOp.elements().filter(ce->ce instanceof JavaOp.InvokeOp).map(ce->invokeOpHelper(lookup,ce));\n-    }\n-\n-    default  boolean isStatic(){\n-        return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n-    }\n-     default  boolean isInstance(){\n-        return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n-    }\n-    @Override default String name(){\n-        return op().invokeDescriptor().name();\n-    }\n-    default <T>boolean returns(Class<T> clazz){\n-        return isAssignable((JavaType)op().resultType(),clazz);\n-    }\n-    default boolean receives(Class<?>... classes){\n-        boolean  assignable = true;\n-        for (int i=isStatic()?1:0; assignable && i< classes.length; i++) {\n-            var operand = op().operands().get(i);\n-            TypeElement resultType = operand.type() instanceof VarType varType?varType.valueType():null;\n-            assignable &= isAssignable((JavaType) resultType,classes[i-(isStatic()?1:0)]);\n-        }\n-        return assignable;\n-    }\n-\n-    default Method resolvedMethodOrNull(){\n-        try {\n-            return op().invokeDescriptor().resolveToMethod(lookup()) instanceof Method method ? method : null;\n-        }catch (ReflectiveOperationException rope){\n-            return null;\n-        }\n-    }\n-\n-     static Invoke invokeOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-        record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Invoke {}\n-\n-        return codeElement instanceof JavaOp.InvokeOp invokeOp? new Impl(lookup,invokeOp): null;\n-    }\n-\n-     default boolean refIs(Class<?> ...classes) {\n-        return OpTkl.isAssignable(lookup(), op().invokeDescriptor().refType(), classes);\n-    }\n-\n-     default boolean returnsArray() {\n-        return op().resultType() instanceof ArrayType;\n-    }\n-\n-     default boolean returnsVoid() {\n-        return op().invokeDescriptor().type().returnType().equals(JavaType.VOID);\n-    }\n-\n-     default   TypeElement returnType() {\n-        return op().invokeDescriptor().type().returnType();\n-    }\n-\n-    default boolean returnsInt(){\n-        return returnType().equals(JavaType.INT);\n-    }\n-\n-\n-\n-    default boolean returnsClassType(){\n-        return returnType() instanceof ClassType;\n-    }\n-\n-\n-    default TypeElement refType(){\n-        return op().invokeDescriptor().refType();\n-    }\n-\n-    default boolean returnsPrimitive(){\n-        return returnType() instanceof PrimitiveType ;\n-    }\n-    default boolean returnsFloat(){\n-        return returnType() == JavaType.FLOAT;\n-    }\n-    default boolean returnsChar(){\n-       return returnType() ==   JavaType.CHAR;\n-    }\n-    default boolean returnsShort(){\n-        return returnType() ==   JavaType.SHORT ;\n-    }\n-    default boolean returns16BitValue(){\n-        return returnsChar()||returnsShort();\n-    }\n-    default Method resolveMethodOrNull() {\n-        try {\n-            return op().invokeDescriptor().resolveToMethod(lookup());\n-        } catch (ReflectiveOperationException e) {\n-           return null;\n-        }\n-    }\n-    default Method resolveMethodOrThrow() {\n-        try {\n-            return op().invokeDescriptor().resolveToMethod(lookup());\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    default Class<?> classOrThrow() {\n-        if (refType() instanceof ClassType classType) {\n-            return (Class<?>) OpTkl.classTypeToTypeOrThrow(lookup(), classType);\n-        } else {\n-            throw new IllegalStateException(\" javaRef class is null\");\n-        }\n-    }\n-\n-    default boolean isMappableIface() {\n-        return refIs(MappableIface.class);\n-    }\n-    static Invoke getTargetInvoke(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n-        return lambdaOp.body().entryBlock().ops().stream()\n-                .filter(ce -> ce instanceof JavaOp.InvokeOp)\n-                .map(ce -> invokeOpHelper(lookup,ce))\n-                .filter(Invoke::isStatic)\n-                .filter(invoke -> OpTkl.isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n-                .findFirst()\n-                .orElseThrow();\n-    }\n-\n-\n-\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Invoke.java","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -27,0 +27,3 @@\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.CodeElement;\n@@ -28,0 +31,8 @@\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.ArrayType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -29,0 +40,3 @@\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+import optkl.ifacemapper.AccessType;\n+import optkl.ifacemapper.MappableIface;\n@@ -31,2 +45,1 @@\n-import java.util.function.Predicate;\n-\n+import optkl.util.ops.StatementLikeOp;\n@@ -34,2 +47,14 @@\n-public interface OpHelper<T extends Op> extends LookupCarrier {\n-    T op();\n+import java.lang.annotation.Annotation;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n@@ -37,1 +62,0 @@\n-    String name();\n@@ -39,2 +63,4 @@\n-    default boolean named(Regex regex){\n-        return regex.matches(name());\n+public sealed interface OpHelper<T extends Op> extends LookupCarrier permits OpHelper.Lambda, OpHelper.Named, OpHelper.Ternary {\n+    static <F extends Op, T extends Op> T copyLocation(F from, T to) {\n+        to.setLocation(from.location());\n+        return to;\n@@ -42,5 +68,5 @@\n-    default boolean named(String name){\n-        return name().equals(name);\n-    }\n-    default boolean named(Predicate<String> predicate){\n-        return predicate.test(name());\n+\n+    T op();\n+    default   <TO extends Op> TO copyLocationTo(TO to) {\n+        to.setLocation(op().location());\n+        return to;\n@@ -48,1 +74,1 @@\n-    default <C>boolean isAssignable(JavaType javaType, Class<C> clazz){\n+    static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n@@ -50,10 +76,1 @@\n-            boolean isit1=  OpTkl.isAssignable(lookup(),javaType,clazz);\n-            var basicType = javaType.toBasicType();\n-            var resolveType = basicType.resolve(lookup());\n-            var isit2 = resolveType.getTypeName().equals(clazz.getName());\n-            var resolveTypeClass = resolveType.getClass();\n-            var isit3 = clazz.isAssignableFrom(resolveTypeClass);\n-            var isit4 = resolveTypeClass.isAssignableFrom(clazz);\n-            \/\/ System.out.println(\"isit1=\"+isit1+\",isit2=\"+isit2+\",isit3=\"+isit3+\",isit4=\"+isit4);\n-            return  isit2;\n-\n+            return classType.resolve(lookup);\n@@ -61,1 +78,0 @@\n-            System.out.println(\"Hmm\");\n@@ -65,0 +81,24 @@\n+\n+    static boolean isAssignable(MethodHandles.Lookup lookup, TypeElement typeElement, Class<?>... classes) {\n+        if (typeElement instanceof ClassType classType) {\n+            Type type = classTypeToTypeOrThrow(lookup, classType);\n+            return Arrays.stream(classes).anyMatch(clazz -> clazz.isAssignableFrom((Class<?>) type));\n+        }else if (typeElement instanceof PrimitiveType){\n+            return Arrays.stream(classes).anyMatch(clazz ->\n+                           (typeElement == JavaType.FLOAT && clazz.equals(float.class))\n+                        || (typeElement == JavaType.DOUBLE && clazz.equals(double.class))\n+                        || (typeElement == JavaType.INT && clazz.equals(int.class))\n+                        || (typeElement == JavaType.LONG && clazz.equals(long.class))\n+                        || (typeElement == JavaType.SHORT && clazz.equals(short.class))\n+                        || (typeElement == JavaType.CHAR && clazz.equals(char.class))\n+                        || (typeElement == JavaType.BYTE && clazz.equals(byte.class))\n+                        || (typeElement == JavaType.BOOLEAN && clazz.equals(boolean.class))\n+                        || (typeElement == JavaType.VOID && clazz.equals(void.class))\n+            );\n+        }\n+        return false;\n+    }\n+\n+     default <C>boolean isAssignable(JavaType javaType, Class<C> clazz){\n+            return  OpHelper.isAssignable(lookup(),javaType,clazz);\n+    }\n@@ -68,0 +108,1 @@\n+\n@@ -69,1 +110,1 @@\n-        return OpTkl.operandAsResult(op(),i) instanceof Op.Result result?result:null;\n+        return operandNAsResult(op(),i) instanceof Op.Result result?result:null;\n@@ -71,1 +112,1 @@\n-    default Op.Result firstOperandAsResultOrNull(int i){\n+    default Op.Result firstOperandAsResultOrNull(){\n@@ -74,0 +115,1 @@\n+\n@@ -81,4 +123,0 @@\n-    default Op.Result firstOperandAsResultOrThrow(){\n-        return operandNAsResultOrThrow(0);\n-    }\n-\n@@ -101,0 +139,388 @@\n+    default CoreOp.VarAccessOp.VarLoadOp varLoadOpFromFirstOperandAsResultOrNull(){\n+           return opFromFirstOperandAsResultOrThrow()\n+                instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp?varLoadOp:null;\n+    }\n+    static Block entryBlockOfBodyN(Op op, int idx) {\n+        return op.bodies().get(idx).entryBlock();\n+    }\n+\n+\n+    static boolean isPrimitiveResult(Value val) {\n+        return ((val instanceof Op.Result result && result.op().resultType() instanceof PrimitiveType primitiveType)?primitiveType:null) != null;\n+    }\n+\n+    static Op.Result asResultOrThrow(Value value) {\n+        if (value instanceof Op.Result result) {\n+            return result;\n+        } else {\n+            throw new RuntimeException(\"Value not a result\");\n+        }\n+    }\n+\n+    static Op.Result operandNAsResult(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n+        return codeElement instanceof Op op && op.operands().size() > n && op.operands().get(n) instanceof Op.Result result ? result : null;\n+    }\n+\n+    static Op.Result asResultOrNull(Value operand) {\n+        return operand instanceof Op.Result result ? result : null;\n+    }\n+\n+    static Op asOpFromResultOrNull(Value operand) {\n+        return asResultOrNull(operand) instanceof Op.Result r && r.op() instanceof Op op ? op : null;\n+    }\n+\n+    static Op.Result lhsResult(JavaOp.BinaryOp binaryOp) {\n+        return (Op.Result) binaryOp.operands().get(0);\n+    }\n+\n+    static Op.Result rhsResult(JavaOp.BinaryOp binaryOp) {\n+        return (Op.Result) binaryOp.operands().get(1);\n+    }\n+\n+    static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n+        return javaConditionalOp.bodies().get(0).entryBlock().ops();\n+    }\n+    static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n+        return javaConditionalOp.bodies().get(1).entryBlock().ops();\n+    }\n+\n+    static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n+        return (Op.Result) binaryTestOp.operands().get(0);\n+    }\n+\n+    static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n+        return (Op.Result) binaryTestOp.operands().get(1);\n+    }\n+\n+    sealed interface Named<T extends Op> extends OpHelper<T>\n+            permits Named.NamedStaticOrInstance, Named.Var, Named.VarAccess {\n+        String name();\n+        default boolean named(Regex regex){\n+            return regex.matches(name());\n+        }\n+        default boolean named( String...names){\n+           return Set.of(names).contains(name());\n+        }\n+        default boolean named(Predicate<String> predicate){\n+            return predicate.test(name());\n+        }\n+\n+        sealed interface VarAccess extends Named<CoreOp.VarAccessOp> {\n+            @Override\n+            default  String name(){\n+                return op().varOp().varName();\n+            }\n+\n+            default  <T>boolean of(Class<T> clazz){\n+                return isAssignable((JavaType) op().resultType(),clazz);\n+            }\n+            record Impl(MethodHandles.Lookup lookup, CoreOp.VarAccessOp op) implements VarAccess {}\n+            static VarAccess varAccess(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement) {\n+                return codeElement instanceof CoreOp.VarAccessOp varAccessOp ? new VarAccess.Impl(lookup, varAccessOp) : null;\n+            }\n+            static Stream<VarAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+                return funcOp.elements().filter(ce -> ce instanceof CoreOp.VarAccessOp).map(ce -> varAccess(lookup, ce));\n+            }\n+        }\n+        sealed interface Var extends Named<CoreOp.VarOp> {\n+            @Override\n+            default  String name(){\n+                return op().varName();\n+            }\n+\n+            default  <T>boolean of(Class<T> clazz){\n+                return isAssignable((JavaType) op().varValueType(),clazz);\n+            }\n+            record Impl(MethodHandles.Lookup lookup, CoreOp.VarOp op) implements Var {}\n+            static Var var(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement) {\n+                return codeElement instanceof CoreOp.VarOp varOp ? new Var.Impl(lookup, varOp) : null;\n+            }\n+            static Stream<Var> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+                return funcOp.elements().filter(ce -> ce instanceof CoreOp.VarOp).map(ce -> var(lookup, ce));\n+            }\n+        }\n+\n+        sealed interface NamedStaticOrInstance<T extends Op> extends Named<T> {\n+             boolean isStatic();\n+\n+             boolean isInstance();\n+             default Op.Result instance(){\n+                if (isInstance()){\n+                    return (Op.Result) op().operands().getFirst();\n+                }else {\n+                    return null;\n+                }\n+            }\n+            default Op instanceOp(){\n+                return instance() instanceof Op.Result result? result.op():null;\n+            }\n+\n+            default VarAccess instanceVarAccess(){\n+                 return instanceOp() instanceof CoreOp.VarAccessOp varAccessOp && VarAccess.varAccess(lookup(),varAccessOp) instanceof VarAccess varAccess?varAccess:null;\n+            }\n+            default boolean isInstanceAccessedViaVarAccess(){\n+                return instanceVarAccess()!=null;\n+            }\n+            sealed interface FieldAccess extends NamedStaticOrInstance<JavaOp.FieldAccessOp> {\n+\n+                @Override\n+                default String name() {\n+                    return op().fieldDescriptor().name();\n+                }\n+\n+                @Override default boolean isStatic() {\n+                    return operandCount()==0;\n+                }\n+\n+                @Override default boolean isInstance() {\n+                    return !isStatic();\n+                }\n+                default boolean isPrimitive() {\n+                    return op().result().type() instanceof PrimitiveType;\n+                }\n+\n+                default TypeElement resultType() {\n+                    return op().resultType();\n+                }\n+\n+                default TypeElement refType() {\n+                    return op().fieldDescriptor().refType();\n+                }\n+\n+                default boolean refType(Class<?>... classes) {\n+                    return OpHelper.isAssignable(lookup(), refType(), classes);\n+                }\n+\n+                default Object getStaticFinalPrimitiveValue() {\n+                    if (refType() instanceof ClassType classType) {\n+                        Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n+                        try {\n+                            Field field = clazz.getField(name());\n+                            field.setAccessible(true);\n+                            return field.get(null);\n+                        } catch (NoSuchFieldException | IllegalAccessException e) {\n+                            try {\n+                                Field field = clazz.getDeclaredField(name());\n+                                field.setAccessible(true);\n+                                return field.get(null);\n+                            } catch (NoSuchFieldException | IllegalAccessException e2) {\n+                                throw new RuntimeException(e2);\n+                            }\n+                        }\n+                    }\n+                    throw new RuntimeException(\"Could not find field value\" + op());\n+                }\n+                default boolean isLoad(){\n+                    return op() instanceof JavaOp.FieldAccessOp.FieldLoadOp;\n+                }\n+                default boolean isStore(){\n+                    return op() instanceof JavaOp.FieldAccessOp.FieldStoreOp;\n+                }\n+                record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements FieldAccess {\n+                }\n+                static FieldAccess fieldAccess(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+                    return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp ? new FieldAccess.Impl(lookup, fieldAccessOp) : null;\n+                }\n+                static Stream<FieldAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+                    return funcOp.elements().filter(ce -> ce instanceof JavaOp.FieldAccessOp).map(ce -> fieldAccess(lookup, ce));\n+                }\n+            }\n+\n+            sealed interface Invoke extends NamedStaticOrInstance<JavaOp.InvokeOp> {\n+                static Stream<Invoke> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+                    return funcOp.elements().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> invoke(lookup, ce));\n+                }\n+\n+                @Override default boolean isStatic() {\n+                    return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n+                }\n+\n+                @Override default boolean isInstance() {\n+                    return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n+                }\n+\n+                @Override\n+                default String name() {\n+                    return op().invokeDescriptor().name();\n+                }\n+\n+                default <T> boolean returns(Class<T> clazz) {\n+                    return isAssignable((JavaType) op().resultType(), clazz);\n+                }\n+\n+                default boolean receives(Class<?>... classes) {\n+                    boolean assignable = true;\n+                    for (int i = isStatic() ? 1 : 0; assignable && i < classes.length; i++) {\n+                        var operand = op().operands().get(i);\n+                        TypeElement resultType = operand.type() instanceof VarType varType ? varType.valueType() : null;\n+                        assignable &= isAssignable((JavaType) resultType, classes[i - (isStatic() ? 1 : 0)]);\n+                    }\n+                    return assignable;\n+                }\n+\n+                default Method resolvedMethodOrNull() {\n+                    try {\n+                        return op().invokeDescriptor().resolveToMethod(lookup()) instanceof Method method ? method : null;\n+                    } catch (ReflectiveOperationException rope) {\n+                        return null;\n+                    }\n+                }\n+\n+\n+                default boolean refIs(Class<?>... classes) {\n+                    return OpHelper.isAssignable(lookup(), op().invokeDescriptor().refType(), classes);\n+                }\n+\n+                default boolean returnsArray() {\n+                    return op().resultType() instanceof ArrayType;\n+                }\n+\n+                default boolean returnsVoid() {\n+                    return op().invokeDescriptor().type().returnType().equals(JavaType.VOID);\n+                }\n+\n+                default TypeElement returnType() {\n+                    return op().invokeDescriptor().type().returnType();\n+                }\n+\n+                default boolean returnsInt() {\n+                    return returnType().equals(JavaType.INT);\n+                }\n+\n+\n+                default boolean returnsClassType() {\n+                    return returnType() instanceof ClassType;\n+                }\n+\n+\n+                default TypeElement refType() {\n+                    return op().invokeDescriptor().refType();\n+                }\n+\n+                default boolean returnsPrimitive() {\n+                    return returnType() instanceof PrimitiveType;\n+                }\n+\n+                default boolean returnsFloat() {\n+                    return returnType() == JavaType.FLOAT;\n+                }\n+\n+                default boolean returnsChar() {\n+                    return returnType() == JavaType.CHAR;\n+                }\n+\n+                default boolean returnsShort() {\n+                    return returnType() == JavaType.SHORT;\n+                }\n+\n+                default boolean returns16BitValue() {\n+                    return returnsChar() || returnsShort();\n+                }\n+\n+                default Method resolveMethodOrNull() {\n+                    try {\n+                        return op().invokeDescriptor().resolveToMethod(lookup());\n+                    } catch (ReflectiveOperationException e) {\n+                        return null;\n+                    }\n+                }\n+\n+                default Method resolveMethodOrThrow() {\n+                    try {\n+                        return op().invokeDescriptor().resolveToMethod(lookup());\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+\n+                default Class<?> classOrThrow() {\n+                    if (refType() instanceof ClassType classType) {\n+                        return (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n+                    } else {\n+                        throw new IllegalStateException(\" javaRef class is null\");\n+                    }\n+                }\n+\n+                default boolean isMappableIface() {\n+                    return refIs(MappableIface.class);\n+                }\n+\n+                default List<AccessType.TypeAndAccess> paramaterAccessList() {\n+                    Annotation[][] parameterAnnotations = resolveMethodOrThrow().getParameterAnnotations();\n+                    int firstParam = isInstance() ? 1 : 0; \/\/ if virtual\n+                    List<AccessType.TypeAndAccess> typeAndAccesses = new ArrayList<>();\n+                    for (int i = firstParam; i < operandCount(); i++) {\n+                        typeAndAccesses.add(AccessType.TypeAndAccess.of(parameterAnnotations[i - firstParam], op().operands().get(i)));\n+                    }\n+                    return typeAndAccesses;\n+                }\n+\n+\n+                record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Invoke {\n+                }\n+\n+                static Invoke invoke(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+                    return codeElement instanceof JavaOp.InvokeOp invokeOp ? new Impl(lookup, invokeOp) : null;\n+                }\n+\n+                default Op.Result returnResult() {\n+                    return op().result();\n+                }\n+\n+                static Invoke getTargetInvoke(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n+                    return lambdaOp.body().entryBlock().ops().stream()\n+                            .filter(ce -> ce instanceof JavaOp.InvokeOp)\n+                            .map(ce -> invoke(lookup, ce))\n+                            .filter(Invoke::isStatic)\n+                            .filter(invoke -> OpHelper.isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n+                            .findFirst()\n+                            .orElseThrow();\n+                }\n+            }\n+        }\n+    }\n+\n+    interface Statement {\n+\n+       private  static Op asStatementOpOrNull(CodeElement<?, ?> ce) {\n+            if (ce instanceof Op op) {\n+                return (\n+                        (\n+                                (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n+                                        || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n+                                        || (op instanceof StatementLikeOp)\n+                        )\n+                                && !(op instanceof CoreOp.VarOp varOp && (!varOp.isUninitialized()\n+                                && varOp.operands().getFirst() instanceof Block.Parameter parameter\n+                                && parameter.invokableOperation() instanceof CoreOp.FuncOp)\n+                        )\n+                                && !(op instanceof CoreOp.YieldOp)\n+                )\n+                        ? op\n+                        : null;\n+            } else {\n+                return null;\n+            }\n+\n+        }\n+\n+       private static boolean isStatementOp(CodeElement<?, ?> ce) {\n+            return Objects.nonNull(asStatementOpOrNull(ce));\n+        }\n+\n+        static Stream<Op> statements(Block block) {\n+            return block.ops().stream().filter(Statement::isStatementOp);\n+        }\n+\n+        static Stream<Op> bodyStatements(Body body) {\n+            var list = new ArrayList<>(statements(body.entryBlock()).toList());\n+            if (list.getLast() instanceof JavaOp.ContinueOp) {\n+                list.removeLast();\n+            }\n+            return list.stream();\n+        }\n+        static Stream<Op> loopBodyStatements(Op.Loop op) {\n+           return bodyStatements(op.loopBody());\n+        }\n+\n+    }\n@@ -102,0 +528,60 @@\n+    sealed interface Ternary extends OpHelper<JavaOp.ConditionalExpressionOp>{\n+        default  <T>boolean of(Class<T> clazz){\n+            return isAssignable((JavaType) op().resultType(),clazz);\n+        }\n+\n+        default Block condBlock() {return OpHelper.entryBlockOfBodyN(op(), 0);}\n+\n+        default Block thenBlock() {\n+            return OpHelper.entryBlockOfBodyN(op(), 1);\n+        }\n+\n+        default Block elseBlock() {\n+            return OpHelper.entryBlockOfBodyN(op(), 2);\n+        }\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.ConditionalExpressionOp op) implements Ternary {}\n+        static Ternary ternary(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+            return codeElement instanceof JavaOp.ConditionalExpressionOp op? new Impl(lookup,op): null;\n+        }\n+    }\n+\n+    sealed interface Lambda extends OpHelper<JavaOp.LambdaOp>{\n+        default  <T>boolean of(Class<T> clazz){\n+            return isAssignable((JavaType) op().resultType(),clazz);\n+        }\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.LambdaOp op) implements Lambda {}\n+        static Lambda lambdaOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+            return codeElement instanceof JavaOp.LambdaOp lambdaOp? new Impl(lookup,lambdaOp): null;\n+        }\n+\n+        default Object[] getQuotedCapturedValues(Quoted quoted, Method method) {\n+            var block = op().body().entryBlock();\n+            var ops = block.ops();\n+            Object[] varLoadNames = ops.stream()\n+                    .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                    .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n+                    .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n+                    .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n+                    .map(CoreOp.VarOp::varName).toArray();\n+            Map<String, Object> nameValueMap = new HashMap<>();\n+\n+            quoted.capturedValues().forEach((k, v) -> {\n+                if (k instanceof Op.Result result) {\n+                    if (result.op() instanceof CoreOp.VarOp varOp) {\n+                        nameValueMap.put(varOp.varName(), v);\n+                    }\n+                }\n+            });\n+            Object[] args = new Object[method.getParameterCount()];\n+            if (args.length != varLoadNames.length) {\n+                throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n+            }\n+            for (int i = 1; i < args.length; i++) {\n+                args[i] = nameValueMap.get(varLoadNames[i].toString());\n+                if (args[i] instanceof CoreOp.Var<?> var) {\n+                    args[i] = var.value();\n+                }\n+            }\n+            return args;\n+        }\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":516,"deletions":30,"binary":false,"changes":546,"status":"modified"},{"patch":"@@ -1,360 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-import optkl.util.CallSite;\n-import optkl.util.ops.StatementLikeOp;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n-\n-\n-public interface OpTkl {\n-\n-    static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n-        try {\n-            return classType.resolve(lookup);\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static boolean isAssignable(MethodHandles.Lookup lookup, TypeElement typeElement, Class<?>... classes) {\n-        if (typeElement instanceof ClassType classType) {\n-            Type type = classTypeToTypeOrThrow(lookup, classType);\n-            return Arrays.stream(classes).anyMatch(clazz -> clazz.isAssignableFrom((Class<?>) type));\n-        }\n-        return false;\n-\n-    }\n-\n-\n-\n-    static Object[] getQuotedCapturedValues(JavaOp.LambdaOp lambdaOp, Quoted quoted, Method method) {\n-        var block = lambdaOp.body().entryBlock();\n-        var ops = block.ops();\n-        Object[] varLoadNames = ops.stream()\n-                .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n-                .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n-                .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n-                .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n-                .map(CoreOp.VarOp::varName).toArray();\n-        Map<String, Object> nameValueMap = new HashMap<>();\n-\n-        quoted.capturedValues().forEach((k, v) -> {\n-            if (k instanceof Op.Result result) {\n-                if (result.op() instanceof CoreOp.VarOp varOp) {\n-                    nameValueMap.put(varOp.varName(), v);\n-                }\n-            }\n-        });\n-        Object[] args = new Object[method.getParameterCount()];\n-        if (args.length != varLoadNames.length) {\n-            throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n-        }\n-        for (int i = 1; i < args.length; i++) {\n-            args[i] = nameValueMap.get(varLoadNames[i].toString());\n-            if (args[i] instanceof CoreOp.Var varbox) {\n-                args[i] = varbox.value();\n-            }\n-        }\n-        return args;\n-    }\n-\n-\n-\n-    static Op.Result lhsResult(JavaOp.BinaryOp binaryOp) {\n-        return (Op.Result) binaryOp.operands().get(0);\n-    }\n-\n-    static Op.Result rhsResult(JavaOp.BinaryOp binaryOp) {\n-        return (Op.Result) binaryOp.operands().get(1);\n-    }\n-\n-    static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx) {\n-        return javaConditionalOp.bodies().get(idx).entryBlock().ops();\n-    }\n-\n-    static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n-        return ops(javaConditionalOp, 0);\n-    }\n-\n-    static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n-        return ops(javaConditionalOp, 1);\n-    }\n-\n-    static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx) {\n-        return (Op.Result) binaryTestOp.operands().get(idx);\n-    }\n-\n-    static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n-        return result(binaryTestOp, 0);\n-    }\n-\n-    static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n-        return result(binaryTestOp, 1);\n-    }\n-\n-    static Op.Result result(JavaOp.ConvOp convOp) {\n-        return (Op.Result) convOp.operands().getFirst();\n-    }\n-\n-    static Op.Result result(CoreOp.ReturnOp returnOp) {\n-        return (Op.Result) returnOp.operands().getFirst();\n-    }\n-\n-    static Block block(JavaOp.ConditionalExpressionOp ternaryOp, int idx) {\n-        return ternaryOp.bodies().get(idx).entryBlock();\n-    }\n-\n-    static Block condBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n-        return block(ternaryOp, 0);\n-    }\n-\n-    static Block thenBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n-        return block(ternaryOp, 1);\n-    }\n-\n-    static Block elseBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n-        return block(ternaryOp, 2);\n-    }\n-\n-\n-    static Value operandOrNull(Op op, int idx) {\n-        return op.operands().size() > idx ? op.operands().get(idx) : null;\n-    }\n-\n-    static Block block(JavaOp.ForOp forOp, int idx) {\n-        return forOp.bodies().get(idx).entryBlock();\n-    }\n-\n-    static Block mutateBlock(JavaOp.ForOp forOp) {\n-        return block(forOp, 2);\n-    }\n-\n-    static Block condBlock(JavaOp.ForOp forOp) {\n-        return forOp.cond().entryBlock();\n-    }\n-\n-    static Block initBlock(JavaOp.ForOp forOp) {\n-        return forOp.init().entryBlock();\n-    }\n-\n-    static Block block(JavaOp.WhileOp whileOp, int idx) {\n-        return whileOp.bodies().get(idx).entryBlock();\n-    }\n-\n-    static Block condBlock(JavaOp.WhileOp whileOp) {\n-        return block(whileOp, 0);\n-    }\n-\n-\n-    static PrimitiveType asPrimitiveResultOrNull(Value v) {\n-        return (v instanceof Op.Result r && r.op().resultType() instanceof PrimitiveType primitiveType)?primitiveType:null;\n-    }\n-\n-    static boolean isPrimitiveResult(Value v) {\n-        return (asPrimitiveResultOrNull(v) != null);\n-    }\n-\n-    static Op.Result asResultOrThrow(Value value) {\n-        if (value instanceof Op.Result r) {\n-            return r;\n-        } else {\n-            throw new RuntimeException(\"Value not a result\");\n-        }\n-    }\n-\n-    static Stream<Op.Result> operandsAsResults(jdk.incubator.code.CodeElement<?, ?> codeElement) {\n-        return codeElement instanceof Op ?\n-                ((Op) codeElement).operands().stream().filter(o -> o instanceof Op.Result).map(o -> (Op.Result) o)\n-                : Stream.of();\n-    }\n-\n-    static Op.Result operandAsResult(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n-        return codeElement instanceof Op op && op.operands().size() > n && op.operands().get(n) instanceof Op.Result result ? result : null;\n-    }\n-\n-    static Op.Result asResultOrNull(Value operand) {\n-        return operand instanceof Op.Result result ? result : null;\n-    }\n-\n-    static Op asOpFromResultOrNull(Value operand) {\n-        return asResultOrNull(operand) instanceof Op.Result r && r.op() instanceof Op op ? op : null;\n-    }\n-\n-    static Op opOfResultOrNull(Op.Result result) {\n-        return result.op() instanceof Op op ? op : null;\n-    }\n-\n-    static CoreOp.VarAccessOp.VarLoadOp asVarLoadOrNull(Op op) {\n-        return op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp ? varLoadOp : null;\n-    }\n-\n-    static boolean resultType(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp, Class<?>... classes) {\n-        return isAssignable(lookup, varLoadOp.resultType(), classes);\n-    }\n-\n-    static Stream<Op> loopBodyStatements(Op.Loop op) {\n-        var list = new ArrayList<>(statements(op.loopBody().entryBlock()).toList());\n-        if (list.getLast() instanceof JavaOp.ContinueOp) {\n-            list.removeLast();\n-        }\n-        return list.stream();\n-    }\n-\n-    static Op asStatementOpOrNull(CodeElement<?, ?> ce) {\n-        if (ce instanceof Op op) {\n-            return (\n-                    (\n-                            (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n-                                    || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n-                                    || (op instanceof StatementLikeOp)\n-                    )\n-                            && !(op instanceof CoreOp.VarOp varOp && isParamVar(varOp))\/\/..ParamVar.of(varOp) != null)\n-                            && !(op instanceof CoreOp.YieldOp)\n-            )\n-                    ? op\n-                    : null;\n-        } else {\n-            return null;\n-        }\n-\n-    }\n-\n-    static boolean isStatementOp(CodeElement<?, ?> ce) {\n-        return Objects.nonNull(asStatementOpOrNull(ce));\n-    }\n-\n-    static Stream<Op> statements(Block block) {\n-        return block.ops().stream().filter(OpTkl::isStatementOp);\n-    }\n-\n-    static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        return funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-    }\n-\n-    static Stream<jdk.incubator.code.CodeElement<?, ?>> elements(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        return funcOp.elements();\n-    }\n-\n-    static <T extends Op> Stream<T> ops(CallSite callSite, CoreOp.FuncOp funcOp,\n-                                        Predicate<jdk.incubator.code.CodeElement<?, ?>> predicate,\n-                                        Function<CodeElement<?, ?>, T> mapper\n-    ) {\n-        if (callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        return funcOp.elements().filter(predicate).map(mapper);\n-    }\n-\n-\n-    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<Op> predicate, CodeTransformer CodeTransformer) {\n-        if (callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        return funcOp.transform((blockBuilder, op) -> {\n-            if (predicate.test(op)) {\n-                var builder = CodeTransformer.acceptOp(blockBuilder, op);\n-                if (builder != blockBuilder) {\n-                    throw new RuntimeException(\"Where does this builder come from \" + builder);\n-                }\n-            } else {\n-                blockBuilder.op(op);\n-            }\n-            return blockBuilder;\n-        });\n-    }\n-\n-    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, CodeTransformer CodeTransformer) {\n-        if (callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        return funcOp.transform(CodeTransformer);\n-    }\n-\n-\n-    static Class<?> typeElementToClass(MethodHandles.Lookup lookup, TypeElement type) {\n-        class PrimitiveHolder {\n-            static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n-                    JavaType.BYTE, byte.class,\n-                    JavaType.SHORT, short.class,\n-                    JavaType.INT, int.class,\n-                    JavaType.LONG, long.class,\n-                    JavaType.FLOAT, float.class,\n-                    JavaType.DOUBLE, double.class,\n-                    JavaType.CHAR, char.class,\n-                    JavaType.BOOLEAN, boolean.class\n-            );\n-        }\n-        try {\n-            if (type instanceof PrimitiveType primitiveType) {\n-                return PrimitiveHolder.primitiveToClass.get(primitiveType);\n-            } else if (type instanceof ClassType classType) {\n-                return ((Class<?>) classType.resolve(lookup));\n-            } else {\n-                throw new IllegalArgumentException(\"given type cannot be converted to class\");\n-            }\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(\"given type cannot be converted to class\");\n-        }\n-    }\n-\n-    static boolean isParamVar(CoreOp.VarOp varOp) {\n-        return !varOp.isUninitialized()\n-                && varOp.operands().getFirst() instanceof Block.Parameter parameter\n-                && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp;\n-    }\n-}\n-\n-\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":0,"deletions":360,"binary":false,"changes":360,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -34,0 +35,1 @@\n+import optkl.codebuilders.JavaCodeBuilder;\n@@ -36,0 +38,2 @@\n+import optkl.util.OpCodeBuilder;\n+import optkl.util.carriers.LookupCarrier;\n@@ -37,1 +41,1 @@\n-import java.util.LinkedHashSet;\n+import java.lang.invoke.MethodHandles;\n@@ -40,1 +44,0 @@\n-import java.util.function.BiConsumer;\n@@ -45,5 +48,6 @@\n-import static optkl.OpTkl.operandOrNull;\n-\n-public class Trxfmr {\n-    public static Trxfmr of(CoreOp.FuncOp funcOp) {\n-        return new Trxfmr(funcOp);\n+public class Trxfmr implements LookupCarrier{\n+    @Override public MethodHandles.Lookup lookup(){\n+        return lookup;\n+    }\n+    public static Trxfmr of(MethodHandles.Lookup lookup,CallSite callSite,CoreOp.FuncOp funcOp) {\n+        return new Trxfmr(lookup,callSite,funcOp);\n@@ -51,2 +55,8 @@\n-    public static Trxfmr of(CallSite callSite,CoreOp.FuncOp funcOp) {\n-        return new Trxfmr(callSite,funcOp);\n+    \/\/public static Trxfmr of(CoreOp.FuncOp funcOp) {\n+      \/\/  return of(null,null, funcOp);\n+   \/\/ }\n+    \/\/public static Trxfmr of(CallSite callSite,CoreOp.FuncOp funcOp) {\n+      \/\/  return of(null,callSite, funcOp);\n+    \/\/}\n+    public static Trxfmr of(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n+        return of(lookup,null, funcOp);\n@@ -54,3 +64,2 @@\n-    public static <F extends Op, T extends Op> T copyLocation(F from, T to) {\n-        to.setLocation(from.location());\n-        return to;\n+    public static Trxfmr of(LookupCarrier lookupCarrier, CoreOp.FuncOp funcOp) {\n+        return of(lookupCarrier.lookup(),null, funcOp);\n@@ -70,2 +79,12 @@\n-    interface TransformerCarrier {\n-        Trxfmr trxfmr();\n+\n+    public Trxfmr toText(String prefix, String suffix) {\n+        return run(trxfmr -> {\n+                    if (prefix != null && !prefix.isEmpty()){\n+                        System.out.println(prefix);\n+                    }\n+                    System.out.println(OpCodeBuilder.toText(trxfmr.funcOp()));\n+                    if (suffix != null && !suffix.isEmpty()){\n+                        System.out.println(suffix);\n+                    }\n+                }\n+        );\n@@ -73,2 +92,5 @@\n-    interface CursorCarrier<T extends Cursor>{\n-        T cursor();\n+    public Trxfmr toText() {\n+        return toText(null, null);\n+    }\n+    public Trxfmr toText(String prefix) {\n+        return toText(prefix, null);\n@@ -77,15 +99,10 @@\n-  \/*  public interface  Walker extends TransformerCarrier {\n-        void op(Op op);\n-        Op op();\n-        void funcOp(CoreOp.FuncOp funcOp);\n-        CoreOp.FuncOp funcOp();\n-              class Impl implements TransformerCarrier,Walker {\n-                private final Trxfmr trxfmr;\n-                public Trxfmr trxfmr() {\n-                    return trxfmr;\n-                }\n-                private Op op;\n-                private CoreOp.FuncOp funcOp;\n-                @Override\n-                public void op(Op op) {\n-                    this.op = op;\n+    public Trxfmr toJava(String prefix, String suffix) {\n+        return run(trxfmr -> {\n+                    if (prefix != null && !prefix.isEmpty()){\n+                        System.out.println(prefix);\n+                    }\n+                    var javaCodeBuilder = new JavaCodeBuilder<>(lookup, trxfmr.funcOp());\n+                    System.out.println(javaCodeBuilder.toText());\n+                    if (suffix != null && !suffix.isEmpty()){\n+                        System.out.println(suffix);\n+                    }\n@@ -93,0 +110,1 @@\n+        );\n@@ -94,4 +112,7 @@\n-                @Override\n-                public Op op() {\n-                    return this.op;\n-                }\n+    }\n+    public Trxfmr toJava(String prefix) {\n+        return toJava(prefix, null);\n+    }\n+    public Trxfmr toJava() {\n+        return toJava(null, null);\n+    }\n@@ -99,4 +120,11 @@\n-                @Override\n-                public void funcOp(CoreOp.FuncOp funcOp) {\n-                    this.funcOp = funcOp;\n-                }\n+    public void exec( Object ... args) {\n+        try {\n+            if (args.length==0) {\n+                BytecodeGenerator.generate(lookup, funcOp()).invoke();\n+            }else{\n+                BytecodeGenerator.generate(lookup, funcOp()).invoke(args);\n+            }\n+        } catch (Throwable throwable) {\n+            throw new RuntimeException(throwable);\n+        }\n+    }\n@@ -104,4 +132,0 @@\n-                @Override\n-                public CoreOp.FuncOp funcOp() {\n-                    return this.funcOp;\n-                }\n@@ -109,9 +133,6 @@\n-                Impl(Trxfmr trxfmr, CoreOp.FuncOp funcOp) {\n-                    this.trxfmr = trxfmr;\n-                    this.funcOp = funcOp;\n-                }\n-            }\n-      \/\/  static Walker of(Trxfmr trxfmr, CoreOp.FuncOp funcOp){\n-        \/\/    return new Impl(trxfmr,funcOp);\n-       \/\/ }\n-    } *\/\n+    interface TransformerCarrier {\n+        Trxfmr trxfmr();\n+    }\n+    interface CursorCarrier<T extends Cursor>{\n+        T cursor();\n+    }\n@@ -120,1 +141,1 @@\n-        enum Action{NONE,REMOVED,REPLACE,ADDED };\n+        enum Action{NONE,RETAIN,REMOVED,REPLACE,ADDED };\n@@ -135,1 +156,0 @@\n-        Op.Result add(Op op, Consumer<Mapper<?>> mapperConsumer);\n@@ -139,1 +159,5 @@\n-\n+        Op.Result retain(Consumer<Mapper<?>> mapperConsumer);\n+        default Op.Result retain(){\n+            return retain(_->{});\n+        }\n+        Op.Result add(Op op, Consumer<Mapper<?>> mapperConsumer);\n@@ -215,1 +239,1 @@\n-                    var result = trxfmr.opToResultOp(op(),builder().op(copyLocation(op(), replacement)));\n+                    var result = trxfmr.opToResultOp(op(),builder().op(OpHelper.copyLocation(op(), replacement)));\n@@ -225,1 +249,1 @@\n-                    var result = trxfmr.opToResultOp(op(),builder().op(copyLocation(op(), newOne)));\n+                    var result = trxfmr.opToResultOp(op(),builder().op(OpHelper.copyLocation(op(), newOne)));\n@@ -233,0 +257,6 @@\n+                public Op.Result retain( Consumer<Mapper<?>> mapperConsumer) {\n+                    handled(true);\n+                    action(Action.RETAIN);\n+                    return trxfmr.opToResultOp(op(),builder().op(op()));\n+                }\n+                @Override\n@@ -252,1 +282,1 @@\n-            return getValue(operandOrNull(op(),idx));\n+            return getValue(OpHelper.operandNAsResult(op(),idx));\n@@ -256,10 +286,0 @@\n-    public interface Selector<T extends Selector<T>> extends TransformerCarrier {\n-        default T  select(Op...ops){\n-            trxfmr().selected.addAll(List.of(ops));\n-            return (T)this;\n-        }\n-       static Selector<?> of(Trxfmr trxfmr){\n-            record SelectorImpl(Trxfmr trxfmr) implements Selector<SelectorImpl>{}\n-            return  new SelectorImpl(trxfmr);\n-        }\n-    }\n@@ -298,1 +318,1 @@\n-    public final Set<Op> selected = new LinkedHashSet<>();\n+    public final MethodHandles.Lookup lookup;\n@@ -310,1 +330,2 @@\n-    public Trxfmr(CallSite callSite, CoreOp.FuncOp funcOp) {\n+    private Trxfmr(MethodHandles.Lookup lookup,CallSite callSite, CoreOp.FuncOp funcOp) {\n+        this.lookup = lookup;\n@@ -318,2 +339,0 @@\n-    public Trxfmr(CoreOp.FuncOp funcOp) {\n-        this (null,funcOp);\n@@ -321,0 +340,3 @@\n+    public Trxfmr run(Consumer<Trxfmr> action){\n+        action.accept(this);\n+        return this;\n@@ -322,5 +344,4 @@\n-    public Trxfmr select(Predicate<Op> codeElementPredicate, BiConsumer<Selector<?>,Op> selectorConsumer) {\n-        Selector<?> selector = Selector.of(this);\n-        funcOp().elements().filter(ce->ce instanceof Op).map(ce->(Op)ce).filter(codeElementPredicate).forEach(op->\n-                selectorConsumer.accept(selector,op)\n-        );\n+    public Trxfmr when(boolean c,Consumer<Trxfmr> action){\n+        if (c) {\n+            run(action);\n+        }\n@@ -330,1 +351,0 @@\n-\n@@ -344,6 +364,2 @@\n-    private boolean shouldTransform(Predicate<CodeElement<?,?>> predicate, Op op){\n-        boolean isEmpty = selected.isEmpty();\n-        boolean isInSelected = selected.contains(op);\n-        boolean isSelected = isEmpty|isInSelected;\n-        boolean passesPredicate = predicate.test(op);\n-        return isSelected && passesPredicate;\n+    public Trxfmr transform(Predicate<CodeElement<?,?>> predicate, Consumer<Cursor> cursorConsumer){\n+        return transform(funcOp.funcName(),predicate,cursorConsumer);\n@@ -351,2 +367,1 @@\n-\n-    public Trxfmr transform(Predicate<CodeElement<?,?>> predicate, Consumer<Cursor> cursorConsumer) {\n+    public Trxfmr transform(String name, Predicate<CodeElement<?,?>> predicate, Consumer<Cursor> cursorConsumer) {\n@@ -356,2 +371,2 @@\n-        var newFuncOp = funcOp().transform((blockBuilder, op) -> {\n-            if (shouldTransform(predicate,op)){\n+        var newFuncOp = funcOp().transform(name,(blockBuilder, op) -> {\n+            if (predicate.test(op)){\n@@ -372,0 +387,1 @@\n+\n@@ -381,1 +397,1 @@\n-            if (shouldTransform(predicate,op)){\n+            if (predicate.test(op)){\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":105,"deletions":89,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Field;\n-\n-import static optkl.OpTkl.classTypeToTypeOrThrow;\n-\n-public interface VarAccess extends OpHelper<CoreOp.VarAccessOp>{\n-\n-    @Override\n-    default  String name(){\n-        return op().varOp().varName();\n-    }\n-\n-    default boolean isPrimitive(){\n-        return op().result().type() instanceof PrimitiveType;\n-    }\n-\n-\n-    default  <T>boolean of(Class<T> clazz){\n-        return isAssignable((JavaType) op().resultType(),clazz);\n-    }\n-\n-    static VarAccess varAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-        record Impl(MethodHandles.Lookup lookup, CoreOp.VarAccessOp op) implements VarAccess {}\n-        return codeElement instanceof CoreOp.VarAccessOp varAccessOp? new Impl(lookup,varAccessOp): null;\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/VarAccess.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl.codebuilders;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.ParamVar;\n-\n-\/* this should not be too C99 specific *\/\n-public interface BabylonCoreOpBuilder<T extends CodeBuilder<?>, SB extends CodeBuilderContext> {\n-    T type(SB buildContext, JavaType javaType);\n-\n-    T varLoadOp(SB buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp);\n-\n-    T varStoreOp(SB buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp);\n-\n-    T varOp(SB buildContext, CoreOp.VarOp varOp);\n-\n-    T varOp(SB buildContext, CoreOp.VarOp varOp, ParamVar paramVar );\n-\n-    T fieldLoadOp(SB buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp);\n-\n-    T fieldStoreOp(SB buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp);\n-\n-    T unaryOp(SB buildContext, JavaOp.UnaryOp unaryOp);\n-\n-    T binaryOp(SB buildContext, JavaOp.BinaryOp binaryOp);\n-\n-    T conditionalOp(SB buildContext, JavaOp.JavaConditionalOp conditionalOp);\n-\n-    T binaryTestOp(SB buildContext, JavaOp.BinaryTestOp binaryTestOp);\n-\n-    T convOp(SB buildContext, JavaOp.ConvOp convOp);\n-\n-    T constantOp(SB buildContext, CoreOp.ConstantOp constantOp);\n-\n-    T yieldOp(SB buildContext, CoreOp.YieldOp yieldOp);\n-\n-    T lambdaOp(SB buildContext, JavaOp.LambdaOp lambdaOp);\n-\n-    T tupleOp(SB buildContext, CoreOp.TupleOp tupleOp);\n-\n-    T funcCallOp(SB buildContext, CoreOp.FuncCallOp funcCallOp);\n-\n-    T ifOp(SB buildContext, JavaOp.IfOp ifOp);\n-\n-    T whileOp(SB buildContext, JavaOp.WhileOp whileOp);\n-\n-    T labeledOp(SB buildContext, JavaOp.LabeledOp labeledOp);\n-\n-    T continueOp(SB buildContext, JavaOp.ContinueOp continueOp);\n-\n-    T breakOp(SB buildContext, JavaOp.BreakOp breakOp);\n-\n-    T forOp(SB buildContext, JavaOp.ForOp forOp);\n-\n-    T invokeOp(SB buildContext, JavaOp.InvokeOp invokeOp);\n-\n-    T conditionalExpressionOp(SB buildContext, JavaOp.ConditionalExpressionOp ternaryOp);\n-\n-    T parenthesisIfNeeded(SB buildContext, Op parent, Op child);\n-\n-    T returnOp(SB buildContext, CoreOp.ReturnOp returnOp);\n-\n-    default T recurse(SB buildContext, Op op) {\n-        switch (op) {\n-            case CoreOp.VarAccessOp.VarLoadOp $ -> varLoadOp(buildContext, $);\n-            case CoreOp.VarAccessOp.VarStoreOp $ -> varStoreOp(buildContext, $);\n-            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoadOp(buildContext, $);\n-            case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStoreOp(buildContext, $);\n-            case JavaOp.ConvOp $ -> convOp(buildContext, $);\n-            case CoreOp.ConstantOp $ -> constantOp(buildContext, $);\n-            case CoreOp.YieldOp $ -> yieldOp(buildContext, $);\n-            case CoreOp.FuncCallOp $ -> funcCallOp(buildContext, $);\n-            case JavaOp.InvokeOp $ -> invokeOp(buildContext, $);\n-            case JavaOp.ConditionalExpressionOp $ -> conditionalExpressionOp(buildContext, $);\n-            case CoreOp.VarOp $ when ParamVar.of($) instanceof ParamVar paramVar -> varOp(buildContext, $,paramVar);\n-            case CoreOp.VarOp $ -> varOp(buildContext, $);\n-            case JavaOp.LambdaOp $ -> lambdaOp(buildContext, $);\n-            case CoreOp.TupleOp $ -> tupleOp(buildContext, $);\n-            case JavaOp.WhileOp $ -> whileOp(buildContext, $);\n-            case JavaOp.IfOp $ -> ifOp(buildContext, $);\n-            case JavaOp.ForOp $ -> forOp(buildContext, $);\n-            case CoreOp.ReturnOp $ -> returnOp(buildContext, $);\n-            case JavaOp.LabeledOp $ -> labeledOp(buildContext, $);\n-            case JavaOp.BreakOp $ -> breakOp(buildContext, $);\n-            case JavaOp.ContinueOp $ -> continueOp(buildContext, $);\n-            case JavaOp.BinaryTestOp $ -> binaryTestOp(buildContext, $);\n-            case JavaOp.BinaryOp $ -> binaryOp(buildContext, $);\n-            case JavaOp.JavaConditionalOp $ -> conditionalOp(buildContext, $);\n-            case JavaOp.UnaryOp $ -> unaryOp(buildContext, $);\n-\n-            default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n-        }\n-        return (T) this;\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/BabylonCoreOpBuilder.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.codebuilders;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.ParamVar;\n+\n+\/* this should not be too C99 specific also cannot reference HAT Ops. *\/\n+public interface BabylonOpDispatcher<T extends JavaOrC99StyleCodeBuilder<T>, SB extends ScopedCodeBuilderContext> {\n+    T type(SB buildContext, JavaType javaType);\n+\n+    T varLoadOp(SB buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp);\n+\n+    T varStoreOp(SB buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp);\n+\n+    T varOp(SB buildContext, CoreOp.VarOp varOp);\n+\n+    T varOp(SB buildContext, CoreOp.VarOp varOp, ParamVar paramVar );\n+\n+    T fieldLoadOp(SB buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp);\n+\n+    T fieldStoreOp(SB buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp);\n+\n+    T unaryOp(SB buildContext, JavaOp.UnaryOp unaryOp);\n+\n+    T binaryOp(SB buildContext, JavaOp.BinaryOp binaryOp);\n+\n+    T conditionalOp(SB buildContext, JavaOp.JavaConditionalOp conditionalOp);\n+\n+    T binaryTestOp(SB buildContext, JavaOp.BinaryTestOp binaryTestOp);\n+\n+    T convOp(SB buildContext, JavaOp.ConvOp convOp);\n+\n+    T constantOp(SB buildContext, CoreOp.ConstantOp constantOp);\n+\n+    T yieldOp(SB buildContext, CoreOp.YieldOp yieldOp);\n+\n+    T lambdaOp(SB buildContext, JavaOp.LambdaOp lambdaOp);\n+\n+    T tupleOp(SB buildContext, CoreOp.TupleOp tupleOp);\n+\n+    T funcCallOp(SB buildContext, CoreOp.FuncCallOp funcCallOp);\n+\n+    T ifOp(SB buildContext, JavaOp.IfOp ifOp);\n+\n+    T whileOp(SB buildContext, JavaOp.WhileOp whileOp);\n+\n+    T labeledOp(SB buildContext, JavaOp.LabeledOp labeledOp);\n+\n+    T continueOp(SB buildContext, JavaOp.ContinueOp continueOp);\n+\n+    T breakOp(SB buildContext, JavaOp.BreakOp breakOp);\n+\n+    T forOp(SB buildContext, JavaOp.ForOp forOp);\n+\n+    T invokeOp(SB buildContext, JavaOp.InvokeOp invokeOp);\n+\n+    T conditionalExpressionOp(SB buildContext, JavaOp.ConditionalExpressionOp ternaryOp);\n+\n+    T parenthesisIfNeeded(SB buildContext, Op parent, Op child);\n+\n+    T returnOp(SB buildContext, CoreOp.ReturnOp returnOp);\n+\n+    T newOp(SB buildContext, JavaOp.NewOp newOp);\n+    T arrayLoadOp(SB buildContext, JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp);\n+    T arrayStoreOp(SB buildContext, JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp);\n+    T enhancedForOp(SB buildContext, JavaOp.EnhancedForOp enhancedForOp);\n+    default T recurse(SB buildContext, Op op) {\n+        switch (op) {\n+            case CoreOp.VarAccessOp.VarLoadOp $ -> varLoadOp(buildContext, $);\n+            case CoreOp.VarAccessOp.VarStoreOp $ -> varStoreOp(buildContext, $);\n+            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoadOp(buildContext, $);\n+            case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStoreOp(buildContext, $);\n+            case JavaOp.ConvOp $ -> convOp(buildContext, $);\n+            case CoreOp.ConstantOp $ -> constantOp(buildContext, $);\n+            case CoreOp.YieldOp $ -> yieldOp(buildContext, $);\n+            case CoreOp.FuncCallOp $ -> funcCallOp(buildContext, $);\n+            case JavaOp.InvokeOp $ -> invokeOp(buildContext, $);\n+            case JavaOp.ConditionalExpressionOp $ -> conditionalExpressionOp(buildContext, $);\n+            case CoreOp.VarOp $ when ParamVar.of($) instanceof ParamVar paramVar -> varOp(buildContext, $,paramVar);\n+            case CoreOp.VarOp $ -> varOp(buildContext, $);\n+            case JavaOp.LambdaOp $ -> lambdaOp(buildContext, $);\n+            case CoreOp.TupleOp $ -> tupleOp(buildContext, $);\n+            case JavaOp.WhileOp $ -> whileOp(buildContext, $);\n+            case JavaOp.IfOp $ -> ifOp(buildContext, $);\n+            case JavaOp.ForOp $ -> forOp(buildContext, $);\n+            case CoreOp.ReturnOp $ -> returnOp(buildContext, $);\n+            case JavaOp.LabeledOp $ -> labeledOp(buildContext, $);\n+            case JavaOp.BreakOp $ -> breakOp(buildContext, $);\n+            case JavaOp.ContinueOp $ -> continueOp(buildContext, $);\n+            case JavaOp.BinaryTestOp $ -> binaryTestOp(buildContext, $);\n+            case JavaOp.BinaryOp $ -> binaryOp(buildContext, $);\n+            case JavaOp.JavaConditionalOp $ -> conditionalOp(buildContext, $);\n+            case JavaOp.UnaryOp $ -> unaryOp(buildContext, $);\n+            case JavaOp.NewOp $ -> newOp(buildContext, $);\n+            case JavaOp.ArrayAccessOp.ArrayStoreOp  $ ->  arrayStoreOp(buildContext,$);\n+            case JavaOp.ArrayAccessOp.ArrayLoadOp  $ ->  arrayLoadOp(buildContext,$);\n+            case JavaOp.EnhancedForOp $ -> enhancedForOp(buildContext,$);\n+            default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n+        }\n+        return (T) this;\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/BabylonOpDispatcher.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.codebuilders;\n+import jdk.incubator.code.dialect.java.ClassType;\n+\n+import java.util.function.Consumer;\n+\n+public  class C99CodeBuilder<T extends C99CodeBuilder<T>> extends JavaOrC99StyleCodeBuilder<T> {\n+\n+    public final T suffix_t(ClassType type){\n+        String name = type.toClassName();\n+        int dotIdx = name.lastIndexOf('.');\n+        int dollarIdx = name.lastIndexOf('$');\n+        int idx = Math.max(dotIdx, dollarIdx);\n+        if (idx > 0) {\n+            name = name.substring(idx + 1);\n+        }\n+        return suffix_t(name);\n+    }\n+\n+    public final T suffix_t(String name) {\n+        return identifier(name).identifier(\"_t\");\n+    }\n+\n+    public final T suffix_u(String name) {\n+        return identifier(name).identifier(\"_u\");\n+    }\n+\n+    public final T suffix_s(String name) {\n+        return identifier(name).identifier(\"_s\");\n+    }\n+\n+    public final T suffix_t(Class<?> klass) {\n+        return suffix_t(klass.getSimpleName());\n+    }\n+\n+    public final T suffix_u(Class<?> klass) {\n+        return suffix_u(klass.getSimpleName());\n+    }\n+\n+    public final T suffix_s(Class<?> klass) {\n+        return suffix_s(klass.getSimpleName());\n+    }\n+\n+    public final T structOrUnion(boolean isStruct) {\n+        return (isStruct ? structKeyword() : union());\n+    }\n+\n+    public final T typedefKeyword() {\n+        return keyword(\"typedef\");\n+    }\n+\n+    public final T structKeyword() {\n+        return keyword(\"struct\");\n+    }\n+\n+    public final T union() {\n+        return keyword(\"union\");\n+    }\n+\n+    public final T externC() {\n+        return externKeyword().space().dquote(\"C\");\n+    }\n+\n+    public final T hashDefineKeyword() {\n+        return hash().keyword(\"define\");\n+    }\n+\n+    public final T hashIfdefKeyword() {\n+        return hash().keyword(\"ifdef\");\n+    }\n+\n+    public final T hashIfndefKeyword() {\n+        return hash().keyword(\"ifndef\");\n+    }\n+\n+    public final T hashEndif() {\n+        return hash().keyword(\"endif\").nl();\n+    }\n+\n+    public final T hashIfdef(String value) {\n+        return hashIfdefKeyword().space().constant(value).nl();\n+    }\n+\n+    public final T hashIfndef(String value) {\n+        return hashIfndefKeyword().space().constant(value).nl();\n+    }\n+\n+    public final T hashIfdef(String value, Consumer<T> consumer) {\n+        return hashIfdef(value).accept(consumer).hashEndif();\n+    }\n+\n+    public final T hashIfndef(String value, Consumer<T> consumer) {\n+        return hashIfndef(value).accept(consumer).hashEndif();\n+    }\n+\n+    public final T pragmaKeyword() {\n+        return keyword(\"pragma\");\n+    }\n+\n+    public final T includeKeyword() {\n+        return keyword(\"include\");\n+    }\n+\n+    public final T hashDefine(String name, String... values) {\n+        hashDefineKeyword().space().identifier(name);\n+        for (String value : values) {\n+            space().constant(value);\n+        }\n+        return nl();\n+    }\n+\n+    public final T hashDefine(String name, Consumer<T> consumer) {\n+        hashDefineKeyword().space().identifier(name);\n+        space();\n+        consumer.accept(self());\n+        return nl();\n+    }\n+\n+    public final T pragma(String name, String... values) {\n+        hash().pragmaKeyword().space().identifier(name);\n+        for (String value : values) {\n+            space().constant(value);\n+        }\n+        return nl();\n+    }\n+\n+    public final T includeSys(String... values) {\n+        for (String value : values) {\n+            hash().includeKeyword().space().lt().identifier(value).gt().nl();\n+        }\n+        return self();\n+    }\n+\n+    public final T include(String... values) {\n+        for (String value : values) {\n+            hash().includeKeyword().space().dquote().identifier(value).dquote().nl();\n+        }\n+        return nl();\n+    }\n+\n+    public final T externKeyword() {\n+        return keyword(\"extern\");\n+    }\n+\n+    public final T u08Type() {\n+        return typeName(\"unsigned\").space().s08Type();\n+    }\n+\n+    public final T u08Type(String identifier) {\n+        return u08Type().space().identifier(identifier);\n+    }\n+\n+    public final T u08PtrType() {\n+        return u08Type().space().asterisk();\n+    }\n+\n+    public final T u08PtrType(String identifier) {\n+        return u08PtrType().identifier(identifier);\n+    }\n+\n+    public final T u32Type() {\n+        return typeName(\"unsigned\").space().s32Type();\n+    }\n+\n+    public final T u32Type(String identifier ) {\n+        return u32Type().space().identifier(identifier);\n+    }\n+\n+    public final T u64Type() {\n+        return typeName(\"unsigned\").space().s64Type();\n+    }\n+\n+    public final T u16Type() {\n+        return typeName(\"unsigned\").space().s16Type();\n+    }\n+\n+    public final T u16Type(String identifier) {\n+        return u16Type().space().identifier(identifier);\n+    }\n+\n+    public final T bfloat16Type(String identifier) {\n+        return suffix_t(\"BFLOAT16_UNION\").space().identifier(identifier);\n+    }\n+\n+    public final  T typedefStructOrUnion(boolean isStruct, Class<?> klass, Consumer<T> consumer) {\n+        return typedefKeyword()\n+                .space()\n+                .structOrUnion(isStruct)\n+                .space()\n+                .either(isStruct, _ -> suffix_s(klass), _ -> suffix_u(klass))\n+                .braceNlIndented(consumer)\n+                .suffix_t(klass).semicolonNl();\n+    }\n+\n+    public final T typedefStruct(String name, Consumer<T> consumer) {\n+        return typedefKeyword()\n+                .space()\n+                .structKeyword()\n+                .space()\n+                .suffix_s(name)\n+                .braceNlIndented(consumer)\n+                .suffix_t(name)\n+                .semicolonNl();\n+    }\n+\n+    public final T typedefUnion(String name, Consumer<T> consumer) {\n+        return typedefKeyword()\n+                .space()\n+                .union()\n+                .space()\n+                .suffix_s(name)\n+                .braceNlIndented(consumer)\n+                .suffix_t(name)\n+                .semicolonNl();\n+    }\n+\n+    public final T typedefStruct(Class<?>clazz, Consumer<T> consumer) {\n+        return typedefStruct(clazz.getSimpleName(), consumer);\n+    }\n+\n+    public final T typedefSingleValueStruct(String structName, String type) {\n+        return typedefStruct(structName,_-> typeName(type).space().identifier(\"value\").semicolon());\n+    }\n+\n+    public final T unionBfloat16() {\n+        return typedefUnion(\"BFLOAT16_UNION\", _ -> {\n+            typeName(\"float\").space().identifier(\"f\").semicolon().nl();\n+            u16Type(\"s\").sizeArray(2).semicolon();\n+        });\n+    }\n+\n+    public final T funcDef(Consumer<T> type, Consumer<T> name, Consumer<T> args, Consumer<T> body){\n+        type.accept(self());\n+        space();\n+        name.accept(self());\n+        paren(args);\n+        braceNlIndented(body);\n+        return nl();\n+    }\n+\n+\n+    public final T call(Consumer<T> name,Consumer<T> ...args) {\n+        name.accept(self());\n+        return paren(_->commaSpaceSeparated(args));\n+    }\n+\n+    public final T call(String name,Consumer<T> ...args) {\n+        return call(_->identifier(name),args);\n+    }\n+\n+\n+    public final T sizeof() {\n+        return emitText(\"sizeof\");\n+    }\n+\n+    public final T sizeof(String identifier) {\n+        return sizeof(_->identifier(identifier));\n+    }\n+\n+    public final T sizeof(Consumer<T> consumer) {\n+        return sizeof().paren(consumer);\n+    }\n+\n+    public final T voidPtrType() {\n+        return voidType().space().asterisk();\n+    }\n+\n+    public final T voidPtrType(String identifier) {\n+        return voidPtrType().identifier(identifier);\n+    }\n+\n+    public final T sizeType() {\n+        return typeName(\"size_t\");\n+    }\n+\n+    public final T sizeType(String identifier) {\n+        return sizeType().space().identifier(identifier);\n+    }\n+\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/C99CodeBuilder.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -727,0 +727,4 @@\n+    public final T varName(CoreOp.VarAccessOp.VarLoadOp varOp) {\n+        blockInlineComment(varOp.toString());\n+        return self();\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/CodeBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.codebuilders;\n+\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import optkl.OpHelper;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public class JavaCodeBuilder<T extends JavaCodeBuilder<T>> extends JavaOrC99StyleCodeBuilder<T> implements BabylonOpDispatcher<T,ScopedCodeBuilderContext> {\n+    public T createJava(ScopedCodeBuilderContext buildContext) {\n+        buildContext.funcScope(buildContext.funcOp, () -> {\n+            typeName(buildContext.funcOp.resultType().toString()).space().funcName(buildContext.funcOp);\n+            parenNlIndented(_ ->\n+                    commaNlSeparated(\n+                            buildContext.paramTable.list(),\n+                            param -> declareParam(buildContext, param)\n+                    )\n+            );\n+            braceNlIndented(_ -> nlSeparated(\n+                    OpHelper.Statement.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                    statement -> statement(buildContext, statement)\n+                    )\n+            );\n+        });\n+        return nl();\n+    }\n+    MethodHandles.Lookup lookup;\n+    CoreOp.FuncOp funcOp;\n+    public JavaCodeBuilder(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp){\n+        super();\n+        this.lookup=lookup;\n+        this.funcOp = funcOp;\n+    }\n+\n+    public String toText() {\n+        ScopedCodeBuilderContext scopedCodeBuilderContext= new ScopedCodeBuilderContext(lookup,funcOp);\n+        return createJava(scopedCodeBuilderContext).getText();\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaCodeBuilder.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,495 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.codebuilders;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ArrayType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.FuncOpParams;\n+import optkl.OpHelper;\n+import optkl.ParamVar;\n+import optkl.util.StreamMutable;\n+import optkl.util.ops.Precedence;\n+\n+import java.util.function.Consumer;\n+\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Ternary.ternary;\n+\n+public class JavaOrC99StyleCodeBuilder<T extends JavaOrC99StyleCodeBuilder<T>> extends CodeBuilder<T>  implements BabylonOpDispatcher<T,ScopedCodeBuilderContext>{\n+\n+    public final T assign(Consumer<T> lhs, Consumer<T> rhs){\n+        lhs.accept(self());\n+        space().equals().space();\n+        rhs.accept(self());\n+        return self();\n+    }\n+\n+    public final T cast(Consumer<T> type){\n+        return paren(_-> type.accept(self()));\n+    }\n+\n+    public final T returnKeyword(Consumer<T> exp){\n+        return returnKeyword().space().paren(_-> exp.accept(self())).semicolon();\n+    }\n+    public final T forLoop(Consumer<T> init, Consumer<T> test, Consumer<T>mutate, Consumer<T>body) {\n+        return  forKeyword()\n+                .paren(_->{\n+                    init.accept(self());\n+                    semicolon().space();\n+                    test.accept(self());\n+                    semicolon().space();mutate.accept(self());\n+                })\n+                .braceNlIndented(body::accept);\n+    }\n+\n+    public final T literal(TypeElement typeElement, String string){\n+        if (typeElement.toString().equals(\"java.lang.String\")){\n+            dquote().escaped(string).dquote();\n+        }else{\n+            literal(string);\n+        }\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n+        return typeName(javaType.toString());\n+    }\n+\n+\n+    @Override\n+    public T varLoadOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n+        if (resolve instanceof CoreOp.VarOp varOp) {\n+            varName(varOp);\n+        }else if (resolve instanceof CoreOp.VarAccessOp.VarLoadOp){\n+            varName(varLoadOp);\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public T varStoreOp(ScopedCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp) {\n+        Op op = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n+        varName((CoreOp.VarOp) op);\n+        equals().parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public final T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n+        if (varOp.isUninitialized()) {\n+            type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp);\n+        } else {\n+            if (buildContext.isVarOpFinal(varOp)) {\n+                constKeyword().space();\n+            }\n+            type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp).space().equals().space();\n+            var first = varOp.operands().getFirst();\n+            if (first instanceof Op.Result result) {\n+                parenthesisIfNeeded(buildContext, varOp, result.op());\n+            }else if (first instanceof Block.Parameter parameter) {\n+               var p1 =  parameter.declaringBlock().parameters().getFirst();\n+\n+                var r = parameter.uses().iterator().next();\n+                \/\/parenthesisIfNeeded(buildContext, varOp, r.op());\n+               \/\/ if (r.op() instanceof CoreOp.VarOp varOp1){\n+                 \/\/   identifier(varOp1.varName());\n+               \/\/ }\n+              blockInlineComment(\"param \"+r);\n+            }else{\n+                blockInlineComment(\"look at varOp \"+first);\n+            }\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final T varOp(ScopedCodeBuilderContext buildContext, CoreOp.VarOp varOp, ParamVar paramVar) {\n+        varName(varOp);\n+        return self();\n+    }\n+\n+    @Override\n+    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        var fieldAccess = fieldAccess(buildContext.lookup,fieldLoadOp);\n+        if (fieldAccess.operandCount()==0 && fieldAccess.isPrimitive() ) {\n+            literal(fieldAccess.getStaticFinalPrimitiveValue().toString());\n+        } else {\n+          identifier(fieldAccess.name());\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final T fieldStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp) {\n+        var fieldAccess = fieldAccess(buildContext.lookup,fieldStoreOp);\n+        identifier(fieldAccess.name()).space().equals().space();\n+        recurse(buildContext,((Op.Result)fieldAccess.op().operands().get(0)).op());\n+        dot();\n+        recurse(buildContext,((Op.Result)fieldAccess.op().operands().get(1)).op());\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public final  T unaryOp(ScopedCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp) {\n+        symbol(unaryOp).parenthesisIfNeeded(buildContext, unaryOp, ((Op.Result)unaryOp.operands().getFirst()).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public final  T binaryOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp) {\n+        parenthesisIfNeeded(buildContext, binaryOp, OpHelper.lhsResult(binaryOp).op());\n+        symbol(binaryOp);\n+        parenthesisIfNeeded(buildContext, binaryOp, OpHelper.rhsResult(binaryOp).op());\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public final T conditionalOp(ScopedCodeBuilderContext buildContext, JavaOp.JavaConditionalOp logicalOp) {\n+        OpHelper.lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n+        space().symbol(logicalOp).space();\n+        OpHelper.rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n+        return self();\n+    }\n+\n+    @Override\n+    public final T binaryTestOp(ScopedCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp) {\n+        parenthesisIfNeeded(buildContext, binaryTestOp, OpHelper.lhsResult(binaryTestOp).op());\n+        symbol(binaryTestOp);\n+        parenthesisIfNeeded(buildContext, binaryTestOp, OpHelper.rhsResult(binaryTestOp).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public T convOp(ScopedCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n+        \/\/ TODO: I think we need to work out how to handle doubles. If I remove this OpenCL on MAC complains (no FP64)\n+        if (convOp.resultType() == JavaType.DOUBLE) {\n+            paren(_ -> type(buildContext,JavaType.FLOAT)); \/\/ why double to float?\n+        } else {\n+            paren(_ -> type(buildContext,(JavaType)convOp.resultType()));\n+        }\n+        parenthesisIfNeeded(buildContext, convOp, ((Op.Result) convOp.operands().getFirst()).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public final T constantOp(ScopedCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp) {\n+        if (constantOp.value() == null) {\n+            nullConst();\n+        } else {\n+            literal(constantOp.resultType(),constantOp.value().toString());\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final  T yieldOp(ScopedCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp) {\n+        if (yieldOp.operands().getFirst() instanceof Op.Result result) {\n+            recurse(buildContext, result.op());\n+        }\n+        return self();\n+    }\n+\n+\n+\n+    @Override\n+    public final  T tupleOp(ScopedCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp) {\n+        commaSpaceSeparated(tupleOp.operands(),operand->{\n+            if (operand instanceof Op.Result result) {\n+                recurse(buildContext, result.op());\n+            } else {\n+                throw new IllegalStateException(\"handle tuple\");\n+                \/\/comment(\"\/* nothing to tuple *\/\");\n+            }\n+        });\n+        return self();\n+    }\n+\n+    @Override\n+    public final T funcCallOp(ScopedCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp) {\n+        funcName(funcCallOp);\n+        paren(_ ->\n+                commaSpaceSeparated(\n+                        funcCallOp.operands().stream().filter(e->e instanceof Op.Result ).map(e->(Op.Result)e),\n+                        result -> recurse(buildContext,result.op())\n+                )\n+        );\n+        return self();\n+    }\n+\n+    @Override\n+    public final T labeledOp(ScopedCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp) {\n+        var labelNameOp = labeledOp.bodies().getFirst().entryBlock().ops().getFirst();\n+        CoreOp.ConstantOp constantOp = (CoreOp.ConstantOp) labelNameOp;\n+        literal(constantOp.value().toString()).colon().nl();\n+        var forLoopOp = labeledOp.bodies().getFirst().entryBlock().ops().get(1);\n+        recurse(buildContext,forLoopOp);\n+        return self();\n+    }\n+\n+    @Override\n+    public final T breakOp(ScopedCodeBuilderContext buildContext, JavaOp.BreakOp breakOp) {\n+        breakKeyword();\n+        if (!breakOp.operands().isEmpty() && breakOp.operands().getFirst() instanceof Op.Result result) {\n+            space();\n+            if (result.op() instanceof CoreOp.ConstantOp c) {\n+                literal(c.value().toString());\n+            }\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public final T continueOp(ScopedCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp) {\n+        if (!continueOp.operands().isEmpty()\n+                && continueOp.operands().getFirst() instanceof Op.Result result\n+                && result.op() instanceof CoreOp.ConstantOp c\n+        ) {\n+            continueKeyword().space().literal(c.value().toString());\n+        } else if (buildContext.scope.parent instanceof ScopedCodeBuilderContext.ForScope) {\n+            \/\/ nope\n+        } else {\n+            continueKeyword();\n+        }\n+\n+        return self();\n+    }\n+\n+    @Override\n+    public final T ifOp(ScopedCodeBuilderContext buildContext, JavaOp.IfOp ifOp) {\n+        buildContext.ifScope(ifOp, () -> {\n+            var lastWasBody = StreamMutable.of(false);\n+            var i = StreamMutable.of(0);\n+            \/\/ We probably should just use a regular for loop here ;)\n+            ifOp.bodies().forEach(b->{\n+                int idx = i.get();\n+                if (b.yieldType() instanceof JavaType javaType && javaType == JavaType.VOID) {\n+                    if (ifOp.bodies().size() > idx && ifOp.bodies().get(idx).entryBlock().ops().size() > 1){\n+                        if (lastWasBody.get()) {\n+                            elseKeyword();\n+                        }\n+                        braceNlIndented(_ ->\n+                                nlSeparated(OpHelper.Statement.statements(ifOp.bodies().get(idx).entryBlock()),\n+                                        root-> statement(buildContext,root)\n+                                ));\n+                    }\n+                    lastWasBody.set(true);\n+                } else {\n+                    when(idx>0,_-> elseKeyword().space());\n+                    ifKeyword().paren(_ ->\n+                            ifOp.bodies().get(idx).entryBlock()            \/\/ get the entryblock if bodies[c.value]\n+                                    .ops().stream().filter(o->o instanceof CoreOp.YieldOp) \/\/ we want all the yields\n+                                    .forEach((yield) -> recurse(buildContext, yield))\n+                    );\n+                    lastWasBody.set(false);\n+                }\n+                i.set(i.get()+1);\n+            });\n+        });\n+        return self();\n+    }\n+\n+    @Override\n+    public final T whileOp(ScopedCodeBuilderContext buildContext, JavaOp.WhileOp whileOp) {\n+        whileKeyword().paren(_ ->\n+                OpHelper.entryBlockOfBodyN(whileOp, 0)\n+                        .ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n+                        .forEach(o -> recurse(buildContext, o))\n+        );\n+        braceNlIndented(_ ->\n+                nlSeparated(OpHelper.Statement.loopBodyStatements(whileOp),\n+                        statement->statement(buildContext,statement)\n+                )\n+        );\n+        return self();\n+    }\n+\n+    @Override\n+    public final T forOp(ScopedCodeBuilderContext buildContext, JavaOp.ForOp forOp) {\n+        buildContext.forScope(forOp, () ->\n+                forKeyword().paren(_ -> {\n+                    forOp.init().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+                    semicolon().space();\n+                    forOp.cond().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+                    semicolon().space();\n+                    commaSpaceSeparated(\n+                            OpHelper.Statement.statements(forOp.update().entryBlock()),\n+                            op -> recurse(buildContext, op)\n+                    );\n+                }).braceNlIndented(_ ->\n+                        nlSeparated(OpHelper.Statement.loopBodyStatements(forOp),\n+                                statement ->statement(buildContext,statement)\n+                        )\n+                )\n+        );\n+        return self();\n+    }\n+\n+    @Override\n+    public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n+        var invoke = invoke(buildContext.lookup,invokeOp);\n+\n+            funcName(invoke.op()).paren(_ ->\n+                    commaSpaceSeparated(invoke.op().operands(),\n+                            op -> {if (op instanceof Op.Result result) {recurse(buildContext, result.op());}\n+                            })\n+            );\n+\n+        return self();\n+    }\n+\n+    @Override\n+    public final T conditionalExpressionOp(ScopedCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp) {\n+        OpHelper.Ternary ternary = ternary(buildContext.lookup,ternaryOp);\n+        ternary.condBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        questionMark();\n+        ternary.thenBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        colon();\n+        ternary.elseBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        return self();\n+    }\n+\n+    \/**\n+     * Wrap paren() of precedence of op is higher than parent.\n+     *\n+     * @param buildContext\n+     * @param parent\n+     * @param child\n+     *\/\n+    @Override\n+    public final  T parenthesisIfNeeded(ScopedCodeBuilderContext buildContext, Op parent, Op child) {\n+        return parenWhen(Precedence.needsParenthesis(parent,child), _ -> recurse(buildContext, child));\n+    }\n+\n+    @Override\n+    public final  T returnOp(ScopedCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp) {\n+        returnKeyword().when(!returnOp.operands().isEmpty(),\n+                $-> $.space().parenthesisIfNeeded(buildContext, returnOp, ((Op.Result) returnOp.operands().getFirst()).op())\n+        );\n+        return self();\n+    }\n+\n+    public final  T statement(ScopedCodeBuilderContext buildContext,Op op) {\n+        recurse(buildContext, op);\n+        if (switch (op){\n+            case JavaOp.ForOp _ -> false;\n+            case JavaOp.WhileOp _ -> false;\n+            case JavaOp.IfOp _ -> false;\n+            case JavaOp.LabeledOp _ -> false;\n+            case JavaOp.YieldOp _ -> false;\n+            case CoreOp.TupleOp _ ->false;\n+            default -> true;\n+        }\n+        ){\n+            semicolon();\n+        }\n+        return self();\n+    }\n+\n+    public final  T declareParam(ScopedCodeBuilderContext buildContext, FuncOpParams.Info param){\n+        return  type(buildContext,(JavaType) param.parameter.type()).space().varName(param.varOp);\n+    }\n+\n+    @Override\n+    public T newOp(ScopedCodeBuilderContext buildContext, JavaOp.NewOp newOp) {\n+         newKeyword().space().type(buildContext,(JavaType) newOp.type());\n+       if (newOp.operands().isEmpty()){\n+           ocparen();\n+       }else {\n+           if (newOp.type() instanceof ArrayType){\n+               brace(_ -> {\n+                   commaSpaceSeparated(newOp.operands(),\n+                           op -> {\n+                               if (op instanceof Op.Result result) {\n+                                   recurse(buildContext, result.op());\n+                               }\n+                           });\n+               });\n+           }else {\n+               paren(_ -> {\n+                   commaSpaceSeparated(newOp.operands(),\n+                           op -> {\n+                               if (op instanceof Op.Result result) {\n+                                   recurse(buildContext, result.op());\n+                               }\n+                           });\n+               });\n+           }\n+       }\n+       return self();\n+    }\n+    @Override\n+    public T arrayLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp){\n+        recurse(buildContext,((Op.Result)arrayLoadOp.operands().get(0)).op());\n+        sbrace(_-> recurse(buildContext,((Op.Result)arrayLoadOp.operands().get(1)).op()));\n+        return self();\n+    }\n+\n+    @Override\n+    public T arrayStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp){\n+        recurse(buildContext,((Op.Result)arrayStoreOp.operands().get(0)).op());\n+        sbrace(_-> recurse(buildContext,((Op.Result)arrayStoreOp.operands().get(1)).op()));\n+        space().equals().space();\n+        recurse(buildContext,((Op.Result)arrayStoreOp.operands().get(2)).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public T enhancedForOp(ScopedCodeBuilderContext builderContext, JavaOp.EnhancedForOp enhancedForOp){\n+        forKeyword().paren(_-> {\n+            enhancedForOp.initialization().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(builderContext, o));\n+            space().colon().space().blockInlineComment(\"Get rid of = before this\");\n+            enhancedForOp.expression().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(builderContext, o));\n+        }).braceNlIndented(_->\n+            nlSeparated(OpHelper.Statement.loopBodyStatements(enhancedForOp),\n+                    statement ->statement(builderContext,statement)\n+            )\n+\n+        );\n+        return self();\n+    }\n+    @Override\n+    public final T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp) {\n+        braceNlIndented(_-> {\n+            blockInlineComment(\"LAMBDA\");\n+            nlSeparated(OpHelper.Statement.bodyStatements(lambdaOp.body()),\n+                    statement -> statement(buildContext, statement)\n+            );\n+            blockInlineComment(\"ADBMAL\");\n+        });\n+        return self();\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaOrC99StyleCodeBuilder.java","additions":495,"deletions":0,"binary":false,"changes":495,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.dialect.core.VarType;\n@@ -65,0 +66,3 @@\n+            if (value instanceof Block.Parameter parameter){\n+                return parameter.uses().iterator().next().op();\n+            }\n@@ -82,1 +86,2 @@\n-                    throw new IllegalStateException(\"what ?\");\n+                    return super.resolve(value);\n+                    \/\/throw new IllegalStateException(\"what ?\");\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/ScopedCodeBuilderContext.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.OpHelper;\n+\n@@ -28,0 +32,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -61,0 +66,40 @@\n+\n+\n+\n+    public record TypeAndAccess(Annotation[] annotations, Value value, JavaType javaType) {\n+        public static TypeAndAccess of(Annotation[] annotations, Value value) {\n+            return new TypeAndAccess(annotations, value, (JavaType) value.type());\n+        }\n+\n+      public  boolean isIface(MethodHandles.Lookup lookup) {\n+            return OpHelper.isAssignable(lookup, javaType, MappableIface.class);\n+        }\n+\n+      public   boolean ro() {\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof MappableIface.RO) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+       public boolean rw() {\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof MappableIface.RW) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+       public boolean wo() {\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof MappableIface.WO) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/ifacemapper\/AccessType.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -52,1 +52,4 @@\n-                 JavaOp.WhileOp _\n+                 JavaOp.WhileOp _,\n+                 JavaOp.ArrayAccessOp.ArrayLoadOp _,\n+                 JavaOp.ArrayAccessOp.ArrayStoreOp _,\n+                 JavaOp.NewOp _\n@@ -94,0 +97,1 @@\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/util\/ops\/Precedence.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.codebuilders.JavaHATCodeBuilder;\n+import optkl.codebuilders.JavaCodeBuilder;\n@@ -84,1 +84,1 @@\n-       var builder=  new JavaHATCodeBuilder(MethodHandles.lookup(),mandel);\n+       var builder=  new JavaCodeBuilder(MethodHandles.lookup(),mandel);\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/TestJavaHATCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,0 +75,26 @@\n+    \/**\n+     * Returns this value as an operation result.\n+     *\n+     * @return the value as an operation result.\n+     * @throws IllegalStateException if the value is not an instance of an operation result.\n+     *\/\n+    public Op.Result result() {\n+        if (this instanceof Op.Result r) {\n+            return r;\n+        }\n+        throw new IllegalStateException(\"Value is not an instance of operation result\");\n+    }\n+\n+    \/**\n+     * Returns this value as a block parameter.\n+     *\n+     * @return the value as a block parameter.\n+     * @throws IllegalStateException if the value is not an instance of a block parameter.\n+     *\/\n+    public Block.Parameter parameter() {\n+        if (this instanceof Block.Parameter p) {\n+            return p;\n+        }\n+        throw new IllegalStateException(\"Value is not an instance of block parameter\");\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Value.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n- * This operation accepts an int operand, variable number of distinct constant labels\n- * and the same number of successors.\n+ * This operation accepts an int computational type operand (JVMS 2.11.1-B),\n+ * variable number of distinct constant labels and the same number of successors.\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/ConstantLabelSwitchOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.stream.Stream;\n@@ -51,0 +52,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -106,1 +108,15 @@\n-        block.op(new ConstantLabelSwitchOp(selector, labelsAndTargets.labels(), blocks.stream().map(Block.Builder::successor).toList()));\n+        if (ConstantLabelSwitchChecker.isIntegralReferenceType(selector.type())) {\n+            \/\/ unbox selector\n+            if (selector.type().equals(J_L_CHARACTER)) {\n+                selector = block.op(JavaOp.invoke(MethodRef.method(selector.type(), \"charValue\", JavaType.CHAR), selector));\n+            } else {\n+                selector = block.op(JavaOp.invoke(MethodRef.method(selector.type(), \"intValue\", JavaType.INT), selector));\n+            }\n+        }\n+        var labels = labelsAndTargets.labels();\n+        if (!labels.contains(null)) {\n+            \/\/ implicit default to exit\n+            labels.add(null);\n+            blocks.add(exit);\n+        }\n+        block.op(new ConstantLabelSwitchOp(selector, labels, blocks.stream().map(Block.Builder::successor).toList()));\n@@ -279,1 +295,6 @@\n-                block.op(((Op.Result) vop.initOperand()).op());\n+                Op cop = ((Op.Result) vop.initOperand()).op();\n+                if (cop instanceof JavaOp.ConvOp) {\n+                    \/\/ converted constant\n+                    block.op(((Op.Result)cop.operands().getFirst()).op());\n+                }\n+                block.op(cop);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/LoweringTransform.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -21,0 +21,2 @@\n+ * @run main Unreflect TestSwitchExpressionOp\n+ * @run junit TestSwitchExpressionOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,4 +18,7 @@\n-* @test\n-* @modules jdk.incubator.code\n-* @run junit TestSwitchStatementOp\n-* *\/\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run junit TestSwitchStatementOp\n+ * @run main Unreflect TestSwitchStatementOp\n+ * @run junit TestSwitchStatementOp\n+ *\n+ *\/\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchStatementOp.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run junit TestValueCast\n+ * @run junit\/othervm -Dbabylon.ssa=cytron TestValueCast\n+ *\/\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.function.IntBinaryOperator;\n+import java.util.stream.Stream;\n+\n+public class TestValueCast {\n+\n+    public JavaOp.LambdaOp f() {\n+        IntBinaryOperator ibo = (@Reflect IntBinaryOperator) (a, b) -> {\n+            if (a > b) {\n+                a *= 2;\n+                return a % b;\n+            }\n+            return a + b;\n+        };\n+        return (JavaOp.LambdaOp) Op.ofQuotable(ibo).get().op();\n+    }\n+\n+    static Stream<Value> values(CodeElement<?, ?> r) {\n+        return r.elements().mapMulti((e, c) -> {\n+            switch (e) {\n+                case Block block -> block.parameters().forEach(c);\n+                case Op op -> c.accept(op.result());\n+                case Body _ -> { }\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testCast() {\n+        JavaOp.LambdaOp f = f();\n+        Stream<Value> stream = values(f);\n+        stream.forEach(v -> {\n+            switch (v) {\n+                case Op.Result r -> Assertions.assertEquals(r, v.result());\n+                case Block.Parameter p -> Assertions.assertEquals(p, v.parameter());\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testExceptions() {\n+        JavaOp.LambdaOp f = f();\n+        Stream<Value> stream = values(f);\n+        stream.forEach(v -> {\n+            switch (v) {\n+                case Op.Result r -> Assertions.assertThrows(IllegalStateException.class, () -> v.parameter());\n+                case Block.Parameter p -> Assertions.assertThrows(IllegalStateException.class, () -> v.result());\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestValueCast.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}