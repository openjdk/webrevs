{"files":[{"patch":"@@ -380,1 +380,1 @@\n-            String code = config.isPTX() ? createPTX(kernelCallGraph,  args) : createC99(kernelCallGraph,  ndRange, args);\n+            String code = config.isPTX() ? createPTX(kernelCallGraph,  args) : createC99(kernelCallGraph, args);\n@@ -413,1 +413,2 @@\n-        out.append(builder.getTextAndReset());\n+        out.append(builder.getText());\n+        builder.clear();\n@@ -452,1 +453,0 @@\n-                   \/\/ && OpWrapper.wrap(func.lookup,invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n@@ -492,1 +492,2 @@\n-        String out = builder.getTextAndReset();\n+        String out = builder.getText();\n+        builder.clear();\n@@ -497,1 +498,2 @@\n-        String body = builder.getTextAndReset();\n+        String body = builder.getText();\n+        builder.clear();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public abstract class CodeBuilder<T extends CodeBuilder<T>> extends TextBuilder<T> {\n+public abstract class CodeBuilder<T extends CodeBuilder<T>> extends TextBuilder<T>  implements CodeRenderer<T> {\n@@ -498,0 +498,49 @@\n+\n+\n+    @Override\n+    public final T comment(String text) {\n+        return emitText(text);\n+    }\n+    @Override\n+    public T identifier(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public T reserved(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public T label(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public final T symbol(String text) {\n+        return emitText(text);\n+    }\n+    @Override\n+    public final T typeName(String text) {\n+        return emitText(text);\n+    }\n+    @Override\n+    public final T keyword(String text) {\n+        return emitText(text);\n+    }\n+\n+    @Override\n+    public final T literal(String text) {\n+        return emitText(text);\n+    }\n+    @Override\n+    public T nl() {\n+      return super.nl();\n+    }\n+\n+    @Override\n+    public T space() {\n+        return emitText(\" \");\n+    }\n+\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilder.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-public interface TextRenderer<T extends TextBuilder<T>>{\n+public interface CodeRenderer<T extends CodeBuilder<T>>{\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeRenderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/TextRenderer.java","status":"renamed"},{"patch":"@@ -48,1 +48,1 @@\n-public abstract class TextBuilder<T extends TextBuilder<T>> implements TextRenderer<T> {\n+public abstract class TextBuilder<T extends TextBuilder<T>> {\n@@ -88,1 +88,1 @@\n-    State state = new State();\n+    private State state = new State();\n@@ -90,1 +90,1 @@\n-    public T reset() {\n+    public T clear() {\n@@ -99,5 +99,1 @@\n-    public String getTextAndReset() {\n-        String text = getText();\n-        reset();\n-        return text;\n-    }\n+\n@@ -132,5 +128,0 @@\n-    public T indent() {\n-        state.indentation();\n-        return self();\n-    }\n-\n@@ -142,18 +133,0 @@\n-    @Override\n-    public final T comment(String text) {\n-        return emitText(text);\n-    }\n-    @Override\n-    public T identifier(String text) {\n-        return emitText(text);\n-    }\n-\n-    @Override\n-    public T reserved(String text) {\n-        return emitText(text);\n-    }\n-\n-    @Override\n-    public T label(String text) {\n-        return emitText(text);\n-    }\n@@ -164,0 +137,2 @@\n+\n+\n@@ -171,18 +146,0 @@\n-    @Override\n-    public final T symbol(String text) {\n-        return emitText(text);\n-    }\n-    @Override\n-    public final T typeName(String text) {\n-        return emitText(text);\n-    }\n-    @Override\n-    public final T keyword(String text) {\n-        return emitText(text);\n-    }\n-\n-    @Override\n-    public final T literal(String text) {\n-        return emitText(text);\n-    }\n-\n@@ -206,2 +163,0 @@\n-\n-    @Override\n@@ -211,1 +166,0 @@\n-\n@@ -214,6 +168,0 @@\n-\n-    @Override\n-    public T space() {\n-         return emitText(\" \");\n-    }\n-\n@@ -225,0 +173,3 @@\n+\n+\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/TextBuilder.java","additions":9,"deletions":58,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,824 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.text;\n+\n+import java.io.*;\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.WildcardType;\n+import jdk.incubator.code.extern.ExternalizedOp;\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n+\n+import java.lang.reflect.Array;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * A writer of code models to the textual form.\n+ * <p>\n+ * A code model in textual form may be parsed back into the runtime form by parsing it.\n+ *\/\n+public final class OpCodeBuilder {\n+\n+    \/\/ Hacked from jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/JavaTypeUtils.java\n+static class JavaTypeUtils{\n+\n+    \/\/ useful type identifiers\n+\n+    \/**  Inflated Java class type name *\/\n+    public static final String JAVA_TYPE_CLASS_NAME = \"java.type.class\";\n+    \/**  Inflated Java array type name *\/\n+    public static final String JAVA_TYPE_ARRAY_NAME = \"java.type.array\";\n+    \/**  Inflated Java wildcard type name *\/\n+    public static final String JAVA_TYPE_WILDCARD_NAME = \"java.type.wildcard\";\n+    \/**  Inflated Java type var name *\/\n+    public static final String JAVA_TYPE_VAR_NAME = \"java.type.var\";\n+    \/**  Inflated Java primitive type name *\/\n+    public static final String JAVA_TYPE_PRIMITIVE_NAME = \"java.type.primitive\";\n+\n+    \/** Inflated Java field reference name *\/\n+    public static final String JAVA_REF_FIELD_NAME = \"java.ref.field\";\n+    \/** Inflated Java method reference name *\/\n+    public static final String JAVA_REF_METHOD_NAME = \"java.ref.method\";\n+    \/** Inflated Java constructor reference name *\/\n+    public static final String JAVA_REF_CONSTRUCTOR_NAME = \"java.ref.constructor\";\n+    \/** Inflated Java record name *\/\n+    public static final String JAVA_REF_RECORD_NAME = \"java.ref.record\";\n+\n+    \/** Flattened Java type name *\/\n+    public static final String JAVA_TYPE_FLAT_NAME_PREFIX = \"java.type:\";\n+    \/** Flattened Java reference name *\/\n+    public static final String JAVA_REF_FLAT_NAME_PREFIX = \"java.ref:\";\n+\n+    \/**\n+     * An enum modelling the Java type form kind. Useful for switching.\n+     *\/\n+    public enum Kind {\n+        \/** A flattened type form *\/\n+        FLATTENED_TYPE,\n+        \/** A flattened reference form *\/\n+        FLATTENED_REF,\n+        \/** An inflated type form *\/\n+        INFLATED_TYPE,\n+        \/** An inflated reference form *\/\n+        INFLATED_REF,\n+        \/** Some other form *\/\n+        OTHER;\n+\n+        \/**\n+         * Constructs a new kind from an externalized type form\n+         * @param tree the externalized type form\n+         * @return the kind modelling {@code tree}\n+         *\/\n+        public static Kind of(ExternalizedTypeElement tree) {\n+            return switch (tree.identifier()) {\n+                case JAVA_TYPE_CLASS_NAME, JAVA_TYPE_ARRAY_NAME,\n+                     JAVA_TYPE_PRIMITIVE_NAME, JAVA_TYPE_WILDCARD_NAME,\n+                     JAVA_TYPE_VAR_NAME -> INFLATED_TYPE;\n+                case JAVA_REF_FIELD_NAME, JAVA_REF_CONSTRUCTOR_NAME,\n+                     JAVA_REF_METHOD_NAME, JAVA_REF_RECORD_NAME -> INFLATED_REF;\n+                case String s when s.startsWith(JAVA_TYPE_FLAT_NAME_PREFIX) -> FLATTENED_TYPE;\n+                case String s when s.startsWith(JAVA_REF_FLAT_NAME_PREFIX) -> FLATTENED_REF;\n+                default -> OTHER;\n+            };\n+        }\n+    }\n+    private static ExternalizedTypeElement nameToType(String name) {\n+        return ExternalizedTypeElement.of(name);\n+    }\n+    private static <T> T select(ExternalizedTypeElement tree, int index, Function<ExternalizedTypeElement, T> valueFunc) {\n+        if (index >= tree.arguments().size()) {\n+            throw new UnsupportedOperationException();\n+        }\n+        return valueFunc.apply(tree.arguments().get(index));\n+    }\n+    private static <T> List<T> selectFrom(ExternalizedTypeElement tree, int startIncl, Function<ExternalizedTypeElement, T> valueFunc) {\n+        if (startIncl >= tree.arguments().size()) {\n+            return List.of();\n+        }\n+        return IntStream.range(startIncl, tree.arguments().size())\n+                .mapToObj(i -> valueFunc.apply(tree.arguments().get(i)))\n+                .toList();\n+    }\n+\n+    private static String typeToName(ExternalizedTypeElement tree) {\n+        if (!tree.arguments().isEmpty()) {\n+            throw new UnsupportedOperationException();\n+        }\n+        return tree.identifier();\n+    }\n+\n+    \/**\n+     * {@return a flat string modelling the provided inflated Java reference form}.\n+     * @param tree the inflated Java type form\n+     *\/\n+    public static String toExternalRefString(ExternalizedTypeElement tree) {\n+        return switch (tree.identifier()) {\n+            case JAVA_REF_FIELD_NAME -> {\n+                String owner = select(tree, 0, JavaTypeUtils::toExternalTypeString);\n+                String fieldName = select(tree, 1, JavaTypeUtils::typeToName);\n+                String fieldType = select(tree, 2, JavaTypeUtils::toExternalTypeString);\n+                yield String.format(\"%s::%s:%s\", owner, fieldName, fieldType);\n+            }\n+            case JAVA_REF_METHOD_NAME -> {\n+                String owner = select(tree, 0, JavaTypeUtils::toExternalTypeString);\n+                ExternalizedTypeElement nameAndArgs = select(tree, 1, Function.identity());\n+                String methodName = nameAndArgs.identifier();\n+                List<String> paramTypes = selectFrom(nameAndArgs, 0, JavaTypeUtils::toExternalTypeString);\n+                String restype = select(tree, 2, JavaTypeUtils::toExternalTypeString);\n+                yield String.format(\"%s::%s(%s):%s\", owner, methodName, String.join(\", \", paramTypes), restype);\n+            }\n+            case JAVA_REF_CONSTRUCTOR_NAME -> {\n+                String owner = select(tree, 0, JavaTypeUtils::toExternalTypeString);\n+                ExternalizedTypeElement nameAndArgs = select(tree, 1, Function.identity());\n+                List<String> paramTypes = selectFrom(nameAndArgs, 0, JavaTypeUtils::toExternalTypeString);\n+                yield String.format(\"%s::(%s)\", owner, String.join(\", \", paramTypes));\n+            }\n+            case JAVA_REF_RECORD_NAME -> {\n+                String owner = select(tree, 0, JavaTypeUtils::toExternalTypeString);\n+                List<String> components = selectFrom(tree, 1, Function.identity()).stream()\n+                        .map(t -> {\n+                            String componentName = t.identifier();\n+                            String componentType = select(t, 0, JavaTypeUtils::toExternalTypeString);\n+                            return String.format(\"%s %s\", componentType, componentName);\n+                        }).toList();\n+                yield String.format(\"(%s)%s\", String.join(\", \", components), owner);\n+            }\n+            default ->  throw new UnsupportedOperationException();\n+        };\n+    }\n+\n+    private static boolean isSameType(ExternalizedTypeElement tree, TypeElement typeElement) {\n+        return tree.equals(typeElement.externalize());\n+    }\n+\n+    \/**\n+     * {@return a flat string modelling the provided inflated Java type form}.\n+     * @param tree the inflated Java type form\n+     *\/\n+    public static String toExternalTypeString(ExternalizedTypeElement tree) {\n+        return switch (tree.identifier()) {\n+            case JAVA_TYPE_CLASS_NAME -> {\n+                String className = select(tree, 0, JavaTypeUtils::typeToName);\n+                ExternalizedTypeElement enclosing = select(tree, 1, Function.identity());\n+                String typeargs = tree.arguments().size() == 2 ?\n+                        \"\" :\n+                        selectFrom(tree, 2, JavaTypeUtils::toExternalTypeString).stream()\n+                                .collect(Collectors.joining(\", \", \"<\", \">\"));\n+                if (isSameType(enclosing, JavaType.VOID)) {\n+                    yield String.format(\"%s%s\", className, typeargs);\n+                } else {\n+                    String enclosingString = toExternalTypeString(enclosing);\n+                    yield String.format(\"%s::%s%s\", enclosingString, className, typeargs);\n+                }\n+            }\n+            case JAVA_TYPE_ARRAY_NAME -> {\n+                String componentType = select(tree, 0, JavaTypeUtils::toExternalTypeString);\n+                yield String.format(\"%s[]\", componentType);\n+            }\n+            case JAVA_TYPE_WILDCARD_NAME -> {\n+                WildcardType.BoundKind boundKind = select(tree, 0, t -> WildcardType.BoundKind.valueOf(typeToName(t)));\n+                ExternalizedTypeElement bound = select(tree, 1, Function.identity());\n+                yield boundKind == WildcardType.BoundKind.EXTENDS && isSameType(bound, JavaType.J_L_OBJECT) ?\n+                        \"?\" :\n+                        String.format(\"? %s %s\", boundKind.name().toLowerCase(), toExternalTypeString(bound));\n+            }\n+            case JAVA_TYPE_VAR_NAME -> {\n+                String tvarName = select(tree, 0, JavaTypeUtils::typeToName);\n+                String owner = select(tree, 1, t ->\n+                        switch (Kind.of(t)) {\n+                            case INFLATED_REF -> \"&\" + toExternalRefString(t);\n+                            case INFLATED_TYPE -> toExternalTypeString(t);\n+                            default ->  throw new UnsupportedOperationException();\n+                        });\n+                ExternalizedTypeElement bound = select(tree, 2, Function.identity());\n+                yield isSameType(bound, JavaType.J_L_OBJECT) ?\n+                        String.format(\"%s::<%s>\", owner, tvarName) :\n+                        String.format(\"%s::<%s extends %s>\", owner, tvarName, toExternalTypeString(bound));\n+            }\n+            case JAVA_TYPE_PRIMITIVE_NAME -> select(tree, 0, JavaTypeUtils::typeToName);\n+            default -> throw  new UnsupportedOperationException();\n+        };\n+    }\n+\n+    \/**\n+     * {@return the flat Java form corresponding to the provided inflated Java form}\n+     * @param tree the inflated Java form\n+     *\/\n+    public static ExternalizedTypeElement flatten(ExternalizedTypeElement tree) {\n+        return switch (Kind.of(tree)) {\n+            case INFLATED_TYPE -> nameToType(String.format(\"%s\\\"%s\\\"\", JAVA_TYPE_FLAT_NAME_PREFIX, toExternalTypeString(tree)));\n+            case INFLATED_REF -> nameToType(String.format(\"%s\\\"%s\\\"\", JAVA_REF_FLAT_NAME_PREFIX, toExternalRefString(tree)));\n+            default -> ExternalizedTypeElement.of(tree.identifier(), tree.arguments().stream().map(JavaTypeUtils::flatten).toList());\n+        };\n+    }\n+\n+}\n+    \/**\n+     * The attribute name associated with the location attribute.\n+     *\/\n+    static final String ATTRIBUTE_LOCATION = \"loc\";\n+\n+    static final class GlobalValueBlockNaming implements Function<CodeItem, String> {\n+        final Map<CodeItem, String> gn;\n+        int valueOrdinal = 0;\n+\n+        GlobalValueBlockNaming() {\n+            this.gn = new HashMap<>();\n+        }\n+\n+        private String name(Block b) {\n+            Block p = b.ancestorBlock();\n+            return (p == null ? \"block_\" : name(p) + \"_\") + b.index();\n+        }\n+\n+        @Override\n+        public String apply(CodeItem codeItem) {\n+            return switch (codeItem) {\n+                case Block block -> gn.computeIfAbsent(block, _b -> name(block));\n+                case Value value -> gn.computeIfAbsent(value, _v -> String.valueOf(valueOrdinal++));\n+                default -> throw new IllegalStateException(\"Unexpected code item: \" + codeItem);\n+            };\n+        }\n+    }\n+\n+    static final class AttributeMapper {\n+        static String toString(Object value) {\n+            if (value == ExternalizedOp.NULL_ATTRIBUTE_VALUE) {\n+                return \"null\";\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            toString(value, sb);\n+            return sb.toString();\n+        }\n+\n+        static void toString(Object o, StringBuilder sb) {\n+            if (o.getClass().isArray()) {\n+                \/\/ note, while we can't parse back the array representation, this might be useful\n+                \/\/ for non-externalizable ops that want better string representation of array attribute values (e.g. ONNX)\n+                arrayToString(o, sb);\n+            } else {\n+                switch (o) {\n+                    case Integer i -> sb.append(i);\n+                    case Long l -> sb.append(l).append('L');\n+                    case Float f -> sb.append(f).append('f');\n+                    case Double d -> sb.append(d).append('d');\n+                    case Character c -> sb.append('\\'').append(c).append('\\'');\n+                    case Boolean b -> sb.append(b);\n+                    case TypeElement te -> sb.append(JavaTypeUtils.flatten(te.externalize()).toString());\n+                    default -> {  \/\/ fallback to a string\n+                        sb.append('\"');\n+                        quote(o.toString(), sb);\n+                        sb.append('\"');\n+                    }\n+                }\n+            }\n+        }\n+\n+        static void arrayToString(Object a, StringBuilder sb) {\n+            boolean first = true;\n+            sb.append(\"[\");\n+            for (int i = 0; i < Array.getLength(a); i++) {\n+                if (!first) {\n+                    sb.append(\", \");\n+                }\n+                toString(Array.get(a, i), sb);\n+                first = false;\n+            }\n+            sb.append(\"]\");\n+        }\n+    }\n+\n+    static void quote(String s, StringBuilder sb) {\n+        for (int i = 0; i < s.length(); i++) {\n+            sb.append(quote(s.charAt(i)));\n+        }\n+    }\n+\n+    \/**\n+     * Escapes a character if it has an escape sequence or is\n+     * non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    \/\/ Copied from com.sun.tools.javac.util.Convert\n+    static String quote(char ch) {\n+        return switch (ch) {\n+            case '\\b' -> \"\\\\b\";\n+            case '\\f' -> \"\\\\f\";\n+            case '\\n' -> \"\\\\n\";\n+            case '\\r' -> \"\\\\r\";\n+            case '\\t' -> \"\\\\t\";\n+            case '\\'' -> \"\\\\'\";\n+            case '\\\"' -> \"\\\\\\\"\";\n+            case '\\\\' -> \"\\\\\\\\\";\n+            default -> (isPrintableAscii(ch))\n+                    ? String.valueOf(ch)\n+                    : String.format(\"\\\\u%04x\", (int) ch);\n+        };\n+    }\n+\n+    \/**\n+     * Is a character printable ASCII?\n+     *\/\n+    static boolean isPrintableAscii(char ch) {\n+        return ch >= ' ' && ch <= '~';\n+    }\n+\n+    static final class IndentWriter {\n+        static final int INDENT = 2;\n+        private final Writer w;\n+        private int indent;\n+        private boolean writeIndent = true;\n+\n+        IndentWriter(Writer w) {\n+            this(w, 0);\n+        }\n+\n+        IndentWriter(Writer w, int indent) {\n+            this.w = w;\n+            this.indent = indent;\n+        }\n+\n+\n+        public void write(String s)  {\n+            try {\n+                if (writeIndent) {\n+                    w.write(\" \".repeat(indent));\n+                    writeIndent = false;\n+                }\n+                w.write(s);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+\n+        }\n+\n+        public void nl(){\n+            write(\"\\n\");\n+            writeIndent=true;\n+        }\n+\n+        public void symbol(String symbol){\n+           write(symbol);\n+        }\n+\n+        void space(){\n+            write(\" \");\n+        }\n+\n+        void in() {\n+            indent += INDENT;\n+        }\n+        void out() {\n+            indent -= INDENT;\n+        }\n+    }\n+\n+    \/**\n+     * Computes global names for blocks and values in a code model.\n+     * <p>\n+     * The code model is traversed in the same order as if the model\n+     * was written. Therefore, the names in the returned map will the\n+     * same as the names that are written. This can be useful for debugging\n+     * and testing.\n+     *\n+     * @param root the code model\n+     * @return the map of computed names, modifiable\n+     *\/\n+    public static Function<CodeItem, String> computeGlobalNames(Op root) {\n+        OpCodeBuilder w = new OpCodeBuilder(Writer.nullWriter());\n+        w.writeOp(root);\n+        return w.namer();\n+    }\n+\n+    \/**\n+     * Writes a code model (an operation) to the output stream, using the UTF-8 character set.\n+     *\n+     * @param out the output stream\n+     * @param op the code model\n+     *\/\n+    public static void writeTo(OutputStream out, Op op, Option... options) {\n+        writeTo(new OutputStreamWriter(out, StandardCharsets.UTF_8), op, options);\n+    }\n+\n+    \/**\n+     * Writes a code model (an operation) to the character stream.\n+     * <p>\n+     * The character stream will be flushed after the model is writen.\n+     *\n+     * @param w the character stream\n+     * @param op the code model\n+     * @param options the writer options\n+     *\/\n+    public static void writeTo(Writer w, Op op, Option... options) {\n+        OpCodeBuilder ow = new OpCodeBuilder(w, options);\n+        ow.writeOp(op);\n+        try {\n+            \/\/ @@@ Is this needed?\n+            w.flush();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Writes a code model (an operation) to a string.\n+     *\n+     * @param op the code model\n+     * @param options the writer options\n+     *\/\n+    public static String toText(Op op, OpCodeBuilder.Option... options) {\n+        StringWriter w = new StringWriter();\n+        writeTo(w, op, options);\n+        return w.toString();\n+    }\n+\n+    \/**\n+     * An option that affects the writing operations.\n+     *\/\n+    public sealed interface Option {\n+    }\n+\n+    \/**\n+     * An option describing the function to use for naming code items.\n+     *\/\n+    public sealed interface CodeItemNamerOption extends Option\n+            permits NamerOptionImpl {\n+\n+        static CodeItemNamerOption of(Function<CodeItem, String> named) {\n+            return new NamerOptionImpl(named);\n+        }\n+\n+        static CodeItemNamerOption defaultValue() {\n+            return of(new GlobalValueBlockNaming());\n+        }\n+\n+        Function<CodeItem, String> namer();\n+    }\n+    private record NamerOptionImpl(Function<CodeItem, String> namer) implements CodeItemNamerOption {\n+    }\n+\n+    \/**\n+     * An option describing whether location information should be written or dropped.\n+     *\/\n+    public enum LocationOption implements Option {\n+        \/** Writes location *\/\n+        WRITE_LOCATION,\n+        \/** Drops location *\/\n+        DROP_LOCATION;\n+\n+        public static LocationOption defaultValue() {\n+            return WRITE_LOCATION;\n+        }\n+    }\n+\n+    \/**\n+     * An option describing whether an operation's descendant code elements should be written or dropped.\n+     *\/\n+    public enum OpDescendantsOption implements Option {\n+        \/** Writes descendants of an operation, if any *\/\n+        WRITE_DESCENDANTS,\n+        \/** Drops descendants of an operation, if any *\/\n+        DROP_DESCENDANTS;\n+\n+        public static OpDescendantsOption defaultValue() {\n+            return WRITE_DESCENDANTS;\n+        }\n+    }\n+\n+    \/**\n+     * An option describing whether an operation's result be written or dropped if its type is void.\n+     *\/\n+    public enum VoidOpResultOption implements Option {\n+        \/** Writes void operation result *\/\n+        WRITE_VOID,\n+        \/** Drops void operation result *\/\n+        DROP_VOID;\n+\n+        public static VoidOpResultOption defaultValue() {\n+            return DROP_VOID;\n+        }\n+    }\n+\n+    final Function<CodeItem, String> namer;\n+    final IndentWriter w;\n+    final boolean dropLocation;\n+    final boolean dropOpDescendants;\n+    final boolean writeVoidOpResult;\n+\n+    \/**\n+     * Creates a writer of code models (operations) to their textual form.\n+     *\n+     * @param w the character stream writer to write the textual form.\n+     *\/\n+    public OpCodeBuilder(Writer w) {\n+        this.w = new IndentWriter(w);\n+        this.namer = new GlobalValueBlockNaming();\n+        this.dropLocation = false;\n+        this.dropOpDescendants = false;\n+        this.writeVoidOpResult = false;\n+    }\n+\n+    \/**\n+     * Creates a writer of code models (operations) to their textual form.\n+     *\n+     * @param w the character stream writer to write the textual form.\n+     * @param options the writer options\n+     *\/\n+    public OpCodeBuilder(Writer w, Option... options) {\n+        Function<CodeItem, String> namer = null;\n+        boolean dropLocation = false;\n+        boolean dropOpDescendants = false;\n+        boolean writeVoidOpResult = false;\n+        for (Option option : options) {\n+            switch (option) {\n+                case CodeItemNamerOption namerOption -> {\n+                    namer = namerOption.namer();\n+                }\n+                case LocationOption locationOption -> {\n+                    dropLocation = locationOption ==\n+                            LocationOption.DROP_LOCATION;\n+                }\n+                case OpDescendantsOption opDescendantsOption -> {\n+                    dropOpDescendants = opDescendantsOption ==\n+                            OpDescendantsOption.DROP_DESCENDANTS;\n+                }\n+                case VoidOpResultOption voidOpResultOption -> {\n+                    writeVoidOpResult = voidOpResultOption == VoidOpResultOption.WRITE_VOID;\n+                }\n+            }\n+        }\n+\n+        this.w = new IndentWriter(w);\n+        this.namer = (namer == null) ? new GlobalValueBlockNaming() : namer;\n+        this.dropLocation = dropLocation;\n+        this.dropOpDescendants = dropOpDescendants;\n+        this.writeVoidOpResult = writeVoidOpResult;\n+    }\n+\n+    \/**\n+     * {@return the function that names blocks and values.}\n+     *\/\n+    public Function<CodeItem, String> namer() {\n+        return namer;\n+    }\n+\n+    \/**\n+     * Writes a code model, an operation, to the character stream.\n+     *\n+     * @param op the code model\n+     *\/\n+    public OpCodeBuilder writeOp(Op op) {\n+        if (op.parent() != null) {\n+            Op.Result opr = op.result();\n+            if (writeVoidOpResult || !opr.type().equals(JavaType.VOID)) {\n+                writeValueDeclaration(opr).space().equal().space();\n+            }\n+        }\n+        write(op.opName());\n+\n+        if (!op.operands().isEmpty()) {\n+            space().writeSpaceSeparatedList(op.operands(), this::writeValueUse);\n+        }\n+\n+        if (!op.successors().isEmpty()) {\n+            space().writeSpaceSeparatedList(op.successors(), this::writeSuccessor);\n+        }\n+\n+        if (!dropLocation) {\n+            Location location = op.location();\n+            if (location != null) {\n+                space().writeAttribute(ATTRIBUTE_LOCATION, op.location());\n+            }\n+        }\n+        Map<String, Object> attributes = op.externalize();\n+        if (!attributes.isEmpty()) {\n+            space().writeSpaceSeparatedList(attributes.entrySet(), e -> writeAttribute(e.getKey(), e.getValue()));\n+        }\n+\n+        if (!dropOpDescendants && !op.bodies().isEmpty()) {\n+            int nBodies = op.bodies().size();\n+            if (nBodies == 1) {\n+                space();\n+            } else {\n+                nl().in().in();\n+            }\n+            boolean first = true;\n+            for (Body body : op.bodies()) {\n+                if (!first) {\n+                    nl();\n+                }\n+                writeBody(body);\n+                first = false;\n+            }\n+            if (nBodies > 1) {\n+                out().out();\n+            }\n+        }\n+        semicolon();\n+        return this;\n+    }\n+\n+    OpCodeBuilder writeSuccessor(Block.Reference successor) {\n+        writeBlockName(successor.targetBlock());\n+        if (!successor.arguments().isEmpty()) {\n+            oparen().nl().in().writeCommaSeparatedList(successor.arguments(), this::writeValueUse).out().nl().cparen();\n+        }\n+        return this;\n+    }\n+\n+    OpCodeBuilder writeAttribute(String name, Object value) {\n+        at();\n+        if (!name.isEmpty()) {\n+            write(name);\n+            equal();\n+        }\n+        write(AttributeMapper.toString(value));\n+        return this;\n+    }\n+\n+    OpCodeBuilder writeBody(Body body) {\n+        Block eb = body.entryBlock();\n+        oparen();\n+        if (!eb.parameters().isEmpty()) {\n+            nl().in().writeCommaSeparatedList(eb.parameters(), this::writeValueDeclaration).out().nl();\n+        }\n+        cparen();\n+        writeType(body.bodyType().returnType());\n+        space().arrow().space();\n+        obrace().nl().in();\n+        for (Block b : body.blocks()) {\n+            if (!b.isEntryBlock()) {\n+                nl();\n+            }\n+            writeBlock(b);\n+        }\n+        out().cbrace();\n+        return this;\n+    }\n+\n+    OpCodeBuilder writeBlock(Block block) {\n+        if (!block.isEntryBlock()) {\n+            writeBlockName(block);\n+            if (!block.parameters().isEmpty()) {\n+                oparen().nl().in().writeCommaSeparatedList(block.parameters(), this::writeValueDeclaration).out().nl().cparen();\n+            }\n+            colon().nl();\n+        }\n+        in();\n+        for (Op op : block.ops()) {\n+            writeOp(op).nl();\n+        }\n+        out();\n+        return this;\n+    }\n+\n+    OpCodeBuilder writeBlockName(Block b) {\n+       return hat().write(namer.apply(b));\n+    }\n+\n+    OpCodeBuilder ssaid(Value v){\n+       return percent().write(namer.apply(v));\n+    }\n+\n+    OpCodeBuilder writeValueUse(Value v) {\n+       return  ssaid(v);\n+    }\n+\n+    OpCodeBuilder writeValueDeclaration(Value v) {\n+        return ssaid(v).space().colon().space().writeType(v.type());\n+    }\n+\n+    <T> OpCodeBuilder writeSpaceSeparatedList(Iterable<T> l, Consumer<T> c) {\n+        return writeSeparatedList(\" \", l, c);\n+    }\n+\n+    <T> OpCodeBuilder writeCommaSeparatedList(Iterable<T> l, Consumer<T> c) {\n+        return writeSeparatedNlList(\", \", l, c);\n+    }\n+\n+    <T> OpCodeBuilder writeSeparatedList(String separator, Iterable<T> l, Consumer<T> c) {\n+        boolean first = true;\n+        for (T t : l) {\n+            if (!first) {\n+                write(separator);\n+            }\n+            c.accept(t);\n+            first = false;\n+        }\n+        return this;\n+    }\n+    <T> OpCodeBuilder writeSeparatedNlList(String separator, Iterable<T> l, Consumer<T> c) {\n+        boolean first = true;\n+        for (T t : l) {\n+            if (!first) {\n+                write(separator);\n+                nl();\n+            }\n+            c.accept(t);\n+            first = false;\n+        }\n+        return this;\n+    }\n+    OpCodeBuilder writeType(TypeElement te) {\n+        write(JavaTypeUtils.flatten(te.externalize()).toString());\n+        return this;\n+    }\n+\n+    OpCodeBuilder write(String s) {\n+        w.write(s);\n+        return this;\n+    }\n+    OpCodeBuilder nl() {\n+          w.nl();\n+        return this;\n+    }\n+\n+    OpCodeBuilder semicolon(){\n+        w.symbol(\";\");\n+        return this;\n+    }\n+\n+    OpCodeBuilder space(){\n+        w.space();\n+        return this;\n+    }\n+    OpCodeBuilder colon(){\n+        w.symbol(\":\");\n+        return this;\n+    }\n+    OpCodeBuilder oparen(){\n+        w.symbol(\"(\");\n+        return this;\n+    }\n+    OpCodeBuilder obrace(){\n+        w.symbol(\"{\");\n+        return this;\n+    }\n+    OpCodeBuilder cparen(){\n+        w.symbol(\")\");\n+        return this;\n+    }\n+    OpCodeBuilder cbrace(){\n+        w.symbol(\"}\");\n+        return this;\n+    }\n+    OpCodeBuilder equal(){\n+        w.symbol(\"=\");\n+        return this;\n+    }\n+    OpCodeBuilder in(){\n+        w.in();\n+        return this;\n+    }\n+    OpCodeBuilder out(){\n+        w.out();\n+        return this;\n+    }\n+    OpCodeBuilder arrow(){\n+        w.symbol(\"->\");\n+        return this;\n+    }\n+    OpCodeBuilder at(){\n+        w.symbol(\"@\");\n+        return this;\n+    }\n+    OpCodeBuilder hat(){\n+        w.symbol(\"^\");\n+        return this;\n+    }\n+    OpCodeBuilder percent(){\n+        w.symbol(\"%\");\n+        return this;\n+    }\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/OpCodeBuilder.java","additions":824,"deletions":0,"binary":false,"changes":824,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -37,1 +38,0 @@\n-import java.lang.reflect.Method;\n@@ -78,6 +78,14 @@\n-           builder.createJava(new ScopedCodeBuilderContext( MethodHandles.lookup(),Op.ofMethod(\n-                Compute.class.getDeclaredMethod(\"mandel\", KernelContext.class, S32Array.class,  S32Array2D.class, float.class, float.class,float.class)).get()\n-           ));\n-           builder.createJava(new ScopedCodeBuilderContext( MethodHandles.lookup(),Op.ofMethod(\n-               Compute.class.getDeclaredMethod(\"compute\", ComputeContext.class,  S32Array.class, S32Array2D.class,float.class, float.class,float.class)).get()\n-          ));\n+           CoreOp.FuncOp mandel =  Op.ofMethod(Compute.class.getDeclaredMethod(\"mandel\",\n+                       KernelContext.class, S32Array.class,  S32Array2D.class, float.class, float.class,float.class)).get();\n+            CoreOp.FuncOp compute =  Op.ofMethod(Compute.class.getDeclaredMethod(\"compute\",\n+                    ComputeContext.class,  S32Array.class, S32Array2D.class,float.class, float.class,float.class)).get();\n+\n+            OpCodeBuilder.writeTo(System.out,mandel);\n+            System.out.println();\n+            System.out.println(\"----\");\n+            System.out.println(mandel.toText());\n+\n+       System.out.println();\n+       System.out.println(\"----\");\n+           builder.createJava(new ScopedCodeBuilderContext( MethodHandles.lookup(),mandel));\n+           builder.createJava(new ScopedCodeBuilderContext( MethodHandles.lookup(),compute));\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/TestJavaHATCodeBuilder.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"}]}