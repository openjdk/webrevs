{"files":[{"patch":"@@ -40,2 +40,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -44,8 +42,5 @@\n-    static Pattern remPattern = Pattern.compile(\"^ *REM(.*)$\");\n-    static Pattern colonPattern = Pattern.compile(\"^ *(:) *$\");\n-    static Pattern verticesPattern = Pattern.compile(\"^ *(vertices) *$\");\n-    static Pattern facesPattern = Pattern.compile(\"^ *(faces) *$\");\n-    static Pattern hueLigSatPattern = Pattern.compile(\"^ *(hue-lig-sat) *$\");\n-    static String hexRegex = \"((?:-?&[0-9a-fA-F][0-9a-fA-F])|0)\";\n-    static String commaRegex = \" *, *\";\n-    static String hexOrColorCommaRegex = \"(\" + hexRegex + \"|(?:(?:[a-zA-Z][a-zA-Z0-9]*)))\" + commaRegex;\n+    static Regex remRegex = Regex.of(\"^ *REM(.*)$\");\n+    static Regex colonRegex = Regex.of(\"^ *(:) *$\");\n+    static Regex verticesRegex = Regex.of( \"^ *(vertices) *$\");\n+    static Regex facesRegex = Regex.of(\"^ *(faces) *$\");\n+    static Regex hueLigSatRegex = Regex.of(\"^ *(hue-lig-sat) *$\");\n@@ -53,17 +48,6 @@\n-    static String hexCommaRegex = hexRegex + commaRegex;\n-    static String decRegex = \"([0-9]+)\";\n-    static String decCommaRegex = decRegex + commaRegex;\n-    static Pattern face6Pattern = Pattern.compile(\"^ *\"\n-            + hexOrColorCommaRegex + hexCommaRegex + hexCommaRegex + hexCommaRegex\n-            + \"6\" + commaRegex + decCommaRegex + decCommaRegex + decCommaRegex + decCommaRegex + decCommaRegex + decRegex + \" *$\");\n-    static Pattern face5Pattern = Pattern.compile(\"^ *\"\n-            + hexOrColorCommaRegex + hexCommaRegex + hexCommaRegex + hexCommaRegex\n-            + \"5\" + commaRegex + decCommaRegex + decCommaRegex + decCommaRegex + decCommaRegex + decRegex + \" *$\");\n-    static Pattern face4Pattern = Pattern.compile(\"^ *\"\n-            + hexOrColorCommaRegex + hexCommaRegex + hexCommaRegex + hexCommaRegex\n-            + \"4\" + commaRegex + decCommaRegex + decCommaRegex + decCommaRegex + decRegex + \" *$\");\n-    static Pattern face3Pattern = Pattern.compile(\"^ *\"\n-            + hexOrColorCommaRegex + hexCommaRegex + hexCommaRegex + hexCommaRegex\n-            + \"3\" + commaRegex + decCommaRegex + decCommaRegex + decRegex + \" *$\");\n-    static Pattern frontLaserVertexPattern = Pattern.compile(\"^ *\" + hexRegex + \" *$\");\n-    static Pattern vertexPattern = Pattern.compile(\"^ *\" + hexCommaRegex + hexCommaRegex + hexRegex + \" *$\");\n+    static String hexRegexStr = \"((?:-?&[0-9a-fA-F][0-9a-fA-F])|0)\";\n+    static String commaRegexStr = \" *, *\";\n+    static String hexOrColorCommaRegexStr = \"(\" + hexRegexStr + \"|(?:(?:[a-zA-Z][a-zA-Z0-9]*)))\" + commaRegexStr;\n+    static String hexCommaRegexStr = hexRegexStr + commaRegexStr;\n+    static String decRegexStr = \"([0-9]+)\";\n+    static String decCommaRegexStr = decRegexStr + commaRegexStr;\n@@ -71,3 +55,4 @@\n-    static Pattern vertexCountPattern = Pattern.compile(\"^ *\" + hexCommaRegex + hexRegex + \" *$\");\n-    static Pattern namePattern = Pattern.compile(\"^ *([A-Za-z][0-9A-Za-z]+) *$\");\n-    static Pattern emptyPattern = Pattern.compile(\"^ *$\");\n+    static Regex face6Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"6\" ,commaRegexStr, decCommaRegexStr.repeat(5), decRegexStr, \" *$\");\n+    static Regex face5Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"5\" ,commaRegexStr, decCommaRegexStr.repeat(4), decRegexStr, \" *$\");\n+    static Regex face4Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"4\" ,commaRegexStr, decCommaRegexStr.repeat(3), decRegexStr, \" *$\");\n+    static Regex face3Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"3\" ,commaRegexStr, decCommaRegexStr.repeat(2), decRegexStr, \" *$\");\n@@ -75,7 +60,5 @@\n-    static String getGroups(Matcher m) {\n-        StringBuilder sb = new StringBuilder();\n-        for (int i = 0; i <= m.groupCount(); i++) {\n-            sb.append(\"#\" + i + \"{\" + m.group(i) + \"}\");\n-        }\n-        return sb.toString();\n-    }\n+    static Regex frontLaserVertexRegex = Regex.of( \"^ *\" + hexRegexStr + \" *$\");\n+    static Regex vertexRegex = Regex.of(\"^ *\" + hexCommaRegexStr + hexCommaRegexStr + hexRegexStr + \" *$\");\n+    static Regex vertexCountRegex = Regex.of(\"^ *\" + hexCommaRegexStr + hexRegexStr + \" *$\");\n+    static Regex nameRegex = Regex.of(\"^ *([A-Za-z][0-9A-Za-z]+) *$\");\n+    static Regex emptyRegex = Regex.of(\"^ *$\");\n@@ -83,3 +66,0 @@\n-    static void showGroups(String label, Matcher m) {\n-        System.out.println(label + \":  \" + getGroups(m));\n-    }\n@@ -87,3 +67,0 @@\n-    static float hex2Float(String s) {\n-        return (s.startsWith(\"-\"))? (-Integer.parseInt(s.substring(2), 16) \/ 64f): (Integer.parseInt(s.substring(1), 16) \/ 64f);\n-    }\n@@ -101,5 +78,1 @@\n-                Matcher lm;\n-                if ((lm = remPattern.matcher(line)).matches()\n-                        || (lm = emptyPattern.matcher(line)).matches()\n-                        ||(lm = colonPattern.matcher(line)).matches()) {\n-                } else {\n+                if (!Regex.any(line, remRegex,emptyRegex,colonRegex).matched()) {\n@@ -107,2 +80,2 @@\n-                        case AWAITING_NAME: {\n-                            if ((lm = namePattern.matcher(line)).matches() && lm.group(1).equals(name)) {\n+                        case AWAITING_NAME ->{\n+                            if (nameRegex.is(line) instanceof Regex.OK ok && ok.string(1).equals(name)) {\n@@ -111,7 +84,0 @@\n-\n-                            }\n-                            break;\n-                        }\n-                        case AWAITING_LAZER: {\n-                            if ((lm = frontLaserVertexPattern.matcher(line)).matches()) {\n-                                state = State.AWAITING_COUNTS;\n@@ -119,1 +85,0 @@\n-                            break;\n@@ -121,16 +86,7 @@\n-                        case AWAITING_COUNTS: {\n-                            if ((lm = vertexCountPattern.matcher(line)).matches()) {\n-                                state = State.AWAITING_VERTICES;\n-                            }\n-                            break;\n-                        }\n-                        case AWAITING_VERTICES: {\n-                            if ((lm = verticesPattern.matcher(line)).matches()) {\n-                                state = State.AWAITING_FACES;\n-                            }\n-                            break;\n-                        }\n-                        case AWAITING_FACES: {\n-                            if ((lm = vertexPattern.matcher(line)).matches()) {\n-                                mesh.vec3(hex2Float(lm.group(1)),  hex2Float(lm.group(2)), hex2Float(lm.group(3)));\n-                            } else if ((lm = facesPattern.matcher(line)).matches()) {\n+                        case AWAITING_LAZER-> state = frontLaserVertexRegex.is(line).matched()?State.AWAITING_COUNTS:state;\n+                        case AWAITING_COUNTS-> state  =vertexCountRegex.is(line).matched()?State.AWAITING_VERTICES:state;\n+                        case AWAITING_VERTICES-> state = verticesRegex.is(line).matched()?State.AWAITING_FACES:state;\n+                        case AWAITING_FACES->{\n+                            if (vertexRegex.is(line) instanceof Regex.OK ok) {\n+                                mesh.vec3(ok.f(1),  ok.f(2), ok.f(3));\n+                            } else if (facesRegex.is(line).matched()) {\n@@ -139,1 +95,0 @@\n-                            break;\n@@ -141,11 +96,5 @@\n-                        case AWAITING_HUE_LIG_SAT: {\n-                            if ((lm = face6Pattern.matcher(line)).matches()\n-                                 || (lm = face5Pattern.matcher(line)).matches()\n-                                    || (lm = face4Pattern.matcher(line)).matches()\n-                                    || (lm = face3Pattern.matcher(line)).matches()\n-                            ) {\n-                               \/\/ showGroups(\"FACE \", lm);\n-                            \/\/    int vN = F32Vec3.createVec3( hex2Float(lm.group(3)),hex2Float(lm.group(4)),hex2Float(lm.group(5)));\n-                                int v0 = mesh.vecEntries[Integer.parseInt(lm.group(6))];\n-                                int v1 = mesh.vecEntries[Integer.parseInt(lm.group(7))];\n-                                int v2 = mesh.vecEntries[Integer.parseInt(lm.group(8))];\n+                        case AWAITING_HUE_LIG_SAT-> {\n+                            if (Regex.any(line,face6Regex,face5Regex,face4Regex,face3Regex) instanceof Regex.OK ok) {\n+                                int v0 = mesh.vecEntries[ok.i(6)];\n+                                int v1 = mesh.vecEntries[ok.i(7)];\n+                                int v2 = mesh.vecEntries[ok.i(8)];\n@@ -153,1 +102,1 @@\n-                                if (lm.groupCount()==8){\n+                                if (ok.regex() == face3Regex){\n@@ -155,14 +104,6 @@\n-                                }else {\n-                                    int v3 = mesh.vecEntries[Integer.parseInt(lm.group(9))];\n-                                    if (lm.groupCount() == 9) {\n-                                        mesh.quad(v0, v1,v2, v3,  0xff0000);\n-                                    } else {\n-                                        int v4 = mesh.vecEntries[Integer.parseInt(lm.group(10))];\n-                                        if (lm.groupCount() == 10) {\n-                                            mesh.pent(v0, v1, v2, v3, v4, 0x0000ff);\n-                                        } else {\n-                                            int v5 =  mesh.vecEntries[Integer.parseInt(lm.group(11))];\n-                                          \/\/  System.out.println(\"normals {\"+nx+\",\"+ny+\",\"+nz+\"} abinormal=\"+abinormal);\n-                                            mesh.hex(v0, v1, v2, v3, v4, v5, 0xfff000);\n-                                        }\n-                                    }\n+                                }else if (ok.regex() == face4Regex) {\n+                                    mesh.quad(v0, v1,v2, mesh.vecEntries[ok.i(9)],  0xff0000);\n+                                } else if (ok.regex()== face5Regex) {\n+                                    mesh.pent(v0, v1, v2, mesh.vecEntries[ok.i(9)], mesh.vecEntries[ok.i(10)], 0x0000ff);\n+                                } else {\n+                                    mesh.hex(v0, v1, v2, mesh.vecEntries[ok.i(9)], mesh.vecEntries[ok.i(10)], mesh.vecEntries[ok.i(11)], 0xfff000);\n@@ -170,1 +111,1 @@\n-                            } else if ((lm = hueLigSatPattern.matcher(line)).matches()) {\n+                            } else if ((hueLigSatRegex.is(line).matched())) {\n@@ -176,4 +117,0 @@\n-                            break;\n-                        }\n-                        default: {\n-                           \/\/ System.out.println(\"WHAt \" + line);\n@@ -181,0 +118,2 @@\n+                        default->  throw new IllegalStateException((\"WHAt \" + line));\n+\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/EliteMeshReader.java","additions":45,"deletions":106,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+\n@@ -42,3 +45,7 @@\n-    public static void main(String[] args) {\n-        var vf = (args.length > 0 )\n-                ? ViewFrame.of(\"view\", Rasterizer.of(View.of(1024, 1024), Rasterizer.DisplayMode.WIRE), () -> EliteMeshReader.load(args[0]))\n+    public static void main(String[] argArr) {\n+        var args = new ArrayList<>(List.of(argArr));\n+        \/\/\/args.add(\"ANACONDA\");\n+        var viewFrame = (args.size() > 0 )\n+                ? ViewFrame.of(\"view\", Rasterizer.of(View.of(1024, 1024), Rasterizer.DisplayMode.WIRE), () ->\n+                    EliteMeshReader.load(args.getFirst())\n+                )\n@@ -46,8 +53,8 @@\n-            for (int x = -2; x < 4; x += 2) {\n-                for (int y = -2; y < 4; y += 2) {\n-                    for (int z = -2; z < 4; z += 2) {\n-                        F32Mesh3D.of(\"cubeoctahedron\").cubeoctahedron(x, y, z, 2).fin();\n-                    }\n-                }\n-            }\n-        });\n+                     for (int x = -2; x < 4; x += 2) {\n+                         for (int y = -2; y < 4; y += 2) {\n+                             for (int z = -2; z < 4; z += 2) {\n+                                 F32Mesh3D.of(\"cubeoctahedron\").cubeoctahedron(x, y, z, 2).fin();\n+                             }\n+                         }\n+                     }\n+                });\n@@ -56,1 +63,1 @@\n-            vf.update();\n+            viewFrame.update();\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Main.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package view;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+record Regex(Pattern pattern) {\n+    interface Match {\n+        boolean matched();\n+    }\n+\n+    record OK(Regex regex, Matcher matcher, boolean matched) implements Match {\n+        public static OK of(Regex regex, Matcher matcher) {\n+            return new OK(regex, matcher, true);\n+        }\n+        float hex2Float(String s) {\n+            return (s.startsWith(\"-\"))? (-Integer.parseInt(s.substring(2), 16) \/ 64f): (Integer.parseInt(s.substring(1), 16) \/ 64f);\n+        }\n+        public float f(int idx) {\n+            return hex2Float(string(idx));\n+        }\n+\n+        public int i(int idx) {\n+            return Integer.parseInt(string(idx));\n+        }\n+\n+        public String string(int idx) {\n+            return matcher.group(idx);\n+        }\n+    }\n+\n+    record FAIL(boolean matched) implements Match {\n+        public static FAIL of() {\n+            return new FAIL(false);\n+        }\n+    }\n+\n+    static Regex of(String... strings) {\n+        return new Regex(Pattern.compile(String.join(\"\", strings)));\n+    }\n+\n+    static Match any(String line, Regex... regexes) {\n+        for (Regex r : regexes) {\n+            if (r.is(line) instanceof OK ok) {\n+                return ok;\n+            }\n+        }\n+        return FAIL.of();\n+    }\n+\n+    Match is(String s) {\n+        if (pattern.matcher(s) instanceof Matcher matcher && matcher.matches()) {\n+            return OK.of(this, matcher);\n+        } else {\n+            return FAIL.of();\n+        }\n+    }\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Regex.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/examples\/view\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/examples\/view\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/examples\/view\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"core\" \/>\n+    <orderEntry type=\"module\" module-name=\"example_shared\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_opencl\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/example_view.iml","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"}]}