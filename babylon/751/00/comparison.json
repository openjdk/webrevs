{"files":[{"patch":"@@ -261,2 +261,0 @@\n-                    \/\/ Approach 1: The first approach support iFace and Buffer types to be used in Local and Private memory\n-                    \/\/ TODO: Once we decide to move towards the DeviceType implementation, we will remove this part\n@@ -264,14 +262,9 @@\n-                    \/\/ DON'T DO THIS !!!!  we are needlessly allocating a memory segment here pn each dispatch!!!\n-                    \/\/ just to get the bound schema.\n-                    Method method = clazz.getMethod(\"create\", hat.Accelerator.class);\n-                    method.setAccessible(true);\n-                    Buffer invoke = (Buffer) method.invoke(null, kernelCallGraph.computeContext.accelerator);\n-                    if (invoke != null) {\n-                        \/\/ code gen of the struct\n-                        BoundSchema<?> boundSchema = Buffer.getBoundSchema(invoke);\n-                        boundSchema.schema().rootIfaceType.visitTypes(0, t -> {\n-                            if (!already.contains(t)) {\n-                                builder.typedef(boundSchema, t);\n-                                already.add(t);\n-                            }\n-                        });\n+                    Field schemaField = clazz.getDeclaredField(\"schema\");\n+                    schemaField.setAccessible(true);\n+                    var schema = (DeviceSchema<?>)schemaField.get(schemaField);\n+                    \/\/ <1> We are creating text form of DeviceType schema\n+                    String toText = schema.toText();\n+                    if (toText != null) {\n+                        \/\/ <2> just to then parse the text from above.\n+                        \/\/ Lets get the model in a cleaner form\n+                        generateDeviceTypeStructs(builder, toText, typedefs);\n@@ -279,13 +272,1 @@\n-                        \/\/ new approach for supporting DeviceTypes\n-                        Field schemaField = clazz.getDeclaredField(\"schema\");\n-                        schemaField.setAccessible(true);\n-                        var schema = (DeviceSchema<?>)schemaField.get(schemaField);\n-                        \/\/ <1> We are creating text form of DeviceType schema\n-                        String toText = schema.toText();\n-                        if (toText != null) {\n-                            \/\/ <2> just to then parse the text from above.\n-                            \/\/ Lets get the model in a cleaner form\n-                            generateDeviceTypeStructs(builder, toText, typedefs);\n-                        } else {\n-                            throw new RuntimeException(\"[ERROR] Could not find valid device schema \");\n-                        }\n+                        throw new RuntimeException(\"[ERROR] Could not find valid device schema \");\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":10,"deletions":29,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,1 +29,11 @@\n-import hat.dialect.*;\n+import hat.dialect.HATLocalVarOp;\n+import hat.dialect.HATPhaseUtils;\n+import hat.dialect.HATPrivateVarOp;\n+import hat.dialect.HATVectorAddOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorDivOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorMulOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATVectorSubOp;\n+import hat.dialect.HATVectorVarOp;\n@@ -43,1 +53,4 @@\n-import java.util.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n@@ -68,1 +81,0 @@\n-                    \/\/ catching HATVectorBinaryOps not stored in VarOps\n@@ -70,0 +82,1 @@\n+                        \/\/ catching HATVectorBinaryOps not stored in VarOps\n@@ -72,1 +85,1 @@\n-                                invokeOp.externalizeOpName(),\n+                                obtainVarNameFromInvoke(invokeOp),\n@@ -452,0 +465,11 @@\n+\n+    private String obtainVarNameFromInvoke(JavaOp.InvokeOp invokeOp) {\n+        Op.Result invokeResult = invokeOp.result();\n+        if (!invokeResult.uses().isEmpty()) {\n+            Op.Result r = invokeResult.uses().stream().toList().getFirst();\n+            if (r.op() instanceof CoreOp.VarOp varOp) {\n+                return varOp.varName();\n+            }\n+        }\n+        return invokeOp.externalizeOpName();\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -47,1 +46,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -592,1 +590,1 @@\n-    private interface SharedMemory extends Buffer {\n+    private interface SharedMemory extends DeviceType {\n@@ -595,8 +593,4 @@\n-        Schema<SharedMemory> schema = Schema.of(SharedMemory.class,\n-                arr -> arr.array(\"array\", 1024));\n-        static SharedMemory create(Accelerator accelerator) {\n-            return schema.allocate(accelerator);\n-        }\n-        static SharedMemory createLocal() {\n-            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n-        }\n+        DeviceSchema<SharedMemory> schema = DeviceSchema.of(SharedMemory.class,\n+                arr -> arr.withArray(\"array\", 1024));\n+\n+        static SharedMemory createLocal() { return null; }\n@@ -613,1 +607,1 @@\n-    public interface PrivateArray extends Buffer {\n+    public interface PrivateArray extends DeviceType {\n@@ -616,8 +610,4 @@\n-        Schema<PrivateArray> schema = Schema.of(PrivateArray.class,\n-                arr -> arr.array(\"array\", 16));\n-        static PrivateArray create(Accelerator accelerator) {\n-            return schema.allocate(accelerator);\n-        }\n-        static PrivateArray createPrivate() {\n-            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n-        }\n+        DeviceSchema<PrivateArray> schema = DeviceSchema.of(PrivateArray.class,\n+                arr -> arr.withArray(\"array\", 16));\n+\n+        static PrivateArray createPrivate() { return null; }\n@@ -640,2 +630,0 @@\n-            \/\/ int[] a = new int[4];\n-            \/\/ a[1] = 4;\n@@ -650,0 +638,1 @@\n+            kc.barrier();\n@@ -728,0 +717,1 @@\n+            kc.barrier();\n@@ -747,3 +737,1 @@\n-        accelerator.compute(\n-                cc -> basicDeviceType(cc, arr)  \/\/QuotableComputeContextConsumer\n-        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        accelerator.compute(cc -> basicDeviceType(cc, arr));\n@@ -755,4 +743,0 @@\n-    \/*\n-     * testing DeviceTypes instead of Buffer\n-     *\/\n-\n@@ -771,0 +755,1 @@\n+            kc.barrier();\n@@ -790,3 +775,1 @@\n-        accelerator.compute(\n-                cc -> deviceType(cc, arr)  \/\/QuotableComputeContextConsumer\n-        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        accelerator.compute(cc -> deviceType(cc, arr));\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrayView.java","additions":15,"deletions":32,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.device.DeviceSchema;\n+import hat.device.DeviceType;\n@@ -34,1 +36,0 @@\n-import hat.ifacemapper.Schema;\n@@ -219,1 +220,1 @@\n-    private interface SharedMemory extends Buffer {\n+    private interface SharedMemory extends DeviceType {\n@@ -222,5 +223,2 @@\n-        Schema<SharedMemory> schema = Schema.of(SharedMemory.class,\n-                arr -> arr.array(\"array\", 1024));\n-        static SharedMemory create(Accelerator accelerator) {\n-            return schema.allocate(accelerator);\n-        }\n+        DeviceSchema<SharedMemory> schema = DeviceSchema.of(SharedMemory.class,\n+                arr -> arr.withArray(\"array\", 1024));\n@@ -228,3 +226,0 @@\n-            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n-        }\n-        default Float4 float4View(int index) {\n@@ -233,2 +228,0 @@\n-        default void storeFloat4View(Float4 float4, int index) {\n-        }\n@@ -259,1 +252,1 @@\n-    private interface PrivateMemory extends Buffer {\n+    private interface PrivateMemory extends DeviceType {\n@@ -262,5 +255,2 @@\n-        Schema<PrivateMemory> schema = Schema.of(PrivateMemory.class,\n-                arr -> arr.array(\"array\", 4));\n-        static PrivateMemory create(Accelerator accelerator) {\n-            return schema.allocate(accelerator);\n-        }\n+        DeviceSchema<PrivateMemory> schema = DeviceSchema.of(PrivateMemory.class,\n+                arr -> arr.withArray(\"array\", 4));\n@@ -268,3 +258,0 @@\n-            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n-        }\n-        default Float4 float4View(int index) {\n@@ -273,2 +260,0 @@\n-        default void storeFloat4View(Float4 float4, int index) {\n-        }\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorArrayView.java","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"}]}