{"files":[{"patch":"@@ -576,1 +576,1 @@\n-                            conditionalBranch(cob, op, CodeBuilder::iconst_1, CodeBuilder::iconst_0);\n+                            cob.ifThenElse(prepareReverseCondition(cob, op), CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n@@ -737,9 +737,1 @@\n-                        conditionalBranch(cob, btop,\n-                                trueBuilder -> {\n-                                    assignBlockArguments(btop, op.trueBranch(), trueBuilder, c);\n-                                    trueBuilder.goto_(c.getLabel(op.trueBranch().targetBlock()));\n-                                },\n-                                falseBuilder -> {\n-                                    assignBlockArguments(btop, op.falseBranch(), falseBuilder, c);\n-                                    falseBuilder.goto_(c.getLabel(op.falseBranch().targetBlock()));\n-                                });\n+                        conditionalBranch(cob, c, btop, op.trueBranch(), op.falseBranch());\n@@ -748,9 +740,1 @@\n-                        cob.ifThenElse(\n-                                trueBuilder -> {\n-                                    assignBlockArguments(op, op.trueBranch(), trueBuilder, c);\n-                                    trueBuilder.goto_(c.getLabel(op.trueBranch().targetBlock()));\n-                                },\n-                                falseBuilder -> {\n-                                    assignBlockArguments(op, op.falseBranch(), falseBuilder, c);\n-                                    falseBuilder.goto_(c.getLabel(op.falseBranch().targetBlock()));\n-                                });\n+                        conditionalBranch(cob, c, Opcode.IFEQ, op, op.trueBranch(), op.falseBranch());\n@@ -899,7 +883,8 @@\n-            Integer slot = liveSet.get(v);\n-            if (slot != null) {\n-                freeSlots.set(slot);\n-                if (slotsPerValue(v) == 2) {\n-                    freeSlots.set(slot + 1);\n-                }\n-            }\n+\/\/@@@ BytecodeLift does not handle slot overrides correctly yet\n+\/\/            Integer slot = liveSet.get(v);\n+\/\/            if (slot != null) {\n+\/\/                freeSlots.set(slot);\n+\/\/                if (slotsPerValue(v) == 2) {\n+\/\/                    freeSlots.set(slot + 1);\n+\/\/                }\n+\/\/            }\n@@ -939,2 +924,22 @@\n-    private static void conditionalBranch(CodeBuilder cob, BinaryTestOp op,\n-                                          Consumer<BlockCodeBuilder> trueBlock, Consumer<BlockCodeBuilder> falseBlock) {\n+    private static void conditionalBranch(CodeBuilder cob, ConversionContext c, BinaryTestOp op,\n+                                          Block.Reference trueBlock, Block.Reference falseBlock) {\n+        conditionalBranch(cob, c, prepareReverseCondition(cob, op), op, trueBlock, falseBlock);\n+    }\n+\n+    private static void conditionalBranch(CodeBuilder cob, ConversionContext c, Opcode reverseOpcode, Op op,\n+                                          Block.Reference trueBlock, Block.Reference falseBlock) {\n+        if (falseBlock.targetBlock().parameters().isEmpty()) {\n+            assignBlockArguments(op, falseBlock, cob, c);\n+            cob.branchInstruction(reverseOpcode, c.getLabel(falseBlock.targetBlock()));\n+        } else {\n+            cob.ifThen(reverseOpcode,\n+                bb -> {\n+                    assignBlockArguments(op, falseBlock, bb, c);\n+                    bb.goto_(c.getLabel(falseBlock.targetBlock()));\n+                });\n+        }\n+        assignBlockArguments(op, trueBlock, cob, c);\n+        cob.goto_(c.getLabel(trueBlock.targetBlock()));\n+    }\n+\n+    private static Opcode prepareReverseCondition(CodeBuilder cob, BinaryTestOp op) {\n@@ -943,7 +948,7 @@\n-            cob.ifThenElse(switch (op) {\n-                case EqOp _ -> Opcode.IF_ICMPEQ;\n-                case NeqOp _ -> Opcode.IF_ICMPNE;\n-                case GtOp _ -> Opcode.IF_ICMPGT;\n-                case GeOp _ -> Opcode.IF_ICMPGE;\n-                case LtOp _ -> Opcode.IF_ICMPLT;\n-                case LeOp _ -> Opcode.IF_ICMPLE;\n+            return switch (op) {\n+                case EqOp _ -> Opcode.IF_ICMPNE;\n+                case NeqOp _ -> Opcode.IF_ICMPEQ;\n+                case GtOp _ -> Opcode.IF_ICMPLE;\n+                case GeOp _ -> Opcode.IF_ICMPLT;\n+                case LtOp _ -> Opcode.IF_ICMPGE;\n+                case LeOp _ -> Opcode.IF_ICMPGT;\n@@ -952,1 +957,1 @@\n-            }, trueBlock, falseBlock);\n+            };\n@@ -961,7 +966,7 @@\n-            cob.ifThenElse(switch (op) {\n-                case EqOp _ -> Opcode.IFEQ;\n-                case NeqOp _ -> Opcode.IFNE;\n-                case GtOp _ -> Opcode.IFGT;\n-                case GeOp _ -> Opcode.IFGE;\n-                case LtOp _ -> Opcode.IFLT;\n-                case LeOp _ -> Opcode.IFLE;\n+            return switch (op) {\n+                case EqOp _ -> Opcode.IFNE;\n+                case NeqOp _ -> Opcode.IFEQ;\n+                case GtOp _ -> Opcode.IFLE;\n+                case GeOp _ -> Opcode.IFLT;\n+                case LtOp _ -> Opcode.IFGE;\n+                case LeOp _ -> Opcode.IFGT;\n@@ -970,1 +975,1 @@\n-            }, trueBlock, falseBlock);\n+            };\n@@ -986,1 +991,0 @@\n-        \/\/ Push successor values on the stack\n@@ -996,20 +1000,0 @@\n-            } else {\n-                int sslot = c.getSlot(value);\n-\n-                \/\/ Assignment only required if slots differ\n-                if (sslot != bslot) {\n-                    TypeKind vt = toTypeKind(barg.type());\n-                    cob.loadInstruction(vt, sslot);\n-                }\n-            }\n-        }\n-\n-        \/\/ Pop successor arguments on the stack assigning to block argument slots if necessary\n-        for (int i = bargs.size() - 1; i >= 0; i--) {\n-            Block.Parameter barg = bargs.get(i);\n-            int bslot = c.liveSlotSet(s.targetBlock()).getOrAssignSlot(barg);\n-\n-            Value value = sargs.get(i);\n-            if (value instanceof Op.Result or &&\n-                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n-                    !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n@@ -1024,0 +1008,1 @@\n+                    cob.loadInstruction(vt, sslot);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":50,"deletions":65,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+            final HashMap<Label, Map<Integer, Op.Result>> localsMap = new HashMap<>();\n@@ -86,1 +87,1 @@\n-            final Map<Integer, Op.Result> locals = new HashMap<>();\n+            Map<Integer, Op.Result> locals = new HashMap<>();\n@@ -115,0 +116,1 @@\n+                                    localsMap.put(lt.label(), locals);\n@@ -125,0 +127,1 @@\n+                                locals = localsMap.get(lt.label());\n@@ -133,0 +136,1 @@\n+                                        localsMap.putIfAbsent(ec.handler(), locals);\n@@ -172,0 +176,1 @@\n+                            localsMap.putIfAbsent(inst.target(), locals);\n@@ -203,0 +208,1 @@\n+                            localsMap.putIfAbsent(inst.target(), locals);\n@@ -245,1 +251,2 @@\n-                                    locals.put(varIndex, currentBlock.op(CoreOps.var(Integer.toString(varIndex++), operand)));\n+                                    locals = new HashMap<>(locals);\n+                                    locals.put(inst.slot(), currentBlock.op(CoreOps.var(Integer.toString(varIndex++), operand)));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/internal\/jimage\/TEST.properties","status":"copied"},{"patch":"@@ -92,2 +92,2 @@\n-    static int conditionalExpression(int a, int b, int c, int n) {\n-        return (n < 10) ? (n < 5) ? a : b : c;\n+    static int conditionalExpression(int i, int len) {\n+        return ((i - 1 >= 0) ? i - 1 : len - 1);\n@@ -100,3 +100,16 @@\n-        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 1), conditionalExpression(1, 2, 3, 1));\n-        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 6), conditionalExpression(1, 2, 3, 6));\n-        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 11), conditionalExpression(1, 2, 3, 11));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 5, 10), conditionalExpression(5, 10));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 0, 10), conditionalExpression(0, 10));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 0, 50), conditionalExpression(0, 50));\n+    }\n+\n+    static int nestedConditionalExpression(int a, int b, int c, int n) {\n+        return (n < 10) ? (n < 5) ? a : b : c;\n+    }\n+\n+    @Test\n+    public void testNestedConditionalExpression() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"nestedConditionalExpression\");\n+\n+        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 1), nestedConditionalExpression(1, 2, 3, 1));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 6), nestedConditionalExpression(1, 2, 3, 6));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 11), nestedConditionalExpression(1, 2, 3, 11));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftControl.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.StringWriter;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.instruction.*;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.op.CoreOps;\n+\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestLiftSmallCorpus\n+ *\/\n+\n+public class TestLiftSmallCorpus {\n+\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+    private static final ClassFile CF = ClassFile.of(ClassFile.DebugElementsOption.DROP_DEBUG,\n+                                                     ClassFile.LineNumbersOption.DROP_LINE_NUMBERS);\n+    private static final int COLUMN_WIDTH = 150;\n+\n+    private int passed, failed, skipped;\n+\n+    @Test\n+    public void testDoubleRoundtripStability() throws Exception {\n+        passed = 0;\n+        failed = 0;\n+        skipped = 0;\n+        for (Path p : Files.walk(JRT.getPath(\"modules\/java.base\/java\"))\n+                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".class\"))\n+                .toList()) {\n+            testDoubleRoundtripStability(p);\n+        }\n+\n+        \/\/ @@@ There is still several failing cases\n+        Assert.assertTrue(failed < 25, STR.\"failed: \\{failed}, passed: \\{passed}, skipped: \\{skipped}\");\n+    }\n+\n+    private void testDoubleRoundtripStability(Path path) throws Exception {\n+        var clm = CF.parse(path);\n+        for (var originalModel : clm.methods()) {\n+            try {\n+                CoreOps.FuncOp firstLift = lift(originalModel);\n+                CoreOps.FuncOp firstTransform = transform(firstLift);\n+                MethodModel firstModel = lower(firstTransform);\n+                CoreOps.FuncOp secondLift = lift(firstModel);\n+                CoreOps.FuncOp secondTransform = transform(secondLift);\n+                MethodModel secondModel = lower(secondTransform);\n+\n+                \/\/ testing only methods passing through\n+                var firstNormalized = normalize(firstModel);\n+                var secondNormalized = normalize(secondModel);\n+                if (!firstNormalized.equals(secondNormalized)) {\n+                    failed++;\n+                    System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n+                    printInColumns(firstLift, secondLift);\n+                    printInColumns(firstTransform, secondTransform);\n+                    printInColumns(firstNormalized, secondNormalized);\n+                    System.out.println();\n+                } else {\n+                    passed++;\n+                }\n+            } catch (Exception e) {\n+                \/\/ We skip methods failing to lift or lower for now\n+                skipped++;\n+            }\n+        }\n+    }\n+    private static void printInColumns(CoreOps.FuncOp first, CoreOps.FuncOp second) {\n+        StringWriter fw = new StringWriter();\n+        first.writeTo(fw);\n+        StringWriter sw = new StringWriter();\n+        second.writeTo(sw);\n+        printInColumns(fw.toString().lines().toList(), sw.toString().lines().toList());\n+    }\n+\n+    private static void printInColumns(List<String> first, List<String> second) {\n+        System.out.println(\"-\".repeat(COLUMN_WIDTH ) + \"--+-\" + \"-\".repeat(COLUMN_WIDTH ));\n+        for (int i = 0; i < first.size() || i < second.size(); i++) {\n+            String f = i < first.size() ? first.get(i) : \"\";\n+            String s = i < second.size() ? second.get(i) : \"\";\n+            System.out.println(\" \" + f + (f.length() < COLUMN_WIDTH ? \" \".repeat(COLUMN_WIDTH - f.length()) : \"\") + (f.equals(s) ? \" | \" : \" x \") + s);\n+        }\n+    }\n+\n+    private static CoreOps.FuncOp lift(MethodModel mm) {\n+        return BytecodeLift.lift(mm);\n+    }\n+\n+    private static CoreOps.FuncOp transform(CoreOps.FuncOp func) {\n+        return SSA.transform(func.transform((block, op) -> {\n+                    if (op instanceof Op.Lowerable lop) {\n+                        return lop.lower(block);\n+                    } else {\n+                        block.op(op);\n+                        return block;\n+                    }\n+                }));\n+    }\n+\n+    private static MethodModel lower(CoreOps.FuncOp func) {\n+        return CF.parse(BytecodeGenerator.generateClassData(\n+                MethodHandles.lookup(),\n+                func)).methods().get(0);\n+    }\n+\n+\n+    public static List<String> normalize(MethodModel mm) {\n+        record El(int index, String format, Label... targets) {\n+            public El(int index, Instruction i, Object format, Label... targets) {\n+                this(index, trim(i.opcode()) + \" \" + format, targets);\n+            }\n+            public String toString(Map<Label, Integer> targetsMap) {\n+                return \"%3d: \".formatted(index) + (targets.length == 0 ? format : format.formatted(Stream.of(targets).map(l -> targetsMap.get(l)).toArray()));\n+            }\n+        }\n+\n+        Map<Label, Integer> targetsMap = new HashMap<>();\n+        List<El> elements = new ArrayList<>();\n+        Label lastLabel = null;\n+        int i = 0;\n+        for (var e : mm.code().orElseThrow()) {\n+            var er = switch (e) {\n+                case LabelTarget lt -> {\n+                    lastLabel = lt.label();\n+                    yield null;\n+                }\n+                case ExceptionCatch ec ->\n+                    new El(i++, \"ExceptionCatch start: @%d end: @%d handler: @%d\" + ec.catchType().map(ct -> \" catch type: \" + ct.asInternalName()).orElse(\"\"), ec.tryStart(), ec.tryEnd(), ec.handler());\n+                case BranchInstruction ins ->\n+                    new El(i++, ins, \"@%d\", ins.target());\n+                case ConstantInstruction ins ->\n+                    new El(i++, \"LDC \" + ins.constantValue());\n+                case FieldInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \".\" + ins.name().stringValue());\n+                case InvokeDynamicInstruction ins ->\n+                    new El(i++, ins, ins.name().stringValue() + ins.typeSymbol() + \" \" + ins.bootstrapMethod() + \"(\" + ins.bootstrapArgs() + \")\");\n+                case InvokeInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \"::\" + ins.name().stringValue() + ins.typeSymbol().displayDescriptor());\n+                case LoadInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case StoreInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case IncrementInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot() + \" \" + ins.constant());\n+                case LookupSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case NewMultiArrayInstruction ins ->\n+                    new El(i++, ins, ins.arrayType().asInternalName() + \"(\" + ins.dimensions() + \")\");\n+                case NewObjectInstruction ins ->\n+                    new El(i++, ins, ins.className().asInternalName());\n+                case NewPrimitiveArrayInstruction ins ->\n+                    new El(i++, ins, ins.typeKind());\n+                case NewReferenceArrayInstruction ins ->\n+                    new El(i++, ins, ins.componentType().asInternalName());\n+                case TableSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case TypeCheckInstruction ins ->\n+                    new El(i++, ins, ins.type().asInternalName());\n+                case Instruction ins ->\n+                    new El(i++, ins, \"\");\n+                default -> null;\n+            };\n+            if (er != null) {\n+                if (lastLabel != null) {\n+                    targetsMap.put(lastLabel, elements.size());\n+                    lastLabel = null;\n+                }\n+                elements.add(er);\n+            }\n+        }\n+        return elements.stream().map(el -> el.toString(targetsMap)).toList();\n+    }\n+\n+    private static String trim(Opcode opcode) {\n+        var name = opcode.toString();\n+        int i = name.indexOf('_');\n+        return i > 2 ? name.substring(0, i) : name;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftSmallCorpus.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"}]}