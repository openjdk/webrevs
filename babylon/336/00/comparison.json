{"files":[{"patch":"@@ -69,1 +69,1 @@\n-  : eventMax(256), events(new cl_event[eventMax]), eventc(0){\n+  : eventMax(10000), events(new cl_event[eventMax]), eventc(0){\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+\n+\n@@ -54,1 +56,1 @@\n-            List<Mode> modes = new ArrayList<>();\n+          \/\/  List<Mode> modes = new ArrayList<>();\n@@ -57,3 +59,3 @@\n-                Arrays.stream(opts.split(\",\")).forEach(opt ->\n-                        modes.add(of(opt))\n-                );\n+           \/\/     Arrays.stream(opts.split(\",\")).forEach(opt ->\n+                        return of(opts);\n+             \/\/   );\n@@ -61,1 +63,1 @@\n-           return of(modes);\n+           return of();\n@@ -96,2 +98,10 @@\n-                    System.out.println(\"Unexpected opt '\"+name+\"'\");\n-                    yield Mode.of(0);\n+                    if (name.contains(\",\")) {\n+                        List<Mode> modes = new ArrayList<>();\n+                        Arrays.stream(name.split(\",\")).forEach(opt ->\n+                                modes.add(of(opt))\n+                        );\n+                        yield of(modes);\n+                    } else {\n+                        System.out.println(\"Unexpected opt '\" + name + \"'\");\n+                        yield Mode.of(0);\n+                    }\n@@ -247,0 +257,3 @@\n+    public OpenCLBackend(String spec) {\n+        this(Mode.of(spec));\n+    }\n@@ -258,0 +271,1 @@\n+\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-   void  resetBits(int bitsToReset) {\n+   void  xorBits(int bitsToReset) {\n@@ -154,0 +154,5 @@\n+    void  resetBits(int bitsToReset) {\n+         \/\/ say bits = 0b0111 (7) and bitz = 0b0100 (4)\n+         bits = bits&~bitsToReset;  \/\/ xored = 0b0011 (3)\n+         \/\/bits =  xored;\n+      }\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -75,3 +75,1 @@\n-  var dir = DirEntry.current();\n-\n-    \/\/ var dir = DirEntry.current();\n+    var dir = DirEntry.current();\n@@ -103,0 +101,12 @@\n+    var wrapJar= buildDir.jarFile(\"wrap.jar\");\n+    var clWrapJar= buildDir.jarFile(\"clwrap.jar\");\n+    var glWrapJar= buildDir.jarFile(\"glwrap.jar\");\n+    var cuWrapJar= buildDir.jarFile(\"cuwrap.jar\");\n+    var hatJar = buildDir.jarFile(\"hat-1.0.jar\");\n+\n+ var hatJavacOpts = javacBuilder($ -> $\n+            .enable_preview()\n+            .add_modules(\"jdk.incubator.code\")\n+            .add_exports_to_all_unnamed(\"java.base\", \"jdk.internal\", \"jdk.internal.vm.annotation\")\n+            .current_source()\n+    );\n@@ -104,2 +114,12 @@\n-    var wrap= jar(jar -> jar\n-         .jarFile(buildDir.jarFile(\"wrap.jar\"))\n+    var hatJarOptions = jarBuilder($ -> $\n+            .verbose(verbose)\n+    );\n+    jar(hatJarOptions, jar -> jar\n+            .jarFile(hatJar)\n+            .maven_style_root(hatCoreDir)\n+            .javac(hatJavacOpts, javac -> {\n+            })\n+    );\n+\n+    jar(jar -> jar\n+         .jarFile(wrapJar)\n@@ -127,1 +147,1 @@\n-               .jarFile(buildDir.jarFile(\"clwrap.jar\"))\n+               .jarFile(clWrapJar)\n@@ -129,1 +149,1 @@\n-               .javac(javac -> javac.current_source().class_path(wrap, openclCapability.jarFile(buildDir)))\n+               .javac(javac -> javac.current_source().class_path(wrapJar,hatJar, openclCapability.jarFile(buildDir)))\n@@ -150,1 +170,1 @@\n-               .jarFile(buildDir.jarFile(\"glwrap.jar\"))\n+               .jarFile(glWrapJar)\n@@ -156,1 +176,1 @@\n-                  .class_path(wrap, openglCapability.jarFile(buildDir))\n+                  .class_path(wrapJar, openglCapability.jarFile(buildDir))\n@@ -170,18 +190,1 @@\n-    var hatJavacOpts = javacBuilder($ -> $\n-            .enable_preview()\n-            .add_modules(\"jdk.incubator.code\")\n-            .add_exports_to_all_unnamed(\"java.base\", \"jdk.internal\", \"jdk.internal.vm.annotation\")\n-            .current_source()\n-    );\n-\n-    var hatJarOptions = jarBuilder($ -> $\n-            .verbose(verbose)\n-    );\n-    var hatJarFile = buildDir.jarFile(\"hat-1.0.jar\");\n-    jar(hatJarOptions, jar -> jar\n-            .jarFile(hatJarFile)\n-            .maven_style_root(hatCoreDir)\n-            .javac(hatJavacOpts, javac -> {\n-            })\n-    );\n-\n+   \n@@ -191,2 +194,1 @@\n-    ffiBackends\n-            .subDirs()\n+    ffiBackends.subDirs()\n@@ -195,2 +197,2 @@\n-                var jarFile = buildDir.jarFile(\"hat-backend-ffi-\" + backend.fileName() + \"-1.0.jar\");\n-                out.println(jarFile.fileName());\n+                var ffiBackendJarFile = buildDir.jarFile(\"hat-backend-ffi-\" + backend.fileName() + \"-1.0.jar\");\n+                out.println(ffiBackendJarFile.fileName());\n@@ -198,1 +200,1 @@\n-                        .jarFile(jarFile)\n+                        .jarFile(ffiBackendJarFile)\n@@ -200,1 +202,1 @@\n-                        .javac(hatJavacOpts, javac -> javac.class_path(hatJarFile))\n+                        .javac(hatJavacOpts, javac -> javac.class_path(hatJar))\n@@ -211,2 +213,2 @@\n-          .javac(hatJavacOpts, javac -> javac.verbose(true)\n-              .class_path(hatJarFile)\n+          .javac(hatJavacOpts, javac -> javac.verbose(verbose)\n+              .class_path(hatJar)\n@@ -219,1 +221,1 @@\n-       var jextractedOpenCLBackendOpenCLResult = jar(hatJarOptions, jar -> jar\n+       jar(hatJarOptions, jar -> jar\n@@ -222,2 +224,2 @@\n-          .javac(hatJavacOpts, javac -> javac.verbose(true)\n-              .class_path(hatJarFile, openclCapability.jarFile(buildDir), jextractedBackendSharedResult )\n+          .javac(hatJavacOpts, javac -> javac.verbose(verbose)\n+              .class_path(hatJar, openclCapability.jarFile(buildDir), jextractedBackendSharedResult )\n@@ -234,2 +236,2 @@\n-                var jarFile = buildDir.jarFile(\"hat-backend-java-\" + backend.fileName() + \"-1.0.jar\");\n-                out.println(jarFile.fileName());\n+                var backendJarFile = buildDir.jarFile(\"hat-backend-java-\" + backend.fileName() + \"-1.0.jar\");\n+                out.println(backendJarFile.fileName());\n@@ -237,1 +239,1 @@\n-                        .jarFile(jarFile)\n+                        .jarFile(backendJarFile)\n@@ -245,1 +247,1 @@\n-            .filter(example -> example.failsToMatch(\"^.*(experiments|nbody|target|.idea)$\"))\n+            .filter(example -> example.failsToMatch(\"^.*(experiments|nbody|life|target|.idea)$\"))\n@@ -247,2 +249,2 @@\n-                var jarFile = buildDir.jarFile(\"hat-example-\" + example.fileName() + \"-1.0.jar\");\n-                out.println(jarFile.fileName());\n+                var exampleJarFile = buildDir.jarFile(\"hat-example-\" + example.fileName() + \"-1.0.jar\");\n+                out.println(exampleJarFile.fileName());\n@@ -250,1 +252,1 @@\n-                        .jarFile(jarFile)\n+                        .jarFile(exampleJarFile)\n@@ -252,6 +254,2 @@\n-                        .javac(hatJavacOpts, javac -> javac.class_path(hatJarFile,  openclCapability.jarFile(buildDir),\n-                            buildDir.jarFile(\"wrap.jar\"),\n-                            buildDir.jarFile(\"clwrap.jar\")))\n-                        .manifest(manifest -> manifest\n-                                .main_class(example.fileName() + \".Main\")\n-                        )\n+                        .javac(hatJavacOpts, javac -> javac.class_path(hatJar))\n+                        .manifest(manifest -> manifest .main_class(example.fileName() + \".Main\"))\n@@ -262,0 +260,13 @@\n+    if (jextractCapability.available() && openclCapability.available()) {\n+        var example = examples.dir(\"life\");\n+        var exampleJarFile = buildDir.jarFile(\"hat-example-\" + example.fileName() + \"-1.0.jar\");\n+        out.println(exampleJarFile.fileName());\n+        jar(hatJarOptions, jar -> jar\n+                .jarFile(exampleJarFile)\n+                .maven_style_root(example)\n+                .javac(hatJavacOpts, javac -> javac\n+                   .class_path(hatJar, wrapJar, clWrapJar, openclCapability.jarFile(buildDir), buildDir.jarFile(\"hat-backend-ffi-opencl-1.0.jar\"))\n+                )\n+        );\n+    }\n+\n@@ -265,2 +276,2 @@\n-        var jarFile = buildDir.jarFile(\"hat-example-\" + example.fileName() + \"-1.0.jar\");\n-        out.println(jarFile.fileName());\n+        var exampleJarFile = buildDir.jarFile(\"hat-example-\" + example.fileName() + \"-1.0.jar\");\n+        out.println(exampleJarFile.fileName());\n@@ -268,1 +279,1 @@\n-                .jarFile(jarFile)\n+                .jarFile(exampleJarFile)\n@@ -270,5 +281,3 @@\n-                .javac(hatJavacOpts, javac -> javac.class_path(hatJarFile, \n-                            buildDir.jarFile(\"wrap.jar\"),\n-                            buildDir.jarFile(\"clwrap.jar\"),\n-                            buildDir.jarFile(\"glwrap.jar\"),\n-                            openclCapability.jarFile(buildDir), openglCapability.jarFile(buildDir)))\n+                .javac(hatJavacOpts, javac -> javac\n+                    .class_path( hatJar, wrapJar, clWrapJar, glWrapJar, openclCapability.jarFile(buildDir), openglCapability.jarFile(buildDir),buildDir.jarFile(\"hat-backend-ffi-opencl-1.0.jar\"))\n+                )\n","filename":"hat\/bld","additions":68,"deletions":59,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import static hat.ifacemapper.MappableIface.*;\n-\n+import hat.backend.ffi.OpenCLBackend;\n@@ -34,0 +33,1 @@\n+import hat.ifacemapper.SegmentMapper;\n@@ -37,2 +37,0 @@\n-import wrap.Scalar;\n-import wrap.Sequence;\n@@ -43,1 +41,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -46,0 +43,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -49,0 +47,2 @@\n+import static hat.ifacemapper.MappableIface.RO;\n+import static hat.ifacemapper.MappableIface.RW;\n@@ -51,1 +51,0 @@\n-import static wrap.LayoutBuilder.structOf;\n@@ -54,1 +53,0 @@\n-    final static int ZeroBase = 0;\n@@ -60,0 +58,7 @@\n+        \/*\n+         * struct CellGrid{\n+         *     int width;\n+         *     int height;\n+         *     byte[width*height*2] cellArray;\n+         *  }\n+         *\/\n@@ -79,1 +84,1 @@\n-        default CellGrid copySliceTo(byte[] bytes, int to) {\n+        default void copySliceTo(byte[] bytes, int to) {\n@@ -82,1 +87,5 @@\n-            return this;\n+\n+        }\n+\n+        default int wxh() {\n+            return width() * height();\n@@ -87,0 +96,7 @@\n+        \/*\n+         * struct Control{\n+         *     int from;\n+         *     int to;\n+         *     long generation\n+         *  }\n+         *\/\n@@ -95,1 +111,1 @@\n-        Schema<Control> schema = Schema.of(Control.class, lifeSupport -> lifeSupport.fields(\"from\", \"to\"));\n+        long generation();\n@@ -97,7 +113,5 @@\n-        static Control create(Accelerator accelerator, CellGrid CLWrapCellGrid) {\n-            var instance = schema.allocate(accelerator);\n-            instance.to(CLWrapCellGrid.width() * CLWrapCellGrid.height());\n-            instance.from(0);\n-            return instance;\n-        }\n-    }\n+        void generation(long generation);\n+        void requiredFrameRate(long requiredFrameRate);\n+        long requiredFrameRate();\n+        void  maxGenerations(long maxGenerations);\n+        long maxGenerations();\n@@ -105,5 +119,3 @@\n-    public static class Compute {\n-        @CodeReflection\n-        public static int val(@RO CellGrid grid, int from, int w, int x, int y) {\n-            return grid.cell( ((long) y * w)  + x +from)&1;\n-        }\n+        Schema<Control> schema = Schema.of(\n+                Control.class, control ->\n+                        control.fields(\"from\", \"to\", \"generation\", \"requiredFrameRate\", \"maxGenerations\"));\n@@ -111,24 +123,6 @@\n-        @CodeReflection\n-        public static void life(@RO KernelContext kc, @RO Control control, @RW CellGrid cellGrid) {\n-            if (kc.x < kc.maxX) {\n-                int w = cellGrid.width();\n-                int h = cellGrid.height();\n-                int from = control.from();\n-                int to = control.to();\n-                int x = kc.x % w;\n-                int y = kc.x \/ w;\n-                byte cell = cellGrid.cell(kc.x + from);\n-                if (x>0 && x<(w-1) && y>0 && y<(h-1)) { \/\/ passports please\n-                    int count =\n-                            val(cellGrid,from,w,x-1,y-1)\n-                                    +val(cellGrid,from,w,x-1,y+0)\n-                                    +val(cellGrid,from,w,x-1,y+1)\n-                                    +val(cellGrid,from,w,x+0,y-1)\n-                                    +val(cellGrid,from,w,x+0,y+1)\n-                                    +val(cellGrid,from,w,x+1,y+0)\n-                                    +val(cellGrid,from,w,x+1,y-1)\n-                                    +val(cellGrid,from,w,x+1,y+1);\n-                    cell =  ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n-                }\n-                cellGrid.cell(kc.x + to, cell);\n-            }\n+        static Control create(Accelerator accelerator, CellGrid cellGrid) {\n+            var instance = schema.allocate(accelerator);\n+            instance.from(cellGrid.width() * cellGrid.height());\n+            instance.to(0);\n+            instance.generation(0);\n+            return instance;\n@@ -138,25 +132,0 @@\n-        @CodeReflection\n-        static public void compute(final ComputeContext cc, Viewer viewer, Control ctrl, CellGrid grid) {\n-            \/\/  while (viewer.isVisible()) {\n-            cc.dispatchKernel(\n-                    grid.width() * grid.height(),\n-                    kc -> Compute.life(kc, ctrl, grid)\n-            );\n-            int to = ctrl.from(); ctrl.from(ctrl.to()); ctrl.to(to); \/\/swap from\/to\n-\n-\n-              \/\/  if (start==0L) {\n-                 \/\/   start = System.currentTimeMillis();\n-              \/\/  }else {\n-               \/\/     this.controls.generation.setText(String.format(\"%8d\", ++generationCounter));\n-                 \/\/   this.controls.generationsPerSecond.setText(\n-                   \/\/         String.format(\"%5.2f\", (generationCounter * 1000f) \/ (System.currentTimeMillis() - start))\n-                   \/\/ );\n-                    viewer.mainPanel.repaint();\n-              \/\/  }\n-\n-           \/\/ if (viewer.isReadyForUpdate()) {\n-           \/\/     viewer.update(grid, to);\n-          \/\/  }\n-            \/\/   }\n-        }\n@@ -164,41 +133,0 @@\n-    public static class CLWrapCellGrid {\n-        \/*\n-         * struct CellGrid{\n-         *     int width;\n-         *     int height;\n-         *     byte[width*height*2] cellArray;\n-         *  }\n-         *\/\n-        final MemoryLayout layout;\n-        final MemorySegment segment;\n-        final Scalar width;\n-        final Scalar height;\n-        final Sequence cellArray;\n-\n-\n-        final private int w;\n-        final private int h;\n-        final private int wxh;\n-\n-        CLWrapCellGrid(Arena arena, int w, int h) {\n-            this.w = w;\n-            this.h = h;\n-            this.wxh = w * h;\n-            this.layout = structOf(\"CLWrapCellGrid\", $ -> $\n-                    .i32(\"width\")\n-                    .i32(\"height\")\n-                    .i8Seq(\"cellArray\", (long) wxh * 2)\n-            );\n-            this.segment = arena.allocate(layout);\n-            this.width = Scalar.of(segment, layout, \"width\", this.w);\n-            this.height = Scalar.of(segment, layout, \"height\", this.h);\n-            this.cellArray = Sequence.of(segment, layout, \"cellArray\");\n-        }\n-\n-        int width() {\n-            return w;\/\/width.i32();\n-        }\n-\n-        int height() {\n-            return h;\/\/height.i32();\n-        }\n@@ -206,3 +134,9 @@\n-        byte cell(int idx) {\n-            return cellArray.i8(idx);\n-        }\n+    public static class Compute {\n+        public static final String codeHeader=  \"\"\"\n+                #define ALIVE -1\n+                #define DEAD 0\n+                 typedef struct control_s{\n+                     int from;\n+                     int to;\n+                     long generation;\n+                 }control_t;\n@@ -210,3 +144,5 @@\n-        void cell(int idx, byte v) {\n-            cellArray.set(idx, v);\/\/\n-        }\n+                 typedef struct cellGrid_s{\n+                     int width;\n+                     int height;\n+                     signed char cellArray[0];\n+                 }cellGrid_t;\n@@ -214,6 +150,1 @@\n-        CLWrapCellGrid copySliceTo(byte[] bytes, int to) {\n-            MemorySegment.copy(segment, JAVA_BYTE,\n-                    JAVA_INT.byteSize() + JAVA_INT.byteSize() + to * JAVA_BYTE.byteSize(),\n-                    bytes, 0, wxh);\n-            return this;\n-        }\n+                 \"\"\";\n@@ -221,4 +152,5 @@\n-        public int wxh() {\n-            return wxh;\n-        }\n-    }\n+        final static String codeVal = \"\"\"\n+                 inline int val(__global cellGrid_t *CLWrapCellGrid, int from, int w, int x, int y) {\n+                     return CLWrapCellGrid->cellArray[((y * w) + x + from)] & 1;\n+                 }\n+                \"\"\";\n@@ -226,18 +158,0 @@\n-    public static class CLWrapControl {\n-        final MemorySegment segment;\n-        final MemoryLayout layout;\n-        final Scalar from;\n-        final Scalar to;\n-        final Scalar generation;\n-\n-\n-        CLWrapControl(Arena arena, CLWrapCellGrid CLWrapCellGrid) {\n-            this.layout = structOf(\"CLWrapControl\", $ -> $\n-                    .i32(\"from\")\n-                    .i32(\"to\")\n-                    .i64(\"generation\")\n-            );\n-            this.segment = arena.allocate(this.layout);\n-            this.from = Scalar.of(this.segment, this.layout, \"from\", CLWrapCellGrid.width() * CLWrapCellGrid.height());\n-            this.to = Scalar.of(this.segment, this.layout, \"to\", 0);\n-            this.generation = Scalar.of(this.segment, this.layout, \"generation\", 0);\n@@ -245,0 +159,3 @@\n+        @CodeReflection\n+        public static int val(@RO CellGrid grid, int from, int w, int x, int y) {\n+            return grid.cell(((long) y * w) + x + from) & 1;\n@@ -247,2 +164,23 @@\n-        int from() {\n-            return this.from.i32();\n+        final static String codeLifePerIdx = \"\"\"\n+         __kernel void life( __global  cellGrid_t *CLWrapCellGrid ,__global control_t *CLWrapControl ){\n+            int kcx = get_global_id(0);\n+            int w = CLWrapCellGrid->width;\n+            int h = CLWrapCellGrid->height;\n+            int from = CLWrapControl->from;\n+            int to = CLWrapControl->to;\n+            int x = kcx % w;\n+            int y = kcx \/ w;\n+            signed char cell = CLWrapCellGrid->cellArray[kcx + from];\n+            if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n+                int count =\n+                        val(CLWrapCellGrid, from, w, x - 1, y - 1)\n+                                + val(CLWrapCellGrid, from, w, x - 1, y + 0)\n+                                + val(CLWrapCellGrid, from, w, x - 1, y + 1)\n+                                + val(CLWrapCellGrid, from, w, x + 0, y - 1)\n+                                + val(CLWrapCellGrid, from, w, x + 0, y + 1)\n+                                + val(CLWrapCellGrid, from, w, x + 1, y + 0)\n+                                + val(CLWrapCellGrid, from, w, x + 1, y - 1)\n+                                + val(CLWrapCellGrid, from, w, x + 1, y + 1);\n+                cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n+            }\n+            CLWrapCellGrid->cellArray[kcx + to]=  cell;\n@@ -250,0 +188,1 @@\n+                \"\"\";\n@@ -251,2 +190,22 @@\n-        int to() {\n-            return this.to.i32();\n+        @CodeReflection\n+        public static void lifePerIdx(int idx, @RO Control control, @RW CellGrid cellGrid) {\n+            int w = cellGrid.width();\n+            int h = cellGrid.height();\n+            int from = control.from();\n+            int to = control.to();\n+            int x = idx % w;\n+            int y = idx \/ w;\n+            byte cell = cellGrid.cell(idx + from);\n+            if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n+                int count =\n+                        val(cellGrid, from, w, x - 1, y - 1)\n+                                + val(cellGrid, from, w, x - 1, y + 0)\n+                                + val(cellGrid, from, w, x - 1, y + 1)\n+                                + val(cellGrid, from, w, x + 0, y - 1)\n+                                + val(cellGrid, from, w, x + 0, y + 1)\n+                                + val(cellGrid, from, w, x + 1, y + 0)\n+                                + val(cellGrid, from, w, x + 1, y - 1)\n+                                + val(cellGrid, from, w, x + 1, y + 1);\n+                cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n+            }\n+            cellGrid.cell(idx + to, cell);\n@@ -255,3 +214,0 @@\n-        void generation(long generation) {\n-            this.generation.set(generation);\n-        }\n@@ -259,5 +215,5 @@\n-        void swap() {\n-            int from = from();\n-            int to = to();\n-            this.to.set(from);\n-            this.from.set(to);\n+        @CodeReflection\n+        public static void life(@RO KernelContext kc, @RO Control control, @RW CellGrid cellGrid) {\n+            if (kc.x < kc.maxX) {\n+                Compute.lifePerIdx(kc.x, control, cellGrid);\n+            }\n@@ -266,5 +222,0 @@\n-    }\n-\n-    public static int val(CLWrapCellGrid grid, int from, int w, int x, int y) {\n-        return grid.cell((y * w) + x + from) & 1;\n-    }\n@@ -272,20 +223,28 @@\n-    public static void life(int kcx, CLWrapControl CLWrapControl, CLWrapCellGrid CLWrapCellGrid) {\n-\n-        int w = CLWrapCellGrid.width();\n-        int h = CLWrapCellGrid.height();\n-        int from = CLWrapControl.from();\n-        int to = CLWrapControl.to();\n-        int x = kcx % w;\n-        int y = kcx \/ w;\n-        byte cell = CLWrapCellGrid.cell(kcx + from);\n-        if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n-            int count =\n-                    val(CLWrapCellGrid, from, w, x - 1, y - 1)\n-                            + val(CLWrapCellGrid, from, w, x - 1, y + 0)\n-                            + val(CLWrapCellGrid, from, w, x - 1, y + 1)\n-                            + val(CLWrapCellGrid, from, w, x + 0, y - 1)\n-                            + val(CLWrapCellGrid, from, w, x + 0, y + 1)\n-                            + val(CLWrapCellGrid, from, w, x + 1, y + 0)\n-                            + val(CLWrapCellGrid, from, w, x + 1, y - 1)\n-                            + val(CLWrapCellGrid, from, w, x + 1, y + 1);\n-            cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n+        @CodeReflection\n+        static public void compute(final ComputeContext cc, Viewer viewer, Control ctrl, CellGrid cellGrid) {\n+            long framesSinceLastChange = 0;\n+            long lastFrame = System.currentTimeMillis();\n+            while (ctrl.generation() < ctrl.maxGenerations()) {\n+                final long now = System.currentTimeMillis();\n+                cc.dispatchKernel(\n+                        cellGrid.width() * cellGrid.height(),\n+                        kc -> Compute.life(kc, ctrl, cellGrid)\n+                );\n+                int to = ctrl.from();\n+                ctrl.from(ctrl.to());\n+                ctrl.to(to);\n+                boolean displayThisGeneration =\n+                        viewer.mainPanel.state.equals(Viewer.MainPanel.State.Done)\n+                                && (now - lastFrame >= ( 1000 \/  ctrl.requiredFrameRate()));\n+                if (displayThisGeneration) {\n+                    lastFrame = now;\n+                    viewer.controls.updateGenerationCounter(ctrl.generation(), framesSinceLastChange,\n+                            (1000 \/ ctrl.requiredFrameRate()));\n+\n+                    cellGrid.copySliceTo(viewer.mainPanel.rasterData, ctrl.from());\n+                    viewer.mainPanel.state = Viewer.MainPanel.State.Scheduled;\n+                    viewer.mainPanel.repaint();\n+                }\n+                framesSinceLastChange++;\n+                ctrl.generation(ctrl.generation()+1);\n+            }\n@@ -293,2 +252,0 @@\n-        CLWrapCellGrid.cell(kcx + to, cell);\n-        \/\/  }\n@@ -299,0 +256,2 @@\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new OpenCLBackend(\"GPU,MINIMIZE_COPIES\"));\n+\n@@ -304,2 +263,2 @@\n-        CLWrapCellGrid CLWrapCellGrid = new CLWrapCellGrid(\n-                Arena.global(),\n+\n+        CellGrid cellGrid = CellGrid.create(accelerator,\n@@ -307,2 +266,1 @@\n-                patternData.getMetaData().getHeight() + 2\n-        );\n+                patternData.getMetaData().getHeight() + 2);\n@@ -312,4 +270,2 @@\n-        patternData.getLiveCells().getCoordinates().stream().forEach(c -> {\n-                    CLWrapCellGrid.cell((1 + c.getX()) + (1 + c.getY()) * CLWrapCellGrid.width(), ALIVE);\n-                    \/\/  CLWrapCellGrid.cell(CLWrapCellGrid.wxh + (1 + c.getX()) + (1 + c.getY()) * CLWrapCellGrid.width(), ALIVE);\n-                }\n+        patternData.getLiveCells().getCoordinates().stream().forEach(c ->\n+                cellGrid.cell((1 + c.getX()) + (1 + c.getY()) * cellGrid.width(), ALIVE)\n@@ -318,2 +274,1 @@\n-        CLWrapControl CLWrapControl = new CLWrapControl(arena, CLWrapCellGrid);\n-        Viewer viewer = new Viewer(\"Life\", CLWrapCellGrid);\n+        Control control = Control.create(accelerator, cellGrid);\n@@ -321,1 +276,0 @@\n-        CLWrapComputeContext CLWrapComputeContext = new CLWrapComputeContext(arena, 20);\n@@ -323,0 +277,1 @@\n+        CLWrapComputeContext clWrapComputeContext = new CLWrapComputeContext(arena, 20);\n@@ -324,1 +279,1 @@\n-        System.out.println(\"platforms \" + platforms.size());\n+       \/\/ System.out.println(\"platforms \" + platforms.size());\n@@ -326,6 +281,0 @@\n-        platform.devices.forEach(device -> {\n-            System.out.println(\"   Compute Units     \" + device.computeUnits());\n-            System.out.println(\"   Device Name       \" + device.deviceName());\n-            System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n-            System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n-        });\n@@ -333,5 +282,4 @@\n-        System.out.println(\"   Compute Units     \" + device.computeUnits());\n-        System.out.println(\"   Device Name       \" + device.deviceName());\n-        System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n-\n-        System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+       \/\/ System.out.println(\"   Compute Units     \" + device.computeUnits());\n+       \/\/ System.out.println(\"   Device Name       \" + device.deviceName());\n+      \/\/  System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n+       \/\/ System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n@@ -340,43 +288,1 @@\n-        var code = \"\"\"\n-                #define ALIVE -1\n-                #define DEAD 0\n-                 typedef struct control_s{\n-                     int from;\n-                     int to;\n-                     long generation;\n-                 }control_t;\n-\n-                 typedef struct cellGrid_s{\n-                     int width;\n-                     int height;\n-                     signed char cellArray[0];\n-                 }cellGrid_t;\n-\n-                 inline int val(__global cellGrid_t *CLWrapCellGrid, int from, int w, int x, int y) {\n-                     return CLWrapCellGrid->cellArray[((y * w) + x + from)] & 1;\n-                 }\n-                 __kernel void life( __global  cellGrid_t *CLWrapCellGrid ,__global control_t *CLWrapControl ){\n-                      int kcx = get_global_id(0);\n-                      int w = CLWrapCellGrid->width;\n-                      int h = CLWrapCellGrid->height;\n-                      int from = CLWrapControl->from;\n-                      int to = CLWrapControl->to;\n-                      int x = kcx % w;\n-                      int y = kcx \/ w;\n-                      signed char cell = CLWrapCellGrid->cellArray[kcx + from];\n-                      if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n-                          int count =\n-                                 val(CLWrapCellGrid, from, w, x - 1, y - 1)\n-                                 + val(CLWrapCellGrid, from, w, x - 1, y + 0)\n-                                 + val(CLWrapCellGrid, from, w, x - 1, y + 1)\n-                                 + val(CLWrapCellGrid, from, w, x + 0, y - 1)\n-                                 + val(CLWrapCellGrid, from, w, x + 0, y + 1)\n-                                 + val(CLWrapCellGrid, from, w, x + 1, y + 0)\n-                                 + val(CLWrapCellGrid, from, w, x + 1, y - 1)\n-                                 + val(CLWrapCellGrid, from, w, x + 1, y + 1);\n-                          cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n-                      }\n-                      CLWrapCellGrid->cellArray[kcx + to]=  cell;\n-                   }\n-                \"\"\";\n-        var program = context.buildProgram(code);\n+        var program = context.buildProgram(Compute.codeHeader +Compute.codeVal + Compute.codeLifePerIdx);\n@@ -384,6 +290,7 @@\n-        CLWrapComputeContext.MemorySegmentState cellGridState = CLWrapComputeContext.register(CLWrapCellGrid.segment);\n-        CLWrapComputeContext.MemorySegmentState controlState = CLWrapComputeContext.register(CLWrapControl.segment);\n-\n-\n-        CLWrapCellGrid.copySliceTo(viewer.mainPanel.rasterData, CLWrapControl.to());\n-        CLWrapControl.swap();\n+        boolean useHat = true;\n+        boolean useBufferBitz = false;\n+        Viewer viewer = new Viewer(\"Life\", cellGrid, useHat);\n+        cellGrid.copySliceTo(viewer.mainPanel.rasterData, control.to());\n+        var tempFrom = control.from();\n+        control.from(control.to());\n+        control.to(tempFrom);\n@@ -391,0 +298,2 @@\n+        control.requiredFrameRate(10);\n+        control.maxGenerations(1000000);\n@@ -392,30 +301,18 @@\n-\n-        long start = System.currentTimeMillis();\n-        long generationCounter = 0;\n-\n-        long requiredFrameRate = 10;\n-        long generations = 1000000;\n-        long generationsSinceLastChange = 0;\n-        long framesSinceLastChange = 0;\n-\n-        long msPerFrame = 1000 \/ requiredFrameRate;\n-        long lastFrame = start;\n-        controlState.copyToDevice = true;\n-        controlState.copyFromDevice = true;\n-        cellGridState.copyToDevice = true;\n-        viewer.mainPanel.state = Viewer.MainPanel.State.Done;\n-        while (generationCounter < generations) {\n-            boolean alwaysCopy = viewer.controls.alwaysCopy();\n-            long now = System.currentTimeMillis();\n-            boolean displayThisGeneration =\n-                    viewer.mainPanel.state.equals(Viewer.MainPanel.State.Done)\n-                            && (now - lastFrame >= msPerFrame);\n-\n-            if (viewer.controls.useGPU()) {\n-                cellGridState.copyToDevice = alwaysCopy || generationCounter == 0; \/\/ only first\n-                cellGridState.copyFromDevice = alwaysCopy || displayThisGeneration;\n-                kernel.run(CLWrapComputeContext, CLWrapCellGrid.wxh, cellGridState, controlState);\n-            } else {\n-                IntStream.range(0, CLWrapCellGrid.wxh()).parallel().forEach(kcx ->\n-                        life(kcx, CLWrapControl, CLWrapCellGrid)\n-                );\n+        if (useHat){\n+            accelerator.compute(cc->Compute.compute(cc, viewer, control, cellGrid ));\n+        }else {\n+            CLWrapComputeContext.MemorySegmentState cellGridState = useBufferBitz?null:clWrapComputeContext.register(Buffer.getMemorySegment((CellGrid) cellGrid));\n+            CLWrapComputeContext.MemorySegmentState controlState = useBufferBitz?null:clWrapComputeContext.register(Buffer.getMemorySegment(control));\n+\n+            long start = System.currentTimeMillis();\n+            long generationsSinceLastChange = 0;\n+            long framesSinceLastChange = 0;\n+            long lastFrame = start;\n+            if (!useBufferBitz) {\n+                controlState.copyToDevice = true;\n+                controlState.copyFromDevice = true;\n+                cellGridState.copyToDevice = true;\n+            }else{\n+              \/\/  System.out.println(\"At start control\"+SegmentMapper.BufferState.of(control).setHostDirty(true));\n+\n+              \/\/  System.out.println(\"At start cellgrid \"+SegmentMapper.BufferState.of(cellGrid).setHostDirty(true).setDeviceDirty(true));\n@@ -423,10 +320,46 @@\n-            CLWrapControl.generation(generationCounter);\n-            CLWrapControl.swap();\n-            ++generationCounter;\n-            ++generationsSinceLastChange;\n-            if (displayThisGeneration) {\n-                if (viewer.controls.updated) {\n-                    \/\/ When the user changes something we have to update FPS\n-                    generationsSinceLastChange = 0;\n-                    framesSinceLastChange = 0;\n-                    viewer.controls.updated = false;\n+            viewer.mainPanel.state = Viewer.MainPanel.State.Done;\n+            while (control.generation() < control.maxGenerations()) {\n+                boolean alwaysCopy = !viewer.controls.minimizeCopies();\n+                final long now = System.currentTimeMillis();\n+                boolean displayThisGeneration =\n+                        viewer.mainPanel.state.equals(Viewer.MainPanel.State.Done)\n+                                && (now - lastFrame >= ( 1000 \/  control.requiredFrameRate()));\n+\n+\n+                if (viewer.controls.useGPU()) {\n+                    if (useBufferBitz){\n+                        SegmentMapper.BufferState bufferState = SegmentMapper.BufferState.of(cellGrid);\n+                        bufferState.setHostDirty(alwaysCopy || (control.generation() == 0)); \/\/ only first\n+                        bufferState.setDeviceDirty(alwaysCopy || displayThisGeneration);\n+                       \/\/ System.out.println(\"displayThisGeneration: \"+displayThisGeneration + \" useBufferBitz == true so \"+bufferState);\n+                        kernel.run(clWrapComputeContext, cellGrid.wxh(), cellGrid, control);\n+                    }else {\n+                        cellGridState.copyToDevice = alwaysCopy || control.generation() == 0; \/\/ only first\n+                        cellGridState.copyFromDevice = alwaysCopy || displayThisGeneration;\n+                        kernel.run(clWrapComputeContext, cellGrid.wxh(), cellGridState, controlState);\n+                    }\n+                } else {\n+                    IntStream.range(0, cellGrid.wxh()).parallel().forEach(kcx ->\n+                            Compute.lifePerIdx(kcx, control, cellGrid)\n+                    );\n+                }\n+                tempFrom = control.from();\n+                control.from(control.to());\n+                control.to(tempFrom);\n+                control.generation(control.generation() + 1);\n+\n+                ++generationsSinceLastChange;\n+                if (displayThisGeneration) {\n+                    if (viewer.controls.updated) {\n+                        \/\/ When the user changes something we have to update FPS\n+                        generationsSinceLastChange = 0;\n+                        framesSinceLastChange = 0;\n+                        viewer.controls.updated = false;\n+                    }\n+                    viewer.controls.updateGenerationCounter(generationsSinceLastChange, framesSinceLastChange,\n+                            ( 1000 \/  control.requiredFrameRate()));\n+                    cellGrid.copySliceTo(viewer.mainPanel.rasterData, control.from());\n+                    viewer.mainPanel.state = Viewer.MainPanel.State.Scheduled;\n+                    viewer.mainPanel.repaint();\n+                    lastFrame = now;\n+                    framesSinceLastChange++;\n@@ -434,6 +367,0 @@\n-                viewer.controls.updateGenerationCounter(generationsSinceLastChange, framesSinceLastChange, msPerFrame);\n-                CLWrapCellGrid.copySliceTo(viewer.mainPanel.rasterData, CLWrapControl.from());\n-                viewer.mainPanel.state = Viewer.MainPanel.State.Scheduled;\n-                viewer.mainPanel.repaint();\n-                lastFrame = now;\n-                framesSinceLastChange++;\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":230,"deletions":303,"binary":false,"changes":533,"status":"modified"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package life;\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.backend.Backend;\n-import hat.buffer.Buffer;\n-import hat.ifacemapper.MappableIface.*;\n-import hat.ifacemapper.Schema;\n-import io.github.robertograham.rleparser.RleParser;\n-import io.github.robertograham.rleparser.domain.PatternData;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandles;\n-import jdk.incubator.code.CodeReflection;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-\n-public class Main {\n-\n-    public interface CellGrid extends Buffer {\n-        int width();\n-\n-        int height();\n-\n-        byte cell(long idx);\n-\n-        void cell(long idx, byte b);\n-\n-        Schema<CellGrid> schema = Schema.of(CellGrid.class, lifeData -> lifeData\n-                .arrayLen(\"width\", \"height\").stride(2).array(\"cell\")\n-        );\n-\n-        static CellGrid create(Accelerator accelerator, int width, int height) {\n-            return schema.allocate(accelerator, width, height);\n-        }\n-\n-        ValueLayout valueLayout = JAVA_BYTE;\n-        long headerOffset = JAVA_INT.byteOffset() * 2;\n-\n-        default CellGrid copySliceTo(byte[] bytes, int to) {\n-            long offset = headerOffset + to * valueLayout.byteOffset();\n-            MemorySegment.copy(Buffer.getMemorySegment(this), valueLayout, offset, bytes, 0, width() * height());\n-            return this;\n-        }\n-    }\n-\n-    public interface Control extends Buffer {\n-        int from();\n-\n-        void from(int from);\n-\n-        int to();\n-\n-        void to(int to);\n-\n-        Schema<Control> schema = Schema.of(Control.class, lifeSupport -> lifeSupport.fields(\"from\", \"to\"));\n-\n-        static Control create(Accelerator accelerator, CellGrid CLWrapCellGrid) {\n-            var instance = schema.allocate(accelerator);\n-            instance.to(CLWrapCellGrid.width() * CLWrapCellGrid.height());\n-            instance.from(0);\n-            return instance;\n-        }\n-    }\n-\n-\n-    public final static byte ALIVE = (byte) 0xff;\n-    public final static byte DEAD = 0x00;\n-\n-    public static class Compute {\n-        @CodeReflection\n-        public static int val(@RO CellGrid grid, int from, int w, int x, int y) {\n-            return grid.cell( ((long) y * w)  + x +from)&1;\n-        }\n-\n-        @CodeReflection\n-        public static void life(@RO KernelContext kc, @RO Control CLWrapControl, @RW CellGrid CLWrapCellGrid) {\n-            if (kc.x < kc.maxX) {\n-                int w = CLWrapCellGrid.width();\n-                int h = CLWrapCellGrid.height();\n-                int from = CLWrapControl.from();\n-                int to = CLWrapControl.to();\n-                int x = kc.x % w;\n-                int y = kc.x \/ w;\n-                byte cell = CLWrapCellGrid.cell(kc.x + from);\n-                if (x>0 && x<(w-1) && y>0 && y<(h-1)) { \/\/ passports please\n-                    int count =\n-                            val(CLWrapCellGrid,from,w,x-1,y-1)\n-                            +val(CLWrapCellGrid,from,w,x-1,y+0)\n-                            +val(CLWrapCellGrid,from,w,x-1,y+1)\n-                            +val(CLWrapCellGrid,from,w,x+0,y-1)\n-                            +val(CLWrapCellGrid,from,w,x+0,y+1)\n-                            +val(CLWrapCellGrid,from,w,x+1,y+0)\n-                            +val(CLWrapCellGrid,from,w,x+1,y-1)\n-                            +val(CLWrapCellGrid,from,w,x+1,y+1);\n-                    cell =  ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n-                }\n-                CLWrapCellGrid.cell(kc.x + to, cell);\n-            }\n-        }\n-\n-\n-        @CodeReflection\n-        static public void compute(final ComputeContext cc, Viewer viewer, Control ctrl, CellGrid grid) {\n-          \/\/  while (viewer.isVisible()) {\n-                cc.dispatchKernel(\n-                        grid.width() * grid.height(),\n-                        kc -> Compute.life(kc, ctrl, grid)\n-                );\n-                int to = ctrl.from(); ctrl.from(ctrl.to()); ctrl.to(to); \/\/swap from\/to\n-                if (viewer.isReadyForUpdate()) {\n-                    viewer.update(grid, to);\n-                }\n-         \/\/   }\n-        }\n-    }\n-\n-\n-    public static void main(String[] args) {\n-        boolean headless = Boolean.getBoolean(\"headless\") || (args.length > 0 && args[0].equals(\"--headless\"));\n-\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), \/*Backend.JAVA_MULTITHREADED);\/\/*\/Backend.FIRST);\n-\n-        PatternData patternData = RleParser.readPatternData(\n-                Main.class.getClassLoader().getResourceAsStream(\"orig.rle\")\n-        );\n-        CellGrid CLWrapCellGrid = CellGrid.create(accelerator,\n-                  patternData.getMetaData().getWidth() + 2,\n-                patternData.getMetaData().getHeight() + 2\n-\n-        );\n-        patternData.getLiveCells().getCoordinates().stream().forEach(c ->\n-                CLWrapCellGrid.cell((1 + c.getX()) + (1 + c.getY()) * CLWrapCellGrid.width(), ALIVE)\n-        );\n-\n-        Control CLWrapControl = Control.create(accelerator, CLWrapCellGrid);\n-        final Viewer viewer = new Viewer(\"Life\", CLWrapControl, CLWrapCellGrid);\n-        viewer.update(CLWrapCellGrid, 0);\n-        viewer.waitForStart();\n-        while (viewer.isVisible()) {\n-            accelerator.compute(cc -> Compute.compute(cc, viewer, CLWrapControl, CLWrapCellGrid));\n-        }\n-\n-    }\n-}\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java.no","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"},{"patch":"@@ -52,1 +52,1 @@\n-\n+    boolean useHat = false;\n@@ -59,1 +59,1 @@\n-        enum State {Scheduled, Done};\n+        public enum State {Scheduled, Done};\n@@ -70,1 +70,1 @@\n-        private boolean released;\n+        private boolean mouseReleased;\n@@ -76,8 +76,1 @@\n-        class Drag{\n-            public int xDiff;\n-            public int yDiff;\n-            Drag(int xDiff, int yDiff) {\n-                this.xDiff = xDiff;\n-                this.yDiff = yDiff;\n-            }\n-        }\n+        record Drag(int xDiff, int yDiff){ }\n@@ -118,1 +111,1 @@\n-                    released = false;\n+                    mouseReleased = false;\n@@ -120,0 +113,1 @@\n+                    repaint();\n@@ -121,1 +115,0 @@\n-\n@@ -124,1 +117,1 @@\n-                    released = true;\n+                    mouseReleased = true;\n@@ -134,1 +127,1 @@\n-            AffineTransform at = new AffineTransform();\n+            AffineTransform affineTransform = new AffineTransform();\n@@ -141,1 +134,1 @@\n-                at.translate(xOffset, yOffset);\n+                affineTransform.translate(xOffset, yOffset);\n@@ -145,2 +138,2 @@\n-                at.translate(xOffset +drag.xDiff, yOffset + drag.yDiff);\n-                if (released) {\n+                affineTransform.translate(xOffset +drag.xDiff, yOffset + drag.yDiff);\n+                if (mouseReleased) {\n@@ -152,1 +145,1 @@\n-                at.translate(xOffset, yOffset);\n+                affineTransform.translate(xOffset, yOffset);\n@@ -154,4 +147,4 @@\n-            at.scale(zoomFactor, zoomFactor);\n-            g2.transform(at);\n-            g2.setColor(Color.BLACK);\n-            g2.fillRect(0-5000, 0-5000, image.getWidth()+10000, image.getHeight()+10000);\n+            affineTransform.scale(zoomFactor, zoomFactor);\n+            g2.transform(affineTransform);\n+            g2.setColor(Color.DARK_GRAY);\n+            g2.fillRect(-image.getWidth(),-image.getHeight(), image.getWidth()*3, image.getHeight()*3);\n@@ -163,0 +156,1 @@\n+        private boolean useHat;\n@@ -164,5 +158,5 @@\n-        private  JTextField generationsPerSecondTextField;\n-        private  JButton startButton;\n-        private  JToggleButton useGPUToggleButton;\n-        private  JToggleButton alwaysCopyToggleButton;\n-        private  JComboBox<String> generationsPerFrameComboBox;\n+        private JTextField generationsPerSecondTextField;\n+        private JButton startButton;\n+        private JToggleButton useGPUToggleButton;\n+        private JToggleButton minimizeCopiesToggleButton;\n+        private JComboBox<String> generationsPerFrameComboBox;\n@@ -170,1 +164,2 @@\n-        Controls(JMenuBar menuBar){\n+        Controls(JMenuBar menuBar, boolean useHat){\n+            this.useHat = useHat;\n@@ -173,5 +168,8 @@\n-            this.useGPUToggleButton =addToggle(menuBar, \"Java\", \"GPU\");\n-            this.alwaysCopyToggleButton = addToggle(menuBar,\"Minimize Moves\",\"Always Copy\");\n-         \/\/   this.generationsPerFrameComboBox = (JComboBox<String>) menuBar.add(new JComboBox<String>(\n-           \/\/         new String[]{\"1\", \"10\", \"20\"})\n-           \/\/ );\n+            if (!useHat) {\n+                this.useGPUToggleButton = addToggle(menuBar, \"Java\", \"GPU\");\n+                this.minimizeCopiesToggleButton = addToggle(menuBar, \"Always Copy\", \"Minimize Moves\");\n+                this.minimizeCopiesToggleButton.setEnabled(false);\n+                useGPUToggleButton.addChangeListener(event->{\n+                    this.minimizeCopiesToggleButton.setEnabled(useGPUToggleButton.isSelected());\n+                });\n+            }\n@@ -203,2 +201,2 @@\n-        public boolean alwaysCopy() {\n-            return alwaysCopyToggleButton.isSelected();\n+        public boolean minimizeCopies() {\n+            return minimizeCopiesToggleButton.isSelected();\n@@ -223,1 +221,1 @@\n-    Viewer(String title, Main.CLWrapCellGrid CLWrapCellGrid) {\n+    Viewer(String title, Main.CellGrid cellGrid, boolean useHat) {\n@@ -225,1 +223,2 @@\n-        this.mainPanel = new MainPanel(new BufferedImage(CLWrapCellGrid.width(), CLWrapCellGrid.height(), BufferedImage.TYPE_BYTE_GRAY));\n+        this.useHat = useHat;\n+        this.mainPanel = new MainPanel(new BufferedImage(cellGrid.width(), cellGrid.height(), BufferedImage.TYPE_BYTE_GRAY));\n@@ -227,1 +226,1 @@\n-        this.controls = new Controls(menuBar);\n+        this.controls = new Controls(menuBar, useHat);\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Viewer.java","additions":38,"deletions":39,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package life;\n-\n-import javax.swing.Box;\n-import javax.swing.JButton;\n-import javax.swing.JComponent;\n-import javax.swing.JFrame;\n-import javax.swing.JLabel;\n-import javax.swing.JMenuBar;\n-import javax.swing.JTextField;\n-import javax.swing.WindowConstants;\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import java.awt.GraphicsEnvironment;\n-import java.awt.MouseInfo;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n-import java.awt.event.MouseAdapter;\n-import java.awt.event.MouseEvent;\n-import java.awt.event.MouseMotionAdapter;\n-import java.awt.geom.AffineTransform;\n-import java.awt.image.BufferedImage;\n-import java.awt.image.DataBufferByte;\n-\n-public class Viewer extends JFrame {\n-\n-\n-    private final Object doorBell = new Object();\n-    final Controls controls;\n-    final MainPanel mainPanel;\n-    volatile private boolean started=false;\n-\n-    static final public class MainPanel extends JComponent {\n-        final double IN = 1.1;\n-        final double OUT = 1\/IN;\n-        private final BufferedImage image;\n-        final byte[] rasterData;\n-        private final double initialZoomFactor;\n-        private double zoomFactor;\n-        private double prevZoomFactor;\n-        private boolean zooming;\n-        private boolean released;\n-        private double xOffset = 0;\n-        private double yOffset = 0;\n-        private Point startPoint;\n-\n-\n-        class Drag{\n-            public int xDiff;\n-            public int yDiff;\n-            Drag(int xDiff, int yDiff) {\n-                this.xDiff = xDiff;\n-                this.yDiff = yDiff;\n-            }\n-        }\n-        Drag drag = null;\n-\n-        @Override\n-        public Dimension getPreferredSize() {\n-            return new Dimension((int)(image.getWidth()*zoomFactor), (int)(image.getHeight()*zoomFactor));\n-        }\n-        public MainPanel(BufferedImage image) {\n-            this.image = image;\n-            Rectangle bounds = GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds();\n-            this.initialZoomFactor = Math.min((bounds.width-20)\/(float)image.getWidth(),\n-                    (bounds.height-20)\/(float)image.getHeight());\n-            this.rasterData = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();\n-            this.prevZoomFactor =initialZoomFactor;\n-            this.zoomFactor = initialZoomFactor;\n-            addMouseWheelListener(e -> {\n-                zooming = true;\n-                zoomFactor = zoomFactor * ((e.getWheelRotation() < 0)?IN:OUT);\n-                if (zoomFactor < initialZoomFactor ){\n-                    zoomFactor = initialZoomFactor;\n-                    prevZoomFactor = zoomFactor;\n-                }\n-                repaint();\n-            });\n-            addMouseMotionListener(new MouseMotionAdapter() {\n-                @Override\n-                public void mouseDragged(MouseEvent e) {\n-                    Point curPoint = e.getLocationOnScreen();\n-                    drag = new Drag(curPoint.x - startPoint.x, curPoint.y - startPoint.y);\n-                    repaint();\n-                }\n-            });\n-            addMouseListener(new MouseAdapter() {\n-                @Override\n-                public void mousePressed(MouseEvent e) {\n-                    released = false;\n-                    startPoint = MouseInfo.getPointerInfo().getLocation();\n-                }\n-\n-                @Override\n-                public void mouseReleased(MouseEvent e) {\n-                    released = true;\n-                    repaint();\n-                }\n-            });\n-        }\n-\n-        @Override\n-        public void paint(Graphics g) {\n-            super.paint(g);\n-            Graphics2D g2 = (Graphics2D) g;\n-            AffineTransform at = new AffineTransform();\n-            if (zooming) {\n-                double xRel = MouseInfo.getPointerInfo().getLocation().getX() - getLocationOnScreen().getX();\n-                double yRel = MouseInfo.getPointerInfo().getLocation().getY() - getLocationOnScreen().getY();\n-                double zoomDiv = zoomFactor \/ prevZoomFactor;\n-                xOffset = (zoomDiv) * (xOffset) + (1 - zoomDiv) * xRel;\n-                yOffset = (zoomDiv) * (yOffset) + (1 - zoomDiv) * yRel;\n-                at.translate(xOffset, yOffset);\n-                prevZoomFactor = zoomFactor;\n-                zooming = false;\n-            } else if (drag!= null) {\n-                at.translate(xOffset +drag.xDiff, yOffset + drag.yDiff);\n-                if (released) {\n-                    xOffset += drag.xDiff;\n-                    yOffset += drag.yDiff;\n-                    drag = null;\n-                }\n-            } else{\n-                at.translate(xOffset, yOffset);\n-            }\n-            at.scale(zoomFactor, zoomFactor);\n-            g2.transform(at);\n-            g2.setColor(Color.BLACK);\n-            g2.fillRect(0-5000, 0-5000, image.getWidth()+10000, image.getHeight()+10000);\n-            g2.drawImage(image, 0,0, image.getWidth(), image.getHeight(), 0, 0, image.getWidth(), image.getHeight(), this);\n-        }\n-    }\n-    public static class Controls{\n-        JTextField generation;\n-        JTextField generationsPerSecond;\n-\n-        JButton start;\n-        JMenuBar menuBar;\n-        Controls(){\n-            menuBar = new JMenuBar();\n-            ((JButton) menuBar.add(new JButton(\"Exit\"))).addActionListener(_ -> System.exit(0));\n-            this.start = (JButton) menuBar.add(new JButton(\"Start\"));\n-            menuBar.add(Box.createHorizontalStrut(40));\n-            generation = create (\"Gen\");\n-            generationsPerSecond = create (\"Gen\/Sec\");\n-        }\n-        JTextField create (String name){\n-            menuBar.add(new JLabel(name));\n-            JTextField textField = (JTextField) menuBar.add(new JTextField(\"\",5));\n-            textField.setEditable(false);\n-            return textField;\n-        }\n-    }\n-\n-    Viewer(String title, Main.Control CLWrapControl,Main.CellGrid CLWrapCellGrid) {\n-        super(title);\n-        this.mainPanel = new MainPanel(new BufferedImage(CLWrapCellGrid.width(), CLWrapCellGrid.height(), BufferedImage.TYPE_BYTE_GRAY));\n-        this.controls = new Controls();\n-        setJMenuBar(controls.menuBar);\n-        controls.start.addActionListener(_ -> {started=true;synchronized (doorBell) {doorBell.notify();}});\n-        this.getContentPane().add(this.mainPanel);\n-        this.setLocationRelativeTo(null);\n-        this.pack();\n-        this.setVisible(true);\n-        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n-    }\n-\n-    public void waitForStart() {\n-        while (!started) {\n-            synchronized (doorBell) {\n-                try {\n-                    doorBell.wait();\n-                } catch (final InterruptedException ie) {\n-                    ie.getStackTrace();\n-                }\n-            }\n-        }\n-    }\n-     long start=0L;\n-    int generationCounter=0;\n-    public boolean isVisible(){\n-        return true;\n-    }\n-    public boolean isReadyForUpdate(){\n-        if (start==0L) {\n-            start = System.currentTimeMillis();\n-        }else {\n-            this.controls.generation.setText(String.format(\"%8d\", ++generationCounter));\n-            this.controls.generationsPerSecond.setText(\n-                    String.format(\"%5.2f\", (generationCounter * 1000f) \/ (System.currentTimeMillis() - start))\n-            );\n-            mainPanel.repaint();\n-        }\n-        return true;\n-    }\n-\n-    public void update(Main.CellGrid CLWrapCellGrid, int to) {\n-        CLWrapCellGrid.copySliceTo(mainPanel.rasterData, to);\n-        mainPanel.repaint();\n-    }\n-}\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Viewer.java.no","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"},{"patch":"@@ -1,473 +0,0 @@\n-package nbody;\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- *   - Redistributions of source code must retain the above copyright\n- *     notice, this list of conditions and the following disclaimer.\n- *\n- *   - Redistributions in binary form must reproduce the above copyright\n- *     notice, this list of conditions and the following disclaimer in the\n- *     documentation and\/or other materials provided with the distribution.\n- *\n- *   - Neither the name of Oracle nor the names of its\n- *     contributors may be used to endorse or promote products derived\n- *     from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n- * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-import opencl.opencl_h;\n-\n-import java.io.IOException;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/\/import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static opencl.opencl_h.CL_DEVICE_TYPE_ALL;\n-import static opencl.opencl_h.CL_MEM_READ_WRITE;\n-import static opencl.opencl_h.CL_MEM_USE_HOST_PTR;\n-import static opencl.opencl_h.CL_QUEUE_PROFILING_ENABLE;\n-\n-public class CLWrap {\n-    public static MemorySegment NULL = MemorySegment.NULL;\n-\n-    \/\/ https:\/\/streamhpc.com\/blog\/2013-04-28\/opencl-error-codes\/\n-    static class Platform {\n-        static class Device {\n-            final Platform platform;\n-            final MemorySegment deviceId;\n-\n-            int intDeviceInfo(int query) {\n-                var value = 0;\n-                if ((opencl_h.clGetDeviceInfo(deviceId, query, opencl_h.C_INT.byteSize(), platform.intValuePtr, NULL)) != opencl_h.CL_SUCCESS()) {\n-                    System.out.println(\"Failed to get query \" + query);\n-                } else {\n-                    value = platform.intValuePtr.get(opencl_h.C_INT, 0);\n-                }\n-                return value;\n-            }\n-\n-            String strDeviceInfo(int query) {\n-                String value = null;\n-                if ((opencl_h.clGetDeviceInfo(deviceId, query, 2048, platform.byte2048ValuePtr, platform.intValuePtr)) != opencl_h.CL_SUCCESS()) {\n-                    System.out.println(\"Failed to get query \" + query);\n-                } else {\n-                    int len = platform.intValuePtr.get(opencl_h.C_INT, 0);\n-                    byte[] bytes = platform.byte2048ValuePtr.toArray(ValueLayout.JAVA_BYTE);\n-                    value = new String(bytes).substring(0, len - 1);\n-                }\n-                return value;\n-            }\n-\n-            int computeUnits() {\n-                return intDeviceInfo(opencl_h.CL_DEVICE_MAX_COMPUTE_UNITS());\n-            }\n-\n-            String deviceName() {\n-                return strDeviceInfo(opencl_h.CL_DEVICE_NAME());\n-            }\n-\n-            String builtInKernels() {\n-                return strDeviceInfo(opencl_h.CL_DEVICE_BUILT_IN_KERNELS());\n-            }\n-\n-            Device(Platform platform, MemorySegment deviceId) {\n-                this.platform = platform;\n-                this.deviceId = deviceId;\n-            }\n-\n-            public static class Context {\n-                Device device;\n-                MemorySegment context;\n-                MemorySegment queue;\n-\n-                Context(Device device, MemorySegment context) {\n-                    this.device = device;\n-                    this.context = context;\n-                    var statusPtr = device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, 1);\n-\n-                    var queue_props = CL_QUEUE_PROFILING_ENABLE();\n-                    if ((this.queue = opencl_h.clCreateCommandQueue(context, device.deviceId, queue_props, statusPtr)) == NULL) {\n-                        int status = statusPtr.get(opencl_h.C_INT, 0);\n-                        opencl_h.clReleaseContext(context);\n-                        \/\/ delete[] platforms;\n-                        \/\/ delete[] device_ids;\n-                        return;\n-                    }\n-\n-                }\n-\n-                static public class Program {\n-                    Context context;\n-                    String source;\n-                    MemorySegment program;\n-                    String log;\n-\n-                    Program(Context context, String source) {\n-                        this.context = context;\n-                        this.source = source;\n-                        MemorySegment sourcePtr = context.device.platform.openCL.arena.allocateFrom(source);\n-                        var sourcePtrPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, sourcePtr);\n-                    \/\/    sourcePtrPtr.set(opencl_h.C_POINTER, 0, sourcePtr);\n-                        var sourceLenPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_LONG,  source.length());\n-                    \/\/    sourceLenPtr.set(opencl_h.C_LONG, 0, source.length());\n-                        var statusPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n-                        if ((program = opencl_h.clCreateProgramWithSource(context.context, 1, sourcePtrPtr, sourceLenPtr, statusPtr)) == NULL) {\n-                            int status = statusPtr.get(opencl_h.C_INT, 0);\n-                            if (status != opencl_h.CL_SUCCESS()) {\n-                                System.out.println(\"failed to createProgram \" + status);\n-                            }\n-                            System.out.println(\"failed to createProgram\");\n-                        } else {\n-                            int status = statusPtr.get(opencl_h.C_INT, 0);\n-                            if (status != opencl_h.CL_SUCCESS()) {\n-                                System.out.println(\"failed to create program \" + status);\n-                            }\n-                            var deviceIdPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, context.device.deviceId);\n-                          \/\/  deviceIdPtr.set(opencl_h.C_POINTER, 0, context.device.deviceId);\n-                            if ((status = opencl_h.clBuildProgram(program, 1, deviceIdPtr, NULL, NULL, NULL)) != opencl_h.CL_SUCCESS()) {\n-                                System.out.println(\"failed to build\" + status);\n-                                \/\/ dont return we may still be able to get log!\n-                            }\n-\n-                            var logLenPtr = context.device.platform.openCL.arena.allocate(opencl_h.C_LONG, 1);\n-\n-                            if ((status = opencl_h.clGetProgramBuildInfo(program, context.device.deviceId, opencl_h.CL_PROGRAM_BUILD_LOG(), 0, NULL, logLenPtr)) != opencl_h.CL_SUCCESS()) {\n-                                System.out.println(\"failed to get log build \" + status);\n-                            } else {\n-                                long logLen = logLenPtr.get(opencl_h.C_LONG, 0);\n-                                var logPtr = context.device.platform.openCL.arena.allocate(opencl_h.C_CHAR, 1 + logLen);\n-                                if ((status = opencl_h.clGetProgramBuildInfo(program, context.device.deviceId, opencl_h.CL_PROGRAM_BUILD_LOG(), logLen, logPtr, logLenPtr)) != opencl_h.CL_SUCCESS()) {\n-                                    System.out.println(\"clGetBuildInfo (getting log) failed\");\n-                                } else {\n-                                    byte[] bytes = logPtr.toArray(ValueLayout.JAVA_BYTE);\n-                                    log = new String(bytes).substring(0, (int) logLen);\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    public static class Kernel {\n-                        Program program;\n-                        MemorySegment kernel;\n-                        String kernelName;\n-\n-                        public Kernel(Program program, String kernelName) {\n-                            this.program = program;\n-                            this.kernelName = kernelName;\n-                            var statusPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, opencl_h.CL_SUCCESS());\n-                            MemorySegment kernelNamePtr = program.context.device.platform.openCL.arena.allocateFrom(kernelName);\n-                            kernel = opencl_h.clCreateKernel(program.program, kernelNamePtr, statusPtr);\n-                            int status = statusPtr.get(opencl_h.C_INT, 0);\n-                            if (status != opencl_h.CL_SUCCESS()) {\n-                                System.out.println(\"failed to create kernel \" + status);\n-                            }\n-                        }\n-\n-                        public void run(int range, Object... args) {\n-                            var bufPtr = program.context.device.platform.openCL.arena.allocate(opencl_h.cl_mem, args.length);\n-                            var statusPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, opencl_h.CL_SUCCESS());\n-                            int status;\n-                            var eventMax = args.length * 4 + 1;\n-                            int eventc = 0;\n-                            var eventsPtr = program.context.device.platform.openCL.arena.allocate(opencl_h.cl_event, eventMax);\n-                            boolean block = false;\/\/ true;\n-                            for (int i = 0; i < args.length; i++) {\n-                                if (args[i] instanceof MemorySegment memorySegment) {\n-                                    MemorySegment clMem = opencl_h.clCreateBuffer(program.context.context,\n-                                            CL_MEM_USE_HOST_PTR() | CL_MEM_READ_WRITE(),\n-                                            memorySegment.byteSize(),\n-                                            memorySegment,\n-                                            statusPtr);\n-                                    status = statusPtr.get(opencl_h.C_INT, 0);\n-                                    if (status != opencl_h.CL_SUCCESS()) {\n-                                        System.out.println(\"failed to create memory buffer \" + status);\n-                                    }\n-                                    bufPtr.set(opencl_h.cl_mem, i * opencl_h.cl_mem.byteSize(), clMem);\n-                                    status = opencl_h.clEnqueueWriteBuffer(program.context.queue,\n-                                            clMem,\n-                                            block ? opencl_h.CL_TRUE() : opencl_h.CL_FALSE(), \/\/block?\n-                                            0,\n-                                            memorySegment.byteSize(),\n-                                            memorySegment,\n-                                            block ? 0 : eventc,\n-                                            block ? NULL : ((eventc == 0) ? NULL : eventsPtr),\n-                                            block ? NULL : eventsPtr.asSlice(eventc * opencl_h.cl_event.byteSize(), opencl_h.cl_event)\n-                                    );\n-                                    if (status != opencl_h.CL_SUCCESS()) {\n-                                        System.out.println(\"failed to enqueue write \" + status);\n-                                    }\n-                                    if (!block) {\n-                                        eventc++;\n-                                    }\n-                                    var clMemPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, clMem);\n-\n-                                    status = opencl_h.clSetKernelArg(kernel, i, opencl_h.C_POINTER.byteSize(), clMemPtr);\n-                                    if (status != opencl_h.CL_SUCCESS()) {\n-                                        System.out.println(\"failed to set arg \" + status);\n-                                    }\n-                                } else {\n-                                    bufPtr.set(opencl_h.cl_mem, i * opencl_h.cl_mem.byteSize(), NULL);\n-                                    switch (args[i]){\n-                                        case Integer intArg->{\n-                                            var intPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, intArg);\n-                                            status = opencl_h.clSetKernelArg(kernel, i, opencl_h.C_INT.byteSize(), intPtr);\n-                                            if (status != opencl_h.CL_SUCCESS()) {\n-                                                System.out.println(\"failed to set arg \" + status);\n-                                            }\n-                                        }\n-                                        case Float floatArg->{\n-                                            var floatPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_FLOAT, floatArg);\n-                                            status = opencl_h.clSetKernelArg(kernel, i, opencl_h.C_FLOAT.byteSize(), floatPtr);\n-                                            if (status != opencl_h.CL_SUCCESS()) {\n-                                                System.out.println(\"failed to set arg \" + status);\n-                                            }\n-                                        }\n-                                        default -> throw new IllegalStateException(\"Unexpected value: \" + args[i]);\n-                                    }\n-                                }\n-                            }\n-\n-                            \/\/ We need to store x,y,z sizes so this is a kind of int3\n-                            var globalSizePtr = program.context.device.platform.openCL.arena.allocate(opencl_h.C_INT, 3);\n-                            globalSizePtr.set(opencl_h.C_INT, 0, range);\n-                            globalSizePtr.set(opencl_h.C_INT, 1*opencl_h.C_INT.byteSize(), 0);\n-                            globalSizePtr.set(opencl_h.C_INT, 2*opencl_h.C_INT.byteSize(), 0);\n-                            status = opencl_h.clEnqueueNDRangeKernel(\n-                                    program.context.queue,\n-                                    kernel,\n-                                    1, \/\/ this must match the # of dims we are using in this case 1 of 3\n-                                    NULL,\n-                                    globalSizePtr,\n-                                    NULL,\n-                                    block ? 0 : eventc,\n-                                    block ? NULL : ((eventc == 0) ? NULL : eventsPtr),\n-                                    block ? NULL : eventsPtr.asSlice(eventc * opencl_h.cl_event.byteSize(), opencl_h.cl_event\n-                                    )\n-                            );\n-                            if (status != opencl_h.CL_SUCCESS()) {\n-                                System.out.println(\"failed to enqueue NDRange \" + status);\n-                            }\n-\n-                            if (block) {\n-                                opencl_h.clFlush(program.context.queue);\n-                            } else {\n-                                eventc++;\n-                                status = opencl_h.clWaitForEvents(eventc, eventsPtr);\n-                                if (status != opencl_h.CL_SUCCESS()) {\n-                                    System.out.println(\"failed to wait for ndrange events \" + status);\n-                                }\n-                            }\n-\n-                            for (int i = 0; i < args.length; i++) {\n-                                if (args[i] instanceof MemorySegment memorySegment) {\n-                                    MemorySegment clMem = bufPtr.get(opencl_h.cl_mem, (long) i * opencl_h.cl_mem.byteSize());\n-                                    status = opencl_h.clEnqueueReadBuffer(program.context.queue,\n-                                            clMem,\n-                                            block ? opencl_h.CL_TRUE() : opencl_h.CL_FALSE(),\n-                                            0,\n-                                            memorySegment.byteSize(),\n-                                            memorySegment,\n-                                            block ? 0 : eventc,\n-                                            block ? NULL : ((eventc == 0) ? NULL : eventsPtr),\n-                                            block ? NULL : eventsPtr.asSlice(eventc * opencl_h.cl_event.byteSize(), opencl_h.cl_event)\/\/ block?NULL:readEventPtr\n-                                    );\n-                                    if (status != opencl_h.CL_SUCCESS()) {\n-                                        System.out.println(\"failed to enqueue read \" + status);\n-                                    }\n-                                    if (!block) {\n-                                        eventc++;\n-                                    }\n-                                }\n-                            }\n-                            if (!block) {\n-                                status = opencl_h.clWaitForEvents(eventc, eventsPtr);\n-                                if (status != opencl_h.CL_SUCCESS()) {\n-                                    System.out.println(\"failed to wait for events \" + status);\n-                                }\n-                            }\n-                            for (int i = 0; i < args.length; i++) {\n-                                if (args[i] instanceof MemorySegment memorySegment) {\n-                                    MemorySegment clMem = bufPtr.get(opencl_h.cl_mem, (long) i * opencl_h.cl_mem.byteSize());\n-                                    status = opencl_h.clReleaseMemObject(clMem);\n-                                    if (status != opencl_h.CL_SUCCESS()) {\n-                                        System.out.println(\"failed to release memObject \" + status);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    public Kernel getKernel(String kernelName) {\n-                        return new Kernel(this, kernelName);\n-                    }\n-                }\n-\n-                public Program buildProgram(String source) {\n-                    var program = new Program(this, source);\n-                    return program;\n-                }\n-            }\n-\n-            public Context createContext() {\n-\n-                var statusPtr = platform.openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n-                MemorySegment context;\n-                var deviceIds = platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, this.deviceId);\n-                if ((context = opencl_h.clCreateContext(NULL, 1, deviceIds, NULL, NULL, statusPtr)) == NULL) {\n-                    int status = statusPtr.get(opencl_h.C_INT, 0);\n-                    System.out.println(\"Failed to get context  \");\n-                    return null;\n-                } else {\n-                    int status = statusPtr.get(opencl_h.C_INT, 0);\n-                    if (status != opencl_h.CL_SUCCESS()) {\n-                        System.out.println(\"failed to get context  \" + status);\n-                    }\n-                    return new Context(this, context);\n-                }\n-            }\n-        }\n-\n-        int intPlatformInfo(int query) {\n-            var value = 0;\n-            if ((opencl_h.clGetPlatformInfo(platformId, query, opencl_h.C_INT.byteSize(), intValuePtr, NULL)) != opencl_h.CL_SUCCESS()) {\n-                System.out.println(\"Failed to get query \" + query);\n-            } else {\n-                value = intValuePtr.get(opencl_h.C_INT, 0);\n-            }\n-            return value;\n-        }\n-\n-        String strPlatformInfo(int query) {\n-            String value = null;\n-            int status;\n-            if ((status = opencl_h.clGetPlatformInfo(platformId, query, 2048, byte2048ValuePtr, intValuePtr)) != opencl_h.CL_SUCCESS()) {\n-                System.err.println(\"Failed to get query \" + query);\n-            } else {\n-                int len = intValuePtr.get(opencl_h.C_INT, 0);\n-                byte[] bytes = byte2048ValuePtr.toArray(ValueLayout.JAVA_BYTE);\n-                value = new String(bytes).substring(0, len - 1);\n-            }\n-            return value;\n-        }\n-\n-        CLWrap openCL;\n-        MemorySegment platformId;\n-        List<Device> devices = new ArrayList<>();\n-        final MemorySegment intValuePtr;\n-        final MemorySegment byte2048ValuePtr;\n-\n-        String platformName() {\n-            return strPlatformInfo(opencl_h.CL_PLATFORM_NAME());\n-        }\n-\n-        String vendorName() {\n-            return strPlatformInfo(opencl_h.CL_PLATFORM_VENDOR());\n-        }\n-\n-        String version() {\n-            return strPlatformInfo(opencl_h.CL_PLATFORM_VERSION());\n-        }\n-\n-        public Platform(CLWrap openCL, MemorySegment platformId) {\n-            this.openCL = openCL;\n-            this.platformId = platformId;\n-            this.intValuePtr = openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n-            this.byte2048ValuePtr = openCL.arena.allocate(opencl_h.C_CHAR, 2048);\n-            var devicecPtr = openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n-            int status;\n-            if ((status = opencl_h.clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), 0, NULL, devicecPtr)) != opencl_h.CL_SUCCESS()) {\n-                System.err.println(\"Failed getting devicec for platform 0 \");\n-            } else {\n-                int devicec = devicecPtr.get(opencl_h.C_INT, 0);\n-                \/\/  System.out.println(\"platform 0 has \" + devicec + \" device\" + ((devicec > 1) ? \"s\" : \"\"));\n-                var deviceIdsPtr = openCL.arena.allocate(opencl_h.C_POINTER, devicec);\n-                if ((status = opencl_h.clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), devicec, deviceIdsPtr, devicecPtr)) != opencl_h.CL_SUCCESS()) {\n-                    System.err.println(\"Failed getting deviceids  for platform 0 \");\n-                } else {\n-                    \/\/ System.out.println(\"We have \"+devicec+\" device ids\");\n-                    for (int i = 0; i < devicec; i++) {\n-                        devices.add(new Device(this, deviceIdsPtr.get(opencl_h.C_POINTER, i * opencl_h.C_POINTER.byteSize())));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    List<Platform> platforms = new ArrayList<>();\n-\n-    Arena arena;\n-\n-    CLWrap(Arena arena) {\n-        this.arena = arena;\n-        var platformcPtr = arena.allocateFrom(opencl_h.C_INT, 0);\n-\n-        if ((opencl_h.clGetPlatformIDs(0, NULL, platformcPtr)) != opencl_h.CL_SUCCESS()) {\n-            System.out.println(\"Failed to get opencl platforms\");\n-        } else {\n-            int platformc = platformcPtr.get(opencl_h.C_INT, 0);\n-            \/\/ System.out.println(\"There are \"+platformc+\" platforms\");\n-            var platformIdsPtr = arena.allocate(opencl_h.C_POINTER, platformc);\n-            if ((opencl_h.clGetPlatformIDs(platformc, platformIdsPtr, platformcPtr)) != opencl_h.CL_SUCCESS()) {\n-                System.out.println(\"Failed getting platform ids\");\n-            } else {\n-                for (int i = 0; i < platformc; i++) {\n-                    \/\/ System.out.println(\"We should have the ids\");\n-                    platforms.add(new Platform(this, platformIdsPtr.get(opencl_h.C_POINTER, i)));\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    public static void main(String[] args) throws IOException {\n-        try (var arena = Arena.ofConfined()) {\n-            CLWrap openCL = new CLWrap(arena);\n-\n-            Platform.Device[] selectedDevice = new Platform.Device[1];\n-            openCL.platforms.forEach(platform -> {\n-                System.out.println(\"Platform Name \" + platform.platformName());\n-                platform.devices.forEach(device -> {\n-                    System.out.println(\"   Compute Units     \" + device.computeUnits());\n-                    System.out.println(\"   Device Name       \" + device.deviceName());\n-                    System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n-                    selectedDevice[0] = device;\n-                });\n-            });\n-            var context = selectedDevice[0].createContext();\n-            var program = context.buildProgram(\"\"\"\n-                    __kernel void squares(__global int* in,__global int* out ){\n-                        int gid = get_global_id(0);\n-                        out[gid] = in[gid]*in[gid];\n-                    }\n-                    \"\"\");\n-            var kernel = program.getKernel(\"squares\");\n-            var in = arena.allocate(opencl_h.C_INT, 512);\n-            var out = arena.allocate(opencl_h.C_INT, 512);\n-            for (int i = 0; i < 512; i++) {\n-                in.set(opencl_h.C_INT, (int) i * opencl_h.C_INT.byteSize(), i);\n-            }\n-            kernel.run(512, in, out);\n-            for (int i = 0; i < 512; i++) {\n-                System.out.println(i + \" \" + out.get(opencl_h.C_INT, (int) i * opencl_h.C_INT.byteSize()));\n-            }\n-        }\n-    }\n-}\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/CLWrap.java","additions":0,"deletions":473,"binary":false,"changes":473,"status":"deleted"},{"patch":"@@ -1,262 +0,0 @@\n-package nbody;\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- *   - Redistributions of source code must retain the above copyright\n- *     notice, this list of conditions and the following disclaimer.\n- *\n- *   - Redistributions in binary form must reproduce the above copyright\n- *     notice, this list of conditions and the following disclaimer in the\n- *     documentation and\/or other materials provided with the distribution.\n- *\n- *   - Neither the name of Oracle nor the names of its\n- *     contributors may be used to endorse or promote products derived\n- *     from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n- * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-import opengl.glutDisplayFunc$func;\n-import opengl.glutIdleFunc$func;\n-\n-import javax.imageio.ImageIO;\n-import java.awt.image.BufferedImage;\n-import java.awt.image.DataBufferByte;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-import java.util.Arrays;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static opengl.opengl_h.C_CHAR;\n-import static opengl.opengl_h.C_FLOAT;\n-import static opengl.opengl_h.C_INT;\n-import static opengl.opengl_h.GLUT_DEPTH;\n-import static opengl.opengl_h.GLUT_DOUBLE;\n-import static opengl.opengl_h.GLUT_RGB;\n-import static opengl.opengl_h.GL_AMBIENT;\n-import static opengl.opengl_h.GL_COLOR_BUFFER_BIT;\n-import static opengl.opengl_h.GL_COLOR_MATERIAL;\n-import static opengl.opengl_h.GL_DEPTH_BUFFER_BIT;\n-import static opengl.opengl_h.GL_DEPTH_TEST;\n-import static opengl.opengl_h.GL_DIFFUSE;\n-import static opengl.opengl_h.GL_FRONT;\n-import static opengl.opengl_h.GL_LIGHT0;\n-import static opengl.opengl_h.GL_LIGHTING;\n-import static opengl.opengl_h.GL_LINEAR;\n-import static opengl.opengl_h.GL_NEAREST;\n-import static opengl.opengl_h.GL_ONE;\n-import static opengl.opengl_h.GL_POSITION;\n-import static opengl.opengl_h.GL_QUADS;\n-import static opengl.opengl_h.GL_SHININESS;\n-import static opengl.opengl_h.GL_SMOOTH;\n-import static opengl.opengl_h.GL_SPECULAR;\n-import static opengl.opengl_h.GL_SRC_ALPHA;\n-import static opengl.opengl_h.GL_TEXTURE_2D;\n-import static opengl.opengl_h.GL_TEXTURE_MAG_FILTER;\n-import static opengl.opengl_h.GL_TEXTURE_MIN_FILTER;\n-import static opengl.opengl_h.GL_UNSIGNED_BYTE;\n-import static opengl.opengl_h.glActiveTexture;\n-import static opengl.opengl_h.glBegin;\n-import static opengl.opengl_h.glBindTexture;\n-import static opengl.opengl_h.glBlendFunc;\n-import static opengl.opengl_h.glClear;\n-import static opengl.opengl_h.glClearColor;\n-import static opengl.opengl_h.glColor3f;\n-import static opengl.opengl_h.glDisable;\n-import static opengl.opengl_h.glEnable;\n-import static opengl.opengl_h.glEnd;\n-import static opengl.opengl_h.glGenTextures;\n-import static opengl.opengl_h.glLightfv;\n-import static opengl.opengl_h.glLoadIdentity;\n-import static opengl.opengl_h.glMaterialfv;\n-import static opengl.opengl_h.glPopMatrix;\n-import static opengl.opengl_h.glPushMatrix;\n-import static opengl.opengl_h.glRotatef;\n-import static opengl.opengl_h.glScalef;\n-import static opengl.opengl_h.glShadeModel;\n-import static opengl.opengl_h.glTexCoord2f;\n-import static opengl.opengl_h.glTexImage2D;\n-import static opengl.opengl_h.glTexParameteri;\n-import static opengl.opengl_h.glVertex3f;\n-import static opengl.opengl_h.glutCreateWindow;\n-import static opengl.opengl_h.glutDisplayFunc;\n-import static opengl.opengl_h.glutIdleFunc;\n-import static opengl.opengl_h.glutInit;\n-import static opengl.opengl_h.glutInitDisplayMode;\n-import static opengl.opengl_h.glutInitWindowSize;\n-import static opengl.opengl_h.glutMainLoop;\n-import static opengl.opengl_h.glutPostRedisplay;\n-import static opengl.opengl_h.glutSolidTeapot;\n-import static opengl.opengl_h.glutSwapBuffers;\n-import static opengl.opengl_h_2.GL_BLEND;\n-import static opengl.opengl_h_2.GL_RGBA;\n-\n-public class GLWrap {\n-    public static class GLTexture {\n-        final Arena arena;\n-        final MemorySegment data;\n-        final int width;\n-        final int height;\n-        int idx;\n-        GLTexture(Arena arena, InputStream textureStream) {\n-            this.arena = arena;\n-            BufferedImage img = null;\n-            try {\n-                img = ImageIO.read(textureStream);\n-                this.width = img.getWidth();\n-                this.height = img.getHeight();\n-                BufferedImage image = new BufferedImage(width,height, BufferedImage.TYPE_4BYTE_ABGR_PRE);\n-                image.getGraphics().drawImage(img, 0, 0, null);\n-                var raster = image.getRaster();\n-                var dataBuffer = raster.getDataBuffer();\n-                data = arena.allocateFrom(C_CHAR, ((DataBufferByte) dataBuffer).getData());\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-\n-    public static class GLWindow {\n-        Arena arena;\n-        int width;\n-        int height;\n-        String name;\n-        GLTexture[] textures;\n-        MemorySegment textureBuf;\n-        GLWindow(Arena arena, int width, int height, String name, GLTexture... textures) {\n-            this.arena = arena;\n-            this.width = width;\n-            this.height = height;\n-            this.name = name;\n-            this.textures = textures;\n-            var argc = arena.allocateFrom(C_INT, 0);\n-            glutInit(argc, argc);\n-            glutInitDisplayMode(GLUT_DOUBLE() | GLUT_RGB() | GLUT_DEPTH());\n-            glutInitWindowSize(width, height);\n-            glutCreateWindow(arena.allocateFrom(\"NBODY!\"));\n-\n-            glClearColor(0f, 0f, 0f, 0f);\n-            \/\/ Setup Lighting see  https:\/\/www.khronos.org\/opengl\/wiki\/How_lighting_works\n-            glShadeModel(GL_SMOOTH());\n-            glEnable(GL_BLEND());\n-            glBlendFunc(GL_SRC_ALPHA(), GL_ONE());\n-            glEnable(GL_TEXTURE_2D());\n-            textureBuf = arena.allocate(C_INT, textures.length*C_INT.byteSize());\n-            glGenTextures(textures.length, textureBuf);\n-            int[] count = {0};\n-            Arrays.stream(textures).forEach(texture -> {\n-                texture.idx=count[0]++;\n-                glBindTexture(GL_TEXTURE_2D(), textureBuf.get(JAVA_INT, texture.idx * JAVA_INT.byteSize()));\n-                glTexImage2D(GL_TEXTURE_2D(), 0, GL_RGBA(), texture.width,\n-                        texture.height, 0, GL_RGBA(), GL_UNSIGNED_BYTE(), texture.data);\n-                glTexParameteri(GL_TEXTURE_2D(), GL_TEXTURE_MAG_FILTER(), GL_LINEAR());\n-                glTexParameteri(GL_TEXTURE_2D(), GL_TEXTURE_MIN_FILTER(), GL_NEAREST());\n-            });\n-            var useLighting = false;\n-            if (useLighting) {\n-                glEnable(GL_LIGHTING());\n-\n-                var light = GL_LIGHT0(); \/\/ .... GL_LIGHT_0 .. -> 7\n-\n-                var pos = arena.allocateFrom(C_FLOAT, new float[]{0.0f, 15.0f, -15.0f, 0});\n-\n-                glLightfv(light, GL_POSITION(), pos);\n-\n-                var red_ambient_light = arena.allocateFrom(C_FLOAT, new float[]{1f, 0.0f, 0.0f, 0.0f});\n-\n-                var grey_diffuse_light = arena.allocateFrom(C_FLOAT, new float[]{1f, 1f, 1f, 0.0f});\n-\n-                var yellow_specular_light = arena.allocateFrom(C_FLOAT, new float[]{1.0f, 1.0f, 0.0f, 0.0f});\n-                glLightfv(light, GL_AMBIENT(), red_ambient_light);\n-                glLightfv(light, GL_DIFFUSE(), grey_diffuse_light);\n-                glLightfv(light, GL_SPECULAR(), yellow_specular_light);\n-\n-                var shini = arena.allocate(C_FLOAT, 113);\n-                glMaterialfv(GL_FRONT(), GL_SHININESS(), shini);\n-\n-                var useColorMaterials = false;\n-                if (useColorMaterials) {\n-                    glEnable(GL_COLOR_MATERIAL());\n-                } else {\n-                    glDisable(GL_COLOR_MATERIAL());\n-                }\n-                glEnable(light);\n-                glEnable(GL_DEPTH_TEST());\n-            } else {\n-                glDisable(GL_LIGHTING());\n-            }\n-            glutDisplayFunc(glutDisplayFunc$func.allocate(this::display, arena));\n-            glutIdleFunc(glutIdleFunc$func.allocate(this::onIdle, arena));\n-        }\n-        void display() {\n-            glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n-            glPushMatrix();\n-            glLoadIdentity();\n-            glRotatef(0f, 0f,0f, 0f);\n-            \/\/glRotatef(rot, 0f, 1f, 0f);\n-            \/\/   glTranslatef(0f, 0f, trans);\n-            glScalef(.1f, .1f, 1);\n-\n-            glActiveTexture(textureBuf.get(ValueLayout.JAVA_INT, 0));\n-            glBindTexture(GL_TEXTURE_2D(), textureBuf.get(ValueLayout.JAVA_INT, 0));\n-            glColor3f(1f, 1f, 1f);\n-            glBegin(GL_QUADS());\n-            {\n-                float dx = -.5f;\n-                float dy = -.5f;\n-                float dz = -.5f;\n-                float x = 0f;\n-                float y= 0f;\n-                float z = 0f;\n-                    glTexCoord2f(0, 1);\n-                    glVertex3f(x + dx, y + dy + 1, z + dz);\n-                    glTexCoord2f(0, 0);\n-                    glVertex3f(x + dx, y + dy, z + dz);\n-                    glTexCoord2f(1, 0);\n-                    glVertex3f(x + dx + 1, y + dy, z + dz);\n-                    glTexCoord2f(1, 1);\n-                    glVertex3f(x + dx + 1, y + dy + 1, z + dz);\n-            }\n-            glEnd();\n-            glColor3f(0.8f, 0.1f, 0.1f);\n-            glutSolidTeapot(1d);\n-            glPopMatrix();\n-            glutSwapBuffers();\n-        }\n-\n-        void onIdle() {\n-            glutPostRedisplay();\n-        }\n-\n-        public void mainLoop() {\n-            glutMainLoop();\n-        }\n-    }\n-\n-\n-    public void main(String[] args) throws IOException {\n-        try (var arena = Arena.ofConfined()) {\n-            new GLWindow(arena, 800,800,\"name\",\n-                    new GLTexture(arena, GLWrap.class.getResourceAsStream(\"\/particle.png\"))\n-            ).mainLoop();\n-        }\n-    }\n-}\n-\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/GLWrap.java","additions":0,"deletions":262,"binary":false,"changes":262,"status":"deleted"},{"patch":"@@ -37,1 +37,1 @@\n-        NBodyGLWindow.Mode mode = NBodyGLWindow.Mode.of(args.length > 3 ? args[3] : NBodyGLWindow.Mode.OpenCL.toString());\n+        NBodyGLWindow.Mode mode = NBodyGLWindow.Mode.of(args.length > 3 ? args[3] : NBodyGLWindow.Mode.HAT.toString());\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,520 +0,0 @@\n-package nbody;\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.backend.Backend;\n-import hat.buffer.Buffer;\n-import static hat.ifacemapper.MappableIface.*;\n-import hat.ifacemapper.Schema;\n-import jdk.incubator.code.CodeReflection;\n-\n-import java.io.IOException;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.invoke.MethodHandles;\n-import java.util.stream.IntStream;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static opengl.opengl_h.GL_COLOR_BUFFER_BIT;\n-import static opengl.opengl_h.GL_DEPTH_BUFFER_BIT;\n-import static opengl.opengl_h.GL_QUADS;\n-import static opengl.opengl_h.GL_TEXTURE_2D;\n-import static opengl.opengl_h.glBegin;\n-import static opengl.opengl_h.glBindTexture;\n-import static opengl.opengl_h.glClear;\n-import static opengl.opengl_h.glColor3f;\n-import static opengl.opengl_h.glEnd;\n-import static opengl.opengl_h.glLoadIdentity;\n-import static opengl.opengl_h.glPopMatrix;\n-import static opengl.opengl_h.glPushMatrix;\n-import static opengl.opengl_h.glRotatef;\n-import static opengl.opengl_h.glScalef;\n-import static opengl.opengl_h.glTexCoord2f;\n-import static opengl.opengl_h.glVertex3f;\n-import static opengl.opengl_h.glutSwapBuffers;\n-import static opengl.opengl_h_3.C_FLOAT;\n-\n-\n-public class Main {\n-    public interface Universe extends Buffer {\n-        int length();\n-\n-        interface Body extends Struct {\n-            float x();\n-\n-            float y();\n-\n-            float z();\n-\n-            float vx();\n-\n-            float vy();\n-\n-            float vz();\n-\n-            void x(float x);\n-\n-            void y(float y);\n-\n-            void z(float z);\n-\n-            void vx(float vx);\n-\n-            void vy(float vy);\n-\n-            void vz(float vz);\n-        }\n-\n-        Body body(long idx);\n-\n-        Schema<Universe> schema = Schema.of(Universe.class, resultTable -> resultTable\n-\n-                .arrayLen(\"length\").array(\"body\", array -> array\n-                        .fields(\"x\", \"y\", \"z\", \"vx\", \"vy\", \"vz\")\n-                )\n-        );\n-\n-        static Universe create(Accelerator accelerator, int length) {\n-            return schema.allocate(accelerator, length);\n-        }\n-\n-    }\n-\n-    public static class NBody extends GLWrap.GLWindow {\n-\n-        protected final static float delT = .1f;\n-\n-        protected final static float espSqr = 0.1f;\n-\n-        protected final static float mass = .5f;\n-\n-        @CodeReflection\n-        static public void nbodyKernel(@RO KernelContext kc, @RW Universe universe, float mass, float delT, float espSqr) {\n-            float accx = 0.0f;\n-            float accy = 0.0f;\n-            float accz = 0.0f;\n-            Universe.Body me = universe.body(kc.x);\n-\n-            for (int i = 0; i < kc.maxX; i++) {\n-                Universe.Body body = universe.body(i);\n-                float dx = body.x() - me.x();\n-                float dy = body.y() - me.y();\n-                float dz = body.z() - me.z();\n-                float invDist = (float) (1.0f \/ Math.sqrt(((dx * dx) + (dy * dy) + (dz * dz) + espSqr)));\n-                float s = mass * invDist * invDist * invDist;\n-                accx = accx + (s * dx);\n-                accy = accy + (s * dy);\n-                accz = accz + (s * dz);\n-            }\n-            accx = accx * delT;\n-            accy = accy * delT;\n-            accz = accz * delT;\n-            me.x(me.x() + (me.vx() * delT + accx * .5f * delT));\n-            me.y(me.y() + (me.vy() * delT + accy * .5f * delT));\n-            me.z(me.z() + (me.vz() * delT + accz * .5f * delT));\n-            me.vx(me.vx() + accx);\n-            me.vy(me.vy() + accy);\n-            me.vz(me.vz() + accz);\n-        }\n-\n-        @CodeReflection\n-        public static void nbodyCompute(@RO ComputeContext cc, @RW Universe universe, float mass, float delT, float espSqr) {\n-            float cmass = mass;\n-            float cdelT = delT;\n-            float cespSqr= espSqr;\n-\n-            cc.dispatchKernel(universe.length(), kc -> nbodyKernel(kc, universe, cmass, cdelT, cespSqr));\n-        }\n-\n-\n-        private static int STRIDE = 4;\n-        private static int Xidx = 0;\n-        private static int Yidx = 1;\n-        private static int Zidx = 2;\n-\n-        final float[] xyzPos;\n-        final float[] xyzVel;\n-\n-        final GLWrap.GLTexture particle;\n-        final MemorySegment xyzPosSeg;\n-        final MemorySegment xyzVelSeg;\n-        final Universe universe;\n-        final Accelerator accelerator;\n-        final CLWrap.Platform.Device.Context.Program.Kernel kernel;\n-\n-        int count;\n-        int frames = 0;\n-        long startTime = 0l;\n-\n-        public enum Mode {\n-            HAT(),\n-            OpenCL(\"\"\"\n-                    __kernel void nbody( __global float *xyzPos ,__global float* xyzVel, float mass, float delT, float espSqr ){\n-                        int body = get_global_id(0);\n-                        int STRIDE=4;\n-                        int Xidx=0;\n-                        int Yidx=1;\n-                        int Zidx=2;\n-                        int bodyStride = body*STRIDE;\n-                        int bodyStrideX = bodyStride+Xidx;\n-                        int bodyStrideY = bodyStride+Yidx;\n-                        int bodyStrideZ = bodyStride+Zidx;\n-\n-                        float accx = 0.0;\n-                        float accy = 0.0;\n-                        float accz = 0.0;\n-                        float myPosx = xyzPos[bodyStrideX];\n-                        float myPosy = xyzPos[bodyStrideY];\n-                        float myPosz = xyzPos[bodyStrideZ];\n-                        for (int i = 0; i < get_global_size(0); i++) {\n-                            int iStride = i*STRIDE;\n-                            float dx = xyzPos[iStride+Xidx] - myPosx;\n-                            float dy = xyzPos[iStride+Yidx] - myPosy;\n-                            float dz = xyzPos[iStride+Zidx] - myPosz;\n-                            float invDist =  (float) 1.0\/sqrt((float)((dx * dx) + (dy * dy) + (dz * dz) + espSqr));\n-                            float s = mass * invDist * invDist * invDist;\n-                            accx = accx + (s * dx);\n-                            accy = accy + (s * dy);\n-                            accz = accz + (s * dz);\n-                        }\n-                        accx = accx * delT;\n-                        accy = accy * delT;\n-                        accz = accz * delT;\n-                        xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * 0.5 * delT);\n-                        xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * 0.5 * delT);\n-                        xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * 0.5 * delT);\n-\n-                        xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n-                        xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n-                        xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n-\n-                    }\n-                    \"\"\"),\n-            OpenCL4(\"\"\"\n-                    __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n-                        float4 acc = (0.0,0.0,0.0,0.0);\n-                        float4 myPos = xyzPos[get_global_id(0)];\n-                        float4 myVel = xyzVel[get_global_id(0)];\n-                        for (int i = 0; i < get_global_size(0); i++) {\n-                               float4 delta =  xyzPos[i] - myPos;\n-                               float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n-                               float s = mass * invDist * invDist * invDist;\n-                               acc= acc + (s * delta);\n-                        }\n-                        acc = acc*delT;\n-                        myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n-                        myVel = myVel + acc;\n-                        xyzPos[get_global_id(0)] = myPos;\n-                        xyzVel[get_global_id(0)] = myVel;\n-\n-                    }\n-                    \"\"\"),\n-            JavaSeq(false),\n-            JavaMT(true);\n-            final public boolean hat;\n-            final public String code;\n-            final public boolean isOpenCL;\n-            final public boolean isJava;\n-            final public boolean isMultiThreaded;\n-\n-            Mode() {\n-                this.hat = true;\n-                this.code = null;\n-                this.isOpenCL = false;\n-                this.isJava = false;\n-                this.isMultiThreaded = false;\n-            }\n-\n-            Mode(String code) {\n-                this.hat = true;\n-                this.code = code;\n-                this.isOpenCL = true;\n-                this.isJava = false;\n-                this.isMultiThreaded = false;\n-            }\n-\n-            Mode(boolean isMultiThreaded) {\n-                this.hat = true;\n-                this.code = null;\n-                this.isOpenCL = false;\n-                this.isJava = true;\n-                this.isMultiThreaded = isMultiThreaded;\n-            }\n-\n-            public static Mode of(String name, Mode defaultMode) {\n-                return switch (name) {\n-                    case \"HAT\" -> NBody.Mode.HAT;\n-                    case \"OpenCL\" -> NBody.Mode.OpenCL;\n-                    case \"JavaSeq\" -> NBody.Mode.JavaSeq;\n-                    case \"JavaMT\" -> NBody.Mode.JavaMT;\n-                    case \"OpenCL4\" -> NBody.Mode.OpenCL4;\n-                    default -> defaultMode;\n-                };\n-            }\n-        }\n-\n-        final Mode mode;\n-\n-        public NBody(Arena arena, int width, int height, GLWrap.GLTexture particle, int count, Mode mode) {\n-            super(arena, width, height, \"nbody\", particle);\n-            this.particle = particle;\n-            this.count = count;\n-            this.xyzPos = new float[count * STRIDE];\n-            this.xyzVel = new float[count * STRIDE];\n-            this.mode = mode;\n-            final float maxDist = 80f;\n-\n-            System.out.println(count + \" particles\");\n-\n-            switch (mode) {\n-                case OpenCL, OpenCL4, JavaMT, JavaSeq -> {\n-                    for (int body = 0; body < count; body++) {\n-                        final float theta = (float) (Math.random() * Math.PI * 2);\n-                        final float phi = (float) (Math.random() * Math.PI * 2);\n-                        final float radius = (float) (Math.random() * maxDist);\n-\n-                        \/\/ get random 3D coordinates in sphere\n-                        xyzPos[(body * STRIDE) + Xidx] = (float) (radius * Math.cos(theta) * Math.sin(phi));\n-                        xyzPos[(body * STRIDE) + Yidx] = (float) (radius * Math.sin(theta) * Math.sin(phi));\n-                        xyzPos[(body * STRIDE) + Zidx] = (float) (radius * Math.cos(phi));\n-                    }\n-                }\n-                default -> {\n-                }\n-\n-            }\n-            switch (mode){\n-                case OpenCL,OpenCL4->{\n-                    xyzPosSeg = arena.allocateFrom(JAVA_FLOAT, xyzPos);\n-                    xyzVelSeg = arena.allocateFrom(JAVA_FLOAT, xyzVel);\n-                    CLWrap openCL = new CLWrap(arena);\n-\n-                    CLWrap.Platform.Device[] selectedDevice = new CLWrap.Platform.Device[1];\n-                    openCL.platforms.forEach(platform -> {\n-                        System.out.println(\"Platform Name \" + platform.platformName());\n-                        platform.devices.forEach(device -> {\n-                            System.out.println(\"   Compute Units     \" + device.computeUnits());\n-                            System.out.println(\"   Device Name       \" + device.deviceName());\n-                            System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n-                            selectedDevice[0] = device;\n-                        });\n-                    });\n-                    var context = selectedDevice[0].createContext();\n-                    var program = context.buildProgram(mode.code);\n-                    kernel = program.getKernel(\"nbody\");\n-                    accelerator = null;\n-                    universe = null;\n-                }\n-                case JavaMT,JavaSeq->{\n-                    kernel = null;\n-                    xyzPosSeg = null;\n-                    xyzVelSeg = null;\n-                    accelerator = null;\n-                    universe = null;\n-                }\n-                case HAT->{\n-                    kernel = null;\n-                    xyzPosSeg = null;\n-                    xyzVelSeg = null;\n-                    accelerator = new Accelerator(MethodHandles.lookup(),\n-                            Backend.FIRST\n-                    );\n-                    universe = Universe.create(accelerator, count);\n-                    for (int body = 0; body < count; body++) {\n-                        Universe.Body b = universe.body(body);\n-                        final float theta = (float) (Math.random() * Math.PI * 2);\n-                        final float phi = (float) (Math.random() * Math.PI * 2);\n-                        final float radius = (float) (Math.random() * maxDist);\n-\n-                        \/\/ get random 3D coordinates in sphere\n-                        b.x((float) (radius * Math.cos(theta) * Math.sin(phi)));\n-                        b.y((float) (radius * Math.sin(theta) * Math.sin(phi)));\n-                        b.z((float) (radius * Math.cos(phi)));\n-                    }\n-                }\n-                default -> {\n-                    kernel = null;\n-                    xyzPosSeg = null;\n-                    xyzVelSeg = null;\n-                    accelerator = null;\n-                    universe = null;\n-                }\n-            }\n-        }\n-\n-\n-        float rot = 0f;\n-\n-        public static void run(int body, int size, float[] xyzPos, float[] xyzVel, float mass, float delT, float espSqr) {\n-            float accx = 0.f;\n-            float accy = 0.f;\n-            float accz = 0.f;\n-            int bodyStride = body * STRIDE;\n-            int bodyStrideX = bodyStride + Xidx;\n-            int bodyStrideY = bodyStride + Yidx;\n-            int bodyStrideZ = bodyStride + Zidx;\n-\n-            final float myPosx = xyzPos[bodyStrideX];\n-            final float myPosy = xyzPos[bodyStrideY];\n-            final float myPosz = xyzPos[bodyStrideZ];\n-\n-            for (int i = 0; i < size; i++) {\n-                int iStride = i * STRIDE;\n-                int iStrideX = iStride + Xidx;\n-                int iStrideY = iStride + Yidx;\n-                int iStrideZ = iStride + Zidx;\n-                final float dx = xyzPos[iStrideX] - myPosx;\n-                final float dy = xyzPos[iStrideY] - myPosy;\n-                final float dz = xyzPos[iStrideZ] - myPosz;\n-                final float invDist = 1 \/ (float) Math.sqrt((dx * dx) + (dy * dy) + (dz * dz) + espSqr);\n-                final float s = mass * invDist * invDist * invDist;\n-                accx = accx + (s * dx);\n-                accy = accy + (s * dy);\n-                accz = accz + (s * dz);\n-            }\n-            accx = accx * delT;\n-            accy = accy * delT;\n-            accz = accz * delT;\n-            xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * .5f * delT);\n-            xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * .5f * delT);\n-            xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * .5f * delT);\n-\n-            xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n-            xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n-            xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n-        }\n-\n-        void display() {\n-            if (startTime == 0) {\n-                startTime = System.currentTimeMillis();\n-            }\n-            glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n-            glPushMatrix();\n-            glLoadIdentity();\n-            glRotatef(-rot \/ 2f, 0f, 0f, 1f);\n-            \/\/glRotatef(rot, 0f, 1f, 0f);\n-            \/\/   glTranslatef(0f, 0f, trans);\n-            glScalef(.01f, .01f, .01f);\n-            glColor3f(1f, 1f, 1f);\n-\n-            switch (mode){\n-                case JavaMT,JavaSeq ->{\n-                    if (mode.isMultiThreaded) {\n-                        IntStream.range(0, count).parallel().forEach(\n-                                i -> run(i, count, xyzPos, xyzVel, mass, delT, espSqr)\n-                        );\n-                    } else {\n-                        IntStream.range(0, count).forEach(\n-                                i -> run(i, count, xyzPos, xyzVel, mass, delT, espSqr)\n-                        );\n-                    }\n-                }\n-                case OpenCL,OpenCL4->{\n-                    kernel.run(count, xyzPosSeg, xyzVelSeg, mass, delT, espSqr);\n-                }\n-                case HAT->{\n-                    float cmass = mass;\n-                    float cdelT = delT;\n-                    float cespSqr = espSqr;\n-                    Universe cuniverse = universe;\n-                    accelerator.compute(cc -> nbodyCompute(cc, cuniverse, cmass, cdelT, cespSqr));\n-                }\n-            }\n-\n-            glBegin(GL_QUADS());\n-            {\n-                glBindTexture(GL_TEXTURE_2D(), textureBuf.get(JAVA_INT, particle.idx * JAVA_INT.byteSize()));\n-                float dx = -.5f;\n-                float dy = -.5f;\n-                float dz = -.5f;\n-\n-                for (int i = 0; i < count; i++) {\n-                    float x=0,y=0,z=0;\n-                    switch (mode){\n-                        case OpenCL4 ,OpenCL -> {\n-                            x = xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Xidx * C_FLOAT.byteSize()));\n-                            y = xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Yidx * C_FLOAT.byteSize()));\n-                            z = xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Zidx * C_FLOAT.byteSize()));\n-                        }\n-                        case JavaMT, JavaSeq -> {\n-                            x = xyzPos[(i * STRIDE) + Xidx];\n-                            y = xyzPos[(i * STRIDE) + Yidx];\n-                            z = xyzPos[(i * STRIDE) + Zidx];\n-                        }\n-                        case HAT ->{\n-                            Universe.Body body = universe.body(i);\n-                            x=body.x();\n-                            y=body.y();\n-                            z=body.z();\n-                        }\n-                    }\n-                    final int LEFT = 0;\n-                    final int RIGHT = 1;\n-                    final int TOP = 0;\n-                    final int BOTTOM = 1;\n-                    glTexCoord2f(LEFT, BOTTOM);\n-                    glVertex3f(x + dx + LEFT, y + dy + BOTTOM, z + dz);\n-                    glTexCoord2f(LEFT, TOP);\n-                    glVertex3f(x + dx + LEFT, y + dy + TOP, z + dz);\n-                    glTexCoord2f(RIGHT, TOP);\n-                    glVertex3f(x + dx + RIGHT, y + dy + TOP, z + dz);\n-                    glTexCoord2f(RIGHT, BOTTOM);\n-                    glVertex3f(x + dx + RIGHT, y + dy + BOTTOM, z + dz);\n-                }\n-            }\n-            glEnd();\n-            glColor3f(0.8f, 0.1f, 0.1f);\n-            glPopMatrix();\n-            glutSwapBuffers();\n-            frames++;\n-            long elapsed = System.currentTimeMillis() - startTime;\n-            if (elapsed > 200 || (frames % 100) == 0) {\n-                float secs = elapsed \/ 1000f;\n-              \/\/  System.out.println((frames \/ secs) + \"fps\");\n-            }\n-        }\n-\n-        void onIdle() {\n-            rot += 1f;\n-            super.onIdle();\n-        }\n-    }\n-\n-    public void main(String[] args) {\n-        int particleCount =  32768;\n-        NBody.Mode mode = NBody.Mode.HAT;\/\/NBody.Mode.OpenCL4;\/\/NBody.Mode.of(\"HAT\", NBody.Mode.OpenCL);\n-        System.out.println(\"mode\" + mode);\n-        try (var arena = Arena.ofConfined()) {\n-            var particleTexture = new GLWrap.GLTexture(arena, NBody.class.getResourceAsStream(\"\/particle.png\"));\n-            new NBody(arena, 1000, 1000, particleTexture, particleCount, mode).mainLoop();\n-        }\n-    }\n-}\n-\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Main.java.no","additions":0,"deletions":520,"binary":false,"changes":520,"status":"deleted"},{"patch":"@@ -65,1 +65,1 @@\n-    final GLTexture particle;\n+    protected final GLTexture particle;\n@@ -71,1 +71,1 @@\n-    final long startTime = System.currentTimeMillis();\n+    protected final long startTime = System.currentTimeMillis();\n@@ -173,7 +173,7 @@\n-    static final float WEST = 0;\n-    static final float EAST = 1;\n-    static final float NORTH = 0;\n-    static final float SOUTH = 1;\n-    static float dx = -.5f;\n-    static float dy = -.5f;\n-    static float dz = -.5f;\n+    protected static final float WEST = 0;\n+    protected static final float EAST = 1;\n+    protected static final float NORTH = 0;\n+    protected static final float SOUTH = 1;\n+    protected static float dx = -.5f;\n+    protected static float dy = -.5f;\n+    protected static float dz = -.5f;\n@@ -196,3 +196,2 @@\n-\n-                for (int bodyIdx = 0; bodyIdx < bodyCount; bodyIdx++) {\n-                    var bodyf4 = xyzPosFloatArr.get(bodyIdx);\n+    for (int bodyIdx = 0; bodyIdx < bodyCount; bodyIdx++) {\n+        var bodyf4 = xyzPosFloatArr.get(bodyIdx);\n@@ -213,9 +212,10 @@\n-                    glTexCoord2f(WEST, SOUTH);\n-                    glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n-                    glTexCoord2f(WEST, NORTH);\n-                    glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n-                    glTexCoord2f(EAST, NORTH);\n-                    glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n-                    glTexCoord2f(EAST, SOUTH);\n-                    glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n-                }\n+        glTexCoord2f(WEST, SOUTH);\n+        glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n+        glTexCoord2f(WEST, NORTH);\n+        glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n+        glTexCoord2f(EAST, NORTH);\n+        glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n+        glTexCoord2f(EAST, SOUTH);\n+        glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n+\n+}\n@@ -257,1 +257,1 @@\n-        OpenCL, Cuda, OpenCL4, Cuda4, JavaSeq, JavaMT, JavaSeq4, JavaMT4;\n+        HAT,OpenCL, Cuda, OpenCL4, Cuda4, JavaSeq, JavaMT, JavaSeq4, JavaMT4;\n@@ -261,0 +261,1 @@\n+                case \"HAT\" -> Mode.HAT;\n@@ -275,1 +276,1 @@\n-        Mode mode = Mode.of(args.length>3?args[3]: Mode.JavaMT.toString());\n+        Mode mode = Mode.of(args.length>3?args[3]: Mode.HAT.toString());\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/NBodyGLWindow.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,0 +28,28 @@\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.backend.ffi.OpenCLBackend;\n+import hat.buffer.Buffer;\n+import hat.KernelContext;\n+import hat.ifacemapper.MappableIface;\n+import static hat.ifacemapper.MappableIface.*;\n+import static opengl.opengl_h.glMatrixMode;\n+import static opengl.opengl_h.glRasterPos2f;\n+import static opengl.opengl_h.glScalef;\n+import static opengl.opengl_h.glTexCoord2f;\n+import static opengl.opengl_h.glVertex3f;\n+import static opengl.opengl_h.glutBitmapCharacter;\n+import static opengl.opengl_h.glutBitmapTimesRoman24$segment;\n+import static opengl.opengl_h.glutSwapBuffers;\n+import static opengl.opengl_h_1.glBindTexture;\n+import static opengl.opengl_h_1.glClear;\n+import static opengl.opengl_h_1.glClearColor;\n+import static opengl.opengl_h_1.glColor3f;\n+import static opengl.opengl_h_1.glDisable;\n+import static opengl.opengl_h_1.glEnable;\n+import static opengl.opengl_h_2.GL_COLOR_BUFFER_BIT;\n+import static opengl.opengl_h_2.GL_DEPTH_BUFFER_BIT;\n+import static opengl.opengl_h_2.GL_MODELVIEW;\n+import static opengl.opengl_h_2.GL_TEXTURE_2D;\n+\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n@@ -35,0 +63,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -38,0 +67,97 @@\n+        public interface Universe extends Buffer {\n+            int length();\n+\n+            interface Body extends Struct {\n+                float x();\n+\n+                float y();\n+\n+                float z();\n+\n+                float vx();\n+\n+                float vy();\n+\n+                float vz();\n+\n+                void x(float x);\n+\n+                void y(float y);\n+\n+                void z(float z);\n+\n+                void vx(float vx);\n+\n+                void vy(float vy);\n+\n+                void vz(float vz);\n+            }\n+\n+            Body body(long idx);\n+            \/*\n+            typedef Body_s{\n+                float x;\n+                float y;\n+                float vx;\n+                float vy;\n+            } Body_t;\n+\n+            typedef Universe_s{\n+               int length;\n+               Body body[1];\n+            }Universe_t;\n+\n+             *\/\n+            Schema<Universe> schema = Schema.of(Universe.class, resultTable -> resultTable\n+\n+                    .arrayLen(\"length\").array(\"body\", array -> array\n+                            .fields(\"x\", \"y\", \"z\", \"vx\", \"vy\", \"vz\")\n+                    )\n+            );\n+\n+            static Universe create(Accelerator accelerator, int length) {\n+                return schema.allocate(accelerator, length);\n+            }\n+\n+        }\n+\n+\n+        @CodeReflection\n+        static public void nbodyKernel(@RO KernelContext kc, @RW Universe universe, float mass, float delT, float espSqr) {\n+            float accx = 0.0f;\n+            float accy = 0.0f;\n+            float accz = 0.0f;\n+            Universe.Body me = universe.body(kc.x);\n+\n+            for (int i = 0; i < kc.maxX; i++) {\n+                Universe.Body body = universe.body(i);\n+                float dx = body.x() - me.x();\n+                float dy = body.y() - me.y();\n+                float dz = body.z() - me.z();\n+                float invDist = (float) (1.0f \/ Math.sqrt(((dx * dx) + (dy * dy) + (dz * dz) + espSqr)));\n+                float s = mass * invDist * invDist * invDist;\n+                accx = accx + (s * dx);\n+                accy = accy + (s * dy);\n+                accz = accz + (s * dz);\n+            }\n+            accx = accx * delT;\n+            accy = accy * delT;\n+            accz = accz * delT;\n+            me.x(me.x() + (me.vx() * delT + accx * .5f * delT));\n+            me.y(me.y() + (me.vy() * delT + accy * .5f * delT));\n+            me.z(me.z() + (me.vz() * delT + accz * .5f * delT));\n+            me.vx(me.vx() + accx);\n+            me.vy(me.vy() + accy);\n+            me.vz(me.vz() + accz);\n+        }\n+\n+        @CodeReflection\n+        public static void nbodyCompute(@RO ComputeContext cc, @RW Universe universe, float mass, float delT, float espSqr) {\n+            float cmass = mass;\n+            float cdelT = delT;\n+            float cespSqr= espSqr;\n+\n+            cc.dispatchKernel(universe.length(), kc -> nbodyKernel(kc, universe, cmass, cdelT, cespSqr));\n+        }\n+\n+\n@@ -39,1 +165,1 @@\n-        final CLWrapComputeContext CLWrapComputeContext;\n+        final CLWrapComputeContext clWrapComputeContext;\n@@ -42,2 +168,2 @@\n-\n-\n+final Accelerator accelerator;\n+final Universe universe;\n@@ -46,8 +172,40 @@\n-            this.CLWrapComputeContext = new CLWrapComputeContext(arena, 20);\n-            this.vel = CLWrapComputeContext.register(xyzVelFloatArr.ptr());\n-            this.pos = CLWrapComputeContext.register(xyzPosFloatArr.ptr());\n-\n-            var platforms = CLPlatform.platforms(arena);\n-            System.out.println(\"platforms \" + platforms.size());\n-            var platform = platforms.get(0);\n-            platform.devices.forEach(device -> {\n+            final float maxDist = 80f;\n+            if (mode.equals(Mode.HAT)){\n+                kernel = null;\n+                clWrapComputeContext = null;\n+                vel=null;\n+                pos=null;\n+                accelerator = new Accelerator(MethodHandles.lookup(),\n+                        new OpenCLBackend(OpenCLBackend.Mode.of(\"GPU\"))\n+                );\n+                universe = Universe.create(accelerator, bodyCount);\n+                for (int body = 0; body < bodyCount; body++) {\n+                    Universe.Body b = universe.body(body);\n+                    final float theta = (float) (Math.random() * Math.PI * 2);\n+                    final float phi = (float) (Math.random() * Math.PI * 2);\n+                    final float radius = (float) (Math.random() * maxDist);\n+\n+                    \/\/ get random 3D coordinates in sphere\n+                    b.x((float) (radius * Math.cos(theta) * Math.sin(phi)));\n+                    b.y((float) (radius * Math.sin(theta) * Math.sin(phi)));\n+                    b.z((float) (radius * Math.cos(phi)));\n+                }\n+\n+\n+            }else {\n+                this.universe = null;\n+                this.accelerator=null;\n+                this.clWrapComputeContext = new CLWrapComputeContext(arena, 20);\n+                this.vel = clWrapComputeContext.register(xyzVelFloatArr.ptr());\n+                this.pos = clWrapComputeContext.register(xyzPosFloatArr.ptr());\n+\n+                var platforms = CLPlatform.platforms(arena);\n+                System.out.println(\"platforms \" + platforms.size());\n+                var platform = platforms.get(0);\n+                platform.devices.forEach(device -> {\n+                    System.out.println(\"   Compute Units     \" + device.computeUnits());\n+                    System.out.println(\"   Device Name       \" + device.deviceName());\n+                    System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n+                    System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+                });\n+                var device = platform.devices.get(0);\n@@ -57,0 +215,1 @@\n+\n@@ -58,37 +217,42 @@\n-            });\n-            var device = platform.devices.get(0);\n-            System.out.println(\"   Compute Units     \" + device.computeUnits());\n-            System.out.println(\"   Device Name       \" + device.deviceName());\n-            System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n-\n-            System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n-            var context = device.createContext();\n-            String code = switch (mode) {\n-                case Mode.OpenCL -> \"\"\"\n-                        __kernel void nbody( __global float *xyzPos ,__global float* xyzVel, float mass, float delT, float espSqr ){\n-                            int body = get_global_id(0);\n-                            int STRIDE=4;\n-                            int Xidx=0;\n-                            int Yidx=1;\n-                            int Zidx=2;\n-                            int bodyStride = body*STRIDE;\n-                            int bodyStrideX = bodyStride+Xidx;\n-                            int bodyStrideY = bodyStride+Yidx;\n-                            int bodyStrideZ = bodyStride+Zidx;\n-\n-                            float accx = 0.0;\n-                            float accy = 0.0;\n-                            float accz = 0.0;\n-                            float myPosx = xyzPos[bodyStrideX];\n-                            float myPosy = xyzPos[bodyStrideY];\n-                            float myPosz = xyzPos[bodyStrideZ];\n-                            for (int i = 0; i < get_global_size(0); i++) {\n-                                int iStride = i*STRIDE;\n-                                float dx = xyzPos[iStride+Xidx] - myPosx;\n-                                float dy = xyzPos[iStride+Yidx] - myPosy;\n-                                float dz = xyzPos[iStride+Zidx] - myPosz;\n-                                float invDist =  (float) 1.0\/sqrt((float)((dx * dx) + (dy * dy) + (dz * dz) + espSqr));\n-                                float s = mass * invDist * invDist * invDist;\n-                                accx = accx + (s * dx);\n-                                accy = accy + (s * dy);\n-                                accz = accz + (s * dz);\n+                var context = device.createContext();\n+                String code = switch (mode) {\n+                    case Mode.OpenCL -> \"\"\"\n+                            __kernel void nbody( __global float *xyzPos ,__global float* xyzVel, float mass, float delT, float espSqr ){\n+                                int body = get_global_id(0);\n+                                int STRIDE=4;\n+                                int Xidx=0;\n+                                int Yidx=1;\n+                                int Zidx=2;\n+                                int bodyStride = body*STRIDE;\n+                                int bodyStrideX = bodyStride+Xidx;\n+                                int bodyStrideY = bodyStride+Yidx;\n+                                int bodyStrideZ = bodyStride+Zidx;\n+\n+                                float accx = 0.0;\n+                                float accy = 0.0;\n+                                float accz = 0.0;\n+                                float myPosx = xyzPos[bodyStrideX];\n+                                float myPosy = xyzPos[bodyStrideY];\n+                                float myPosz = xyzPos[bodyStrideZ];\n+                                for (int i = 0; i < get_global_size(0); i++) {\n+                                    int iStride = i*STRIDE;\n+                                    float dx = xyzPos[iStride+Xidx] - myPosx;\n+                                    float dy = xyzPos[iStride+Yidx] - myPosy;\n+                                    float dz = xyzPos[iStride+Zidx] - myPosz;\n+                                    float invDist =  (float) 1.0\/sqrt((float)((dx * dx) + (dy * dy) + (dz * dz) + espSqr));\n+                                    float s = mass * invDist * invDist * invDist;\n+                                    accx = accx + (s * dx);\n+                                    accy = accy + (s * dy);\n+                                    accz = accz + (s * dz);\n+                                }\n+                                accx = accx * delT;\n+                                accy = accy * delT;\n+                                accz = accz * delT;\n+                                xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * 0.5 * delT);\n+                                xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * 0.5 * delT);\n+                                xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * 0.5 * delT);\n+\n+                                xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n+                                xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n+                                xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n+\n@@ -96,6 +260,17 @@\n-                            accx = accx * delT;\n-                            accy = accy * delT;\n-                            accz = accz * delT;\n-                            xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * 0.5 * delT);\n-                            xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * 0.5 * delT);\n-                            xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * 0.5 * delT);\n+                            \"\"\";\n+                   \/* case Mode.OpenCL4 -> \"\"\"\n+                            __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n+                                float4 acc = (0.0,0.0,0.0,0.0);\n+                                float4 myPos = xyzPos[get_global_id(0)];\n+                                float4 myVel = xyzVel[get_global_id(0)];\n+                                for (int i = 0; i < get_global_size(0); i++) {\n+                                       float4 delta =  xyzPos[i] - myPos;\n+                                       float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n+                                       float s = mass * invDist * invDist * invDist;\n+                                       acc= acc + (s * delta);\n+                                }\n+                                acc = acc*delT;\n+                                myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n+                                myVel = myVel + acc;\n+                                xyzPos[get_global_id(0)] = myPos;\n+                                xyzVel[get_global_id(0)] = myVel;\n@@ -103,3 +278,18 @@\n-                            xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n-                            xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n-                            xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n+                            }\n+                            \"\"\";*\/\n+                    case Mode.OpenCL4 -> \"\"\"\n+                            __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n+                                float4 acc = (0.0,0.0,0.0,0.0);\n+                                float4 myPos = xyzPos[get_global_id(0)];\n+                                float4 myVel = xyzVel[get_global_id(0)];\n+                                for (int i = 0; i < get_global_size(0); i++) {\n+                                       float4 delta =  xyzPos[i] - myPos;\n+                                       float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n+                                       float s = mass * invDist * invDist * invDist;\n+                                       acc= acc + (s * delta);\n+                                }\n+                                acc = acc*delT;\n+                                myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n+                                myVel = myVel + acc;\n+                                xyzPos[get_global_id(0)] = myPos;\n+                                xyzVel[get_global_id(0)] = myVel;\n@@ -107,12 +297,0 @@\n-                        }\n-                        \"\"\";\n-                case Mode.OpenCL4 -> \"\"\"\n-                        __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n-                            float4 acc = (0.0,0.0,0.0,0.0);\n-                            float4 myPos = xyzPos[get_global_id(0)];\n-                            float4 myVel = xyzVel[get_global_id(0)];\n-                            for (int i = 0; i < get_global_size(0); i++) {\n-                                   float4 delta =  xyzPos[i] - myPos;\n-                                   float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n-                                   float s = mass * invDist * invDist * invDist;\n-                                   acc= acc + (s * delta);\n@@ -120,5 +298,44 @@\n-                            acc = acc*delT;\n-                            myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n-                            myVel = myVel + acc;\n-                            xyzPos[get_global_id(0)] = myPos;\n-                            xyzVel[get_global_id(0)] = myVel;\n+                            \"\"\";\n+                    default -> throw new IllegalStateException();\n+                };\n+                var program = context.buildProgram(code);\n+                kernel = program.getKernel(\"nbody\");\n+            }\n+        }\n+        @Override\n+        public void display() {\n+            if (mode.equals(Mode.HAT)) {\n+                moveBodies();\n+                glClearColor(0f, 0f, 0f, 0f);\n+                glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n+                glEnable(GL_TEXTURE_2D()); \/\/ Annoyingly important,\n+                glBindTexture(GL_TEXTURE_2D(), textureBuf.get(particle.idx));\n+\n+                glPushMatrix1(() -> {\n+                    glScalef(.01f, .01f, .01f);\n+                    glColor3f(1f, 1f, 1f);\n+                    glQuads(() -> {\n+                        for (int bodyIdx = 0; bodyIdx < bodyCount; bodyIdx++) {\n+                            var bodyf4 = universe.body(bodyIdx);\/\/xyzPosFloatArr.get(bodyIdx);\n+\n+                            \/*\n+                             * Textures are mapped to a quad by defining the vertices in\n+                             * the order SW,NW,NE,SE\n+                             &\n+                             *   2--->3\n+                             *   ^    |\n+                             *   |    v\n+                             *   1    4\n+                             *\n+                             * Here we are describing the 'texture plane' for the body.\n+                             * Ideally we need to rotate this to point to the camera (see billboarding)\n+                             *\/\n+\n+                            glTexCoord2f(WEST, SOUTH);\n+                            glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n+                            glTexCoord2f(WEST, NORTH);\n+                            glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n+                            glTexCoord2f(EAST, NORTH);\n+                            glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n+                            glTexCoord2f(EAST, SOUTH);\n+                            glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n@@ -127,5 +344,26 @@\n-                        \"\"\";\n-                default -> throw new IllegalStateException();\n-            };\n-            var program = context.buildProgram(code);\n-            kernel = program.getKernel(\"nbody\");\n+                    });\n+                });\n+\n+                glDisable(GL_TEXTURE_2D()); \/\/ Annoyingly important .. took two days to work that out\n+                \/\/glUseProgram(0);\n+                glMatrixMode(GL_MODELVIEW());\n+                glPushMatrix1(() -> {\n+                    glColor3f(0.0f, 1.0f, 0.0f);\n+                    var font = glutBitmapTimesRoman24$segment();\n+                    long elapsed = System.currentTimeMillis() - startTime;\n+                    float secs = elapsed \/ 1000f;\n+                    var FPS = \"Mode: \"+mode.toString()+\" Bodies \"+bodyCount+\" FPS: \"+((frameCount \/ secs));\n+                    \/\/ System.out.print(\" gw \"+glutGet(GLUT_SCREEN_WIDTH())+\" gh \"+glutGet(GLUT_SCREEN_HEIGHT()));\n+                    \/\/ System.out.print(\" a \"+aspect+\",s \"+size);\n+                    \/\/ System.out.println(\" w \"+width+\" h\"+height);\n+\n+                    glRasterPos2f(-.8f, .7f);\n+                    for (int c : FPS.getBytes()) {\n+                        glutBitmapCharacter(font, c);\n+                    }\n+                });\n+                glutSwapBuffers();\n+                frameCount++;\n+            }else{\n+                super.display();\n+            }\n@@ -137,1 +375,7 @@\n-            if (mode.equals(Mode.OpenCL4) || mode.equals(Mode.OpenCL)) {\n+            if (mode.equals(Mode.HAT)) {\n+                float cmass = mass;\n+                float cdelT = delT;\n+                float cespSqr = espSqr;\n+                Universe cuniverse = universe;\n+                accelerator.compute(cc -> nbodyCompute(cc, cuniverse, cmass, cdelT, cespSqr));\n+            }else if (mode.equals(Mode.OpenCL4) || mode.equals(Mode.OpenCL)) {\n@@ -148,1 +392,1 @@\n-                kernel.run(CLWrapComputeContext, bodyCount, pos, vel, mass, delT, espSqr);\n+                kernel.run(clWrapComputeContext, bodyCount, pos, vel, mass, delT, espSqr);\n@@ -157,1 +401,1 @@\n-        NBodyGLWindow.Mode mode = NBodyGLWindow.Mode.of(args.length > 3 ? args[3] : NBodyGLWindow.Mode.OpenCL.toString());\n+        NBodyGLWindow.Mode mode = NBodyGLWindow.Mode.of(args.length > 3 ? args[3] : NBodyGLWindow.Mode.OpenCL4.toString());\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/opencl\/NBody.java","additions":326,"deletions":82,"binary":false,"changes":408,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        SegmentMapper.BufferState.of(this).setHostDirty();\n+        SegmentMapper.BufferState.of(this).setHostDirty(true);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -405,0 +405,4 @@\n+        static final VarHandle vendorPtr = stateMemoryLayout.varHandle(\n+                MemoryLayout.PathElement.groupElement(\"vendorPtr\")\n+        );\n+\n@@ -427,2 +431,6 @@\n-        public BufferState orBits(int bits) {\n-            BufferState.bits.set(segment, paddedSize, getBits()|bits);\n+        public BufferState and(int bitz) {\n+            BufferState.bits.set(segment, paddedSize, getBits()&bitz);\n+            return this;\n+        }\n+        public BufferState or(int bitz) {\n+            BufferState.bits.set(segment, paddedSize, getBits()|bitz);\n@@ -431,4 +439,5 @@\n-        public BufferState resetBits(int bits) {\n-            int bitz = getBits();   \/\/ say bits = 0b0111 (7) and bitz = 0b0100 (4)\n-            int xored = bits^bitz;  \/\/ xored = 0b0011 (3)\n-            BufferState.bits.set(segment, paddedSize, xored);\n+\n+        public BufferState xor(int bitz) {\n+             \/\/ if getBits() = 0b0111 (7) and bitz = 0b0100 (4) xored = 0x0011 3\n+             \/\/ if getBits() = 0b0011 (3) and bitz = 0b0100 (4) xored = 0x0111 7\n+            BufferState.bits.set(segment, paddedSize, getBits()^bitz);\n@@ -438,0 +447,8 @@\n+        public BufferState andNot(int bitz) {\n+            \/\/ if getBits() = 0b0111 (7) and bitz = 0b0100 (4) andNot = 0b0111 & 0b1011 = 0x0011 3\n+            \/\/ if getBits() = 0b0011 (3) and bitz = 0b0100 (4) andNot = 0b0011 & 0b1011 = 0x0011 3\n+            BufferState.bits.set(segment, paddedSize, getBits()&~bitz);\n+            return this;\n+        }\n+\n+\n@@ -441,2 +458,4 @@\n-        public boolean testAllBitsAreSet(int bits) {\n-            return (getBits()&bits)==bits;\n+        public MemorySegment getVendorPtr(){return (MemorySegment) BufferState.vendorPtr.get(segment, paddedSize);}\n+        public void setVendorPtr(MemorySegment vendorPtr){BufferState.vendorPtr.set(segment, paddedSize,vendorPtr);}\n+        public boolean all(int bitz) {\n+            return (getBits()&bitz)==bitz;\n@@ -444,2 +463,18 @@\n-        public boolean testAnyBitsAreSet(int bits) {\n-            return (getBits()&bits)!=0;\n+        public boolean any(int bitz) {\n+            return (getBits()&bitz)!=0;\n+        }\n+        public BufferState setHostDirty(boolean dirty) {\n+            if (dirty){\n+                or(BIT_HOST_DIRTY);\n+            }else{\n+                andNot(BIT_HOST_DIRTY);\n+            }\n+            return this;\n+        }\n+        public BufferState setDeviceDirty(boolean dirty) {\n+            if (dirty){\n+                or(BIT_DEVICE_DIRTY);\n+            }else{\n+                andNot(BIT_DEVICE_DIRTY); \/\/ this is wrong we want bits&=!BIT_DEVICE_DIRTY\n+            }\n+            return this;\n@@ -447,1 +482,0 @@\n-\n@@ -449,1 +483,1 @@\n-            return testAllBitsAreSet(BIT_HOST_NEW);\n+            return all(BIT_HOST_NEW);\n@@ -452,1 +486,1 @@\n-            return testAllBitsAreSet(BIT_HOST_DIRTY);\n+            return all(BIT_HOST_DIRTY);\n@@ -455,1 +489,1 @@\n-            return testAllBitsAreSet(BIT_HOST_NEW|BIT_HOST_DIRTY);\n+            return all(BIT_HOST_NEW|BIT_HOST_DIRTY);\n@@ -458,1 +492,1 @@\n-            return testAllBitsAreSet(BIT_DEVICE_DIRTY);\n+            return all(BIT_DEVICE_DIRTY);\n@@ -461,1 +495,1 @@\n-            return resetBits(BIT_DEVICE_DIRTY);\n+            return xor(BIT_DEVICE_DIRTY);\n@@ -464,1 +498,1 @@\n-            return resetBits(BIT_HOST_DIRTY);\n+            return xor(BIT_HOST_DIRTY);\n@@ -467,1 +501,1 @@\n-            return resetBits(BIT_HOST_NEW);\n+            return xor(BIT_HOST_NEW);\n@@ -470,1 +504,0 @@\n-\n@@ -495,1 +528,1 @@\n-                if (testAllBitsAreSet(BIT_HOST_DIRTY)){\n+                if (all(BIT_HOST_DIRTY)){\n@@ -498,1 +531,1 @@\n-                if (testAllBitsAreSet(BIT_DEVICE_DIRTY)){\n+                if (all(BIT_DEVICE_DIRTY)){\n@@ -501,1 +534,1 @@\n-                if (testAllBitsAreSet(BIT_HOST_NEW)){\n+                if (all(BIT_HOST_NEW)){\n@@ -504,0 +537,2 @@\n+                var vendorPtr = getVendorPtr();\n+                builder.append(\",\").append(\"VENDOR_PTR:\").append(Long.toHexString(vendorPtr.address()));\n@@ -513,2 +548,1 @@\n-        public void setHostDirty() {\n-        }\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":58,"deletions":24,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_X\" project-jdk-name=\"24-ea\" project-jdk-type=\"JavaSDK\">\n+  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_X\" project-jdk-name=\"24-ea (2)\" project-jdk-type=\"JavaSDK\">\n","filename":"hat\/intellij\/.idea\/misc.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -21,0 +21,1 @@\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n","filename":"hat\/intellij\/clwrap.iml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -17,0 +17,1 @@\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_opencl\" \/>\n","filename":"hat\/intellij\/life.iml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.buffer.Buffer;\n+import hat.ifacemapper.SegmentMapper;\n@@ -37,1 +39,10 @@\n-import static opencl.opencl_h.*;\n+import static opencl.opencl_h.CL_DEVICE_BUILT_IN_KERNELS;\n+import static opencl.opencl_h.CL_DEVICE_MAX_COMPUTE_UNITS;\n+import static opencl.opencl_h.CL_DEVICE_NAME;\n+import static opencl.opencl_h.CL_DEVICE_TYPE_ALL;\n+import static opencl.opencl_h.CL_DEVICE_VENDOR;\n+import static opencl.opencl_h.CL_MEM_READ_WRITE;\n+import static opencl.opencl_h.CL_MEM_USE_HOST_PTR;\n+import static opencl.opencl_h.CL_PROGRAM_BUILD_LOG;\n+import static opencl.opencl_h.CL_QUEUE_PROFILING_ENABLE;\n+import static opencl.opencl_h.CL_SUCCESS;\n@@ -44,1 +55,1 @@\n-        var platformc = arenaWrapper.intPtr( 0);\n+        var platformc = arenaWrapper.intPtr(0);\n@@ -48,1 +59,1 @@\n-            var platformIds = arenaWrapper.ptrArr( platformc.get());\n+            var platformIds = arenaWrapper.ptrArr(platformc.get());\n@@ -92,0 +103,1 @@\n+\n@@ -197,1 +209,1 @@\n-                                    memorySegmentState.clMemPtr = CLWrapComputeContext.ClMemPtr.of(arena(),opencl_h.clCreateBuffer(program.context.context,\n+                                    memorySegmentState.clMemPtr = CLWrapComputeContext.ClMemPtr.of(arena(), opencl_h.clCreateBuffer(program.context.context,\n@@ -205,1 +217,1 @@\n-                                      }\n+                                }\n@@ -226,0 +238,40 @@\n+                            } else if (args[i] instanceof Buffer buffer) {\n+                                \/\/  System.out.println(\"Arg \"+i+\" is a buffer so checking if we need to write\");\n+                                SegmentMapper.BufferState bufferState = SegmentMapper.BufferState.of(buffer);\n+\n+                                \/\/System.out.println(\"Before possible write\"+ bufferState);\n+                                MemorySegment memorySegment = Buffer.getMemorySegment(buffer);\n+\n+                                CLWrapComputeContext.ClMemPtr clmem = clWrapComputeContext.clMemMap.computeIfAbsent(memorySegment, k ->\n+                                        CLWrapComputeContext.ClMemPtr.of(arena(), opencl_h.clCreateBuffer(program.context.context,\n+                                                CL_MEM_USE_HOST_PTR() | CL_MEM_READ_WRITE(),\n+                                                memorySegment.byteSize(),\n+                                                memorySegment,\n+                                                status.ptr()))\n+                                );\n+                                if (bufferState.isHostDirty()) {\n+\n+                                    \/\/System.out.println(\"arg \" + args[i] + \" isHostDirty copying in\");\n+                                    status.set(opencl_h.clEnqueueWriteBuffer(program.context.queue,\n+                                            clmem.get(),\n+                                            clWrapComputeContext.blockInt(),\n+                                            0,\n+                                            memorySegment.byteSize(),\n+                                            memorySegment,\n+                                            clWrapComputeContext.eventc(),\n+                                            clWrapComputeContext.eventsPtr(),\n+                                            clWrapComputeContext.nextEventPtrSlot()\n+                                    ));\n+                                    if (!status.isOK()) {\n+                                        System.out.println(\"failed to enqueue write \" + status);\n+                                    }\n+                                } else {\n+\n+                                    \/\/  System.out.println(\"arg \"+args[i]+\" is not HostDirty not copying in\");\n+                                }\n+                                \/\/     System.out.println(\"After possible write \"+ bufferState);\n+                                status.set(opencl_h.clSetKernelArg(kernel, i, clmem.sizeof(), clmem.ptr()));\n+                                if (!status.isOK()) {\n+                                    System.out.println(\"failed to set arg \" + status);\n+                                }\n+\n@@ -249,3 +301,3 @@\n-                                clWrapComputeContext.eventc(),\n-                                clWrapComputeContext.eventsPtr(),\n-                                clWrapComputeContext.nextEventPtrSlot()\n+                                        clWrapComputeContext.eventc(),\n+                                        clWrapComputeContext.eventsPtr(),\n+                                        clWrapComputeContext.nextEventPtrSlot()\n@@ -279,0 +331,25 @@\n+                            } else if (args[i] instanceof Buffer buffer) {\n+                                \/\/   System.out.println(\"Arg \"+i+\" is a buffer so checking if we need to read\");\n+                                SegmentMapper.BufferState bufferState = SegmentMapper.BufferState.of(buffer);\n+                                MemorySegment memorySegment = Buffer.getMemorySegment(buffer);\n+                                CLWrapComputeContext.ClMemPtr clmem = clWrapComputeContext.clMemMap.get(memorySegment);\n+                                \/\/ System.out.println(\"Before possible read \"+ bufferState);\n+                                if (bufferState.isDeviceDirty()) {\n+                                  \/\/  System.out.println(\"arg \" + args[i] + \" isDeviceDirty copying out\");\n+                                    status.set(opencl_h.clEnqueueReadBuffer(program.context.queue,\n+                                            clmem.get(),\n+                                            clWrapComputeContext.blockInt(),\n+                                            0,\n+                                            memorySegment.byteSize(),\n+                                            memorySegment,\n+                                            clWrapComputeContext.eventc(),\n+                                            clWrapComputeContext.eventsPtr(),\n+                                            clWrapComputeContext.nextEventPtrSlot()\n+                                    ));\n+                                    if (!status.isOK()) {\n+                                        System.out.println(\"failed to enqueue read \" + status);\n+                                    }\n+                                } else {\n+                                    \/\/   System.out.println(\"arg \"+args[i]+\" isnot DeviceDirty not copying out\");\n+                                }\n+\n@@ -358,1 +435,1 @@\n-        var devicec = intPtr( 0);\n+        var devicec = intPtr(0);\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/CLPlatform.java","additions":86,"deletions":9,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+\n@@ -131,0 +132,2 @@\n+    public final Map<MemorySegment, CLWrapComputeContext.ClMemPtr> clMemMap = new HashMap<>();\n+\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/CLWrapComputeContext.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-    public Object get(int idx) {\n-        return varHandle.get(memorySegment, 0, (long) idx);\n+    public Object get(long idx) {\n+        return varHandle.get(memorySegment, 0,  idx);\n@@ -58,1 +58,1 @@\n-    public byte i8(int idx) {\n+    public byte i8(long idx) {\n@@ -62,1 +62,1 @@\n-    public short i16(int idx) {\n+    public short i16(long idx ) {\n@@ -66,1 +66,1 @@\n-    public int i32(int idx) {\n+    public int i32(long idx ) {\n@@ -70,1 +70,1 @@\n-    public long i64(int idx) {\n+    public long i64(long idx ) {\n@@ -74,1 +74,1 @@\n-    public float f32(int idx) {\n+    public float f32(long idx ) {\n@@ -78,1 +78,1 @@\n-    public double f64(int idx) {\n+    public double f64(long idx ) {\n@@ -82,2 +82,2 @@\n-    public Sequence set(int idx, byte v) {\n-        varHandle.set(memorySegment, 0, (long) idx, v);\n+    public Sequence set(long idx , byte v) {\n+        varHandle.set(memorySegment, 0,  idx, v);\n","filename":"hat\/wrap\/wrap\/src\/main\/java\/wrap\/Sequence.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}