{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import hat.ifacemapper.Schema;\n@@ -49,9 +50,0 @@\n-        static MockConfig create(BufferAllocator bufferAllocator, MethodHandles.Lookup lookup, boolean gpu) {\n-            MockConfig config = bufferAllocator.allocate(SegmentMapper.of(lookup, MockConfig.class,\n-                    JAVA_BOOLEAN.withName(\"gpu\"),\n-                    JAVA_BOOLEAN.withName(\"junk\")\n-            ));\n-            config.gpu(gpu);\n-            return config;\n-        }\n-\n@@ -65,0 +57,9 @@\n+\n+        Schema<MockConfig> schema = Schema.of(MockConfig.class, s->s.fields(\"gpu\", \"junk\"));\n+        static MockConfig create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, boolean gpu) {\n+            MockConfig config =schema.allocate(lookup,bufferAllocator);\n+            config.gpu(gpu);\n+            return config;\n+        }\n+\n+\n@@ -69,1 +70,1 @@\n-        getBackend(MockConfig.create(this, MethodHandles.lookup(), true));\n+        getBackend(MockConfig.create(MethodHandles.lookup(),this,  true));\n","filename":"hat\/backends\/mock\/src\/main\/java\/hat\/backend\/MockBackend.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import hat.ifacemapper.Schema;\n@@ -47,1 +48,1 @@\n-        \/\/         boolean junk;\n+        \/\/         boolean verbose;\n@@ -49,9 +50,0 @@\n-        static OpenCLConfig create(BufferAllocator bufferAllocator, MethodHandles.Lookup lookup, boolean gpu) {\n-            OpenCLConfig config = bufferAllocator.allocate(SegmentMapper.of(lookup, OpenCLConfig.class,\n-                    JAVA_BOOLEAN.withName(\"gpu\"),\n-                    JAVA_BOOLEAN.withName(\"junk\")\n-            ));\n-            config.gpu(gpu);\n-            return config;\n-        }\n-\n@@ -62,1 +54,12 @@\n-        boolean junk();\n+      \/\/  boolean verbose();\n+\n+       \/\/ void verbose(boolean verbose);\n+        Schema<OpenCLConfig> schema = Schema.of(OpenCLConfig.class, s->s.fields(\"gpu\"));\n+\n+        static OpenCLConfig create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, boolean gpu, boolean verbose) {\n+            OpenCLConfig config =schema.allocate(lookup,bufferAllocator);\n+            config.gpu(gpu);\n+         \/\/   config.verbose(verbose);\n+            return config;\n+        }\n+\n@@ -64,1 +67,0 @@\n-        void junk(boolean junk);\n@@ -69,1 +71,1 @@\n-        getBackend(OpenCLConfig.create(this, MethodHandles.lookup(), true));\n+        getBackend(OpenCLConfig.create( MethodHandles.lookup(),this, true, true));\n","filename":"hat\/backends\/opencl\/src\/main\/java\/hat\/backend\/OpenCLBackend.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -163,63 +163,37 @@\n- static Cascade create(BufferAllocator bufferAllocator, XMLHaarCascadeModel haarCascade) {\n-\n-        Cascade cascade = bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), Cascade.class,\n-                JAVA_INT.withName(\"width\"),\n-                JAVA_INT.withName(\"height\"),\n-                JAVA_INT.withName(\"featureCount\"),\n-                sequenceLayout(haarCascade.features.size(), Feature.layout.withName(Feature.class.getSimpleName())).withName(\"feature\"),\n-                JAVA_INT.withName(\"stageCount\"),\n-                sequenceLayout(haarCascade.stages.size(), Stage.layout.withName(Stage.class.getSimpleName())).withName(\"stage\"),\n-                JAVA_INT.withName(\"treeCount\"),\n-                sequenceLayout(haarCascade.trees.size(), Tree.layout.withName(Tree.class.getSimpleName())).withName(\"tree\")\n-        ));\n-        cascade.width(haarCascade.width());\n-        cascade.height(haarCascade.height());\n-        cascade.featureCount(haarCascade.features.size());\n-        cascade.stageCount(haarCascade.stages.size());\n-        cascade.treeCount(haarCascade.trees.size());\n-        for (int idx = 0; idx < haarCascade.features.size(); idx++) {\n-            Cascade.Feature cascadeFeature = cascade.feature(idx);\n-            var haarfeature = haarCascade.features.get(idx);\n-            cascadeFeature.id(haarfeature.id());\n-            cascadeFeature.threshold(haarfeature.threshold());\n-            Cascade.Feature.LinkOrValue cascadeLeft = cascadeFeature.left();\n-            cascadeLeft.hasValue(haarfeature.left.hasValue());\n-            if (haarfeature.left.hasValue()) {\n-                cascadeLeft.anon().value(haarfeature.left.value());\n-            } else {\n-                cascadeLeft.anon().value(haarfeature.left.featureId());\n-            }\n-            Cascade.Feature.LinkOrValue cascadeRight = cascadeFeature.right();\n-            cascadeRight.hasValue(haarfeature.right.hasValue());\n-            if (haarfeature.right.hasValue()) {\n-                cascadeRight.anon().value(haarfeature.right.value());\n-            } else {\n-                cascadeRight.anon().featureId(haarfeature.right.featureId());\n-            }\n-            for (int r = 0; r < 3; r++) {\n-                var haarrect = haarfeature.rects[r];\n-                if (haarrect != null) {\n-                    Cascade.Feature.Rect cascadeRect = cascadeFeature.rect(r);\n-                    cascadeRect.x(haarrect.x());\n-                    cascadeRect.y(haarrect.y());\n-                    cascadeRect.width(haarrect.width());\n-                    cascadeRect.height(haarrect.height());\n-                    cascadeRect.weight(haarrect.weight());\n-                }\n-            }\n-        }\n-        for (XMLHaarCascadeModel.Stage haarstage : haarCascade.stages) {\n-            Cascade.Stage cascadeStage = cascade.stage(haarstage.id);\n-            cascadeStage.id(haarstage.id());\n-            cascadeStage.threshold(haarstage.threshold());\n-            cascadeStage.firstTreeId(haarstage.firstTreeId());\n-            cascadeStage.treeCount(haarstage.treeCount());\n-        }\n-\n-        for (XMLHaarCascadeModel.Tree haarTree : haarCascade.trees) {\n-            Cascade.Tree cascadeTree = cascade.tree(haarTree.id());\n-            cascadeTree.id(haarTree.id());\n-            cascadeTree.firstFeatureId(haarTree.firstFeatureId());\n-            cascadeTree.featureCount(haarTree.featureCount());\n-        }\n-        return cascade;\n+ import java.lang.invoke.MethodHandles;\n+\n+static Cascade create(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator, XMLHaarCascadeModel haarCascade) {\n+\n+  Cascade cascade = bufferAllocator.allocate(SegmentMapper.of(lookup, Cascade.class,\n+          JAVA_INT.withName(\"width\"),\n+          JAVA_INT.withName(\"height\"),\n+          JAVA_INT.withName(\"featureCount\"),\n+          sequenceLayout(haarCascade.features.size(), Feature.layout.withName(Feature.class.getSimpleName())).withName(\"feature\"),\n+          JAVA_INT.withName(\"stageCount\"),\n+          sequenceLayout(haarCascade.stages.size(), Stage.layout.withName(Stage.class.getSimpleName())).withName(\"stage\"),\n+          JAVA_INT.withName(\"treeCount\"),\n+          sequenceLayout(haarCascade.trees.size(), Tree.layout.withName(Tree.class.getSimpleName())).withName(\"tree\")\n+  ));\n+  cascade.width(haarCascade.width());\n+  cascade.height(haarCascade.height());\n+  cascade.featureCount(haarCascade.features.size());\n+  cascade.stageCount(haarCascade.stages.size());\n+  cascade.treeCount(haarCascade.trees.size());\n+  for (int idx = 0; idx < haarCascade.features.size(); idx++) {\n+    Cascade.Feature cascadeFeature = cascade.feature(idx);\n+    var haarfeature = haarCascade.features.get(idx);\n+    cascadeFeature.id(haarfeature.id());\n+    cascadeFeature.threshold(haarfeature.threshold());\n+    Cascade.Feature.LinkOrValue cascadeLeft = cascadeFeature.left();\n+    cascadeLeft.hasValue(haarfeature.left.hasValue());\n+    if (haarfeature.left.hasValue()) {\n+      cascadeLeft.anon().value(haarfeature.left.value());\n+    } else {\n+      cascadeLeft.anon().value(haarfeature.left.featureId());\n+    }\n+    Cascade.Feature.LinkOrValue cascadeRight = cascadeFeature.right();\n+    cascadeRight.hasValue(haarfeature.right.hasValue());\n+    if (haarfeature.right.hasValue()) {\n+      cascadeRight.anon().value(haarfeature.right.value());\n+    } else {\n+      cascadeRight.anon().featureId(haarfeature.right.featureId());\n@@ -227,0 +201,28 @@\n+    for (int r = 0; r < 3; r++) {\n+      var haarrect = haarfeature.rects[r];\n+      if (haarrect != null) {\n+        Cascade.Feature.Rect cascadeRect = cascadeFeature.rect(r);\n+        cascadeRect.x(haarrect.x());\n+        cascadeRect.y(haarrect.y());\n+        cascadeRect.width(haarrect.width());\n+        cascadeRect.height(haarrect.height());\n+        cascadeRect.weight(haarrect.weight());\n+      }\n+    }\n+  }\n+  for (XMLHaarCascadeModel.Stage haarstage : haarCascade.stages) {\n+    Cascade.Stage cascadeStage = cascade.stage(haarstage.id);\n+    cascadeStage.id(haarstage.id());\n+    cascadeStage.threshold(haarstage.threshold());\n+    cascadeStage.firstTreeId(haarstage.firstTreeId());\n+    cascadeStage.treeCount(haarstage.treeCount());\n+  }\n+\n+  for (XMLHaarCascadeModel.Tree haarTree : haarCascade.trees) {\n+    Cascade.Tree cascadeTree = cascade.tree(haarTree.id());\n+    cascadeTree.id(haarTree.id());\n+    cascadeTree.firstFeatureId(haarTree.firstFeatureId());\n+    cascadeTree.featureCount(haarTree.featureCount());\n+  }\n+  return cascade;\n+}\n","filename":"hat\/docs\/hat-04-02-cascade-interface-mapping.md","additions":65,"deletions":63,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -68,2 +68,1 @@\n-        var a = F32Array.schema.allocate(accelerator, 100);\n-        a.length(100);\n+        var a = F32Array.create(accelerator,100);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ForTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6,0 +6,2 @@\n+import java.lang.foreign.Arena;\n+import java.lang.invoke.MethodHandle;\n@@ -17,0 +19,4 @@\n+import hat.buffer.Buffer;\n+import hat.buffer.BufferAllocator;\n+import hat.ifacemapper.Schema;\n+import hat.ifacemapper.SegmentMapper;\n@@ -38,0 +44,7 @@\n+        BufferAllocator bufferAllocator = new BufferAllocator() {\n+            @Override\n+            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema) {\n+                return segmentMapper.allocate(Arena.global(),boundSchema);\n+            }\n+        };\n+\n@@ -39,1 +52,3 @@\n-        System.out.println(PointyHat.ColoredWeightedPoint.schema.boundSchema().groupLayout);\n+\n+        PointyHat.ColoredWeightedPoint p = PointyHat.ColoredWeightedPoint.schema.allocate(MethodHandles.lookup(),bufferAllocator);\n+        System.out.println(Buffer.getLayout(p));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InvokeToPtr.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -17,25 +17,1 @@\n-        S32Array s32Array = S32Array.schema.allocate(accelerator, 10);\n-        s32Array.length(10);\n-\/*\n-            accelerator.compute(cc->ccargS32Array) -> {\n-                var range = cc.accelerator.range(argS32Array.length());\n-                DispatchArity.KernelSam1<S32Array> kernel = (id, kArgS32Array) -> {\n-                    kArgS32Array.array(id.x, kArgS32Array.array(id.x) * 2);\n-                };\n-                cc.dispatchKernel(kernel, range, s32Array);\n-            }, s32Array);\n-\n-            accelerator.compute((cc, argS32Array) -> {\n-                var range = cc.accelerator.range(argS32Array.length());\n-                cc.dispatchKernel(\n-                        (id, kArgS32Array) -> {\n-                            kArgS32Array.array(id.x, kArgS32Array.array(id.x) * 2);\n-                        }, range, argS32Array);\n-            }, s32Array);\n-\n-            accelerator.compute((cc, argS32Array) ->\n-                            cc.dispatchKernel((id, kArgS32Array) ->\n-                                    kArgS32Array.array(id.x, kArgS32Array.array(id.x) * 2), cc.accelerator.range(argS32Array.length()), argS32Array)\n-                    , s32Array);\n-\n- *\/\n+        S32Array s32Array = S32Array.create(accelerator, 10);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LambdaTest.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.buffer.MappableIface;\n+import hat.ifacemapper.MappableIface;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import hat.buffer.CompleteBuffer;\n@@ -46,1 +45,1 @@\n-    public interface MeshData extends CompleteBuffer {\n+    public interface MeshData extends Buffer {\n@@ -107,3 +106,1 @@\n-        static  MeshData create(BufferAllocator bufferAllocator) {\n-           return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), MeshData.class, getLayout()));\n-        }\n+\n@@ -115,0 +112,3 @@\n+        static  MeshData create(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator) {\n+            return schema.allocate(lookup,bufferAllocator,100,10);\n+        }\n@@ -145,2 +145,2 @@\n-        var meshDataNew = boundSchema.allocate(accelerator);\n-        var meshDataOld = MeshData.create(accelerator);\n+        var meshDataNew = boundSchema.allocate(accelerator.lookup,accelerator);\n+        var meshDataOld = MeshData.create(accelerator.lookup,accelerator);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -8,0 +8,1 @@\n+import hat.buffer.Buffer;\n@@ -11,2 +12,0 @@\n-import hat.buffer.CompleteBuffer;\n-import hat.ifacemapper.HatData;\n@@ -22,1 +21,1 @@\n-    public interface ColoredWeightedPoint extends CompleteBuffer {\n+    public interface ColoredWeightedPoint extends Buffer {\n@@ -75,1 +74,1 @@\n-        static ColoredWeightedPoint create(BufferAllocator bufferAllocator) {\n+        static ColoredWeightedPoint create(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator) {\n@@ -77,4 +76,1 @@\n-            System.out.println(schema.boundSchema().groupLayout);\n-            HatData hatData = new HatData() {\n-            };\n-            return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), ColoredWeightedPoint.class, LAYOUT,hatData));\n+            return schema.allocate(lookup,bufferAllocator);\n@@ -116,1 +112,1 @@\n-        var coloredWeightedPoint = ColoredWeightedPoint.create(accelerator);\n+        var coloredWeightedPoint = ColoredWeightedPoint.create(MethodHandles.lookup(),accelerator);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -8,0 +8,1 @@\n+import hat.buffer.Buffer;\n@@ -11,2 +12,0 @@\n-import hat.buffer.CompleteBuffer;\n-import hat.ifacemapper.HatData;\n@@ -22,1 +21,1 @@\n-    public interface PointArray extends CompleteBuffer {\n+    public interface PointArray extends Buffer {\n@@ -60,1 +59,1 @@\n-        static PointArray create(BufferAllocator bufferAllocator, int len) {\n+        static PointArray create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int len) {\n@@ -62,4 +61,1 @@\n-            System.out.println(schema.boundSchema(100).groupLayout);\n-            HatData hatData = new HatData() {\n-            };\n-            PointArray pointArray = bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), PointArray.class, LAYOUT,hatData));\n+            PointArray pointArray= schema.allocate(lookup,bufferAllocator,100);\n@@ -95,1 +91,1 @@\n-        var pointArray = PointArray.create(accelerator,100);\n+        var pointArray = PointArray.create(accelerator.lookup,accelerator,100);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHatArray.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.buffer.BufferAllocator;\n@@ -30,0 +31,4 @@\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.invoke.MethodHandles;\n@@ -34,5 +39,7 @@\n-        var boundSchema = S08x3RGBImage.schema.boundSchema( 100,100);\n-        System.out.println(boundSchema.groupLayout);\n-        var rgbS08x3Image = boundSchema.allocate(Schema.GlobalArenaAllocator);\n-        rgbS08x3Image.width(100);\n-        rgbS08x3Image.height(100);\n+        BufferAllocator bufferAllocator = new BufferAllocator() {\n+            @Override\n+            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema) {\n+                return segmentMapper.allocate(Arena.global(),boundSchema);\n+            }\n+        };\n+        var rgbS08x3Image = S08x3RGBImage.create(MethodHandles.lookup(), bufferAllocator,100,100);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S08x3ImageTest.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.buffer.BufferAllocator;\n@@ -30,0 +31,5 @@\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n@@ -34,9 +40,7 @@\n-        hat.buffer.S32Array os32  = hat.buffer.S32Array.schema.allocate( 100);\n-        os32.length(100);\n-        System.out.println(\"Layout from hat S32Array \"+ Buffer.getLayout(os32));\n-\n-        var s32Array = S32Array.schema.allocate( 100);\n-       \/\/ Schema.BoundSchema boundSchema = (Schema.BoundSchema)Buffer.getHatData(s32Array);\n-        int s23ArrayLen = s32Array.length();\n-        System.out.println(s23ArrayLen);\n-\n+        BufferAllocator bufferAllocator = new BufferAllocator() {\n+            @Override\n+            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema) {\n+                return segmentMapper.allocate(Arena.global(),boundSchema);\n+            }\n+        };\n+        hat.buffer.S32Array s32Array  = hat.buffer.S32Array.create(MethodHandles.lookup(),bufferAllocator, 100);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32ArrayTest.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -95,6 +95,3 @@\n-        var a = F32Array.schema.allocate(accelerator, 100);\n-        a.length(100);\n-        var b = F32Array.schema.allocate(accelerator, 100);\n-        b.length(100);\n-        var c = F32Array.schema.allocate(accelerator, 100);\n-        c.length(100);\n+        var a = F32Array.create(accelerator, 100);\n+        var b = F32Array.create(accelerator, 100);\n+        var c = F32Array.create(accelerator, 100);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/GetBackend.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -8,0 +8,1 @@\n+import hat.buffer.SchemaBuilder;\n@@ -114,9 +115,4 @@\n-        var a = F32Array.schema.allocate(accelerator, arrA.length);\n-        a.length(arrA.length);\n-        a.copyFrom(arrA);\n-        var b = F32Array.schema.allocate(accelerator, arrB.length);\n-        b.length(arrB.length);\n-        b.copyFrom(arrB);\n-        var c = F32Array.schema.allocate(accelerator, size * size);\n-        c.length(size*size);\n-        System.out.print(c.schema());\n+        var a = F32Array.create(accelerator, arrA.length);\n+        var b = F32Array.create(accelerator, arrB.length);\n+        var c = F32Array.create(accelerator, size * size);\n+        System.out.print(SchemaBuilder.schema(c));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/MatrixMultiply.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -83,3 +83,1 @@\n-        S32Array2D s32Array2D = S32Array2D.schema.allocate(accelerator, width, height);\n-        s32Array2D.width(width);\n-        s32Array2D.height(height);\n+        S32Array2D s32Array2D = S32Array2D.create(accelerator, width, height);\n@@ -101,3 +99,1 @@\n-        S32Array pallette = S32Array.schema.allocate(accelerator, palletteArray.length);\n-        pallette.length(palletteArray.length);\n-        pallette.copyfrom(palletteArray);\n+        S32Array pallette = S32Array.createFrom(accelerator, palletteArray);\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/MandelCompute.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,2 +61,1 @@\n-        var arr = S32Array.schema.allocate(accelerator, 32);\n-        arr.length(32);\n+        var arr = S32Array.create(accelerator, 32);\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Squares.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -52,0 +53,1 @@\n+    final MethodHandles.Lookup lookup;\n@@ -67,1 +69,1 @@\n-        public IntegralWindow(Container container, BufferAllocator bufferAllocator, F32Array2D integralImageF32, F32Array2D integralSqImageF32) {\n+        public IntegralWindow(Container container, MethodHandles.Lookup lookup,BufferAllocator bufferAllocator, F32Array2D integralImageF32, F32Array2D integralSqImageF32) {\n@@ -76,2 +78,2 @@\n-                this.integralImageU16 = U16GreyImage.schema.allocate(bufferAllocator,integral.getWidth(),integral.getHeight());\/\/create(bufferAllocator, integral);\n-                this.integralSqImageU16 = U16GreyImage.schema.allocate(bufferAllocator, integral.getWidth(),integral.getHeight());\n+                this.integralImageU16 = U16GreyImage.create(lookup,bufferAllocator,integral.getWidth(),integral.getHeight());\n+                this.integralSqImageU16 = U16GreyImage.create(lookup,bufferAllocator, integral.getWidth(),integral.getHeight());\n@@ -172,1 +174,2 @@\n-    public HaarViewer(BufferAllocator bufferAllocator,\n+    public HaarViewer(MethodHandles.Lookup lookup,\n+                      BufferAllocator bufferAllocator,\n@@ -180,0 +183,1 @@\n+        this.lookup = lookup;\n@@ -248,1 +252,1 @@\n-        this.integralWindow = new IntegralWindow(this, bufferAllocator, integralImageF32, integralSqImageF32);\n+        this.integralWindow = new IntegralWindow(this,lookup, bufferAllocator, integralImageF32, integralSqImageF32);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/HaarViewer.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -63,6 +63,1 @@\n-        var cascade = Cascade.schema.allocate(\n-                accelerator,\n-                xmlCascade.featureCount(),\n-                xmlCascade.stageCount(),\n-                xmlCascade.treeCount()\n-        ).copyFrom(xmlCascade);\n+        var cascade = Cascade.createFrom(accelerator,xmlCascade);\n@@ -70,5 +65,1 @@\n-        S08x3RGBImage rgbImage = S08x3RGBImage.schema.allocate(accelerator, nasa1996.getWidth(),nasa1996.getHeight());\n-        rgbImage.width(nasa1996.getWidth());\n-        rgbImage.height(nasa1996.getHeight());\n-      \/\/  rgbImage.elementsPerPixel(3);\n-      \/\/  rgbImage.bufferedImageType(BufferedImage.TYPE_INT_RGB);\n+        S08x3RGBImage rgbImage = S08x3RGBImage.create(accelerator, nasa1996.getWidth(),nasa1996.getHeight());\n@@ -76,3 +67,1 @@\n-        ResultTable resultTable = ResultTable.schema.allocate(1000);\n-        resultTable.length(1000);\n-\n+        ResultTable resultTable = ResultTable.create(accelerator,1000);\n@@ -82,1 +71,1 @@\n-            harViz = new HaarViewer(accelerator, nasa1996, rgbImage, cascade, null, null);\n+            harViz = new HaarViewer(accelerator.lookup,accelerator, nasa1996, rgbImage, cascade, null, null);\n@@ -84,4 +73,3 @@\n-        ScaleTable.Constraints constraints = new ScaleTable.Constraints(cascade,rgbImage.width(),rgbImage.height());\n-        ScaleTable scaleTable = ScaleTable.schema.allocate(constraints.scales);\n-        scaleTable.length(constraints.scales);\n-        scaleTable.applyConstraints(constraints);\n+\n+        ScaleTable scaleTable = ScaleTable.createFrom(accelerator,new ScaleTable.Constraints(cascade,rgbImage.width(),rgbImage.height()));\n+\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCompute.java","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -306,4 +306,1 @@\n-        F32Array2D f32Array2D = F32Array2D.schema.allocate(cc, width, height);\n-        f32Array2D.width(width);\n-        f32Array2D.height(height);\n-        return f32Array2D;\n+        return F32Array2D.create(cc.accelerator, width, height);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,10 +57,1 @@\n-        var cascade = Cascade.schema.allocate(accelerator,xmlCascade.featureCount(),xmlCascade.stageCount(),xmlCascade.treeCount()).copyFrom(xmlCascade);\n-\n-        S08x3RGBImage rgbImage = S08x3RGBImage.schema.allocate(accelerator, nasa.getWidth(),nasa.getHeight());\n-        rgbImage.width(nasa.getWidth());\n-        rgbImage.height(nasa.getHeight());\n-       \/\/ rgbImage.elementsPerPixel(3);\n-       \/\/ rgbImage.bufferedImageType(BufferedImage.TYPE_INT_RGB);\n-\n-       \/\/ var rgbImage = RgbS08x3Image.create(accelerator, nasa);\n-\n+        var cascade = Cascade.createFrom(accelerator,xmlCascade);\n@@ -69,2 +60,2 @@\n-        ScaleTable.Constraints constraints = new ScaleTable.Constraints(cascade,width,height);\n-        \/\/ harViz.showIntegrals();\n+        S08x3RGBImage rgbImage = S08x3RGBImage.create(accelerator,width,height);\n+\n@@ -72,3 +63,1 @@\n-        var scaleTable = ScaleTable.schema.allocate(constraints.scales);\n-        scaleTable.length(constraints.scales);\n-        scaleTable.applyConstraints(constraints);\n+        \/\/ harViz.showIntegrals();\n@@ -76,0 +65,1 @@\n+        var scaleTable = ScaleTable.createFrom(accelerator,new ScaleTable.Constraints(cascade,width,height));\n@@ -77,12 +67,0 @@\n-        var greyImageF32 = F32Array2D.schema.allocate(accelerator, width, height);\n-        greyImageF32.width(width);\n-        greyImageF32.height(height);\n-        var integralImageF32 = F32Array2D.schema.allocate(accelerator, width, height);\n-        integralImageF32.width(width);\n-        integralImageF32.height(height);\n-        var integralSqImageF32 = F32Array2D.schema.allocate(accelerator, width, height);\n-        integralSqImageF32.width(width);\n-        integralSqImageF32.height(height);\n-        var resultTable = ResultTable.schema.allocate(accelerator, 1000);\n-        resultTable.length(1000);\n-        resultTable.atomicResultTableCount(0);\n@@ -90,0 +68,4 @@\n+        var greyImageF32 = F32Array2D.create(accelerator, width, height);\n+        var integralImageF32 = F32Array2D.create(accelerator, width, height);\n+        var integralSqImageF32 = F32Array2D.create(accelerator, width, height);\n+        var resultTable = ResultTable.create(accelerator, 1000);\n@@ -93,1 +75,1 @@\n-        HaarViewer harViz = new HaarViewer(accelerator, nasa, rgbImage, cascade, integralImageF32, integralSqImageF32);\n+        HaarViewer harViz = new HaarViewer(accelerator.lookup, accelerator, nasa, rgbImage, cascade, integralImageF32, integralSqImageF32);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/attic\/ViolaJones.java","additions":10,"deletions":28,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.Accelerator;\n+import hat.buffer.BufferAllocator;\n@@ -28,1 +30,1 @@\n-import hat.buffer.CompleteBuffer;\n+import hat.buffer.Buffer;\n@@ -30,1 +32,3 @@\n-public interface Cascade extends CompleteBuffer {\n+import java.lang.invoke.MethodHandles;\n+\n+public interface Cascade extends Buffer {\n@@ -165,0 +169,25 @@\n+    static Cascade create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height,\n+    int features,int stages,int trees){\n+        var instance  = schema.allocate(lookup,\n+                bufferAllocator,\n+                features,\n+                stages,\n+                trees\n+        );\n+        instance.width(width);\n+        instance.height(height);\n+        instance.featureCount(features);\n+        instance.stageCount(stages);\n+        instance.treeCount(trees);\n+        return instance;\n+    }\n+\n+    static Cascade create(Accelerator accelerator, int width, int height,\n+                          int features, int stages, int trees){\n+       return create(accelerator.lookup,accelerator,width,height,features,stages,trees);\n+    }\n+\n+    static Cascade createFrom(Accelerator accelerator, Cascade cascade){\n+        return create(accelerator.lookup,accelerator,cascade.width(),cascade.height(),cascade.featureCount(),cascade.stageCount(),cascade.treeCount()).copyFrom(cascade);\n+    }\n+\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/Cascade.java","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n-import hat.buffer.IncompleteBuffer;\n+import hat.Accelerator;\n+import hat.buffer.Buffer;\n+import hat.buffer.BufferAllocator;\n@@ -30,1 +32,3 @@\n-public interface ResultTable extends IncompleteBuffer  {\n+import java.lang.invoke.MethodHandles;\n+\n+public interface ResultTable extends Buffer {\n@@ -59,1 +63,2 @@\n-            .arrayLen(\"length\").array(\"result\", array->array\n+            .arrayLen(\"length\")\n+            .array(\"result\", array->array\n@@ -63,0 +68,11 @@\n+\n+    static ResultTable create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator,int length){\n+        var instance = schema.allocate(lookup,bufferAllocator,length);\n+        instance.length(length);\n+        instance.atomicResultTableCount(0);\n+        return instance;\n+    }\n+\n+    static ResultTable create(Accelerator accelerator, int length){\n+       return create(accelerator.lookup, accelerator,length);\n+    }\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ResultTable.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-import hat.buffer.IncompleteBuffer;\n+import hat.Accelerator;\n+import hat.buffer.Buffer;\n+import hat.buffer.BufferAllocator;\n@@ -31,1 +33,3 @@\n-public interface ScaleTable extends IncompleteBuffer {\n+import java.lang.invoke.MethodHandles;\n+\n+public interface ScaleTable extends Buffer {\n@@ -111,1 +115,1 @@\n-      default void applyConstraints ( Constraints constraints) {\n+      default ScaleTable applyConstraints ( Constraints constraints) {\n@@ -142,0 +146,1 @@\n+        return this;\n@@ -172,0 +177,15 @@\n+\n+    static ScaleTable create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int length){\n+        var instance = schema.allocate(lookup,bufferAllocator,length);\n+        instance.length(length);\n+        return instance;\n+    }\n+\n+    static ScaleTable create(Accelerator accelerator, int length){\n+        return create(accelerator.lookup, accelerator,length);\n+    }\n+\n+    static ScaleTable createFrom(Accelerator accelerator, Constraints constraints){\n+        return create(accelerator.lookup, accelerator,constraints.scales).applyConstraints(constraints);\n+    }\n+\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ScaleTable.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.ifacemapper.Schema;\n@@ -71,1 +72,1 @@\n-    public final MethodHandles.Lookup lookup;\n+    public MethodHandles.Lookup lookup;\n@@ -73,2 +74,0 @@\n-    private final Map<Method, hat.ComputeContext> cache = new HashMap<>();\n-\n@@ -76,0 +75,1 @@\n+    private final Map<Method, hat.ComputeContext> cache = new HashMap<>();\n@@ -107,2 +107,2 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper) {\n-        return backend.allocate(segmentMapper);\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundShema) {\n+        return backend.allocate(segmentMapper, boundShema);\n","filename":"hat\/hat\/src\/main\/java\/hat\/Accelerator.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+import hat.ifacemapper.Schema;\n@@ -124,2 +125,2 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper) {\n-        return accelerator.allocate(segmentMapper);\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema) {\n+        return accelerator.allocate(segmentMapper, boundSchema);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ComputeContext.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-import hat.buffer.MappableIface;\n+import hat.ifacemapper.MappableIface;\n","filename":"hat\/hat\/src\/main\/java\/hat\/HatPtr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.backend.c99codebuilders.Typedef;\n@@ -35,0 +34,1 @@\n+import hat.ifacemapper.Schema;\n@@ -38,1 +38,1 @@\n-import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n@@ -40,0 +40,1 @@\n+import java.util.Set;\n@@ -53,0 +54,1 @@\n+\n@@ -58,3 +60,3 @@\n-            this.kernelContext =KernelContext.create(c99NativeBackend,0,0);\n-            ndRangeAndArgs[0]=this.kernelContext;\n-            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator, ndRangeAndArgs);\n+            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator.lookup, c99NativeBackend, 0, 0);\n+            ndRangeAndArgs[0] = this.kernelContext;\n+            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator.lookup, kernelCallGraph.computeContext.accelerator, ndRangeAndArgs);\n@@ -65,1 +67,1 @@\n-            args[0]=this.kernelContext;\n+            args[0] = this.kernelContext;\n@@ -75,1 +77,1 @@\n-        Map<String, Typedef> scope = new LinkedHashMap<>();\n+        Set<Schema.SchemaNode.IfaceTypeNode> already = new LinkedHashSet<>();\n@@ -79,1 +81,18 @@\n-                .forEach(ifaceBuffer -> builder.typedef(scope, ifaceBuffer));\n+                .forEach(ifaceBuffer -> {\n+                    Schema.BoundSchema<?> boundSchema = Buffer.getBoundSchema(ifaceBuffer);\n+                    boundSchema.schema.rootIfaceTypeNode.visitTypes(0, t -> {\n+                        if (!already.contains(t)) {\n+                            builder.typedef(boundSchema, t);\n+                            already.add(t);\n+                        }\n+                    });\n+                });\n+\/*\n+            Map<String, Typedef> scope = new LinkedHashMap<>();\n+            Arrays.stream(args)\n+                    .filter(arg -> arg instanceof Buffer)\n+                    .map(arg -> (Buffer) arg)\n+                    .forEach(ifaceBuffer -> builder.typedef(scope, ifaceBuffer));\n+\n+*\/\n+\n@@ -81,1 +100,1 @@\n-        \/\/ The sort below ensures we don't need forward declarations\n+        \/\/ Sorting by rank ensures we don't need forward declarations\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/C99NativeBackend.java","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-import hat.ifacemapper.HatData;\n+import hat.ifacemapper.Schema;\n@@ -157,3 +157,2 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper) {\n-        return segmentMapper.allocate(Arena.global(), new HatData() {\n-        });\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema) {\n+        return segmentMapper.allocate(Arena.global(), boundSchema);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.ifacemapper.HatData;\n+import hat.ifacemapper.Schema;\n@@ -42,3 +42,2 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper){\n-        return segmentMapper.allocate(arena, new HatData() {\n-        });\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema){\n+        return segmentMapper.allocate(arena, boundSchema);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/JavaBackend.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.ifacemapper.HatData;\n+import hat.ifacemapper.Schema;\n@@ -48,3 +48,2 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper){\n-        return segmentMapper.allocate(arena, new HatData() {\n-        });\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> boundSchema){\n+        return segmentMapper.allocate(arena, boundSchema);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeBackend.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.buffer.SchemaBuilder;\n@@ -92,1 +93,1 @@\n-                String schema = backendConfig.schema();\n+                String schema = SchemaBuilder.schema(backendConfig);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeBackendDriver.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ifacemapper.Schema;\n@@ -419,1 +420,1 @@\n-        return typedef(scope, new Typedef(instance));\n+        return typedef(scope, Typedef.of(instance));\n@@ -422,0 +423,1 @@\n+\n@@ -425,0 +427,1 @@\n+\n@@ -442,1 +445,1 @@\n-                                    }else{\n+                                    } else {\n@@ -450,0 +453,2 @@\n+\n+\n@@ -455,2 +460,75 @@\n-    public T atomicInc(C99HatBuildContext buildContext, Op.Result instanceResult, String name){\n-         throw new IllegalStateException(\"atimicInc not implemented\");\n+    public T typedef(Schema.BoundSchema<?> boundSchema,Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n+        typedefKeyword().space().structOrUnion(ifaceTypeNode instanceof Schema.SchemaNode.Struct)\n+                .space().suffix_s(ifaceTypeNode.iface.getSimpleName()).braceNlIndented(_ -> {\n+                    System.out.println(ifaceTypeNode);\n+                    int fieldCount = ifaceTypeNode.fields.size();\n+                    StreamCounter.of(ifaceTypeNode.fields, (c, field) -> {\n+                        nlIf(c.isNotFirst());\n+                        boolean isLast = c.value() == fieldCount - 1;\n+                        if (field instanceof Schema.SchemaNode.PrimitiveNamedFieldNode primitiveField) {\n+                            typeName(primitiveField.type.getSimpleName());\n+                            space().typeName(primitiveField.name);\n+                            if (primitiveField instanceof Schema.SchemaNode.PrimitiveArray array) {\n+                                if (array instanceof Schema.SchemaNode.PrimitiveFieldControlledArray fieldControlledArray) {\n+                                    if (isLast && ifaceTypeNode.parent == null) {\n+                                        sbrace(_ -> literal(1));\n+                                    } else {\n+                                        boolean[] done = new boolean[]{false};\n+                                        boundSchema.arraySizeBindings.forEach(a->{\n+                                            if (a.field.equals(array)){\n+                                                sbrace(_ -> literal(a.len));\n+                                                done[0] = true;\n+                                            }\n+                                            \/\/System.out.println(a);\n+                                        });\n+                                        if (!done[0]) {\n+                                            throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n+                                        }\n+                                    }\n+                                } else if (array instanceof Schema.SchemaNode.PrimitiveFixedArray fixed) {\n+                                    sbrace(_ -> literal(Math.max(1, fixed.len)));\n+                                } else {\n+                                    throw new IllegalStateException(\"what kind of array \");\n+                                }\n+                            }\n+                        } else if (field instanceof Schema.SchemaNode.MapableIfaceNamedFieldNode ifaceField) {\n+                            suffix_t(ifaceField.ifaceTypeNode.iface.getSimpleName());\n+                            space().typeName(ifaceField.name);\n+                            if (ifaceField instanceof Schema.SchemaNode.IfaceMappableArray array) {\n+                                if (array instanceof Schema.SchemaNode.IfaceMapableFieldControlledArray fieldControlledArray) {\n+                                    if (isLast && ifaceTypeNode.parent == null) {\n+                                        sbrace(_ -> literal(1));\n+                                    } else {\n+                                        boolean[] done = new boolean[]{false};\n+                                        boundSchema.arraySizeBindings.forEach(a -> {\n+                                            if (a.field.equals(ifaceField)) {\n+                                                sbrace(_ -> literal(a.len));\n+                                                done[0] = true;\n+                                            }\n+                                            \/\/System.out.println(a);\n+                                        });\n+                                        if (!done[0]) {\n+                                            throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n+                                        }\n+                                    }\n+                                } else if (array instanceof Schema.SchemaNode.IfaceMapableFixedArray fixed) {\n+                                    sbrace(_ -> literal(Math.max(1, fixed.len)));\n+                                } else {\n+                                    throw new IllegalStateException(\"what kind of array \");\n+                                }\n+                            }\n+                        }else if (field instanceof Schema.SchemaNode.Padding){\n+                            \/\/ SKIP\n+                        } else {\n+                            throw new IllegalStateException(\"hmm\");\n+                        }\n+\n+\n+                        semicolon();\n+                    });\n+                }).suffix_t(ifaceTypeNode.iface.getSimpleName()).semicolon().nl().nl();\n+        return self();\n+    }\n+\n+    public T atomicInc(C99HatBuildContext buildContext, Op.Result instanceResult, String name) {\n+        throw new IllegalStateException(\"atimicInc not implemented\");\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatBuilder.java","additions":82,"deletions":4,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-import hat.buffer.IncompleteBuffer;\n+import hat.ifacemapper.Schema;\n@@ -20,0 +20,5 @@\n+import static hat.ifacemapper.MapperUtil.SECRET_BOUND_SCHEMA_METHOD_NAME;\n+import static hat.ifacemapper.MapperUtil.SECRET_LAYOUT_METHOD_NAME;\n+import static hat.ifacemapper.MapperUtil.SECRET_OFFSET_METHOD_NAME;\n+import static hat.ifacemapper.MapperUtil.SECRET_SEGMENT_METHOD_NAME;\n+\n@@ -23,0 +28,1 @@\n+    boolean isIncomplete = false;\n@@ -52,1 +58,1 @@\n-    public static class NameAndType extends AbstractNameAndType {\n+    public static class NameAndType extends Typedef.AbstractNameAndType {\n@@ -58,1 +64,1 @@\n-    public static class NameAndArrayOfType extends AbstractNameAndType {\n+    public static class NameAndArrayOfType extends Typedef.AbstractNameAndType {\n@@ -69,1 +75,0 @@\n-\n@@ -75,1 +80,1 @@\n-    public Typedef(Class<?> iface, MemoryLayout memoryLayout) {\n+    public Typedef(Class<?> iface, MemoryLayout memoryLayout, Schema.BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n@@ -79,0 +84,3 @@\n+      \/\/  if (iface != boundSchema.schema.rootTypeSchemaNode.type) {\n+        \/\/    throw new IllegalStateException(\"bad\");\n+       \/\/ }\n@@ -80,0 +88,1 @@\n+\n@@ -81,0 +90,2 @@\n+\n+            \/\/ This is replicating th schema info\n@@ -87,7 +98,10 @@\n-                if (name.equals(\"id\")) {\n-                    name = name;\n-                }\n-                if (nameToFieldNameAndType.containsKey(name) || name.equals(\"equals\") || name.equals(\"toString\") || name.equals(\"hashCode\")\n-                        || name.equals(\"$_$_$oFfSeT$_$_$\") || name.equals(\"$_$_$sEgMeNt$_$_$\")\n-                        || name.equals(\"$_$_$lAyOuT$_$_$\")\n-                        || name.equals(\"notify\") || name.equals(\"notifyAll\")\n+                if (nameToFieldNameAndType.containsKey(name)\n+                        || name.equals(\"equals\")\n+                        || name.equals(\"toString\")\n+                        || name.equals(\"hashCode\")\n+                        || name.equals(SECRET_OFFSET_METHOD_NAME)\n+                        || name.equals(SECRET_SEGMENT_METHOD_NAME)\n+                        || name.equals(SECRET_LAYOUT_METHOD_NAME)\n+                        || name.equals(SECRET_BOUND_SCHEMA_METHOD_NAME)\n+                        || name.equals(\"notify\")\n+                        || name.equals(\"notifyAll\")\n@@ -105,1 +119,1 @@\n-                            nameToFieldNameAndType.put(name, new NameAndType(this, name, parameterTypes[0]));\n+                            nameToFieldNameAndType.put(name, new Typedef.NameAndType(this, name, parameterTypes[0]));\n@@ -107,1 +121,1 @@\n-                            nameToFieldNameAndType.put(name, new NameAndArrayOfType(this, name, parameterTypes[1], -1));\n+                            nameToFieldNameAndType.put(name, new Typedef.NameAndArrayOfType(this, name, parameterTypes[1], -1));\n@@ -114,1 +128,1 @@\n-                            nameToFieldNameAndType.put(name, new NameAndType(this, name, returnType));\n+                            nameToFieldNameAndType.put(name, new Typedef.NameAndType(this, name, returnType));\n@@ -116,1 +130,1 @@\n-                            nameToFieldNameAndType.put(name, new NameAndArrayOfType(this, name, returnType, -1));\n+                            nameToFieldNameAndType.put(name, new Typedef.NameAndArrayOfType(this, name, returnType, -1));\n@@ -143,1 +157,1 @@\n-                        if (nameAndType instanceof NameAndArrayOfType nameAndArrayOfType) {\n+                        if (nameAndType instanceof Typedef.NameAndArrayOfType nameAndArrayOfType) {\n@@ -161,1 +175,1 @@\n-            if (nameAndTypes.getLast() instanceof NameAndArrayOfType nameAndArrayOfType) {\n+            if (nameAndTypes.getLast() instanceof Typedef.NameAndArrayOfType nameAndArrayOfType) {\n@@ -172,1 +186,1 @@\n-                    nameAndType.typeDef = new Typedef(nameAndType.type, gl);\n+                    nameAndType.typeDef = new Typedef(nameAndType.type, gl, boundSchema, ifaceTypeNode);\n@@ -174,1 +188,1 @@\n-                    nameAndType.typeDef = new Typedef(nameAndType.type, slgl);\n+                    nameAndType.typeDef = new Typedef(nameAndType.type, slgl, boundSchema, ifaceTypeNode);\n@@ -182,2 +196,7 @@\n-    Typedef(Buffer instance) {\n-        this(instance.getClass().getInterfaces()[0], Buffer.getLayout(instance));\n+    private Typedef(Buffer instance, Schema.BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n+        this(instance.getClass().getInterfaces()[0], Buffer.getLayout(instance), boundSchema, ifaceTypeNode);\n+    }\n+\n+    static <T extends Buffer> Typedef of(T instance) {\n+        Schema.BoundSchema<T> boundSchema = (Schema.BoundSchema<T>) Buffer.getBoundSchema(instance);\n+        return new Typedef(instance, boundSchema, boundSchema.schema.rootIfaceTypeNode);\n@@ -187,1 +206,1 @@\n-        return IncompleteBuffer.class.isAssignableFrom(iface);\n+        return isIncomplete;\n@@ -189,0 +208,1 @@\n+\n@@ -190,0 +210,1 @@\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/Typedef.java","additions":44,"deletions":23,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -34,1 +35,1 @@\n-public interface ArgArray extends IncompleteBuffer {\n+public interface ArgArray extends Buffer {\n@@ -268,1 +269,1 @@\n-    static ArgArray create(BufferAllocator bufferAllocator, Object... args) {\n+    static ArgArray create(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator, Object... args) {\n@@ -283,2 +284,1 @@\n-                case CompleteBuffer buffer -> \"(!:\" + buffer.schema()+\")\";\n-                case IncompleteBuffer buffer -> \"(?:\" + buffer.schema()+\")\";\n+                case Buffer buffer -> \"(?:\" +SchemaBuilder.schema(buffer)+\")\";\n@@ -293,1 +293,1 @@\n-        ArgArray argArray = schema.allocate(bufferAllocator,args.length,schemaStr.length() + 1);\n+        ArgArray argArray = schema.allocate(lookup,bufferAllocator,args.length,schemaStr.length() + 1);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-public interface BackendConfig extends CompleteBuffer {\n+public interface BackendConfig extends Buffer {\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/BackendConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n-import hat.ifacemapper.HatData;\n+\n+import hat.ifacemapper.MappableIface;\n+import hat.ifacemapper.Schema;\n@@ -33,1 +35,1 @@\n-import static hat.ifacemapper.MapperUtil.SECRET_HAT_DATA_METHOD_NAME;\n+import static hat.ifacemapper.MapperUtil.SECRET_BOUND_SCHEMA_METHOD_NAME;\n@@ -54,1 +56,1 @@\n-    static <T extends Buffer>HatData getHatData(T buffer) {\n+    static <T extends Buffer> Schema.BoundSchema getBoundSchema(T buffer) {\n@@ -56,1 +58,1 @@\n-            return (HatData) buffer.getClass().getDeclaredMethod(SECRET_HAT_DATA_METHOD_NAME).invoke(buffer);\n+            return (Schema.BoundSchema<?>) buffer.getClass().getDeclaredMethod(SECRET_BOUND_SCHEMA_METHOD_NAME).invoke(buffer);\n@@ -77,1 +79,0 @@\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+import hat.ifacemapper.Schema;\n@@ -6,1 +7,3 @@\n-@FunctionalInterface\n+import java.lang.invoke.MethodHandles;\n+\n+\n@@ -8,1 +11,1 @@\n-    <T extends Buffer>T allocate(SegmentMapper<T> segmentMapper);\n+    <T extends Buffer>T allocate(SegmentMapper<T> segmentMapper, Schema.BoundSchema<T> buffer);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/BufferAllocator.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,14 +0,0 @@\n-package hat.buffer;\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-\n-public interface CompleteBuffer extends Buffer {\n-    default String schema() {\n-        return new SchemaBuilder()\n-                .literal(Buffer.getMemorySegment(this).byteSize())\n-                .hash()\n-                .layout(Buffer.getLayout(this),null, false)\n-                .toString();\n-    }\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/CompleteBuffer.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -36,1 +37,1 @@\n-public interface F32Array extends IncompleteBuffer {\n+public interface F32Array extends Buffer {\n@@ -47,0 +48,8 @@\n+    static F32Array create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int length){\n+        var instance = schema.allocate(lookup,bufferAllocator, length);\n+        instance.length(length);\n+        return instance;\n+    }\n+    static F32Array create(Accelerator accelerator, int length){\n+        return create(accelerator.lookup, accelerator, length);\n+    }\n@@ -51,0 +60,4 @@\n+    static F32Array createFrom(Accelerator accelerator, float[] arr){\n+        return create(accelerator.lookup, accelerator, arr.length).copyFrom(arr);\n+    }\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -35,1 +36,1 @@\n-public interface F32Array2D extends IncompleteBuffer {\n+public interface F32Array2D extends Buffer {\n@@ -40,2 +41,1 @@\n-    Schema<F32Array2D> schema = Schema.of(F32Array2D.class, s32Array->s32Array\n-            .arrayLen(\"width\",\"height\").stride(1).array(\"array\"));\n+\n@@ -54,0 +54,14 @@\n+\n+    Schema<F32Array2D> schema = Schema.of(F32Array2D.class, s32Array->s32Array\n+            .arrayLen(\"width\",\"height\").stride(1).array(\"array\"));\n+\n+    static F32Array2D create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height){\n+        var instance = schema.allocate(lookup,bufferAllocator, width,height);\n+        instance.width(width);\n+        instance.height(height);\n+        return instance;\n+    }\n+    static F32Array2D create(Accelerator accelerator,  int width, int height){\n+        return create(accelerator.lookup, accelerator, width,height);\n+    }\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-public interface ImageIfaceBuffer<T extends ImageIfaceBuffer<?>> extends IncompleteBuffer {\n+public interface ImageIfaceBuffer<T extends ImageIfaceBuffer<?>> extends Buffer {\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ImageIfaceBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,27 +0,0 @@\n-package hat.buffer;\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-\n-public interface IncompleteBuffer extends Buffer {\n-    default String schema() {\n-        MemoryLayout memoryLayout = Buffer.getLayout(this);\n-        if (memoryLayout instanceof StructLayout structLayout) {\n-            var memberLayouts = structLayout.memberLayouts();\n-            if (memberLayouts.getLast() instanceof SequenceLayout tailSequenceLayout) {\n-                return new SchemaBuilder()\n-                        .literal(memoryLayout.byteOffset(\n-                                MemoryLayout.PathElement.groupElement(memberLayouts.size() - 1)))\n-                        .plus()\n-                        .layout(Buffer.getLayout(this),tailSequenceLayout,true)\n-                        .toString();\n-            } else {\n-                throw new IllegalStateException(\"IncompleteBuffer last layout is not SequenceLayout!\");\n-            }\n-        } else {\n-            throw new IllegalStateException(\"IncompleteBuffer must be a StructLayout\");\n-        }\n-\n-    }\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/IncompleteBuffer.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -3,1 +3,1 @@\n-import hat.ifacemapper.HatData;\n+\n@@ -5,1 +5,0 @@\n-import hat.ifacemapper.SegmentMapper;\n@@ -7,3 +6,0 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n@@ -12,1 +8,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -14,1 +9,1 @@\n-public interface KernelContext extends CompleteBuffer {\n+public interface KernelContext extends Buffer {\n@@ -22,2 +17,2 @@\n-    static KernelContext create(BufferAllocator bufferAllocator, int x, int maxX) {\n-        KernelContext kernelContext =  schema.allocate(bufferAllocator);\n+    static KernelContext create(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator, int x, int maxX) {\n+        KernelContext kernelContext =  schema.allocate(lookup,bufferAllocator);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/KernelContext.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,4 +0,0 @@\n-package hat.buffer;\n-\n-public interface MappableIface {\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/MappableIface.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -3,0 +3,1 @@\n+import hat.Accelerator;\n@@ -5,0 +6,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -16,0 +19,10 @@\n+    static S08x3RGBImage create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height){\n+        var instance = schema.allocate(lookup, bufferAllocator,width,height);\n+        instance.width(width);\n+        instance.height(height);\n+        return instance;\n+    }\n+    static S08x3RGBImage create(Accelerator accelerator, int width, int height){\n+        return create(accelerator.lookup,accelerator,width,height);\n+    }\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S08x3RGBImage.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -36,1 +37,1 @@\n-public interface S32Array extends IncompleteBuffer {\n+public interface S32Array extends Buffer {\n@@ -45,0 +46,11 @@\n+    static S32Array create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int length){\n+        var instance = schema.allocate(lookup,bufferAllocator, length);\n+        instance.length(length);\n+        return instance;\n+    }\n+    static S32Array create(Accelerator accelerator, int length){\n+        return create(accelerator.lookup, accelerator, length);\n+    }\n+    static S32Array createFrom(Accelerator accelerator, int[] arr){\n+        return create(accelerator.lookup, accelerator, arr.length).copyfrom(arr);\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -34,1 +35,1 @@\n-public interface S32Array2D extends IncompleteBuffer {\n+public interface S32Array2D extends Buffer {\n@@ -40,2 +41,1 @@\n-    Schema<S32Array2D> schema = Schema.of(S32Array2D.class, s32Array->s32Array\n-            .arrayLen(\"width\",\"height\").stride(1).array(\"array\"));\n+\n@@ -53,0 +53,13 @@\n+    Schema<S32Array2D> schema = Schema.of(S32Array2D.class, s32Array->s32Array\n+            .arrayLen(\"width\",\"height\").stride(1).array(\"array\"));\n+\n+    static S32Array2D create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height){\n+        var instance = schema.allocate(lookup,bufferAllocator, width,height);\n+        instance.width(width);\n+        instance.height(height);\n+        return instance;\n+    }\n+    static S32Array2D create(Accelerator accelerator,  int width, int height){\n+        return create(accelerator.lookup, accelerator, width,height);\n+    }\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32Array2D.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -41,0 +43,8 @@\n+\n+\n+    static S32RGBAImage create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height){\n+        var instance = schema.allocate(lookup, bufferAllocator,width,height);\n+        instance.width(width);\n+        instance.height(height);\n+        return instance;\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32RGBAImage.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-    SchemaBuilder layout(MemoryLayout layout, SequenceLayout tailSequenceLayout, boolean incomplete) {\n+    SchemaBuilder layout(MemoryLayout layout, SequenceLayout tailSequenceLayout) {\n@@ -23,1 +23,1 @@\n-                        layout(l, tailSequenceLayout, incomplete);\n+                        layout(l, tailSequenceLayout);\n@@ -33,1 +33,1 @@\n-                        layout(l, tailSequenceLayout, incomplete);\n+                        layout(l, tailSequenceLayout);\n@@ -45,3 +45,3 @@\n-                    if (sequenceLayout.equals(tailSequenceLayout) && incomplete) {\n-                        asterisk();\n-                    } else {\n+                   \/\/ if (sequenceLayout.equals(tailSequenceLayout) && incomplete) {\n+                     \/\/   asterisk();\n+                    \/\/} else {\n@@ -49,1 +49,1 @@\n-                    }\n+                   \/\/ }\n@@ -51,1 +51,1 @@\n-                    layout(sequenceLayout.elementLayout(), tailSequenceLayout, incomplete);\n+                    layout(sequenceLayout.elementLayout(), tailSequenceLayout);\n@@ -57,0 +57,27 @@\n+\n+    public static String schema(Buffer buffer) {\n+       \/\/ if (complete) {\n+            return new SchemaBuilder()\n+                    .literal(Buffer.getMemorySegment(buffer).byteSize())\n+                    .hash()\n+                    .layout(Buffer.getLayout(buffer), null)\n+                    .toString();\n+    \/*    }else{\n+            MemoryLayout memoryLayout = Buffer.getLayout(buffer);\n+            if (memoryLayout instanceof StructLayout structLayout) {\n+                var memberLayouts = structLayout.memberLayouts();\n+                if (memberLayouts.getLast() instanceof SequenceLayout tailSequenceLayout) {\n+                    return new SchemaBuilder()\n+                            .literal(memoryLayout.byteOffset(\n+                                    MemoryLayout.PathElement.groupElement(memberLayouts.size() - 1)))\n+                            .plus()\n+                            .layout(Buffer.getLayout(buffer),tailSequenceLayout,true)\n+                            .toString();\n+                } else {\n+                    throw new IllegalStateException(\"IncompleteBuffer last layout is not SequenceLayout!\");\n+                }\n+            } else {\n+                throw new IllegalStateException(\"IncompleteBuffer must be a StructLayout\");\n+            }\n+        }*\/\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/SchemaBuilder.java","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -36,0 +38,1 @@\n+\n@@ -39,0 +42,7 @@\n+\n+    static U16GreyImage create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height){\n+        var instance = schema.allocate(lookup, bufferAllocator,width,height);\n+        instance.width(width);\n+        instance.height(height);\n+        return instance;\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/U16GreyImage.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private final HatData hatData;\n+    private final Schema.BoundSchema<?> boundSchema;\n@@ -58,1 +58,1 @@\n-                                    HatData hatData,\n+                                    Schema.BoundSchema<?> boundSchema,\n@@ -60,1 +60,1 @@\n-                                    ValueType valueType, \/\/ This is always ValueType.Interface... !\n+\n@@ -65,1 +65,1 @@\n-        this.hatData = hatData;\n+        this.boundSchema = boundSchema;\n@@ -71,1 +71,1 @@\n-        List<Method> unsupportedAccessors = accessors.stream(k -> !k.isSupportedFor(valueType))\n+     \/*   List<Method> unsupportedAccessors = accessors.stream(k -> !k.isSupportedFor(valueType))\n@@ -77,1 +77,1 @@\n-        }\n+        } *\/\n@@ -91,2 +91,2 @@\n-    public final HatData hatData() {\n-        return hatData;\n+    public final Schema.BoundSchema boundSchema() {\n+        return boundSchema;\n@@ -101,1 +101,1 @@\n-                \"hatData=\" + ((hatData==null)?\"null\":hatData) + \", \" +\n+                \"hatData=\" + ((boundSchema==null)?\"null\":boundSchema) + \", \" +\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/AbstractSegmentMapper.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-import static hat.ifacemapper.MapperUtil.SECRET_HAT_DATA_METHOD_NAME;\n+import static hat.ifacemapper.MapperUtil.SECRET_BOUND_SCHEMA_METHOD_NAME;\n@@ -83,1 +83,1 @@\n-    static final String HAT_DATA_FIELD_NAME = \"boundSchema\";\n+    static final String BOUND_SCHEMA_FIELD_NAME = \"boundSchema\";\n@@ -88,1 +88,1 @@\n-    private static final ClassDesc HAT_DATA_CLASS_DESC = desc(HatData.class);\n+    private static final ClassDesc BOUND_SCHEMA_CLASS_DESC = desc(Schema.BoundSchema.class);\n@@ -124,1 +124,1 @@\n-        cb.withField(HAT_DATA_FIELD_NAME, HAT_DATA_CLASS_DESC, ACC_PRIVATE | ACC_FINAL);\n+        cb.withField(BOUND_SCHEMA_FIELD_NAME, BOUND_SCHEMA_CLASS_DESC, ACC_PRIVATE | ACC_FINAL);\n@@ -133,1 +133,1 @@\n-        final int HAT_DATA_VAR_SLOT = 3;\n+        final int BOUND_SCHEMA_VAR_SLOT = 3;\n@@ -135,1 +135,1 @@\n-        cb.withMethodBody(INIT_NAME, MethodTypeDesc.of(CD_void, MEMORY_SEGMENT_CLASS_DESC, LAYOUT_CLASS_DESC, HAT_DATA_CLASS_DESC, CD_long), ACC_PUBLIC,\n+        cb.withMethodBody(INIT_NAME, MethodTypeDesc.of(CD_void, MEMORY_SEGMENT_CLASS_DESC, LAYOUT_CLASS_DESC, BOUND_SCHEMA_CLASS_DESC, CD_long), ACC_PUBLIC,\n@@ -151,3 +151,3 @@\n-                        .aload(HAT_DATA_VAR_SLOT)\n-                        .checkcast(HAT_DATA_CLASS_DESC)\n-                        .putfield(classDesc, HAT_DATA_FIELD_NAME, HAT_DATA_CLASS_DESC) \/\/ this.boundSchema = boundSchema\n+                        .aload(BOUND_SCHEMA_VAR_SLOT)\n+                        .checkcast(BOUND_SCHEMA_CLASS_DESC)\n+                        .putfield(classDesc, BOUND_SCHEMA_FIELD_NAME, BOUND_SCHEMA_CLASS_DESC) \/\/ this.boundSchema = boundSchema\n@@ -187,1 +187,1 @@\n-        cb.withMethodBody(SECRET_HAT_DATA_METHOD_NAME, MethodTypeDesc.of(HAT_DATA_CLASS_DESC), ACC_PUBLIC, cob ->\n+        cb.withMethodBody(SECRET_BOUND_SCHEMA_METHOD_NAME, MethodTypeDesc.of(BOUND_SCHEMA_CLASS_DESC), ACC_PUBLIC, cob ->\n@@ -189,1 +189,1 @@\n-                        .getfield(classDesc, HAT_DATA_FIELD_NAME, HAT_DATA_CLASS_DESC)\n+                        .getfield(classDesc, BOUND_SCHEMA_FIELD_NAME, BOUND_SCHEMA_CLASS_DESC)\n@@ -278,1 +278,1 @@\n-                            .getfield(classDesc, HAT_DATA_FIELD_NAME, HAT_DATA_CLASS_DESC); \/\/ Layout\n+                            .getfield(classDesc, BOUND_SCHEMA_FIELD_NAME, BOUND_SCHEMA_CLASS_DESC); \/\/ Layout\n@@ -283,1 +283,1 @@\n-                                    LAYOUT_CLASS_DESC,HAT_DATA_CLASS_DESC, CD_long))\n+                                    LAYOUT_CLASS_DESC, BOUND_SCHEMA_CLASS_DESC, CD_long))\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/ByteCodeGenerator.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,4 +0,0 @@\n-package hat.ifacemapper;\n-\n-public interface HatData {\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/HatData.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -0,0 +1,4 @@\n+package hat.ifacemapper;\n+\n+public interface MappableIface {\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/MappableIface.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -65,1 +65,1 @@\n-    public static final String SECRET_HAT_DATA_METHOD_NAME = \"$_$_$hAtDaTa$_$_$\";\n+    public static final String SECRET_BOUND_SCHEMA_METHOD_NAME = \"$_$_$bOuNdScHeMa$_$_$\";\n@@ -107,0 +107,1 @@\n+                        method.getReturnType() == Schema.BoundSchema.class && method.getName().equals(\"boundSchema\") ||\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/MapperUtil.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import hat.ifacemapper.accessor.ValueType;\n@@ -8,1 +9,0 @@\n-import java.lang.foreign.Arena;\n@@ -21,1 +21,1 @@\n-    SchemaNode.TypeSchemaNode schemaRootField;\n+    final public SchemaNode.IfaceTypeNode rootIfaceTypeNode;\n@@ -24,4 +24,4 @@\n-    static abstract sealed class LayoutToBoundFieldTreeNode permits ChildLayoutToBoundFieldTreeNode, BoundSchema {\n-        static class FieldToLayoutBinding<T extends SchemaNode> {\n-            final T field;\n-            MemoryLayout layout;\n+    public static abstract sealed class LayoutToBoundFieldTreeNode permits ChildLayoutToBoundFieldTreeNode, BoundSchema {\n+        static class FieldToLayoutBinding<T extends SchemaNode.FieldNode> {\n+            public final T field;\n+            public MemoryLayout layout;\n@@ -34,5 +34,4 @@\n-        static class FieldControlledArrayBinding extends FieldToLayoutBinding<SchemaNode.FieldControlledArray> {\n-            final int idx;\n-            final int len;\n-\n-            FieldControlledArrayBinding(int idx, int len, SchemaNode.FieldControlledArray fieldControlledArray) {\n+       public  static class FieldControlledArrayBinding extends FieldToLayoutBinding<SchemaNode.FieldNode> {\n+            public final int idx;\n+            public final int len;\n+            FieldControlledArrayBinding(int idx, int len, SchemaNode.FieldNode fieldControlledArray) {\n@@ -56,1 +55,1 @@\n-        abstract FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout);\n+        abstract FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.NamedFieldNode fieldControlledArray, MemoryLayout memoryLayout);\n@@ -58,1 +57,1 @@\n-        void bind(SchemaNode field, MemoryLayout memoryLayout) {\n+        void bind(SchemaNode.FieldNode field, MemoryLayout memoryLayout) {\n@@ -60,1 +59,3 @@\n-            if (field instanceof SchemaNode.FieldControlledArray fieldControlledArray) {\n+            if (field instanceof SchemaNode.IfaceMapableFieldControlledArray fieldControlledArray) {\n+                fieldToLayoutBinding = createFieldControlledArrayBinding(fieldControlledArray, memoryLayout);\n+            }else if (field instanceof SchemaNode.PrimitiveFieldControlledArray fieldControlledArray) {\n@@ -78,0 +79,2 @@\n+\n+\n@@ -81,3 +84,3 @@\n-        final private List<FieldControlledArrayBinding> arraySizeBindings;\n-        final private int[] arrayLengths;\n-        final Schema<T> schema;\n+        final public List<FieldControlledArrayBinding> arraySizeBindings;\n+        final public int[] arrayLengths;\n+        final public Schema<T> schema;\n@@ -92,6 +95,5 @@\n-            schema.schemaRootField.fields.forEach(c -> c.collectLayouts(scope));\n-            MemoryLayout memoryLayout = isUnion(schema.schemaRootField.type)\n-                    ? MemoryLayout.unionLayout(scope.memoryLayoutListToArray())\n-                    : MemoryLayout.structLayout(scope.memoryLayoutListToArray());\n-            bind(schema.schemaRootField, memoryLayout.withName(schema.iface.getSimpleName()));\n-            this.groupLayout = (GroupLayout) memoryLayouts.getFirst();\n+            schema.rootIfaceTypeNode.fields.forEach(c ->\n+                    c.collectLayouts(scope)\n+            );\n+            this.groupLayout = MemoryLayout.structLayout(scope.memoryLayoutListToArray()).withName(schema.iface.getSimpleName());\n+            memoryLayouts.add(this.groupLayout);\n@@ -100,2 +102,2 @@\n-        public T allocate(BufferAllocator bufferAllocator) {\n-            return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), schema.iface, groupLayout));\n+        public T allocate(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator) {\n+            return bufferAllocator.allocate(SegmentMapper.of(lookup, schema.iface,groupLayout, this),this);\n@@ -109,1 +111,2 @@\n-        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout) {\n+        @Override\n+        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.NamedFieldNode fieldControlledArray, MemoryLayout memoryLayout) {\n@@ -115,0 +118,2 @@\n+\n+\n@@ -126,2 +131,2 @@\n-\n-        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout) {\n+@Override\n+        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.NamedFieldNode fieldControlledArray, MemoryLayout memoryLayout) {\n@@ -190,1 +195,1 @@\n-        TypeSchemaNode parent;\n+        public IfaceTypeNode parent;\n@@ -192,1 +197,1 @@\n-        SchemaNode(TypeSchemaNode parent) {\n+        SchemaNode(IfaceTypeNode parent) {\n@@ -198,2 +203,2 @@\n-        public static abstract sealed class FieldSchemaNode extends SchemaNode permits NamedFieldSchemaNode, Padding {\n-            FieldSchemaNode(TypeSchemaNode parent) {\n+        public static abstract sealed class FieldNode extends SchemaNode permits NamedFieldNode, Padding {\n+            FieldNode(IfaceTypeNode parent) {\n@@ -202,1 +207,0 @@\n-\n@@ -204,2 +208,1 @@\n-\n-            abstract void collectLayouts(LayoutToBoundFieldTreeNode layoutCollector);\n+            public abstract void collectLayouts(LayoutToBoundFieldTreeNode layoutCollector);\n@@ -208,1 +211,1 @@\n-        public static final class Padding extends FieldSchemaNode {\n+        public static final class Padding extends FieldNode {\n@@ -211,1 +214,1 @@\n-            Padding(TypeSchemaNode parent, int len) {\n+            Padding(IfaceTypeNode parent, int len) {\n@@ -222,1 +225,1 @@\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n@@ -227,1 +230,1 @@\n-        public static abstract sealed class NamedFieldSchemaNode extends FieldSchemaNode permits Array, ArrayLen, AtomicField, Field {\n+        public static abstract sealed class NamedFieldNode extends FieldNode permits AddressField, MapableIfaceNamedFieldNode, PrimitiveNamedFieldNode {\n@@ -229,2 +232,0 @@\n-            Class<?> type;\n-            final String name;\n@@ -232,1 +233,2 @@\n-            NamedFieldSchemaNode(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+            public final String name;\n+            NamedFieldNode(IfaceTypeNode parent, AccessorInfo.Key key,  String name) {\n@@ -235,1 +237,0 @@\n-                this.type = type;\n@@ -239,0 +240,6 @@\n+        public static abstract sealed class PrimitiveNamedFieldNode extends NamedFieldNode permits PrimitiveArray, ArrayLen, AtomicField, PrimitiveField {\n+            public Class<?> type;\n+            PrimitiveNamedFieldNode(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+                super(parent,key,  name);\n+                this.type = type;\n+            }\n@@ -240,0 +247,6 @@\n+            @Override\n+            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, parent.getLayout(this.type, layoutToFieldBindingNode).withName(name));\n+            }\n+        }\n+        public static abstract sealed class MapableIfaceNamedFieldNode extends NamedFieldNode permits IfaceMappableArray,  MappableIfaceField {\n@@ -241,3 +254,17 @@\n-        public static final class ArrayLen extends NamedFieldSchemaNode {\n-            ArrayLen(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n-                super(parent, key, type, name);\n+            public IfaceTypeNode ifaceTypeNode;\n+            MapableIfaceNamedFieldNode(IfaceTypeNode parent, AccessorInfo.Key key, Class<MappableIface> iface, String name) {\n+                super(parent,key, name);\n+                this.ifaceTypeNode = parent.types.stream().filter(n->n.iface.isAssignableFrom(iface)).findFirst().orElseThrow();\n+            }\n+            @Override\n+            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, parent.getLayout(this.ifaceTypeNode.iface, layoutToFieldBindingNode).withName(name));\n+            }\n+        }\n+        public static final class AddressField extends NamedFieldNode {\n+\n+            Class<MemorySegment> type;\n+\n+            AddressField(IfaceTypeNode parent, AccessorInfo.Key key, Class<MemorySegment> type, String name) {\n+                super(parent, key, name);\n+                this.type = type;\n@@ -248,1 +275,1 @@\n-                stringConsumer.accept(indent + \"arrayLen \" + key + \":\" + type);\n+                stringConsumer.accept(indent + \"address \" + key + \":\" + type);\n@@ -250,1 +277,0 @@\n-\n@@ -252,1 +278,1 @@\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n@@ -256,0 +282,4 @@\n+        public static final class ArrayLen extends PrimitiveNamedFieldNode {\n+            ArrayLen(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+                super(parent, key, type, name);\n+            }\n@@ -257,1 +287,4 @@\n-        public static final class AtomicField extends NamedFieldSchemaNode {\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"arrayLen \" + key + \":\" + type);\n+            }\n@@ -259,0 +292,1 @@\n+        }\n@@ -260,1 +294,2 @@\n-            AtomicField(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+        public static final class AtomicField extends PrimitiveNamedFieldNode {\n+            AtomicField(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n@@ -269,4 +304,0 @@\n-            @Override\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, parent.getLayout(type, layoutToFieldBindingNode).withName(name));\n-            }\n@@ -275,2 +306,1 @@\n-        public static final class Field extends NamedFieldSchemaNode {\n-\n+        public static final class MappableIfaceField extends MapableIfaceNamedFieldNode {\n@@ -278,1 +308,1 @@\n-            Field(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+            MappableIfaceField(IfaceTypeNode parent, AccessorInfo.Key key, Class<MappableIface> type, String name) {\n@@ -285,1 +315,9 @@\n-                stringConsumer.accept(indent + \"field \" + key + \":\" + type);\n+                stringConsumer.accept(indent + \"mappable field \" + key + \":\" + ifaceTypeNode.iface);\n+            }\n+\n+        }\n+        public static final class PrimitiveField extends PrimitiveNamedFieldNode {\n+\n+            PrimitiveField(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+                super(parent, key, type, name);\n+\n@@ -289,2 +327,2 @@\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, parent.getLayout(type, layoutToFieldBindingNode).withName(name));\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"primitive field \" + key + \":\" + type);\n@@ -294,4 +332,4 @@\n-        public static abstract sealed class TypeSchemaNode extends SchemaNode permits Union, Struct {\n-            private List<FieldSchemaNode> fields = new ArrayList<>();\n-            private List<TypeSchemaNode> types = new ArrayList<>();\n-            Class<?> type;\n+        public static abstract sealed class IfaceTypeNode extends SchemaNode permits Union, Struct {\n+            public List<FieldNode> fields = new ArrayList<>();\n+            public List<IfaceTypeNode> types = new ArrayList<>();\n+            public Class<?> iface;\n@@ -299,1 +337,1 @@\n-            <T extends FieldSchemaNode> T addField(T child) {\n+            <T extends FieldNode> T addField(T child) {\n@@ -304,1 +342,1 @@\n-            <T extends TypeSchemaNode> T addType(T child) {\n+            <T extends IfaceTypeNode> T addType(T child) {\n@@ -309,1 +347,1 @@\n-            TypeSchemaNode(TypeSchemaNode parent, Class<?> type) {\n+            IfaceTypeNode(IfaceTypeNode parent, Class<?> iface) {\n@@ -311,1 +349,6 @@\n-                this.type = type;\n+                this.iface = iface;\n+            }\n+\n+            public void visitTypes(int depth, Consumer<SchemaNode.IfaceTypeNode> ifaceTypeNodeConsumer) {\n+                types.forEach(t->t.visitTypes(depth+1,ifaceTypeNodeConsumer));\n+                ifaceTypeNodeConsumer.accept(this);\n@@ -327,2 +370,2 @@\n-                }else    if (MemorySegment.class.isAssignableFrom(type)) {\n-                        return ValueLayout.ADDRESS;\n+                }else if (MemorySegment.class.isAssignableFrom(type)) {\n+                    return ValueLayout.ADDRESS;\n@@ -330,2 +373,2 @@\n-                    Optional<TypeSchemaNode> optionalTypeSchemaKeyMatchingType = types.stream()\n-                            .filter(typeSchemaNode -> typeSchemaNode.type.equals(type))\n+                    Optional<IfaceTypeNode> optionalTypeSchemaKeyMatchingType = types.stream()\n+                            .filter(ifaceTypeNode -> ifaceTypeNode.iface.equals(type))\n@@ -336,2 +379,2 @@\n-                        typeSchemaKeyMatchingType.fields.forEach(fieldSchemaNode ->\n-                                fieldSchemaNode.collectLayouts(scope)\n+                        typeSchemaKeyMatchingType.fields.forEach(fieldNode ->\n+                                fieldNode.collectLayouts(scope)\n@@ -339,1 +382,1 @@\n-                        return isUnion(typeSchemaKeyMatchingType.type)\n+                        return isUnion(typeSchemaKeyMatchingType.iface)\n@@ -348,2 +391,2 @@\n-            public TypeSchemaNode struct(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n-                parentSchemaNodeConsumer.accept(addType(new Struct(this, typeOf(type, name))));\n+            public IfaceTypeNode struct(String name, Consumer<IfaceTypeNode> parentSchemaNodeConsumer) {\n+                parentSchemaNodeConsumer.accept(addType(new Struct(this, typeOf(iface, name))));\n@@ -353,2 +396,2 @@\n-            public TypeSchemaNode union(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n-                parentSchemaNodeConsumer.accept(addType(new Union(this, typeOf(type, name))));\n+            public IfaceTypeNode union(String name, Consumer<IfaceTypeNode> parentSchemaNodeConsumer) {\n+                parentSchemaNodeConsumer.accept(addType(new Union(this, typeOf(iface, name))));\n@@ -358,2 +401,8 @@\n-            public TypeSchemaNode field(String name) {\n-                addField(new Field(this, AccessorInfo.Key.of(type, name), typeOf(type, name), name));\n+            public IfaceTypeNode field(String name) {\n+                var key = AccessorInfo.Key.of(iface, name);\n+                var typeOf = typeOf(iface, name);\n+                addField(MemorySegment.class.isAssignableFrom(typeOf)\n+                        ? new AddressField(this, key, (Class<MemorySegment>)typeOf, name)\n+                        : MappableIface.class.isAssignableFrom(typeOf)\n+                           ? new MappableIfaceField(this, key, (Class<MappableIface>) typeOf, name)\n+                           : new PrimitiveField(this, key, typeOf, name));\n@@ -363,2 +412,2 @@\n-            public TypeSchemaNode atomic(String name) {\n-                addField(new AtomicField(this, AccessorInfo.Key.of(type, name), typeOf(type, name), name));\n+            public IfaceTypeNode atomic(String name) {\n+                addField(new AtomicField(this, AccessorInfo.Key.of(iface, name), typeOf(iface, name), name));\n@@ -368,1 +417,1 @@\n-            public TypeSchemaNode pad(int len) {\n+            public IfaceTypeNode pad(int len) {\n@@ -373,6 +422,7 @@\n-            public TypeSchemaNode field(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n-                AccessorInfo.Key fieldKey = AccessorInfo.Key.of(type, name);\n-                Class<?> fieldType = typeOf(type, name);\n-                addField(new Field(this, fieldKey, fieldType, name));\n-                TypeSchemaNode field = isStruct(fieldType) ? new SchemaNode.Struct(this, fieldType) : new SchemaNode.Union(this, fieldType);\n-                parentSchemaNodeConsumer.accept(addType(field));\n+            public IfaceTypeNode field(String name, Consumer<IfaceTypeNode> parentSchemaNodeConsumer) {\n+                AccessorInfo.Key fieldKey = AccessorInfo.Key.of(iface, name);\n+                Class<MappableIface> fieldType = (Class<MappableIface>)typeOf(iface, name);\n+                  IfaceTypeNode structOrUnion= isStruct(fieldType) ? new SchemaNode.Struct(this, fieldType) : new SchemaNode.Union(this, fieldType);\n+                addType(structOrUnion);\n+                addField(new MappableIfaceField(this, fieldKey, fieldType, name));\n+                parentSchemaNodeConsumer.accept(structOrUnion);\n@@ -382,3 +432,3 @@\n-            public TypeSchemaNode fields(String name1, String name2, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n-                AccessorInfo.Key fieldKey1 = AccessorInfo.Key.of(type, name1);\n-                AccessorInfo.Key fieldKey2 = AccessorInfo.Key.of(type, name2);\n+            public IfaceTypeNode fields(String name1, String name2, Consumer<IfaceTypeNode> parentSchemaNodeConsumer) {\n+                AccessorInfo.Key fieldKey1 = AccessorInfo.Key.of(iface, name1);\n+                AccessorInfo.Key fieldKey2 = AccessorInfo.Key.of(iface, name2);\n@@ -388,2 +438,2 @@\n-                Class<?> structOrUnionType = typeOf(type, name1);\n-                Class<?> fieldTypeCheck = typeOf(type, name2);\n+                Class<MappableIface> structOrUnionType = (Class<MappableIface>) typeOf(iface, name1);\n+                Class<?> fieldTypeCheck = typeOf(iface, name2);\n@@ -393,3 +443,1 @@\n-                addField(new Field(this, fieldKey1, structOrUnionType, name1));\n-                addField(new Field(this, fieldKey2, structOrUnionType, name2));\n-                TypeSchemaNode typeSchemaNode = isStruct(type)\n+                IfaceTypeNode ifaceTypeNode = isStruct(iface)\n@@ -398,1 +446,5 @@\n-                parentSchemaNodeConsumer.accept(addType(typeSchemaNode));\n+                addType(ifaceTypeNode);\n+                addField(new MappableIfaceField(this, fieldKey1, structOrUnionType, name1));\n+                addField(new MappableIfaceField(this, fieldKey2, structOrUnionType, name2));\n+\n+                parentSchemaNodeConsumer.accept(ifaceTypeNode);\n@@ -402,1 +454,1 @@\n-            public TypeSchemaNode fields(String... names) {\n+            public IfaceTypeNode fields(String... names) {\n@@ -409,2 +461,5 @@\n-            public TypeSchemaNode array(String name, int len) {\n-                addField(new FixedArray(this, AccessorInfo.Key.of(type, name), typeOf(type, name), name, len));\n+            public IfaceTypeNode array(String name, int len) {\n+                AccessorInfo.Key arrayKey = AccessorInfo.Key.of(iface, name);\n+                addField(arrayKey.valueType().equals(ValueType.INTERFACE)\n+                        ?new IfaceMapableFixedArray( this,arrayKey,(Class<MappableIface>)typeOf(iface,name),name, len)\n+                        :new PrimitiveFixedArray(this, arrayKey, typeOf(iface, name), name, len));\n@@ -414,4 +469,4 @@\n-            public TypeSchemaNode array(String name, int len, Consumer<TypeSchemaNode> parentFieldConsumer) {\n-                AccessorInfo.Key arrayKey = AccessorInfo.Key.of(type, name);\n-                Class<?> structOrUnionType = typeOf(type, name);\n-                TypeSchemaNode typeSchemaNode = isStruct(type)\n+            public IfaceTypeNode array(String name, int len, Consumer<IfaceTypeNode> parentFieldConsumer) {\n+                AccessorInfo.Key arrayKey = AccessorInfo.Key.of(iface, name);\n+                Class<MappableIface> structOrUnionType = (Class<MappableIface>)typeOf(iface, name);\n+                IfaceTypeNode ifaceTypeNode = isStruct(iface)\n@@ -420,3 +475,3 @@\n-                parentFieldConsumer.accept(typeSchemaNode);\n-                addType(typeSchemaNode);\n-                addField(new FixedArray(this, arrayKey, structOrUnionType, name, len));\n+                parentFieldConsumer.accept(ifaceTypeNode);\n+                addType(ifaceTypeNode);\n+                addField(new IfaceMapableFixedArray(this, arrayKey, structOrUnionType, name, len));\n@@ -426,2 +481,5 @@\n-            private TypeSchemaNode fieldControlledArray(String name, List<ArrayLen> arrayLenFields, int stride) {\n-                addField(new FieldControlledArray(this, AccessorInfo.Key.of(type, name), typeOf(type, name), name,  arrayLenFields, stride));\n+            private IfaceTypeNode fieldControlledArray(String name, List<ArrayLen> arrayLenFields, int stride) {\n+                AccessorInfo.Key arrayKey = AccessorInfo.Key.of(iface, name);\n+                addField(arrayKey.valueType().equals(ValueType.INTERFACE)\n+                        ?new IfaceMapableFieldControlledArray(this, arrayKey, (Class<MappableIface>)typeOf(iface, name), name,  arrayLenFields, stride)\n+                        :new PrimitiveFieldControlledArray(this, arrayKey, typeOf(iface, name), name,  arrayLenFields, stride));\n@@ -432,1 +490,1 @@\n-                TypeSchemaNode typeSchemaNode;\n+                IfaceTypeNode ifaceTypeNode;\n@@ -437,2 +495,2 @@\n-                public TypeSchemaNode array(String name) {\n-                    return typeSchemaNode.fieldControlledArray(name, arrayLenFields, stride);\n+                public IfaceTypeNode array(String name) {\n+                    return ifaceTypeNode.fieldControlledArray(name, arrayLenFields, stride);\n@@ -447,2 +505,2 @@\n-                    var paddingField = new Padding(typeSchemaNode, padding);\n-                    typeSchemaNode.addField(paddingField);\n+                    var paddingField = new Padding(ifaceTypeNode, padding);\n+                    ifaceTypeNode.addField(paddingField);\n@@ -451,9 +509,11 @@\n-                public TypeSchemaNode array(String name, Consumer<TypeSchemaNode> parentFieldConsumer) {\n-                    Class<?> arrayType = typeOf(typeSchemaNode.type, name);\n-                    this.typeSchemaNode.fieldControlledArray(name, arrayLenFields, stride);\n-                    TypeSchemaNode typeSchemaNode = isStruct(arrayType)\n-                            ? new SchemaNode.Struct(this.typeSchemaNode, arrayType)\n-                            : new SchemaNode.Union(this.typeSchemaNode, arrayType);\n-                    parentFieldConsumer.accept(typeSchemaNode);\n-                    this.typeSchemaNode.addType(typeSchemaNode);\n-                    return this.typeSchemaNode;\n+                public IfaceTypeNode array(String name, Consumer<IfaceTypeNode> parentFieldConsumer) {\n+                    Class<?> arrayType = typeOf(this.ifaceTypeNode.iface, name);\n+                    IfaceTypeNode ifaceTypeNode = isStruct(arrayType)\n+                            ? new SchemaNode.Struct(this.ifaceTypeNode, arrayType)\n+                            : new SchemaNode.Union(this.ifaceTypeNode, arrayType);\n+                    parentFieldConsumer.accept(ifaceTypeNode);\n+                    this.ifaceTypeNode.addType(ifaceTypeNode);\n+                    this.ifaceTypeNode.fieldControlledArray(name, arrayLenFields, stride);\n+\n+\n+                    return this.ifaceTypeNode;\n@@ -462,2 +522,2 @@\n-                ArrayBuildState(TypeSchemaNode typeSchemaNode, List<ArrayLen> arrayLenFields) {\n-                    this.typeSchemaNode = typeSchemaNode;\n+                ArrayBuildState(IfaceTypeNode ifaceTypeNode, List<ArrayLen> arrayLenFields) {\n+                    this.ifaceTypeNode = ifaceTypeNode;\n@@ -471,1 +531,1 @@\n-                    var arrayLenField = new ArrayLen(this, AccessorInfo.Key.of(type, arrayLenFieldName), typeOf(type, arrayLenFieldName), arrayLenFieldName);\n+                    var arrayLenField = new ArrayLen(this, AccessorInfo.Key.of(iface, arrayLenFieldName), typeOf(iface, arrayLenFieldName), arrayLenFieldName);\n@@ -481,1 +541,1 @@\n-                if (isUnion(type)) {\n+                if (isUnion(iface)) {\n@@ -483,1 +543,1 @@\n-                } else if (isStructOrBuffer(type)) {\n+                } else if (isStructOrBuffer(iface)) {\n@@ -488,1 +548,1 @@\n-                stringConsumer.accept(\" \" + type + \"{\");\n+                stringConsumer.accept(\" \" + iface + \"{\");\n@@ -504,2 +564,2 @@\n-        public static final class Struct extends TypeSchemaNode {\n-            Struct(TypeSchemaNode parent, Class<?> type) {\n+        public static final class Struct extends IfaceTypeNode {\n+            Struct(IfaceTypeNode parent, Class<?> type) {\n@@ -510,2 +570,2 @@\n-        public static final class Union extends TypeSchemaNode {\n-            Union(TypeSchemaNode parent, Class<?> type) {\n+        public static final class Union extends IfaceTypeNode {\n+            Union(IfaceTypeNode parent, Class<?> type) {\n@@ -515,3 +575,7 @@\n-\n-        public abstract static sealed class Array extends NamedFieldSchemaNode permits FieldControlledArray, FixedArray {\n-            Array(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+        public abstract static sealed class IfaceMappableArray extends MapableIfaceNamedFieldNode permits IfaceMapableFieldControlledArray, IfaceMapableFixedArray {\n+            IfaceMappableArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<MappableIface> iface, String name) {\n+                super(parent, key, iface, name);\n+            }\n+        }\n+        public abstract static sealed class PrimitiveArray extends PrimitiveNamedFieldNode permits PrimitiveFieldControlledArray, PrimitiveFixedArray {\n+            PrimitiveArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n@@ -521,0 +585,2 @@\n+        public static final class IfaceMapableFixedArray extends IfaceMappableArray {\n+            public int len;\n@@ -522,2 +588,4 @@\n-        public static final class FixedArray extends Array {\n-            int len;\n+            IfaceMapableFixedArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<MappableIface> iface, String name, int len) {\n+                super(parent, key, iface, name);\n+                this.len = len;\n+            }\n@@ -525,1 +593,16 @@\n-            FixedArray(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name, int len) {\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"array [\" + len + \"]\");\n+            }\n+\n+            @Override\n+            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(len,\n+                        parent.getLayout(ifaceTypeNode.iface, layoutToFieldBindingNode).withName(ifaceTypeNode.iface.getSimpleName())\n+                ).withName(name));\n+            }\n+        }\n+        public static final class PrimitiveFixedArray extends PrimitiveArray {\n+            public int len;\n+\n+            PrimitiveFixedArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name, int len) {\n@@ -532,1 +615,1 @@\n-                stringConsumer.accept(indent + \"array [\" + len + \"]\");\n+                stringConsumer.accept(indent + \"primitive array [\" + len + \"]\");\n@@ -536,1 +619,1 @@\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n@@ -543,1 +626,1 @@\n-        public static final class FieldControlledArray extends Array {\n+        public static final class IfaceMapableFieldControlledArray extends IfaceMappableArray {\n@@ -546,1 +629,0 @@\n-          \/\/  int padding;\n@@ -549,1 +631,1 @@\n-            FieldControlledArray(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name, List<ArrayLen> arrayLenFields, int stride) {\n+            IfaceMapableFieldControlledArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<MappableIface> type, String name, List<ArrayLen> arrayLenFields, int stride) {\n@@ -551,1 +633,0 @@\n-               \/\/ this.padding = padding;\n@@ -559,1 +640,1 @@\n-                stringConsumer.accept(indent + name + \"[\" + key + \":\" + type + \"] where len defined by \" + arrayLenFields);\n+                stringConsumer.accept(indent + name + \"[\" + key + \":\" + ifaceTypeNode.iface + \"] where len defined by \" + arrayLenFields);\n@@ -563,1 +644,1 @@\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n@@ -571,1 +652,1 @@\n-                        parent.getLayout(type, layoutToFieldBindingNode).withName(type.getSimpleName())\n+                        parent.getLayout(ifaceTypeNode.iface, layoutToFieldBindingNode).withName(ifaceTypeNode.iface.getSimpleName())\n@@ -575,1 +656,4 @@\n-    }\n+        public static final class PrimitiveFieldControlledArray extends PrimitiveArray {\n+            List<ArrayLen> arrayLenFields;\n+            int stride;\n+            int contributingDims;\n@@ -577,4 +661,6 @@\n-    Schema(Class<T> iface, SchemaNode.TypeSchemaNode schemaRootField) {\n-        this.iface = iface;\n-        this.schemaRootField = schemaRootField;\n-    }\n+            PrimitiveFieldControlledArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name, List<ArrayLen> arrayLenFields, int stride) {\n+                super(parent, key, type, name);\n+                this.arrayLenFields = arrayLenFields;\n+                this.stride = stride;\n+                this.contributingDims = arrayLenFields.size();\n+            }\n@@ -582,3 +668,17 @@\n-    public final static BufferAllocator GlobalArenaAllocator = new BufferAllocator() {\n-        public <T extends Buffer> T allocate(SegmentMapper<T> s) {\n-            return s.allocate(Arena.global(), new HatData() {});\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + name + \"[\" + key + \":\" + type + \"] where len defined by \" + arrayLenFields);\n+            }\n+\n+            @Override\n+            public void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n+                int size = stride; \/\/usually 1 but developer can define.\n+                for (int i = 0; i < contributingDims; i++) {\n+                    size *= layoutToFieldBindingNode.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n+                }\n+\n+                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(size,\n+                        parent.getLayout(type, layoutToFieldBindingNode).withName(type.getSimpleName())\n+                ).withName(name));\n+            }\n@@ -586,1 +686,0 @@\n-    };\n@@ -588,2 +687,0 @@\n-    public BoundSchema<T> boundSchema(int... boundLengths) {\n-        return new BoundSchema<>(this, boundLengths);\n@@ -592,2 +689,3 @@\n-    public T allocate(BufferAllocator bufferAllocator, int... boundLengths) {\n-        return boundSchema(boundLengths).allocate(bufferAllocator);\n+    Schema(Class<T> iface, SchemaNode.IfaceTypeNode rootIfaceTypeNode) {\n+        this.iface = iface;\n+        this.rootIfaceTypeNode = rootIfaceTypeNode;\n@@ -596,2 +694,4 @@\n-    public T allocate(int... boundLengths) {\n-        return allocate(GlobalArenaAllocator, boundLengths);\n+\n+    public T allocate(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator, int... boundLengths) {\n+        BoundSchema<?> boundSchema = new BoundSchema<>(this, boundLengths);\n+        return (T) boundSchema.allocate(lookup,bufferAllocator);\n@@ -600,1 +700,1 @@\n-    public static <T extends Buffer> Schema<T> of(Class<T> iface, Consumer<SchemaNode.TypeSchemaNode> parentFieldConsumer) {\n+    public static <T extends Buffer> Schema<T> of(Class<T> iface,  Consumer<SchemaNode.IfaceTypeNode> parentFieldConsumer) {\n@@ -603,1 +703,1 @@\n-        return new Schema<>(iface, struct);\n+        return new Schema<>(iface,struct);\n@@ -607,1 +707,1 @@\n-        schemaRootField.toText(\"\", stringConsumer);\n+        rootIfaceTypeNode.toText(\"\", stringConsumer);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":269,"deletions":169,"binary":false,"changes":438,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-                                   HatData hatData,\n+                                   Schema.BoundSchema<?> boundSchema,\n@@ -86,2 +86,2 @@\n-        super(lookup, type, layout, hatData,leaf,\n-                ValueType.INTERFACE, MapperUtil::requireImplementableInterfaceType, Accessors::ofInterface);\n+        super(lookup, type, layout, boundSchema,leaf,\n+                MapperUtil::requireImplementableInterfaceType, Accessors::ofInterface);\n@@ -146,1 +146,1 @@\n-        return new Mapped<>(lookup(), newType ,layout(),hatData(), getHandle(), toMapper);\n+        return new Mapped<>(lookup(), newType ,layout(),boundSchema(), getHandle(), toMapper);\n@@ -160,1 +160,1 @@\n-            var ctor = lookup().findConstructor(implClass, MethodType.methodType(void.class, MemorySegment.class, GroupLayout.class, HatData.class,\n+            var ctor = lookup().findConstructor(implClass, MethodType.methodType(void.class, MemorySegment.class, GroupLayout.class, Schema.BoundSchema.class,\n@@ -424,2 +424,2 @@\n-                                                       HatData hatData) {\n-        return new SegmentInterfaceMapper<>(lookup, type,  layout, hatData, false, new ArrayList<>());\n+                                                       Schema.BoundSchema<?> boundSchema) {\n+        return new SegmentInterfaceMapper<>(lookup, type,  layout, boundSchema, false, new ArrayList<>());\n@@ -445,1 +445,1 @@\n-            @Override HatData hatData,\n+            @Override Schema.BoundSchema<?> boundSchema,\n@@ -464,1 +464,1 @@\n-               HatData hatData,\n+               Schema.BoundSchema<?> boundSchema,\n@@ -470,1 +470,1 @@\n-            this.hatData =hatData;\n+            this.boundSchema =boundSchema;\n@@ -485,1 +485,1 @@\n-            return new Mapped<>(lookup, newType,  layout(), hatData(), getHandle(), toMapper);\n+            return new Mapped<>(lookup, newType,  layout(), boundSchema(), getHandle(), toMapper);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentInterfaceMapper.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-    HatData hatData();\n+    Schema.BoundSchema<?> boundSchema();\n@@ -322,2 +322,4 @@\n-    default T allocate(Arena arena, HatData  hatData) {\n-\n+    default T allocate(Arena arena, Schema.BoundSchema<?> boundSchema) {\n+if (boundSchema == null) {\n+    throw new IllegalStateException(\"we must have a bound schema\");\n+}\n@@ -338,1 +340,1 @@\n-        return get(segment, layout(), hatData);\n+        return get(segment, layout(), boundSchema);\n@@ -365,2 +367,2 @@\n-    default T get(MemorySegment segment, GroupLayout groupLayout, HatData hatData) {\n-        return get(segment, groupLayout, hatData, 0L);\n+    default T get(MemorySegment segment, GroupLayout groupLayout, Schema.BoundSchema<?> boundSchema) {\n+        return get(segment, groupLayout, boundSchema, 0L);\n@@ -429,1 +431,1 @@\n-    default T get(MemorySegment segment, GroupLayout layout, HatData hatData, long offset) {\n+    default T get(MemorySegment segment, GroupLayout layout, Schema.BoundSchema<?> boundSchema, long offset) {\n@@ -432,1 +434,1 @@\n-                    .invokeExact(segment, layout, hatData,offset);\n+                    .invokeExact(segment, layout, boundSchema,offset);\n@@ -682,1 +684,1 @@\n-    static <T extends Buffer> SegmentMapper<T> of(MethodHandles.Lookup lookup, Class<T> type, GroupLayout layout, HatData hatData) {\n+    static <T extends Buffer> SegmentMapper<T> of(MethodHandles.Lookup lookup, Class<T> type, GroupLayout layout, Schema.BoundSchema<?> boundSchema) {\n@@ -686,1 +688,1 @@\n-        return SegmentInterfaceMapper.create(lookup,  type, layout, hatData);\n+        return SegmentInterfaceMapper.create(lookup,  type, layout, boundSchema);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.buffer.MappableIface;\n+import hat.ifacemapper.MappableIface;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,2 +69,1 @@\n-        var arr = S32Array.schema.allocate(accelerator, 32);\n-        arr.length(32);\n+        var arr = S32Array.create(accelerator, 32);\n","filename":"hat\/hat\/src\/main\/test\/hat\/SquaresTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+    <mapping directory=\"$PROJECT_DIR$\/..\/hattricks\" vcs=\"Git\" \/>\n","filename":"hat\/intellij\/.idea\/vcs.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}