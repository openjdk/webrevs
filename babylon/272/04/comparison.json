{"files":[{"patch":"@@ -768,2 +768,23 @@\n-                        \/\/ @@@ var args\n-                        processOperands(op);\n+                        if (op.isVarArgs()) {\n+                            processOperands(op.argOperands());\n+                            var varArgOperands = op.varArgOperands();\n+                            cob.loadConstant(varArgOperands.size());\n+                            var compType = ((ArrayType) op.invokeDescriptor().type().parameterTypes().getLast()).componentType();\n+                            var compTypeDesc = compType.toNominalDescriptor();\n+                            var typeKind = TypeKind.from(compTypeDesc);\n+                            if (compTypeDesc.isPrimitive()) {\n+                                cob.newarray(typeKind);\n+                            } else {\n+                                cob.anewarray(compTypeDesc);\n+                            }\n+                            for (int j = 0; j < varArgOperands.size(); j++) {\n+                                \/\/ we duplicate array value on the stack to be consumed by arrayStore\n+                                \/\/ after completion of this loop the array value will be on top of the stack\n+                                cob.dup();\n+                                cob.loadConstant(j);\n+                                load(varArgOperands.get(j));\n+                                cob.arrayStore(typeKind);\n+                            }\n+                        } else {\n+                            processOperands(op);\n+                        }\n@@ -781,3 +802,0 @@\n-                        if (op.isVarArgs()) {\n-                            throw new UnsupportedOperationException(\"invoke varargs unsupported: \" + op.invokeDescriptor());\n-                        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1559,0 +1559,9 @@\n+        public List<Value> argOperands() {\n+            if (isVarArgs){\n+                return operands();\n+            }\n+            int paramCount = invokeDescriptor().type().parameterTypes().size();\n+            int argOperandsCount = paramCount - (invokeKind() == InvokeKind.STATIC ? 1 : 0);\n+            return operands().subList(0, argOperandsCount);\n+        }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestInvokeOp\n+ *\/\n+public class TestInvokeOp {\n+\n+    @Test\n+    void test() {\n+        var f = getFuncOp(this.getClass(), \"f\");\n+        var invokeOps = f.elements().filter(ce -> ce instanceof CoreOp.InvokeOp).map(ce -> ((CoreOp.InvokeOp) ce)).toList();\n+\n+        Assert.assertEquals(invokeOps.get(0).argOperands(), invokeOps.get(0).operands());\n+\n+        Assert.assertEquals(invokeOps.get(1).argOperands(), invokeOps.get(1).operands().subList(0, 1));\n+\n+        Assert.assertEquals(invokeOps.get(2).argOperands(), invokeOps.get(2).operands());\n+\n+        Assert.assertEquals(invokeOps.get(3).argOperands(), invokeOps.get(3).operands().subList(0, 1));\n+\n+        for (CoreOp.InvokeOp invokeOp : invokeOps) {\n+            var l = new ArrayList<>(invokeOp.argOperands());\n+            if (invokeOp.isVarArgs()) {\n+                l.addAll(invokeOp.varArgOperands());\n+            }\n+            Assert.assertEquals(l, invokeOp.operands());\n+        }\n+    }\n+\n+    @CodeReflection\n+    void f() {\n+        s(1);\n+        s(4, 2, 3);\n+        i();\n+        i(0.0, 0.0);\n+    }\n+\n+    static void s(int a, long... l) {}\n+    void i(double... d) {}\n+\n+    static CoreOp.FuncOp getFuncOp(Class<?> c, String name) {\n+        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInvokeOp.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestVarArg\n+ *\n+ *\/\n+public class TestVarArg {\n+\n+    @Test\n+    void test() throws Throwable {\n+        var f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        var lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        var bytes = BytecodeGenerator.generateClassData(MethodHandles.lookup(), f);\n+        var classModel = ClassFile.of().parse(bytes);\n+        ClassPrinter.toYaml(classModel, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+\n+        MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        Assert.assertEquals(mh.invoke(), f());\n+    }\n+\n+    @CodeReflection\n+    static String f() {\n+        String r = \"\";\n+        String ls = System.lineSeparator();\n+\n+        r += ls + h(1);\n+        r += ls + h(2, 3);\n+        r += ls + h(4, (byte) 5);\n+\n+        r += ls + k(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+\n+        r += ls + j(\"s1\", \"s2\", \"s3\");\n+\n+        r += ls + w(8, 9);\n+\n+        r += k();\n+\n+        r += l(11L, 12L);\n+\n+        r += d(21.0, 22.0);\n+\n+        return r;\n+    }\n+\n+    static String h(int i, int... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static String k(byte... s) {\n+        return Arrays.toString(s);\n+    }\n+\n+    static String j(String i, String... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static <T extends Number> String w(T... ts) {\n+        return Arrays.toString(ts);\n+    }\n+\n+    static String l(long... a) {\n+        return Arrays.toString(a);\n+    }\n+\n+    static String d(double... a) {\n+        return Arrays.toString(a);\n+    }\n+\n+    private CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(this.getClass().getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}