{"files":[{"patch":"@@ -863,2 +863,21 @@\n-                        \/\/ @@@ var args\n-                        processOperands(op);\n+                        if (op.isVarArgs()) {\n+                            processOperands(op.operands().subList(0, op.operands().size() - op.varArgOperands().size()));\n+                            var varArgOperands = op.varArgOperands();\n+                            cob.loadConstant(varArgOperands.size());\n+                            var compType = ((ArrayType) op.invokeDescriptor().type().parameterTypes().getLast()).componentType();\n+                            var typeKind = TypeKind.fromDescriptor(compType.toNominalDescriptor().descriptorString());\n+                            if (TypeKind.REFERENCE.equals(typeKind)) {\n+                                var cd = ClassDesc.ofDescriptor(compType.toNominalDescriptor().descriptorString());\n+                                cob.anewarray(cd);\n+                            } else {\n+                                cob.newarray(typeKind);\n+                            }\n+                            for (int j = 0; j < varArgOperands.size(); j++) {\n+                                cob.dup();\n+                                cob.loadConstant(j);\n+                                load(varArgOperands.get(j));\n+                                cob.arrayStore(typeKind);\n+                            }\n+                        } else {\n+                            processOperands(op);\n+                        }\n@@ -876,3 +895,0 @@\n-                        if (op.isVarArgs()) {\n-                            throw new UnsupportedOperationException(\"invoke varargs unsupported: \" + op.invokeDescriptor());\n-                        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestVarArg\n+ *\n+ *\/\n+public class TestVarArg {\n+\n+    @Test\n+    void test() throws Throwable {\n+        var f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        var lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        var bytes = BytecodeGenerator.generateClassData(MethodHandles.lookup(), f);\n+        var classModel = ClassFile.of().parse(bytes);\n+        ClassPrinter.toYaml(classModel, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+\n+        MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        Assert.assertEquals(mh.invoke(), f());\n+    }\n+\n+    @CodeReflection\n+    static String f() {\n+        String r = \"\";\n+        String ls = System.lineSeparator();\n+\n+        r += ls + h(1);\n+        r += ls + h(2, 3);\n+        r += ls + h(4, (byte) 5);\n+\n+        r += ls + k(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+\n+        r += ls + j(\"s1\", \"s2\", \"s3\");\n+\n+        r += ls + w(8, 9);\n+\n+        r += k();\n+\n+        r += w(11L, 12L);\n+\n+        r += w(21.0, 22.0);\n+\n+        return r;\n+    }\n+\n+    static String h(int i, int... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static String k(byte... s) {\n+        return Arrays.toString(s);\n+    }\n+\n+    static String j(String i, String... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static <T extends Number> String w(T... ts) {\n+        return Arrays.toString(ts);\n+    }\n+\n+    private CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(this.getClass().getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}