{"files":[{"patch":"@@ -863,2 +863,21 @@\n-                        \/\/ @@@ var args\n-                        processOperands(op);\n+                        if (op.isVarArgs()) {\n+                            processOperands(op.operands().subList(0, op.operands().size() - op.varArgOperands().size()));\n+                            var varArgOperands = op.varArgOperands();\n+                            cob.loadConstant(varArgOperands.size());\n+                            var compType = ((ArrayType) op.invokeDescriptor().type().parameterTypes().getLast()).componentType();\n+                            var typeKind = TypeKind.fromDescriptor(compType.toNominalDescriptor().descriptorString());\n+                            if (TypeKind.REFERENCE.equals(typeKind)) {\n+                                var cd = ClassDesc.ofDescriptor(compType.toNominalDescriptor().descriptorString());\n+                                cob.anewarray(cd);\n+                            } else {\n+                                cob.newarray(typeKind);\n+                            }\n+                            for (int j = 0; j < varArgOperands.size(); j++) {\n+                                cob.dup();\n+                                cob.loadConstant(j);\n+                                load(varArgOperands.get(j));\n+                                cob.arrayStore(typeKind);\n+                            }\n+                        } else {\n+                            processOperands(op);\n+                        }\n@@ -876,3 +895,0 @@\n-                        if (op.isVarArgs()) {\n-                            throw new UnsupportedOperationException(\"invoke varargs unsupported: \" + op.invokeDescriptor());\n-                        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1563,0 +1563,9 @@\n+        public List<Value> argOperands() {\n+            if (!isVarArgs()){\n+                return operands();\n+            }\n+            int paramCount = invokeDescriptor().type().parameterTypes().size();\n+            int argOperandsCount = paramCount - (invokeKind() == InvokeKind.STATIC ? 1 : 0);\n+            return operands().subList(0, argOperandsCount);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestInvokeOp\n+ *\/\n+public class TestInvokeOp {\n+\n+    @Test\n+    void test() {\n+        var f = getFuncOp(this.getClass(), \"f\");\n+        var invokeOps = f.elements().filter(ce -> ce instanceof CoreOp.InvokeOp).map(ce -> ((CoreOp.InvokeOp) ce)).toList();\n+\n+        Assert.assertEquals(invokeOps.get(0).argOperands(), invokeOps.get(0).operands());\n+\n+        Assert.assertEquals(invokeOps.get(1).argOperands(), invokeOps.get(1).operands().subList(0, 1));\n+\n+        Assert.assertEquals(invokeOps.get(2).argOperands(), invokeOps.get(2).operands());\n+\n+        Assert.assertEquals(invokeOps.get(3).argOperands(), invokeOps.get(3).operands().subList(0, 1));\n+\n+        for (CoreOp.InvokeOp invokeOp : invokeOps) {\n+            var l = new ArrayList<>(invokeOp.argOperands());\n+            if (invokeOp.isVarArgs()) {\n+                l.addAll(invokeOp.varArgOperands());\n+            }\n+            Assert.assertEquals(l, invokeOp.operands());\n+        }\n+    }\n+\n+    @CodeReflection\n+    void f() {\n+        s(1);\n+        s(4, 2, 3);\n+        i();\n+        i(0.0, 0.0);\n+    }\n+\n+    static void s(int a, long... l) {}\n+    void i(double... d) {}\n+\n+    static CoreOp.FuncOp getFuncOp(Class<?> c, String name) {\n+        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInvokeOp.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestVarArg\n+ *\n+ *\/\n+public class TestVarArg {\n+\n+    @Test\n+    void test() throws Throwable {\n+        var f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        var lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        var bytes = BytecodeGenerator.generateClassData(MethodHandles.lookup(), f);\n+        var classModel = ClassFile.of().parse(bytes);\n+        ClassPrinter.toYaml(classModel, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+\n+        MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        Assert.assertEquals(mh.invoke(), f());\n+    }\n+\n+    @CodeReflection\n+    static String f() {\n+        String r = \"\";\n+        String ls = System.lineSeparator();\n+\n+        r += ls + h(1);\n+        r += ls + h(2, 3);\n+        r += ls + h(4, (byte) 5);\n+\n+        r += ls + k(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+\n+        r += ls + j(\"s1\", \"s2\", \"s3\");\n+\n+        r += ls + w(8, 9);\n+\n+        r += k();\n+\n+        r += w(11L, 12L);\n+\n+        r += w(21.0, 22.0);\n+\n+        return r;\n+    }\n+\n+    static String h(int i, int... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static String k(byte... s) {\n+        return Arrays.toString(s);\n+    }\n+\n+    static String j(String i, String... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static <T extends Number> String w(T... ts) {\n+        return Arrays.toString(ts);\n+    }\n+\n+    private CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(this.getClass().getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}