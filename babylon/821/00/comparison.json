{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import optkl.OpHelper;\n@@ -54,2 +53,2 @@\n-\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -444,1 +443,1 @@\n-            if (invokeOpHelper(lookup,op) instanceof OpHelper.NamedOpHelper.Invoke invoke){\n+            if (invoke(lookup,op) instanceof Invoke invoke){\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import optkl.OpHelper;\n@@ -45,2 +44,4 @@\n-import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -144,1 +145,1 @@\n-            if (invokeOpHelper(lookup,op) instanceof OpHelper.NamedOpHelper.Invoke invoke && !invoke.isMappableIface()) {\n+            if (invoke(lookup,op) instanceof Invoke invoke && !invoke.isMappableIface()) {\n@@ -185,1 +186,1 @@\n-            case JavaOp.InvokeOp $ -> methodCall(invokeOpHelper(lookup,$));\n+            case JavaOp.InvokeOp $ -> methodCall(invoke(lookup,$));\n@@ -223,1 +224,1 @@\n-        var fieldAccess = fieldAccessOpHelper(lookup,fieldLoadOp);\n+        var fieldAccess = fieldAccess(lookup,fieldLoadOp);\n@@ -450,1 +451,1 @@\n-    public void methodCall(OpHelper.NamedOpHelper.Invoke invoke) {\n+    public void methodCall(Invoke invoke) {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.callgraph.CallGraph;\n@@ -32,1 +31,0 @@\n-import jdk.incubator.code.Value;\n@@ -34,2 +32,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n@@ -37,5 +33,0 @@\n-import optkl.FuncOpParams;\n-import optkl.OpHelper;\n-import optkl.Trxfmr;\n-import optkl.ifacemapper.AccessType;\n-import optkl.ifacemapper.MappableIface;\n@@ -45,5 +36,0 @@\n-import java.util.List;\n-\n-import static hat.ComputeContext.WRAPPER.ACCESS;\n-import static hat.ComputeContext.WRAPPER.MUTATE;\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import static optkl.OpHelper.NamedOpHelper.Invoke.getTargetInvoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.getTargetInvoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -74,1 +74,1 @@\n-                if (invokeOpHelper(lookup, op) instanceof OpHelper.NamedOpHelper.Invoke invoke                         \/\/ always but pattern friendly\n+                if (invoke(lookup, op) instanceof Invoke invoke                         \/\/ always but pattern friendly\n@@ -122,1 +122,1 @@\n-                    var ioh =  invokeOpHelper(lookup,invokeOp);\n+                    var ioh =  invoke(lookup,invokeOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-import static optkl.OpHelper.NamedOpHelper.Invoke.getTargetInvoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.getTargetInvoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import hat.callgraph.CallGraph;\n@@ -54,1 +53,1 @@\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -115,1 +114,1 @@\n-                        var invoke = invokeOpHelper(lookup, c.op());\n+                        var invoke = invoke(lookup, c.op());\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/Backend.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import optkl.OpHelper;\n+import optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n@@ -78,1 +78,1 @@\n-        OpHelper.NamedOpHelper.Invoke.stream(lookup,entry)\n+        Invoke.stream(lookup,entry)\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -141,1 +141,1 @@\n-        var invoke = invokeOpHelper(computeContext.lookup(),invokeOp);\n+        var invoke = invoke(computeContext.lookup(),invokeOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,2 +53,4 @@\n-import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -354,1 +356,1 @@\n-        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldLoadOp);\n+        var fieldAccess = fieldAccess(buildContext.lookup,fieldLoadOp);\n@@ -741,1 +743,1 @@\n-        var invoke = invokeOpHelper(buildContext.lookup,invokeOp);\n+        var invoke = invoke(buildContext.lookup,invokeOp);\n@@ -752,1 +754,1 @@\n-                                && invokeOpHelper(buildContext.lookup,instance.op()) instanceof OpHelper.NamedOpHelper.Invoke invoke0\n+                                && invoke(buildContext.lookup,instance.op()) instanceof Invoke invoke0\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,3 +43,3 @@\n-\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n-import static optkl.Trxfmr.copyLocation;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.copyLocation;\n@@ -52,1 +52,1 @@\n-        if (OpHelper.NamedOpHelper.Invoke.stream(lookup(), funcOp).anyMatch(invoke ->\n+        if (Invoke.stream(lookup(), funcOp).anyMatch(invoke ->\n@@ -61,1 +61,1 @@\n-                    case JavaOp.InvokeOp i when invokeOpHelper(lookup(), i) instanceof OpHelper.NamedOpHelper.Invoke invoke -> {\n+                    case JavaOp.InvokeOp $ when invoke(lookup(), $) instanceof Invoke invoke -> {\n@@ -64,1 +64,1 @@\n-                            var hatVectorBinaryOp = copyLocation(invoke.op(), buildVectorBinaryOp(\n+                            var hatVectorBinaryOp = invoke.copyLocationTo(buildVectorBinaryOp(\n@@ -308,1 +308,1 @@\n-    private boolean isHatVectorBinaryOperation(OpHelper.NamedOpHelper.Invoke invoke) {\n+    private boolean isHatVectorBinaryOperation(Invoke invoke) {\n@@ -386,1 +386,1 @@\n-    private String varNameFromInvokeFirstUse(OpHelper.NamedOpHelper.Invoke invoke) {\n+    private String varNameFromInvokeFirstUse(Invoke invoke) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import optkl.OpHelper;\n@@ -37,2 +36,2 @@\n-\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -45,1 +44,1 @@\n-                     ce-> invokeOpHelper(lookup(),ce) instanceof OpHelper.NamedOpHelper.Invoke $ && $.named(HATBarrierOp.NAME), \/* predicate *\/\n+                     ce-> invoke(lookup(),ce) instanceof Invoke $ && $.named(HATBarrierOp.NAME), \/* predicate *\/\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import optkl.OpHelper;\n@@ -51,3 +50,3 @@\n-\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n-import static optkl.Trxfmr.copyLocation;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.copyLocation;\n@@ -81,1 +80,1 @@\n-                            && invokeOpHelper(lookup,varOpResult.op()) instanceof OpHelper.NamedOpHelper.Invoke invoke && invoke.named(\"array\");\n+                            && invoke(lookup,varOpResult.op()) instanceof Invoke invoke && invoke.named(\"array\");\n@@ -117,1 +116,1 @@\n-    private boolean is16BitFloat(OpHelper.NamedOpHelper.Invoke invoke, Regex methodName) {\n+    private boolean is16BitFloat(Invoke invoke, Regex methodName) {\n@@ -139,1 +138,1 @@\n-    private void createF16ConvOP(OpHelper.NamedOpHelper.Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n+    private void createF16ConvOP(Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n@@ -141,2 +140,1 @@\n-                blockBuilder.op(copyLocation(invoke.op(),\n-                        new HATF16Op.HATF16ConvOp(\n+                blockBuilder.op(invoke.copyLocationTo(new HATF16Op.HATF16ConvOp(\n@@ -161,1 +159,1 @@\n-    private void createFloatFromF16(OpHelper.NamedOpHelper.Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n+    private void createFloatFromF16(Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n@@ -167,2 +165,1 @@\n-                blockBuilder.op(copyLocation(invoke.op(),\n-                        new HATF16Op.HATF16ToFloatConvOp(\n+                blockBuilder.op(invoke.copyLocationTo(new HATF16Op.HATF16ToFloatConvOp(\n@@ -213,1 +210,1 @@\n-        OpHelper.NamedOpHelper.Invoke.stream(lookup(),funcOp)\n+        Invoke.stream(lookup(),funcOp)\n@@ -237,1 +234,1 @@\n-        OpHelper.NamedOpHelper.Invoke.stream(lookup(),funcOp)\n+        Invoke.stream(lookup(),funcOp)\n@@ -261,1 +258,1 @@\n-        OpHelper.NamedOpHelper.Invoke.stream(lookup(),funcOp)\n+        Invoke.stream(lookup(),funcOp)\n@@ -277,1 +274,1 @@\n-                createF16ConvOP(invokeOpHelper(lookup(),invokeOp), blockBuilder, reducedFloatsType.get(invokeOp));\n+                createF16ConvOP(invoke(lookup(),invokeOp), blockBuilder, reducedFloatsType.get(invokeOp));\n@@ -289,1 +286,1 @@\n-                .map(ce->invokeOpHelper(lookup(),ce))\n+                .map(ce-> invoke(lookup(),ce))\n@@ -296,1 +293,1 @@\n-            if (op instanceof JavaOp.InvokeOp $ && invokeOpHelper(lookup(),$) instanceof OpHelper.NamedOpHelper.Invoke invoke) {\n+            if (op instanceof JavaOp.InvokeOp $ && invoke(lookup(),$) instanceof Invoke invoke) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import optkl.OpHelper;\n@@ -50,2 +49,3 @@\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n-import static optkl.Trxfmr.copyLocation;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.copyLocation;\n@@ -74,1 +74,1 @@\n-    protected abstract boolean isIfaceBufferInvokeWithName(OpHelper.NamedOpHelper.Invoke invoke);\n+    protected abstract boolean isIfaceBufferInvokeWithName(Invoke invoke);\n@@ -84,0 +84,1 @@\n+\n@@ -91,2 +92,2 @@\n-                                && result.op() instanceof JavaOp.InvokeOp invokeOp\n-                                && isIfaceBufferInvokeWithName(invokeOpHelper(lookup(),invokeOp)))\n+                                && invoke(lookup(),result.op()) instanceof Invoke invoke\n+                                && isIfaceBufferInvokeWithName(invoke))\n@@ -101,2 +102,2 @@\n-            if (op instanceof JavaOp.InvokeOp invokeOp && mapMe.contains(invokeOp)) {\n-                invokeOp.result().uses().stream()\n+            if (invoke(lookup(),op) instanceof Invoke invoke && mapMe.contains(invoke.op())) {\n+                invoke.op().result().uses().stream()\n@@ -106,1 +107,1 @@\n-                            blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(factory(blockBuilder, varOp, invokeOp)))\n+                            blockBuilder.context().mapValue(invoke.op().result(), blockBuilder.op(factory(blockBuilder, varOp, invoke.op())))\n@@ -124,1 +125,1 @@\n-        protected boolean isIfaceBufferInvokeWithName(OpHelper.NamedOpHelper.Invoke invoke) {\n+        protected boolean isIfaceBufferInvokeWithName(Invoke invoke) {\n@@ -150,1 +151,1 @@\n-        protected boolean isIfaceBufferInvokeWithName(OpHelper.NamedOpHelper.Invoke invoke){\n+        protected boolean isIfaceBufferInvokeWithName(Invoke invoke){\n@@ -175,1 +176,1 @@\n-        protected boolean isIfaceBufferInvokeWithName(OpHelper.NamedOpHelper.Invoke invoke){\n+        protected boolean isIfaceBufferInvokeWithName(Invoke invoke){\n@@ -185,1 +186,1 @@\n-                        if (invokeOpHelper(lookup(),codeElement) instanceof OpHelper.NamedOpHelper.Invoke invoke\n+                        if (invoke(lookup(),codeElement) instanceof Invoke invoke\n@@ -205,2 +206,9 @@\n-               if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                    insertHatMemoryLoadOp(blockBuilder, invokeOp);\n+               if (invoke(lookup(),op) instanceof Invoke invoke) {\n+                   blockBuilder.context().mapValue(invoke.op().result(),\n+                           blockBuilder.op(invoke.copyLocationTo(\n+                                   new HATMemoryDefOp.HATMemoryLoadOp(invoke.returnType(),\n+                                           invoke.refType(),\n+                                           invoke.name(),\n+                                           blockBuilder.context().getValues(invoke.op().operands())))\n+                           )\n+                   );\n@@ -213,11 +221,0 @@\n-\n-        private void insertHatMemoryLoadOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp) {\n-            HATMemoryDefOp.HATMemoryLoadOp loadOp = new HATMemoryDefOp.HATMemoryLoadOp(invokeOp.resultType(),\n-                    invokeOp.invokeDescriptor().refType(),\n-                    invokeOp.invokeDescriptor().name(),\n-                    blockBuilder.context().getValues(invokeOp.operands()));\n-            Op.Result resultLoad = blockBuilder.op(loadOp);\n-            loadOp.setLocation(invokeOp.location());\n-            blockBuilder.context().mapValue(invokeOp.result(), resultLoad);\n-        }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import optkl.OpHelper;\n@@ -40,1 +39,0 @@\n-import java.util.Objects;\n@@ -43,1 +41,3 @@\n-import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n+import static optkl.OpHelper.Named.VarAccess;\n@@ -74,1 +74,1 @@\n-                    if (fieldAccessOpHelper(lookup(),c.op()) instanceof OpHelper.NamedOpHelper.FieldAccess fieldAccess\n+                    if (fieldAccess(lookup(),c.op()) instanceof FieldAccess fieldAccess\n@@ -76,9 +76,4 @@\n-                            && fieldAccess.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp\n-                            && fieldAccess.named(fieldNameRegex)) {\n-                        OpHelper.operandsAsResults(fieldAccess.op())\n-                                .map(OpHelper::opOfResultOrNull)\n-                                .map(OpHelper.NamedOpHelper.VarAccess::asVarLoadOrNull)\n-                                .filter(Objects::nonNull)\n-                                .findFirst()\n-                                .ifPresent(varLoadOp -> {\n-                                    removeMe.add(varLoadOp); \/\/ We will need to remove this\n+                            && fieldAccess.isLoad()\n+                            && fieldAccess.named(fieldNameRegex)\n+                            && fieldAccess.instanceVarAccess() instanceof VarAccess varAccess) {\n+                                    removeMe.add(varAccess.op()); \/\/ We will need to remove this\n@@ -93,2 +88,1 @@\n-                                });\n-                    }\n+                                }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -241,4 +243,2 @@\n-         funcOp.elements()\n-                 .filter(ce->ce instanceof CoreOp.VarOp)\n-                 .map(ce->(CoreOp.VarOp)ce)\n-                 .forEach(varOp-> varOp.operands().stream()\n+        OpHelper.Named.Var.stream(lookup(),funcOp)\n+                 .forEach(var-> var.op().operands().stream()\n@@ -246,1 +246,1 @@\n-                      .map(operand->invokeOpHelper(lookup(),((Op.Result)operand).op()))\n+                      .map(operand-> invoke(lookup(),((Op.Result)operand).op()))\n@@ -252,1 +252,1 @@\n-                            vectorMetaData.put(varOp, vectorTypeInfo);\n+                            vectorMetaData.put(var.op(), vectorTypeInfo);\n@@ -276,1 +276,1 @@\n-                    if (invokeOpHelper(lookup(),codeElement) instanceof OpHelper.NamedOpHelper.Invoke invoke\n+                    if (invoke(lookup(),codeElement) instanceof Invoke invoke\n@@ -317,1 +317,1 @@\n-                                if (invokeOpHelper(lookup(),result.op()) instanceof OpHelper.NamedOpHelper.Invoke invoke ) {\n+                                if (invoke(lookup(),result.op()) instanceof Invoke invoke ) {\n@@ -356,1 +356,1 @@\n-                    if (invokeOpHelper(lookup(),codeElement) instanceof OpHelper.NamedOpHelper.Invoke invoke) {\n+                    if (invoke(lookup(),codeElement) instanceof Invoke invoke) {\n@@ -391,1 +391,1 @@\n-                    if (invokeOpHelper(lookup(),codeElement) instanceof OpHelper.NamedOpHelper.Invoke invoke) {\n+                    if (invoke(lookup(),codeElement) instanceof Invoke invoke) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -43,2 +43,3 @@\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n-import static optkl.Trxfmr.copyLocation;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.copyLocation;\n@@ -85,1 +86,1 @@\n-        OpHelper.NamedOpHelper.Invoke.stream(lookup(),funcOp)\n+        Invoke.stream(lookup(),funcOp)\n@@ -100,1 +101,1 @@\n-            if (invokeOpHelper(lookup(),op) instanceof OpHelper.NamedOpHelper.Invoke invoke\n+            if (invoke(lookup(),op) instanceof Invoke invoke\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -85,1 +85,1 @@\n-                    if (invokeOpHelper(lookup(),codeElement)instanceof OpHelper.NamedOpHelper.Invoke invoke\n+                    if (invoke(lookup(),codeElement)instanceof Invoke invoke\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import optkl.codebuilders.JavaCodeBuilder;\n@@ -42,1 +41,0 @@\n-import optkl.OpHelper;\n@@ -49,2 +47,2 @@\n-\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -172,1 +170,1 @@\n-                .transform(\"usingAbs\", ce -> invokeOpHelper(lookup,ce) instanceof OpHelper.NamedOpHelper.Invoke $\n+                .transform(\"usingAbs\", ce -> invoke(lookup,ce) instanceof Invoke $\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import optkl.OpHelper;\n@@ -32,1 +31,2 @@\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -76,1 +76,1 @@\n-            if (invokeOpHelper(lookup,op) instanceof OpHelper.NamedOpHelper.Invoke ih\n+            if (invoke(lookup,op) instanceof Invoke ih\n@@ -96,1 +96,1 @@\n-                .transform(\"usingAbs\",ce-> OpHelper.NamedOpHelper.Invoke.invokeOpHelper(lookup,ce) instanceof OpHelper.NamedOpHelper.Invoke $\n+                .transform(\"usingAbs\",ce-> invoke(lookup,ce) instanceof Invoke $\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,2 +63,5 @@\n-public sealed interface OpHelper<T extends Op> extends LookupCarrier permits OpHelper.Lambda, OpHelper.NamedOpHelper, OpHelper.Ternary {\n-    T op();\n+public sealed interface OpHelper<T extends Op> extends LookupCarrier permits OpHelper.Lambda, OpHelper.Named, OpHelper.Ternary {\n+    static <F extends Op, T extends Op> T copyLocation(F from, T to) {\n+        to.setLocation(from.location());\n+        return to;\n+    }\n@@ -66,0 +69,5 @@\n+    T op();\n+    default   <TO extends Op> TO copyLocationTo(TO to) {\n+        to.setLocation(op().location());\n+        return to;\n+    }\n@@ -115,5 +123,0 @@\n-\n-    default Op.Result firstOperandAsResultOrThrow(){\n-        return operandNAsResultOrThrow(0);\n-    }\n-\n@@ -145,5 +148,0 @@\n-    static Value operandNOrNull(Op op, int idx) {\n-        return op.operands().size() > idx ? op.operands().get(idx) : null;\n-    }\n-\n-\n@@ -162,6 +160,0 @@\n-    static Stream<Op.Result> operandsAsResults(jdk.incubator.code.CodeElement<?, ?> codeElement) {\n-        return codeElement instanceof Op ?\n-                ((Op) codeElement).operands().stream().filter(o -> o instanceof Op.Result).map(o -> (Op.Result) o)\n-                : Stream.of();\n-    }\n-\n@@ -180,3 +172,0 @@\n-    static Op opOfResultOrNull(Op.Result result) {\n-        return result.op() instanceof Op op ? op : null;\n-    }\n@@ -206,2 +195,2 @@\n-    sealed interface NamedOpHelper<T extends Op> extends OpHelper<T>\n-            permits NamedOpHelper.FieldAccess, NamedOpHelper.Invoke, NamedOpHelper.VarAccess {\n+    sealed interface Named<T extends Op> extends OpHelper<T>\n+            permits Named.NamedStaticOrInstance, Named.Var, Named.VarAccess {\n@@ -219,2 +208,1 @@\n-        sealed interface VarAccess extends NamedOpHelper<CoreOp.VarAccessOp> {\n-\n+        sealed interface VarAccess extends Named<CoreOp.VarAccessOp> {\n@@ -226,5 +214,0 @@\n-            default boolean isPrimitive(){\n-                return op().result().type() instanceof PrimitiveType;\n-            }\n-\n-\n@@ -235,2 +218,2 @@\n-            static VarAccess varAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-                return codeElement instanceof CoreOp.VarAccessOp varAccessOp? new VarAccess.Impl(lookup,varAccessOp): null;\n+            static VarAccess varAccess(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement) {\n+                return codeElement instanceof CoreOp.VarAccessOp varAccessOp ? new VarAccess.Impl(lookup, varAccessOp) : null;\n@@ -238,2 +221,2 @@\n-            static CoreOp.VarAccessOp.VarLoadOp asVarLoadOrNull(Op op) {\n-                return op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp ? varLoadOp : null;\n+            static Stream<VarAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+                return funcOp.elements().filter(ce -> ce instanceof CoreOp.VarAccessOp).map(ce -> varAccess(lookup, ce));\n@@ -242,3 +225,1 @@\n-\n-        sealed interface FieldAccess extends NamedOpHelper<JavaOp.FieldAccessOp> {\n-\n+        sealed interface Var extends Named<CoreOp.VarOp> {\n@@ -247,1 +228,1 @@\n-                return op().fieldDescriptor().name();\n+                return op().varName();\n@@ -250,2 +231,2 @@\n-            default boolean isPrimitive(){\n-                return op().result().type() instanceof PrimitiveType;\n+            default  <T>boolean of(Class<T> clazz){\n+                return isAssignable((JavaType) op().varValueType(),clazz);\n@@ -253,3 +234,6 @@\n-\n-            default TypeElement resultType(){\n-                return op().resultType();\n+            record Impl(MethodHandles.Lookup lookup, CoreOp.VarOp op) implements Var {}\n+            static Var var(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement) {\n+                return codeElement instanceof CoreOp.VarOp varOp ? new Var.Impl(lookup, varOp) : null;\n+            }\n+            static Stream<Var> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+                return funcOp.elements().filter(ce -> ce instanceof CoreOp.VarOp).map(ce -> var(lookup, ce));\n@@ -257,0 +241,4 @@\n+        }\n+\n+        sealed interface NamedStaticOrInstance<T extends Op> extends Named<T> {\n+             boolean isStatic();\n@@ -258,2 +246,7 @@\n-            default TypeElement refType(){\n-                return op().fieldDescriptor().refType();\n+             boolean isInstance();\n+             default Op.Result instance(){\n+                if (isInstance()){\n+                    return (Op.Result) op().operands().getFirst();\n+                }else {\n+                    return null;\n+                }\n@@ -261,2 +254,2 @@\n-            default boolean refType(Class<?> ... classes){\n-                return OpHelper.isAssignable(lookup(),refType(),classes);\n+            default Op instanceOp(){\n+                return instance() instanceof Op.Result result? result.op():null;\n@@ -264,4 +257,28 @@\n-            default  Object getStaticFinalPrimitiveValue() {\n-                if (refType() instanceof ClassType classType) {\n-                    Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n-                    try {\n+            default VarAccess instanceVarAccess(){\n+                 return instanceOp() instanceof CoreOp.VarAccessOp varAccessOp && VarAccess.varAccess(lookup(),varAccessOp) instanceof VarAccess varAccess?varAccess:null;\n+            }\n+            sealed interface FieldAccess extends NamedStaticOrInstance<JavaOp.FieldAccessOp> {\n+\n+                @Override\n+                default String name() {\n+                    return op().fieldDescriptor().name();\n+                }\n+\n+                @Override default boolean isStatic() {\n+                    return operandCount()==0;\n+                }\n+\n+                @Override default boolean isInstance() {\n+                    return !isStatic();\n+                }\n+                default boolean isPrimitive() {\n+                    return op().result().type() instanceof PrimitiveType;\n+                }\n+\n+                default TypeElement resultType() {\n+                    return op().resultType();\n+                }\n+\n+                default TypeElement refType() {\n+                    return op().fieldDescriptor().refType();\n+                }\n@@ -269,4 +286,7 @@\n-                        Field field = clazz.getField(name());\n-                        field.setAccessible(true);\n-                        return field.get(null);\n-                    } catch (NoSuchFieldException | IllegalAccessException e) {\n+                default boolean refType(Class<?>... classes) {\n+                    return OpHelper.isAssignable(lookup(), refType(), classes);\n+                }\n+\n+                default Object getStaticFinalPrimitiveValue() {\n+                    if (refType() instanceof ClassType classType) {\n+                        Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n@@ -274,1 +294,1 @@\n-                            Field field = clazz.getDeclaredField(name());\n+                            Field field = clazz.getField(name());\n@@ -277,2 +297,8 @@\n-                        }catch (NoSuchFieldException |  IllegalAccessException e2){\n-                            throw new RuntimeException(e2);\n+                        } catch (NoSuchFieldException | IllegalAccessException e) {\n+                            try {\n+                                Field field = clazz.getDeclaredField(name());\n+                                field.setAccessible(true);\n+                                return field.get(null);\n+                            } catch (NoSuchFieldException | IllegalAccessException e2) {\n+                                throw new RuntimeException(e2);\n+                            }\n@@ -280,1 +306,0 @@\n-\n@@ -282,0 +307,15 @@\n+                    throw new RuntimeException(\"Could not find field value\" + op());\n+                }\n+                default boolean isLoad(){\n+                    return op() instanceof JavaOp.FieldAccessOp.FieldLoadOp;\n+                }\n+                default boolean isStore(){\n+                    return op() instanceof JavaOp.FieldAccessOp.FieldStoreOp;\n+                }\n+                record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements FieldAccess {\n+                }\n+                static FieldAccess fieldAccess(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+                    return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp ? new FieldAccess.Impl(lookup, fieldAccessOp) : null;\n+                }\n+                static Stream<FieldAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+                    return funcOp.elements().filter(ce -> ce instanceof JavaOp.FieldAccessOp).map(ce -> fieldAccess(lookup, ce));\n@@ -283,1 +323,0 @@\n-                throw new RuntimeException(\"Could not find field value\" + op());\n@@ -285,1 +324,0 @@\n-            record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements FieldAccess {}\n@@ -287,0 +325,4 @@\n+            sealed interface Invoke extends NamedStaticOrInstance<JavaOp.InvokeOp> {\n+                static Stream<Invoke> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+                    return funcOp.elements().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> invoke(lookup, ce));\n+                }\n@@ -288,1 +330,3 @@\n-            static FieldAccess fieldAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+                @Override default boolean isStatic() {\n+                    return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n+                }\n@@ -290,2 +334,3 @@\n-                return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp? new FieldAccess.Impl(lookup,fieldAccessOp): null;\n-            }\n+                @Override default boolean isInstance() {\n+                    return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n+                }\n@@ -293,4 +338,4 @@\n-            static Stream<FieldAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-                return  funcOp.elements().filter(ce->ce instanceof JavaOp.FieldAccessOp).map(ce->fieldAccessOpHelper(lookup,ce));\n-            }\n-        }\n+                @Override\n+                default String name() {\n+                    return op().invokeDescriptor().name();\n+                }\n@@ -298,1 +343,3 @@\n-        sealed interface Invoke extends NamedOpHelper<JavaOp.InvokeOp> {\n+                default <T> boolean returns(Class<T> clazz) {\n+                    return isAssignable((JavaType) op().resultType(), clazz);\n+                }\n@@ -300,3 +347,9 @@\n-            static Stream<Invoke> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-               return  funcOp.elements().filter(ce->ce instanceof JavaOp.InvokeOp).map(ce->invokeOpHelper(lookup,ce));\n-            }\n+                default boolean receives(Class<?>... classes) {\n+                    boolean assignable = true;\n+                    for (int i = isStatic() ? 1 : 0; assignable && i < classes.length; i++) {\n+                        var operand = op().operands().get(i);\n+                        TypeElement resultType = operand.type() instanceof VarType varType ? varType.valueType() : null;\n+                        assignable &= isAssignable((JavaType) resultType, classes[i - (isStatic() ? 1 : 0)]);\n+                    }\n+                    return assignable;\n+                }\n@@ -304,21 +357,7 @@\n-            default  boolean isStatic(){\n-                return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n-            }\n-             default  boolean isInstance(){\n-                return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n-            }\n-            @Override default String name(){\n-                return op().invokeDescriptor().name();\n-            }\n-            default <T>boolean returns(Class<T> clazz){\n-                return isAssignable((JavaType)op().resultType(),clazz);\n-            }\n-            default boolean receives(Class<?>... classes){\n-                boolean  assignable = true;\n-                for (int i=isStatic()?1:0; assignable && i< classes.length; i++) {\n-                    var operand = op().operands().get(i);\n-                    TypeElement resultType = operand.type() instanceof VarType varType?varType.valueType():null;\n-                    assignable &= isAssignable((JavaType) resultType,classes[i-(isStatic()?1:0)]);\n-                }\n-                return assignable;\n-            }\n+                default Method resolvedMethodOrNull() {\n+                    try {\n+                        return op().invokeDescriptor().resolveToMethod(lookup()) instanceof Method method ? method : null;\n+                    } catch (ReflectiveOperationException rope) {\n+                        return null;\n+                    }\n+                }\n@@ -326,5 +365,3 @@\n-            default Method resolvedMethodOrNull(){\n-                try {\n-                    return op().invokeDescriptor().resolveToMethod(lookup()) instanceof Method method ? method : null;\n-                }catch (ReflectiveOperationException rope){\n-                    return null;\n+\n+                default boolean refIs(Class<?>... classes) {\n+                    return OpHelper.isAssignable(lookup(), op().invokeDescriptor().refType(), classes);\n@@ -332,1 +369,0 @@\n-            }\n@@ -334,0 +370,3 @@\n+                default boolean returnsArray() {\n+                    return op().resultType() instanceof ArrayType;\n+                }\n@@ -335,3 +374,3 @@\n-             default boolean refIs(Class<?> ...classes) {\n-                return OpHelper.isAssignable(lookup(), op().invokeDescriptor().refType(), classes);\n-            }\n+                default boolean returnsVoid() {\n+                    return op().invokeDescriptor().type().returnType().equals(JavaType.VOID);\n+                }\n@@ -339,3 +378,3 @@\n-             default boolean returnsArray() {\n-                return op().resultType() instanceof ArrayType;\n-            }\n+                default TypeElement returnType() {\n+                    return op().invokeDescriptor().type().returnType();\n+                }\n@@ -343,3 +382,3 @@\n-             default boolean returnsVoid() {\n-                return op().invokeDescriptor().type().returnType().equals(JavaType.VOID);\n-            }\n+                default boolean returnsInt() {\n+                    return returnType().equals(JavaType.INT);\n+                }\n@@ -347,3 +386,0 @@\n-             default   TypeElement returnType() {\n-                return op().invokeDescriptor().type().returnType();\n-            }\n@@ -351,3 +387,3 @@\n-            default boolean returnsInt(){\n-                return returnType().equals(JavaType.INT);\n-            }\n+                default boolean returnsClassType() {\n+                    return returnType() instanceof ClassType;\n+                }\n@@ -356,0 +392,3 @@\n+                default TypeElement refType() {\n+                    return op().invokeDescriptor().refType();\n+                }\n@@ -357,3 +396,3 @@\n-            default boolean returnsClassType(){\n-                return returnType() instanceof ClassType;\n-            }\n+                default boolean returnsPrimitive() {\n+                    return returnType() instanceof PrimitiveType;\n+                }\n@@ -361,0 +400,3 @@\n+                default boolean returnsFloat() {\n+                    return returnType() == JavaType.FLOAT;\n+                }\n@@ -362,3 +404,3 @@\n-            default TypeElement refType(){\n-                return op().invokeDescriptor().refType();\n-            }\n+                default boolean returnsChar() {\n+                    return returnType() == JavaType.CHAR;\n+                }\n@@ -366,20 +408,2 @@\n-            default boolean returnsPrimitive(){\n-                return returnType() instanceof PrimitiveType ;\n-            }\n-            default boolean returnsFloat(){\n-                return returnType() == JavaType.FLOAT;\n-            }\n-            default boolean returnsChar(){\n-               return returnType() ==   JavaType.CHAR;\n-            }\n-            default boolean returnsShort(){\n-                return returnType() ==   JavaType.SHORT ;\n-            }\n-            default boolean returns16BitValue(){\n-                return returnsChar()||returnsShort();\n-            }\n-            default Method resolveMethodOrNull() {\n-                try {\n-                    return op().invokeDescriptor().resolveToMethod(lookup());\n-                } catch (ReflectiveOperationException e) {\n-                   return null;\n+                default boolean returnsShort() {\n+                    return returnType() == JavaType.SHORT;\n@@ -387,6 +411,3 @@\n-            }\n-            default Method resolveMethodOrThrow() {\n-                try {\n-                    return op().invokeDescriptor().resolveToMethod(lookup());\n-                } catch (ReflectiveOperationException e) {\n-                    throw new RuntimeException(e);\n+\n+                default boolean returns16BitValue() {\n+                    return returnsChar() || returnsShort();\n@@ -394,1 +415,0 @@\n-            }\n@@ -396,5 +416,6 @@\n-            default Class<?> classOrThrow() {\n-                if (refType() instanceof ClassType classType) {\n-                    return (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n-                } else {\n-                    throw new IllegalStateException(\" javaRef class is null\");\n+                default Method resolveMethodOrNull() {\n+                    try {\n+                        return op().invokeDescriptor().resolveToMethod(lookup());\n+                    } catch (ReflectiveOperationException e) {\n+                        return null;\n+                    }\n@@ -402,1 +423,0 @@\n-            }\n@@ -404,3 +424,7 @@\n-            default boolean isMappableIface() {\n-                return refIs(MappableIface.class);\n-            }\n+                default Method resolveMethodOrThrow() {\n+                    try {\n+                        return op().invokeDescriptor().resolveToMethod(lookup());\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n@@ -408,6 +432,6 @@\n-           default List<AccessType.TypeAndAccess> paramaterAccessList(){\n-                Annotation[][] parameterAnnotations =  resolveMethodOrThrow().getParameterAnnotations();\n-                int firstParam =isInstance()?1:0; \/\/ if virtual\n-                List<AccessType.TypeAndAccess> typeAndAccesses = new ArrayList<>();\n-                for (int i = firstParam; i < operandCount(); i++) {\n-                    typeAndAccesses.add(AccessType.TypeAndAccess.of(parameterAnnotations[i - firstParam], op().operands().get(i)));\n+                default Class<?> classOrThrow() {\n+                    if (refType() instanceof ClassType classType) {\n+                        return (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n+                    } else {\n+                        throw new IllegalStateException(\" javaRef class is null\");\n+                    }\n@@ -415,2 +439,0 @@\n-                return typeAndAccesses;\n-            }\n@@ -418,1 +440,3 @@\n-            record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Invoke {}\n+                default boolean isMappableIface() {\n+                    return refIs(MappableIface.class);\n+                }\n@@ -420,1 +444,9 @@\n-            static Invoke invokeOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+                default List<AccessType.TypeAndAccess> paramaterAccessList() {\n+                    Annotation[][] parameterAnnotations = resolveMethodOrThrow().getParameterAnnotations();\n+                    int firstParam = isInstance() ? 1 : 0; \/\/ if virtual\n+                    List<AccessType.TypeAndAccess> typeAndAccesses = new ArrayList<>();\n+                    for (int i = firstParam; i < operandCount(); i++) {\n+                        typeAndAccesses.add(AccessType.TypeAndAccess.of(parameterAnnotations[i - firstParam], op().operands().get(i)));\n+                    }\n+                    return typeAndAccesses;\n+                }\n@@ -422,5 +454,0 @@\n-                return codeElement instanceof JavaOp.InvokeOp invokeOp? new Invoke.Impl(lookup,invokeOp): null;\n-            }\n-            default Op.Result returnResult(){\n-                return op().result();\n-            }\n@@ -428,8 +455,20 @@\n-            static Invoke getTargetInvoke(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n-                return lambdaOp.body().entryBlock().ops().stream()\n-                        .filter(ce -> ce instanceof JavaOp.InvokeOp)\n-                        .map(ce -> invokeOpHelper(lookup,ce))\n-                        .filter(Invoke::isStatic)\n-                        .filter(invoke -> OpHelper.isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n-                        .findFirst()\n-                        .orElseThrow();\n+                record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Invoke {\n+                }\n+\n+                static Invoke invoke(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+                    return codeElement instanceof JavaOp.InvokeOp invokeOp ? new Impl(lookup, invokeOp) : null;\n+                }\n+\n+                default Op.Result returnResult() {\n+                    return op().result();\n+                }\n+\n+                static Invoke getTargetInvoke(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n+                    return lambdaOp.body().entryBlock().ops().stream()\n+                            .filter(ce -> ce instanceof JavaOp.InvokeOp)\n+                            .map(ce -> invoke(lookup, ce))\n+                            .filter(Invoke::isStatic)\n+                            .filter(invoke -> OpHelper.isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n+                            .findFirst()\n+                            .orElseThrow();\n+                }\n@@ -486,5 +525,0 @@\n-\n-        default boolean isPrimitive(){\n-            return op().result().type() instanceof PrimitiveType;\n-        }\n-\n@@ -495,3 +529,1 @@\n-        default Block condBlock() {\n-            return OpHelper.entryBlockOfBodyN(op(), 0);\n-        }\n+        default Block condBlock() {return OpHelper.entryBlockOfBodyN(op(), 0);}\n@@ -507,2 +539,1 @@\n-        static Ternary ternaryOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-\n+        static Ternary ternary(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n@@ -514,4 +545,0 @@\n-        default boolean isPrimitive(){\n-            return op().result().type() instanceof PrimitiveType;\n-        }\n-\n@@ -523,1 +550,0 @@\n-\n@@ -527,1 +553,0 @@\n-\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":220,"deletions":195,"binary":false,"changes":415,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -54,4 +53,0 @@\n-    public static <F extends Op, T extends Op> T copyLocation(F from, T to) {\n-        to.setLocation(from.location());\n-        return to;\n-    }\n@@ -220,1 +215,1 @@\n-                    var result = trxfmr.opToResultOp(op(),builder().op(copyLocation(op(), replacement)));\n+                    var result = trxfmr.opToResultOp(op(),builder().op(OpHelper.copyLocation(op(), replacement)));\n@@ -230,1 +225,1 @@\n-                    var result = trxfmr.opToResultOp(op(),builder().op(copyLocation(op(), newOne)));\n+                    var result = trxfmr.opToResultOp(op(),builder().op(OpHelper.copyLocation(op(), newOne)));\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -728,1 +728,2 @@\n-        return blockInlineComment(\"varName of varLoadOp?\");\/\/varName(varOp.varOp());\n+        blockInlineComment(varOp.toString());\n+        return self();\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/CodeBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.code.Block;\n@@ -41,3 +42,3 @@\n-import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n-import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n-import static optkl.OpHelper.Ternary.ternaryOpHelper;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Ternary.ternary;\n@@ -120,3 +121,11 @@\n-            }else {\n-\n-                blockInlineComment(\"how \"+first);\n+            }else if (first instanceof Block.Parameter parameter) {\n+               var p1 =  parameter.declaringBlock().parameters().getFirst();\n+\n+                var r = parameter.uses().iterator().next();\n+                \/\/parenthesisIfNeeded(buildContext, varOp, r.op());\n+               \/\/ if (r.op() instanceof CoreOp.VarOp varOp1){\n+                 \/\/   identifier(varOp1.varName());\n+               \/\/ }\n+              blockInlineComment(\"param \"+r);\n+            }else{\n+                blockInlineComment(\"look at varOp \"+first);\n@@ -136,1 +145,1 @@\n-        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldLoadOp);\n+        var fieldAccess = fieldAccess(buildContext.lookup,fieldLoadOp);\n@@ -147,1 +156,1 @@\n-        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldStoreOp);\n+        var fieldAccess = fieldAccess(buildContext.lookup,fieldStoreOp);\n@@ -354,1 +363,1 @@\n-        var invoke = invokeOpHelper(buildContext.lookup,invokeOp);\n+        var invoke = invoke(buildContext.lookup,invokeOp);\n@@ -367,1 +376,1 @@\n-        OpHelper.Ternary ternary = ternaryOpHelper(buildContext.lookup,ternaryOp);\n+        OpHelper.Ternary ternary = ternary(buildContext.lookup,ternaryOp);\n@@ -464,2 +473,2 @@\n-            keyword(\"var\").space().blockInlineComment(\"v\").space().colon().space();\n-            \/\/  enhancedForOp.initialization().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(builderContext, o));\n+            enhancedForOp.initialization().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(builderContext, o));\n+            space().colon().space().blockInlineComment(\"Get rid of = before this\");\n@@ -467,2 +476,0 @@\n-            \/\/ enhancedForOp.loopBody().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(builderContext, o));\n-            \/\/ recurse(builderContext,exp);\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaOrC99StyleCodeBuilder.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"}]}