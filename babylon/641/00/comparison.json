{"files":[{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.util;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public record Regex(Pattern pattern) {\n+    public interface Match {\n+        boolean matched();\n+    }\n+\n+    public interface OK extends Match {\n+        Regex regex();\n+        Matcher matcher();\n+        default  String string(int idx) {\n+            return matcher().group(idx);\n+        }\n+        static float hex2Float(String s) {\n+            return (s.startsWith(\"-\")) ?\n+                    (-Integer.parseInt(s.substring(2), 16) \/ 64f): (Integer.parseInt(s.substring(1), 16) \/ 64f);\n+        }\n+        default float f(int idx) {\n+            return hex2Float(string(idx));\n+        }\n+\n+        default  int i(int idx) {\n+            return Integer.parseInt(string(idx));\n+        }\n+    }\n+\n+\n+    public record DefaultOk(Regex regex, Matcher matcher, boolean matched) implements OK {\n+        public static OK of(Regex regex, Matcher matcher) {\n+            return new DefaultOk(regex, matcher, true);\n+        }\n+    }\n+\n+    record FAIL(boolean matched) implements Match {\n+        public static FAIL of() {\n+            return new FAIL(false);\n+        }\n+    }\n+\n+    public static Regex of(String... strings) {\n+        return new Regex(Pattern.compile(String.join(\"\", strings)));\n+    }\n+\n+    public static Match any(String line, Regex... regexes) {\n+        for (Regex r : regexes) {\n+            if (r.is(line) instanceof OK ok) {\n+                return ok;\n+            }\n+        }\n+        return FAIL.of();\n+    }\n+    public Match is(String s, Predicate<Matcher> matcherPredicate, BiFunction<Regex,Matcher,OK> factory) {\n+        if (pattern.matcher(s) instanceof Matcher matcher && matcher.matches() && matcherPredicate.test(matcher)) {\n+            return factory.apply(this, matcher);\n+        } else {\n+            return FAIL.of();\n+        }\n+    }\n+    public Match is(String s, Predicate<Matcher> matcherPredicate) {\n+        return is(s, matcherPredicate,(r,m)->new DefaultOk(r,m, true));\n+    }\n+    public Match is(String s) {\n+        return is(s, _->true);\n+    }\n+    public boolean matches(String s, Predicate<Matcher> matcherPredicate) {\n+        return is(s, matcherPredicate).matched();\n+    }\n+    public boolean matches(String s) {\n+        return is(s).matched();\n+    }\n+    public boolean matchesOrThrow(String s) {\n+        if(!is(s).matched()){\n+            throw new RuntimeException(\"failed expected match\");\n+        }else{\n+            return true;\n+        }\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/util\/Regex.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -32,2 +32,2 @@\n-    public StreamMutable<R> set(R value) {\n-        this.value = value;\n+    public StreamMutable<R> setIf(boolean iff,R value) {\n+        this.value = iff?value:this.value;\n@@ -36,0 +36,6 @@\n+    public StreamMutable<R> set(R value) {\n+      return setIf(true, value);\n+    }\n+    public boolean eq(R r){\n+        return r.equals(value);\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/util\/StreamMutable.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+\n@@ -253,1 +254,1 @@\n-    static void crossGroupScan(@RO KernelContext kc, @RW S32Array dataBuf) {\n+    static void crossGroupScan(@RO KernelContext kc, @RW S32Array dataBuf) {\/*\n@@ -287,1 +288,1 @@\n-        kc.barrier();\n+        kc.barrier(); *\/\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import hat.util.Regex;\n+import hat.util.StreamMutable;\n@@ -37,2 +39,0 @@\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n@@ -40,0 +40,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -42,6 +43,0 @@\n-    static Regex remRegex = Regex.of(\"^ *REM(.*)$\");\n-    static Regex colonRegex = Regex.of(\"^ *(:) *$\");\n-    static Regex verticesRegex = Regex.of( \"^ *(vertices) *$\");\n-    static Regex facesRegex = Regex.of(\"^ *(faces) *$\");\n-    static Regex hueLigSatRegex = Regex.of(\"^ *(hue-lig-sat) *$\");\n-\n@@ -55,4 +50,4 @@\n-    static Regex face6Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"6\" ,commaRegexStr, decCommaRegexStr.repeat(5), decRegexStr, \" *$\");\n-    static Regex face5Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"5\" ,commaRegexStr, decCommaRegexStr.repeat(4), decRegexStr, \" *$\");\n-    static Regex face4Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"4\" ,commaRegexStr, decCommaRegexStr.repeat(3), decRegexStr, \" *$\");\n-    static Regex face3Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"3\" ,commaRegexStr, decCommaRegexStr.repeat(2), decRegexStr, \" *$\");\n+    static Regex face6Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"6\", commaRegexStr, decCommaRegexStr.repeat(5), decRegexStr, \" *$\");\n+    static Regex face5Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"5\", commaRegexStr, decCommaRegexStr.repeat(4), decRegexStr, \" *$\");\n+    static Regex face4Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"4\", commaRegexStr, decCommaRegexStr.repeat(3), decRegexStr, \" *$\");\n+    static Regex face3Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"3\", commaRegexStr, decCommaRegexStr.repeat(2), decRegexStr, \" *$\");\n@@ -60,1 +55,0 @@\n-    static Regex frontLaserVertexRegex = Regex.of( \"^ *\" + hexRegexStr + \" *$\");\n@@ -62,2 +56,0 @@\n-    static Regex vertexCountRegex = Regex.of(\"^ *\" + hexCommaRegexStr + hexRegexStr + \" *$\");\n-    static Regex nameRegex = Regex.of(\"^ *([A-Za-z][0-9A-Za-z]+) *$\");\n@@ -65,0 +57,3 @@\n+    static Regex remRegex = Regex.of(\"^ *REM(.*)$\");\n+    static Regex colonRegex = Regex.of(\"^ *(:) *$\");\n+    static Regex facesRegex = Regex.of(\"^ *(faces) *$\");\n@@ -66,3 +61,20 @@\n-\n-\n-    enum State {AWAITING_NAME, AWAITING_LAZER, AWAITING_COUNTS, AWAITING_VERTICES, AWAITING_HUE_LIG_SAT, AWAITING_FACES}\n+    interface St {\n+        default String name(){\n+            return this.getClass().getSimpleName();\n+        }\n+        record awaiting_name(Regex r) implements St {}\n+        record awaiting_lazer(Regex r) implements St {}\n+        record awaiting_counts(Regex r) implements St {}\n+        record awaiting_vertices(Regex r) implements St {}\n+        record awaiting_hue_lig_sat(Regex r) implements St {}\n+        record awaiting_faces() implements St { }\n+        record done() implements St{}\n+        awaiting_name awaiting_name = new awaiting_name( Regex.of(\"^ *([A-Za-z][0-9A-Za-z]+) *$\"));\n+        awaiting_lazer awaiting_lazer = new awaiting_lazer(Regex.of(\"^ *\" + hexRegexStr + \" *$\"));\n+        awaiting_counts awaiting_counts = new awaiting_counts(Regex.of(\"^ *\" + hexCommaRegexStr + hexRegexStr + \" *$\"));\n+        awaiting_vertices awaiting_vertices = new awaiting_vertices(Regex.of(\"^ *(vertices) *$\"));\n+        awaiting_hue_lig_sat awaiting_hue_lig_sat = new awaiting_hue_lig_sat(Regex.of(\"^ *(hue-lig-sat) *$\"));\n+        awaiting_faces awaiting_faces = new awaiting_faces();\n+        done done  = new done();\n+        \/\/St[] all = new St[]{awaiting_name, awaiting_lazer, awaiting_counts, awaiting_vertices, awaiting_hue_lig_sat, awaiting_faces};\n+    }\n@@ -71,14 +83,22 @@\n-        try {\n-            BufferedReader reader = new BufferedReader(new InputStreamReader(EliteMeshReader.class.getResourceAsStream(\"\/meshes\/Elite.txt\")));\n-\n-            State state = State.AWAITING_NAME;\n-            F32Mesh3D mesh= null;\n-            for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n-                line = line.trim();\n-                if (!Regex.any(line, remRegex,emptyRegex,colonRegex).matched()) {\n-                    switch (state) {\n-                        case AWAITING_NAME ->{\n-                            if (nameRegex.is(line) instanceof Regex.OK ok && ok.string(1).equals(name)) {\n-                                state = State.AWAITING_LAZER;\n-                                mesh = F32Mesh3D.of(name);\n-                            }\n+        final var mesh = StreamMutable.of((F32Mesh3D) null);\n+        final var st = StreamMutable.of((St) St.awaiting_name);\n+        new BufferedReader(\n+                new InputStreamReader(EliteMeshReader.class.getResourceAsStream(\"\/meshes\/Elite.txt\"), StandardCharsets.UTF_8))\n+                .lines()\n+                .map(String::trim)\n+                .forEach(line -> {\n+                   \/\/ System.out.println(st.get().name());\n+                    if (st.get() instanceof St.awaiting_name(Regex r) && r.matches(line, whoseMatcher -> whoseMatcher.group(1).equals(name))) {\n+                        st.set(St.awaiting_lazer);\n+                        mesh.set(F32Mesh3D.of(name));\n+                    } else if (st.get() instanceof St.awaiting_lazer(Regex r)) {\n+                        st.setIf(r.matches(line), St.awaiting_counts);\n+                    } else if (st.get() instanceof St.awaiting_counts(Regex r)) {\n+                        st.setIf(r.matches(line), St.awaiting_vertices);\n+                    } else if (st.get() instanceof St.awaiting_vertices(Regex r)) {\n+                        st.setIf(r.matches(line), St.awaiting_faces);\n+                    } else if (st.get() instanceof St.awaiting_faces s) {\n+                        if (vertexRegex.is(line) instanceof Regex.OK ok) {\n+                            mesh.get().vec3(ok.f(1), ok.f(2), ok.f(3));\n+                        } else if (facesRegex.matchesOrThrow(line)) {\n+                            st.set(St.awaiting_hue_lig_sat);\n@@ -86,28 +106,11 @@\n-                        case AWAITING_LAZER-> state = frontLaserVertexRegex.is(line).matched()?State.AWAITING_COUNTS:state;\n-                        case AWAITING_COUNTS-> state  =vertexCountRegex.is(line).matched()?State.AWAITING_VERTICES:state;\n-                        case AWAITING_VERTICES-> state = verticesRegex.is(line).matched()?State.AWAITING_FACES:state;\n-                        case AWAITING_FACES->{\n-                            if (vertexRegex.is(line) instanceof Regex.OK ok) {\n-                                mesh.vec3(ok.f(1),  ok.f(2), ok.f(3));\n-                            } else if (facesRegex.is(line).matched()) {\n-                                state = State.AWAITING_HUE_LIG_SAT;\n-                            }\n-                        }\n-                        case AWAITING_HUE_LIG_SAT-> {\n-                            if (Regex.any(line,face6Regex,face5Regex,face4Regex,face3Regex) instanceof Regex.OK ok) {\n-                                int v0 = mesh.vecEntries[ok.i(6)];\n-                                int v1 = mesh.vecEntries[ok.i(7)];\n-                                int v2 = mesh.vecEntries[ok.i(8)];\n-\n-                                if (ok.regex() == face3Regex){\n-                                    mesh.tri(v0, v1, v2,  0x00ff00 );\n-                                }else if (ok.regex() == face4Regex) {\n-                                    mesh.quad(v0, v1,v2, mesh.vecEntries[ok.i(9)],  0xff0000);\n-                                } else if (ok.regex()== face5Regex) {\n-                                    mesh.pent(v0, v1, v2, mesh.vecEntries[ok.i(9)], mesh.vecEntries[ok.i(10)], 0x0000ff);\n-                                } else {\n-                                    mesh.hex(v0, v1, v2, mesh.vecEntries[ok.i(9)], mesh.vecEntries[ok.i(10)], mesh.vecEntries[ok.i(11)], 0xfff000);\n-                                }\n-                            } else if ((hueLigSatRegex.is(line).matched())) {\n-                                mesh.fin();\n-                                return;\n+                    } else if (st.get() instanceof St.awaiting_hue_lig_sat(Regex r)) {\n+                        if (Regex.any(line, face6Regex, face5Regex, face4Regex, face3Regex) instanceof Regex.OK ok) {\n+                            int v0 = mesh.get().vecEntries[ok.i(6)];\n+                            int v1 = mesh.get().vecEntries[ok.i(7)];\n+                            int v2 = mesh.get().vecEntries[ok.i(8)];\n+                            if (ok.regex() == face3Regex) {\n+                                mesh.get().tri(v0, v1, v2, 0x00ff00);\n+                            } else if (ok.regex() == face4Regex) {\n+                                mesh.get().quad(v0, v1, v2, mesh.get().vecEntries[ok.i(9)], 0xff0000);\n+                            } else if (ok.regex() == face5Regex) {\n+                                mesh.get().pent(v0, v1, v2, mesh.get().vecEntries[ok.i(9)], mesh.get().vecEntries[ok.i(10)], 0x0000ff);\n@@ -115,1 +118,1 @@\n-                                System.out.println(\"In \" + state + \" skipping \" + line);\n+                                mesh.get().hex(v0, v1, v2, mesh.get().vecEntries[ok.i(9)], mesh.get().vecEntries[ok.i(10)], mesh.get().vecEntries[ok.i(11)], 0xfff000);\n@@ -117,0 +120,5 @@\n+                        } else if (r.matches(line)) {\n+                            mesh.get().fin();\n+                            st.set(St.done);\n+                        }else if (!remRegex.matches(line)){\n+                            System.out.println(\"UNHANDLED \"+line);\n@@ -118,2 +126,4 @@\n-                        default->  throw new IllegalStateException((\"WHAt \" + line));\n-\n+                    }else if (st.get() instanceof St.done){\n+                        \/\/ we don't care\n+                    } else if (st.get() instanceof St &&  Regex.any(line, remRegex, emptyRegex, colonRegex).matched()) {\n+                        \/\/ we dont care ;)\n@@ -121,7 +131,1 @@\n-                }\n-            }\n-        } catch (FileNotFoundException e) {\n-            e.printStackTrace();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n+                });\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/EliteMeshReader.java","additions":74,"deletions":70,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        \/\/\/args.add(\"ANACONDA\");\n+        \/\/args.add(\"COBRA\");\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view;\n-\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-record Regex(Pattern pattern) {\n-    interface Match {\n-        boolean matched();\n-    }\n-\n-    record OK(Regex regex, Matcher matcher, boolean matched) implements Match {\n-        public static OK of(Regex regex, Matcher matcher) {\n-            return new OK(regex, matcher, true);\n-        }\n-        float hex2Float(String s) {\n-            return (s.startsWith(\"-\"))? (-Integer.parseInt(s.substring(2), 16) \/ 64f): (Integer.parseInt(s.substring(1), 16) \/ 64f);\n-        }\n-        public float f(int idx) {\n-            return hex2Float(string(idx));\n-        }\n-\n-        public int i(int idx) {\n-            return Integer.parseInt(string(idx));\n-        }\n-\n-        public String string(int idx) {\n-            return matcher.group(idx);\n-        }\n-    }\n-\n-    record FAIL(boolean matched) implements Match {\n-        public static FAIL of() {\n-            return new FAIL(false);\n-        }\n-    }\n-\n-    static Regex of(String... strings) {\n-        return new Regex(Pattern.compile(String.join(\"\", strings)));\n-    }\n-\n-    static Match any(String line, Regex... regexes) {\n-        for (Regex r : regexes) {\n-            if (r.is(line) instanceof OK ok) {\n-                return ok;\n-            }\n-        }\n-        return FAIL.of();\n-    }\n-\n-    Match is(String s) {\n-        if (pattern.matcher(s) instanceof Matcher matcher && matcher.matches()) {\n-            return OK.of(this, matcher);\n-        } else {\n-            return FAIL.of();\n-        }\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Regex.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -0,0 +1,1 @@\n+-cp build\/hat-core-1.0.jar  hat.FFIConfigCreator\n","filename":"hat\/hat\/ffisync","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"}]}