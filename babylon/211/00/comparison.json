{"files":[{"patch":"@@ -76,20 +76,1 @@\n-    sealed interface JavaStatement permits\n-            ArrayAccessOp.ArrayStoreOp,\n-            AssertOp,\n-            FieldAccessOp.FieldStoreOp,\n-            InvokeOp,\n-            NewOp,\n-            ReturnOp,\n-            ThrowOp,\n-            VarAccessOp.VarStoreOp,\n-            VarOp,\n-            ExtendedOp.JavaBlockOp,\n-            ExtendedOp.JavaDoWhileOp,\n-            ExtendedOp.JavaEnhancedForOp,\n-            ExtendedOp.JavaForOp,\n-            ExtendedOp.JavaIfOp,\n-            ExtendedOp.JavaLabelOp,\n-            ExtendedOp.JavaLabeledOp,\n-            ExtendedOp.JavaTryOp,\n-            ExtendedOp.JavaWhileOp,\n-            ExtendedOp.JavaYieldOp {\n+    sealed interface JavaStatement permits ArrayAccessOp.ArrayStoreOp, AssertOp, FieldAccessOp.FieldStoreOp, InvokeOp, NewOp, ReturnOp, ThrowOp, VarAccessOp.VarStoreOp, VarOp, ExtendedOp.JavaBlockOp, ExtendedOp.JavaDoWhileOp, ExtendedOp.JavaEnhancedForOp, ExtendedOp.JavaForOp, ExtendedOp.JavaIfOp, ExtendedOp.JavaLabelOp, ExtendedOp.JavaLabeledOp, ExtendedOp.JavaSwitchStatementOp, ExtendedOp.JavaTryOp, ExtendedOp.JavaWhileOp, ExtendedOp.JavaYieldOp {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -901,0 +901,55 @@\n+    \/**\n+     * The switch statement operation, that can model Java language switch statement.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaSwitchStatementOp.NAME)\n+    public static final class JavaSwitchStatementOp extends ExtendedOp\n+            implements Op.Nested, JavaStatement {\n+        public static final String NAME = \"java.switch.statement\";\n+\n+        final List<Body> bodies;\n+\n+        public JavaSwitchStatementOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaSwitchStatementOp(JavaSwitchStatementOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaSwitchStatementOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchStatementOp(this, cc, ot);\n+        }\n+\n+        JavaSwitchStatementOp(Value target, List<Body.Builder> bodyCs) {\n+            super(NAME, List.of(target));\n+\n+            \/\/ Each case is modelled as a contiguous pair of bodies\n+            \/\/ The first body models the case labels, and the second models the case statements\n+            \/\/ The labels body has a parameter whose type is target operand's type and returns a boolean value\n+            \/\/ The statements body has no parameters and returns void\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n@@ -3048,0 +3103,10 @@\n+    \/**\n+     * Creates a switch statement operation.\n+     * @param target the switch target value\n+     * @param bodies the body builders of the operation to be built and become its children\n+     * @return the switch statement operation\n+     *\/\n+    public static JavaSwitchStatementOp switchStatement(Value target, List<Body.Builder> bodies) {\n+        return new JavaSwitchStatementOp(target, bodies);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -452,1 +452,1 @@\n-                Tag.SWITCH, Tag.SYNCHRONIZED,\n+                Tag.SYNCHRONIZED,\n@@ -1640,0 +1640,147 @@\n+        @Override\n+        public void visitSwitch(JCTree.JCSwitch tree) {\n+            Value target = toValue(tree.selector);\n+\n+            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n+            FunctionType actionType = FunctionType.VOID;\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            for (JCTree.JCCase c : tree.cases) {\n+                \/\/ Labels body\n+                JCTree.JCCaseLabel headCl = c.labels.head;\n+                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                    if (c.labels.size() > 1) {\n+                        throw unsupported(c);\n+                    }\n+\n+                    pushBody(pcl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.guard != null) {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+\n+                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                        Value patVal = scanPattern(pcl.pat, localTarget);\n+                        append(CoreOp._yield(patVal));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                        append(CoreOp._yield(toValue(c.guard)));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        localResult = append(ExtendedOp.conditionalAnd(clBodies));\n+                    } else {\n+                        localResult = scanPattern(pcl.pat, localTarget);\n+                    }\n+                    \/\/ Yield the boolean result of the condition\n+                    append(CoreOp._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                    pushBody(headCl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.labels.size() == 1) {\n+                        Value expr = toValue(ccl.expr);\n+                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                        \/\/ so, we convert constant to the type of the selector expression\n+                        expr = convert(expr, tree.selector.type);\n+                        if (tree.selector.type.isPrimitive()) {\n+                            localResult = append(CoreOp.eq(localTarget, expr));\n+                        } else {\n+                            localResult = append(CoreOp.invoke(\n+                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                    localTarget, expr));\n+                        }\n+                    } else {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+                        for (JCTree.JCCaseLabel cl : c.labels) {\n+                            ccl = (JCTree.JCConstantCaseLabel) cl;\n+                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n+\n+                            Value expr = toValue(ccl.expr);\n+                            expr = convert(expr, tree.selector.type);\n+                            final Value labelResult;\n+                            if (tree.selector.type.isPrimitive()) {\n+                                labelResult = append(CoreOp.eq(localTarget, expr));\n+                            } else {\n+                                labelResult = append(CoreOp.invoke(\n+                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                        localTarget, expr));\n+                            }\n+\n+                            append(CoreOp._yield(labelResult));\n+                            clBodies.add(stack.body);\n+\n+                            \/\/ Pop label\n+                            popBody();\n+                        }\n+\n+                        localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                    }\n+\n+                    append(CoreOp._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop labels\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                    \/\/ @@@ Do we need to model the default label body?\n+                    pushBody(headCl, FunctionType.VOID);\n+\n+                    append(CoreOp._yield());\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else {\n+                    throw unsupported(tree);\n+                }\n+\n+                \/\/ Statements body\n+                switch (c.caseKind) {\n+                    case RULE -> {\n+                        pushBody(c.body, actionType);\n+                        \/\/ we should add yield when no break\n+                        if (c.body instanceof JCTree.JCExpressionStatement es) {\n+                            Value bodyVal = toValue(es);\n+                            append(CoreOp._yield());\n+                        }\n+                        else if (c.body instanceof JCTree.JCBlock b) {\n+                            toValue(b);\n+                            if (!(b.stats.last() instanceof JCTree.JCBreak)) {\n+                                append(CoreOp._yield());\n+                            }\n+                        }\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                    case STATEMENT -> {\n+                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                        pushBody(c, actionType);\n+\n+                        scan(c.stats);\n+\n+                        appendTerminating(c.completesNormally ?\n+                                headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n+                                : CoreOp::unreachable);\n+\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                };\n+            }\n+\n+            result = append(ExtendedOp.switchStatement(target, bodies));\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":148,"deletions":1,"binary":false,"changes":149,"status":"modified"}]}