{"files":[{"patch":"@@ -95,1 +95,2 @@\n-            ExtendedOp.JavaYieldOp {\n+            ExtendedOp.JavaYieldOp,\n+            ExtendedOp.JavaSwitchStatementOp {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-            } while (!(op instanceof Op.Loop));\n+            } while (!(op instanceof Op.Loop || op instanceof JavaSwitchStatementOp));\n@@ -127,2 +127,8 @@\n-            Op.Loop lop = (Op.Loop) op;\n-            return lop.loopBody() == b ? op : null;\n+            if (op instanceof Op.Loop lop) {\n+                return lop.loopBody() == b ? op : null;\n+            } else if (op instanceof JavaSwitchStatementOp swStat) {\n+                return swStat.bodies().contains(b) ? op : null;\n+            } else {\n+                \/\/ @@@ can't happen (at least for now)\n+                throw new IllegalStateException();\n+            }\n@@ -903,0 +909,167 @@\n+    \/**\n+     * The switch statement operation, that can model Java language switch statement.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaSwitchStatementOp.NAME)\n+    public static final class JavaSwitchStatementOp extends ExtendedOp\n+            implements Op.Nested, JavaStatement, Op.Lowerable {\n+        public static final String NAME = \"java.switch.statement\";\n+\n+        final List<Body> bodies;\n+\n+        public JavaSwitchStatementOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaSwitchStatementOp(JavaSwitchStatementOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaSwitchStatementOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchStatementOp(this, cc, ot);\n+        }\n+\n+        JavaSwitchStatementOp(Value target, List<Body.Builder> bodyCs) {\n+            super(NAME, List.of(target));\n+\n+            \/\/ Each case is modelled as a contiguous pair of bodies\n+            \/\/ The first body models the case labels, and the second models the case statements\n+            \/\/ The labels body has a parameter whose type is target operand's type and returns a boolean value\n+            \/\/ The statements body has no parameters and returns void\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+\n+            Value selectorExpression = b.context().getValue(operands().get(0));\n+\n+            \/\/ @@@ we can add this during model generation\n+            \/\/ if no case null, add one that throws NPE\n+            if (!(selectorExpression.type() instanceof PrimitiveType) && !haveNullCase()) {\n+                Block.Builder throwBlock = b.block();\n+                throwBlock.op(_throw(\n+                        throwBlock.op(_new(FunctionType.functionType(JavaType.type(NullPointerException.class))))\n+                ));\n+\n+                Block.Builder continueBlock = b.block();\n+\n+                Result p = b.op(invoke(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                        selectorExpression, b.op(constant(J_L_OBJECT, null))));\n+                b.op(conditionalBranch(p, throwBlock.successor(), continueBlock.successor()));\n+\n+                b = continueBlock;\n+            }\n+\n+            List<Block.Builder> blocks = new ArrayList<>();\n+            for (int i = 0; i < bodies().size(); i++) {\n+                Block.Builder bb = b.block();\n+                if (i == 0) {\n+                    bb = b;\n+                }\n+                blocks.add(bb);\n+            }\n+\n+            Block.Builder exit;\n+            if (bodies.isEmpty()) {\n+                exit = b;\n+            } else {\n+                exit = b.block();\n+            }\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            \/\/ map statement body to nextExprBlock\n+            \/\/ this mapping will be used for lowering SwitchFallThroughOp\n+            for (int i = 1; i < bodies().size() - 2; i+=2) {\n+                setBranchTarget(b.context(), bodies().get(i), new BranchTarget(null, blocks.get(i + 2)));\n+            }\n+\n+            for (int i = 0; i < bodies().size(); i++) {\n+                boolean isLabelBody = i % 2 == 0;\n+                Block.Builder curr = blocks.get(i);\n+                if (isLabelBody) {\n+                    Block.Builder statement = blocks.get(i + 1);\n+                    boolean isLastLabel = i == blocks.size() - 2;\n+                    Block.Builder nextLabel = isLastLabel ? null : blocks.get(i + 2);\n+                    curr.transformBody(bodies().get(i), List.of(selectorExpression), opT.andThen((block, op) -> {\n+                        switch (op) {\n+                            case YieldOp yop -> {\n+                                if (isLastLabel) {\n+                                    block.op(branch(statement.successor()));\n+                                } else {\n+                                    block.op(conditionalBranch(\n+                                            block.context().getValue(yop.yieldValue()),\n+                                            statement.successor(),\n+                                            nextLabel.successor()\n+                                    ));\n+                                }\n+                            }\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                } else { \/\/ statement body\n+                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n+                        switch (op) {\n+                            case YieldOp yop -> block.op(branch(exit.successor()));\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                }\n+            }\n+\n+            return exit;\n+        }\n+\n+        private boolean haveNullCase() {\n+            \/*\n+            case null is modeled like this:\n+            (%4 : T)boolean -> {\n+                %5 : java.lang.Object = constant @null;\n+                %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                yield %6;\n+            }\n+            * *\/\n+            for (int i = 0; i < bodies().size() - 2; i+=2) {\n+                Body labelBody = bodies().get(i);\n+                if (labelBody.blocks().size() != 1) {\n+                    continue; \/\/ we skip, for now\n+                }\n+                Op terminatingOp = bodies().get(i).entryBlock().terminatingOp();\n+                \/\/@@@ when op pattern matching is ready, we can use it\n+                if (terminatingOp instanceof YieldOp yieldOp &&\n+                        yieldOp.yieldValue() instanceof Op.Result opr &&\n+                        opr.op() instanceof InvokeOp invokeOp &&\n+                        invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class)) &&\n+                        invokeOp.operands().stream().anyMatch(o -> o instanceof Op.Result r && r.op() instanceof ConstantOp cop && cop.value() == null)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n@@ -3050,0 +3223,10 @@\n+    \/**\n+     * Creates a switch statement operation.\n+     * @param target the switch target value\n+     * @param bodies the body builders of the operation to be built and become its children\n+     * @return the switch statement operation\n+     *\/\n+    public static JavaSwitchStatementOp switchStatement(Value target, List<Body.Builder> bodies) {\n+        return new JavaSwitchStatementOp(target, bodies);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":186,"deletions":3,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -452,1 +452,1 @@\n-                Tag.SWITCH, Tag.SYNCHRONIZED,\n+                Tag.SYNCHRONIZED,\n@@ -842,1 +842,7 @@\n-                    case PLUS_ASG -> append(CoreOp.add(lhs, rhs));\n+                    case PLUS_ASG -> {\n+                        if (tree.operator.opcode == ByteCodes.string_add) {\n+                            yield append(CoreOp.concat(lhs, rhs));\n+                        } else {\n+                            yield append(CoreOp.add(lhs, rhs));\n+                        }\n+                    }\n@@ -1669,0 +1675,174 @@\n+        @Override\n+        public void visitSwitch(JCTree.JCSwitch tree) {\n+            Value target = toValue(tree.selector);\n+\n+            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n+            FunctionType actionType = FunctionType.VOID;\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            for (JCTree.JCCase c : tree.cases) {\n+                \/\/ Labels body\n+                JCTree.JCCaseLabel headCl = c.labels.head;\n+                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                    if (c.labels.size() > 1) {\n+                        throw unsupported(c);\n+                    }\n+\n+                    pushBody(pcl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.guard != null) {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+\n+                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                        Value patVal = scanPattern(pcl.pat, localTarget);\n+                        append(CoreOp._yield(patVal));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                        append(CoreOp._yield(toValue(c.guard)));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        localResult = append(ExtendedOp.conditionalAnd(clBodies));\n+                    } else {\n+                        localResult = scanPattern(pcl.pat, localTarget);\n+                    }\n+                    \/\/ Yield the boolean result of the condition\n+                    append(CoreOp._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                    pushBody(headCl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.labels.size() == 1) {\n+                        Value expr = toValue(ccl.expr);\n+                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                        \/\/ so, we convert constant to the type of the selector expression\n+                        expr = convert(expr, tree.selector.type);\n+                        if (tree.selector.type.isPrimitive()) {\n+                            localResult = append(CoreOp.eq(localTarget, expr));\n+                        } else {\n+                            localResult = append(CoreOp.invoke(\n+                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                    localTarget, expr));\n+                        }\n+                    } else {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+                        for (JCTree.JCCaseLabel cl : c.labels) {\n+                            ccl = (JCTree.JCConstantCaseLabel) cl;\n+                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n+\n+                            Value expr = toValue(ccl.expr);\n+                            expr = convert(expr, tree.selector.type);\n+                            final Value labelResult;\n+                            if (tree.selector.type.isPrimitive()) {\n+                                labelResult = append(CoreOp.eq(localTarget, expr));\n+                            } else {\n+                                labelResult = append(CoreOp.invoke(\n+                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                        localTarget, expr));\n+                            }\n+\n+                            append(CoreOp._yield(labelResult));\n+                            clBodies.add(stack.body);\n+\n+                            \/\/ Pop label\n+                            popBody();\n+                        }\n+\n+                        localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                    }\n+\n+                    append(CoreOp._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop labels\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                    \/\/ @@@ Do we need to model the default label body?\n+                    pushBody(headCl, FunctionType.VOID);\n+\n+                    append(CoreOp._yield());\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else {\n+                    throw unsupported(tree);\n+                }\n+\n+                \/\/ Statements body\n+                switch (c.caseKind) {\n+                    case RULE -> {\n+                        pushBody(c.body, actionType);\n+                        if (c.body instanceof JCTree.JCBlock b) {\n+                            toValue(b);\n+                            if (!(b.stats.last() instanceof JCTree.JCBreak)) {\n+                                append(CoreOp._yield()); \/\/ @@@ _break is also an option\n+                            }\n+                        }\n+                        else if (c.body instanceof JCTree.JCStatement s) {\n+                            toValue(s);\n+                            if (!(s instanceof JCTree.JCThrow)) {\n+                                append(CoreOp._yield());\n+                            }\n+                        }\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                    case STATEMENT -> {\n+                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                        pushBody(c, actionType);\n+\n+                        scan(c.stats);\n+\n+                        appendTerminating(c.completesNormally ?\n+                                headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n+                                : CoreOp::unreachable);\n+\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                };\n+            }\n+\n+            \/\/ if enhanced switch and no default label\n+            \/\/ enhanced: target type not byte, char short, int, String, or, has case pattern or case null\n+            boolean enhancedSw = !List.of(JavaType.BYTE, JavaType.CHAR, JavaType.SHORT, JavaType.INT,\n+                    JavaType.J_L_BYTE, JavaType.J_L_CHARACTER, JavaType.J_L_SHORT, JavaType.J_L_INTEGER,\n+                    JavaType.J_L_STRING).contains(typeToTypeElement(tree.selector.type));\n+            enhancedSw = enhancedSw && !Flags.isEnum(tree.selector.type.tsym);\n+            enhancedSw = enhancedSw || tree.patternSwitch;\n+            enhancedSw = enhancedSw || tree.cases.stream().anyMatch(c -> c.labels.stream().anyMatch(l -> {\n+                return l instanceof JCTree.JCConstantCaseLabel ccl && ccl.expr instanceof JCLiteral literal && literal.value == null;\n+            }));\n+            if (enhancedSw && !tree.hasUnconditionalPattern) {\n+                \/\/ label\n+                pushBody(tree, FunctionType.VOID);\n+                append(CoreOp._yield());\n+                bodies.add(stack.body);\n+                popBody();\n+\n+                \/\/ statement\n+                pushBody(tree, actionType);\n+                append(CoreOp._throw(\n+                        append(CoreOp._new(FunctionType.functionType(JavaType.type(MatchException.class))))\n+                ));\n+                bodies.add(stack.body);\n+                popBody();\n+            }\n+\n+            result = append(ExtendedOp.switchStatement(target, bodies));\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":182,"deletions":2,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+* @test\n+* @run testng TestSwitchStatementOp\n+* *\/\n+public class TestSwitchStatementOp {\n+\n+    @Test\n+    void testCaseConstantBehaviorIsSyntaxIndependent() {\n+        CoreOp.FuncOp ruleExpression = lower(\"caseConstantRuleExpression\");\n+        CoreOp.FuncOp ruleBlock = lower(\"caseConstantRuleBlock\");\n+        CoreOp.FuncOp statement = lower(\"caseConstantStatement\");\n+\n+        String[] args = {\"FOO\", \"BAR\", \"BAZ\", \"OTHER\"};\n+\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static String caseConstantRuleExpression(String r) {\n+        String s = \"\";\n+        switch (r) {\n+            case \"FOO\" -> s += \"BAR\";\n+            case \"BAR\" -> s += \"BAZ\";\n+            case \"BAZ\" -> s += \"FOO\";\n+            default -> s += \"else\";\n+        }\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String caseConstantRuleBlock(String r) {\n+        String s = \"\";\n+        switch (r) {\n+            case \"FOO\" -> {\n+                s += \"BAR\";\n+            }\n+            case \"BAR\" -> {\n+                s += \"BAZ\";\n+            }\n+            case \"BAZ\" -> {\n+                s += \"FOO\";\n+            }\n+            default -> {\n+                s += \"else\";\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    private static String caseConstantStatement(String s) {\n+        String r = \"\";\n+        switch (s) {\n+            case \"FOO\":\n+                r += \"BAR\";\n+                break;\n+            case \"BAR\":\n+                r += \"BAZ\";\n+                break;\n+            case \"BAZ\":\n+                r += \"FOO\";\n+                break;\n+            default:\n+                r += \"else\";\n+        }\n+        return r;\n+    }\n+\n+    @Test\n+    void testCaseConstantMultiLabels() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantMultiLabels\");\n+        char[] args = {'a', 'e', 'i', 'o', 'u', 'j', 'p', 'g'};\n+        for (char arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantMultiLabels(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static String caseConstantMultiLabels(char c) {\n+        String r = \"\";\n+        switch (Character.toLowerCase(c)) {\n+            case 'a', 'e', 'i', 'o', 'u':\n+                r += \"vowel\";\n+                break;\n+            default:\n+                r += \"consonant\";\n+        }\n+        return r;\n+    }\n+\n+    @Test\n+    void testCaseConstantThrow() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantThrow\");\n+\n+        Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, 8));\n+\n+        int[] args = {9, 10};\n+        for (int arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantThrow(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static String caseConstantThrow(Integer i) {\n+        String r = \"\";\n+        switch (i) {\n+            case 8 -> throw new IllegalArgumentException();\n+            case 9 -> r += \"Nine\";\n+            default -> r += \"An integer\";\n+        }\n+        return r;\n+    }\n+\n+    private static CoreOp.FuncOp lower(String methodName) {\n+        return lower(getCodeModel(methodName));\n+    }\n+\n+    private static CoreOp.FuncOp lower(CoreOp.FuncOp f) {\n+        writeModel(f, System.out, OpWriter.LocationOption.DROP_LOCATION);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        writeModel(lf, System.out, OpWriter.LocationOption.DROP_LOCATION);\n+\n+        return lf;\n+    }\n+\n+    private static void writeModel(CoreOp.FuncOp f, OutputStream os, OpWriter.Option... options) {\n+        StringWriter sw = new StringWriter();\n+        new OpWriter(sw, options).writeOp(f);\n+        try {\n+            os.write(sw.toString().getBytes());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static CoreOp.FuncOp getCodeModel(String methodName) {\n+        Optional<Method> om = Stream.of(TestSwitchStatementOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchStatementOp.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,1940 @@\n+import java.lang.runtime.CodeReflection;\n+import java.util.Collection;\n+import java.util.RandomAccess;\n+import java.util.Stack;\n+\n+\/*\n+ * @test\n+ * @build SwitchStatementTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester SwitchStatementTest\n+ *\/\n+public class SwitchStatementTest {\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantRuleExpression\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"s\";\n+                %4 : java.lang.String = var.load %1;\n+                java.switch.statement %4\n+                    (%5 : java.lang.String)boolean -> {\n+                        %6 : java.lang.String = constant @\"FOO\";\n+                        %7 : boolean = invoke %5 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %7;\n+                    }\n+                    ()void -> {\n+                        %8 : java.lang.String = var.load %3;\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : java.lang.String = add %8 %9;\n+                        var.store %3 %10;\n+                        yield;\n+                    }\n+                    (%11 : java.lang.String)boolean -> {\n+                        %12 : java.lang.String = constant @\"BAR\";\n+                        %13 : boolean = invoke %11 %12 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %13;\n+                    }\n+                    ()void -> {\n+                        %14 : java.lang.String = var.load %3;\n+                        %15 : java.lang.String = constant @\"BAZ\";\n+                        %16 : java.lang.String = add %14 %15;\n+                        var.store %3 %16;\n+                        yield;\n+                    }\n+                    (%17 : java.lang.String)boolean -> {\n+                        %18 : java.lang.String = constant @\"BAZ\";\n+                        %19 : boolean = invoke %17 %18 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %19;\n+                    }\n+                    ()void -> {\n+                        %20 : java.lang.String = var.load %3;\n+                        %21 : java.lang.String = constant @\"FOO\";\n+                        %22 : java.lang.String = add %20 %21;\n+                        var.store %3 %22;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %23 : java.lang.String = var.load %3;\n+                        %24 : java.lang.String = constant @\"else\";\n+                        %25 : java.lang.String = add %23 %24;\n+                        var.store %3 %25;\n+                        yield;\n+                    };\n+                %26 : java.lang.String = var.load %3;\n+                return %26;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    public static String caseConstantRuleExpression(String r) {\n+        String s = \"\";\n+        switch (r) {\n+            case \"FOO\" -> s += \"BAR\";\n+            case \"BAR\" -> s += \"BAZ\";\n+            case \"BAZ\" -> s += \"FOO\";\n+            default -> s += \"else\";\n+        }\n+        return s;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantRuleBlock\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"s\";\n+                %4 : java.lang.String = var.load %1;\n+                java.switch.statement %4\n+                    (%5 : java.lang.String)boolean -> {\n+                        %6 : java.lang.String = constant @\"FOO\";\n+                        %7 : boolean = invoke %5 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %7;\n+                    }\n+                    ()void -> {\n+                        %8 : java.lang.String = var.load %3;\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : java.lang.String = add %8 %9;\n+                        var.store %3 %10;\n+                        yield;\n+                    }\n+                    (%11 : java.lang.String)boolean -> {\n+                        %12 : java.lang.String = constant @\"BAR\";\n+                        %13 : boolean = invoke %11 %12 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %13;\n+                    }\n+                    ()void -> {\n+                        %14 : java.lang.String = var.load %3;\n+                        %15 : java.lang.String = constant @\"BAZ\";\n+                        %16 : java.lang.String = add %14 %15;\n+                        var.store %3 %16;\n+                        yield;\n+                    }\n+                    (%17 : java.lang.String)boolean -> {\n+                        %18 : java.lang.String = constant @\"BAZ\";\n+                        %19 : boolean = invoke %17 %18 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %19;\n+                    }\n+                    ()void -> {\n+                        %20 : java.lang.String = var.load %3;\n+                        %21 : java.lang.String = constant @\"FOO\";\n+                        %22 : java.lang.String = add %20 %21;\n+                        var.store %3 %22;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %23 : java.lang.String = var.load %3;\n+                        %24 : java.lang.String = constant @\"else\";\n+                        %25 : java.lang.String = add %23 %24;\n+                        var.store %3 %25;\n+                        yield;\n+                    };\n+                %26 : java.lang.String = var.load %3;\n+                return %26;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    public static String caseConstantRuleBlock(String r) {\n+        String s = \"\";\n+        switch (r) {\n+            case \"FOO\" -> {\n+                s += \"BAR\";\n+            }\n+            case \"BAR\" -> {\n+                s += \"BAZ\";\n+            }\n+            case \"BAZ\" -> {\n+                s += \"FOO\";\n+            }\n+            default -> {\n+                s += \"else\";\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantStatement\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : java.lang.String = var.load %1;\n+                java.switch.statement %4\n+                    (%5 : java.lang.String)boolean -> {\n+                        %6 : java.lang.String = constant @\"FOO\";\n+                        %7 : boolean = invoke %5 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %7;\n+                    }\n+                    ()void -> {\n+                        %8 : java.lang.String = var.load %3;\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : java.lang.String = add %8 %9;\n+                        var.store %3 %10;\n+                        java.break;\n+                    }\n+                    (%11 : java.lang.String)boolean -> {\n+                        %12 : java.lang.String = constant @\"BAR\";\n+                        %13 : boolean = invoke %11 %12 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %13;\n+                    }\n+                    ()void -> {\n+                        %14 : java.lang.String = var.load %3;\n+                        %15 : java.lang.String = constant @\"BAZ\";\n+                        %16 : java.lang.String = add %14 %15;\n+                        var.store %3 %16;\n+                        java.break;\n+                    }\n+                    (%17 : java.lang.String)boolean -> {\n+                        %18 : java.lang.String = constant @\"BAZ\";\n+                        %19 : boolean = invoke %17 %18 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %19;\n+                    }\n+                    ()void -> {\n+                        %20 : java.lang.String = var.load %3;\n+                        %21 : java.lang.String = constant @\"FOO\";\n+                        %22 : java.lang.String = add %20 %21;\n+                        var.store %3 %22;\n+                        java.break;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %23 : java.lang.String = var.load %3;\n+                        %24 : java.lang.String = constant @\"else\";\n+                        %25 : java.lang.String = add %23 %24;\n+                        var.store %3 %25;\n+                        yield;\n+                    };\n+                %26 : java.lang.String = var.load %3;\n+                return %26;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantStatement(String s) {\n+        String r = \"\";\n+        switch (s) {\n+            case \"FOO\":\n+                r += \"BAR\";\n+                break;\n+            case \"BAR\":\n+                r += \"BAZ\";\n+                break;\n+            case \"BAZ\":\n+                r += \"FOO\";\n+                break;\n+            default:\n+                r += \"else\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantMultiLabels\" (%0 : char)java.lang.String -> {\n+                %1 : Var<char> = var %0 @\"c\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : char = var.load %1;\n+                %5 : char = invoke %4 @\"java.lang.Character::toLowerCase(char)char\";\n+                java.switch.statement %5\n+                    (%6 : char)boolean -> {\n+                        %7 : boolean = java.cor\n+                            ()boolean -> {\n+                                %8 : char = constant @\"a\";\n+                                %9 : boolean = eq %6 %8;\n+                                yield %9;\n+                            }\n+                            ()boolean -> {\n+                                %10 : char = constant @\"e\";\n+                                %11 : boolean = eq %6 %10;\n+                                yield %11;\n+                            }\n+                            ()boolean -> {\n+                                %12 : char = constant @\"i\";\n+                                %13 : boolean = eq %6 %12;\n+                                yield %13;\n+                            }\n+                            ()boolean -> {\n+                                %14 : char = constant @\"o\";\n+                                %15 : boolean = eq %6 %14;\n+                                yield %15;\n+                            }\n+                            ()boolean -> {\n+                                %16 : char = constant @\"u\";\n+                                %17 : boolean = eq %6 %16;\n+                                yield %17;\n+                            };\n+                        yield %7;\n+                    }\n+                    ()void -> {\n+                        %18 : java.lang.String = var.load %3;\n+                        %19 : java.lang.String = constant @\"vowel\";\n+                        %20 : java.lang.String = add %18 %19;\n+                        var.store %3 %20;\n+                        java.break;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %21 : java.lang.String = var.load %3;\n+                        %22 : java.lang.String = constant @\"consonant\";\n+                        %23 : java.lang.String = add %21 %22;\n+                        var.store %3 %23;\n+                        yield;\n+                    };\n+                %24 : java.lang.String = var.load %3;\n+                return %24;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantMultiLabels(char c) {\n+        String r = \"\";\n+        switch (Character.toLowerCase(c)) {\n+            case 'a', 'e', 'i', 'o', 'u':\n+                r += \"vowel\";\n+                break;\n+            default:\n+                r += \"consonant\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantThrow\" (%0 : java.lang.Integer)java.lang.String -> {\n+                %1 : Var<java.lang.Integer> = var %0 @\"i\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : java.lang.Integer = var.load %1;\n+                java.switch.statement %4\n+                    (%5 : java.lang.Integer)boolean -> {\n+                        %6 : int = constant @\"8\";\n+                        %7 : java.lang.Integer = invoke %6 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %8 : boolean = invoke %5 %7 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %8;\n+                    }\n+                    ()void -> {\n+                        %9 : java.lang.IllegalArgumentException = new @\"func<java.lang.IllegalArgumentException>\";\n+                        throw %9;\n+                    }\n+                    (%10 : java.lang.Integer)boolean -> {\n+                        %11 : int = constant @\"9\";\n+                        %12 : java.lang.Integer = invoke %11 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %13 : boolean = invoke %10 %12 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %13;\n+                    }\n+                    ()void -> {\n+                        %14 : java.lang.String = var.load %3;\n+                        %15 : java.lang.String = constant @\"Nine\";\n+                        %16 : java.lang.String = add %14 %15;\n+                        var.store %3 %16;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %17 : java.lang.String = var.load %3;\n+                        %18 : java.lang.String = constant @\"An integer\";\n+                        %19 : java.lang.String = add %17 %18;\n+                        var.store %3 %19;\n+                        yield;\n+                    };\n+                %20 : java.lang.String = var.load %3;\n+                return %20;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantThrow(Integer i) {\n+        String r = \"\";\n+        switch (i) {\n+            case 8 -> throw new IllegalArgumentException();\n+            case 9 -> r += \"Nine\";\n+            default -> r += \"An integer\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantNullLabel\" (%0 : java.lang.String)java.lang.String -> {\n+                  %1 : Var<java.lang.String> = var %0 @\"s\";\n+                  %2 : java.lang.String = constant @\"\";\n+                  %3 : Var<java.lang.String> = var %2 @\"r\";\n+                  %4 : java.lang.String = var.load %1;\n+                  java.switch.statement %4\n+                      (%5 : java.lang.String)boolean -> {\n+                          %6 : java.lang.Object = constant @null;\n+                          %7 : boolean = invoke %5 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                          yield %7;\n+                      }\n+                      ()void -> {\n+                          %8 : java.lang.String = var.load %3;\n+                          %9 : java.lang.String = constant @\"null\";\n+                          %10 : java.lang.String = add %8 %9;\n+                          var.store %3 %10;\n+                          yield;\n+                      }\n+                      ()void -> {\n+                          yield;\n+                      }\n+                      ()void -> {\n+                          %11 : java.lang.String = var.load %3;\n+                          %12 : java.lang.String = constant @\"non null\";\n+                          %13 : java.lang.String = add %11 %12;\n+                          var.store %3 %13;\n+                          yield;\n+                      };\n+                  %14 : java.lang.String = var.load %3;\n+                  return %14;\n+              };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantNullLabel(String s) {\n+        String r = \"\";\n+        switch (s) {\n+            case null -> r += \"null\";\n+            default -> r += \"non null\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantFallThrough\" (%0 : char)java.lang.String -> {\n+                %1 : Var<char> = var %0 @\"c\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : char = var.load %1;\n+                java.switch.statement %4\n+                    (%5 : char)boolean -> {\n+                        %6 : char = constant @\"A\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()void -> {\n+                        java.switch.fallthrough;\n+                    }\n+                    (%8 : char)boolean -> {\n+                        %9 : char = constant @\"B\";\n+                        %10 : boolean = eq %8 %9;\n+                        yield %10;\n+                    }\n+                    ()void -> {\n+                        %11 : java.lang.String = var.load %3;\n+                        %12 : java.lang.String = constant @\"A or B\";\n+                        %13 : java.lang.String = add %11 %12;\n+                        var.store %3 %13;\n+                        java.break;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %14 : java.lang.String = var.load %3;\n+                        %15 : java.lang.String = constant @\"Neither A nor B\";\n+                        %16 : java.lang.String = add %14 %15;\n+                        var.store %3 %16;\n+                        yield;\n+                    };\n+                %17 : java.lang.String = var.load %3;\n+                return %17;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantFallThrough(char c) {\n+        String r = \"\";\n+        switch (c) {\n+            case 'A':\n+            case 'B':\n+                r += \"A or B\";\n+                break;\n+            default:\n+                r += \"Neither A nor B\";\n+        }\n+        return r;\n+    }\n+\n+    enum Day {\n+        MON, TUE, WED, THU, FRI, SAT, SUN\n+    }\n+    @IR(\"\"\"\n+            func @\"caseConstantEnum\" (%0 : SwitchStatementTest$Day)java.lang.String -> {\n+                %1 : Var<SwitchStatementTest$Day> = var %0 @\"d\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : SwitchStatementTest$Day = var.load %1;\n+                java.switch.statement %4\n+                    (%5 : SwitchStatementTest$Day)boolean -> {\n+                        %6 : boolean = java.cor\n+                            ()boolean -> {\n+                                %7 : SwitchStatementTest$Day = field.load @\"SwitchStatementTest$Day::MON()SwitchStatementTest$Day\";\n+                                %8 : boolean = invoke %5 %7 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %8;\n+                            }\n+                            ()boolean -> {\n+                                %9 : SwitchStatementTest$Day = field.load @\"SwitchStatementTest$Day::FRI()SwitchStatementTest$Day\";\n+                                %10 : boolean = invoke %5 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %10;\n+                            }\n+                            ()boolean -> {\n+                                %11 : SwitchStatementTest$Day = field.load @\"SwitchStatementTest$Day::SUN()SwitchStatementTest$Day\";\n+                                %12 : boolean = invoke %5 %11 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %12;\n+                            };\n+                        yield %6;\n+                    }\n+                    ()void -> {\n+                        %13 : java.lang.String = var.load %3;\n+                        %14 : int = constant @\"6\";\n+                        %15 : java.lang.Integer = invoke %14 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %16 : java.lang.String = add %13 %15;\n+                        var.store %3 %16;\n+                        yield;\n+                    }\n+                    (%17 : SwitchStatementTest$Day)boolean -> {\n+                        %18 : SwitchStatementTest$Day = field.load @\"SwitchStatementTest$Day::TUE()SwitchStatementTest$Day\";\n+                        %19 : boolean = invoke %17 %18 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %19;\n+                    }\n+                    ()void -> {\n+                        %20 : java.lang.String = var.load %3;\n+                        %21 : int = constant @\"7\";\n+                        %22 : java.lang.Integer = invoke %21 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %23 : java.lang.String = add %20 %22;\n+                        var.store %3 %23;\n+                        yield;\n+                    }\n+                    (%24 : SwitchStatementTest$Day)boolean -> {\n+                        %25 : boolean = java.cor\n+                            ()boolean -> {\n+                                %26 : SwitchStatementTest$Day = field.load @\"SwitchStatementTest$Day::THU()SwitchStatementTest$Day\";\n+                                %27 : boolean = invoke %24 %26 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %27;\n+                            }\n+                            ()boolean -> {\n+                                %28 : SwitchStatementTest$Day = field.load @\"SwitchStatementTest$Day::SAT()SwitchStatementTest$Day\";\n+                                %29 : boolean = invoke %24 %28 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %29;\n+                            };\n+                        yield %25;\n+                    }\n+                    ()void -> {\n+                        %30 : java.lang.String = var.load %3;\n+                        %31 : int = constant @\"8\";\n+                        %32 : java.lang.Integer = invoke %31 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %33 : java.lang.String = add %30 %32;\n+                        var.store %3 %33;\n+                        yield;\n+                    }\n+                    (%34 : SwitchStatementTest$Day)boolean -> {\n+                        %35 : SwitchStatementTest$Day = field.load @\"SwitchStatementTest$Day::WED()SwitchStatementTest$Day\";\n+                        %36 : boolean = invoke %34 %35 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %36;\n+                    }\n+                    ()void -> {\n+                        %37 : java.lang.String = var.load %3;\n+                        %38 : int = constant @\"9\";\n+                        %39 : java.lang.Integer = invoke %38 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %40 : java.lang.String = add %37 %39;\n+                        var.store %3 %40;\n+                        yield;\n+                    };\n+                %41 : java.lang.String = var.load %3;\n+                return %41;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantEnum(Day d) {\n+        String r = \"\";\n+        switch (d) {\n+            \/\/ @@@ concat of String and int is modeled as: add str Integer\n+            case MON, FRI, SUN -> r += 6;\n+            case TUE -> r += 7;\n+            case THU, SAT -> r += 8;\n+            case WED -> r += 9;\n+        }\n+        return r;\n+    }\n+\n+    static class Constants {\n+        static final int c1 = 12;\n+    }\n+    @IR(\"\"\"\n+            func @\"caseConstantOtherKindsOfExpr\" (%0 : int)java.lang.String -> {\n+                %1 : Var<int> = var %0 @\"i\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : int = constant @\"11\";\n+                %5 : Var<int> = var %4 @\"eleven\";\n+                %6 : int = var.load %1;\n+                java.switch.statement %6\n+                    (%7 : int)boolean -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : int = constant @\"15\";\n+                        %10 : int = and %8 %9;\n+                        %11 : boolean = eq %7 %10;\n+                        yield %11;\n+                    }\n+                    ()void -> {\n+                        %12 : java.lang.String = var.load %3;\n+                        %13 : int = constant @\"1\";\n+                        %14 : java.lang.Integer = invoke %13 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %15 : java.lang.String = add %12 %14;\n+                        var.store %3 %15;\n+                        yield;\n+                    }\n+                    (%16 : int)boolean -> {\n+                        %17 : int = constant @\"4\";\n+                        %18 : int = constant @\"1\";\n+                        %19 : int = ashr %17 %18;\n+                        %20 : boolean = eq %16 %19;\n+                        yield %20;\n+                    }\n+                    ()void -> {\n+                        %21 : java.lang.String = var.load %3;\n+                        %22 : java.lang.String = constant @\"2\";\n+                        %23 : java.lang.String = add %21 %22;\n+                        var.store %3 %23;\n+                        yield;\n+                    }\n+                    (%24 : int)boolean -> {\n+                        %25 : long = constant @\"3\";\n+                        %26 : int = conv %25;\n+                        %27 : boolean = eq %24 %26;\n+                        yield %27;\n+                    }\n+                    ()void -> {\n+                        %28 : java.lang.String = var.load %3;\n+                        %29 : int = constant @\"3\";\n+                        %30 : java.lang.Integer = invoke %29 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %31 : java.lang.String = add %28 %30;\n+                        var.store %3 %31;\n+                        yield;\n+                    }\n+                    (%32 : int)boolean -> {\n+                        %33 : int = constant @\"2\";\n+                        %34 : int = constant @\"1\";\n+                        %35 : int = lshl %33 %34;\n+                        %36 : boolean = eq %32 %35;\n+                        yield %36;\n+                    }\n+                    ()void -> {\n+                        %37 : java.lang.String = var.load %3;\n+                        %38 : int = constant @\"4\";\n+                        %39 : java.lang.Integer = invoke %38 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %40 : java.lang.String = add %37 %39;\n+                        var.store %3 %40;\n+                        yield;\n+                    }\n+                    (%41 : int)boolean -> {\n+                        %42 : int = constant @\"10\";\n+                        %43 : int = constant @\"2\";\n+                        %44 : int = div %42 %43;\n+                        %45 : boolean = eq %41 %44;\n+                        yield %45;\n+                    }\n+                    ()void -> {\n+                        %46 : java.lang.String = var.load %3;\n+                        %47 : int = constant @\"5\";\n+                        %48 : java.lang.Integer = invoke %47 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %49 : java.lang.String = add %46 %48;\n+                        var.store %3 %49;\n+                        yield;\n+                    }\n+                    (%50 : int)boolean -> {\n+                        %51 : int = constant @\"12\";\n+                        %52 : int = constant @\"6\";\n+                        %53 : int = sub %51 %52;\n+                        %54 : boolean = eq %50 %53;\n+                        yield %54;\n+                    }\n+                    ()void -> {\n+                        %55 : java.lang.String = var.load %3;\n+                        %56 : int = constant @\"6\";\n+                        %57 : java.lang.Integer = invoke %56 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %58 : java.lang.String = add %55 %57;\n+                        var.store %3 %58;\n+                        yield;\n+                    }\n+                    (%59 : int)boolean -> {\n+                        %60 : int = constant @\"3\";\n+                        %61 : int = constant @\"4\";\n+                        %62 : int = add %60 %61;\n+                        %63 : boolean = eq %59 %62;\n+                        yield %63;\n+                    }\n+                    ()void -> {\n+                        %64 : java.lang.String = var.load %3;\n+                        %65 : int = constant @\"7\";\n+                        %66 : java.lang.Integer = invoke %65 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %67 : java.lang.String = add %64 %66;\n+                        var.store %3 %67;\n+                        yield;\n+                    }\n+                    (%68 : int)boolean -> {\n+                        %69 : int = constant @\"2\";\n+                        %70 : int = constant @\"2\";\n+                        %71 : int = mul %69 %70;\n+                        %72 : int = constant @\"2\";\n+                        %73 : int = mul %71 %72;\n+                        %74 : boolean = eq %68 %73;\n+                        yield %74;\n+                    }\n+                    ()void -> {\n+                        %75 : java.lang.String = var.load %3;\n+                        %76 : int = constant @\"8\";\n+                        %77 : java.lang.Integer = invoke %76 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %78 : java.lang.String = add %75 %77;\n+                        var.store %3 %78;\n+                        yield;\n+                    }\n+                    (%79 : int)boolean -> {\n+                        %80 : int = constant @\"8\";\n+                        %81 : int = constant @\"1\";\n+                        %82 : int = or %80 %81;\n+                        %83 : boolean = eq %79 %82;\n+                        yield %83;\n+                    }\n+                    ()void -> {\n+                        %84 : java.lang.String = var.load %3;\n+                        %85 : int = constant @\"9\";\n+                        %86 : java.lang.Integer = invoke %85 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %87 : java.lang.String = add %84 %86;\n+                        var.store %3 %87;\n+                        yield;\n+                    }\n+                    (%88 : int)boolean -> {\n+                        %89 : int = constant @\"10\";\n+                        %90 : boolean = eq %88 %89;\n+                        yield %90;\n+                    }\n+                    ()void -> {\n+                        %91 : java.lang.String = var.load %3;\n+                        %92 : int = constant @\"10\";\n+                        %93 : java.lang.Integer = invoke %92 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %94 : java.lang.String = add %91 %93;\n+                        var.store %3 %94;\n+                        yield;\n+                    }\n+                    (%95 : int)boolean -> {\n+                        %96 : int = var.load %5;\n+                        %97 : boolean = eq %95 %96;\n+                        yield %97;\n+                    }\n+                    ()void -> {\n+                        %98 : java.lang.String = var.load %3;\n+                        %99 : int = constant @\"11\";\n+                        %100 : java.lang.Integer = invoke %99 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %101 : java.lang.String = add %98 %100;\n+                        var.store %3 %101;\n+                        yield;\n+                    }\n+                    (%102 : int)boolean -> {\n+                        %103 : int = field.load @\"SwitchStatementTest$Constants::c1()int\";\n+                        %104 : boolean = eq %102 %103;\n+                        yield %104;\n+                    }\n+                    ()void -> {\n+                        %105 : java.lang.String = var.load %3;\n+                        %106 : int = field.load @\"SwitchStatementTest$Constants::c1()int\";\n+                        %107 : java.lang.Integer = invoke %106 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %108 : java.lang.String = add %105 %107;\n+                        var.store %3 %108;\n+                        yield;\n+                    }\n+                    (%109 : int)boolean -> {\n+                        %110 : int = java.cexpression\n+                            ()boolean -> {\n+                                %111 : int = constant @\"1\";\n+                                %112 : int = constant @\"0\";\n+                                %113 : boolean = gt %111 %112;\n+                                yield %113;\n+                            }\n+                            ()int -> {\n+                                %114 : int = constant @\"13\";\n+                                yield %114;\n+                            }\n+                            ()int -> {\n+                                %115 : int = constant @\"133\";\n+                                yield %115;\n+                            };\n+                        %116 : boolean = eq %109 %110;\n+                        yield %116;\n+                    }\n+                    ()void -> {\n+                        %117 : java.lang.String = var.load %3;\n+                        %118 : int = constant @\"13\";\n+                        %119 : java.lang.Integer = invoke %118 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %120 : java.lang.String = add %117 %119;\n+                        var.store %3 %120;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %121 : java.lang.String = var.load %3;\n+                        %122 : java.lang.String = constant @\"an int\";\n+                        %123 : java.lang.String = add %121 %122;\n+                        var.store %3 %123;\n+                        yield;\n+                    };\n+                %124 : java.lang.String = var.load %3;\n+                return %124;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantOtherKindsOfExpr(int i) {\n+        String r = \"\";\n+        final int eleven = 11;\n+        switch (i) {\n+            case 1 & 0xF -> r += 1;\n+            case 4>>1 -> r += \"2\";\n+            case (int) 3L -> r += 3;\n+            case 2<<1 -> r += 4;\n+            case 10 \/ 2 -> r += 5;\n+            case 12 - 6 -> r += 6;\n+            case 3 + 4 -> r += 7;\n+            case 2 * 2 * 2 -> r += 8;\n+            case 8 | 1 -> r += 9;\n+            case (10) -> r += 10;\n+            case eleven -> r += 11;\n+            case Constants.c1 -> r += Constants.c1;\n+            case 1 > 0 ? 13 : 133 -> r += 13;\n+            default -> r += \"an int\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantConv\" (%0 : short)java.lang.String -> {\n+                %1 : Var<short> = var %0 @\"a\";\n+                %2 : int = constant @\"1\";\n+                %3 : short = conv %2;\n+                %4 : Var<short> = var %3 @\"s\";\n+                %5 : int = constant @\"2\";\n+                %6 : byte = conv %5;\n+                %7 : Var<byte> = var %6 @\"b\";\n+                %8 : java.lang.String = constant @\"\";\n+                %9 : Var<java.lang.String> = var %8 @\"r\";\n+                %10 : short = var.load %1;\n+                java.switch.statement %10\n+                    (%11 : short)boolean -> {\n+                        %12 : short = var.load %4;\n+                        %13 : boolean = eq %11 %12;\n+                        yield %13;\n+                    }\n+                    ()void -> {\n+                        %14 : java.lang.String = var.load %9;\n+                        %15 : java.lang.String = constant @\"one\";\n+                        %16 : java.lang.String = add %14 %15;\n+                        var.store %9 %16;\n+                        yield;\n+                    }\n+                    (%17 : short)boolean -> {\n+                        %18 : byte = var.load %7;\n+                        %19 : short = conv %18;\n+                        %20 : boolean = eq %17 %19;\n+                        yield %20;\n+                    }\n+                    ()void -> {\n+                        %21 : java.lang.String = var.load %9;\n+                        %22 : java.lang.String = constant @\"two\";\n+                        %23 : java.lang.String = add %21 %22;\n+                        var.store %9 %23;\n+                        yield;\n+                    }\n+                    (%24 : short)boolean -> {\n+                        %25 : int = constant @\"3\";\n+                        %26 : short = conv %25;\n+                        %27 : boolean = eq %24 %26;\n+                        yield %27;\n+                    }\n+                    ()void -> {\n+                        %28 : java.lang.String = var.load %9;\n+                        %29 : java.lang.String = constant @\"three\";\n+                        %30 : java.lang.String = add %28 %29;\n+                        var.store %9 %30;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %31 : java.lang.String = var.load %9;\n+                        %32 : java.lang.String = constant @\"else\";\n+                        %33 : java.lang.String = add %31 %32;\n+                        var.store %9 %33;\n+                        yield;\n+                    };\n+                %34 : java.lang.String = var.load %9;\n+                return %34;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String caseConstantConv(short a) { \/\/ @@@ tests should be easy to test with interpreter, e.g. tests returning a string result\n+        final short s = 1;\n+        final byte b = 2;\n+        String r = \"\";\n+        switch (a) {\n+            \/\/ @@@ string concat is modeled as: add s1 s2\n+            case s -> r += \"one\"; \/\/ identity, short -> short\n+            case b -> r += \"two\"; \/\/ widening primitive conversion, byte -> short\n+            case 3 -> r += \"three\"; \/\/ narrowing primitive conversion, int -> short\n+            default -> r += \"else\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantConv2\" (%0 : java.lang.Byte)java.lang.String -> {\n+                %1 : Var<java.lang.Byte> = var %0 @\"a\";\n+                %2 : int = constant @\"2\";\n+                %3 : byte = conv %2;\n+                %4 : Var<byte> = var %3 @\"b\";\n+                %5 : java.lang.String = constant @\"\";\n+                %6 : Var<java.lang.String> = var %5 @\"r\";\n+                %7 : java.lang.Byte = var.load %1;\n+                java.switch.statement %7\n+                    (%8 : java.lang.Byte)boolean -> {\n+                        %9 : int = constant @\"1\";\n+                        %10 : byte = conv %9;\n+                        %11 : java.lang.Byte = invoke %10 @\"java.lang.Byte::valueOf(byte)java.lang.Byte\";\n+                        %12 : boolean = invoke %8 %11 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %12;\n+                    }\n+                    ()void -> {\n+                        %13 : java.lang.String = var.load %6;\n+                        %14 : java.lang.String = constant @\"one\";\n+                        %15 : java.lang.String = add %13 %14;\n+                        var.store %6 %15;\n+                        yield;\n+                    }\n+                    (%16 : java.lang.Byte)boolean -> {\n+                        %17 : byte = var.load %4;\n+                        %18 : java.lang.Byte = invoke %17 @\"java.lang.Byte::valueOf(byte)java.lang.Byte\";\n+                        %19 : boolean = invoke %16 %18 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %19;\n+                    }\n+                    ()void -> {\n+                        %20 : java.lang.String = var.load %6;\n+                        %21 : java.lang.String = constant @\"two\";\n+                        %22 : java.lang.String = add %20 %21;\n+                        var.store %6 %22;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %23 : java.lang.String = var.load %6;\n+                        %24 : java.lang.String = constant @\"default\";\n+                        %25 : java.lang.String = add %23 %24;\n+                        var.store %6 %25;\n+                        yield;\n+                    };\n+                %26 : java.lang.String = var.load %6;\n+                return %26;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String caseConstantConv2(Byte a) {\n+        final byte b = 2;\n+        String r = \"\";\n+        switch (a) {\n+            case 1 -> r+= \"one\"; \/\/ narrowing primitive conversion followed by a boxing conversion, int -> bye -> Byte\n+            case b -> r+= \"two\"; \/\/ boxing, byte -> Byte\n+            default -> r+= \"default\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"nonEnhancedSwStatNoDefault\" (%0 : int)java.lang.String -> {\n+                %1 : Var<int> = var %0 @\"a\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : int = var.load %1;\n+                java.switch.statement %4\n+                    (%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()void -> {\n+                        %8 : java.lang.String = var.load %3;\n+                        %9 : java.lang.String = constant @\"1\";\n+                        %10 : java.lang.String = add %8 %9;\n+                        var.store %3 %10;\n+                        yield;\n+                    }\n+                    (%11 : int)boolean -> {\n+                        %12 : int = constant @\"2\";\n+                        %13 : boolean = eq %11 %12;\n+                        yield %13;\n+                    }\n+                    ()void -> {\n+                        %14 : java.lang.String = var.load %3;\n+                        %15 : int = constant @\"2\";\n+                        %16 : java.lang.Integer = invoke %15 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %17 : java.lang.String = add %14 %16;\n+                        var.store %3 %17;\n+                        yield;\n+                    };\n+                %18 : java.lang.String = var.load %3;\n+                return %18;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String nonEnhancedSwStatNoDefault(int a) {\n+        String r = \"\";\n+        switch (a) {\n+            case 1 -> r += \"1\";\n+            case 2 -> r += 2;\n+        }\n+        return r;\n+    }\n+\n+    enum E {A, B}\n+    @IR(\"\"\"\n+            func @\"enhancedSwStatNoDefault1\" (%0 : SwitchStatementTest$E)java.lang.String -> {\n+                %1 : Var<SwitchStatementTest$E> = var %0 @\"e\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : SwitchStatementTest$E = var.load %1;\n+                java.switch.statement %4\n+                    (%5 : SwitchStatementTest$E)boolean -> {\n+                        %6 : SwitchStatementTest$E = field.load @\"SwitchStatementTest$E::A()SwitchStatementTest$E\";\n+                        %7 : boolean = invoke %5 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %7;\n+                    }\n+                    ()void -> {\n+                        %8 : java.lang.String = var.load %3;\n+                        %9 : SwitchStatementTest$E = field.load @\"SwitchStatementTest$E::A()SwitchStatementTest$E\";\n+                        %10 : java.lang.String = cast %9 @\"java.lang.String\";\n+                        %11 : java.lang.String = add %8 %10;\n+                        var.store %3 %11;\n+                        yield;\n+                    }\n+                    (%12 : SwitchStatementTest$E)boolean -> {\n+                        %13 : SwitchStatementTest$E = field.load @\"SwitchStatementTest$E::B()SwitchStatementTest$E\";\n+                        %14 : boolean = invoke %12 %13 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %14;\n+                    }\n+                    ()void -> {\n+                        %15 : java.lang.String = var.load %3;\n+                        %16 : SwitchStatementTest$E = field.load @\"SwitchStatementTest$E::B()SwitchStatementTest$E\";\n+                        %17 : java.lang.String = cast %16 @\"java.lang.String\";\n+                        %18 : java.lang.String = add %15 %17;\n+                        var.store %3 %18;\n+                        yield;\n+                    }\n+                    (%19 : SwitchStatementTest$E)boolean -> {\n+                        %20 : java.lang.Object = constant @null;\n+                        %21 : boolean = invoke %19 %20 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %21;\n+                    }\n+                    ()void -> {\n+                        %22 : java.lang.String = var.load %3;\n+                        %23 : java.lang.String = constant @\"null\";\n+                        %24 : java.lang.String = add %22 %23;\n+                        var.store %3 %24;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %25 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        throw %25;\n+                    };\n+                %26 : java.lang.String = var.load %3;\n+                return %26;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String enhancedSwStatNoDefault1(E e) {\n+        String r = \"\";\n+        switch (e) {\n+            case A -> r += E.A;\n+            case B -> r += E.B;\n+            case null -> r += \"null\";\n+        }\n+        return r;\n+    }\n+\n+    sealed interface I permits K, J {}\n+    record K() implements I {}\n+    static final class J implements I {}\n+    @IR(\"\"\"\n+            func @\"enhancedSwStatNoDefault2\" (%0 : SwitchStatementTest$I)java.lang.String -> {\n+                %1 : Var<SwitchStatementTest$I> = var %0 @\"i\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : SwitchStatementTest$I = var.load %1;\n+                %5 : SwitchStatementTest$K = constant @null;\n+                %6 : Var<SwitchStatementTest$K> = var %5 @\"k\";\n+                %7 : SwitchStatementTest$J = constant @null;\n+                %8 : Var<SwitchStatementTest$J> = var %7 @\"j\";\n+                java.switch.statement %4\n+                    (%9 : SwitchStatementTest$I)boolean -> {\n+                        %10 : boolean = pattern.match %9\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<SwitchStatementTest$K> -> {\n+                                %11 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<SwitchStatementTest$K> = pattern.binding @\"k\";\n+                                yield %11;\n+                            }\n+                            (%12 : SwitchStatementTest$K)void -> {\n+                                var.store %6 %12;\n+                                yield;\n+                            };\n+                        yield %10;\n+                    }\n+                    ()void -> {\n+                        %13 : java.lang.String = var.load %3;\n+                        %14 : java.lang.String = constant @\"K\";\n+                        %15 : java.lang.String = add %13 %14;\n+                        var.store %3 %15;\n+                        yield;\n+                    }\n+                    (%16 : SwitchStatementTest$I)boolean -> {\n+                        %17 : boolean = pattern.match %16\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<SwitchStatementTest$J> -> {\n+                                %18 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<SwitchStatementTest$J> = pattern.binding @\"j\";\n+                                yield %18;\n+                            }\n+                            (%19 : SwitchStatementTest$J)void -> {\n+                                var.store %8 %19;\n+                                yield;\n+                            };\n+                        yield %17;\n+                    }\n+                    ()void -> {\n+                        %20 : java.lang.String = var.load %3;\n+                        %21 : java.lang.String = constant @\"J\";\n+                        %22 : java.lang.String = add %20 %21;\n+                        var.store %3 %22;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %23 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        throw %23;\n+                    };\n+                %24 : java.lang.String = var.load %3;\n+                return %24;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String enhancedSwStatNoDefault2(I i) {\n+        String r = \"\";\n+        switch (i) {\n+            case K k -> r += \"K\";\n+            case J j -> r += \"J\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"enhancedSwStatUnconditionalPattern\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : java.lang.String = var.load %1;\n+                %5 : java.lang.Object = constant @null;\n+                %6 : Var<java.lang.Object> = var %5 @\"o\";\n+                java.switch.statement %4\n+                    (%7 : java.lang.String)boolean -> {\n+                        %8 : java.lang.String = constant @\"A\";\n+                        %9 : boolean = invoke %7 %8 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %9;\n+                    }\n+                    ()void -> {\n+                        %10 : java.lang.String = var.load %3;\n+                        %11 : java.lang.String = constant @\"A\";\n+                        %12 : java.lang.String = add %10 %11;\n+                        var.store %3 %12;\n+                        yield;\n+                    }\n+                    (%13 : java.lang.String)boolean -> {\n+                        %14 : boolean = pattern.match %13\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Object> -> {\n+                                %15 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Object> = pattern.binding @\"o\";\n+                                yield %15;\n+                            }\n+                            (%16 : java.lang.Object)void -> {\n+                                var.store %6 %16;\n+                                yield;\n+                            };\n+                        yield %14;\n+                    }\n+                    ()void -> {\n+                        %17 : java.lang.String = var.load %3;\n+                        %18 : java.lang.String = constant @\"obj\";\n+                        %19 : java.lang.String = add %17 %18;\n+                        var.store %3 %19;\n+                        yield;\n+                    };\n+                %20 : java.lang.String = var.load %3;\n+                return %20;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String enhancedSwStatUnconditionalPattern(String s) {\n+        String r = \"\";\n+        switch (s) {\n+            case \"A\" -> r += \"A\";\n+            case Object o -> r += \"obj\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"casePatternRuleExpression\" (%0 : java.lang.Object)java.lang.String -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"o\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : java.lang.Object = var.load %1;\n+                %5 : java.lang.Integer = constant @null;\n+                %6 : Var<java.lang.Integer> = var %5 @\"i\";\n+                %7 : java.lang.String = constant @null;\n+                %8 : Var<java.lang.String> = var %7 @\"s\";\n+                java.switch.statement %4\n+                    (%9 : java.lang.Object)boolean -> {\n+                        %10 : boolean = pattern.match %9\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Integer> -> {\n+                                %11 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Integer> = pattern.binding @\"i\";\n+                                yield %11;\n+                            }\n+                            (%12 : java.lang.Integer)void -> {\n+                                var.store %6 %12;\n+                                yield;\n+                            };\n+                        yield %10;\n+                    }\n+                    ()void -> {\n+                        %13 : java.lang.String = var.load %3;\n+                        %14 : java.lang.String = constant @\"integer\";\n+                        %15 : java.lang.String = add %13 %14;\n+                        var.store %3 %15;\n+                        yield;\n+                    }\n+                    (%16 : java.lang.Object)boolean -> {\n+                        %17 : boolean = pattern.match %16\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> -> {\n+                                %18 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %18;\n+                            }\n+                            (%19 : java.lang.String)void -> {\n+                                var.store %8 %19;\n+                                yield;\n+                            };\n+                        yield %17;\n+                    }\n+                    ()void -> {\n+                        %20 : java.lang.String = var.load %3;\n+                        %21 : java.lang.String = constant @\"string\";\n+                        %22 : java.lang.String = add %20 %21;\n+                        var.store %3 %22;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %23 : java.lang.String = var.load %3;\n+                        %24 : java.lang.String = constant @\"else\";\n+                        %25 : java.lang.String = add %23 %24;\n+                        var.store %3 %25;\n+                        yield;\n+                    };\n+                %26 : java.lang.String = var.load %3;\n+                return %26;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String casePatternRuleExpression(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case Integer i -> r += \"integer\";\n+            case String s -> r+= \"string\";\n+            default -> r+= \"else\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"casePatternRuleBlock\" (%0 : java.lang.Object)java.lang.String -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"o\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : java.lang.Object = var.load %1;\n+                %5 : java.lang.Integer = constant @null;\n+                %6 : Var<java.lang.Integer> = var %5 @\"i\";\n+                %7 : java.lang.String = constant @null;\n+                %8 : Var<java.lang.String> = var %7 @\"s\";\n+                java.switch.statement %4\n+                    (%9 : java.lang.Object)boolean -> {\n+                        %10 : boolean = pattern.match %9\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Integer> -> {\n+                                %11 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Integer> = pattern.binding @\"i\";\n+                                yield %11;\n+                            }\n+                            (%12 : java.lang.Integer)void -> {\n+                                var.store %6 %12;\n+                                yield;\n+                            };\n+                        yield %10;\n+                    }\n+                    ()void -> {\n+                        %13 : java.lang.String = var.load %3;\n+                        %14 : java.lang.String = constant @\"integer\";\n+                        %15 : java.lang.String = add %13 %14;\n+                        var.store %3 %15;\n+                        yield;\n+                    }\n+                    (%16 : java.lang.Object)boolean -> {\n+                        %17 : boolean = pattern.match %16\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> -> {\n+                                %18 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %18;\n+                            }\n+                            (%19 : java.lang.String)void -> {\n+                                var.store %8 %19;\n+                                yield;\n+                            };\n+                        yield %17;\n+                    }\n+                    ()void -> {\n+                        %20 : java.lang.String = var.load %3;\n+                        %21 : java.lang.String = constant @\"string\";\n+                        %22 : java.lang.String = add %20 %21;\n+                        var.store %3 %22;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %23 : java.lang.String = var.load %3;\n+                        %24 : java.lang.String = constant @\"else\";\n+                        %25 : java.lang.String = add %23 %24;\n+                        var.store %3 %25;\n+                        yield;\n+                    };\n+                %26 : java.lang.String = var.load %3;\n+                return %26;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String casePatternRuleBlock(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case Integer i -> {\n+                r += \"integer\";\n+            }\n+            case String s -> {\n+                r += \"string\";\n+            }\n+            default -> {\n+                r += \"else\";\n+            }\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"casePatternStatement\" (%0 : java.lang.Object)java.lang.String -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"o\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : java.lang.Object = var.load %1;\n+                %5 : java.lang.Integer = constant @null;\n+                %6 : Var<java.lang.Integer> = var %5 @\"i\";\n+                %7 : java.lang.String = constant @null;\n+                %8 : Var<java.lang.String> = var %7 @\"s\";\n+                java.switch.statement %4\n+                    (%9 : java.lang.Object)boolean -> {\n+                        %10 : boolean = pattern.match %9\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Integer> -> {\n+                                %11 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Integer> = pattern.binding @\"i\";\n+                                yield %11;\n+                            }\n+                            (%12 : java.lang.Integer)void -> {\n+                                var.store %6 %12;\n+                                yield;\n+                            };\n+                        yield %10;\n+                    }\n+                    ()void -> {\n+                        %13 : java.lang.String = var.load %3;\n+                        %14 : java.lang.String = constant @\"integer\";\n+                        %15 : java.lang.String = add %13 %14;\n+                        var.store %3 %15;\n+                        java.break;\n+                    }\n+                    (%16 : java.lang.Object)boolean -> {\n+                        %17 : boolean = pattern.match %16\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> -> {\n+                                %18 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %18;\n+                            }\n+                            (%19 : java.lang.String)void -> {\n+                                var.store %8 %19;\n+                                yield;\n+                            };\n+                        yield %17;\n+                    }\n+                    ()void -> {\n+                        %20 : java.lang.String = var.load %3;\n+                        %21 : java.lang.String = constant @\"string\";\n+                        %22 : java.lang.String = add %20 %21;\n+                        var.store %3 %22;\n+                        java.break;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %23 : java.lang.String = var.load %3;\n+                        %24 : java.lang.String = constant @\"else\";\n+                        %25 : java.lang.String = add %23 %24;\n+                        var.store %3 %25;\n+                        yield;\n+                    };\n+                %26 : java.lang.String = var.load %3;\n+                return %26;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String casePatternStatement(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case Integer i:\n+                r += \"integer\";\n+                break;\n+            case String s:\n+                r += \"string\";\n+                break;\n+            default:\n+                r += \"else\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"casePatternThrow\" (%0 : java.lang.Object)java.lang.String -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"o\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : java.lang.Object = var.load %1;\n+                %5 : java.lang.Number = constant @null;\n+                %6 : Var<java.lang.Number> = var %5 @\"n\";\n+                %7 : java.lang.String = constant @null;\n+                %8 : Var<java.lang.String> = var %7 @\"s\";\n+                java.switch.statement %4\n+                    (%9 : java.lang.Object)boolean -> {\n+                        %10 : boolean = pattern.match %9\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Number> -> {\n+                                %11 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Number> = pattern.binding @\"n\";\n+                                yield %11;\n+                            }\n+                            (%12 : java.lang.Number)void -> {\n+                                var.store %6 %12;\n+                                yield;\n+                            };\n+                        yield %10;\n+                    }\n+                    ()void -> {\n+                        %13 : java.lang.IllegalArgumentException = new @\"func<java.lang.IllegalArgumentException>\";\n+                        throw %13;\n+                    }\n+                    (%14 : java.lang.Object)boolean -> {\n+                        %15 : boolean = pattern.match %14\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> -> {\n+                                %16 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %16;\n+                            }\n+                            (%17 : java.lang.String)void -> {\n+                                var.store %8 %17;\n+                                yield;\n+                            };\n+                        yield %15;\n+                    }\n+                    ()void -> {\n+                        %18 : java.lang.String = var.load %3;\n+                        %19 : java.lang.String = constant @\"a string\";\n+                        %20 : java.lang.String = add %18 %19;\n+                        var.store %3 %20;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %21 : java.lang.String = var.load %3;\n+                        %22 : java.lang.Object = var.load %1;\n+                        %23 : java.lang.Class<+<java.lang.Object>> = invoke %22 @\"java.lang.Object::getClass()java.lang.Class\";\n+                        %24 : java.lang.String = invoke %23 @\"java.lang.Class::getName()java.lang.String\";\n+                        %25 : java.lang.String = add %21 %24;\n+                        var.store %3 %25;\n+                        yield;\n+                    };\n+                %26 : java.lang.String = var.load %3;\n+                return %26;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String casePatternThrow(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case Number n -> throw new IllegalArgumentException();\n+            case String s -> r += \"a string\";\n+            default -> r += o.getClass().getName();\n+        }\n+        return r;\n+    }\n+\n+    \/\/ @@@ code model for such as code is not supported\n+\/\/    @CodeReflection\n+    private static String casePatternMultiLabel(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case Integer _, Long _, Character _, Byte _, Short _-> r += \"integral type\";\n+            default -> r += \"non integral type\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"casePatternWithCaseConstant\" (%0 : java.lang.Integer)java.lang.String -> {\n+                %1 : Var<java.lang.Integer> = var %0 @\"a\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : java.lang.Integer = var.load %1;\n+                %5 : java.lang.Integer = constant @null;\n+                %6 : Var<java.lang.Integer> = var %5 @\"i\";\n+                %7 : java.lang.Integer = constant @null;\n+                %8 : Var<java.lang.Integer> = var %7 @\"i\";\n+                java.switch.statement %4\n+                    (%9 : java.lang.Integer)boolean -> {\n+                        %10 : int = constant @\"42\";\n+                        %11 : java.lang.Integer = invoke %10 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %12 : boolean = invoke %9 %11 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %12;\n+                    }\n+                    ()void -> {\n+                        %13 : java.lang.String = var.load %3;\n+                        %14 : java.lang.String = constant @\"forty two\";\n+                        %15 : java.lang.String = add %13 %14;\n+                        var.store %3 %15;\n+                        yield;\n+                    }\n+                    (%16 : java.lang.Integer)boolean -> {\n+                        %17 : boolean = java.cand\n+                            ()boolean -> {\n+                                %18 : boolean = pattern.match %16\n+                                    ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Integer> -> {\n+                                        %19 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Integer> = pattern.binding @\"i\";\n+                                        yield %19;\n+                                    }\n+                                    (%20 : java.lang.Integer)void -> {\n+                                        var.store %6 %20;\n+                                        yield;\n+                                    };\n+                                yield %18;\n+                            }\n+                            ()boolean -> {\n+                                %21 : java.lang.Integer = var.load %6;\n+                                %22 : int = invoke %21 @\"java.lang.Integer::intValue()int\";\n+                                %23 : int = constant @\"0\";\n+                                %24 : boolean = gt %22 %23;\n+                                yield %24;\n+                            };\n+                        yield %17;\n+                    }\n+                    ()void -> {\n+                        %25 : java.lang.String = var.load %3;\n+                        %26 : java.lang.String = constant @\"positive int\";\n+                        %27 : java.lang.String = add %25 %26;\n+                        var.store %3 %27;\n+                        yield;\n+                    }\n+                    (%28 : java.lang.Integer)boolean -> {\n+                        %29 : boolean = java.cand\n+                            ()boolean -> {\n+                                %30 : boolean = pattern.match %28\n+                                    ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Integer> -> {\n+                                        %31 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Integer> = pattern.binding @\"i\";\n+                                        yield %31;\n+                                    }\n+                                    (%32 : java.lang.Integer)void -> {\n+                                        var.store %8 %32;\n+                                        yield;\n+                                    };\n+                                yield %30;\n+                            }\n+                            ()boolean -> {\n+                                %33 : java.lang.Integer = var.load %8;\n+                                %34 : int = invoke %33 @\"java.lang.Integer::intValue()int\";\n+                                %35 : int = constant @\"0\";\n+                                %36 : boolean = lt %34 %35;\n+                                yield %36;\n+                            };\n+                        yield %29;\n+                    }\n+                    ()void -> {\n+                        %37 : java.lang.String = var.load %3;\n+                        %38 : java.lang.String = constant @\"negative int\";\n+                        %39 : java.lang.String = add %37 %38;\n+                        var.store %3 %39;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %40 : java.lang.String = var.load %3;\n+                        %41 : java.lang.String = constant @\"zero\";\n+                        %42 : java.lang.String = add %40 %41;\n+                        var.store %3 %42;\n+                        yield;\n+                    };\n+                %43 : java.lang.String = var.load %3;\n+                return %43;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String casePatternWithCaseConstant(Integer a) {\n+        String r = \"\";\n+        switch (a) {\n+            case 42 -> r += \"forty two\";\n+            \/\/ @@@ case int will not match, because of the way InstanceOfOp is interpreted\n+            case Integer i when i > 0 -> r += \"positive int\";\n+            case Integer i when i < 0 -> r += \"negative int\";\n+            default -> r += \"zero\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseTypePattern\" (%0 : java.lang.Object)java.lang.String -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"o\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : java.lang.Object = var.load %1;\n+                %5 : java.lang.String = constant @null;\n+                %6 : Var<java.lang.String> = var %5 @\"\";\n+                %7 : java.util.RandomAccess = constant @null;\n+                %8 : Var<java.util.RandomAccess> = var %7 @\"\";\n+                %9 : int[] = constant @null;\n+                %10 : Var<int[]> = var %9 @\"\";\n+                %11 : java.util.Stack[][] = constant @null;\n+                %12 : Var<java.util.Stack[][]> = var %11 @\"\";\n+                %13 : java.util.Collection[][][] = constant @null;\n+                %14 : Var<java.util.Collection[][][]> = var %13 @\"\";\n+                %15 : java.lang.Number = constant @null;\n+                %16 : Var<java.lang.Number> = var %15 @\"n\";\n+                java.switch.statement %4\n+                    (%17 : java.lang.Object)boolean -> {\n+                        %18 : boolean = pattern.match %17\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> -> {\n+                                %19 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> = pattern.binding @\"\";\n+                                yield %19;\n+                            }\n+                            (%20 : java.lang.String)void -> {\n+                                var.store %6 %20;\n+                                yield;\n+                            };\n+                        yield %18;\n+                    }\n+                    ()void -> {\n+                        %21 : java.lang.String = var.load %3;\n+                        %22 : java.lang.String = constant @\"String\";\n+                        %23 : java.lang.String = add %21 %22;\n+                        var.store %3 %23;\n+                        yield;\n+                    }\n+                    (%24 : java.lang.Object)boolean -> {\n+                        %25 : boolean = pattern.match %24\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.util.RandomAccess> -> {\n+                                %26 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.util.RandomAccess> = pattern.binding @\"\";\n+                                yield %26;\n+                            }\n+                            (%27 : java.util.RandomAccess)void -> {\n+                                var.store %8 %27;\n+                                yield;\n+                            };\n+                        yield %25;\n+                    }\n+                    ()void -> {\n+                        %28 : java.lang.String = var.load %3;\n+                        %29 : java.lang.String = constant @\"RandomAccess\";\n+                        %30 : java.lang.String = add %28 %29;\n+                        var.store %3 %30;\n+                        yield;\n+                    }\n+                    (%31 : java.lang.Object)boolean -> {\n+                        %32 : boolean = pattern.match %31\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<int[]> -> {\n+                                %33 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<int[]> = pattern.binding @\"\";\n+                                yield %33;\n+                            }\n+                            (%34 : int[])void -> {\n+                                var.store %10 %34;\n+                                yield;\n+                            };\n+                        yield %32;\n+                    }\n+                    ()void -> {\n+                        %35 : java.lang.String = var.load %3;\n+                        %36 : java.lang.String = constant @\"int[]\";\n+                        %37 : java.lang.String = add %35 %36;\n+                        var.store %3 %37;\n+                        yield;\n+                    }\n+                    (%38 : java.lang.Object)boolean -> {\n+                        %39 : boolean = pattern.match %38\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.util.Stack[][]> -> {\n+                                %40 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.util.Stack[][]> = pattern.binding @\"\";\n+                                yield %40;\n+                            }\n+                            (%41 : java.util.Stack[][])void -> {\n+                                var.store %12 %41;\n+                                yield;\n+                            };\n+                        yield %39;\n+                    }\n+                    ()void -> {\n+                        %42 : java.lang.String = var.load %3;\n+                        %43 : java.lang.String = constant @\"Stack[][]\";\n+                        %44 : java.lang.String = add %42 %43;\n+                        var.store %3 %44;\n+                        yield;\n+                    }\n+                    (%45 : java.lang.Object)boolean -> {\n+                        %46 : boolean = pattern.match %45\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.util.Collection[][][]> -> {\n+                                %47 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.util.Collection[][][]> = pattern.binding @\"\";\n+                                yield %47;\n+                            }\n+                            (%48 : java.util.Collection[][][])void -> {\n+                                var.store %14 %48;\n+                                yield;\n+                            };\n+                        yield %46;\n+                    }\n+                    ()void -> {\n+                        %49 : java.lang.String = var.load %3;\n+                        %50 : java.lang.String = constant @\"Collection[][][]\";\n+                        %51 : java.lang.String = add %49 %50;\n+                        var.store %3 %51;\n+                        yield;\n+                    }\n+                    (%52 : java.lang.Object)boolean -> {\n+                        %53 : boolean = pattern.match %52\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Number> -> {\n+                                %54 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Number> = pattern.binding @\"n\";\n+                                yield %54;\n+                            }\n+                            (%55 : java.lang.Number)void -> {\n+                                var.store %16 %55;\n+                                yield;\n+                            };\n+                        yield %53;\n+                    }\n+                    ()void -> {\n+                        %56 : java.lang.String = var.load %3;\n+                        %57 : java.lang.String = constant @\"Number\";\n+                        %58 : java.lang.String = add %56 %57;\n+                        var.store %3 %58;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %59 : java.lang.String = var.load %3;\n+                        %60 : java.lang.String = constant @\"something else\";\n+                        %61 : java.lang.String = add %59 %60;\n+                        var.store %3 %61;\n+                        yield;\n+                    };\n+                %62 : java.lang.String = var.load %3;\n+                return %62;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String caseTypePattern(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case String _ -> r+= \"String\"; \/\/ class\n+            case RandomAccess _ -> r+= \"RandomAccess\"; \/\/ interface\n+            case int[] _ -> r+= \"int[]\"; \/\/ array primitive\n+            case Stack[][] _ -> r+= \"Stack[][]\"; \/\/ array class\n+            case Collection[][][] _ -> r+= \"Collection[][][]\"; \/\/ array interface\n+            case final Number n -> r+= \"Number\"; \/\/ final modifier\n+            default -> r+= \"something else\";\n+        }\n+        return r;\n+    }\n+\n+    record R(Number n) {}\n+    @IR(\"\"\"\n+            func @\"caseRecordPattern\" (%0 : java.lang.Object)java.lang.String -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"o\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : java.lang.Object = var.load %1;\n+                %5 : java.lang.Number = constant @null;\n+                %6 : Var<java.lang.Number> = var %5 @\"n\";\n+                java.switch.statement %4\n+                    (%7 : java.lang.Object)boolean -> {\n+                        %8 : boolean = pattern.match %7\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchStatementTest$R> -> {\n+                                %9 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Number> = pattern.binding @\"n\";\n+                                %10 : java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchStatementTest$R> = pattern.record %9 @\"(java.lang.Number n)SwitchStatementTest$R\";\n+                                yield %10;\n+                            }\n+                            (%11 : java.lang.Number)void -> {\n+                                var.store %6 %11;\n+                                yield;\n+                            };\n+                        yield %8;\n+                    }\n+                    ()void -> {\n+                        %12 : java.lang.String = var.load %3;\n+                        %13 : java.lang.String = constant @\"R(_)\";\n+                        %14 : java.lang.String = add %12 %13;\n+                        var.store %3 %14;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %15 : java.lang.String = var.load %3;\n+                        %16 : java.lang.String = constant @\"else\";\n+                        %17 : java.lang.String = add %15 %16;\n+                        var.store %3 %17;\n+                        yield;\n+                    };\n+                %18 : java.lang.String = var.load %3;\n+                return %18;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String caseRecordPattern(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case R(Number n) -> r += \"R(_)\";\n+            default -> r+= \"else\";\n+        }\n+        return r;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"casePatternGuard\" (%0 : java.lang.Object)java.lang.String -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"obj\";\n+                %2 : java.lang.String = constant @\"\";\n+                %3 : Var<java.lang.String> = var %2 @\"r\";\n+                %4 : java.lang.Object = var.load %1;\n+                %5 : java.lang.String = constant @null;\n+                %6 : Var<java.lang.String> = var %5 @\"s\";\n+                %7 : java.lang.Number = constant @null;\n+                %8 : Var<java.lang.Number> = var %7 @\"n\";\n+                java.switch.statement %4\n+                    (%9 : java.lang.Object)boolean -> {\n+                        %10 : boolean = java.cand\n+                            ()boolean -> {\n+                                %11 : boolean = pattern.match %9\n+                                    ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> -> {\n+                                        %12 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                        yield %12;\n+                                    }\n+                                    (%13 : java.lang.String)void -> {\n+                                        var.store %6 %13;\n+                                        yield;\n+                                    };\n+                                yield %11;\n+                            }\n+                            ()boolean -> {\n+                                %14 : java.lang.String = var.load %6;\n+                                %15 : int = invoke %14 @\"java.lang.String::length()int\";\n+                                %16 : int = constant @\"3\";\n+                                %17 : boolean = gt %15 %16;\n+                                yield %17;\n+                            };\n+                        yield %10;\n+                    }\n+                    ()void -> {\n+                        %18 : java.lang.String = var.load %3;\n+                        %19 : java.lang.String = constant @\"str with length > %d\";\n+                        %20 : java.lang.String = var.load %6;\n+                        %21 : int = invoke %20 @\"java.lang.String::length()int\";\n+                        %22 : java.lang.Integer = invoke %21 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %23 : java.lang.String = invoke %19 %22 @\"java.lang.String::formatted(java.lang.Object[])java.lang.String\";\n+                        %24 : java.lang.String = add %18 %23;\n+                        var.store %3 %24;\n+                        yield;\n+                    }\n+                    (%25 : java.lang.Object)boolean -> {\n+                        %26 : boolean = java.cand\n+                            ()boolean -> {\n+                                %27 : boolean = pattern.match %25\n+                                    ()java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchStatementTest$R> -> {\n+                                        %28 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Number> = pattern.binding @\"n\";\n+                                        %29 : java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchStatementTest$R> = pattern.record %28 @\"(java.lang.Number n)SwitchStatementTest$R\";\n+                                        yield %29;\n+                                    }\n+                                    (%30 : java.lang.Number)void -> {\n+                                        var.store %8 %30;\n+                                        yield;\n+                                    };\n+                                yield %27;\n+                            }\n+                            ()boolean -> {\n+                                %31 : java.lang.Number = var.load %8;\n+                                %32 : java.lang.Class<+<java.lang.Object>> = invoke %31 @\"java.lang.Object::getClass()java.lang.Class\";\n+                                %33 : java.lang.Class = constant @\"java.lang.Double\";\n+                                %34 : boolean = invoke %32 %33 @\"java.lang.Object::equals(java.lang.Object)boolean\";\n+                                yield %34;\n+                            };\n+                        yield %26;\n+                    }\n+                    ()void -> {\n+                        %35 : java.lang.String = var.load %3;\n+                        %36 : java.lang.String = constant @\"R(Double)\";\n+                        %37 : java.lang.String = add %35 %36;\n+                        var.store %3 %37;\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %38 : java.lang.String = var.load %3;\n+                        %39 : java.lang.String = constant @\"else\";\n+                        %40 : java.lang.String = add %38 %39;\n+                        var.store %3 %40;\n+                        yield;\n+                    };\n+                %41 : java.lang.String = var.load %3;\n+                return %41;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String casePatternGuard(Object obj) {\n+        String r = \"\";\n+        switch (obj) {\n+            case String s when s.length() > 3 -> r += \"str with length > %d\".formatted(s.length());\n+            case R(Number n) when n.getClass().equals(Double.class) -> r += \"R(Double)\";\n+            default -> r += \"else\";\n+        }\n+        return r;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchStatementTest.java","additions":1940,"deletions":0,"binary":false,"changes":1940,"status":"added"}]}