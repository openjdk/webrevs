{"files":[{"patch":"@@ -76,20 +76,1 @@\n-    sealed interface JavaStatement permits\n-            ArrayAccessOp.ArrayStoreOp,\n-            AssertOp,\n-            FieldAccessOp.FieldStoreOp,\n-            InvokeOp,\n-            NewOp,\n-            ReturnOp,\n-            ThrowOp,\n-            VarAccessOp.VarStoreOp,\n-            VarOp,\n-            ExtendedOp.JavaBlockOp,\n-            ExtendedOp.JavaDoWhileOp,\n-            ExtendedOp.JavaEnhancedForOp,\n-            ExtendedOp.JavaForOp,\n-            ExtendedOp.JavaIfOp,\n-            ExtendedOp.JavaLabelOp,\n-            ExtendedOp.JavaLabeledOp,\n-            ExtendedOp.JavaTryOp,\n-            ExtendedOp.JavaWhileOp,\n-            ExtendedOp.JavaYieldOp {\n+    sealed interface JavaStatement permits ArrayAccessOp.ArrayStoreOp, AssertOp, FieldAccessOp.FieldStoreOp, InvokeOp, NewOp, ReturnOp, ThrowOp, VarAccessOp.VarStoreOp, VarOp, ExtendedOp.JavaBlockOp, ExtendedOp.JavaDoWhileOp, ExtendedOp.JavaEnhancedForOp, ExtendedOp.JavaForOp, ExtendedOp.JavaIfOp, ExtendedOp.JavaLabelOp, ExtendedOp.JavaLabeledOp, ExtendedOp.JavaSwitchStatementOp, ExtendedOp.JavaTryOp, ExtendedOp.JavaWhileOp, ExtendedOp.JavaYieldOp {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -901,0 +901,167 @@\n+    \/**\n+     * The switch statement operation, that can model Java language switch statement.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaSwitchStatementOp.NAME)\n+    public static final class JavaSwitchStatementOp extends ExtendedOp\n+            implements Op.Nested, JavaStatement, Op.Lowerable {\n+        public static final String NAME = \"java.switch.statement\";\n+\n+        final List<Body> bodies;\n+\n+        public JavaSwitchStatementOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaSwitchStatementOp(JavaSwitchStatementOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaSwitchStatementOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchStatementOp(this, cc, ot);\n+        }\n+\n+        JavaSwitchStatementOp(Value target, List<Body.Builder> bodyCs) {\n+            super(NAME, List.of(target));\n+\n+            \/\/ Each case is modelled as a contiguous pair of bodies\n+            \/\/ The first body models the case labels, and the second models the case statements\n+            \/\/ The labels body has a parameter whose type is target operand's type and returns a boolean value\n+            \/\/ The statements body has no parameters and returns void\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+\n+            Value selectorExpression = b.context().getValue(operands().get(0));\n+\n+            \/\/ @@@ we can add this during model generation\n+            \/\/ if no case null, add one that throws NPE\n+            if (!(selectorExpression.type() instanceof PrimitiveType) && !haveNullCase()) {\n+                Block.Builder throwBlock = b.block();\n+                throwBlock.op(_throw(\n+                        throwBlock.op(_new(FunctionType.functionType(JavaType.type(NullPointerException.class))))\n+                ));\n+\n+                Block.Builder continueBlock = b.block();\n+\n+                Result p = b.op(invoke(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                        selectorExpression, b.op(constant(J_L_OBJECT, null))));\n+                b.op(conditionalBranch(p, throwBlock.successor(), continueBlock.successor()));\n+\n+                b = continueBlock;\n+            }\n+\n+            List<Block.Builder> blocks = new ArrayList<>();\n+            for (int i = 0; i < bodies().size(); i++) {\n+                Block.Builder bb = b.block();\n+                if (i == 0) {\n+                    bb = b;\n+                }\n+                blocks.add(bb);\n+            }\n+\n+            Block.Builder exit;\n+            if (bodies.isEmpty()) {\n+                exit = b;\n+            } else {\n+                exit = b.block();\n+            }\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            \/\/ map statement body to nextExprBlock\n+            \/\/ this mapping will be used for lowering SwitchFallThroughOp\n+            for (int i = 1; i < bodies().size() - 2; i+=2) {\n+                setBranchTarget(b.context(), bodies().get(i), new BranchTarget(null, blocks.get(i + 2)));\n+            }\n+\n+            for (int i = 0; i < bodies().size(); i++) {\n+                boolean isLabelBody = i % 2 == 0;\n+                Block.Builder curr = blocks.get(i);\n+                if (isLabelBody) {\n+                    Block.Builder statement = blocks.get(i + 1);\n+                    boolean isLastLabel = i == blocks.size() - 2;\n+                    Block.Builder nextLabel = isLastLabel ? null : blocks.get(i + 2);\n+                    curr.transformBody(bodies().get(i), List.of(selectorExpression), opT.andThen((block, op) -> {\n+                        switch (op) {\n+                            case YieldOp yop -> {\n+                                if (isLastLabel) {\n+                                    block.op(branch(statement.successor()));\n+                                } else {\n+                                    block.op(conditionalBranch(\n+                                            block.context().getValue(yop.yieldValue()),\n+                                            statement.successor(),\n+                                            nextLabel.successor()\n+                                    ));\n+                                }\n+                            }\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                } else { \/\/ statement body\n+                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n+                        switch (op) {\n+                            case YieldOp yop -> block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                }\n+            }\n+\n+            return exit;\n+        }\n+\n+        private boolean haveNullCase() {\n+            \/*\n+            case null is modeled like this:\n+            (%4 : T)boolean -> {\n+                %5 : java.lang.Object = constant @null;\n+                %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                yield %6;\n+            }\n+            * *\/\n+            for (int i = 0; i < bodies().size() - 2; i+=2) {\n+                Body labelBody = bodies().get(i);\n+                if (labelBody.blocks().size() != 1) {\n+                    continue; \/\/ we skip, for now\n+                }\n+                Op terminatingOp = bodies().get(i).entryBlock().terminatingOp();\n+                \/\/@@@ when op pattern matching is ready, we can use it\n+                if (terminatingOp instanceof YieldOp yieldOp &&\n+                        yieldOp.yieldValue() instanceof Op.Result opr &&\n+                        opr.op() instanceof InvokeOp invokeOp &&\n+                        invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class)) &&\n+                        invokeOp.operands().stream().anyMatch(o -> o instanceof Op.Result r && r.op() instanceof ConstantOp cop && cop.value() == null)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n@@ -3048,0 +3215,10 @@\n+    \/**\n+     * Creates a switch statement operation.\n+     * @param target the switch target value\n+     * @param bodies the body builders of the operation to be built and become its children\n+     * @return the switch statement operation\n+     *\/\n+    public static JavaSwitchStatementOp switchStatement(Value target, List<Body.Builder> bodies) {\n+        return new JavaSwitchStatementOp(target, bodies);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.*;\n@@ -32,1 +32,0 @@\n-import com.sun.tools.javac.code.Symbol;\n@@ -36,2 +35,0 @@\n-import com.sun.tools.javac.code.Symtab;\n-import com.sun.tools.javac.code.Type;\n@@ -40,2 +37,0 @@\n-import com.sun.tools.javac.code.Type.MethodType;\n-import com.sun.tools.javac.code.Type.TypeVar;\n@@ -43,2 +38,1 @@\n-import com.sun.tools.javac.code.TypeTag;\n-import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.code.Type.*;\n@@ -50,8 +44,1 @@\n-import com.sun.tools.javac.tree.JCTree.JCArrayAccess;\n-import com.sun.tools.javac.tree.JCTree.JCAssign;\n-import com.sun.tools.javac.tree.JCTree.JCBinary;\n-import com.sun.tools.javac.tree.JCTree.JCBlock;\n-import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n-import com.sun.tools.javac.tree.JCTree.JCExpression;\n-import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n-import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression;\n+import com.sun.tools.javac.tree.JCTree.*;\n@@ -59,4 +46,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCIdent;\n-import com.sun.tools.javac.tree.JCTree.JCLambda;\n-import com.sun.tools.javac.tree.JCTree.JCLiteral;\n-import com.sun.tools.javac.tree.JCTree.JCMemberReference;\n@@ -64,8 +47,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n-import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n-import com.sun.tools.javac.tree.JCTree.JCNewArray;\n-import com.sun.tools.javac.tree.JCTree.JCNewClass;\n-import com.sun.tools.javac.tree.JCTree.JCReturn;\n-import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n-import com.sun.tools.javac.tree.JCTree.JCAssert;\n-import com.sun.tools.javac.tree.JCTree.Tag;\n@@ -74,1 +49,0 @@\n-import com.sun.tools.javac.tree.TreeScanner;\n@@ -76,2 +50,1 @@\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.*;\n@@ -79,5 +52,0 @@\n-import com.sun.tools.javac.util.ListBuffer;\n-import com.sun.tools.javac.util.Log;\n-import com.sun.tools.javac.util.Name;\n-import com.sun.tools.javac.util.Names;\n-import com.sun.tools.javac.util.Options;\n@@ -92,0 +60,1 @@\n+import java.util.List;\n@@ -96,3 +65,1 @@\n-import static com.sun.tools.javac.code.Flags.NOOUTERTHIS;\n-import static com.sun.tools.javac.code.Flags.PARAMETER;\n-import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.Flags.*;\n@@ -100,3 +67,1 @@\n-import static com.sun.tools.javac.code.TypeTag.BOT;\n-import static com.sun.tools.javac.code.TypeTag.METHOD;\n-import static com.sun.tools.javac.code.TypeTag.NONE;\n+import static com.sun.tools.javac.code.TypeTag.*;\n@@ -104,0 +69,4 @@\n+import static jdk.internal.java.lang.reflect.code.op.CoreOp._new;\n+import static jdk.internal.java.lang.reflect.code.op.CoreOp._throw;\n+import static jdk.internal.java.lang.reflect.code.type.FunctionType.functionType;\n+import static jdk.internal.java.lang.reflect.code.type.JavaType.type;\n@@ -452,1 +421,1 @@\n-                Tag.SWITCH, Tag.SYNCHRONIZED,\n+                Tag.SYNCHRONIZED,\n@@ -504,1 +473,1 @@\n-            FunctionType bodyType = FunctionType.functionType(\n+            FunctionType bodyType = functionType(\n@@ -531,1 +500,1 @@\n-            FunctionType mtDesc = FunctionType.functionType(typeToTypeElement(mtype.restype),\n+            FunctionType mtDesc = functionType(typeToTypeElement(mtype.restype),\n@@ -728,1 +697,1 @@\n-                    FunctionType.functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n+                    functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n@@ -742,1 +711,1 @@\n-                    FunctionType.functionType(typeToTypeElement(unboxedType)));\n+                    functionType(typeToTypeElement(unboxedType)));\n@@ -1191,1 +1160,1 @@\n-            pushBody(pattern, FunctionType.functionType(patternType));\n+            pushBody(pattern, functionType(patternType));\n@@ -1259,1 +1228,1 @@\n-            FunctionType matchFuncType = FunctionType.functionType(JavaType.VOID, patternDescParams);\n+            FunctionType matchFuncType = functionType(JavaType.VOID, patternDescParams);\n@@ -1314,1 +1283,1 @@\n-            FunctionType constructorType = FunctionType.functionType(\n+            FunctionType constructorType = functionType(\n@@ -1320,1 +1289,1 @@\n-            result = append(CoreOp._new(typeToTypeElement(type), constructorType, args));\n+            result = append(_new(typeToTypeElement(type), constructorType, args));\n@@ -1348,1 +1317,1 @@\n-                FunctionType constructorType = FunctionType.functionType(arrayType,\n+                FunctionType constructorType = functionType(arrayType,\n@@ -1350,1 +1319,1 @@\n-                result = append(CoreOp._new(arrayType, constructorType, indexes));\n+                result = append(_new(arrayType, constructorType, indexes));\n@@ -1445,1 +1414,1 @@\n-                        FunctionType.functionType(JavaType.BOOLEAN));\n+                        functionType(JavaType.BOOLEAN));\n@@ -1493,1 +1462,1 @@\n-            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n+            FunctionType caseLabelType = functionType(JavaType.BOOLEAN, target.type());\n@@ -1495,1 +1464,1 @@\n-            FunctionType actionType = FunctionType.functionType(typeToTypeElement(switchType));\n+            FunctionType actionType = functionType(typeToTypeElement(switchType));\n@@ -1512,1 +1481,1 @@\n-                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                        pushBody(pcl.pat, functionType(JavaType.BOOLEAN));\n@@ -1518,1 +1487,1 @@\n-                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                        pushBody(c.guard, functionType(JavaType.BOOLEAN));\n@@ -1554,1 +1523,1 @@\n-                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n+                            pushBody(ccl, functionType(JavaType.BOOLEAN));\n@@ -1640,0 +1609,173 @@\n+        @Override\n+        public void visitSwitch(JCTree.JCSwitch tree) {\n+            Value target = toValue(tree.selector);\n+\n+            FunctionType caseLabelType = functionType(JavaType.BOOLEAN, target.type());\n+            FunctionType actionType = FunctionType.VOID;\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            for (JCTree.JCCase c : tree.cases) {\n+                \/\/ Labels body\n+                JCTree.JCCaseLabel headCl = c.labels.head;\n+                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                    if (c.labels.size() > 1) {\n+                        throw unsupported(c);\n+                    }\n+\n+                    pushBody(pcl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.guard != null) {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+\n+                        pushBody(pcl.pat, functionType(JavaType.BOOLEAN));\n+                        Value patVal = scanPattern(pcl.pat, localTarget);\n+                        append(CoreOp._yield(patVal));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        pushBody(c.guard, functionType(JavaType.BOOLEAN));\n+                        append(CoreOp._yield(toValue(c.guard)));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        localResult = append(ExtendedOp.conditionalAnd(clBodies));\n+                    } else {\n+                        localResult = scanPattern(pcl.pat, localTarget);\n+                    }\n+                    \/\/ Yield the boolean result of the condition\n+                    append(CoreOp._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                    pushBody(headCl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.labels.size() == 1) {\n+                        Value expr = toValue(ccl.expr);\n+                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                        \/\/ so, we convert constant to the type of the selector expression\n+                        expr = convert(expr, tree.selector.type);\n+                        if (tree.selector.type.isPrimitive()) {\n+                            localResult = append(CoreOp.eq(localTarget, expr));\n+                        } else {\n+                            localResult = append(CoreOp.invoke(\n+                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                    localTarget, expr));\n+                        }\n+                    } else {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+                        for (JCTree.JCCaseLabel cl : c.labels) {\n+                            ccl = (JCTree.JCConstantCaseLabel) cl;\n+                            pushBody(ccl, functionType(JavaType.BOOLEAN));\n+\n+                            Value expr = toValue(ccl.expr);\n+                            expr = convert(expr, tree.selector.type);\n+                            final Value labelResult;\n+                            if (tree.selector.type.isPrimitive()) {\n+                                labelResult = append(CoreOp.eq(localTarget, expr));\n+                            } else {\n+                                labelResult = append(CoreOp.invoke(\n+                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                        localTarget, expr));\n+                            }\n+\n+                            append(CoreOp._yield(labelResult));\n+                            clBodies.add(stack.body);\n+\n+                            \/\/ Pop label\n+                            popBody();\n+                        }\n+\n+                        localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                    }\n+\n+                    append(CoreOp._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop labels\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                    \/\/ @@@ Do we need to model the default label body?\n+                    pushBody(headCl, FunctionType.VOID);\n+\n+                    append(CoreOp._yield());\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else {\n+                    throw unsupported(tree);\n+                }\n+\n+                \/\/ Statements body\n+                switch (c.caseKind) {\n+                    case RULE -> {\n+                        pushBody(c.body, actionType);\n+                        if (c.body instanceof JCTree.JCBlock b) {\n+                            toValue(b);\n+                            if (!(b.stats.last() instanceof JCTree.JCBreak)) {\n+                                append(CoreOp._yield()); \/\/ @@@ _break is also an option\n+                            }\n+                        }\n+                        else if (c.body instanceof JCTree.JCStatement s) {\n+                            toValue(s);\n+                            if (!(s instanceof JCThrow)) {\n+                                append(CoreOp._yield());\n+                            }\n+                        }\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                    case STATEMENT -> {\n+                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                        pushBody(c, actionType);\n+\n+                        scan(c.stats);\n+\n+                        appendTerminating(c.completesNormally ?\n+                                headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n+                                : CoreOp::unreachable);\n+\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                };\n+            }\n+\n+            \/\/ if enhanced switch and no default label\n+            \/\/ enhanced: target type not byte, char short, int, String, or, has case pattern or case null\n+            boolean enhancedSw = !List.of(JavaType.BYTE, JavaType.CHAR, JavaType.SHORT, JavaType.INT,\n+                    JavaType.J_L_BYTE, JavaType.J_L_CHARACTER, JavaType.J_L_SHORT, JavaType.J_L_INTEGER,\n+                    JavaType.J_L_STRING).contains(typeToTypeElement(tree.selector.type));\n+            enhancedSw = enhancedSw || tree.patternSwitch;\n+            enhancedSw = enhancedSw || tree.cases.stream().anyMatch(c -> c.labels.stream().anyMatch(l -> {\n+                return l instanceof JCTree.JCConstantCaseLabel ccl && ccl.expr instanceof JCLiteral literal && literal.value == null;\n+            }));\n+            if (enhancedSw && !tree.hasUnconditionalPattern) {\n+                \/\/ label\n+                pushBody(tree, FunctionType.VOID);\n+                append(CoreOp._yield());\n+                bodies.add(stack.body);\n+                popBody();\n+\n+                \/\/ statement\n+                pushBody(tree, actionType);\n+                append(_throw(\n+                        append(_new(functionType(type(MatchException.class))))\n+                ));\n+                bodies.add(stack.body);\n+                popBody();\n+            }\n+\n+            result = append(ExtendedOp.switchStatement(target, bodies));\n+        }\n+\n@@ -1656,1 +1798,1 @@\n-            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            pushBody(cond, functionType(JavaType.BOOLEAN));\n@@ -1694,1 +1836,1 @@\n-            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            pushBody(cond, functionType(JavaType.BOOLEAN));\n@@ -1711,1 +1853,1 @@\n-            pushBody(tree.expr, FunctionType.functionType(typeToTypeElement(tree.expr.type)));\n+            pushBody(tree.expr, functionType(typeToTypeElement(tree.expr.type)));\n@@ -1727,1 +1869,1 @@\n-            pushBody(var, FunctionType.functionType(varEType, eType));\n+            pushBody(var, functionType(varEType, eType));\n@@ -1735,1 +1877,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varEType));\n+            pushBody(tree.body, functionType(JavaType.VOID, varEType));\n@@ -1789,1 +1931,1 @@\n-                pushBody(null, FunctionType.functionType(TupleType.tupleType(varTypes)));\n+                pushBody(null, functionType(TupleType.tupleType(varTypes)));\n@@ -1795,1 +1937,1 @@\n-                pushBody(null, FunctionType.functionType(varTypes.get(0)));\n+                pushBody(null, functionType(varTypes.get(0)));\n@@ -1811,1 +1953,1 @@\n-            pushBody(tree.cond, FunctionType.functionType(JavaType.BOOLEAN, varTypes));\n+            pushBody(tree.cond, functionType(JavaType.BOOLEAN, varTypes));\n@@ -1828,1 +1970,1 @@\n-            pushBody(null, FunctionType.functionType(JavaType.VOID, varTypes));\n+            pushBody(null, functionType(JavaType.VOID, varTypes));\n@@ -1841,1 +1983,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varTypes));\n+            pushBody(tree.body, functionType(JavaType.VOID, varTypes));\n@@ -1865,1 +2007,1 @@\n-                    FunctionType.functionType(JavaType.BOOLEAN));\n+                    functionType(JavaType.BOOLEAN));\n@@ -1880,1 +2022,1 @@\n-                    FunctionType.functionType(typeToTypeElement(condType)));\n+                    functionType(typeToTypeElement(condType)));\n@@ -1894,1 +2036,1 @@\n-                    FunctionType.functionType(typeToTypeElement(condType)));\n+                    functionType(typeToTypeElement(condType)));\n@@ -1930,1 +2072,1 @@\n-                    FunctionType.functionType(JavaType.BOOLEAN));\n+                    functionType(JavaType.BOOLEAN));\n@@ -1944,1 +2086,1 @@\n-                         FunctionType.functionType(typeToTypeElement(tree.detail.type)));\n+                         functionType(typeToTypeElement(tree.detail.type)));\n@@ -2017,1 +2159,1 @@\n-                pushBody(null, FunctionType.functionType(TupleType.tupleType(rTypes)));\n+                pushBody(null, functionType(TupleType.tupleType(rTypes)));\n@@ -2044,1 +2186,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, rVarTypes));\n+            pushBody(tree.body, functionType(JavaType.VOID, rVarTypes));\n@@ -2058,1 +2200,1 @@\n-                pushBody(catcher.body, FunctionType.functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n+                pushBody(catcher.body, functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n@@ -2140,1 +2282,1 @@\n-                pushBody(tree.lhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                pushBody(tree.lhs, functionType(JavaType.BOOLEAN));\n@@ -2150,1 +2292,1 @@\n-                pushBody(tree.rhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                pushBody(tree.rhs, functionType(JavaType.BOOLEAN));\n@@ -2236,1 +2378,1 @@\n-            result = append(CoreOp._throw(throwVal));\n+            result = append(_throw(throwVal));\n@@ -2345,1 +2487,1 @@\n-                        typ = JavaType.type(ClassDesc.of(t.tsym.flatName().toString()));\n+                        typ = type(ClassDesc.of(t.tsym.flatName().toString()));\n@@ -2409,1 +2551,1 @@\n-            return FunctionType.functionType(\n+            return functionType(\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":224,"deletions":82,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -0,0 +1,316 @@\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @build SwitchStatementTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester SwitchStatementTest\n+ *\/\n+public class SwitchStatementTest {\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantRuleExpression\" (%0 : java.lang.String)void -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                java.switch.statement %2\n+                    (%3 : java.lang.String)boolean -> {\n+                        %4 : java.lang.String = constant @\"FOO\";\n+                        %5 : boolean = invoke %3 %4 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %5;\n+                    }\n+                    ()void -> {\n+                        %6 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %7 : java.lang.String = constant @\"BAR\";\n+                        invoke %6 %7 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    }\n+                    (%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()void -> {\n+                        %11 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %12 : java.lang.String = constant @\"BAZ\";\n+                        invoke %11 %12 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    }\n+                    (%13 : java.lang.String)boolean -> {\n+                        %14 : java.lang.String = constant @\"BAZ\";\n+                        %15 : boolean = invoke %13 %14 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %15;\n+                    }\n+                    ()void -> {\n+                        %16 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %17 : java.lang.String = constant @\"FOO\";\n+                        invoke %16 %17 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %18 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %19 : java.lang.String = constant @\"else\";\n+                        invoke %18 %19 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    public static void caseConstantRuleExpression(String r) {\n+        switch (r) {\n+            case \"FOO\" -> System.out.println(\"BAR\");\n+            case \"BAR\" -> System.out.println(\"BAZ\");\n+            case \"BAZ\" -> System.out.println(\"FOO\");\n+            default -> System.out.println(\"else\");\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantRuleBlock\" (%0 : java.lang.String)void -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                java.switch.statement %2\n+                    (%3 : java.lang.String)boolean -> {\n+                        %4 : java.lang.String = constant @\"FOO\";\n+                        %5 : boolean = invoke %3 %4 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %5;\n+                    }\n+                    ()void -> {\n+                        %6 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %7 : java.lang.String = constant @\"BAR\";\n+                        invoke %6 %7 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    }\n+                    (%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()void -> {\n+                        %11 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %12 : java.lang.String = constant @\"BAZ\";\n+                        invoke %11 %12 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    }\n+                    (%13 : java.lang.String)boolean -> {\n+                        %14 : java.lang.String = constant @\"BAZ\";\n+                        %15 : boolean = invoke %13 %14 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %15;\n+                    }\n+                    ()void -> {\n+                        %16 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %17 : java.lang.String = constant @\"FOO\";\n+                        invoke %16 %17 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %18 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %19 : java.lang.String = constant @\"else\";\n+                        invoke %18 %19 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    public static void caseConstantRuleBlock(String r) {\n+        switch (r) {\n+            case \"FOO\" -> {\n+                System.out.println(\"BAR\");\n+            }\n+            case \"BAR\" -> {\n+                System.out.println(\"BAZ\");\n+            }\n+            case \"BAZ\" -> {\n+                System.out.println(\"FOO\");\n+            }\n+            default -> {\n+                System.out.println(\"else\");\n+            }\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantStatement\" (%0 : java.lang.String)void -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = var.load %1;\n+                java.switch.statement %2\n+                    (%3 : java.lang.String)boolean -> {\n+                        %4 : java.lang.String = constant @\"FOO\";\n+                        %5 : boolean = invoke %3 %4 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %5;\n+                    }\n+                    ()void -> {\n+                        %6 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %7 : java.lang.String = constant @\"BAR\";\n+                        invoke %6 %7 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        java.break;\n+                    }\n+                    (%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()void -> {\n+                        %11 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %12 : java.lang.String = constant @\"BAZ\";\n+                        invoke %11 %12 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        java.break;\n+                    }\n+                    (%13 : java.lang.String)boolean -> {\n+                        %14 : java.lang.String = constant @\"BAZ\";\n+                        %15 : boolean = invoke %13 %14 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %15;\n+                    }\n+                    ()void -> {\n+                        %16 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %17 : java.lang.String = constant @\"FOO\";\n+                        invoke %16 %17 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        java.break;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %18 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %19 : java.lang.String = constant @\"else\";\n+                        invoke %18 %19 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static void caseConstantStatement(String s) {\n+        switch (s) {\n+            case \"FOO\":\n+                System.out.println(\"BAR\");\n+                break;\n+            case \"BAR\":\n+                System.out.println(\"BAZ\");\n+                break;\n+            case \"BAZ\":\n+                System.out.println(\"FOO\");;\n+                break;\n+            default:\n+                System.out.println(\"else\");\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantMultiLabels\" (%0 : char)void -> {\n+                %1 : Var<char> = var %0 @\"c\";\n+                %2 : char = var.load %1;\n+                %3 : char = invoke %2 @\"java.lang.Character::toLowerCase(char)char\";\n+                java.switch.statement %3\n+                    (%4 : char)boolean -> {\n+                        %5 : boolean = java.cor\n+                            ()boolean -> {\n+                                %6 : char = constant @\"a\";\n+                                %7 : boolean = eq %4 %6;\n+                                yield %7;\n+                            }\n+                            ()boolean -> {\n+                                %8 : char = constant @\"e\";\n+                                %9 : boolean = eq %4 %8;\n+                                yield %9;\n+                            }\n+                            ()boolean -> {\n+                                %10 : char = constant @\"i\";\n+                                %11 : boolean = eq %4 %10;\n+                                yield %11;\n+                            }\n+                            ()boolean -> {\n+                                %12 : char = constant @\"o\";\n+                                %13 : boolean = eq %4 %12;\n+                                yield %13;\n+                            }\n+                            ()boolean -> {\n+                                %14 : char = constant @\"u\";\n+                                %15 : boolean = eq %4 %14;\n+                                yield %15;\n+                            };\n+                        yield %5;\n+                    }\n+                    ()void -> {\n+                        %16 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %17 : java.lang.String = constant @\"vowel\";\n+                        invoke %16 %17 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        java.switch.fallthrough;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %18 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %19 : java.lang.String = constant @\"else\";\n+                        invoke %18 %19 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static void caseConstantMultiLabels(char c) {\n+        switch (Character.toLowerCase(c)) {\n+            case 'a', 'e', 'i', 'o', 'u':\n+                System.out.println(\"vowel\");\n+            default:\n+                System.out.println(\"else\");\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantThrow\" (%0 : java.lang.Integer)void -> {\n+                %1 : Var<java.lang.Integer> = var %0 @\"i\";\n+                %2 : java.lang.Integer = var.load %1;\n+                java.switch.statement %2\n+                    (%3 : java.lang.Integer)boolean -> {\n+                        %4 : int = constant @\"8\";\n+                        %5 : java.lang.Integer = invoke %4 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %6 : boolean = invoke %3 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()void -> {\n+                        %7 : java.lang.IllegalArgumentException = new @\"func<java.lang.IllegalArgumentException>\";\n+                        throw %7;\n+                    }\n+                    (%8 : java.lang.Integer)boolean -> {\n+                        %9 : int = constant @\"9\";\n+                        %10 : java.lang.Integer = invoke %9 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %11 : boolean = invoke %8 %10 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %11;\n+                    }\n+                    ()void -> {\n+                        %12 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %13 : java.lang.String = constant @\"Nine\";\n+                        invoke %12 %13 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()void -> {\n+                        %14 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %15 : java.lang.String = constant @\"An integer\";\n+                        invoke %14 %15 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static void caseConstantThrow(Integer i) {\n+        switch (i) {\n+            case 8 -> throw new IllegalArgumentException();\n+            case 9 -> System.out.println(\"Nine\");\n+            default -> System.out.println(\"An integer\");\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchStatementTest.java","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"}]}