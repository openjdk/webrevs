{"files":[{"patch":"@@ -124,1 +124,1 @@\n-            } while (!(op instanceof Op.Loop));\n+            } while (!(op instanceof Op.Loop || op instanceof JavaSwitchStatementOp));\n@@ -127,2 +127,8 @@\n-            Op.Loop lop = (Op.Loop) op;\n-            return lop.loopBody() == b ? op : null;\n+            if (op instanceof Op.Loop lop) {\n+                return lop.loopBody() == b ? op : null;\n+            } else if (op instanceof JavaSwitchStatementOp swStat) {\n+                return swStat.bodies().contains(b) ? op : null;\n+            } else {\n+                \/\/ @@@ can't happen (at least for now)\n+                throw new IllegalStateException();\n+            }\n@@ -1028,1 +1034,1 @@\n-                            case YieldOp yop -> block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                            case YieldOp yop -> block.op(branch(exit.successor()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -811,1 +811,7 @@\n-                    case PLUS_ASG -> append(CoreOp.add(lhs, rhs));\n+                    case PLUS_ASG -> {\n+                        if (tree.operator.opcode == ByteCodes.string_add) {\n+                            yield append(CoreOp.concat(lhs, rhs));\n+                        } else {\n+                            yield append(CoreOp.add(lhs, rhs));\n+                        }\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+* @test\n+* @run testng TestSwitchStatementOp\n+* *\/\n+public class TestSwitchStatementOp {\n+\n+    @Test\n+    void testCaseConstantBehaviorIsSyntaxIndependent() {\n+        CoreOp.FuncOp ruleExpression = lower(\"caseConstantRuleExpression\");\n+        CoreOp.FuncOp ruleBlock = lower(\"caseConstantRuleBlock\");\n+        CoreOp.FuncOp statement = lower(\"caseConstantStatement\");\n+\n+        String[] args = {\"FOO\", \"BAR\", \"BAZ\", \"OTHER\"};\n+\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static String caseConstantRuleExpression(String r) {\n+        String s = \"\";\n+        switch (r) {\n+            case \"FOO\" -> s += \"BAR\";\n+            case \"BAR\" -> s += \"BAZ\";\n+            case \"BAZ\" -> s += \"FOO\";\n+            default -> s += \"else\";\n+        }\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String caseConstantRuleBlock(String r) {\n+        String s = \"\";\n+        switch (r) {\n+            case \"FOO\" -> {\n+                s += \"BAR\";\n+            }\n+            case \"BAR\" -> {\n+                s += \"BAZ\";\n+            }\n+            case \"BAZ\" -> {\n+                s += \"FOO\";\n+            }\n+            default -> {\n+                s += \"else\";\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    private static String caseConstantStatement(String s) {\n+        String r = \"\";\n+        switch (s) {\n+            case \"FOO\":\n+                r += \"BAR\";\n+                break;\n+            case \"BAR\":\n+                r += \"BAZ\";\n+                break;\n+            case \"BAZ\":\n+                r += \"FOO\";\n+                break;\n+            default:\n+                r += \"else\";\n+        }\n+        return r;\n+    }\n+\n+    private static CoreOp.FuncOp lower(String methodName) {\n+        return lower(getCodeModel(methodName));\n+    }\n+\n+    private static CoreOp.FuncOp lower(CoreOp.FuncOp f) {\n+        writeModel(f, System.out, OpWriter.LocationOption.DROP_LOCATION);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        writeModel(lf, System.out, OpWriter.LocationOption.DROP_LOCATION);\n+\n+        return lf;\n+    }\n+\n+    private static void writeModel(CoreOp.FuncOp f, OutputStream os, OpWriter.Option... options) {\n+        StringWriter sw = new StringWriter();\n+        new OpWriter(sw, options).writeOp(f);\n+        try {\n+            os.write(sw.toString().getBytes());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static CoreOp.FuncOp getCodeModel(String methodName) {\n+        Optional<Method> om = Stream.of(TestSwitchStatementOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchStatementOp.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}