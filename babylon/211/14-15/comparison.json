{"files":[{"patch":"@@ -1012,11 +1012,6 @@\n-                            case YieldOp yop -> {\n-                                if (isLastLabel) {\n-                                    block.op(branch(statement.successor()));\n-                                } else {\n-                                    block.op(conditionalBranch(\n-                                            block.context().getValue(yop.yieldValue()),\n-                                            statement.successor(),\n-                                            nextLabel.successor()\n-                                    ));\n-                                }\n-                            }\n+                            case YieldOp yop when yop.operands().isEmpty() -> block.op(branch(statement.successor()));\n+                            case YieldOp yop -> block.op(conditionalBranch(\n+                                    block.context().getValue(yop.yieldValue()),\n+                                    statement.successor(),\n+                                    isLastLabel ? exit.successor() : nextLabel.successor()\n+                            ));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-import java.util.Optional;\n+import java.util.*;\n@@ -232,0 +232,257 @@\n+    @Test\n+    void testCaseConstantConv() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantConv\");\n+        for (short i = 1; i < 5; i++) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, i), caseConstantConv(i));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String caseConstantConv(short a) {\n+        final short s = 1;\n+        final byte b = 2;\n+        String r = \"\";\n+        switch (a) {\n+            case s -> r += \"one\"; \/\/ identity, short -> short\n+            case b -> r += \"two\"; \/\/ widening primitive conversion, byte -> short\n+            case 3 -> r += \"three\"; \/\/ narrowing primitive conversion, int -> short\n+            default -> r += \"else\";\n+        }\n+        return r;\n+    }\n+\n+    @Test\n+    void testCaseConstantConv2() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantConv2\");\n+        Byte[] args = {1, 2, 3};\n+        for (Byte arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseConstantConv2(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String caseConstantConv2(Byte a) {\n+        final byte b = 2;\n+        String r = \"\";\n+        switch (a) {\n+            case 1 -> r+= \"one\"; \/\/ narrowing primitive conversion followed by a boxing conversion, int -> bye -> Byte\n+            case b -> r+= \"two\"; \/\/ boxing, byte -> Byte\n+            default -> r+= \"default\";\n+        }\n+        return r;\n+    }\n+\n+    @Test\n+    void testNonEnhancedSwStatNoDefault() {\n+        CoreOp.FuncOp lmodel = lower(\"nonEnhancedSwStatNoDefault\");\n+        for (int i = 1; i < 4; i++) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, i), nonEnhancedSwStatNoDefault(i));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String nonEnhancedSwStatNoDefault(int a) {\n+        String r = \"\";\n+        switch (a) {\n+            case 1 -> r += \"1\";\n+            case 2 -> r += 2;\n+        }\n+        return r;\n+    }\n+\n+    \/\/ no reason to test enhanced switch statement that has no default\n+    \/\/ because we can't test for MatchException without separate compilation\n+\n+    @Test\n+    void testEnhancedSwStatUnconditionalPattern() {\n+        CoreOp.FuncOp lmodel = lower(\"enhancedSwStatUnconditionalPattern\");\n+        String[] args = {\"A\", \"B\"};\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), enhancedSwStatUnconditionalPattern(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String enhancedSwStatUnconditionalPattern(String s) {\n+        String r = \"\";\n+        switch (s) {\n+            case \"A\" -> r += \"A\";\n+            case Object o -> r += \"obj\";\n+        }\n+        return r;\n+    }\n+\n+    @Test\n+    void testCasePatternBehaviorIsSyntaxIndependent() {\n+        CoreOp.FuncOp ruleExpression = lower(\"casePatternRuleExpression\");\n+        CoreOp.FuncOp ruleBlock = lower(\"casePatternRuleBlock\");\n+        CoreOp.FuncOp statement = lower(\"casePatternStatement\");\n+\n+        Object[] args = {1, \"2\", 3L};\n+\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternRuleExpression(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case Integer i -> r += \"integer\";\n+            case String s -> r+= \"string\";\n+            default -> r+= \"else\";\n+        }\n+        return r;\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternRuleBlock(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case Integer i -> {\n+                r += \"integer\";\n+            }\n+            case String s -> {\n+                r += \"string\";\n+            }\n+            default -> {\n+                r += \"else\";\n+            }\n+        }\n+        return r;\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternStatement(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case Integer i:\n+                r += \"integer\";\n+                break;\n+            case String s:\n+                r += \"string\";\n+                break;\n+            default:\n+                r += \"else\";\n+        }\n+        return r;\n+    }\n+\n+    @Test\n+    void testCasePatternThrow() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternThrow\");\n+\n+        Object[] args = {Byte.MAX_VALUE, Short.MIN_VALUE, 0, 1L, 11f, 22d};\n+        for (Object arg : args) {\n+            Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, arg));\n+        }\n+\n+        Object[] args2 = {\"abc\", List.of()};\n+        for (Object arg : args2) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternThrow(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static String casePatternThrow(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case Number n -> throw new IllegalArgumentException();\n+            case String s -> r += \"a string\";\n+            default -> r += o.getClass().getName();\n+        }\n+        return r;\n+    }\n+\n+    \/\/ @@@ when multi patterns is supported, we will test it\n+\n+    @Test\n+    void testCasePatternWithCaseConstant() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternWithCaseConstant\");\n+        int[] args = {42, 43, -44, 0};\n+        for (int arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), casePatternWithCaseConstant(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String casePatternWithCaseConstant(Integer a) {\n+        String r = \"\";\n+        switch (a) {\n+            case 42 -> r += \"forty two\";\n+            \/\/ @@@ case int will not match, because of the way InstanceOfOp is interpreted\n+            case Integer i when i > 0 -> r += \"positive int\";\n+            case Integer i when i < 0 -> r += \"negative int\";\n+            default -> r += \"zero\";\n+        }\n+        return r;\n+    }\n+\n+    @Test\n+    void testCaseTypePattern() {\n+        CoreOp.FuncOp lmodel = lower(\"caseTypePattern\");\n+        Object[] args = {\"str\", new ArrayList<>(), new int[]{}, new Stack[][]{}, new Collection[][][]{}, 8, 'x'};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseTypePattern(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String caseTypePattern(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case String _ -> r+= \"String\"; \/\/ class\n+            case RandomAccess _ -> r+= \"RandomAccess\"; \/\/ interface\n+            case int[] _ -> r+= \"int[]\"; \/\/ array primitive\n+            case Stack[][] _ -> r+= \"Stack[][]\"; \/\/ array class\n+            case Collection[][][] _ -> r+= \"Collection[][][]\"; \/\/ array interface\n+            case final Number n -> r+= \"Number\"; \/\/ final modifier\n+            default -> r+= \"something else\";\n+        }\n+        return r;\n+    }\n+\n+    @Test\n+    void testCaseRecordPattern() {\n+        \/\/ @@@ new R(null) must match the pattern R(Number c), but it doesn't\n+        \/\/ @@@ test with generic record\n+        CoreOp.FuncOp lmodel = lower(\"caseRecordPattern\");\n+        Object[] args = {new R(8), new R(1.0), new R(2L), \"abc\"};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), caseRecordPattern(arg));\n+        }\n+    }\n+\n+    record R(Number n) {}\n+    @CodeReflection\n+    static String caseRecordPattern(Object o) {\n+        String r = \"\";\n+        switch (o) {\n+            case R(Number n) -> r += \"R(_)\";\n+            default -> r+= \"else\";\n+        }\n+        return r;\n+    }\n+\n+    @Test\n+    void testCasePatternGuard() {\n+        CoreOp.FuncOp lmodel = lower(\"casePatternGuard\");\n+        Object[] args = {\"c++\", \"java\", new R(8), new R(2L), new R(3f), new R(4.0)};\n+        for (Object arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, arg), casePatternGuard(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String casePatternGuard(Object obj) {\n+        String r = \"\";\n+        switch (obj) {\n+            case String s when s.length() > 3 -> r += \"str with length > %d\".formatted(s.length());\n+            case R(Number n) when n.getClass().equals(Double.class) -> r += \"R(Double)\";\n+            default -> r += \"else\";\n+        }\n+        return r;\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchStatementOp.java","additions":258,"deletions":1,"binary":false,"changes":259,"status":"modified"}]}