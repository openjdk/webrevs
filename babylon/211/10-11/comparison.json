{"files":[{"patch":"@@ -452,1 +452,1 @@\n-                Tag.SWITCH, Tag.SYNCHRONIZED,\n+                Tag.SYNCHRONIZED,\n@@ -1675,0 +1675,174 @@\n+        @Override\n+        public void visitSwitch(JCTree.JCSwitch tree) {\n+            Value target = toValue(tree.selector);\n+\n+            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n+            FunctionType actionType = FunctionType.VOID;\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            for (JCTree.JCCase c : tree.cases) {\n+                \/\/ Labels body\n+                JCTree.JCCaseLabel headCl = c.labels.head;\n+                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                    if (c.labels.size() > 1) {\n+                        throw unsupported(c);\n+                    }\n+\n+                    pushBody(pcl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.guard != null) {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+\n+                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                        Value patVal = scanPattern(pcl.pat, localTarget);\n+                        append(CoreOp._yield(patVal));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                        append(CoreOp._yield(toValue(c.guard)));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        localResult = append(ExtendedOp.conditionalAnd(clBodies));\n+                    } else {\n+                        localResult = scanPattern(pcl.pat, localTarget);\n+                    }\n+                    \/\/ Yield the boolean result of the condition\n+                    append(CoreOp._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                    pushBody(headCl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.labels.size() == 1) {\n+                        Value expr = toValue(ccl.expr);\n+                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                        \/\/ so, we convert constant to the type of the selector expression\n+                        expr = convert(expr, tree.selector.type);\n+                        if (tree.selector.type.isPrimitive()) {\n+                            localResult = append(CoreOp.eq(localTarget, expr));\n+                        } else {\n+                            localResult = append(CoreOp.invoke(\n+                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                    localTarget, expr));\n+                        }\n+                    } else {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+                        for (JCTree.JCCaseLabel cl : c.labels) {\n+                            ccl = (JCTree.JCConstantCaseLabel) cl;\n+                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n+\n+                            Value expr = toValue(ccl.expr);\n+                            expr = convert(expr, tree.selector.type);\n+                            final Value labelResult;\n+                            if (tree.selector.type.isPrimitive()) {\n+                                labelResult = append(CoreOp.eq(localTarget, expr));\n+                            } else {\n+                                labelResult = append(CoreOp.invoke(\n+                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                        localTarget, expr));\n+                            }\n+\n+                            append(CoreOp._yield(labelResult));\n+                            clBodies.add(stack.body);\n+\n+                            \/\/ Pop label\n+                            popBody();\n+                        }\n+\n+                        localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                    }\n+\n+                    append(CoreOp._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop labels\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                    \/\/ @@@ Do we need to model the default label body?\n+                    pushBody(headCl, FunctionType.VOID);\n+\n+                    append(CoreOp._yield());\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else {\n+                    throw unsupported(tree);\n+                }\n+\n+                \/\/ Statements body\n+                switch (c.caseKind) {\n+                    case RULE -> {\n+                        pushBody(c.body, actionType);\n+                        if (c.body instanceof JCTree.JCBlock b) {\n+                            toValue(b);\n+                            if (!(b.stats.last() instanceof JCTree.JCBreak)) {\n+                                append(CoreOp._yield()); \/\/ @@@ _break is also an option\n+                            }\n+                        }\n+                        else if (c.body instanceof JCTree.JCStatement s) {\n+                            toValue(s);\n+                            if (!(s instanceof JCTree.JCThrow)) {\n+                                append(CoreOp._yield());\n+                            }\n+                        }\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                    case STATEMENT -> {\n+                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                        pushBody(c, actionType);\n+\n+                        scan(c.stats);\n+\n+                        appendTerminating(c.completesNormally ?\n+                                headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n+                                : CoreOp::unreachable);\n+\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                };\n+            }\n+\n+            \/\/ if enhanced switch and no default label\n+            \/\/ enhanced: target type not byte, char short, int, String, or, has case pattern or case null\n+            boolean enhancedSw = !List.of(JavaType.BYTE, JavaType.CHAR, JavaType.SHORT, JavaType.INT,\n+                    JavaType.J_L_BYTE, JavaType.J_L_CHARACTER, JavaType.J_L_SHORT, JavaType.J_L_INTEGER,\n+                    JavaType.J_L_STRING).contains(typeToTypeElement(tree.selector.type));\n+            enhancedSw = enhancedSw && !Flags.isEnum(tree.selector.type.tsym);\n+            enhancedSw = enhancedSw || tree.patternSwitch;\n+            enhancedSw = enhancedSw || tree.cases.stream().anyMatch(c -> c.labels.stream().anyMatch(l -> {\n+                return l instanceof JCTree.JCConstantCaseLabel ccl && ccl.expr instanceof JCLiteral literal && literal.value == null;\n+            }));\n+            if (enhancedSw && !tree.hasUnconditionalPattern) {\n+                \/\/ label\n+                pushBody(tree, FunctionType.VOID);\n+                append(CoreOp._yield());\n+                bodies.add(stack.body);\n+                popBody();\n+\n+                \/\/ statement\n+                pushBody(tree, actionType);\n+                append(CoreOp._throw(\n+                        append(CoreOp._new(FunctionType.functionType(JavaType.type(MatchException.class))))\n+                ));\n+                bodies.add(stack.body);\n+                popBody();\n+            }\n+\n+            result = append(ExtendedOp.switchStatement(target, bodies));\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":175,"deletions":1,"binary":false,"changes":176,"status":"modified"}]}