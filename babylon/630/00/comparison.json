{"files":[{"patch":"@@ -45,1 +45,10 @@\n-            return null;\n+            return new F16() {\n+                @Override\n+                public short value() {\n+                    return floatToF16(value);\n+                }\n+\n+                @Override\n+                public void value(short value) {\n+                }\n+            };\n@@ -57,1 +66,1 @@\n-            return null;\n+            return F16.of(f16ToFloat(ha.value()) + f16ToFloat(hb.value()));\n@@ -61,1 +70,1 @@\n-            return null;\n+            return F16.of(f16ToFloat(ha.value()) - f16ToFloat(hb.value()));\n@@ -65,1 +74,1 @@\n-            return null;\n+            return F16.of(f16ToFloat(ha.value()) * f16ToFloat(hb.value()));\n@@ -69,1 +78,1 @@\n-            return null;\n+            return F16.of(f16ToFloat(ha.value()) \/ f16ToFloat(hb.value()));\n@@ -83,1 +92,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F16Array.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-                \"hat.test.TestFP16Type\"\n+                \"hat.test.TestF16Type\"\n","filename":"hat\/hat\/test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,321 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.test;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.F16Array;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.MappableIface.RW;\n+import hat.test.annotation.HatTest;\n+import hat.test.engine.HatAsserts;\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Random;\n+\n+import static hat.buffer.F16Array.F16;\n+\n+public class TestF16Type {\n+\n+    @CodeReflection\n+    public static void copy01(@RO KernelContext kernelContext, @RO F16Array a, @RW F16Array b) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            F16Array.F16 hb = b.array(kernelContext.gix);\n+\n+            \/\/ The following expression does not work\n+            \/\/b.array(kernelContext.gix).value(ha.value());\n+\n+            hb.value(ha.value());\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void f16Ops_02(@RO KernelContext kernelContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            F16Array.F16 hb = b.array(kernelContext.gix);\n+\n+            F16Array.F16 result = F16.add(ha, hb);\n+            F16Array.F16 hC = c.array(kernelContext.gix);\n+            hC.value(result.value());\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void f16Ops_03(@RO KernelContext kernelContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            F16Array.F16 hb = b.array(kernelContext.gix);\n+\n+            F16Array.F16 result = F16.add(ha, F16.add(hb, hb));\n+            F16Array.F16 hC = c.array(kernelContext.gix);\n+            hC.value(result.value());\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void f16Ops_04(@RO KernelContext kernelContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            F16Array.F16 hb = b.array(kernelContext.gix);\n+\n+            F16Array.F16 r1 = F16.mul(ha, hb);\n+            F16Array.F16 r2 = F16.div(ha, hb);\n+            F16Array.F16 r3 = F16.sub(ha, hb);\n+            F16Array.F16 r4 = F16.add(r1, r2);\n+            F16Array.F16 r5 = F16.add(r4, r3);\n+            F16Array.F16 hC = c.array(kernelContext.gix);\n+            hC.value(r5.value());\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void f16Ops_05(@RO KernelContext kernelContext, @RW F16Array a) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            F16Array.F16 initVal = F16.of( 2.1f);\n+            ha.value(initVal.value());\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void f16Ops_06(@RO KernelContext kernelContext, @RW F16Array a) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 initVal = F16.of( kernelContext.gix);\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            ha.value(initVal.value());\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void compute01(@RO ComputeContext computeContext, @RO F16Array a, @RW F16Array b) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.copy01(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void compute02(@RO ComputeContext computeContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.f16Ops_02(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void compute03(@RO ComputeContext computeContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.f16Ops_03(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void compute04(@RO ComputeContext computeContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.f16Ops_04(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void compute05(@RO ComputeContext computeContext, @RW F16Array a) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.f16Ops_05(kernelContext, a));\n+    }\n+\n+    @CodeReflection\n+    public static void compute06(@RO ComputeContext computeContext, @RW F16Array a) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestF16Type.f16Ops_06(kernelContext, a));\n+    }\n+\n+    @HatTest\n+    public void testF16_01() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        F16Array arrayB = F16Array.create(accelerator, size);\n+\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.floatToF16(i));\n+        }\n+\n+        accelerator.compute(computeContext -> TestF16Type.compute01(computeContext, arrayA, arrayB));\n+\n+        for (int i = 0; i < arrayB.length(); i++) {\n+            short val = arrayB.array(i).value();\n+            HatAsserts.assertEquals((float)i, F16.f16ToFloat(val), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testF16_02() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        F16Array arrayB = F16Array.create(accelerator, size);\n+        F16Array arrayC = F16Array.create(accelerator, size);\n+\n+        Random random = new Random();\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.floatToF16(random.nextFloat()));\n+            arrayB.array(i).value(F16.floatToF16(random.nextFloat()));\n+        }\n+\n+        accelerator.compute(computeContext -> {\n+            TestF16Type.compute02(computeContext, arrayA, arrayB, arrayC);\n+        });\n+\n+        for (int i = 0; i < arrayC.length(); i++) {\n+            short val = arrayC.array(i).value();\n+            float fa = Float.float16ToFloat(arrayA.array(i).value());\n+            float fb = Float.float16ToFloat(arrayB.array(i).value());\n+            HatAsserts.assertEquals((fa + fb), F16.f16ToFloat(val), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testF16_03() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        F16Array arrayB = F16Array.create(accelerator, size);\n+        F16Array arrayC = F16Array.create(accelerator, size);\n+\n+        Random random = new Random();\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.floatToF16(random.nextFloat()));\n+            arrayB.array(i).value(F16.floatToF16(random.nextFloat()));\n+        }\n+\n+        accelerator.compute(computeContext -> {\n+            TestF16Type.compute03(computeContext, arrayA, arrayB, arrayC);\n+        });\n+\n+        for (int i = 0; i < arrayC.length(); i++) {\n+            short val = arrayC.array(i).value();\n+            float fa = Float.float16ToFloat(arrayA.array(i).value());\n+            float fb = Float.float16ToFloat(arrayB.array(i).value());\n+            HatAsserts.assertEquals((fa + fb + fb), F16.f16ToFloat(val), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testF16_04() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        F16Array arrayB = F16Array.create(accelerator, size);\n+        F16Array arrayC = F16Array.create(accelerator, size);\n+\n+        Random random = new Random();\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.floatToF16(random.nextFloat()));\n+            arrayB.array(i).value(F16.floatToF16(random.nextFloat()));\n+        }\n+\n+        accelerator.compute(computeContext -> {\n+            TestF16Type.compute04(computeContext, arrayA, arrayB, arrayC);\n+        });\n+\n+        for (int i = 0; i < arrayC.length(); i++) {\n+            short val = arrayC.array(i).value();\n+            F16Array.F16 ha = arrayA.array(i);\n+            F16Array.F16 hb = arrayB.array(i);\n+\n+            float fa = Float.float16ToFloat(ha.value());\n+            float fb = Float.float16ToFloat(hb.value());\n+            float r1 = fa * fb;\n+            float r2 = fa \/ fb;\n+            float r3 = fa - fb;\n+            float r4 = r1 + r2;\n+            float r5 = r4 + r3;\n+            HatAsserts.assertEquals(r5, Float.float16ToFloat(val), 0.01f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testF16_05() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.floatToF16(0.0f));\n+        }\n+\n+        accelerator.compute(computeContext -> {\n+            TestF16Type.compute05(computeContext, arrayA);\n+        });\n+\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            short val = arrayA.array(i).value();\n+            HatAsserts.assertEquals(2.1f, Float.float16ToFloat(val), 0.01f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testF16_06() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.floatToF16(0.0f));\n+        }\n+\n+        accelerator.compute(computeContext -> {\n+            TestF16Type.compute06(computeContext, arrayA);\n+        });\n+\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            short val = arrayA.array(i).value();\n+            HatAsserts.assertEquals(i, Float.float16ToFloat(val), 0.01f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testF16_07() {\n+        \/\/ Test CPU Implementation of F16\n+        F16 a = F16.of(2.5f);\n+        F16 b = F16.of(3.5f);\n+        F16 c = F16.add(a, b);\n+        HatAsserts.assertEquals((2.5f + 3.5f), Float.float16ToFloat(c.value()), 0.01f);\n+\n+        F16 d = F16.sub(a, b);\n+        HatAsserts.assertEquals((2.5f - 3.5f), Float.float16ToFloat(d.value()), 0.01f);\n+\n+        F16 e = F16.mul(a, b);\n+        HatAsserts.assertEquals((2.5f * 3.5f), Float.float16ToFloat(e.value()), 0.01f);\n+\n+        F16 f = F16.div(a, b);\n+        HatAsserts.assertEquals((2.5f \/ 3.5f), Float.float16ToFloat(f.value()), 0.01f);\n+    }\n+\n+}\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestF16Type.java","additions":321,"deletions":0,"binary":false,"changes":321,"status":"added"},{"patch":"@@ -1,303 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.test;\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.ComputeRange;\n-import hat.GlobalMesh1D;\n-import hat.KernelContext;\n-import hat.backend.Backend;\n-import hat.buffer.F16Array;\n-import hat.ifacemapper.MappableIface.RO;\n-import hat.ifacemapper.MappableIface.RW;\n-import hat.test.annotation.HatTest;\n-import hat.test.engine.HatAsserts;\n-import jdk.incubator.code.CodeReflection;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.Random;\n-\n-import static hat.buffer.F16Array.F16;\n-\n-public class TestFP16Type {\n-\n-    @CodeReflection\n-    public static void copy01(@RO KernelContext kernelContext, @RO F16Array a, @RW F16Array b) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            F16Array.F16 ha = a.array(kernelContext.gix);\n-            F16Array.F16 hb = b.array(kernelContext.gix);\n-\n-            \/\/ The following expression does not work\n-            \/\/b.array(kernelContext.gix).value(ha.value());\n-\n-            hb.value(ha.value());\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void fp16Ops_02(@RO KernelContext kernelContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            F16Array.F16 ha = a.array(kernelContext.gix);\n-            F16Array.F16 hb = b.array(kernelContext.gix);\n-\n-            F16Array.F16 result = F16.add(ha, hb);\n-            F16Array.F16 hC = c.array(kernelContext.gix);\n-            hC.value(result.value());\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void fp16Ops_03(@RO KernelContext kernelContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            F16Array.F16 ha = a.array(kernelContext.gix);\n-            F16Array.F16 hb = b.array(kernelContext.gix);\n-\n-            F16Array.F16 result = F16.add(ha, F16.add(hb, hb));\n-            F16Array.F16 hC = c.array(kernelContext.gix);\n-            hC.value(result.value());\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void fp16Ops_04(@RO KernelContext kernelContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            F16Array.F16 ha = a.array(kernelContext.gix);\n-            F16Array.F16 hb = b.array(kernelContext.gix);\n-\n-            F16Array.F16 r1 = F16.mul(ha, hb);\n-            F16Array.F16 r2 = F16.div(ha, hb);\n-            F16Array.F16 r3 = F16.sub(ha, hb);\n-            F16Array.F16 r4 = F16.add(r1, r2);\n-            F16Array.F16 r5 = F16.add(r4, r3);\n-            F16Array.F16 hC = c.array(kernelContext.gix);\n-            hC.value(r5.value());\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void fp16Ops_05(@RO KernelContext kernelContext, @RW F16Array a) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            F16Array.F16 ha = a.array(kernelContext.gix);\n-            F16Array.F16 initVal = F16.of( 2.1f);\n-            ha.value(initVal.value());\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void fp16Ops_06(@RO KernelContext kernelContext, @RW F16Array a) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            F16Array.F16 initVal = F16.of( kernelContext.gix);\n-            F16Array.F16 ha = a.array(kernelContext.gix);\n-            ha.value(initVal.value());\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void compute01(@RO ComputeContext computeContext, @RO F16Array a, @RW F16Array b) {\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.copy01(kernelContext, a, b));\n-    }\n-\n-    @CodeReflection\n-    public static void compute02(@RO ComputeContext computeContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.fp16Ops_02(kernelContext, a, b, c));\n-    }\n-\n-    @CodeReflection\n-    public static void compute03(@RO ComputeContext computeContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.fp16Ops_03(kernelContext, a, b, c));\n-    }\n-\n-    @CodeReflection\n-    public static void compute04(@RO ComputeContext computeContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.fp16Ops_04(kernelContext, a, b, c));\n-    }\n-\n-    @CodeReflection\n-    public static void compute05(@RO ComputeContext computeContext, @RW F16Array a) {\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.fp16Ops_05(kernelContext, a));\n-    }\n-\n-    @CodeReflection\n-    public static void compute06(@RO ComputeContext computeContext, @RW F16Array a) {\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n-        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.fp16Ops_06(kernelContext, a));\n-    }\n-\n-    @HatTest\n-    public void testF16_01() {\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-\n-        final int size = 16;\n-        F16Array arrayA = F16Array.create(accelerator, size);\n-        F16Array arrayB = F16Array.create(accelerator, size);\n-\n-        for (int i = 0; i < arrayA.length(); i++) {\n-            arrayA.array(i).value(F16.floatToF16(i));\n-        }\n-\n-        accelerator.compute(computeContext -> TestFP16Type.compute01(computeContext, arrayA, arrayB));\n-\n-        for (int i = 0; i < arrayB.length(); i++) {\n-            short val = arrayB.array(i).value();\n-            HatAsserts.assertEquals((float)i, F16.f16ToFloat(val), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void testF16_02() {\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-\n-        final int size = 16;\n-        F16Array arrayA = F16Array.create(accelerator, size);\n-        F16Array arrayB = F16Array.create(accelerator, size);\n-        F16Array arrayC = F16Array.create(accelerator, size);\n-\n-        Random random = new Random();\n-        for (int i = 0; i < arrayA.length(); i++) {\n-            arrayA.array(i).value(F16.floatToF16(random.nextFloat()));\n-            arrayB.array(i).value(F16.floatToF16(random.nextFloat()));\n-        }\n-\n-        accelerator.compute(computeContext -> {\n-            TestFP16Type.compute02(computeContext, arrayA, arrayB, arrayC);\n-        });\n-\n-        for (int i = 0; i < arrayC.length(); i++) {\n-            short val = arrayC.array(i).value();\n-            float fa = Float.float16ToFloat(arrayA.array(i).value());\n-            float fb = Float.float16ToFloat(arrayB.array(i).value());\n-            HatAsserts.assertEquals((fa + fb), F16.f16ToFloat(val), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void testF16_03() {\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-\n-        final int size = 16;\n-        F16Array arrayA = F16Array.create(accelerator, size);\n-        F16Array arrayB = F16Array.create(accelerator, size);\n-        F16Array arrayC = F16Array.create(accelerator, size);\n-\n-        Random random = new Random();\n-        for (int i = 0; i < arrayA.length(); i++) {\n-            arrayA.array(i).value(F16.floatToF16(random.nextFloat()));\n-            arrayB.array(i).value(F16.floatToF16(random.nextFloat()));\n-        }\n-\n-        accelerator.compute(computeContext -> {\n-            TestFP16Type.compute03(computeContext, arrayA, arrayB, arrayC);\n-        });\n-\n-        for (int i = 0; i < arrayC.length(); i++) {\n-            short val = arrayC.array(i).value();\n-            float fa = Float.float16ToFloat(arrayA.array(i).value());\n-            float fb = Float.float16ToFloat(arrayB.array(i).value());\n-            HatAsserts.assertEquals((fa + fb + fb), F16.f16ToFloat(val), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void testF16_04() {\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-\n-        final int size = 16;\n-        F16Array arrayA = F16Array.create(accelerator, size);\n-        F16Array arrayB = F16Array.create(accelerator, size);\n-        F16Array arrayC = F16Array.create(accelerator, size);\n-\n-        Random random = new Random();\n-        for (int i = 0; i < arrayA.length(); i++) {\n-            arrayA.array(i).value(F16.floatToF16(random.nextFloat()));\n-            arrayB.array(i).value(F16.floatToF16(random.nextFloat()));\n-        }\n-\n-        accelerator.compute(computeContext -> {\n-            TestFP16Type.compute04(computeContext, arrayA, arrayB, arrayC);\n-        });\n-\n-        for (int i = 0; i < arrayC.length(); i++) {\n-            short val = arrayC.array(i).value();\n-            F16Array.F16 ha = arrayA.array(i);\n-            F16Array.F16 hb = arrayB.array(i);\n-\n-            float fa = Float.float16ToFloat(ha.value());\n-            float fb = Float.float16ToFloat(hb.value());\n-            float r1 = fa * fb;\n-            float r2 = fa \/ fb;\n-            float r3 = fa - fb;\n-            float r4 = r1 + r2;\n-            float r5 = r4 + r3;\n-            HatAsserts.assertEquals(r5, Float.float16ToFloat(val), 0.01f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void testF16_05() {\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-\n-        final int size = 16;\n-        F16Array arrayA = F16Array.create(accelerator, size);\n-        for (int i = 0; i < arrayA.length(); i++) {\n-            arrayA.array(i).value(F16.floatToF16(0.0f));\n-        }\n-\n-        accelerator.compute(computeContext -> {\n-            TestFP16Type.compute05(computeContext, arrayA);\n-        });\n-\n-        for (int i = 0; i < arrayA.length(); i++) {\n-            short val = arrayA.array(i).value();\n-            HatAsserts.assertEquals(2.1f, Float.float16ToFloat(val), 0.01f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void testF16_06() {\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-\n-        final int size = 16;\n-        F16Array arrayA = F16Array.create(accelerator, size);\n-        for (int i = 0; i < arrayA.length(); i++) {\n-            arrayA.array(i).value(F16.floatToF16(0.0f));\n-        }\n-\n-        accelerator.compute(computeContext -> {\n-            TestFP16Type.compute06(computeContext, arrayA);\n-        });\n-\n-        for (int i = 0; i < arrayA.length(); i++) {\n-            short val = arrayA.array(i).value();\n-            HatAsserts.assertEquals(i, Float.float16ToFloat(val), 0.01f);\n-        }\n-    }\n-\n-}\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestFP16Type.java","additions":0,"deletions":303,"binary":false,"changes":303,"status":"deleted"},{"patch":"@@ -248,1 +248,1 @@\n-                float sum = 0.0f;\n+                F16 sum = F16.of(0.0f);\n@@ -252,1 +252,1 @@\n-                    sum += Float.float16ToFloat(a.value()) * Float.float16ToFloat(b.value());\n+                    sum = F16.add(sum, F16.mul(a, b));\n@@ -254,1 +254,1 @@\n-                matrixC.array((long) i * size + j).value(Float.floatToFloat16(sum));\n+                matrixC.array((long) i * size + j).value(sum.value());\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMatMul.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}