{"files":[{"patch":"@@ -65,0 +65,2 @@\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.PrimitiveType;\n@@ -267,1 +269,2 @@\n-            cob.constantInstruction(((Constable)constantOp.value()).describeConstable().orElseThrow());\n+            var c = (Constable)constantOp.value();\n+            cob.constantInstruction(c == null ? ConstantDescs.NULL : c.describeConstable().orElseThrow());\n@@ -387,1 +390,1 @@\n-    private static ClassDesc toClassDesc(TypeElement t) {\n+    static ClassDesc toClassDesc(TypeElement t) {\n@@ -396,1 +399,1 @@\n-    private static TypeKind toTypeKind(TypeElement t) {\n+    static TypeKind toTypeKind(TypeElement t) {\n@@ -399,26 +402,2 @@\n-            case JavaType jt -> {\n-                TypeElement bt = jt.toBasicType();\n-                if (bt.equals(JavaType.VOID)) {\n-                    yield TypeKind.VoidType;\n-                } else if (bt.equals(JavaType.INT)) {\n-                    yield TypeKind.IntType;\n-                } else if (bt.equals(JavaType.J_L_OBJECT)) {\n-                    yield TypeKind.ReferenceType;\n-                } else if (bt.equals(JavaType.LONG)) {\n-                    yield TypeKind.LongType;\n-                } else if (bt.equals(JavaType.DOUBLE)) {\n-                    yield TypeKind.DoubleType;\n-                } else if (bt.equals(JavaType.BOOLEAN)) {\n-                    yield TypeKind.BooleanType;\n-                } else if (bt.equals(JavaType.BYTE)) {\n-                    yield TypeKind.ByteType;\n-                } else if (bt.equals(JavaType.CHAR)) {\n-                    yield TypeKind.CharType;\n-                } else if (bt.equals(JavaType.FLOAT)) {\n-                    yield TypeKind.FloatType;\n-                } else if (bt.equals(JavaType.SHORT)) {\n-                    yield TypeKind.ShortType;\n-                } else {\n-                    throw new IllegalArgumentException(\"Bad type: \" + t);\n-                }\n-            }\n+            case PrimitiveType pt -> TypeKind.from(pt.toNominalDescriptor());\n+            case JavaType _ -> TypeKind.ReferenceType;\n@@ -563,1 +542,1 @@\n-                        if (tk != rvt) cob.convertInstruction(tk, rvt);\n+                        if (tk != rvt) conversion(cob, tk, rvt);\n@@ -925,0 +904,60 @@\n+    \/\/ @@@ this method will apperar in CodeBuilder with next merge\/update from master\n+    static CodeBuilder conversion(CodeBuilder cob, TypeKind fromType, TypeKind toType) {\n+        return switch (fromType) {\n+            case IntType, ByteType, CharType, ShortType, BooleanType ->\n+                    switch (toType) {\n+                        case IntType -> cob;\n+                        case LongType -> cob.i2l();\n+                        case DoubleType -> cob.i2d();\n+                        case FloatType -> cob.i2f();\n+                        case ByteType -> cob.i2b();\n+                        case CharType -> cob.i2c();\n+                        case ShortType -> cob.i2s();\n+                        case BooleanType -> cob.iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case LongType ->\n+                    switch (toType) {\n+                        case IntType -> cob.l2i();\n+                        case LongType -> cob;\n+                        case DoubleType -> cob.l2d();\n+                        case FloatType -> cob.l2f();\n+                        case ByteType -> cob.l2i().i2b();\n+                        case CharType -> cob.l2i().i2c();\n+                        case ShortType -> cob.l2i().i2s();\n+                        case BooleanType -> cob.l2i().iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case DoubleType ->\n+                    switch (toType) {\n+                        case IntType -> cob.d2i();\n+                        case LongType -> cob.d2l();\n+                        case DoubleType -> cob;\n+                        case FloatType -> cob.d2f();\n+                        case ByteType -> cob.d2i().i2b();\n+                        case CharType -> cob.d2i().i2c();\n+                        case ShortType -> cob.d2i().i2s();\n+                        case BooleanType -> cob.d2i().iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case FloatType ->\n+                    switch (toType) {\n+                        case IntType -> cob.f2i();\n+                        case LongType -> cob.f2l();\n+                        case DoubleType -> cob.f2d();\n+                        case FloatType -> cob;\n+                        case ByteType -> cob.f2i().i2b();\n+                        case CharType -> cob.f2i().i2c();\n+                        case ShortType -> cob.f2i().i2s();\n+                        case BooleanType -> cob.f2i().iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case VoidType, ReferenceType ->\n+                throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+        };\n+    }\n+\n@@ -1035,1 +1074,1 @@\n-            case IntType ->\n+            case IntType, BooleanType, ByteType, ShortType, CharType ->\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":70,"deletions":31,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.classfile.PseudoInstruction;\n@@ -71,1 +72,2 @@\n-    private final Map<String, Op.Result> varMap;\n+    private final LocalsTypeMapper codeTracker;\n+    private final List<CodeElement> elements;\n@@ -75,4 +77,0 @@\n-    private static String varName(int slot, TypeKind tk) {\n-        return tk.typeName() + slot;\n-    }\n-\n@@ -107,1 +105,1 @@\n-        this.varMap = new HashMap<>();\n+        this.elements = codeModel.elementList();\n@@ -109,8 +107,2 @@\n-        List<Block.Parameter> bps = entryBlock.parameters();\n-        List<ClassDesc> mps = methodModel.methodTypeSymbol().parameterList();\n-        for (int i = 0, slot = 0; i < bps.size(); i++) {\n-            TypeKind tk = TypeKind.from(mps.get(i)).asLoadable();\n-            varStore(slot, tk, bps.get(i));\n-            slot += tk.slotSize();\n-        }\n-        this.blockMap = codeModel.findAttribute(Attributes.STACK_MAP_TABLE).map(sma ->\n+        var smta = codeModel.findAttribute(Attributes.STACK_MAP_TABLE);\n+        this.blockMap = smta.map(sma ->\n@@ -120,1 +112,0 @@\n-    }\n@@ -122,10 +113,6 @@\n-    private void varStore(int slot, TypeKind tk, Value value) {\n-        varMap.compute(varName(slot, tk), (varName, var) -> {\n-            if (var == null) {\n-                return op(CoreOp.var(varName, value));\n-            } else {\n-                op(CoreOp.varStore(var, value));\n-                return var;\n-            }\n-        });\n-    }\n+        List<Block.Parameter> bps = entryBlock.parameters();\n+        MethodTypeDesc mtd = methodModel.methodTypeSymbol();\n+        for (int i = 0, slot = 0; i < bps.size(); i++) {\n+            op(SlotOp.store(slot, bps.get(i)));\n+            slot += TypeKind.from(mtd.parameterType(i)).slotSize();\n+        }\n@@ -133,4 +120,1 @@\n-    private Op.Result var(int slot, TypeKind tk) {\n-        Op.Result r = varMap.get(varName(slot, tk));\n-        if (r == null) throw new IllegalArgumentException(\"Undeclared variable: \" + slot + \"-\" + tk); \/\/ @@@ these cases may need lazy var injection\n-        return r;\n+        this.codeTracker = new LocalsTypeMapper(methodModel.parent().get().thisClass().asSymbol(), mtd, methodModel.flags().has(AccessFlag.STATIC), smta, elements);\n@@ -157,1 +141,1 @@\n-        return CoreOp.func(\n+        var lifted = CoreOp.func(\n@@ -161,0 +145,1 @@\n+        return SlotSSA.transform(lifted);\n@@ -196,2 +181,0 @@\n-\n-        List<CodeElement> elements = codeModel.elementList();\n@@ -204,6 +187,9 @@\n-                    \/\/ Start of a new block\n-                    Block.Builder next = getBlock(lt.label());\n-                    if (currentBlock != null) {\n-                        \/\/ Implicit goto next block, add explicitly\n-                        \/\/ Use stack content as next block arguments\n-                        op(CoreOp.branch(next.successor(List.copyOf(stack))));\n+                    Block.Builder next = blockMap.get(lt.label());\n+                    \/\/ Start of a new block if defined by stack maps\n+                    if (next != null) {\n+                        if (currentBlock != null) {\n+                            \/\/ Implicit goto next block, add explicitly\n+                            \/\/ Use stack content as next block arguments\n+                            op(CoreOp.branch(next.successor(List.copyOf(stack))));\n+                        }\n+                        moveTo(next);\n@@ -211,1 +197,0 @@\n-                    moveTo(next);\n@@ -261,4 +246,1 @@\n-                    if (!stack.isEmpty()) {\n-                        throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n-                    }\n-                    Block.Builder next = currentBlock.block();\n+                    Block.Builder next = newBlock();\n@@ -266,2 +248,2 @@\n-                            next.successor(),\n-                            getBlock(inst.target()).successor()));\n+                            next.successor(List.copyOf(stack)),\n+                            getBlock(inst.target()).successor(List.copyOf(stack))));\n@@ -293,1 +275,1 @@\n-                    stack.push(op(CoreOp.varLoad(var(inst.slot(), inst.typeKind()))));\n+                    stack.push(op(SlotOp.load(inst.slot(), JavaType.type(codeTracker.getTypeOf(inst)))));\n@@ -296,1 +278,1 @@\n-                    varStore(inst.slot(), inst.typeKind(), stack.pop());\n+                    op(SlotOp.store(inst.slot(), stack.pop()));\n@@ -299,3 +281,3 @@\n-                    varStore(inst.slot(), TypeKind.IntType, op(CoreOp.add(\n-                            op(CoreOp.varLoad(var(inst.slot(), TypeKind.IntType))),\n-                            op(CoreOp.constant(JavaType.INT, inst.constant())))));\n+                    op(SlotOp.store(inst.slot(), op(CoreOp.add(\n+                            op(SlotOp.load(inst.slot(), JavaType.INT)),\n+                            op(CoreOp.constant(JavaType.INT, inst.constant()))))));\n@@ -353,0 +335,6 @@\n+                        case ISHL, LSHL ->\n+                                CoreOp.lshl(stack.pop(), operand);\n+                        case ISHR, LSHR ->\n+                                CoreOp.ashr(stack.pop(), operand);\n+                        case IUSHR, LUSHR ->\n+                                CoreOp.lshr(stack.pop(), operand);\n@@ -463,0 +451,3 @@\n+                case TypeCheckInstruction inst -> {\n+                    stack.push(op(CoreOp.instanceOf(JavaType.type(inst.type().asSymbol()), stack.pop())));\n+                }\n@@ -465,3 +456,88 @@\n-                        case POP, POP2 -> stack.pop(); \/\/ @@@ check the type width\n-                        case DUP, DUP2 -> stack.push(stack.peek());\n-                        \/\/@@@ implement all other stack ops\n+                        case POP -> {\n+                            stack.pop();\n+                        }\n+                        case POP2 -> {\n+                            if (isCategory1(stack.pop())) {\n+                                stack.pop();\n+                            }\n+                        }\n+                        case DUP -> {\n+                            stack.push(stack.peek());\n+                        }\n+                        case DUP_X1 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            stack.push(value1);\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case DUP_X2 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            if (isCategory1(value2)) {\n+                                var value3 = stack.pop();\n+                                stack.push(value1);\n+                                stack.push(value3);\n+                            } else {\n+                                stack.push(value1);\n+                            }\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case DUP2 -> {\n+                            var value1 = stack.peek();\n+                            if (isCategory1(value1)) {\n+                                stack.pop();\n+                                var value2 = stack.peek();\n+                                stack.push(value1);\n+                                stack.push(value2);\n+                            }\n+                            stack.push(value1);\n+                        }\n+                        case DUP2_X1 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            if (isCategory1(value1)) {\n+                                var value3 = stack.pop();\n+                                stack.push(value2);\n+                                stack.push(value1);\n+                                stack.push(value3);\n+                            } else {\n+                                stack.push(value1);\n+                            }\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case DUP2_X2 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            if (isCategory1(value1)) {\n+                                var value3 = stack.pop();\n+                                if (isCategory1(value3)) {\n+                                    var value4 = stack.pop();\n+                                    stack.push(value2);\n+                                    stack.push(value1);\n+                                    stack.push(value4);\n+                                } else {\n+                                    stack.push(value2);\n+                                    stack.push(value1);\n+                                }\n+                                stack.push(value3);\n+                            } else {\n+                                if (isCategory1(value2)) {\n+                                    var value3 = stack.pop();\n+                                    stack.push(value1);\n+                                    stack.push(value3);\n+                                } else {\n+                                    stack.push(value1);\n+                                }\n+                            }\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case SWAP -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            stack.push(value1);\n+                            stack.push(value2);\n+                        }\n@@ -472,0 +548,1 @@\n+                case PseudoInstruction _ -> {}\n@@ -479,0 +556,4 @@\n+\n+    private static boolean isCategory1(Value v) {\n+        return BytecodeGenerator.toTypeKind(v.type()).slotSize() == 1;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":134,"deletions":53,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapFrameInfo.ObjectVerificationTypeInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.ClassDesc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n+import java.lang.constant.ConstantDescs;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.IdentityHashMap;\n+\n+public final class LocalsTypeMapper {\n+\n+    private final Map<LoadInstruction, ClassDesc> insMap;\n+    private final ClassDesc thisClass;\n+    private final List<ClassDesc> stack, locals;\n+    private final Map<Label, StackMapFrameInfo> stackMap;\n+\n+    public LocalsTypeMapper(ClassDesc thisClass,\n+                         MethodTypeDesc methodType,\n+                         boolean isStatic,\n+                         Optional<StackMapTableAttribute> stackMapTableAttribute,\n+                         List<CodeElement> codeElements) {\n+        this.insMap = new IdentityHashMap<>();\n+        this.thisClass = thisClass;\n+        this.stack = new ArrayList<>();\n+        this.locals = new ArrayList<>();\n+        if (!isStatic) locals.add(thisClass);\n+        for (var pt : methodType.parameterList()) {\n+            locals.add(pt);\n+            if (pt.equals(CD_long) || pt.equals(CD_double)) locals.add(null);\n+        }\n+        this.stackMap = stackMapTableAttribute.map(a -> a.entries().stream().collect(Collectors.toMap(\n+                StackMapFrameInfo::target,\n+                Function.identity()))).orElse(Map.of());\n+        codeElements.forEach(this::accept);\n+    }\n+\n+    public ClassDesc getTypeOf(LoadInstruction li) {\n+        return insMap.get(li);\n+    }\n+\n+    private ClassDesc vtiToStackType(StackMapFrameInfo.VerificationTypeInfo vti) {\n+        return switch (vti) {\n+            case ITEM_INTEGER -> CD_int;\n+            case ITEM_FLOAT -> CD_float;\n+            case ITEM_DOUBLE -> CD_double;\n+            case ITEM_LONG -> CD_long;\n+            case ITEM_UNINITIALIZED_THIS -> thisClass;\n+            case ObjectVerificationTypeInfo ovti -> ovti.classSymbol();\n+            default -> null;\n+        };\n+    }\n+\n+    private void push(ClassDesc type) {\n+        if (!ConstantDescs.CD_void.equals(type)) stack.addLast(type);\n+    }\n+\n+    private void pushAt(int pos, ClassDesc... types) {\n+        for (var t : types)\n+            if (!ConstantDescs.CD_void.equals(t))\n+                stack.add(stack.size() + pos, t);\n+    }\n+\n+    private boolean doubleAt(int pos) {\n+        var t  = stack.get(stack.size() + pos);\n+        return t.equals(CD_long) || t.equals(CD_double);\n+    }\n+\n+    private ClassDesc pop() {\n+        return stack.removeLast();\n+    }\n+\n+    private ClassDesc get(int pos) {\n+        return stack.get(stack.size() + pos);\n+    }\n+\n+    private ClassDesc top() {\n+        return stack.getLast();\n+    }\n+\n+    private ClassDesc[] top2() {\n+        return new ClassDesc[] {stack.get(stack.size() - 2), stack.getLast()};\n+    }\n+\n+    private LocalsTypeMapper pop(int i) {\n+        while (i-- > 0) pop();\n+        return this;\n+    }\n+\n+    private void store(int slot, ClassDesc type) {\n+        for (int i = locals.size(); i <= slot; i++) locals.add(null);\n+        locals.set(slot, type);\n+    }\n+\n+    private ClassDesc load(int slot) {\n+        return locals.get(slot);\n+    }\n+\n+    private void accept(CodeElement el) {\n+        switch (el) {\n+            case ArrayLoadInstruction _ ->\n+                pop(1).push(pop().componentType());\n+            case ArrayStoreInstruction _ ->\n+                pop(3);\n+            case BranchInstruction i when !i.opcode().isUnconditionalBranch() ->\n+                pop(1);\n+            case ConstantInstruction i ->\n+                push(ClassDesc.ofDescriptor(i.typeKind() == TypeKind.ReferenceType ?\n+                        i.constantValue().getClass().descriptorString() : i.typeKind().descriptor()));\n+            case ConvertInstruction i ->\n+                pop(1).push(ClassDesc.ofDescriptor(i.toType().descriptor()));\n+            case FieldInstruction i -> {\n+                switch (i.opcode()) {\n+                    case GETSTATIC ->\n+                        push(i.typeSymbol());\n+                    case GETFIELD ->\n+                        pop(1).push(i.typeSymbol());\n+                    case PUTSTATIC ->\n+                        pop(1);\n+                    case PUTFIELD ->\n+                        pop(2);\n+                }\n+            }\n+            case InvokeDynamicInstruction i ->\n+                pop(i.typeSymbol().parameterCount()).push(i.typeSymbol().returnType());\n+            case InvokeInstruction i ->\n+                pop(i.typeSymbol().parameterCount() + (i.opcode() == Opcode.INVOKESTATIC ? 0 : 1))\n+                        .push(i.typeSymbol().returnType());\n+            case LoadInstruction i -> {\n+                push(load(i.slot()));\n+                insMap.put(i, locals.get(i.slot()));\n+            }\n+            case StoreInstruction i ->\n+                store(i.slot(), pop());\n+            case MonitorInstruction _ ->\n+                pop(1);\n+            case NewMultiArrayInstruction i ->\n+                pop(i.dimensions()).push(i.arrayType().asSymbol());\n+            case NewObjectInstruction i ->\n+                push(i.className().asSymbol());\n+            case NewPrimitiveArrayInstruction i ->\n+                pop(1).push(ClassDesc.ofDescriptor(i.typeKind().descriptor()).arrayType());\n+            case NewReferenceArrayInstruction i ->\n+                pop(1).push(i.componentType().asSymbol().arrayType());\n+            case OperatorInstruction i ->\n+                pop(switch (i.opcode()) {\n+                    case ARRAYLENGTH, INEG, LNEG, FNEG, DNEG -> 1;\n+                    default -> 2;\n+                }).push(ClassDesc.ofDescriptor(i.typeKind().descriptor()));\n+            case StackInstruction i -> {\n+                switch (i.opcode()) {\n+                    case POP -> pop(1);\n+                    case POP2 -> pop(doubleAt(-1) ? 1 : 2);\n+                    case DUP -> push(top());\n+                    case DUP2 -> {\n+                        if (doubleAt(-1)) {\n+                            push(top());\n+                        } else {\n+                            pushAt(-2, top2());\n+                        }\n+                    }\n+                    case DUP_X1 -> pushAt(-2, top());\n+                    case DUP_X2 -> pushAt(doubleAt(-2) ? -2 : -3, top());\n+                    case DUP2_X1 -> {\n+                        if (doubleAt(-1)) {\n+                            pushAt(-2, top());\n+                        } else {\n+                            pushAt(-3, top2());\n+                        }\n+                    }\n+                    case DUP2_X2 -> {\n+                        if (doubleAt(-1)) {\n+                            pushAt(doubleAt(-2) ? -2 : -3, top());\n+                        } else {\n+                            pushAt(doubleAt(-3) ? -3 : -4, top2());\n+                        }\n+                    }\n+                    case SWAP -> pushAt(-1, pop());\n+                }\n+            }\n+            case TypeCheckInstruction i ->\n+                pop(1).push(i.opcode() == Opcode.CHECKCAST ? i.type().asSymbol() : ConstantDescs.CD_int);\n+            case LabelTarget lt -> {\n+                var smfi = stackMap.get(lt.label());\n+                if (smfi != null) {\n+                    stack.clear();\n+                    for (var vti : smfi.stack()) {\n+                        push(vtiToStackType(vti));\n+                    }\n+                    locals.clear();\n+                    int slot = 0;\n+                    for (var vti : smfi.locals()) {\n+                        store(slot, vtiToStackType(vti));\n+                        slot += (vti == ITEM_DOUBLE || vti == ITEM_LONG) ? 2 : 1;\n+                    }\n+                }\n+            }\n+            default -> {}\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsTypeMapper.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.ExternalizableOp;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class SlotOp extends ExternalizableOp {\n+    public static final String ATTRIBUTE_SLOT = \"slot\";\n+\n+    final int slot;\n+\n+    protected SlotOp(SlotOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.slot = that.slot;\n+    }\n+\n+    protected SlotOp(String name, List<? extends Value> operands, int slot) {\n+        super(name, operands);\n+        this.slot = slot;\n+    }\n+\n+    protected SlotOp(ExternalizedOp def) {\n+        super(def);\n+\n+        this.slot = def.extractAttributeValue(ATTRIBUTE_SLOT, true,\n+                v -> switch (v) {\n+                    case String s -> Integer.parseInt(s);\n+                    case Integer i -> i;\n+                    default -> throw new UnsupportedOperationException(\"Unsupported slot value:\" + v);\n+                });\n+    }\n+\n+    public int slot() {\n+        return slot;\n+    }\n+\n+    @Override\n+    public Map<String, Object> attributes() {\n+        HashMap<String, Object> m = new HashMap<>(super.attributes());\n+        m.put(\"\", slot);\n+        return Collections.unmodifiableMap(m);\n+    }\n+\n+    @OpFactory.OpDeclaration(SlotLoadOp.NAME)\n+    public static final class SlotLoadOp extends SlotOp {\n+        public static final String NAME = \"slot.load\";\n+\n+        final TypeElement resultType;\n+\n+        public SlotLoadOp(ExternalizedOp opdef) {\n+            super(opdef);\n+\n+            if (opdef.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand\");\n+            }\n+\n+            this.resultType = opdef.resultType();\n+        }\n+\n+        SlotLoadOp(SlotLoadOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public SlotLoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SlotLoadOp(this, cc);\n+        }\n+\n+        SlotLoadOp(int slot, TypeElement resultType) {\n+            super(NAME, List.of(), slot);\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(SlotStoreOp.NAME)\n+    public static final class SlotStoreOp extends SlotOp {\n+        public static final String NAME = \"slot.store\";\n+\n+        public SlotStoreOp(ExternalizedOp opdef) {\n+            super(opdef);\n+\n+            if (opdef.operands().size() != 2) {\n+                throw new IllegalArgumentException(\"Operation must have two operands\");\n+            }\n+        }\n+\n+        SlotStoreOp(SlotStoreOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SlotStoreOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SlotStoreOp(this, cc);\n+        }\n+\n+        SlotStoreOp(int slot, Value v) {\n+            super(NAME, List.of(v), slot);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    public static SlotLoadOp load(int slot) {\n+        return load(slot, JavaType.J_L_OBJECT);\n+    }\n+\n+    public static SlotLoadOp load(int slot, TypeElement resultType) {\n+        return new SlotLoadOp(slot, resultType);\n+    }\n+\n+    public static SlotStoreOp store(int slot, Value v) {\n+        return new SlotStoreOp(slot, v);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotOp.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.reflect.code.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Functionality to transform a code model into pure SSA form, replacing operations that declare variables and\n+ * access them with the use of values they depend on or additional block parameters.\n+ *\/\n+public final class SlotSSA {\n+    private SlotSSA() {\n+    }\n+\n+    \/**\n+     * Applies an SSA transformation to an invokable operation, replacing operations that declare variables and\n+     * access them with the use of values they depend on or additional block parameters.\n+     * <p>\n+     * The operation should first be in lowered form before applying this transformation.\n+     * <p>\n+     * Note: this implementation does not currently work correctly when a variable is stored to within an exception\n+     * region and read from outside as a result of catching an exception. In such cases a complete transformation may be\n+     * not possible and such variables will need to be retained.\n+     *\n+     * @param iop the invokable operation\n+     * @return the transformed operation\n+     * @param <T> the invokable type\n+     *\/\n+    public static <T extends Op & Op.Invokable> T transform(T iop) {\n+        Map<Block, Set<Integer>> joinPoints = new HashMap<>();\n+        Map<SlotOp.SlotLoadOp, Object> loadValues = new HashMap<>();\n+        Map<Block.Reference, List<SlotValue>> joinSuccessorValues = new HashMap<>();\n+\n+        Map<Body, Boolean> visited = new HashMap<>();\n+        Map<Block, Map<Integer, Block.Parameter>> joinBlockArguments = new HashMap<>();\n+        @SuppressWarnings(\"unchecked\")\n+        T liop = (T) iop.transform(CopyContext.create(), (block, op) -> {\n+            \/\/ Compute join points and value mappings for body\n+            visited.computeIfAbsent(op.ancestorBody(), b -> {\n+                findJoinPoints(b, joinPoints);\n+                variableToValue(b, joinPoints, loadValues, joinSuccessorValues);\n+                return true;\n+            });\n+\n+            if (op instanceof SlotOp) {\n+                \/\/ Drop slot operations\n+                if (op instanceof SlotOp.SlotLoadOp vl) {\n+                    \/\/ Replace result of load\n+                    Object loadValue = loadValues.get(vl);\n+                    CopyContext cc = block.context();\n+                    Value v = loadValue instanceof SlotBlockArgument vba\n+                            ? joinBlockArguments.get(vba.b()).get(vba.slot())\n+                            : cc.getValue((Value) loadValue);\n+                    cc.mapValue(op.result(), v);\n+                }\n+            } else if (op instanceof Op.Terminating) {\n+                for (Block.Reference s : op.successors()) {\n+                    List<SlotValue> joinValues = joinSuccessorValues.get(s);\n+                    \/\/ Successor has join values\n+                    if (joinValues != null) {\n+                        CopyContext cc = block.context();\n+\n+                        \/\/ Lazily append target block arguments\n+                        joinBlockArguments.computeIfAbsent(s.targetBlock(), b -> {\n+                            Block.Builder bb = cc.getBlock(b);\n+                            return joinPoints.get(b).stream().collect(Collectors.toMap(\n+                                    slot -> slot,\n+                                    \/\/ @@@\n+                                    slot -> bb.parameter(joinValues.stream().filter(sv -> sv.slot == slot).findAny().map(sv ->\n+                                            (sv.value instanceof SlotBlockArgument vba\n+                                                ? joinBlockArguments.get(vba.b()).get(vba.slot())\n+                                                : cc.getValue((Value) sv.value)).type()).orElseThrow())));\n+                        });\n+\n+                        \/\/ Append successor arguments\n+                        List<Value> values = new ArrayList<>();\n+                        for (SlotValue sv : joinValues) {\n+                            Value v = sv.value instanceof SlotBlockArgument vba\n+                                    ? joinBlockArguments.get(vba.b()).get(vba.slot())\n+                                    : cc.getValue((Value) sv.value);\n+                            values.add(v);\n+                        }\n+\n+                        \/\/ Map successor with append arguments\n+                        List<Value> toArgs = cc.getValues(s.arguments());\n+                        toArgs.addAll(values);\n+                        Block.Reference toS = cc.getBlock(s.targetBlock()).successor(toArgs);\n+                        cc.mapSuccessor(s, toS);\n+                    }\n+                }\n+\n+                block.apply(op);\n+            } else {\n+                block.apply(op);\n+            }\n+\n+            return block;\n+        });\n+        return liop;\n+    }\n+\n+    record SlotBlockArgument(Block b, int slot) {\n+    }\n+\n+    record SlotValue(int slot, Object value) {\n+    }\n+\n+    \/\/ @@@ Check for var uses in exception regions\n+    \/\/     A variable cannot be converted to SAA form if the variable is stored\n+    \/\/     to in an exception region and accessed from an associated catch region\n+\n+    static void variableToValue(Body body,\n+                                Map<Block, Set<Integer>> joinPoints,\n+                                Map<SlotOp.SlotLoadOp, Object> loadValues,\n+                                Map<Block.Reference, List<SlotValue>> joinSuccessorValues) {\n+        Map<Integer, Deque<Object>> variableStack = new HashMap<>();\n+        Node top = buildDomTree(body.entryBlock(), body.immediateDominators());\n+        variableToValue(top, variableStack, joinPoints, loadValues, joinSuccessorValues);\n+    }\n+\n+    \/**\n+     * Replaces usages of a variable with the corresponding value, from a given block node in the dominator tree.\n+     * <p>\n+     * The result of a {@code VarLoadOp} for variable, {@code V} say the result of a {@code VarOp} operation,\n+     * is replaced with the value passed as an operand to the immediately dominating {@code VarStoreOp} that operates\n+     * on {@code V}, or a block argument representing the equivalent of a phi-value of {@code V}.\n+     * After which, any related {@code VarOp}, {@code VarLoadOp}, or {@code VarStoreOp} operations are removed.\n+     *\n+     * @param n             the node in the dominator tree\n+     * @param variableStack the variable stack\n+     * @param joinPoints    the join points\n+     * @implNote See \"Efficiently Computing Static Single Assignment Form and the Control Dependence Graph\" by Ron Cytron et. al.\n+     * Section 5.2 and Figure 12.\n+     *\/\n+    static void variableToValue(Node n,\n+                                Map<Integer, Deque<Object>> variableStack,\n+                                Map<Block, Set<Integer>> joinPoints,\n+                                Map<SlotOp.SlotLoadOp, Object> loadValues,\n+                                Map<Block.Reference, List<SlotValue>> joinSuccessorValues) {\n+\n+        int size = n.b().ops().size();\n+\n+        \/\/ Check if slot is associated with block argument (phi)\n+        \/\/ Push argument onto slot's stack\n+        {\n+            Set<Integer> slots = joinPoints.get(n.b());\n+            if (slots != null) {\n+                slots.forEach(slot -> {\n+                    variableStack.get(slot).push(new SlotBlockArgument(n.b(), slot));\n+                });\n+            }\n+        }\n+\n+        {\n+            for (int i = 0; i < size - 1; i++) {\n+                Op op = n.b().ops().get(i);\n+\n+                if (op instanceof SlotOp.SlotStoreOp storeOp) {\n+                    \/\/ Value assigned to slot\n+                    Value current = op.operands().get(0);\n+                    variableStack.computeIfAbsent(storeOp.slot(), _ -> new ArrayDeque<>())\n+                            .push(current);\n+                } else if (op instanceof SlotOp.SlotLoadOp loadOp) {\n+                    Object to = variableStack.get(loadOp.slot()).peek();\n+                    loadValues.put(loadOp, to);\n+                }\n+            }\n+\n+            \/\/ Add successor args for joint points\n+            for (Block.Reference succ : n.b().successors()) {\n+                Set<Integer> slots = joinPoints.get(succ.targetBlock());\n+                if (slots != null) {\n+                    List<SlotValue> joinValues = slots.stream()\n+                            .map(vop -> new SlotValue(vop, variableStack.get(vop).peek())).toList();\n+                    joinSuccessorValues.put(succ, joinValues);\n+                }\n+            }\n+        }\n+\n+        \/\/ Traverse children of dom tree\n+        for (Node y : n.children()) {\n+            variableToValue(y, variableStack, joinPoints, loadValues, joinSuccessorValues);\n+        }\n+\n+        \/\/ Pop off values for slots\n+        {\n+            Set<Integer> slots = joinPoints.get(n.b());\n+            if (slots != null) {\n+                slots.forEach(slot -> {\n+                    variableStack.get(slot).pop();\n+                });\n+            }\n+\n+            for (int i = 0; i < size - 1; i++) {\n+                Op op = n.b().ops().get(i);\n+\n+                if (op instanceof SlotOp.SlotStoreOp storeOp) {\n+                    variableStack.get(storeOp.slot()).pop();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Finds the join points of a body.\n+     * <p>\n+     * A join point is a block that is in the dominance frontier of one or more predecessors, that make one or more\n+     * stores to variables (using the {@code VarStoreOp} operation on the result of a {@code VarOp} operation).\n+     * The join point contains the set variables ({@code VarOp} operations) that are stored to.\n+     * <p>\n+     * A variable of a joint point indicates that a block argument may need to be added to the join point's block\n+     * when converting variables to SSA form. Different values of a variable may occur at different control flow\n+     * paths at the join point. The block argument represents the convergence of multiple values for the same\n+     * variable, where a predecessor assigns to the block argument.\n+     * (Block arguments are equivalent to phi-values, or phi-nodes, used in other representations.)\n+     *\n+     * @param body the body.\n+     * @param joinPoints the returned join points.\n+     * @implNote See \"Efficiently Computing Static Single Assignment Form and the Control Dependence Graph\" by Ron Cytron et. al.\n+     * Section 5.1 and Figure 11.\n+     *\/\n+    public static void findJoinPoints(Body body, Map<Block, Set<Integer>> joinPoints) {\n+        Map<Block, Set<Block>> df = body.dominanceFrontier();\n+        Map<Integer, PaC> a = findSlots(body);\n+\n+        int iterCount = 0;\n+        int[] hasAlready = new int[body.blocks().size()];\n+        int[] work = new int[body.blocks().size()];\n+\n+        Deque<Block> w = new ArrayDeque<>();\n+\n+        for (int slot : a.keySet()) {\n+            PaC pac = a.get(slot);\n+\n+            iterCount++;\n+            for (Block cb : pac.consumers) {\n+                work[cb.index()] = iterCount;\n+                w.push(cb);\n+            }\n+            while (!w.isEmpty()) {\n+                Block x = w.pop();\n+                \/\/ propagate consumers to predecessor blocks\n+                for (Block y : x.predecessors()) {\n+                    if (work[y.index()] < iterCount){\n+                        work[y.index()] = iterCount;\n+                        if (!pac.producers.contains(y) && !pac.consumers.contains(y)) {\n+                            pac.consumers.add(y);\n+                            w.push(y);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            iterCount++;\n+            for (Block x : pac.producers) {\n+                work[x.index()] = iterCount;\n+                w.push(x);\n+            }\n+            while (!w.isEmpty()) {\n+                Block x = w.pop();\n+                \/\/ calculate join points\n+                for (Block y : df.getOrDefault(x, Set.of())) {\n+                    if (hasAlready[y.index()] < iterCount) {\n+                        if (pac.consumers.contains(y)) {\n+                            joinPoints.computeIfAbsent(y, _ -> new LinkedHashSet<>()).add(slot);\n+                        }\n+                        hasAlready[y.index()] = iterCount;\n+\n+                        if (work[y.index()] < iterCount) {\n+                            work[y.index()] = iterCount;\n+                            w.push(y);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    record PaC(Set<Block> producers, Set<Block> consumers) {\n+        public PaC() {\n+            this(new LinkedHashSet<>(), new LinkedHashSet<>());\n+        }\n+    }\n+\n+    \/\/ Returns map of slots to blocks that contain stores and to blocks containing load preceeding store\n+    \/\/ Throws ISE if a descendant store operation is encountered\n+    \/\/ @@@ Compute map for whole tree, then traverse keys with filter\n+    static Map<Integer, PaC> findSlots(Body r) {\n+        return r.traverse(new LinkedHashMap<>(), CodeElement.opVisitor((slots, op) -> {\n+            if (op instanceof SlotOp.SlotStoreOp storeOp) {\n+                slots.computeIfAbsent(storeOp.slot(), _ -> new PaC()).producers.add(storeOp.parentBlock());\n+            } else if (op instanceof SlotOp.SlotLoadOp loadOp) {\n+                var sal = slots.computeIfAbsent(loadOp.slot(), _ -> new PaC());\n+                if (!sal.producers.contains(loadOp.parentBlock())) sal.consumers.add(loadOp.parentBlock());\n+            }\n+            return slots;\n+        }));\n+    }\n+\n+    record Node(Block b, Set<Node> children) {\n+    }\n+\n+    static Node buildDomTree(Block entryBlock, Map<Block, Block> idoms) {\n+        Map<Block, Node> tree = new HashMap<>();\n+        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n+            Block id = e.getValue();\n+            Block b = e.getKey();\n+\n+            Node parent = tree.computeIfAbsent(id, _k -> new Node(_k, new HashSet<>()));\n+            if (b == entryBlock) {\n+                continue;\n+            }\n+\n+            Node child = tree.computeIfAbsent(b, _k -> new Node(_k, new HashSet<>()));\n+            parent.children.add(child);\n+        }\n+        return tree.get(entryBlock);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotSSA.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.bytecode.SlotOp;\n+import java.lang.reflect.code.bytecode.SlotSSA;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.MethodRef;\n+\n+\/*\n+ * @test\n+ * @run testng TestSlots\n+ *\/\n+public class TestSlotOps {\n+\n+    static void m(int i) {\n+\n+    }\n+\n+    @Test\n+    public void test() {\n+        CoreOp.FuncOp f = build();\n+        System.out.println(f.toText());\n+\n+        CoreOp.FuncOp fssa = SlotSSA.transform(f);\n+        System.out.println(fssa.toText());\n+    }\n+\n+    static CoreOp.FuncOp build() {\n+        return CoreOp.func(\"f\", FunctionType.functionType(JavaType.J_L_STRING)).body(b -> {\n+            Block.Builder trueBlock = b.block();\n+            Block.Builder falseBlock = b.block();\n+            Block.Builder exitBlock = b.block();\n+\n+            \/\/ Entry block\n+            {\n+                Value nullConstant = b.op(CoreOp.constant(JavaType.J_L_OBJECT, null));\n+                b.op(SlotOp.store(0, nullConstant));\n+\n+                b.op(CoreOp.conditionalBranch(b.op(CoreOp.constant(JavaType.BOOLEAN, true)),\n+                        trueBlock.successor(), falseBlock.successor()));\n+            }\n+\n+            \/\/ True block\n+            {\n+                Value oneConstant = trueBlock.op(CoreOp.constant(JavaType.INT, 1));\n+                trueBlock.op(SlotOp.store(0, oneConstant));\n+\n+                Value loadValue = trueBlock.op(SlotOp.load(0, JavaType.INT));\n+                trueBlock.op(CoreOp.invoke(MethodRef.method(TestSlots.class, \"m\", void.class, int.class), loadValue));\n+\n+                Value stringConstant = trueBlock.op(CoreOp.constant(JavaType.J_L_STRING, \"TRUE\"));\n+                trueBlock.op(SlotOp.store(0, stringConstant));\n+\n+                trueBlock.op(CoreOp.branch(exitBlock.successor()));\n+            }\n+\n+            \/\/ False block\n+            {\n+                Value stringConstant = falseBlock.op(CoreOp.constant(JavaType.J_L_STRING, \"FALSE\"));\n+                falseBlock.op(SlotOp.store(0, stringConstant));\n+\n+                falseBlock.op(CoreOp.branch(exitBlock.successor()));\n+            }\n+\n+            \/\/ Exit block\n+            {\n+                Value loadValue = exitBlock.op(SlotOp.load(0, JavaType.J_L_STRING));\n+                exitBlock.op(CoreOp._return(loadValue));\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlotOps.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.reflect.code.OpTransformer;\n@@ -60,2 +59,1 @@\n-    private static final ClassFile CF = ClassFile.of(ClassFile.DebugElementsOption.DROP_DEBUG,\n-                                                     ClassFile.LineNumbersOption.DROP_LINE_NUMBERS);\n+    private static final ClassFile CF = ClassFile.of();\n@@ -89,1 +87,1 @@\n-        Assert.assertTrue(notMatching < 31 && passed > 5400, String.format(\"\"\"\n+        Assert.assertTrue(passed > 6400, String.format(\"\"\"\n@@ -174,1 +172,8 @@\n-        return SSA.transform(func.transform(OpTransformer.LOWERING_TRANSFORMER));\n+        return SSA.transform(func.transform((block, op) -> {\n+                    if (op instanceof Op.Lowerable lop) {\n+                        return lop.lower(block);\n+                    } else {\n+                        block.op(op);\n+                        return block;\n+                    }\n+                }));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"}]}