{"files":[{"patch":"@@ -50,1 +50,1 @@\n-public final class LocalsTypeMapper {\n+final class LocalsTypeMapper {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsTypeMapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-        Map<Integer, PaC> a = findSlots(body);\n+        Map<Integer, SlotAccesses> a = findSlots(body);\n@@ -258,1 +258,1 @@\n-            PaC pac = a.get(slot);\n+            SlotAccesses sa = a.get(slot);\n@@ -261,20 +261,1 @@\n-            for (Block cb : pac.consumers) {\n-                work[cb.index()] = iterCount;\n-                w.push(cb);\n-            }\n-            while (!w.isEmpty()) {\n-                Block x = w.pop();\n-                \/\/ propagate consumers to predecessor blocks\n-                for (Block y : x.predecessors()) {\n-                    if (work[y.index()] < iterCount){\n-                        work[y.index()] = iterCount;\n-                        if (!pac.producers.contains(y) && !pac.consumers.contains(y)) {\n-                            pac.consumers.add(y);\n-                            w.push(y);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            iterCount++;\n-            for (Block x : pac.producers) {\n+            for (Block x : sa.stores) {\n@@ -286,1 +267,1 @@\n-                \/\/ calculate join points\n+\n@@ -289,1 +270,1 @@\n-                        if (pac.consumers.contains(y)) {\n+                        if (sa.loadsBeforeStores.contains(y)) {\n@@ -304,2 +285,2 @@\n-    record PaC(Set<Block> producers, Set<Block> consumers) {\n-        public PaC() {\n+    record SlotAccesses(Set<Block> stores, Set<Block> loadsBeforeStores) {\n+        public SlotAccesses() {\n@@ -313,2 +294,2 @@\n-    static Map<Integer, PaC> findSlots(Body r) {\n-        return r.traverse(new LinkedHashMap<>(), CodeElement.opVisitor((slots, op) -> {\n+    static Map<Integer, SlotAccesses> findSlots(Body r) {\n+        LinkedHashMap<Integer, SlotAccesses> slotMap = r.traverse(new LinkedHashMap<>(), CodeElement.opVisitor((slots, op) -> {\n@@ -316,1 +297,1 @@\n-                slots.computeIfAbsent(storeOp.slot(), _ -> new PaC()).producers.add(storeOp.parentBlock());\n+                slots.computeIfAbsent(storeOp.slot(), _ -> new SlotAccesses()).stores.add(storeOp.parentBlock());\n@@ -318,2 +299,2 @@\n-                var sal = slots.computeIfAbsent(loadOp.slot(), _ -> new PaC());\n-                if (!sal.producers.contains(loadOp.parentBlock())) sal.consumers.add(loadOp.parentBlock());\n+                var sa = slots.computeIfAbsent(loadOp.slot(), _ -> new SlotAccesses());\n+                if (!sa.stores.contains(loadOp.parentBlock())) sa.loadsBeforeStores.add(loadOp.parentBlock());\n@@ -323,0 +304,25 @@\n+\n+        int iterCount = 0;\n+        int[] work = new int[r.blocks().size()];\n+        Deque<Block> w = new ArrayDeque<>();\n+        for (SlotAccesses sa : slotMap.values()) {\n+            iterCount++;\n+            for (Block cb : sa.loadsBeforeStores) {\n+                work[cb.index()] = iterCount;\n+                w.push(cb);\n+            }\n+            while (!w.isEmpty()) {\n+                Block x = w.pop();\n+                \/\/ propagate loadsBeforeStores to predecessor blocks\n+                for (Block y : x.predecessors()) {\n+                    if (work[y.index()] < iterCount){\n+                        work[y.index()] = iterCount;\n+                        if (!sa.stores.contains(y) && !sa.loadsBeforeStores.contains(y)) {\n+                            sa.loadsBeforeStores.add(y);\n+                            w.push(y);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return slotMap;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotSSA.java","additions":37,"deletions":31,"binary":false,"changes":68,"status":"modified"}]}