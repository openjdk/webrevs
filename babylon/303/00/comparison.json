{"files":[{"patch":"@@ -27,2 +27,1 @@\n-import hat.backend.c99codebuilders.C99HatBuildContext;\n-import hat.backend.c99codebuilders.C99HatKernelBuilder;\n+import hat.backend.codebuilders.C99HATKernelBuilder;\n@@ -34,1 +33,1 @@\n-public class CudaHatKernelBuilder extends C99HatKernelBuilder<CudaHatKernelBuilder> {\n+public class CudaHatKernelBuilder extends C99HATKernelBuilder<CudaHatKernelBuilder> {\n@@ -81,1 +80,1 @@\n-    public CudaHatKernelBuilder atomicInc(C99HatBuildContext buildContext, Op.Result instanceResult, String name){\n+    public CudaHatKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHatKernelBuilder.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-import hat.backend.c99codebuilders.C99HatBuildContext;\n-import hat.backend.c99codebuilders.C99HatKernelBuilder;\n+import hat.backend.codebuilders.C99HATKernelBuilder;\n@@ -34,1 +33,1 @@\n-public class OpenCLHatKernelBuilder extends C99HatKernelBuilder<OpenCLHatKernelBuilder> {\n+public class OpenCLHatKernelBuilder extends C99HATKernelBuilder<OpenCLHatKernelBuilder> {\n@@ -77,1 +76,1 @@\n-    public OpenCLHatKernelBuilder atomicInc(C99HatBuildContext buildContext, Op.Result instanceResult, String name){\n+    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHatKernelBuilder.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    <artifactId>hat-backend-ffi-hip<\/artifactId>\n+    <artifactId>hat-backend-ffi-shared<\/artifactId>\n@@ -66,1 +66,1 @@\n-                                <copy file=\"target\/hat-backend-ffi-hip-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                                <copy file=\"target\/hat-backend-java-shared-1.0.jar\" toDir=\"${hat.build}\"\/>\n","filename":"hat\/backends\/ffi\/shared\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/backends\/ffi\/hip\/pom.xml","status":"copied"},{"patch":"@@ -27,2 +27,1 @@\n-import hat.backend.c99codebuilders.C99HatBuildContext;\n-import hat.backend.c99codebuilders.C99HatKernelBuilder;\n+import hat.backend.codebuilders.C99HATKernelBuilder;\n@@ -33,1 +32,1 @@\n-public class OpenCLHatKernelBuilder extends C99HatKernelBuilder<OpenCLHatKernelBuilder> {\n+public class OpenCLHatKernelBuilder extends C99HATKernelBuilder<OpenCLHatKernelBuilder> {\n@@ -76,1 +75,1 @@\n-    public OpenCLHatKernelBuilder atomicInc(C99HatBuildContext buildContext, Op.Result instanceResult, String name){\n+    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.backend.c99codebuilders.HatComputeBuilder;\n+import hat.backend.codebuilders.C99HATComputeBuilder;\n@@ -79,1 +79,1 @@\n-        HatComputeBuilder codeBuilder = new HatComputeBuilder();\n+        C99HATComputeBuilder codeBuilder = new C99HATComputeBuilder();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Main.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,231 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.c99codebuilders;\n-\n-\n-import hat.text.CodeBuilder;\n-\n-import java.util.Arrays;\n-import java.util.function.Consumer;\n-\n-public abstract class C99CodeBuilder<T extends C99CodeBuilder<T>> extends CodeBuilder<T> {\n-    public T suffix_t(String name) {\n-        return identifier(name).identifier(\"_t\");\n-    }\n-\n-    public T suffix_u(String name) {\n-        return identifier(name).identifier(\"_u\");\n-    }\n-\n-    public T suffix_s(String name) {\n-        return identifier(name).identifier(\"_s\");\n-    }\n-\n-\n-    public T intDeclaration(String name) {\n-        return intType().space().identifier(name);\n-    }\n-\n-    public T floatDeclaration(String name) {\n-        return floatType().space().identifier(name);\n-    }\n-\n-    public T booleanDeclaration(String name) {\n-        return booleanType().space().identifier(name);\n-    }\n-\n-    public T byteDeclaration(String name) {\n-        return charType().space().identifier(name);\n-    }\n-\n-    public T shortDeclaration(String name) {\n-        return shortType().space().identifier(name);\n-    }\n-\n-    public T structOrUnion(boolean isStruct) {\n-        return (isStruct ? structKeyword() : union());\n-    }\n-\n-\n-    public T typedefKeyword() {\n-        return keyword(\"typedef\");\n-    }\n-\n-\n-    public T structKeyword() {\n-        return keyword(\"struct\");\n-    }\n-\n-    public T union() {\n-        return keyword(\"union\");\n-    }\n-\n-\n-    public T externC() {\n-        return externKeyword().space().dquote(\"C\");\n-    }\n-\n-    T hashDefineKeyword() {\n-        return hash().keyword(\"define\");\n-    }\n-\n-    T hashIfdefKeyword() {\n-        return hash().keyword(\"ifdef\");\n-    }\n-\n-    T hashIfndefKeyword() {\n-        return hash().keyword(\"ifndef\");\n-    }\n-\n-    protected T hashEndif() {\n-        return hash().keyword(\"endif\").nl();\n-    }\n-\n-    T hashIfdef(String value) {\n-        return hashIfdefKeyword().space().append(value).nl();\n-    }\n-\n-    protected T hashIfndef(String value) {\n-        return hashIfndefKeyword().space().append(value).nl();\n-    }\n-\n-    T hashIfdef(String value, Consumer<T> consumer) {\n-        return hashIfdef(value).accept(consumer).hashEndif();\n-    }\n-\n-    protected T hashIfndef(String value, Consumer<T> consumer) {\n-        return hashIfndef(value).accept(consumer).hashEndif();\n-    }\n-  \/*  public T defonce(String name, Runnable r) {\n-        return ifndef(name+\"_ONCE_DEF\",()->{\n-            define(name+\"_ONCE_DEF\").nl();\n-            r.run();\n-        });\n-    }*\/\n-\n-    T pragmaKeyword() {\n-        return keyword(\"pragma\");\n-    }\n-\n-    public T hashDefine(String name, String... values) {\n-        hashDefineKeyword().space().identifier(name);\n-        for (String value : values) {\n-            space().append(value);\n-        }\n-        return nl();\n-    }\n-\n-    public T pragma(String name, String... values) {\n-        hash().pragmaKeyword().space().identifier(name);\n-        for (String value : values) {\n-            space().append(value);\n-        }\n-        return nl();\n-    }\n-\n-    T externKeyword() {\n-        return keyword(\"extern\");\n-    }\n-\n-    protected T camel(String value) {\n-        return identifier(Character.toString(Character.toLowerCase(value.charAt(0)))).identifier(value.substring(1));\n-    }\n-\n-    T camelJoin(String prefix, String suffix) {\n-        return camel(prefix).identifier(Character.toString(Character.toUpperCase(suffix.charAt(0)))).identifier(suffix.substring(1));\n-    }\n-\n-    public final T unsignedCharType() {\n-        return typeName(\"unsigned\").space().charType();\n-    }\n-\n-    public T charTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> charType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T unsignedCharTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedCharType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T shortTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> shortType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T unsignedShortTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedShortType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T intTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> intType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T unsignedIntTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedIntType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T floatTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> floatType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T longTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> longType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T unsignedLongTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedLongType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    public T doubleTypeDefs(String... names) {\n-        Arrays.stream(names).forEach(name -> typedef(_ -> doubleType(), _ -> identifier(name)));\n-        return self();\n-    }\n-\n-    private T typedef(Consumer<T> lhs, Consumer<T> rhs) {\n-        return semicolonTerminatedLine(_ -> typedefKeyword().space().accept(lhs).space().accept(rhs));\n-    }\n-\n-    public final T unsignedIntType() {\n-        return typeName(\"unsigned\").space().intType();\n-    }\n-\n-    public final T unsignedLongType() {\n-        return typeName(\"unsigned\").space().longType();\n-    }\n-\n-    public final T unsignedShortType() {\n-        return typeName(\"unsigned\").space().shortType();\n-    }\n-\n-\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99CodeBuilder.java","additions":0,"deletions":231,"binary":false,"changes":231,"status":"deleted"},{"patch":"@@ -1,251 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package hat.backend.c99codebuilders;\n-\n-import hat.optools.ForOpWrapper;\n-import hat.optools.FuncOpWrapper;\n-import hat.optools.IfOpWrapper;\n-import hat.optools.OpWrapper;\n-import hat.optools.WhileOpWrapper;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.op.CoreOp;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-public class C99HatBuildContext {\n-\n-\n-    static class Scope<OW extends OpWrapper<?>> {\n-        final Scope<?> parent;\n-        final OW opWrapper;\n-\n-        public Scope(Scope<?> parent, OW opWrapper) {\n-            this.parent = parent;\n-            this.opWrapper = opWrapper;\n-        }\n-\n-        public CoreOp.VarOp resolve(Value value) {\n-            if (value instanceof Op.Result result && result.op() instanceof CoreOp.VarOp varOp) {\n-                return varOp;\n-            }\n-            if (parent != null) {\n-                return parent.resolve(value);\n-            }\n-            throw new IllegalStateException(\"failed to resolve VarOp for value \" + value);\n-        }\n-    }\n-\n-    static class FuncScope extends Scope<FuncOpWrapper> {\n-        FuncScope(Scope<?> parent, FuncOpWrapper funcOpWrapper) {\n-            super(parent, funcOpWrapper);\n-        }\n-\n-        @Override\n-        public CoreOp.VarOp resolve(Value value) {\n-            if (value instanceof Block.Parameter blockParameter) {\n-                if (opWrapper.parameterVarOpMap.containsKey(blockParameter)) {\n-                    return opWrapper.parameterVarOpMap.get(blockParameter);\n-                } else {\n-                    throw new IllegalStateException(\"what ?\");\n-                }\n-            } else {\n-                return super.resolve(value);\n-            }\n-        }\n-    }\n-\n-    static abstract class LoopScope<T extends OpWrapper<?>> extends Scope<T> {\n-\n-        public LoopScope(Scope<?> parent, T opWrapper) {\n-            super(parent, opWrapper);\n-        }\n-    }\n-\n-\n-    static class ForScope extends LoopScope<ForOpWrapper> {\n-        Map<Block.Parameter, CoreOp.VarOp> blockParamToVarOpMap = new HashMap<>();\n-\n-        ForOpWrapper forOpWrapper() {\n-            return opWrapper;\n-        }\n-\n-        ForScope(Scope<?> parent, ForOpWrapper forOpWrapper) {\n-            super(parent, forOpWrapper);\n-            var loopParams = forOpWrapper().op().loopBody().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-            var updateParams = forOpWrapper().op().update().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-            var condParams = forOpWrapper().op().cond().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-            var lastInitOp = forOpWrapper().op().init().entryBlock().ops().getLast();\n-            var lastInitOpOperand0Result = (Op.Result) lastInitOp.operands().getFirst();\n-            var lastInitOpOperand0ResultOp = lastInitOpOperand0Result.op();\n-            CoreOp.VarOp varOps[];\n-            if (lastInitOpOperand0ResultOp instanceof CoreOp.TupleOp tupleOp) {\n-                 \/*\n-                 for (int j = 1, i=2, k=3; j < size; k+=1,i+=2,j+=3) {\n-                    float sum = k+i+j;\n-                 }\n-                 java.for\n-                 ()Tuple<Var<int>, Var<int>, Var<int>> -> {\n-                     %0 : int = constant @\"1\";\n-                     %1 : Var<int> = var %0 @\"j\";\n-                     %2 : int = constant @\"2\";\n-                     %3 : Var<int> = var %2 @\"i\";\n-                     %4 : int = constant @\"3\";\n-                     %5 : Var<int> = var %4 @\"k\";\n-                     %6 : Tuple<Var<int>, Var<int>, Var<int>> = tuple %1 %3 %5;\n-                     yield %6;\n-                 }\n-                 (%7 : Var<int>, %8 : Var<int>, %9 : Var<int>)boolean -> {\n-                     %10 : int = var.load %7;\n-                     %11 : int = var.load %12;\n-                     %13 : boolean = lt %10 %11;\n-                     yield %13;\n-                 }\n-                 (%14 : Var<int>, %15 : Var<int>, %16 : Var<int>)void -> {\n-                     %17 : int = var.load %16;\n-                     %18 : int = constant @\"1\";\n-                     %19 : int = add %17 %18;\n-                     var.store %16 %19;\n-                     %20 : int = var.load %15;\n-                     %21 : int = constant @\"2\";\n-                     %22 : int = add %20 %21;\n-                     var.store %15 %22;\n-                     %23 : int = var.load %14;\n-                     %24 : int = constant @\"3\";\n-                     %25 : int = add %23 %24;\n-                     var.store %14 %25;\n-                     yield;\n-                 }\n-                 (%26 : Var<int>, %27 : Var<int>, %28 : Var<int>)void -> {\n-                     %29 : int = var.load %28;\n-                     %30 : int = var.load %27;\n-                     %31 : int = add %29 %30;\n-                     %32 : int = var.load %26;\n-                     %33 : int = add %31 %32;\n-                     %34 : float = conv %33;\n-                     %35 : Var<float> = var %34 @\"sum\";\n-                     java.continue;\n-                 };\n-                 *\/\n-                varOps = tupleOp.operands().stream().map(operand -> (CoreOp.VarOp) (((Op.Result) operand).op())).toList().toArray(new CoreOp.VarOp[0]);\n-            } else {\n-                 \/*\n-                 for (int j = 0; j < size; j+=1) {\n-                    float sum = j;\n-                 }\n-                 java.for\n-                    ()Var<int> -> {\n-                        %0 : int = constant @\"0\";\n-                        %1 : Var<int> = var %0 @\"j\";\n-                        yield %1;\n-                    }\n-                    (%2 : Var<int>)boolean -> {\n-                        %3 : int = var.load %2;\n-                        %4 : int = var.load %5;\n-                        %6 : boolean = lt %3 %4;\n-                        yield %6;\n-                    }\n-                    (%7 : Var<int>)void -> {\n-                        %8 : int = var.load %7;\n-                        %9 : int = constant @\"1\";\n-                        %10 : int = add %8 %9;\n-                        var.store %7 %10;\n-                        yield;\n-                    }\n-                    (%11 : Var<int>)void -> {\n-                        %12 : int = var.load %11;\n-                        %13 : float = conv %12;\n-                        %14 : Var<float> = var %13 @\"sum\";\n-                        java.continue;\n-                    };\n-\n-                 *\/\n-                varOps = new CoreOp.VarOp[]{(CoreOp.VarOp) lastInitOpOperand0ResultOp};\n-            }\n-            for (int i = 0; i < varOps.length; i++) {\n-                blockParamToVarOpMap.put(condParams[i], varOps[i]);\n-                blockParamToVarOpMap.put(updateParams[i], varOps[i]);\n-                blockParamToVarOpMap.put(loopParams[i], varOps[i]);\n-            }\n-        }\n-\n-\n-        @Override\n-        public CoreOp.VarOp resolve(Value value) {\n-            if (value instanceof Block.Parameter blockParameter) {\n-                CoreOp.VarOp varOp = this.blockParamToVarOpMap.get(blockParameter);\n-                if (varOp != null) {\n-                    return varOp;\n-                }\n-            }\n-            return super.resolve(value);\n-        }\n-    }\n-\n-    static class IfScope extends Scope<IfOpWrapper> {\n-        IfScope(Scope<?> parent, IfOpWrapper opWrapper) {\n-            super(parent, opWrapper);\n-        }\n-    }\n-\n-    static class WhileScope extends LoopScope<WhileOpWrapper> {\n-        WhileScope(Scope<?> parent, WhileOpWrapper opWrapper) {\n-            super(parent, opWrapper);\n-        }\n-\n-    }\n-\n-    Scope<?> scope = null;\n-\n-    private void popScope() {\n-        scope = scope.parent;\n-    }\n-\n-    private void pushScope(OpWrapper<?> opWrapper) {\n-        scope = switch (opWrapper) {\n-            case FuncOpWrapper $ -> new FuncScope(scope, $);\n-            case ForOpWrapper $ -> new ForScope(scope, $);\n-            case IfOpWrapper $ -> new IfScope(scope, $);\n-            case WhileOpWrapper $ -> new WhileScope(scope, $);\n-            default -> new Scope<>(scope, opWrapper);\n-        };\n-    }\n-\n-    public void scope(OpWrapper<?> opWrapper, Runnable r) {\n-        pushScope(opWrapper);\n-        r.run();\n-        popScope();\n-    }\n-\n-    FuncOpWrapper funcOpWrapper;\n-\n-    C99HatBuildContext(FuncOpWrapper funcOpWrapper) {\n-        this.funcOpWrapper = funcOpWrapper;\n-    }\n-\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatBuildContext.java","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.c99codebuilders;\n-\n-\n-import hat.optools.BinaryArithmeticOrLogicOperation;\n-import hat.optools.BinaryTestOpWrapper;\n-import hat.optools.ConstantOpWrapper;\n-import hat.optools.ConvOpWrapper;\n-import hat.optools.FieldLoadOpWrapper;\n-import hat.optools.FieldStoreOpWrapper;\n-import hat.optools.ForOpWrapper;\n-import hat.optools.FuncCallOpWrapper;\n-import hat.optools.IfOpWrapper;\n-import hat.optools.InvokeOpWrapper;\n-import hat.optools.JavaBreakOpWrapper;\n-import hat.optools.JavaContinueOpWrapper;\n-import hat.optools.JavaLabeledOpWrapper;\n-import hat.optools.LambdaOpWrapper;\n-import hat.optools.LogicalOpWrapper;\n-import hat.optools.OpWrapper;\n-import hat.optools.ReturnOpWrapper;\n-import hat.optools.TernaryOpWrapper;\n-import hat.optools.TupleOpWrapper;\n-import hat.optools.UnaryArithmeticOrLogicOpWrapper;\n-import hat.optools.VarDeclarationOpWrapper;\n-import hat.optools.VarFuncDeclarationOpWrapper;\n-import hat.optools.VarLoadOpWrapper;\n-import hat.optools.VarStoreOpWrapper;\n-import hat.optools.WhileOpWrapper;\n-import hat.optools.YieldOpWrapper;\n-\n-import jdk.incubator.code.Op;\n-\n-public interface C99HatBuilderInterface<T extends C99HatBuilder<?>> {\n-\n-\n-    public T varLoad(C99HatBuildContext buildContext, VarLoadOpWrapper varAccessOpWrapper);\n-\n-    public T varStore(C99HatBuildContext buildContext, VarStoreOpWrapper varAccessOpWrapper);\n-\n-    \/\/ public T var(BuildContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper) ;\n-\n-    public T varDeclaration(C99HatBuildContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper);\n-\n-    public T varFuncDeclaration(C99HatBuildContext buildContext, VarFuncDeclarationOpWrapper varFuncDeclarationOpWrapper);\n-\n-    public T fieldLoad(C99HatBuildContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper);\n-\n-    public T fieldStore(C99HatBuildContext buildContext, FieldStoreOpWrapper fieldStoreOpWrapper);\n-\n-    T unaryOperation(C99HatBuildContext buildContext, UnaryArithmeticOrLogicOpWrapper unaryOperatorOpWrapper);\n-\n-\n-    T binaryOperation(C99HatBuildContext buildContext, BinaryArithmeticOrLogicOperation binaryOperatorOpWrapper);\n-\n-    T logical(C99HatBuildContext buildContext, LogicalOpWrapper logicalOpWrapper);\n-\n-    T binaryTest(C99HatBuildContext buildContext, BinaryTestOpWrapper binaryTestOpWrapper);\n-\n-    T conv(C99HatBuildContext buildContext, ConvOpWrapper convOpWrapper);\n-\n-\n-    T constant(C99HatBuildContext buildContext, ConstantOpWrapper constantOpWrapper);\n-\n-    T javaYield(C99HatBuildContext buildContext, YieldOpWrapper yieldOpWrapper);\n-\n-    T lambda(C99HatBuildContext buildContext, LambdaOpWrapper lambdaOpWrapper);\n-\n-    T tuple(C99HatBuildContext buildContext, TupleOpWrapper lambdaOpWrapper);\n-\n-    T funcCall(C99HatBuildContext buildContext, FuncCallOpWrapper funcCallOpWrapper);\n-\n-    T javaIf(C99HatBuildContext buildContext, IfOpWrapper ifOpWrapper);\n-\n-    T javaWhile(C99HatBuildContext buildContext, WhileOpWrapper whileOpWrapper);\n-\n-    T javaLabeled(C99HatBuildContext buildContext, JavaLabeledOpWrapper javaLabeledOpWrapperOp);\n-\n-    T javaContinue(C99HatBuildContext buildContext, JavaContinueOpWrapper javaContinueOpWrapper);\n-\n-    T javaBreak(C99HatBuildContext buildContext, JavaBreakOpWrapper javaBreakOpWrapper);\n-\n-    T javaFor(C99HatBuildContext buildContext, ForOpWrapper forOpWrapper);\n-\n-\n-    public T methodCall(C99HatBuildContext buildContext, InvokeOpWrapper invokeOpWrapper);\n-\n-    public T ternary(C99HatBuildContext buildContext, TernaryOpWrapper ternaryOpWrapper);\n-\n-    public T parencedence(C99HatBuildContext buildContext, Op parent, OpWrapper<?> child);\n-\n-    public T parencedence(C99HatBuildContext buildContext, OpWrapper<?> parent, OpWrapper<?> child);\n-\n-    public T parencedence(C99HatBuildContext buildContext, Op parent, Op child);\n-\n-    public T parencedence(C99HatBuildContext buildContext, OpWrapper<?> parent, Op child);\n-\n-    public T ret(C99HatBuildContext buildContext, ReturnOpWrapper returnOpWrapper);\n-\n-    default T recurse(C99HatBuildContext buildContext, OpWrapper<?> wrappedOp) {\n-        switch (wrappedOp) {\n-            case VarLoadOpWrapper $ -> varLoad(buildContext, $);\n-            case VarStoreOpWrapper $ -> varStore(buildContext, $);\n-            case FieldLoadOpWrapper $ -> fieldLoad(buildContext, $);\n-            case FieldStoreOpWrapper $ -> fieldStore(buildContext, $);\n-            case BinaryArithmeticOrLogicOperation $ -> binaryOperation(buildContext, $);\n-            case UnaryArithmeticOrLogicOpWrapper $ -> unaryOperation(buildContext, $);\n-            case BinaryTestOpWrapper $ -> binaryTest(buildContext, $);\n-            case ConvOpWrapper $ -> conv(buildContext, $);\n-            case ConstantOpWrapper $ -> constant(buildContext, $);\n-            case YieldOpWrapper $ -> javaYield(buildContext, $);\n-            case FuncCallOpWrapper $ -> funcCall(buildContext, $);\n-            case LogicalOpWrapper $ -> logical(buildContext, $);\n-            case InvokeOpWrapper $ -> methodCall(buildContext, $);\n-            case TernaryOpWrapper $ -> ternary(buildContext, $);\n-            case VarDeclarationOpWrapper $ -> varDeclaration(buildContext, $);\n-            case VarFuncDeclarationOpWrapper $ -> varFuncDeclaration(buildContext, $);\n-            case LambdaOpWrapper $ -> lambda(buildContext, $);\n-            case TupleOpWrapper $ -> tuple(buildContext, $);\n-            case WhileOpWrapper $ -> javaWhile(buildContext, $);\n-            case IfOpWrapper $ -> javaIf(buildContext, $);\n-            case ForOpWrapper $ -> javaFor(buildContext, $);\n-\n-            case ReturnOpWrapper $ -> ret(buildContext, $);\n-            case JavaLabeledOpWrapper $ -> javaLabeled(buildContext, $);\n-            case JavaBreakOpWrapper $ -> javaBreak(buildContext, $);\n-            case JavaContinueOpWrapper $ -> javaContinue(buildContext, $);\n-            default -> throw new IllegalStateException(\"handle nesting of op \" + wrappedOp.op());\n-        }\n-        return (T) this;\n-    }\n-\n-\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatBuilderInterface.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.c99codebuilders;\n-\n-public class HatComputeBuilder extends C99HatComputeBuilder<HatComputeBuilder> {\n-\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/HatComputeBuilder.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend.c99codebuilders;\n+package hat.backend.codebuilders;\n@@ -35,1 +35,1 @@\n-public abstract class C99HatComputeBuilder<T extends C99HatComputeBuilder<T>> extends C99HatBuilder<T> {\n+public  class C99HATComputeBuilder<T extends C99HATComputeBuilder<T>> extends HATCodeBuilderWithContext<T> {\n@@ -46,1 +46,1 @@\n-        C99HatBuildContext buildContext = new C99HatBuildContext(funcOpWrapper);\n+        CodeBuilderContext buildContext = new CodeBuilderContext(funcOpWrapper);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATComputeBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatComputeBuilder.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend.c99codebuilders;\n+package hat.backend.codebuilders;\n@@ -41,2 +41,2 @@\n-public abstract class C99HatKernelBuilder<T extends C99HatKernelBuilder<T>> extends C99HatBuilder<T> {\n-    public C99HatKernelBuilder() {\n+public abstract class C99HATKernelBuilder<T extends C99HATKernelBuilder<T>> extends HATCodeBuilderWithContext<T> {\n+    public C99HATKernelBuilder() {\n@@ -105,1 +105,1 @@\n-        C99HatBuildContext buildContext = new C99HatBuildContext(kernelReachableResolvedMethodCall.funcOpWrapper());\n+        CodeBuilderContext buildContext = new CodeBuilderContext(kernelReachableResolvedMethodCall.funcOpWrapper());\n@@ -128,1 +128,1 @@\n-        C99HatBuildContext buildContext = new C99HatBuildContext(kernelEntrypoint.funcOpWrapper());\n+        CodeBuilderContext buildContext = new CodeBuilderContext(kernelEntrypoint.funcOpWrapper());\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATKernelBuilder.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatKernelBuilder.java","status":"renamed"},{"patch":"@@ -0,0 +1,578 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend.codebuilders;\n+\n+\n+import hat.optools.BinaryArithmeticOrLogicOperation;\n+import hat.optools.BinaryTestOpWrapper;\n+import hat.optools.ConstantOpWrapper;\n+import hat.optools.ConvOpWrapper;\n+import hat.optools.FieldLoadOpWrapper;\n+import hat.optools.FieldStoreOpWrapper;\n+import hat.optools.ForOpWrapper;\n+import hat.optools.FuncCallOpWrapper;\n+import hat.optools.FuncOpWrapper;\n+import hat.optools.IfOpWrapper;\n+import hat.optools.InvokeOpWrapper;\n+import hat.optools.JavaBreakOpWrapper;\n+import hat.optools.JavaContinueOpWrapper;\n+import hat.optools.JavaLabeledOpWrapper;\n+import hat.optools.LambdaOpWrapper;\n+import hat.optools.LogicalOpWrapper;\n+import hat.optools.OpWrapper;\n+import hat.optools.ReturnOpWrapper;\n+import hat.optools.TernaryOpWrapper;\n+import hat.optools.TupleOpWrapper;\n+import hat.optools.UnaryArithmeticOrLogicOpWrapper;\n+import hat.optools.VarDeclarationOpWrapper;\n+import hat.optools.VarFuncDeclarationOpWrapper;\n+import hat.optools.VarLoadOpWrapper;\n+import hat.optools.VarStoreOpWrapper;\n+import hat.optools.WhileOpWrapper;\n+import hat.optools.YieldOpWrapper;\n+import hat.text.CodeBuilder;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+public abstract class HATCodeBuilder<T extends HATCodeBuilder<T>> extends CodeBuilder<T> {\n+    public T suffix_t(String name) {\n+        return identifier(name).identifier(\"_t\");\n+    }\n+\n+    public T suffix_u(String name) {\n+        return identifier(name).identifier(\"_u\");\n+    }\n+\n+    public T suffix_s(String name) {\n+        return identifier(name).identifier(\"_s\");\n+    }\n+\n+\n+    public T intDeclaration(String name) {\n+        return intType().space().identifier(name);\n+    }\n+\n+    public T floatDeclaration(String name) {\n+        return floatType().space().identifier(name);\n+    }\n+\n+    public T booleanDeclaration(String name) {\n+        return booleanType().space().identifier(name);\n+    }\n+\n+    public T byteDeclaration(String name) {\n+        return charType().space().identifier(name);\n+    }\n+\n+    public T shortDeclaration(String name) {\n+        return shortType().space().identifier(name);\n+    }\n+\n+    public T structOrUnion(boolean isStruct) {\n+        return (isStruct ? structKeyword() : union());\n+    }\n+\n+\n+    public T typedefKeyword() {\n+        return keyword(\"typedef\");\n+    }\n+\n+\n+    public T structKeyword() {\n+        return keyword(\"struct\");\n+    }\n+\n+    public T union() {\n+        return keyword(\"union\");\n+    }\n+\n+\n+    public T externC() {\n+        return externKeyword().space().dquote(\"C\");\n+    }\n+\n+    T hashDefineKeyword() {\n+        return hash().keyword(\"define\");\n+    }\n+\n+    T hashIfdefKeyword() {\n+        return hash().keyword(\"ifdef\");\n+    }\n+\n+    T hashIfndefKeyword() {\n+        return hash().keyword(\"ifndef\");\n+    }\n+\n+    protected T hashEndif() {\n+        return hash().keyword(\"endif\").nl();\n+    }\n+\n+    T hashIfdef(String value) {\n+        return hashIfdefKeyword().space().append(value).nl();\n+    }\n+\n+    protected T hashIfndef(String value) {\n+        return hashIfndefKeyword().space().append(value).nl();\n+    }\n+\n+    T hashIfdef(String value, Consumer<T> consumer) {\n+        return hashIfdef(value).accept(consumer).hashEndif();\n+    }\n+\n+    protected T hashIfndef(String value, Consumer<T> consumer) {\n+        return hashIfndef(value).accept(consumer).hashEndif();\n+    }\n+  \/*  public T defonce(String name, Runnable r) {\n+        return ifndef(name+\"_ONCE_DEF\",()->{\n+            define(name+\"_ONCE_DEF\").nl();\n+            r.run();\n+        });\n+    }*\/\n+\n+    T pragmaKeyword() {\n+        return keyword(\"pragma\");\n+    }\n+\n+    public T hashDefine(String name, String... values) {\n+        hashDefineKeyword().space().identifier(name);\n+        for (String value : values) {\n+            space().append(value);\n+        }\n+        return nl();\n+    }\n+\n+    public T pragma(String name, String... values) {\n+        hash().pragmaKeyword().space().identifier(name);\n+        for (String value : values) {\n+            space().append(value);\n+        }\n+        return nl();\n+    }\n+\n+    T externKeyword() {\n+        return keyword(\"extern\");\n+    }\n+\n+    protected T camel(String value) {\n+        return identifier(Character.toString(Character.toLowerCase(value.charAt(0)))).identifier(value.substring(1));\n+    }\n+\n+    T camelJoin(String prefix, String suffix) {\n+        return camel(prefix).identifier(Character.toString(Character.toUpperCase(suffix.charAt(0)))).identifier(suffix.substring(1));\n+    }\n+\n+    public final T unsignedCharType() {\n+        return typeName(\"unsigned\").space().charType();\n+    }\n+\n+    public T charTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> charType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public T unsignedCharTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedCharType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public T shortTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> shortType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public T unsignedShortTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedShortType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public T intTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> intType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public T unsignedIntTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedIntType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public T floatTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> floatType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public T longTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> longType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public T unsignedLongTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> unsignedLongType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    public T doubleTypeDefs(String... names) {\n+        Arrays.stream(names).forEach(name -> typedef(_ -> doubleType(), _ -> identifier(name)));\n+        return self();\n+    }\n+\n+    private T typedef(Consumer<T> lhs, Consumer<T> rhs) {\n+        return semicolonTerminatedLine(_ -> typedefKeyword().space().accept(lhs).space().accept(rhs));\n+    }\n+\n+    public final T unsignedIntType() {\n+        return typeName(\"unsigned\").space().intType();\n+    }\n+\n+    public final T unsignedLongType() {\n+        return typeName(\"unsigned\").space().longType();\n+    }\n+\n+    public final T unsignedShortType() {\n+        return typeName(\"unsigned\").space().shortType();\n+    }\n+\n+\n+    \/* this should not be too C99 specific *\/\n+    public static interface CodeBuilderInterface<T extends HATCodeBuilderWithContext<?>> {\n+\n+\n+         T varLoad(CodeBuilderContext buildContext, VarLoadOpWrapper varAccessOpWrapper);\n+\n+         T varStore(CodeBuilderContext buildContext, VarStoreOpWrapper varAccessOpWrapper);\n+\n+        \/\/ public T var(BuildContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper) ;\n+\n+         T varDeclaration(CodeBuilderContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper);\n+\n+         T varFuncDeclaration(CodeBuilderContext buildContext, VarFuncDeclarationOpWrapper varFuncDeclarationOpWrapper);\n+\n+         T fieldLoad(CodeBuilderContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper);\n+\n+         T fieldStore(CodeBuilderContext buildContext, FieldStoreOpWrapper fieldStoreOpWrapper);\n+\n+        T unaryOperation(CodeBuilderContext buildContext, UnaryArithmeticOrLogicOpWrapper unaryOperatorOpWrapper);\n+\n+\n+        T binaryOperation(CodeBuilderContext buildContext, BinaryArithmeticOrLogicOperation binaryOperatorOpWrapper);\n+\n+        T logical(CodeBuilderContext buildContext, LogicalOpWrapper logicalOpWrapper);\n+\n+        T binaryTest(CodeBuilderContext buildContext, BinaryTestOpWrapper binaryTestOpWrapper);\n+\n+        T conv(CodeBuilderContext buildContext, ConvOpWrapper convOpWrapper);\n+\n+\n+        T constant(CodeBuilderContext buildContext, ConstantOpWrapper constantOpWrapper);\n+\n+        T javaYield(CodeBuilderContext buildContext, YieldOpWrapper yieldOpWrapper);\n+\n+        T lambda(CodeBuilderContext buildContext, LambdaOpWrapper lambdaOpWrapper);\n+\n+        T tuple(CodeBuilderContext buildContext, TupleOpWrapper lambdaOpWrapper);\n+\n+        T funcCall(CodeBuilderContext buildContext, FuncCallOpWrapper funcCallOpWrapper);\n+\n+        T javaIf(CodeBuilderContext buildContext, IfOpWrapper ifOpWrapper);\n+\n+        T javaWhile(CodeBuilderContext buildContext, WhileOpWrapper whileOpWrapper);\n+\n+        T javaLabeled(CodeBuilderContext buildContext, JavaLabeledOpWrapper javaLabeledOpWrapperOp);\n+\n+        T javaContinue(CodeBuilderContext buildContext, JavaContinueOpWrapper javaContinueOpWrapper);\n+\n+        T javaBreak(CodeBuilderContext buildContext, JavaBreakOpWrapper javaBreakOpWrapper);\n+\n+        T javaFor(CodeBuilderContext buildContext, ForOpWrapper forOpWrapper);\n+\n+\n+         T methodCall(CodeBuilderContext buildContext, InvokeOpWrapper invokeOpWrapper);\n+\n+         T ternary(CodeBuilderContext buildContext, TernaryOpWrapper ternaryOpWrapper);\n+\n+         T parencedence(CodeBuilderContext buildContext, Op parent, OpWrapper<?> child);\n+\n+         T parencedence(CodeBuilderContext buildContext, OpWrapper<?> parent, OpWrapper<?> child);\n+\n+         T parencedence(CodeBuilderContext buildContext, Op parent, Op child);\n+\n+         T parencedence(CodeBuilderContext buildContext, OpWrapper<?> parent, Op child);\n+\n+         T ret(CodeBuilderContext buildContext, ReturnOpWrapper returnOpWrapper);\n+\n+        default T recurse(CodeBuilderContext buildContext, OpWrapper<?> wrappedOp) {\n+            switch (wrappedOp) {\n+                case VarLoadOpWrapper $ -> varLoad(buildContext, $);\n+                case VarStoreOpWrapper $ -> varStore(buildContext, $);\n+                case FieldLoadOpWrapper $ -> fieldLoad(buildContext, $);\n+                case FieldStoreOpWrapper $ -> fieldStore(buildContext, $);\n+                case BinaryArithmeticOrLogicOperation $ -> binaryOperation(buildContext, $);\n+                case UnaryArithmeticOrLogicOpWrapper $ -> unaryOperation(buildContext, $);\n+                case BinaryTestOpWrapper $ -> binaryTest(buildContext, $);\n+                case ConvOpWrapper $ -> conv(buildContext, $);\n+                case ConstantOpWrapper $ -> constant(buildContext, $);\n+                case YieldOpWrapper $ -> javaYield(buildContext, $);\n+                case FuncCallOpWrapper $ -> funcCall(buildContext, $);\n+                case LogicalOpWrapper $ -> logical(buildContext, $);\n+                case InvokeOpWrapper $ -> methodCall(buildContext, $);\n+                case TernaryOpWrapper $ -> ternary(buildContext, $);\n+                case VarDeclarationOpWrapper $ -> varDeclaration(buildContext, $);\n+                case VarFuncDeclarationOpWrapper $ -> varFuncDeclaration(buildContext, $);\n+                case LambdaOpWrapper $ -> lambda(buildContext, $);\n+                case TupleOpWrapper $ -> tuple(buildContext, $);\n+                case WhileOpWrapper $ -> javaWhile(buildContext, $);\n+                case IfOpWrapper $ -> javaIf(buildContext, $);\n+                case ForOpWrapper $ -> javaFor(buildContext, $);\n+\n+                case ReturnOpWrapper $ -> ret(buildContext, $);\n+                case JavaLabeledOpWrapper $ -> javaLabeled(buildContext, $);\n+                case JavaBreakOpWrapper $ -> javaBreak(buildContext, $);\n+                case JavaContinueOpWrapper $ -> javaContinue(buildContext, $);\n+                default -> throw new IllegalStateException(\"handle nesting of op \" + wrappedOp.op());\n+            }\n+            return (T) this;\n+        }\n+\n+\n+    }\n+\n+    public static class CodeBuilderContext {\n+\n+        public static class Scope<OW extends OpWrapper<?>> {\n+            final Scope<?> parent;\n+            final OW opWrapper;\n+\n+            public Scope(Scope<?> parent, OW opWrapper) {\n+                this.parent = parent;\n+                this.opWrapper = opWrapper;\n+            }\n+\n+            public CoreOp.VarOp resolve(Value value) {\n+                if (value instanceof Op.Result result && result.op() instanceof CoreOp.VarOp varOp) {\n+                    return varOp;\n+                }\n+                if (parent != null) {\n+                    return parent.resolve(value);\n+                }\n+                throw new IllegalStateException(\"failed to resolve VarOp for value \" + value);\n+            }\n+        }\n+\n+        public static class FuncScope extends Scope<FuncOpWrapper> {\n+            FuncScope(Scope<?> parent, FuncOpWrapper funcOpWrapper) {\n+                super(parent, funcOpWrapper);\n+            }\n+\n+            @Override\n+            public CoreOp.VarOp resolve(Value value) {\n+                if (value instanceof Block.Parameter blockParameter) {\n+                    if (opWrapper.parameterVarOpMap.containsKey(blockParameter)) {\n+                        return opWrapper.parameterVarOpMap.get(blockParameter);\n+                    } else {\n+                        throw new IllegalStateException(\"what ?\");\n+                    }\n+                } else {\n+                    return super.resolve(value);\n+                }\n+            }\n+        }\n+\n+        public static abstract class LoopScope<T extends OpWrapper<?>> extends Scope<T> {\n+\n+            public LoopScope(Scope<?> parent, T opWrapper) {\n+                super(parent, opWrapper);\n+            }\n+        }\n+\n+\n+        public  static class ForScope extends LoopScope<ForOpWrapper> {\n+            Map<Block.Parameter, CoreOp.VarOp> blockParamToVarOpMap = new HashMap<>();\n+\n+            ForOpWrapper forOpWrapper() {\n+                return opWrapper;\n+            }\n+\n+            ForScope(Scope<?> parent, ForOpWrapper forOpWrapper) {\n+                super(parent, forOpWrapper);\n+                var loopParams = forOpWrapper().op().loopBody().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+                var updateParams = forOpWrapper().op().update().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+                var condParams = forOpWrapper().op().cond().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+                var lastInitOp = forOpWrapper().op().init().entryBlock().ops().getLast();\n+                var lastInitOpOperand0Result = (Op.Result) lastInitOp.operands().getFirst();\n+                var lastInitOpOperand0ResultOp = lastInitOpOperand0Result.op();\n+                CoreOp.VarOp varOps[];\n+                if (lastInitOpOperand0ResultOp instanceof CoreOp.TupleOp tupleOp) {\n+                     \/*\n+                     for (int j = 1, i=2, k=3; j < size; k+=1,i+=2,j+=3) {\n+                        float sum = k+i+j;\n+                     }\n+                     java.for\n+                     ()Tuple<Var<int>, Var<int>, Var<int>> -> {\n+                         %0 : int = constant @\"1\";\n+                         %1 : Var<int> = var %0 @\"j\";\n+                         %2 : int = constant @\"2\";\n+                         %3 : Var<int> = var %2 @\"i\";\n+                         %4 : int = constant @\"3\";\n+                         %5 : Var<int> = var %4 @\"k\";\n+                         %6 : Tuple<Var<int>, Var<int>, Var<int>> = tuple %1 %3 %5;\n+                         yield %6;\n+                     }\n+                     (%7 : Var<int>, %8 : Var<int>, %9 : Var<int>)boolean -> {\n+                         %10 : int = var.load %7;\n+                         %11 : int = var.load %12;\n+                         %13 : boolean = lt %10 %11;\n+                         yield %13;\n+                     }\n+                     (%14 : Var<int>, %15 : Var<int>, %16 : Var<int>)void -> {\n+                         %17 : int = var.load %16;\n+                         %18 : int = constant @\"1\";\n+                         %19 : int = add %17 %18;\n+                         var.store %16 %19;\n+                         %20 : int = var.load %15;\n+                         %21 : int = constant @\"2\";\n+                         %22 : int = add %20 %21;\n+                         var.store %15 %22;\n+                         %23 : int = var.load %14;\n+                         %24 : int = constant @\"3\";\n+                         %25 : int = add %23 %24;\n+                         var.store %14 %25;\n+                         yield;\n+                     }\n+                     (%26 : Var<int>, %27 : Var<int>, %28 : Var<int>)void -> {\n+                         %29 : int = var.load %28;\n+                         %30 : int = var.load %27;\n+                         %31 : int = add %29 %30;\n+                         %32 : int = var.load %26;\n+                         %33 : int = add %31 %32;\n+                         %34 : float = conv %33;\n+                         %35 : Var<float> = var %34 @\"sum\";\n+                         java.continue;\n+                     };\n+                     *\/\n+                    varOps = tupleOp.operands().stream().map(operand -> (CoreOp.VarOp) (((Op.Result) operand).op())).toList().toArray(new CoreOp.VarOp[0]);\n+                } else {\n+                     \/*\n+                     for (int j = 0; j < size; j+=1) {\n+                        float sum = j;\n+                     }\n+                     java.for\n+                        ()Var<int> -> {\n+                            %0 : int = constant @\"0\";\n+                            %1 : Var<int> = var %0 @\"j\";\n+                            yield %1;\n+                        }\n+                        (%2 : Var<int>)boolean -> {\n+                            %3 : int = var.load %2;\n+                            %4 : int = var.load %5;\n+                            %6 : boolean = lt %3 %4;\n+                            yield %6;\n+                        }\n+                        (%7 : Var<int>)void -> {\n+                            %8 : int = var.load %7;\n+                            %9 : int = constant @\"1\";\n+                            %10 : int = add %8 %9;\n+                            var.store %7 %10;\n+                            yield;\n+                        }\n+                        (%11 : Var<int>)void -> {\n+                            %12 : int = var.load %11;\n+                            %13 : float = conv %12;\n+                            %14 : Var<float> = var %13 @\"sum\";\n+                            java.continue;\n+                        };\n+\n+                     *\/\n+                    varOps = new CoreOp.VarOp[]{(CoreOp.VarOp) lastInitOpOperand0ResultOp};\n+                }\n+                for (int i = 0; i < varOps.length; i++) {\n+                    blockParamToVarOpMap.put(condParams[i], varOps[i]);\n+                    blockParamToVarOpMap.put(updateParams[i], varOps[i]);\n+                    blockParamToVarOpMap.put(loopParams[i], varOps[i]);\n+                }\n+            }\n+\n+\n+            @Override\n+            public CoreOp.VarOp resolve(Value value) {\n+                if (value instanceof Block.Parameter blockParameter) {\n+                    CoreOp.VarOp varOp = this.blockParamToVarOpMap.get(blockParameter);\n+                    if (varOp != null) {\n+                        return varOp;\n+                    }\n+                }\n+                return super.resolve(value);\n+            }\n+        }\n+\n+        public static class IfScope extends Scope<IfOpWrapper> {\n+            IfScope(Scope<?> parent, IfOpWrapper opWrapper) {\n+                super(parent, opWrapper);\n+            }\n+        }\n+\n+        public static class WhileScope extends LoopScope<WhileOpWrapper> {\n+            WhileScope(Scope<?> parent, WhileOpWrapper opWrapper) {\n+                super(parent, opWrapper);\n+            }\n+\n+        }\n+\n+        public Scope<?> scope = null;\n+\n+        private void popScope() {\n+            scope = scope.parent;\n+        }\n+\n+        private void pushScope(OpWrapper<?> opWrapper) {\n+            scope = switch (opWrapper) {\n+                case FuncOpWrapper $ -> new FuncScope(scope, $);\n+                case ForOpWrapper $ -> new ForScope(scope, $);\n+                case IfOpWrapper $ -> new IfScope(scope, $);\n+                case WhileOpWrapper $ -> new WhileScope(scope, $);\n+                default -> new Scope<>(scope, opWrapper);\n+            };\n+        }\n+\n+        public void scope(OpWrapper<?> opWrapper, Runnable r) {\n+            pushScope(opWrapper);\n+            r.run();\n+            popScope();\n+        }\n+\n+        public  FuncOpWrapper funcOpWrapper;\n+\n+        public CodeBuilderContext(FuncOpWrapper funcOpWrapper) {\n+            this.funcOpWrapper = funcOpWrapper;\n+        }\n+\n+    }\n+\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilder.java","additions":578,"deletions":0,"binary":false,"changes":578,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend.c99codebuilders;\n+package hat.backend.codebuilders;\n@@ -68,1 +68,1 @@\n-public abstract class C99HatBuilder<T extends C99HatBuilder<T>> extends C99CodeBuilder<T> implements C99HatBuilderInterface<T> {\n+public abstract class HATCodeBuilderWithContext<T extends HATCodeBuilderWithContext<T>> extends HATCodeBuilder<T> implements HATCodeBuilder.CodeBuilderInterface<T> {\n@@ -161,1 +161,1 @@\n-    public T varLoad(C99HatBuildContext buildContext, VarLoadOpWrapper varAccessOpWrapper) {\n+    public T varLoad(CodeBuilderContext buildContext, VarLoadOpWrapper varAccessOpWrapper) {\n@@ -168,1 +168,1 @@\n-    public T varStore(C99HatBuildContext buildContext, VarStoreOpWrapper varAccessOpWrapper) {\n+    public T varStore(CodeBuilderContext buildContext, VarStoreOpWrapper varAccessOpWrapper) {\n@@ -176,1 +176,1 @@\n-    public T varDeclaration(C99HatBuildContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper) {\n+    public T varDeclaration(CodeBuilderContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper) {\n@@ -188,1 +188,1 @@\n-    public T varFuncDeclaration(C99HatBuildContext buildContext, VarFuncDeclarationOpWrapper varFuncDeclarationOpWrapper) {\n+    public T varFuncDeclaration(CodeBuilderContext buildContext, VarFuncDeclarationOpWrapper varFuncDeclarationOpWrapper) {\n@@ -194,1 +194,1 @@\n-    public T fieldLoad(C99HatBuildContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper) {\n+    public T fieldLoad(CodeBuilderContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper) {\n@@ -208,1 +208,1 @@\n-    public T fieldStore(C99HatBuildContext buildContext, FieldStoreOpWrapper fieldStoreOpWrapper) {\n+    public T fieldStore(CodeBuilderContext buildContext, FieldStoreOpWrapper fieldStoreOpWrapper) {\n@@ -242,1 +242,1 @@\n-    public T unaryOperation(C99HatBuildContext buildContext, UnaryArithmeticOrLogicOpWrapper unaryOperatorOpWrapper) {\n+    public T unaryOperation(CodeBuilderContext buildContext, UnaryArithmeticOrLogicOpWrapper unaryOperatorOpWrapper) {\n@@ -250,1 +250,1 @@\n-    public T binaryOperation(C99HatBuildContext buildContext, BinaryArithmeticOrLogicOperation binaryOperatorOpWrapper) {\n+    public T binaryOperation(CodeBuilderContext buildContext, BinaryArithmeticOrLogicOperation binaryOperatorOpWrapper) {\n@@ -258,1 +258,1 @@\n-    public T logical(C99HatBuildContext buildContext, LogicalOpWrapper logicalOpWrapper) {\n+    public T logical(CodeBuilderContext buildContext, LogicalOpWrapper logicalOpWrapper) {\n@@ -270,1 +270,1 @@\n-    public T binaryTest(C99HatBuildContext buildContext, BinaryTestOpWrapper binaryTestOpWrapper) {\n+    public T binaryTest(CodeBuilderContext buildContext, BinaryTestOpWrapper binaryTestOpWrapper) {\n@@ -279,1 +279,1 @@\n-    public T conv(C99HatBuildContext buildContext, ConvOpWrapper convOpWrapper) {\n+    public T conv(CodeBuilderContext buildContext, ConvOpWrapper convOpWrapper) {\n@@ -291,1 +291,1 @@\n-    public T constant(C99HatBuildContext buildContext, ConstantOpWrapper constantOpWrapper) {\n+    public T constant(CodeBuilderContext buildContext, ConstantOpWrapper constantOpWrapper) {\n@@ -302,1 +302,1 @@\n-    public T javaYield(C99HatBuildContext buildContext, YieldOpWrapper yieldOpWrapper) {\n+    public T javaYield(CodeBuilderContext buildContext, YieldOpWrapper yieldOpWrapper) {\n@@ -313,1 +313,1 @@\n-    public T lambda(C99HatBuildContext buildContext, LambdaOpWrapper lambdaOpWrapper) {\n+    public T lambda(CodeBuilderContext buildContext, LambdaOpWrapper lambdaOpWrapper) {\n@@ -318,1 +318,1 @@\n-    public T tuple(C99HatBuildContext buildContext, TupleOpWrapper tupleOpWrapper) {\n+    public T tuple(CodeBuilderContext buildContext, TupleOpWrapper tupleOpWrapper) {\n@@ -333,1 +333,1 @@\n-    public T funcCall(C99HatBuildContext buildContext, FuncCallOpWrapper funcCallOpWrapper) {\n+    public T funcCall(CodeBuilderContext buildContext, FuncCallOpWrapper funcCallOpWrapper) {\n@@ -351,1 +351,1 @@\n-    public T javaLabeled(C99HatBuildContext buildContext, JavaLabeledOpWrapper javaLabeledOpWrapper) {\n+    public T javaLabeled(CodeBuilderContext buildContext, JavaLabeledOpWrapper javaLabeledOpWrapper) {\n@@ -361,1 +361,1 @@\n-    public T javaBreak(C99HatBuildContext buildContext, JavaBreakOpWrapper javaBreakOpWrapper) {\n+    public T javaBreak(CodeBuilderContext buildContext, JavaBreakOpWrapper javaBreakOpWrapper) {\n@@ -372,1 +372,1 @@\n-    public T javaContinue(C99HatBuildContext buildContext, JavaContinueOpWrapper javaContinueOpWrapper) {\n+    public T javaContinue(CodeBuilderContext buildContext, JavaContinueOpWrapper javaContinueOpWrapper) {\n@@ -378,1 +378,1 @@\n-        } else if (buildContext.scope.parent instanceof C99HatBuildContext.LoopScope<?>) {\n+        } else if (buildContext.scope.parent instanceof CodeBuilderContext.LoopScope<?>) {\n@@ -388,1 +388,1 @@\n-    public T javaIf(C99HatBuildContext buildContext, IfOpWrapper ifOpWrapper) {\n+    public T javaIf(CodeBuilderContext buildContext, IfOpWrapper ifOpWrapper) {\n@@ -422,1 +422,1 @@\n-    public T javaWhile(C99HatBuildContext buildContext, WhileOpWrapper whileOpWrapper) {\n+    public T javaWhile(CodeBuilderContext buildContext, WhileOpWrapper whileOpWrapper) {\n@@ -434,1 +434,1 @@\n-    public T javaFor(C99HatBuildContext buildContext, ForOpWrapper forOpWrapper) {\n+    public T javaFor(CodeBuilderContext buildContext, ForOpWrapper forOpWrapper) {\n@@ -525,1 +525,1 @@\n-    public T atomicInc(C99HatBuildContext buildContext, Op.Result instanceResult, String name) {\n+    public T atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n@@ -530,1 +530,1 @@\n-    public T methodCall(C99HatBuildContext buildContext, InvokeOpWrapper invokeOpWrapper) {\n+    public T methodCall(CodeBuilderContext buildContext, InvokeOpWrapper invokeOpWrapper) {\n@@ -655,1 +655,1 @@\n-    public T ternary(C99HatBuildContext buildContext, TernaryOpWrapper ternaryOpWrapper) {\n+    public T ternary(CodeBuilderContext buildContext, TernaryOpWrapper ternaryOpWrapper) {\n@@ -673,1 +673,1 @@\n-    public T parencedence(C99HatBuildContext buildContext, Op parent, OpWrapper<?> child) {\n+    public T parencedence(CodeBuilderContext buildContext, Op parent, OpWrapper<?> child) {\n@@ -677,1 +677,1 @@\n-    public T parencedence(C99HatBuildContext buildContext, OpWrapper<?> parent, OpWrapper<?> child) {\n+    public T parencedence(CodeBuilderContext buildContext, OpWrapper<?> parent, OpWrapper<?> child) {\n@@ -681,1 +681,1 @@\n-    public T parencedence(C99HatBuildContext buildContext, Op parent, Op child) {\n+    public T parencedence(CodeBuilderContext buildContext, Op parent, Op child) {\n@@ -685,1 +685,1 @@\n-    public T parencedence(C99HatBuildContext buildContext, OpWrapper<?> parent, Op child) {\n+    public T parencedence(CodeBuilderContext buildContext, OpWrapper<?> parent, Op child) {\n@@ -691,1 +691,1 @@\n-    public T ret(C99HatBuildContext buildContext, ReturnOpWrapper returnOpWrapper) {\n+    public T ret(CodeBuilderContext buildContext, ReturnOpWrapper returnOpWrapper) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilderWithContext.java","additions":33,"deletions":33,"binary":false,"changes":66,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatBuilder.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.backend.c99codebuilders.C99HatKernelBuilder;\n+import hat.backend.codebuilders.C99HATKernelBuilder;\n@@ -76,1 +76,1 @@\n-    public <T extends C99HatKernelBuilder<T>> String createCode(KernelCallGraph kernelCallGraph, T builder, Object[] args) {\n+    public <T extends C99HATKernelBuilder<T>> String createCode(KernelCallGraph kernelCallGraph, T builder, Object[] args) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.backend.c99codebuilders.C99HatKernelBuilder;\n+import hat.backend.codebuilders.C99HATKernelBuilder;\n@@ -77,1 +77,1 @@\n-    public <T extends C99HatKernelBuilder<T>> String createCode(KernelCallGraph kernelCallGraph, T builder, Object[] args) {\n+    public <T extends C99HATKernelBuilder<T>> String createCode(KernelCallGraph kernelCallGraph, T builder, Object[] args) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -528,0 +528,9 @@\n+    public <I> T commaNlSeparated(Iterable<I> iterable, Consumer<I> c) {\n+        StreamCounter.of(iterable, (counter, t) -> {\n+            if (counter.isNotFirst()) {\n+                comma().nl();\n+            }\n+            c.accept(t);\n+        });\n+        return self();\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/text\/CodeBuilder.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -8,0 +8,3 @@\n+    <option name=\"ADDITIONAL_OPTIONS_OVERRIDE\">\n+      <module name=\"life\" options=\"--add-modules=jdk.incubator.code,java.desktop --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports=java.base\/jdk.internal=ALL-UNNAMED\" \/>\n+    <\/option>\n","filename":"hat\/intellij\/.idea\/compiler.xml","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}