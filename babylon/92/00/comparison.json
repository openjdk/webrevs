{"files":[{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -30,1 +31,1 @@\n-: len(len), text(len > 0 ? new char[len] : nullptr) {}\n+        : len(len), text(len > 0 ? new char[len] : nullptr) {}\n@@ -37,0 +38,1 @@\n+\n@@ -41,11 +43,8 @@\n- Ptx *Ptx::nvcc(const char *cudaSource, size_t len) {\n-\n-     uint64_t time = timeSinceEpochMillisec();\n-     std::stringstream  timestampCuda;\n-     timestampCuda <<\".\/tmp\"<<time<<\".cu\";\n-     std::stringstream  timestampPtx;\n-     timestampPtx <<\".\/tmp\"<<time<<\".ptx\";\n-     std::stringstream  timestampStderr;\n-     timestampStderr <<\".\/tmp\"<<time<<\".stderr\";\n-     std::stringstream  timestampStdout;\n-     timestampStdout <<\".\/tmp\"<<time<<\".stdout\";\n+\n+Ptx *Ptx::nvcc(const char *cudaSource, size_t len) {\n+\n+    uint64_t time = timeSinceEpochMillisec();\n+    std::stringstream timestampCuda;\n+    timestampCuda << \".\/tmp\" << time << \".cu\";\n+    std::stringstream timestampPtx;\n+    timestampPtx << \".\/tmp\" << time << \".ptx\";\n@@ -55,4 +54,2 @@\n-    std::cout<<\"cuda \"<<cudaPath<<std::endl;\n-     std::cout<<\"ptx \"<<ptxPath<<std::endl;\n-   \/\/const char *stderrPath = timestampStderr.str().c_str();\n-   \/\/ const char *stdoutPath = timestampStdout.str().c_str();\n+    std::cout << \"cuda \" << cudaPath << std::endl;\n+    std::cout << \"ptx \" << ptxPath << std::endl;\n@@ -63,1 +60,1 @@\n-        cuda.open(cudaPath, std::ofstream::trunc | std::ofstream::trunc);\n+        cuda.open(cudaPath, std::ofstream::trunc);\n@@ -93,1 +90,1 @@\n-            ptx->text[ptx->len-1] = '\\0';\n+            ptx->text[ptx->len - 1] = '\\0';\n@@ -104,4 +101,9 @@\n-CudaBackend::CudaProgram::CudaKernel::CudaBuffer::CudaBuffer(void *ptr, size_t sizeInBytes)\n-        :Buffer(ptr,sizeInBytes) {\n-    std::cout<<\"cuMemAlloc()\"<<std::endl;\n-    cuMemAlloc(&devicePtr, (size_t) sizeInBytes);\n+CudaBackend::CudaProgram::CudaKernel::CudaBuffer::CudaBuffer(Backend::Program::Kernel *kernel, Arg_t *arg)\n+        : Buffer(kernel, arg) {\n+    \/*\n+     *   (void *) arg->value.buffer.memorySegment,\n+     *   (size_t) arg->value.buffer.sizeInBytes);\n+     *\/\n+    std::cout << \"cuMemAlloc()\" << std::endl;\n+    checkCudaErrors(cuMemAlloc(&devicePtr, (size_t) arg->value.buffer.sizeInBytes));\n+    arg->value.buffer.vendorPtr = static_cast<void*>(this);\n@@ -111,1 +113,1 @@\n-    std::cout<<\"cuMemFree()\"<<std::endl;\n+    std::cout << \"cuMemFree()\" << std::endl;\n@@ -114,0 +116,1 @@\n+\n@@ -115,2 +118,2 @@\n-    std::cout<<\"copyToDevice()\"<<std::endl;\n-    checkCudaErrors(cuMemcpyHtoD(devicePtr, ptr, sizeInBytes));\n+    std::cout << \"copyToDevice()\" << std::endl;\n+    checkCudaErrors(cuMemcpyHtoD(devicePtr, arg->value.buffer.memorySegment, arg->value.buffer.sizeInBytes));\n@@ -118,0 +121,1 @@\n+\n@@ -119,2 +123,3 @@\n-    std::cout<<\"copyFromDevice()\"<<std::endl;\n-    checkCudaErrors(cuMemcpyDtoH(ptr, devicePtr, sizeInBytes));\n+    std::cout << \"copyFromDevice()\" << std::endl;\n+    checkCudaErrors(cuMemcpyDtoH(arg->value.buffer.memorySegment, devicePtr, arg->value.buffer.sizeInBytes));\n+\n@@ -122,0 +127,1 @@\n+\n@@ -127,0 +133,1 @@\n+\n@@ -132,1 +139,1 @@\n-    ArgSled argSled((ArgArray_t *) argArray);\n+    ArgSled argSled(static_cast<ArgArray_t *>(argArray));\n@@ -141,4 +148,1 @@\n-                CudaBuffer *cudaBuffer = new CudaBuffer(\n-                        (void *) arg->value.buffer.memorySegment,\n-                        (size_t) arg->value.buffer.sizeInBytes);\n-                std::cout << \"copying out!\"<<std::endl;\n+                auto cudaBuffer = new CudaBuffer(this, arg);\n@@ -146,3 +150,1 @@\n-\n-                argslist[arg->idx] = (void *) &cudaBuffer->devicePtr;\n-                arg->value.buffer.vendorPtr = (void *) cudaBuffer;\n+                argslist[arg->idx] = static_cast<void*>(&cudaBuffer->devicePtr);\n@@ -151,6 +153,8 @@\n-            case 'I': {\n-                argslist[arg->idx] = &arg->value.s32;\n-                break;\n-            }\n-            case 'F': {\n-                argslist[arg->idx] = &arg->value.f32;\n+            case 'I':\n+            case 'F':\n+            case 'J':\n+            case 'D':\n+            case 'C':\n+            case 'S':\n+            {\n+                argslist[arg->idx] = static_cast<void*>(&arg->value);\n@@ -184,13 +188,2 @@\n-#ifdef VERBOSE\n-        std::cout << \"looking at ! \"<<arg->argc<<std::endl;\n-#endif\n-        switch (arg->variant) {\n-            case '&': {\n-                std::cout << \"copying back!\"<<std::endl;\n-                CudaBuffer *cudaBuffer = (CudaBuffer *) arg->value.buffer.vendorPtr;\n-                cudaBuffer->copyFromDevice();\n-\n-                break;\n-            }\n-            default: {\n-            }\n+        if (arg->variant == '&') {\n+            static_cast<CudaBuffer *>(arg->value.buffer.vendorPtr)->copyFromDevice();\n@@ -202,16 +195,3 @@\n-        switch (arg->variant) {\n-            case '&': {\n-#ifdef VERBOSE\n-                std::cout << \"releasing arg \"<<arg->argc<< \" \"<<std::endl;\n-#endif\n-                CudaBuffer *cudaBuffer = (CudaBuffer *) arg->value.buffer.vendorPtr;\n-\n-                delete cudaBuffer;\n-                break;\n-            }\n-            default: {\n-\n-            }\n-#ifdef VERBOSE\n-                std::cout << \"not releasing arg \"<<arg->idx<< \" \"<<std::endl;\n-#endif\n+        if (arg->variant == '&') {\n+            delete static_cast<CudaBuffer *>(arg->value.buffer.vendorPtr);\n+            arg->value.buffer.vendorPtr= nullptr;\n@@ -220,1 +200,0 @@\n-\n@@ -225,2 +204,1 @@\n-CudaBackend::CudaProgram::CudaProgram(Backend *backend, BuildInfo *buildInfo, Ptx *ptx, CUmodule\n-module)\n+CudaBackend::CudaProgram::CudaProgram(Backend *backend, BuildInfo *buildInfo, Ptx *ptx, CUmodule module)\n@@ -231,1 +209,0 @@\n-\n@@ -240,1 +217,1 @@\n-    return (long) new CudaKernel(this, function);\n+    return reinterpret_cast<long>(new CudaKernel(this, function));\n@@ -251,2 +228,2 @@\n-    std::cout << \"CudaBackend constructor\" << std::endl;\n-    CUresult err = cuInit(0);\n+    std::cout << \"CudaBackend constructor \" << ((cudaConfig == nullptr) ? \"cudaConfig== null\" : \"got cudaConfig\")\n+              << std::endl;\n@@ -254,0 +231,1 @@\n+    CUresult err = cuInit(0);\n@@ -256,0 +234,9 @@\n+        std::cout << \"CudaBackend device count\" << std::endl;\n+        checkCudaErrors(cuDeviceGet(&device, 0));\n+        std::cout << \"CudaBackend device ok\" << std::endl;\n+        checkCudaErrors(cuCtxCreate(&context, 0, device));\n+        std::cout << \"CudaBackend context created ok\" << std::endl;\n+    } else {\n+        std::cout << \"CudaBackend failed, we seem to have the runtime library but no device, no context, nada \"\n+                  << std::endl;\n+        exit(1);\n@@ -257,3 +244,0 @@\n-    checkCudaErrors(cuDeviceGet(&device, 0));\n-    checkCudaErrors(cuCtxCreate(&context, 0, device));\n-    std::cout << \"created context\" << std::endl;\n@@ -279,1 +263,1 @@\n-    cuDeviceGetName(name, 100, device);\n+    cuDeviceGetName(name, sizeof(name), device);\n@@ -319,1 +303,1 @@\n-        CUjit_option *jitOptions = new CUjit_option[jitNumOptions];\n+        auto jitOptions = new CUjit_option[jitNumOptions];\n@@ -334,1 +318,1 @@\n-        return (long) new CudaProgram(this, nullptr, ptx, module);\n+        return reinterpret_cast<long>(new CudaProgram(this, nullptr, ptx, module));\n@@ -337,4 +321,4 @@\n-   } else {\n-       std::cout << \"no ptx content!\/\" << std::endl;\n-       exit(1);\n-   }\n+    } else {\n+        std::cout << \"no ptx content!\/\" << std::endl;\n+        exit(1);\n+    }\n@@ -344,3 +328,1 @@\n-    \/\/ Dynamic cast?\n-    CudaBackend::CudaConfig *cudaConfig = (CudaBackend::CudaConfig *) config;\n-    return (long) new CudaBackend(cudaConfig, configSchemaLen, configSchema);\n+    return reinterpret_cast<long>(new CudaBackend(static_cast<CudaBackend::CudaConfig *>(config), configSchemaLen, configSchema));\n","filename":"hat\/backends\/cuda\/cpp\/cuda_backend.cpp","additions":72,"deletions":90,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+\n@@ -72,0 +73,1 @@\n+\n@@ -73,0 +75,1 @@\n+\n@@ -85,1 +88,1 @@\n-        class CudaBuffer: public Backend::Program::Kernel::Buffer {\n+            class CudaBuffer : public Backend::Program::Kernel::Buffer {\n@@ -87,1 +90,0 @@\n-\n@@ -90,1 +92,2 @@\n-                CudaBuffer(void *ptr, size_t sizeInBytes);\n+                CudaBuffer(Backend::Program::Kernel *kernel, Arg_t *arg);\n+\n@@ -92,0 +95,1 @@\n+\n@@ -93,0 +97,1 @@\n+\n@@ -126,0 +131,1 @@\n+\n@@ -127,0 +133,1 @@\n+\n","filename":"hat\/backends\/cuda\/include\/cuda_backend.h","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,2 +27,6 @@\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::OpenCLBuffer(void *ptr, size_t sizeInBytes, cl_context context)\n-        : Backend::Program::Kernel::Buffer(ptr, sizeInBytes) {\n+OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_t *arg)\n+        : Backend::Program::Kernel::Buffer(kernel, arg) {\n+    \/*\n+     *   (void *) arg->value.buffer.memorySegment,\n+     *   (size_t) arg->value.buffer.sizeInBytes);\n+     *\/\n@@ -30,1 +34,12 @@\n-    clMem = clCreateBuffer(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeInBytes, ptr, &status);\n+    auto openclBackend = dynamic_cast<OpenCLBackend *>(kernel->program->backend);\n+    clMem = clCreateBuffer(openclBackend->context,\n+                           CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE,\n+                           arg->value.buffer.sizeInBytes,\n+                           arg->value.buffer.memorySegment,\n+                           &status);\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    arg->value.buffer.vendorPtr = static_cast<void*>(this);\n+    std::cout << \"created buffer \"<<std::endl;\n@@ -32,0 +47,1 @@\n+\n@@ -34,0 +50,25 @@\n+    \/*\n+     *   (void *) arg->value.buffer.memorySegment,\n+     *   (size_t) arg->value.buffer.sizeInBytes);\n+     *\/\n+    auto openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n+    auto openclBackend = dynamic_cast<OpenCLBackend *>(openclKernel->program->backend);\n+    cl_int status = clEnqueueWriteBuffer(openclBackend->command_queue,\n+                                         clMem,\n+                                         CL_FALSE,\n+                                         0,\n+                                         arg->value.buffer.sizeInBytes,\n+                                         arg->value.buffer.memorySegment,\n+                                         openclKernel->eventc,\n+                                         ((openclKernel->eventc == 0) ? NULL : openclKernel->events),\n+                                         &(openclKernel->events[openclKernel->eventc]));\n+\n+\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+\n+    openclKernel->eventc++;\n+    std::cout << \"enqueued buffer copyToDevice \"<<std::endl;\n+\n@@ -35,1 +76,0 @@\n-void OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::copyFromDevice() {\n@@ -37,0 +77,19 @@\n+void OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::copyFromDevice() {\n+    auto openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n+    auto openclBackend = dynamic_cast<OpenCLBackend *>(openclKernel->program->backend);\n+    cl_int status = clEnqueueReadBuffer(openclBackend->command_queue,\n+                                        clMem,\n+                                        CL_FALSE,\n+                                        0,\n+                                        arg->value.buffer.sizeInBytes,\n+                                        arg->value.buffer.memorySegment,\n+                                        openclKernel->eventc,\n+                                        ((openclKernel->eventc == 0) ? NULL : openclKernel->events),\n+                                        &(openclKernel->events[openclKernel->eventc]));\n+\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    openclKernel->eventc++;\n+    std::cout << \"enqueued buffer copyFromDevice \"<<std::endl;\n@@ -38,0 +97,1 @@\n+\n@@ -43,1 +103,2 @@\n-        : Backend::Program::Kernel(program), kernel(kernel) {\n+        : Backend::Program::Kernel(program), kernel(kernel), eventMax(0), events(nullptr),\n+          eventc(0) {\n@@ -51,10 +112,2 @@\n-    \/\/std::cout<<\"ndrange(\"<<range<<\") \"<< std::endl;\n-    ArgSled argSled((ArgArray_t *) argArray);\n-    cl_int status;\n-    OpenCLBackend *backend = (OpenCLBackend *) program->backend;\n-\n-    bool verbose = false;\n-\n-    \/\/ std::cout << \"allocing events \"<< ((argSled.argc()*3)+1)<< std::endl;\n-\n-    backend->allocEvents(argSled.argc() * 3 + 1);\n+    std::cout << \"ndrange(\" << range << \") \" << std::endl;\n+    ArgSled argSled(static_cast<ArgArray_t *>(argArray));\n@@ -62,0 +115,6 @@\n+    if (events != nullptr || eventc != 0) {\n+        std::cerr << \"opencl state issue, we might have leaked events!\" << std::endl;\n+    }\n+    eventMax = argSled.argc() * 4 + 1;\n+    eventc = 0;\n+    events = new cl_event[eventMax];\n@@ -64,11 +123,48 @@\n-\n-        if (arg->variant == '&') {\n-            arg->value.buffer.vendorPtr = new OpenCLBuffer(\n-                    (void *) arg->value.buffer.memorySegment,\n-                    (size_t) arg->value.buffer.sizeInBytes,\n-                    backend->context);\n-            OpenCLBuffer *clbuf = ((OpenCLBuffer *) arg->value.buffer.vendorPtr);\n-            if ((status = clEnqueueWriteBuffer(backend->command_queue, clbuf->clMem, CL_FALSE, 0, clbuf->sizeInBytes, clbuf->ptr, backend->eventc, ((backend->eventc == 0) ? NULL : backend->events),\n-                    &(backend->events[backend->eventc]))) !=\n-                CL_SUCCESS) {\n-                std::cerr << \"write failed!\" << errorMsg(status) << std::endl;\n+        switch (arg->variant) {\n+            case '&': {\n+                auto openclBuffer = new OpenCLBuffer(this, arg);\n+                openclBuffer->copyToDevice();\n+                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &openclBuffer->clMem);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                std::cout << \"set buffer arg \"<<arg->idx<<std::endl;\n+                break;\n+            }\n+            case 'I':\n+            case 'F':\n+            {\n+                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(arg->value.x32), (void *) &arg->value);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                std::cout << \"set I or F arg \"<<arg->idx<<std::endl;\n+                break;\n+            }\n+            case 'S':\n+            case 'C':\n+            {\n+                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(arg->value.x16), (void *) &arg->value);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                std::cout << \"set S or C arg \"<<arg->idx<<std::endl;\n+                break;\n+            }\n+            case 'J':\n+            case 'D':\n+            {\n+                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(arg->value.x64), (void *) &arg->value);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                std::cout << \"set J or D arg \"<<arg->idx<<std::endl;\n+                break;\n+            }\n+            default: {\n+                std::cout << \"unexpected variant \" << (char) arg->variant << std::endl;\n+                exit(1);\n@@ -76,7 +172,0 @@\n-            backend->eventc++;\n-            clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &((OpenCLBuffer *) arg->value.buffer.vendorPtr)->clMem);\n-\n-        } else if (arg->variant == 'I') {\n-            clSetKernelArg(kernel, arg->idx, sizeof(arg->value.s32), (void *) &arg->value.s32);\n-        } else if (arg->variant == 'F') {\n-            clSetKernelArg(kernel, arg->idx, sizeof(arg->value.f32), (void *) &arg->value.f32);\n@@ -85,0 +174,1 @@\n+\n@@ -87,2 +177,2 @@\n-    if ((status = clEnqueueNDRangeKernel(\n-            backend->command_queue,\n+    cl_int status = clEnqueueNDRangeKernel(\n+            dynamic_cast<OpenCLBackend *>(program->backend)->command_queue,\n@@ -94,3 +184,8 @@\n-            backend->eventc,\n-            ((backend->eventc == 0) ? nullptr : backend->events),\n-            &(backend->events[backend->eventc]))) != CL_SUCCESS) {\n+            eventc,\n+            ((eventc == 0)?nullptr:events),\n+            &(events[eventc]));\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    std::cout << \"enqueued dispatch  \"<<std::endl;\n@@ -98,1 +193,1 @@\n-        std::cout <<  \" globalSize=\" << globalSize << \" \" << error(status) << std::endl;\n+    std::cout <<  \" globalSize=\" << globalSize << \" \" << error(status) << std::endl;\n@@ -100,2 +195,2 @@\n-    }\n-    backend->eventc++;\n+\n+    eventc++;\n@@ -104,10 +199,2 @@\n-\n-        if (arg->variant == '&') {\n-            OpenCLBuffer *clBuf = ((OpenCLBuffer *) arg->value.buffer.vendorPtr);\n-            if ((status = clEnqueueReadBuffer(backend->command_queue, clBuf->clMem, CL_FALSE, 0,\n-                    clBuf->sizeInBytes, clBuf->ptr, backend->eventc, ((backend->eventc == 0) ? NULL : backend->events),\n-                    &(backend->events[backend->eventc]))) !=\n-                CL_SUCCESS) {\n-                std::cout << \"read failed!\";\n-            }\n-            backend->eventc++;\n+        if (arg->variant =='&') {\n+            static_cast<OpenCLBuffer *>(arg->value.buffer.vendorPtr)->copyFromDevice();\n@@ -116,1 +203,16 @@\n-    backend->waitForEvents();\n+    status = clWaitForEvents(eventc, events);\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    for (int i = 0; i < eventc; i++) {\n+        status = clReleaseEvent(events[i]);\n+        if (status != CL_SUCCESS) {\n+            std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+            exit(1);\n+        }\n+    }\n+    delete[] events;\n+    eventMax = 0;\n+    eventc = 0;\n+    events = nullptr;\n@@ -119,2 +221,3 @@\n-        if (arg->variant == '&') {\n-            delete ((OpenCLBuffer *) arg->value.buffer.vendorPtr);\n+        if (arg->variant =='&'){\n+            delete static_cast<OpenCLBuffer*>(arg->value.buffer.vendorPtr);\n+            arg->value.buffer.vendorPtr= nullptr;\n@@ -123,1 +226,0 @@\n-    backend->releaseEvents();\n@@ -147,1 +249,1 @@\n-        : Backend((Backend::Config *) openclConfig, configSchemaLen, configSchema), eventMax(0), events(nullptr), eventc(0) {\n+        : Backend((Backend::Config *) openclConfig, configSchemaLen, configSchema) {\n@@ -155,1 +257,2 @@\n-    cl_device_type requestedType = openclConfig == nullptr ? CL_DEVICE_TYPE_GPU : openclConfig->gpu ? CL_DEVICE_TYPE_GPU : CL_DEVICE_TYPE_CPU;\n+    cl_device_type requestedType =\n+            openclConfig == nullptr ? CL_DEVICE_TYPE_GPU : openclConfig->gpu ? CL_DEVICE_TYPE_GPU : CL_DEVICE_TYPE_CPU;\n@@ -193,1 +296,2 @@\n-    if ((command_queue = clCreateCommandQueue(context, device_ids[0], queue_props, &status)) == NULL || status != CL_SUCCESS) {\n+    if ((command_queue = clCreateCommandQueue(context, device_ids[0], queue_props, &status)) == NULL ||\n+        status != CL_SUCCESS) {\n@@ -214,24 +318,1 @@\n-void OpenCLBackend::allocEvents(int max) {\n-    if (events != nullptr || eventc != 0) {\n-        std::cerr << \"opencl state issue, we might have leaked events!\" << std::endl;\n-    }\n-    eventMax = max;\n-    eventc = 0;\n-    events = new cl_event[eventMax];\n-}\n-\n-void OpenCLBackend::releaseEvents() {\n-    for (int i = 0; i < eventc; i++) {\n-        clReleaseEvent(events[i]);\n-    }\n-    delete[] events;\n-    eventMax = 0;\n-    eventc = 0;\n-    events = nullptr;\n-}\n-\n-void OpenCLBackend::waitForEvents() {\n-    clWaitForEvents(eventc, events);\n-}\n-\n-void OpenCLBackend::showEvents(int width) {\n+void OpenCLBackend::OpenCLProgram::OpenCLKernel::showEvents(int width) {\n@@ -260,1 +341,2 @@\n-            if ((clGetEventProfilingInfo(events[event], info, sizeof(samples[sample]), &samples[sample], NULL)) != CL_SUCCESS) {\n+            if ((clGetEventProfilingInfo(events[event], info, sizeof(samples[sample]), &samples[sample], NULL)) !=\n+                CL_SUCCESS) {\n@@ -315,1 +397,5 @@\n-    clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(value), &value, nullptr);\n+    cl_int status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(value), &value, nullptr);\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n@@ -317,0 +403,1 @@\n+\n@@ -323,1 +410,2 @@\n-    status = clGetPlatformInfo(platform_id, CL_PLATFORM_VERSION, sizeof(platformVersionName), platformVersionName, NULL);\n+    status = clGetPlatformInfo(platform_id, CL_PLATFORM_VERSION, sizeof(platformVersionName), platformVersionName,\n+                               NULL);\n@@ -359,1 +447,2 @@\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, sizeof(maxWorkItemDimensions), &maxWorkItemDimensions, NULL);\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, sizeof(maxWorkItemDimensions),\n+                             &maxWorkItemDimensions, NULL);\n@@ -363,1 +452,2 @@\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(size_t) * maxWorkItemDimensions, maxWorkItemSizes, NULL);\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(size_t) * maxWorkItemDimensions,\n+                             maxWorkItemSizes, NULL);\n@@ -369,1 +459,2 @@\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL);\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize,\n+                             NULL);\n@@ -421,1 +512,2 @@\n-    if ((program = clCreateProgramWithSource(context, 1, (const char **) &src, nullptr, &status)) == nullptr || status != CL_SUCCESS) {\n+    if ((program = clCreateProgramWithSource(context, 1, (const char **) &src, nullptr, &status)) == nullptr ||\n+        status != CL_SUCCESS) {\n@@ -442,1 +534,2 @@\n-            if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, logLen + 1, (void *) log, nullptr)) != CL_SUCCESS) {\n+            if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, logLen + 1, (void *) log,\n+                                                nullptr)) != CL_SUCCESS) {\n@@ -458,1 +551,1 @@\n-    return (long) new OpenCLProgram(this, buildInfo, program);\n+    return reinterpret_cast<long>(new OpenCLProgram(this, buildInfo, program));\n@@ -520,1 +613,1 @@\n-\/\/std::cerr << \" clerror '\" << error_table[ii].msg << \"'\" << std::endl;\n+            \/\/std::cerr << \" clerror '\" << error_table[ii].msg << \"'\" << std::endl;\n@@ -530,5 +623,2 @@\n-    \/\/ Dynamic cast?\n-    OpenCLBackend::OpenCLConfig *openclConfig = (OpenCLBackend::OpenCLConfig *) config;\n-\n-    return (long) new OpenCLBackend(openclConfig, configSchemaLen, configSchema);\n-}\n\\ No newline at end of file\n+    return reinterpret_cast<long>(new OpenCLBackend(static_cast<OpenCLBackend::OpenCLConfig*>(config), configSchemaLen, configSchema));\n+}\n","filename":"hat\/backends\/opencl\/cpp\/opencl_backend.cpp","additions":187,"deletions":97,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+\n@@ -38,0 +39,1 @@\n+\n@@ -50,0 +52,1 @@\n+\n@@ -57,1 +60,0 @@\n-        boolean junk;\n@@ -63,1 +65,1 @@\n-        class OpenCLBuffer : public Backend::Program::Kernel::Buffer {\n+            class OpenCLBuffer : public Backend::Program::Kernel::Buffer {\n@@ -65,1 +67,0 @@\n-\n@@ -67,0 +68,1 @@\n+\n@@ -68,0 +70,1 @@\n+\n@@ -69,1 +72,2 @@\n-                OpenCLBuffer(void *ptr, size_t sizeInBytes, cl_context context);\n+\n+                OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_t *arg);\n@@ -76,0 +80,8 @@\n+            size_t eventMax;\n+            cl_event *events;\n+            size_t eventc;\n+        protected:\n+           \/\/ void allocEvents(int max);\n+           \/\/ void releaseEvents();\n+           \/\/ void waitForEvents();\n+            void showEvents(int width);\n@@ -102,3 +114,1 @@\n-    size_t eventMax;\n-    cl_event *events;\n-    size_t eventc;\n+\n@@ -118,5 +128,0 @@\n-protected:\n-\n-    void allocEvents(int max);\n-\n-    void releaseEvents();\n@@ -124,1 +129,0 @@\n-    void waitForEvents();\n@@ -126,1 +130,0 @@\n-    void showEvents(int width);\n","filename":"hat\/backends\/opencl\/include\/opencl_backend.h","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+    u16_t x16;  \/\/ 'C' or 'S\"\n@@ -90,0 +91,1 @@\n+    s32_t x32;  \/\/ 'I' or 'F'\n@@ -93,0 +95,1 @@\n+    s64_t x64; \/\/ 'D' or 'J'\n@@ -99,1 +102,1 @@\n-    u8_t pad1[8];\n+    u8_t pad8[8];\n@@ -101,1 +104,1 @@\n-    u8_t pad[6];\n+    u8_t pad6[6];\n@@ -106,1 +109,1 @@\n-    u8_t pad[12];\n+    u8_t pad12[12];\n@@ -174,9 +177,0 @@\n-    \/*  void *vendorPtr(){\n-        char *cptr = (char*)vendorPtrPtr();\n-        char *cptr2 =  (char*)cptr[0];\n-        return (void*)cptr2;\n-        }\n-\n-        void vendorPtr(void *vendorPtr){\n-     *vendorPtrPtr() =vendorPtr;\n-     } *\/\n@@ -487,2 +481,2 @@\n-                void *ptr;\n-                size_t sizeInBytes;\n+                Kernel *kernel;\n+                Arg_t *arg;\n@@ -491,1 +485,1 @@\n-                Buffer(void *ptr, size_t sizeInBytes):ptr(ptr), sizeInBytes(sizeInBytes) {\n+                Buffer(Kernel *kernel, Arg_t *arg):kernel(kernel),arg(arg){\n","filename":"hat\/backends\/shared\/include\/shared.h","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"}]}