{"files":[{"patch":"@@ -40,0 +40,2 @@\n+ * @run main Unreflect TestArrayCreation\n+ * @run junit TestArrayCreation\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayCreation.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestArrayTypes\n+ * @run junit TestArrayTypes\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayTypes.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestBinops\n+ * @run junit TestBinops\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBinops.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestBlockOp\n+ * @run junit TestBlockOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestBreakContinue\n+ * @run junit TestBreakContinue\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBreakContinue.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+ * @run main Unreflect TestConcat\n+ * @run junit TestConcat\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConcat.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestConditionalExpression\n+ * @run junit TestConditionalExpression\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalExpression.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+ * @run main Unreflect TestConditionalOp\n+ * @run junit TestConditionalOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestConstants\n+ * @run junit TestConstants\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConstants.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+ * @run main Unreflect TestEnhancedForOp\n+ * @run junit TestEnhancedForOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestEnhancedForOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestForOp\n+ * @run junit TestForOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestForOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestIfOp\n+ * @run junit TestIfOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestIfOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestInvokeSuper\n+ * @run junit TestInvokeSuper\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInvokeSuper.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestLambdaOps\n+ * @run junit TestLambdaOps\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+ * @run main Unreflect TestLocalTransformationsAdaption\n+ * @run junit TestLocalTransformationsAdaption\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLocalTransformationsAdaption.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestOverloads\n+ * @run junit TestOverloads\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOverloads.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestPatterns\n+ * @run junit TestPatterns\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,0 +18,2 @@\n+ * @run main Unreflect TestPatterns2\n+ * @run junit TestPatterns2\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns2.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestPrimitiveCast\n+ * @run junit TestPrimitiveCast\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveCast.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+ * @run main Unreflect TestSSA\n+ * @run junit TestSSA\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSSA.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestTry\n+ * @run junit TestTry\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTry.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestTryFinally\n+ * @run junit TestTryFinally\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryFinally.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestTryNested\n+ * @run junit TestTryNested\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryNested.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestVarArgsInvoke\n+ * @run junit TestVarArgsInvoke\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarArgsInvoke.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestWhileOp\n+ * @run junit TestWhileOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestWhileOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.instruction.InvokeDynamicInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.lang.invoke.LambdaConversionException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.runtime.ReflectableLambdaMetafactory;\n+\n+public final class Unreflect {\n+\n+    static final ClassDesc CD_Reflect = Reflect.class.describeConstable().get();\n+    static final ClassDesc CD_Unreflect = Unreflect.class.describeConstable().get();\n+    static final ClassDesc CD_ReflectableLambdaMetafactory = ReflectableLambdaMetafactory.class.describeConstable().get();\n+\n+    static boolean isReflective(MethodModel mm) {\n+        return mm.findAttribute(Attributes.runtimeVisibleAnnotations())\n+                 .map(aa -> aa.annotations().stream().anyMatch(a -> a.classSymbol().equals(CD_Reflect)))\n+                 .orElse(false);\n+    }\n+\n+    static byte[] transform(ClassModel clm) {\n+        return ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(clm, (clb, cle) -> {\n+            if (cle instanceof MethodModel mm) {\n+                if (isReflective(mm)) {\n+                    clb.transformMethod(mm, MethodTransform.dropping(me -> me instanceof CodeModel)\n+                            .andThen(MethodTransform.endHandler(mb -> mb.withCode(cob -> {\n+                                MethodTypeDesc mts = mm.methodTypeSymbol();\n+                                boolean hasReceiver = !mm.flags().has(AccessFlag.STATIC);\n+                                if (hasReceiver) {\n+                                    cob.aload(cob.receiverSlot());\n+                                }\n+                                for (int i = 0; i < mts.parameterCount(); i++) {\n+                                    cob.loadLocal(TypeKind.from(mts.parameterType(i)), cob.parameterSlot(i));\n+                                }\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        ConstantDescs.ofCallsiteBootstrap(CD_Unreflect, \"unreflect\", ConstantDescs.CD_CallSite),\n+                                        mm.methodName().stringValue(),\n+                                        hasReceiver ? mts.insertParameterTypes(0, clm.thisClass().asSymbol()) : mts));\n+                                cob.return_(TypeKind.from(mts.returnType()));\n+                            }))));\n+                } else {\n+                    clb.transformMethod(mm, MethodTransform.transformingCode((cob, coe) -> {\n+                        DirectMethodHandleDesc bsm;\n+                        if (coe instanceof InvokeDynamicInstruction i\n+                                && (bsm = i.bootstrapMethod()).owner().equals(CD_ReflectableLambdaMetafactory)) {\n+                            \/\/ redirect metafactory and altMetafactory\n+                            cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                    MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                              CD_Unreflect,\n+                                                              bsm.methodName(),\n+                                                              bsm.invocationType()),\n+                                    i.name().stringValue(),\n+                                    MethodTypeDesc.ofDescriptor(i.type().stringValue()),\n+                                    i.bootstrapArgs().toArray(ConstantDesc[]::new)));\n+                        } else {\n+                            cob.with(coe);\n+                        }\n+                    }));\n+                }\n+            } else {\n+                clb.with(cle);\n+            }\n+        });\n+    }\n+\n+    public static CallSite unreflect(MethodHandles.Lookup caller,\n+                                     String methodName,\n+                                     MethodType methodType) throws NoSuchMethodException {\n+        for (Method m : caller.lookupClass().getDeclaredMethods()) {\n+            int firstParam = (m.getModifiers() & Modifier.STATIC) == 0 ? 1 : 0;\n+            if (m.getName().equals(methodName)\n+                    && m.getReturnType() == methodType.returnType()\n+                    && m.getParameterCount() == methodType.parameterCount() - firstParam\n+                    && Arrays.equals(m.getParameterTypes(), 0, m.getParameterCount(),\n+                                     methodType.parameterArray(), firstParam, methodType.parameterCount())) {\n+                return new ConstantCallSite(BytecodeGenerator.generate(caller, Op.ofMethod(m).orElseThrow()));\n+            }\n+        }\n+        throw new NoSuchMethodException(caller.lookupClass().getName() + \".\" + methodName + methodType);\n+    }\n+\n+    public static CallSite metafactory(MethodHandles.Lookup caller,\n+                                       String interfaceMethodName,\n+                                       MethodType factoryType,\n+                                       MethodType interfaceMethodType,\n+                                       MethodHandle implementation,\n+                                       MethodType dynamicMethodType) throws LambdaConversionException {\n+        return ReflectableLambdaMetafactory.metafactory(caller,\n+                                                        interfaceMethodName,\n+                                                        factoryType,\n+                                                        interfaceMethodType,\n+                                                        unreflectLambdaImplementation(caller, interfaceMethodName),\n+                                                        dynamicMethodType);\n+    }\n+\n+    public static CallSite altMetafactory(MethodHandles.Lookup caller,\n+                                          String interfaceMethodName,\n+                                          MethodType factoryType,\n+                                          Object... args) throws LambdaConversionException {\n+        args[1] = unreflectLambdaImplementation(caller, interfaceMethodName);\n+        return ReflectableLambdaMetafactory.altMetafactory(caller,\n+                                                           interfaceMethodName,\n+                                                           factoryType,\n+                                                           args);\n+    }\n+\n+    static MethodHandle unreflectLambdaImplementation(MethodHandles.Lookup caller, String interfaceMethodName)\n+            throws LambdaConversionException {\n+        try {\n+            MethodHandle opHandle = caller.findStatic(caller.lookupClass(),\n+                                                      interfaceMethodName.split(\"=\")[1],\n+                                                      MethodType.methodType(Op.class));\n+            return BytecodeGenerator.generate(caller, unquoteLambda((CoreOp.FuncOp)opHandle.invoke()));\n+        } catch (Throwable t) {\n+            throw new LambdaConversionException(t);\n+        }\n+    }\n+\n+    \/\/ flat QuotedOp and LambdaOp\n+    static CoreOp.FuncOp unquoteLambda(CoreOp.FuncOp funcOp) {\n+        int capturedValues = funcOp.parameters().size();\n+        List<Op> ops = funcOp.body().entryBlock().ops();\n+        JavaOp.LambdaOp lambda = (JavaOp.LambdaOp)((CoreOp.QuotedOp)ops.get(ops.size() - 2)).quotedOp();\n+        return CoreOp.func(funcOp.funcName(), CoreType.functionType(\n+                lambda.body().yieldType(),\n+                Stream.of(funcOp.invokableType().parameterTypes(),\n+                          lambda.invokableType().parameterTypes()).flatMap(List::stream).toList())).body(bb -> {\n+            bb.context().mapBlock(funcOp.body().entryBlock(), bb.entryBlock());\n+            bb.context().mapValues(funcOp.parameters(), bb.parameters().subList(0, capturedValues));\n+            for (int i = 0; i < ops.size() - 2; i++) {\n+                Op o = ops.get(i);\n+                bb.context().mapValue(o.result(), bb.op(o));\n+            }\n+            bb.body(lambda.body(),\n+                    bb.parameters().subList(capturedValues, bb.parameters().size()),\n+                    bb.context(),\n+                    CodeTransformer.COPYING_TRANSFORMER);\n+        });\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ process class files from arguments\n+        var toUnreflect = new ArrayDeque<>(List.of(args));\n+        var done = new HashSet<String>();\n+        while (!toUnreflect.isEmpty()) {\n+            String arg = toUnreflect.pop();\n+            if (!arg.endsWith(\".class\")) arg += \".class\";\n+            if (done.add(arg)) {\n+                System.out.println(\"unreflecting \" + arg);\n+                Path clsFile = Path.of(Unreflect.class.getResource(arg).toURI());\n+                ClassModel clm = ClassFile.of().parse(Files.readAllBytes(clsFile));\n+                \/\/ unreflect all nest members\n+                clm.findAttribute(Attributes.nestMembers())\n+                        .ifPresent(nma -> toUnreflect.addAll(\n+                                nma.nestMembers().stream().map(ClassEntry::asInternalName).toList()));\n+                Files.write(clsFile, transform(clm));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/Unreflect.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.code.CodeTransformer;\n@@ -41,0 +40,3 @@\n+ * @library ..\/\n+ * @run junit TestArrayCreation\n+ * @run main Unreflect TestArrayCreation\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+ * @library ..\/\n+ * @run junit TestBranchCompactor\n+ * @run main Unreflect TestBranchCompactor\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+ * @library ..\/\n+ * @run junit\/othervm -Djdk.invoke.MethodHandle.dumpClassFiles=true TestBytecode\n+ * @run main Unreflect TestBytecode\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+ * @library ..\/\n+ * @run junit TestInvokeSuper\n+ * @run main Unreflect TestInvokeSuper\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestInvokeSuper.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+ * @library ..\/\n@@ -26,0 +27,2 @@\n+ * @run main Unreflect TestIsCaseConstantSwitch\n+ * @run junit TestIsCaseConstantSwitch\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestIsCaseConstantSwitch.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+ * @library ..\/\n+ * @run junit TestNestedCapturingLambda\n+ * @run main Unreflect TestNestedCapturingLambda\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNestedCapturingLambda.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+ * @library ..\/\n+ * @run junit TestSlots\n+ * @run main Unreflect TestSlots\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlotOps.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+ * @library ..\/\n+ * @run junit TestSlots\n+ * @run main Unreflect TestSlots\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+ * @library ..\/\n+ * @run junit TestSwitch\n+ * @run main Unreflect TestSwitch\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSwitch.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+ * @library ..\/\n+ * @run junit TestSynchronizedOp\n+ * @run main Unreflect TestSynchronizedOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSynchronizedOp.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+ * @library ..\/\n+ * @run junit TestTry\n+ * @run main Unreflect TestTry\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+ * @library ..\/\n+ * @run junit TestTryFinally\n+ * @run main Unreflect TestTryFinally\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+ * @library ..\/\n+ * @run junit TestTryFinallyNested\n+ * @run main Unreflect TestTryFinallyNested\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -23,0 +23,3 @@\n+ * @library ..\/\n+ * @run junit TestVarArg\n+ * @run main Unreflect TestVarArg\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+ * @library ..\/..\/\n+ * @run junit TestLiftCustomBytecode\n+ * @run main Unreflect TestLiftCustomBytecode\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestLiftCustomBytecode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+ * @library ..\/..\/\n+ * @run junit TestLiftExample\n+ * @run main Unreflect TestLiftExample\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestLiftExample.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+ * @library ..\/..\/\n+ * @run junit TestSmallCorpus\n+ * @run main Unreflect TestSmallCorpus\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestSmallCorpus.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}