{"files":[{"patch":"@@ -40,0 +40,2 @@\n+ * @run main Unreflect TestArrayCreation\n+ * @run junit TestArrayCreation\n@@ -85,0 +87,14 @@\n+    @Reflect\n+    public static String[][] f4() {\n+        return new String[][]{{\"one\", \"two\"}, {\"three\"}};\n+    }\n+\n+    @Test\n+    public void testf4() {\n+        CoreOp.FuncOp f = getFuncOp(\"f4\");\n+\n+        System.out.println(f.toText());\n+\n+        Assertions.assertArrayEquals(f4(), (Object[]) Interpreter.invoke(MethodHandles.lookup(), f));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayCreation.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestArrayTypes\n+ * @run junit TestArrayTypes\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayTypes.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestBinops\n+ * @run junit TestBinops\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBinops.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestBlockOp\n+ * @run junit TestBlockOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestBreakContinue\n+ * @run junit TestBreakContinue\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBreakContinue.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+ * @run main Unreflect TestConcat\n+ * @run junit TestConcat\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConcat.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestConditionalExpression\n+ * @run junit TestConditionalExpression\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalExpression.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+ * @run main Unreflect TestConditionalOp\n+ * @run junit TestConditionalOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestConstants\n+ * @run junit TestConstants\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConstants.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+ * @run main Unreflect TestEnhancedForOp\n+ * @run junit TestEnhancedForOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestEnhancedForOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestForOp\n+ * @run junit TestForOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestForOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestIfOp\n+ * @run junit TestIfOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestIfOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestInvokeSuper\n+ * @run junit TestInvokeSuper\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInvokeSuper.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestLambdaOps\n+ * @run junit TestLambdaOps\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+ * @run main Unreflect TestLocalTransformationsAdaption\n+ * @run junit TestLocalTransformationsAdaption\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLocalTransformationsAdaption.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestOverloads\n+ * @run junit TestOverloads\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOverloads.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestPatterns\n+ * @run junit TestPatterns\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,0 +18,2 @@\n+ * @run main Unreflect TestPatterns2\n+ * @run junit TestPatterns2\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns2.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestPrimitiveCast\n+ * @run junit TestPrimitiveCast\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveCast.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+ * @run main Unreflect TestSSA\n+ * @run junit TestSSA\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSSA.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestTry\n+ * @run junit TestTry\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTry.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestTryFinally\n+ * @run junit TestTryFinally\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryFinally.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestTryNested\n+ * @run junit TestTryNested\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryNested.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @run main Unreflect TestVarArgsInvoke\n+ * @run junit TestVarArgsInvoke\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarArgsInvoke.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @run main Unreflect TestWhileOp\n+ * @run junit TestWhileOp\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestWhileOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.instruction.InvokeDynamicInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.lang.invoke.LambdaConversionException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.runtime.ReflectableLambdaMetafactory;\n+\n+public final class Unreflect {\n+\n+    static final ClassDesc CD_Reflect = Reflect.class.describeConstable().get();\n+    static final ClassDesc CD_Unreflect = Unreflect.class.describeConstable().get();\n+    static final ClassDesc CD_ReflectableLambdaMetafactory = ReflectableLambdaMetafactory.class.describeConstable().get();\n+\n+    static boolean isReflective(MethodModel mm) {\n+        return mm.findAttribute(Attributes.runtimeVisibleAnnotations())\n+                 .map(aa -> aa.annotations().stream().anyMatch(a -> a.classSymbol().equals(CD_Reflect)))\n+                 .orElse(false);\n+    }\n+\n+    static byte[] transform(ClassModel clm) {\n+        return ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(clm, (clb, cle) -> {\n+            if (cle instanceof MethodModel mm) {\n+                if (isReflective(mm)) {\n+                    clb.transformMethod(mm, MethodTransform.dropping(me -> me instanceof CodeModel)\n+                            .andThen(MethodTransform.endHandler(mb -> mb.withCode(cob -> {\n+                                MethodTypeDesc mts = mm.methodTypeSymbol();\n+                                boolean hasReceiver = !mm.flags().has(AccessFlag.STATIC);\n+                                if (hasReceiver) {\n+                                    cob.aload(cob.receiverSlot());\n+                                }\n+                                for (int i = 0; i < mts.parameterCount(); i++) {\n+                                    cob.loadLocal(TypeKind.from(mts.parameterType(i)), cob.parameterSlot(i));\n+                                }\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        ConstantDescs.ofCallsiteBootstrap(CD_Unreflect, \"unreflect\", ConstantDescs.CD_CallSite),\n+                                        mm.methodName().stringValue(),\n+                                        hasReceiver ? mts.insertParameterTypes(0, clm.thisClass().asSymbol()) : mts));\n+                                cob.return_(TypeKind.from(mts.returnType()));\n+                            }))));\n+                } else {\n+                    clb.transformMethod(mm, MethodTransform.transformingCode((cob, coe) -> {\n+                        DirectMethodHandleDesc bsm;\n+                        if (coe instanceof InvokeDynamicInstruction i\n+                                && (bsm = i.bootstrapMethod()).owner().equals(CD_ReflectableLambdaMetafactory)) {\n+                            \/\/ redirect metafactory and altMetafactory\n+                            cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                    MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                              CD_Unreflect,\n+                                                              bsm.methodName(),\n+                                                              bsm.invocationType()),\n+                                    i.name().stringValue(),\n+                                    MethodTypeDesc.ofDescriptor(i.type().stringValue()),\n+                                    i.bootstrapArgs().toArray(ConstantDesc[]::new)));\n+                        } else {\n+                            cob.with(coe);\n+                        }\n+                    }));\n+                }\n+            } else {\n+                clb.with(cle);\n+            }\n+        });\n+    }\n+\n+    public static CallSite unreflect(MethodHandles.Lookup caller,\n+                                     String methodName,\n+                                     MethodType methodType) throws NoSuchMethodException {\n+        for (Method m : caller.lookupClass().getDeclaredMethods()) {\n+            int firstParam = (m.getModifiers() & Modifier.STATIC) == 0 ? 1 : 0;\n+            if (m.getName().equals(methodName)\n+                    && m.getReturnType() == methodType.returnType()\n+                    && m.getParameterCount() == methodType.parameterCount() - firstParam\n+                    && Arrays.equals(m.getParameterTypes(), 0, m.getParameterCount(),\n+                                     methodType.parameterArray(), firstParam, methodType.parameterCount())) {\n+                return new ConstantCallSite(BytecodeGenerator.generate(caller, Op.ofMethod(m).orElseThrow()));\n+            }\n+        }\n+        throw new NoSuchMethodException(caller.lookupClass().getName() + \".\" + methodName + methodType);\n+    }\n+\n+    public static CallSite metafactory(MethodHandles.Lookup caller,\n+                                       String interfaceMethodName,\n+                                       MethodType factoryType,\n+                                       MethodType interfaceMethodType,\n+                                       MethodHandle implementation,\n+                                       MethodType dynamicMethodType) throws LambdaConversionException {\n+        return ReflectableLambdaMetafactory.metafactory(caller,\n+                                                        interfaceMethodName,\n+                                                        factoryType,\n+                                                        interfaceMethodType,\n+                                                        unreflectLambdaImplementation(caller, interfaceMethodName),\n+                                                        dynamicMethodType);\n+    }\n+\n+    public static CallSite altMetafactory(MethodHandles.Lookup caller,\n+                                          String interfaceMethodName,\n+                                          MethodType factoryType,\n+                                          Object... args) throws LambdaConversionException {\n+        args[1] = unreflectLambdaImplementation(caller, interfaceMethodName);\n+        return ReflectableLambdaMetafactory.altMetafactory(caller,\n+                                                           interfaceMethodName,\n+                                                           factoryType,\n+                                                           args);\n+    }\n+\n+    static MethodHandle unreflectLambdaImplementation(MethodHandles.Lookup caller, String interfaceMethodName)\n+            throws LambdaConversionException {\n+        try {\n+            MethodHandle opHandle = caller.findStatic(caller.lookupClass(),\n+                                                      interfaceMethodName.split(\"=\")[1],\n+                                                      MethodType.methodType(Op.class));\n+            return BytecodeGenerator.generate(caller, unquoteLambda((CoreOp.FuncOp)opHandle.invoke()));\n+        } catch (Throwable t) {\n+            throw new LambdaConversionException(t);\n+        }\n+    }\n+\n+    \/\/ flat QuotedOp and LambdaOp\n+    static CoreOp.FuncOp unquoteLambda(CoreOp.FuncOp funcOp) {\n+        int capturedValues = funcOp.parameters().size();\n+        List<Op> ops = funcOp.body().entryBlock().ops();\n+        JavaOp.LambdaOp lambda = (JavaOp.LambdaOp)((CoreOp.QuotedOp)ops.get(ops.size() - 2)).quotedOp();\n+        return CoreOp.func(funcOp.funcName(), CoreType.functionType(\n+                lambda.body().yieldType(),\n+                Stream.of(funcOp.invokableType().parameterTypes(),\n+                          lambda.invokableType().parameterTypes()).flatMap(List::stream).toList())).body(bb -> {\n+            bb.context().mapBlock(funcOp.body().entryBlock(), bb.entryBlock());\n+            bb.context().mapValues(funcOp.parameters(), bb.parameters().subList(0, capturedValues));\n+            for (int i = 0; i < ops.size() - 2; i++) {\n+                Op o = ops.get(i);\n+                bb.context().mapValue(o.result(), bb.op(o));\n+            }\n+            bb.body(lambda.body(),\n+                    bb.parameters().subList(capturedValues, bb.parameters().size()),\n+                    bb.context(),\n+                    CodeTransformer.COPYING_TRANSFORMER);\n+        });\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ process class files from arguments\n+        var toUnreflect = new ArrayDeque<>(List.of(args));\n+        var done = new HashSet<String>();\n+        while (!toUnreflect.isEmpty()) {\n+            String arg = toUnreflect.pop();\n+            if (!arg.endsWith(\".class\")) arg += \".class\";\n+            if (done.add(arg)) {\n+                System.out.println(\"unreflecting \" + arg);\n+                Path clsFile = Path.of(Unreflect.class.getResource(arg).toURI());\n+                ClassModel clm = ClassFile.of().parse(Files.readAllBytes(clsFile));\n+                \/\/ unreflect all nest members\n+                clm.findAttribute(Attributes.nestMembers())\n+                        .ifPresent(nma -> toUnreflect.addAll(\n+                                nma.nestMembers().stream().map(ClassEntry::asInternalName).toList()));\n+                Files.write(clsFile, transform(clm));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/Unreflect.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestArrayCreation\n- *\/\n-\n-public class TestArrayCreation {\n-    @Reflect\n-    public static String[] f() {\n-        return new String[10];\n-    }\n-\n-    @Test\n-    public void testf() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f(), (String[]) mh.invoke());\n-    }\n-\n-    @Reflect\n-    public static String[][] f2() {\n-        return new String[10][];\n-    }\n-\n-    @Test\n-    public void testf2() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f2\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f2(), (String[][]) mh.invoke());\n-    }\n-\n-    @Reflect\n-    public static String[][] f3() {\n-        return new String[10][10];\n-    }\n-\n-    @Test\n-    public void testf3() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f3\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f3(), (String[][]) mh.invoke());\n-    }\n-\n-    @Reflect\n-    public static String[][] f4() {\n-        return new String[][]{{\"one\", \"two\"}, {\"three\"}};\n-    }\n-\n-    @Test\n-    public void testf4() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f4\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f4(), (String[][]) mh.invoke());\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestArrayCreation.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -44,0 +44,3 @@\n+ * @library ..\/\n+ * @run junit TestBranchCompactor\n+ * @run main Unreflect TestBranchCompactor\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import org.opentest4j.TestSkippedException;\n@@ -58,0 +57,3 @@\n+ * @library ..\/\n+ * @run junit\/othervm -Djdk.invoke.MethodHandle.dumpClassFiles=true TestBytecode\n+ * @run main Unreflect TestBytecode\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestInvokeSuper\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-public class TestInvokeSuper {\n-\n-    interface I {\n-        default String f() { return \"I\"; }\n-    }\n-    static class A {\n-        String f() { return \"A\"; }\n-    }\n-\n-    static class B extends A implements I {\n-        final boolean invokeClass;\n-\n-        public B(boolean invokeClass) {\n-            this.invokeClass = invokeClass;\n-        }\n-\n-        @Reflect\n-        public String f() {\n-            return invokeClass ? super.f() : I.super.f();\n-        }\n-    }\n-\n-    @Test\n-    public void testInvokeSuper() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(B.class, \"f\");\n-        MethodHandle mh = generate(f);\n-\n-        for (boolean invokeClass : new boolean[] {true, false}) {\n-            B b = new B(invokeClass);\n-            Assertions.assertEquals(b.f(), mh.invoke(b));\n-        }\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup().in(B.class), f);\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(Class<?> c, String name) {\n-        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestInvokeSuper.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -27,0 +27,3 @@\n+ * @library ..\/\n+ * @run junit TestNestedCapturingLambda\n+ * @run main Unreflect TestNestedCapturingLambda\n@@ -31,1 +34,0 @@\n-import jdk.incubator.code.CodeTransformer;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNestedCapturingLambda.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+ * @library ..\/\n+ * @run junit TestSlots\n+ * @run main Unreflect TestSlots\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlotOps.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.code.CodeTransformer;\n@@ -41,0 +40,3 @@\n+ * @library ..\/\n+ * @run junit TestSlots\n+ * @run main Unreflect TestSlots\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+ * @library ..\/\n+ * @run junit TestSwitch\n+ * @run main Unreflect TestSwitch\n@@ -136,1 +139,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSwitch.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library ..\/\n@@ -32,1 +33,0 @@\n-import jdk.incubator.code.CodeTransformer;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSynchronizedOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,289 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestTry\n- *\/\n-\n-public class TestTry {\n-\n-    @Reflect\n-    public static void catching(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            consume(e);\n-            c.accept(1);\n-            c.accept(-1);\n-        } catch (IllegalArgumentException e) {\n-            consume(e);\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatching() {\n-        CoreOp.FuncOp f = getFuncOp(\"catching\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTry::catching);\n-\n-        test.accept(i -> {\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new NullPointerException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-            if (i == 1) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalArgumentException();\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalStateException();\n-        });\n-    }\n-\n-    @Reflect\n-    public static void catchThrowable(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            consume(e);\n-            c.accept(1);\n-            c.accept(-1);\n-        } catch (Throwable e) {\n-            consume(e);\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchThrowable() {\n-        CoreOp.FuncOp f = getFuncOp(\"catchThrowable\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTry::catchThrowable);\n-\n-        test.accept(i -> {\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-            if (i == 1) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new RuntimeException();\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalStateException();\n-        });\n-    }\n-\n-\n-    @Reflect\n-    public static void catchNested(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-            try {\n-                c.accept(1);\n-                c.accept(-1);\n-            } catch (IllegalStateException e) {\n-                consume(e);\n-                c.accept(2);\n-                c.accept(-1);\n-            }\n-            c.accept(3);\n-            c.accept(-1);\n-        } catch (IllegalArgumentException e) {\n-            consume(e);\n-            c.accept(4);\n-            c.accept(-1);\n-        }\n-        c.accept(5);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchNested() {\n-        CoreOp.FuncOp f = getFuncOp(\"catchNested\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTry::catchNested);\n-\n-        test.accept(i -> {\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalStateException();\n-            if (i == 2) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalStateException();\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalArgumentException();\n-            if (i == 4) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 5) throw new RuntimeException();\n-        });\n-    }\n-\n-\n-    static void consume(Throwable e) {\n-    }\n-\n-    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n-        return c -> {\n-            List<Integer> actual = new ArrayList<>();\n-            IntConsumer actualC = actual::add;\n-            Throwable actualT = null;\n-            try {\n-                actualR.accept(actualC.andThen(c));\n-            } catch (Interpreter.InterpreterException e) {\n-                throw e;\n-            } catch (Throwable t) {\n-                actualT = t;\n-                if (t instanceof AssertionError) {\n-                    t.printStackTrace();\n-                }\n-            }\n-\n-            List<Integer> expected = new ArrayList<>();\n-            IntConsumer expectedC = expected::add;\n-            Throwable expectedT = null;\n-            try {\n-                expectedR.accept(expectedC.andThen(c));\n-            } catch (Throwable t) {\n-                expectedT = t;\n-            }\n-\n-            Assertions.assertEquals(\n-                    expectedT != null ? expectedT.getClass() : null, actualT != null ? actualT.getClass() : null\n-            );\n-            Assertions.assertEquals(expected, actual);\n-        };\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n-        return c -> {\n-            try {\n-                mh.invoke(c);\n-            } catch (Throwable e) {\n-                throw erase(e);\n-            }\n-        };\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <E extends Throwable> E erase(Throwable e) throws E {\n-        return (E) e;\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestTry.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":0,"deletions":289,"binary":false,"changes":289,"status":"deleted"},{"patch":"@@ -1,257 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestTryFinally\n- *\/\n-\n-public class TestTryFinally {\n-\n-    @Reflect\n-    public static void tryCatchFinally(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchFinally() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryCatchFinally\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::tryCatchFinally\n-        );\n-\n-        test(test);\n-    }\n-\n-\n-    @Reflect\n-    public static void tryReturn(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-            return;\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testTryReturn() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryReturn\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::tryReturn\n-                );\n-\n-        test(test);\n-    }\n-\n-\n-    @Reflect\n-    public static void catchThrow(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-            throw e;\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchThrow() {\n-        CoreOp.FuncOp f = getFuncOp(\"catchThrow\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::catchThrow\n-        );\n-\n-        test(test);\n-    }\n-\n-\n-    @Reflect\n-    public static void finallyReturn(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-            return;\n-        }\n-    }\n-\n-    @Test\n-    public void testFinallyReturn() {\n-        CoreOp.FuncOp f = getFuncOp(\"finallyReturn\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::finallyReturn\n-        );\n-\n-        test(test);\n-    }\n-\n-\n-    static void test(Consumer<IntConsumer> test) {\n-        test.accept(i -> {});\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-            if (i == 1) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new RuntimeException();\n-        });\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n-        return c -> {\n-            try {\n-                mh.invoke(c);\n-            } catch (Throwable e) {\n-                throw erase(e);\n-            }\n-        };\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <E extends Throwable> E erase(Throwable e) throws E {\n-        return (E) e;\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestTryFinally.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-\n-    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n-        return c -> {\n-            List<Integer> actual = new ArrayList<>();\n-            IntConsumer actualC = actual::add;\n-            Throwable actualT = null;\n-            try {\n-                actualR.accept(actualC.andThen(c));\n-            } catch (Interpreter.InterpreterException e) {\n-                throw e;\n-            } catch (Throwable t) {\n-                actualT = t;\n-                if (t instanceof AssertionError) {\n-                    t.printStackTrace();\n-                }\n-            }\n-\n-            List<Integer> expected = new ArrayList<>();\n-            IntConsumer expectedC = expected::add;\n-            Throwable expectedT = null;\n-            try {\n-                expectedR.accept(expectedC.andThen(c));\n-            } catch (Throwable t) {\n-                expectedT = t;\n-            }\n-\n-            Assertions.assertEquals(\n-                    expectedT != null ? expectedT.getClass() : null, actualT != null ? actualT.getClass() : null\n-            );\n-            Assertions.assertEquals(expected, actual);\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":0,"deletions":257,"binary":false,"changes":257,"status":"deleted"},{"patch":"@@ -1,256 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestTryFinallyNested\n- *\/\n-\n-public class TestTryFinallyNested {\n-    @Reflect\n-    public static void tryCatchFinally(IntConsumer c, int i) {\n-        try {\n-            try {\n-                if (i == 0) {\n-                    return;\n-                }\n-                c.accept(0);\n-            } catch (IllegalStateException e) {\n-                if (i == 1) {\n-                    return;\n-                }\n-                c.accept(1);\n-            } finally {\n-                if (i == 2) {\n-                    return;\n-                }\n-                c.accept(2);\n-            }\n-            if (i == 3) {\n-                return;\n-            }\n-            c.accept(3);\n-        } catch (IllegalStateException e) {\n-            if (i == 4) {\n-                return;\n-            }\n-            c.accept(4);\n-        } finally {\n-            if (i == 5) {\n-                return;\n-            }\n-            c.accept(5);\n-        }\n-        c.accept(6);\n-    }\n-\n-    @Test\n-    public void testCatchFinally() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryCatchFinally\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        for (int ra = -1; ra < 6; ra++) {\n-            int fra = ra;\n-\n-            Consumer<IntConsumer> test = testConsumer(\n-                    c -> invoke(mh, c, fra),\n-                    c -> tryCatchFinally(c, fra)\n-            );\n-\n-            test.accept(i -> {});\n-            for (int ea = 0; ea < 6; ea++) {\n-                int fea = ea;\n-                test.accept(i -> {\n-                    if (i == fea) throw new IllegalStateException();\n-                });\n-                test.accept(i -> {\n-                    if (i == fea) throw new RuntimeException();\n-                });\n-            }\n-        }\n-    }\n-\n-    @Reflect\n-    public static void tryForLoop(IntConsumer c) {\n-        for (int i = 0; i < 8; i++) {\n-            c.accept(0);\n-            try {\n-                if (i == 4) {\n-                    continue;\n-                } else if (i == 5) {\n-                    break;\n-                }\n-                c.accept(1);\n-            } finally {\n-                c.accept(2);\n-            }\n-            c.accept(3);\n-        }\n-        c.accept(4);\n-    }\n-\n-    @Test\n-    public void testTryForLoop() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryForLoop\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinallyNested::tryForLoop\n-        );\n-\n-        test.accept(i -> { });\n-    }\n-\n-\n-    @Reflect\n-    public static void tryLabeledForLoop(IntConsumer c) {\n-        a: for (int i = 0; i < 8; i++) {\n-            c.accept(0);\n-            b: {\n-                try {\n-                    if (i == 4) {\n-                        continue a;\n-                    } else if (i == 5) {\n-                        break b;\n-                    } else if (i == 6) {\n-                        break a;\n-                    }\n-                    c.accept(1);\n-                } finally {\n-                    c.accept(2);\n-                }\n-                c.accept(3);\n-            }\n-            c.accept(4);\n-        }\n-        c.accept(5);\n-    }\n-\n-    @Test\n-    public void testTryLabeledForLoop() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryLabeledForLoop\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinallyNested::tryLabeledForLoop\n-        );\n-\n-        test.accept(i -> { });\n-    }\n-\n-\n-    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n-        return c -> {\n-            List<Integer> actual = new ArrayList<>();\n-            IntConsumer actualC = actual::add;\n-            Throwable actualT = null;\n-            try {\n-                actualR.accept(actualC.andThen(c));\n-            } catch (Interpreter.InterpreterException e) {\n-                throw e;\n-            } catch (Throwable t) {\n-                actualT = t;\n-                if (t instanceof AssertionError) {\n-                    t.printStackTrace();\n-                }\n-            }\n-\n-            List<Integer> expected = new ArrayList<>();\n-            IntConsumer expectedC = expected::add;\n-            Throwable expectedT = null;\n-            try {\n-                expectedR.accept(expectedC.andThen(c));\n-            } catch (Throwable t) {\n-                expectedT = t;\n-            }\n-\n-            Assertions.assertEquals(\n-                    expectedT != null ? expectedT.getClass() : null, actualT != null ? actualT.getClass() : null\n-            );\n-            Assertions.assertEquals(expected, actual);\n-        };\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n-        return c -> {\n-            try {\n-                mh.invoke(c);\n-            } catch (Throwable e) {\n-                throw erase(e);\n-            }\n-        };\n-    }\n-\n-    static void invoke(MethodHandle mh, IntConsumer c, int i) {\n-        try {\n-            mh.invoke(c, i);\n-        } catch (Throwable e) {\n-            throw erase(e);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <E extends Throwable> E erase(Throwable e) throws E {\n-        return (E) e;\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestTryFinallyNested.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":0,"deletions":256,"binary":false,"changes":256,"status":"deleted"},{"patch":"@@ -23,0 +23,3 @@\n+ * @library ..\/\n+ * @run junit TestVarArg\n+ * @run main Unreflect TestVarArg\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+ * @library ..\/..\/\n+ * @run junit TestLiftCustomBytecode\n+ * @run main Unreflect TestLiftCustomBytecode\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestLiftCustomBytecode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+ * @library ..\/..\/\n+ * @run junit TestLiftExample\n+ * @run main Unreflect TestLiftExample\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestLiftExample.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+ * @library ..\/..\/\n+ * @run junit TestSmallCorpus\n+ * @run main Unreflect TestSmallCorpus\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestSmallCorpus.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}