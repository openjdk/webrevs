{"files":[{"patch":"@@ -25,2 +25,0 @@\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.ClassElement;\n@@ -29,1 +27,0 @@\n-import java.lang.classfile.ClassTransform;\n@@ -35,1 +32,1 @@\n-import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.ConstantDescs;\n@@ -37,1 +34,0 @@\n-import java.lang.constant.MethodHandleDesc;\n@@ -57,3 +53,1 @@\n-\n-    \/\/ lazy initialized\n-    static MethodModel UNREFLECT_BSM;\n+    static final ClassDesc CD_Unreflect = Unreflect.class.describeConstable().get();\n@@ -69,33 +63,19 @@\n-        return ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(clm, new ClassTransform() {\n-            boolean injectBSM = false;\n-\n-            @Override\n-            public void accept(ClassBuilder clb, ClassElement cle) {\n-                if (cle instanceof MethodModel mm) {\n-                    if (isReflective(mm)) {\n-                        clb.transformMethod(mm, MethodTransform.dropping(me -> me instanceof CodeModel)\n-                                .andThen(MethodTransform.endHandler(mb -> mb.withCode(cob -> {\n-                                    System.out.print('.');\n-                                    injectBSM = true;\n-                                    MethodTypeDesc mts = mm.methodTypeSymbol();\n-                                    boolean hasReceiver = !mm.flags().has(AccessFlag.STATIC);\n-                                    if (hasReceiver) {\n-                                        cob.loadLocal(TypeKind.REFERENCE, cob.receiverSlot());\n-                                    }\n-                                    for (int i = 0; i < mts.parameterCount(); i++) {\n-                                        cob.loadLocal(TypeKind.from(mts.parameterType(i)), cob.parameterSlot(i));\n-                                    }\n-                                    cob.invokedynamic(DynamicCallSiteDesc.of(\n-                                                    MethodHandleDesc.ofMethod(clm.flags().has(AccessFlag.INTERFACE)\n-                                                            ? DirectMethodHandleDesc.Kind.INTERFACE_STATIC\n-                                                            : DirectMethodHandleDesc.Kind.STATIC,\n-                                                    clm.thisClass().asSymbol(),\n-                                                    UNREFLECT_BSM.methodName().stringValue(),\n-                                                    UNREFLECT_BSM.methodTypeSymbol()),\n-                                            mm.methodName().stringValue(),\n-                                            hasReceiver ? mts.insertParameterTypes(0, clm.thisClass().asSymbol()): mts));\n-                                    cob.return_(TypeKind.from(mts.returnType()));\n-                                }))));\n-                    } else if (!mm.methodName().equals(UNREFLECT_BSM.methodName())) { \/\/ drop unreflect BSM if already present\n-                        clb.with(cle);\n-                    }\n+        return ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(clm, (clb, cle) -> {\n+                if (cle instanceof MethodModel mm && isReflective(mm)) {\n+                    clb.transformMethod(mm, MethodTransform.dropping(me -> me instanceof CodeModel)\n+                            .andThen(MethodTransform.endHandler(mb -> mb.withCode(cob -> {\n+                                System.out.print('.');\n+                                MethodTypeDesc mts = mm.methodTypeSymbol();\n+                                boolean hasReceiver = !mm.flags().has(AccessFlag.STATIC);\n+                                if (hasReceiver) {\n+                                    cob.loadLocal(TypeKind.REFERENCE, cob.receiverSlot());\n+                                }\n+                                for (int i = 0; i < mts.parameterCount(); i++) {\n+                                    cob.loadLocal(TypeKind.from(mts.parameterType(i)), cob.parameterSlot(i));\n+                                }\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        ConstantDescs.ofCallsiteBootstrap(CD_Unreflect, \"unreflect\", ConstantDescs.CD_CallSite),\n+                                        mm.methodName().stringValue(),\n+                                        hasReceiver ? mts.insertParameterTypes(0, clm.thisClass().asSymbol()): mts));\n+                                cob.return_(TypeKind.from(mts.returnType()));\n+                            }))));\n@@ -105,10 +85,1 @@\n-            }\n-\n-            @Override\n-            public void atEnd(ClassBuilder clb) {\n-                if (injectBSM) {\n-                    System.out.println();\n-                    clb.with(UNREFLECT_BSM);\n-                }\n-            }\n-        });\n+            });\n@@ -117,2 +88,1 @@\n-    \/\/ BSM template\n-    private static CallSite $unreflectBSM(MethodHandles.Lookup caller, String methodName, MethodType methodType)\n+    public static CallSite unreflect(MethodHandles.Lookup caller, String methodName, MethodType methodType)\n@@ -134,4 +104,0 @@\n-        \/\/ initialize unreflect method models\n-        UNREFLECT_BSM = ClassFile.of().parse(Unreflect.class.getResourceAsStream(\"Unreflect.class\").readAllBytes())\n-                .methods().stream().filter(mm -> mm.methodName().equalsString(\"$unreflectBSM\")).findFirst().orElseThrow();\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/Unreflect.java","additions":23,"deletions":57,"binary":false,"changes":80,"status":"modified"}]}