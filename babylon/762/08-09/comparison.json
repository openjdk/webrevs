{"files":[{"patch":"@@ -87,0 +87,14 @@\n+    @Reflect\n+    public static String[][] f4() {\n+        return new String[][]{{\"one\", \"two\"}, {\"three\"}};\n+    }\n+\n+    @Test\n+    public void testf4() {\n+        CoreOp.FuncOp f = getFuncOp(\"f4\");\n+\n+        System.out.println(f.toText());\n+\n+        Assertions.assertArrayEquals(f4(), (Object[]) Interpreter.invoke(MethodHandles.lookup(), f));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayCreation.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @library ..\/\n- * @run junit TestArrayCreation\n- * @run main Unreflect TestArrayCreation\n- * @run junit TestArrayCreation\n- *\/\n-\n-public class TestArrayCreation {\n-    @Reflect\n-    public static String[] f() {\n-        return new String[10];\n-    }\n-\n-    @Test\n-    public void testf() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f(), (String[]) mh.invoke());\n-    }\n-\n-    @Reflect\n-    public static String[][] f2() {\n-        return new String[10][];\n-    }\n-\n-    @Test\n-    public void testf2() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f2\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f2(), (String[][]) mh.invoke());\n-    }\n-\n-    @Reflect\n-    public static String[][] f3() {\n-        return new String[10][10];\n-    }\n-\n-    @Test\n-    public void testf3() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f3\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f3(), (String[][]) mh.invoke());\n-    }\n-\n-    @Reflect\n-    public static String[][] f4() {\n-        return new String[][]{{\"one\", \"two\"}, {\"three\"}};\n-    }\n-\n-    @Test\n-    public void testf4() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(\"f4\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assertions.assertArrayEquals(f4(), (String[][]) mh.invoke());\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestArrayCreation.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -34,1 +34,0 @@\n-import org.opentest4j.TestSkippedException;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @library ..\/\n- * @run junit TestInvokeSuper\n- * @run main Unreflect TestInvokeSuper\n- * @run junit TestInvokeSuper\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-public class TestInvokeSuper {\n-\n-    interface I {\n-        default String f() { return \"I\"; }\n-    }\n-    static class A {\n-        String f() { return \"A\"; }\n-    }\n-\n-    static class B extends A implements I {\n-        final boolean invokeClass;\n-\n-        public B(boolean invokeClass) {\n-            this.invokeClass = invokeClass;\n-        }\n-\n-        @Reflect\n-        public String f() {\n-            return invokeClass ? super.f() : I.super.f();\n-        }\n-    }\n-\n-    @Test\n-    public void testInvokeSuper() throws Throwable {\n-        CoreOp.FuncOp f = getFuncOp(B.class, \"f\");\n-        MethodHandle mh = generate(f);\n-\n-        for (boolean invokeClass : new boolean[] {true, false}) {\n-            B b = new B(invokeClass);\n-            Assertions.assertEquals(b.f(), mh.invoke(b));\n-        }\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup().in(B.class), f);\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(Class<?> c, String name) {\n-        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestInvokeSuper.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -24,1 +24,0 @@\n- * @library ..\/\n@@ -27,2 +26,0 @@\n- * @run main Unreflect TestIsCaseConstantSwitch\n- * @run junit TestIsCaseConstantSwitch\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestIsCaseConstantSwitch.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.code.CodeTransformer;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNestedCapturingLambda.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.code.CodeTransformer;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSwitch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n- * @run main Unreflect TestSynchronizedOp\n- * @run junit TestSynchronizedOp\n@@ -35,1 +33,0 @@\n-import jdk.incubator.code.CodeTransformer;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSynchronizedOp.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,292 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @library ..\/\n- * @run junit TestTry\n- * @run main Unreflect TestTry\n- * @run junit TestTry\n- *\/\n-\n-public class TestTry {\n-\n-    @Reflect\n-    public static void catching(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            consume(e);\n-            c.accept(1);\n-            c.accept(-1);\n-        } catch (IllegalArgumentException e) {\n-            consume(e);\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatching() {\n-        CoreOp.FuncOp f = getFuncOp(\"catching\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTry::catching);\n-\n-        test.accept(i -> {\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new NullPointerException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-            if (i == 1) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalArgumentException();\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalStateException();\n-        });\n-    }\n-\n-    @Reflect\n-    public static void catchThrowable(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            consume(e);\n-            c.accept(1);\n-            c.accept(-1);\n-        } catch (Throwable e) {\n-            consume(e);\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchThrowable() {\n-        CoreOp.FuncOp f = getFuncOp(\"catchThrowable\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTry::catchThrowable);\n-\n-        test.accept(i -> {\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-            if (i == 1) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new RuntimeException();\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalStateException();\n-        });\n-    }\n-\n-\n-    @Reflect\n-    public static void catchNested(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-            try {\n-                c.accept(1);\n-                c.accept(-1);\n-            } catch (IllegalStateException e) {\n-                consume(e);\n-                c.accept(2);\n-                c.accept(-1);\n-            }\n-            c.accept(3);\n-            c.accept(-1);\n-        } catch (IllegalArgumentException e) {\n-            consume(e);\n-            c.accept(4);\n-            c.accept(-1);\n-        }\n-        c.accept(5);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchNested() {\n-        CoreOp.FuncOp f = getFuncOp(\"catchNested\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTry::catchNested);\n-\n-        test.accept(i -> {\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalStateException();\n-            if (i == 2) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 1) throw new IllegalStateException();\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalArgumentException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new IllegalArgumentException();\n-            if (i == 4) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 5) throw new RuntimeException();\n-        });\n-    }\n-\n-\n-    static void consume(Throwable e) {\n-    }\n-\n-    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n-        return c -> {\n-            List<Integer> actual = new ArrayList<>();\n-            IntConsumer actualC = actual::add;\n-            Throwable actualT = null;\n-            try {\n-                actualR.accept(actualC.andThen(c));\n-            } catch (Interpreter.InterpreterException e) {\n-                throw e;\n-            } catch (Throwable t) {\n-                actualT = t;\n-                if (t instanceof AssertionError) {\n-                    t.printStackTrace();\n-                }\n-            }\n-\n-            List<Integer> expected = new ArrayList<>();\n-            IntConsumer expectedC = expected::add;\n-            Throwable expectedT = null;\n-            try {\n-                expectedR.accept(expectedC.andThen(c));\n-            } catch (Throwable t) {\n-                expectedT = t;\n-            }\n-\n-            Assertions.assertEquals(\n-                    expectedT != null ? expectedT.getClass() : null, actualT != null ? actualT.getClass() : null\n-            );\n-            Assertions.assertEquals(expected, actual);\n-        };\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n-        return c -> {\n-            try {\n-                mh.invoke(c);\n-            } catch (Throwable e) {\n-                throw erase(e);\n-            }\n-        };\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <E extends Throwable> E erase(Throwable e) throws E {\n-        return (E) e;\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestTry.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":0,"deletions":292,"binary":false,"changes":292,"status":"deleted"},{"patch":"@@ -1,260 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @library ..\/\n- * @run junit TestTryFinally\n- * @run main Unreflect TestTryFinally\n- * @run junit TestTryFinally\n- *\/\n-\n-public class TestTryFinally {\n-\n-    @Reflect\n-    public static void tryCatchFinally(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchFinally() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryCatchFinally\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::tryCatchFinally\n-        );\n-\n-        test(test);\n-    }\n-\n-\n-    @Reflect\n-    public static void tryReturn(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-            return;\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testTryReturn() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryReturn\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::tryReturn\n-                );\n-\n-        test(test);\n-    }\n-\n-\n-    @Reflect\n-    public static void catchThrow(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-            throw e;\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-        }\n-        c.accept(3);\n-        c.accept(-1);\n-    }\n-\n-    @Test\n-    public void testCatchThrow() {\n-        CoreOp.FuncOp f = getFuncOp(\"catchThrow\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::catchThrow\n-        );\n-\n-        test(test);\n-    }\n-\n-\n-    @Reflect\n-    public static void finallyReturn(IntConsumer c) {\n-        try {\n-            c.accept(0);\n-            c.accept(-1);\n-        } catch (IllegalStateException e) {\n-            c.accept(1);\n-            c.accept(-1);\n-        } finally {\n-            c.accept(2);\n-            c.accept(-1);\n-            return;\n-        }\n-    }\n-\n-    @Test\n-    public void testFinallyReturn() {\n-        CoreOp.FuncOp f = getFuncOp(\"finallyReturn\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinally::finallyReturn\n-        );\n-\n-        test(test);\n-    }\n-\n-\n-    static void test(Consumer<IntConsumer> test) {\n-        test.accept(i -> {});\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 2) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 0) throw new IllegalStateException();\n-            if (i == 1) throw new RuntimeException();\n-        });\n-        test.accept(i -> {\n-            if (i == 3) throw new RuntimeException();\n-        });\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n-        return c -> {\n-            try {\n-                mh.invoke(c);\n-            } catch (Throwable e) {\n-                throw erase(e);\n-            }\n-        };\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <E extends Throwable> E erase(Throwable e) throws E {\n-        return (E) e;\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestTryFinally.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-\n-    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n-        return c -> {\n-            List<Integer> actual = new ArrayList<>();\n-            IntConsumer actualC = actual::add;\n-            Throwable actualT = null;\n-            try {\n-                actualR.accept(actualC.andThen(c));\n-            } catch (Interpreter.InterpreterException e) {\n-                throw e;\n-            } catch (Throwable t) {\n-                actualT = t;\n-                if (t instanceof AssertionError) {\n-                    t.printStackTrace();\n-                }\n-            }\n-\n-            List<Integer> expected = new ArrayList<>();\n-            IntConsumer expectedC = expected::add;\n-            Throwable expectedT = null;\n-            try {\n-                expectedR.accept(expectedC.andThen(c));\n-            } catch (Throwable t) {\n-                expectedT = t;\n-            }\n-\n-            Assertions.assertEquals(\n-                    expectedT != null ? expectedT.getClass() : null, actualT != null ? actualT.getClass() : null\n-            );\n-            Assertions.assertEquals(expected, actual);\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":0,"deletions":260,"binary":false,"changes":260,"status":"deleted"},{"patch":"@@ -1,259 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @library ..\/\n- * @run junit TestTryFinallyNested\n- * @run main Unreflect TestTryFinallyNested\n- * @run junit TestTryFinallyNested\n- *\/\n-\n-public class TestTryFinallyNested {\n-    @Reflect\n-    public static void tryCatchFinally(IntConsumer c, int i) {\n-        try {\n-            try {\n-                if (i == 0) {\n-                    return;\n-                }\n-                c.accept(0);\n-            } catch (IllegalStateException e) {\n-                if (i == 1) {\n-                    return;\n-                }\n-                c.accept(1);\n-            } finally {\n-                if (i == 2) {\n-                    return;\n-                }\n-                c.accept(2);\n-            }\n-            if (i == 3) {\n-                return;\n-            }\n-            c.accept(3);\n-        } catch (IllegalStateException e) {\n-            if (i == 4) {\n-                return;\n-            }\n-            c.accept(4);\n-        } finally {\n-            if (i == 5) {\n-                return;\n-            }\n-            c.accept(5);\n-        }\n-        c.accept(6);\n-    }\n-\n-    @Test\n-    public void testCatchFinally() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryCatchFinally\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        for (int ra = -1; ra < 6; ra++) {\n-            int fra = ra;\n-\n-            Consumer<IntConsumer> test = testConsumer(\n-                    c -> invoke(mh, c, fra),\n-                    c -> tryCatchFinally(c, fra)\n-            );\n-\n-            test.accept(i -> {});\n-            for (int ea = 0; ea < 6; ea++) {\n-                int fea = ea;\n-                test.accept(i -> {\n-                    if (i == fea) throw new IllegalStateException();\n-                });\n-                test.accept(i -> {\n-                    if (i == fea) throw new RuntimeException();\n-                });\n-            }\n-        }\n-    }\n-\n-    @Reflect\n-    public static void tryForLoop(IntConsumer c) {\n-        for (int i = 0; i < 8; i++) {\n-            c.accept(0);\n-            try {\n-                if (i == 4) {\n-                    continue;\n-                } else if (i == 5) {\n-                    break;\n-                }\n-                c.accept(1);\n-            } finally {\n-                c.accept(2);\n-            }\n-            c.accept(3);\n-        }\n-        c.accept(4);\n-    }\n-\n-    @Test\n-    public void testTryForLoop() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryForLoop\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinallyNested::tryForLoop\n-        );\n-\n-        test.accept(i -> { });\n-    }\n-\n-\n-    @Reflect\n-    public static void tryLabeledForLoop(IntConsumer c) {\n-        a: for (int i = 0; i < 8; i++) {\n-            c.accept(0);\n-            b: {\n-                try {\n-                    if (i == 4) {\n-                        continue a;\n-                    } else if (i == 5) {\n-                        break b;\n-                    } else if (i == 6) {\n-                        break a;\n-                    }\n-                    c.accept(1);\n-                } finally {\n-                    c.accept(2);\n-                }\n-                c.accept(3);\n-            }\n-            c.accept(4);\n-        }\n-        c.accept(5);\n-    }\n-\n-    @Test\n-    public void testTryLabeledForLoop() {\n-        CoreOp.FuncOp f = getFuncOp(\"tryLabeledForLoop\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Consumer<IntConsumer> test = testConsumer(\n-                asConsumer(mh),\n-                TestTryFinallyNested::tryLabeledForLoop\n-        );\n-\n-        test.accept(i -> { });\n-    }\n-\n-\n-    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n-        return c -> {\n-            List<Integer> actual = new ArrayList<>();\n-            IntConsumer actualC = actual::add;\n-            Throwable actualT = null;\n-            try {\n-                actualR.accept(actualC.andThen(c));\n-            } catch (Interpreter.InterpreterException e) {\n-                throw e;\n-            } catch (Throwable t) {\n-                actualT = t;\n-                if (t instanceof AssertionError) {\n-                    t.printStackTrace();\n-                }\n-            }\n-\n-            List<Integer> expected = new ArrayList<>();\n-            IntConsumer expectedC = expected::add;\n-            Throwable expectedT = null;\n-            try {\n-                expectedR.accept(expectedC.andThen(c));\n-            } catch (Throwable t) {\n-                expectedT = t;\n-            }\n-\n-            Assertions.assertEquals(\n-                    expectedT != null ? expectedT.getClass() : null, actualT != null ? actualT.getClass() : null\n-            );\n-            Assertions.assertEquals(expected, actual);\n-        };\n-    }\n-\n-    static MethodHandle generate(CoreOp.FuncOp f) {\n-        System.out.println(f.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n-    }\n-\n-    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n-        return c -> {\n-            try {\n-                mh.invoke(c);\n-            } catch (Throwable e) {\n-                throw erase(e);\n-            }\n-        };\n-    }\n-\n-    static void invoke(MethodHandle mh, IntConsumer c, int i) {\n-        try {\n-            mh.invoke(c, i);\n-        } catch (Throwable e) {\n-            throw erase(e);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <E extends Throwable> E erase(Throwable e) throws E {\n-        return (E) e;\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestTryFinallyNested.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":0,"deletions":259,"binary":false,"changes":259,"status":"deleted"}]}