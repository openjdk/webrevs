{"files":[{"patch":"@@ -28,2 +28,0 @@\n- * @run main Unreflect CoreBinaryOpsTest\n- * @run junit CoreBinaryOpsTest\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/CoreBinaryOpsTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.classfile.instruction.InvokeDynamicInstruction;\n@@ -32,0 +33,1 @@\n+import java.lang.constant.ConstantDesc;\n@@ -33,0 +35,1 @@\n+import java.lang.constant.DirectMethodHandleDesc;\n@@ -34,0 +37,1 @@\n+import java.lang.constant.MethodHandleDesc;\n@@ -37,0 +41,2 @@\n+import java.lang.invoke.LambdaConversionException;\n+import java.lang.invoke.MethodHandle;\n@@ -44,1 +50,3 @@\n-import java.util.Arrays;\n+import java.util.*;\n+import java.util.stream.Stream;\n+import jdk.incubator.code.CodeTransformer;\n@@ -49,0 +57,4 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.runtime.ReflectableLambdaMetafactory;\n@@ -54,0 +66,1 @@\n+    static final ClassDesc CD_ReflectableLambdaMetafactory = ReflectableLambdaMetafactory.class.describeConstable().get();\n@@ -64,1 +77,2 @@\n-                if (cle instanceof MethodModel mm && isReflective(mm)) {\n+            if (cle instanceof MethodModel mm) {\n+                if (isReflective(mm)) {\n@@ -70,1 +84,1 @@\n-                                    cob.loadLocal(TypeKind.REFERENCE, cob.receiverSlot());\n+                                    cob.aload(cob.receiverSlot());\n@@ -78,1 +92,1 @@\n-                                        hasReceiver ? mts.insertParameterTypes(0, clm.thisClass().asSymbol()): mts));\n+                                        hasReceiver ? mts.insertParameterTypes(0, clm.thisClass().asSymbol()) : mts));\n@@ -82,1 +96,17 @@\n-                    clb.with(cle);\n+                    clb.transformMethod(mm, MethodTransform.transformingCode((cob, coe) -> {\n+                        DirectMethodHandleDesc bsm;\n+                        if (coe instanceof InvokeDynamicInstruction i\n+                                && (bsm = i.bootstrapMethod()).owner().equals(CD_ReflectableLambdaMetafactory)) {\n+                            \/\/ redirect metafactory and altMetafactory\n+                            cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                    MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                              CD_Unreflect,\n+                                                              bsm.methodName(),\n+                                                              bsm.invocationType()),\n+                                    i.name().stringValue(),\n+                                    MethodTypeDesc.ofDescriptor(i.type().stringValue()),\n+                                    i.bootstrapArgs().toArray(ConstantDesc[]::new)));\n+                        } else {\n+                            cob.with(coe);\n+                        }\n+                    }));\n@@ -84,1 +114,4 @@\n-            });\n+            } else {\n+                clb.with(cle);\n+            }\n+        });\n@@ -87,2 +120,3 @@\n-    public static CallSite unreflect(MethodHandles.Lookup caller, String methodName, MethodType methodType)\n-            throws NoSuchMethodException {\n+    public static CallSite unreflect(MethodHandles.Lookup caller,\n+                                     String methodName,\n+                                     MethodType methodType) throws NoSuchMethodException {\n@@ -102,0 +136,59 @@\n+    public static CallSite metafactory(MethodHandles.Lookup caller,\n+                                       String interfaceMethodName,\n+                                       MethodType factoryType,\n+                                       MethodType interfaceMethodType,\n+                                       MethodHandle implementation,\n+                                       MethodType dynamicMethodType) throws LambdaConversionException {\n+        return ReflectableLambdaMetafactory.metafactory(caller,\n+                                                        interfaceMethodName,\n+                                                        factoryType,\n+                                                        interfaceMethodType,\n+                                                        unreflectImplementation(caller, interfaceMethodName),\n+                                                        dynamicMethodType);\n+    }\n+\n+    public static CallSite altMetafactory(MethodHandles.Lookup caller,\n+                                          String interfaceMethodName,\n+                                          MethodType factoryType,\n+                                          Object... args) throws LambdaConversionException {\n+        args[1] = unreflectImplementation(caller, interfaceMethodName);\n+        return ReflectableLambdaMetafactory.altMetafactory(caller,\n+                                                           interfaceMethodName,\n+                                                           factoryType,\n+                                                           args);\n+    }\n+\n+    static MethodHandle unreflectImplementation(MethodHandles.Lookup caller, String interfaceMethodName)\n+            throws LambdaConversionException {\n+        try {\n+            MethodHandle opHandle = caller.findStatic(caller.lookupClass(),\n+                                                      interfaceMethodName.split(\"=\")[1],\n+                                                      MethodType.methodType(Op.class));\n+            return BytecodeGenerator.generate(caller, unquote((CoreOp.FuncOp)opHandle.invoke()));\n+        } catch (Throwable t) {\n+            throw new LambdaConversionException(t);\n+        }\n+    }\n+\n+    \/\/ flat QuotedOp and LambdaOp\n+    static CoreOp.FuncOp unquote(CoreOp.FuncOp funcOp) {\n+        int capturedValues = funcOp.parameters().size();\n+        List<Op> ops = funcOp.body().entryBlock().ops();\n+        JavaOp.LambdaOp lambda = (JavaOp.LambdaOp)((CoreOp.QuotedOp)ops.get(ops.size() - 2)).quotedOp();\n+        return CoreOp.func(funcOp.funcName(), CoreType.functionType(\n+                lambda.body().yieldType(),\n+                Stream.of(funcOp.invokableType().parameterTypes(),\n+                          lambda.invokableType().parameterTypes()).flatMap(List::stream).toList())).body(bb -> {\n+            bb.context().mapBlock(funcOp.body().entryBlock(), bb.entryBlock());\n+            bb.context().mapValues(funcOp.parameters(), bb.parameters().subList(0, capturedValues));\n+            for (int i = 0; i < ops.size() - 2; i++) {\n+                Op o = ops.get(i);\n+                bb.context().mapValue(o.result(), bb.op(o));\n+            }\n+            bb.body(lambda.body(),\n+                    bb.parameters().subList(capturedValues, bb.parameters().size()),\n+                    bb.context(),\n+                    CodeTransformer.COPYING_TRANSFORMER);\n+        });\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/Unreflect.java","additions":101,"deletions":8,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -45,3 +45,0 @@\n- * @library ..\/\n- * @run junit TestForwardAutoDiff\n- * @run main Unreflect TestForwardAutoDiff\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/TestForwardAutoDiff.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+ * @library ..\/\n+ * @run junit\/othervm -Djdk.invoke.MethodHandle.dumpClassFiles=true TestBytecode\n+ * @run main Unreflect TestBytecode\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+ * @library ..\/\n+ * @run junit\/othervm -ea TestAssert\n+ * @run main Unreflect TestAssert\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/interpreter\/TestAssert.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}