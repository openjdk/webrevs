{"files":[{"patch":"@@ -593,1 +593,1 @@\n-                                    ? List.of(invokableOp.funcDescriptor().returnType())\n+                                    ? List.of(invokableOp.invokableType().returnType())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Block.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.type.FunctionType;\n@@ -41,5 +41,5 @@\n- * A body has a descriptor whose return type is the body's return type and whose parameter types are the entry block's\n- * parameters types, in order.\n- * The descriptor describes the sequence of input parameters types for arguments that are passed to the\n- * body when control flow is passed it, and describes the return type of values that are returned when body passes\n- * control back to the operation.\n+ * A body has a function type whose return type is the body's yield type and whose parameter types are the entry\n+ * block's parameters types, in order.\n+ * The function type describes the sequence of input parameters types for arguments that are passed to the\n+ * body when control flow is passed to it, and describes the return type of values that are returned when body passes\n+ * control back to its parent operation.\n@@ -82,2 +82,2 @@\n-     * Returns the descriptor of this body.\n-     * <p>The descriptor is composed of the body's entry block parameter types and\n+     * Returns the body's function type.\n+     * <p>The function type is composed of the body's entry block parameter types and\n@@ -86,1 +86,1 @@\n-     * @return the descriptor of this body.\n+     * @return the body type.\n@@ -88,1 +88,1 @@\n-    public MethodTypeDesc descriptor() {\n+    public FunctionType bodyType() {\n@@ -90,1 +90,1 @@\n-        return MethodTypeDesc.methodType(yieldType, entryBlock.parameterTypes());\n+        return FunctionType.functionType(yieldType, entryBlock.parameterTypes());\n@@ -290,1 +290,1 @@\n-         * @param desc         the body descriptor\n+         * @param bodyType     the body's function type\n@@ -293,1 +293,1 @@\n-         * @see #of(Builder, MethodTypeDesc, CopyContext, OpTransformer)\n+         * @see #of(Builder, FunctionType, CopyContext, OpTransformer)\n@@ -295,1 +295,1 @@\n-        public static Builder of(Builder ancestorBody, MethodTypeDesc desc) {\n+        public static Builder of(Builder ancestorBody, FunctionType bodyType) {\n@@ -297,1 +297,1 @@\n-            return of(ancestorBody, desc, CopyContext.create(), OpTransformer.COPYING_TRANSFORMER);\n+            return of(ancestorBody, bodyType, CopyContext.create(), OpTransformer.COPYING_TRANSFORMER);\n@@ -304,1 +304,1 @@\n-         * @param desc         the body descriptor\n+         * @param bodyType     the body's function type\n@@ -308,1 +308,1 @@\n-         * @see #of(Builder, MethodTypeDesc, CopyContext, OpTransformer)\n+         * @see #of(Builder, FunctionType, CopyContext, OpTransformer)\n@@ -310,2 +310,2 @@\n-        public static Builder of(Builder ancestorBody, MethodTypeDesc desc, CopyContext cc) {\n-            return of(ancestorBody, desc, cc, OpTransformer.COPYING_TRANSFORMER);\n+        public static Builder of(Builder ancestorBody, FunctionType bodyType, CopyContext cc) {\n+            return of(ancestorBody, bodyType, cc, OpTransformer.COPYING_TRANSFORMER);\n@@ -320,2 +320,3 @@\n-         * The body descriptor defines the body's yield type and the initial sequence of entry block parameters.\n-         * The body's yield is the descriptors return type.\n+         * A function type, referred to as the body type, defines the body's yield type and the initial sequence of\n+         * entry block parameters.\n+         * The body's yield type is the function type's return type.\n@@ -323,1 +324,1 @@\n-         * the body descriptor parameter types.\n+         * the function type's parameter types.\n@@ -330,1 +331,1 @@\n-         * @param desc         the body descriptor\n+         * @param bodyType     the body's function type\n@@ -335,1 +336,1 @@\n-         * @see #of(Builder, MethodTypeDesc, CopyContext, OpTransformer)\n+         * @see #of(Builder, FunctionType, CopyContext, OpTransformer)\n@@ -337,1 +338,1 @@\n-        public static Builder of(Builder ancestorBody, MethodTypeDesc desc,\n+        public static Builder of(Builder ancestorBody, FunctionType bodyType,\n@@ -339,2 +340,2 @@\n-            Body body = new Body(ancestorBody != null ? ancestorBody.target() : null, desc.returnType());\n-            return body.new Builder(ancestorBody, desc, cc, ot);\n+            Body body = new Body(ancestorBody != null ? ancestorBody.target() : null, bodyType.returnType());\n+            return body.new Builder(ancestorBody, bodyType, cc, ot);\n@@ -346,1 +347,1 @@\n-        \/\/ The entry block of this body, whose parameters are given by the body's descriptor\n+        \/\/ The entry block of this body, whose parameters are given by the body's function type\n@@ -355,1 +356,1 @@\n-        Builder(Builder ancestorBody, MethodTypeDesc descriptor,\n+        Builder(Builder ancestorBody, FunctionType bodyType,\n@@ -365,2 +366,2 @@\n-            \/\/ Create entry block from descriptor\n-            Block eb = Body.this.createBlock(descriptor.parameters());\n+            \/\/ Create entry block from the body's function type\n+            Block eb = Body.this.createBlock(bodyType.parameterTypes());\n@@ -440,1 +441,1 @@\n-         * Returns the body's descriptor.\n+         * Returns the body builder's function type.\n@@ -442,2 +443,2 @@\n-         * The descriptor is composed of the body's yield type, as the descriptor's return type, and the currently built\n-         * entry block's parameter types, in order, as the descriptor's parameter types.\n+         * The function type is composed of the body builder's yield type, as the function type's return type, and the\n+         * currently built entry block's parameter types, in order, as the function type's parameter types.\n@@ -445,1 +446,1 @@\n-         * @return the body's descriptor\n+         * @return the body builder's function type\n@@ -447,1 +448,1 @@\n-        public MethodTypeDesc descriptor() {\n+        public FunctionType bodyType() {\n@@ -450,1 +451,1 @@\n-            return MethodTypeDesc.methodType(returnType, eb.parameterTypes());\n+            return FunctionType.functionType(returnType, eb.parameterTypes());\n@@ -511,1 +512,1 @@\n-     * A new body builder is created with the same descriptor as this body.\n+     * A new body builder is created with the same function type as this body.\n@@ -526,2 +527,2 @@\n-                \/\/ Create descriptor with just the return type and add parameters afterward\n-                MethodTypeDesc.methodType(yieldType),\n+                \/\/ Create function type with just the return type and add parameters afterward\n+                FunctionType.functionType(yieldType),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Body.java","additions":41,"deletions":40,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.type.FunctionType;\n@@ -41,2 +41,2 @@\n- * An operation might model the addition of two 32-integers, or a Java method call.\n- * Alternatively an operation may model something more complex like a method bodies, lambda bodies, or\n+ * An operation might model the addition of two 32-bit integers, or a Java method call.\n+ * Alternatively an operation may model something more complex like method bodies, lambda bodies, or\n@@ -86,1 +86,1 @@\n-         * @return the function descriptor describing the input parameter types and return type.\n+         * @return the function type describing the invokable operation's parameter types and return type.\n@@ -88,2 +88,1 @@\n-        \/\/ @@@ Replace with FunctionType\n-        MethodTypeDesc funcDescriptor();\n+        FunctionType invokableType();\n@@ -320,1 +319,1 @@\n-     * Returns the operation's descriptor.\n+     * Returns the operation's function type.\n@@ -322,1 +321,1 @@\n-     * The descriptor's result type is the operation's return type and the descriptor's parameter types are the\n+     * The function type's result type is the operation's result type and the function type's parameter types are the\n@@ -325,1 +324,1 @@\n-     * @return the descriptor\n+     * @return the function type\n@@ -327,2 +326,1 @@\n-    \/\/ @@@ Replace with FunctionType\n-    public MethodTypeDesc descriptor() {\n+    public FunctionType opType() {\n@@ -330,1 +328,1 @@\n-        return MethodTypeDesc.methodType(resultType(), operandTypes);\n+        return FunctionType.functionType(resultType(), operandTypes);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Op.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.type.FunctionType;\n@@ -98,1 +100,2 @@\n-            MethodType mt = fop.funcDescriptor().resolve(hcl);\n+            FunctionType ft = fop.invokableType();\n+            MethodType mt = MethodTypeDesc.ofFunctionType(ft).resolve(hcl);\n@@ -116,0 +119,1 @@\n+        MethodTypeDesc mtd = MethodTypeDesc.ofFunctionType(fop.invokableType());\n@@ -119,1 +123,1 @@\n-                        fop.funcDescriptor().toNominalDescriptor(),\n+                        mtd.toNominalDescriptor(),\n@@ -614,1 +618,1 @@\n-                                        throw new IllegalStateException(\"Bad method descriptor resolution: \" + op.descriptor() + \" > \" + op.invokeDescriptor());\n+                                        throw new IllegalStateException(\"Bad method descriptor resolution: \" + op.opType() + \" > \" + op.invokeDescriptor());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+        MethodTypeDesc mtd = MethodTypeDesc.ofNominalDescriptor(methodModel.methodTypeSymbol());\n@@ -77,1 +78,1 @@\n-                MethodTypeDesc.ofNominalDescriptor(methodModel.methodTypeSymbol())).body(entryBlock -> {\n+                mtd.toFunctionType()).body(entryBlock -> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.code.type.FunctionType;\n@@ -38,0 +39,1 @@\n+\/\/ @@@ Duplicates much of FunctionType\n@@ -39,0 +41,1 @@\n+\n@@ -53,0 +56,5 @@\n+    \/\/ @@@ required?\n+    default FunctionType toFunctionType() {\n+        return FunctionType.functionType(returnType(), parameters());\n+    }\n+\n@@ -76,0 +84,5 @@\n+    \/\/ @@@ required?\n+    static MethodTypeDesc ofFunctionType(FunctionType ft) {\n+        return methodType(ft.returnType(), ft.parameterTypes());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/MethodTypeDesc.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.reflect.code.type.FunctionType;\n@@ -170,2 +171,1 @@\n-                         Map<Value, Object> capturedValues)\n-            implements CoreOps.Closure {\n+                         Map<Value, Object> capturedValues) {\n@@ -397,1 +397,1 @@\n-            MethodType target = resolveToMethodType(l, o.descriptor());\n+            MethodType target = resolveToMethodType(l, o.opType());\n@@ -515,1 +515,1 @@\n-            MethodHandle mh = opHandle(o.opName(), o.descriptor());\n+            MethodHandle mh = opHandle(o.opName(), o.opType());\n@@ -519,1 +519,1 @@\n-            MethodHandle mh = opHandle(o.opName() + \"_\" + o.descriptor().returnType(), o.descriptor());\n+            MethodHandle mh = opHandle(o.opName() + \"_\" + o.opType().returnType(), o.opType());\n@@ -543,2 +543,2 @@\n-    static MethodHandle opHandle(String opName, MethodTypeDesc d) {\n-        MethodType mt = resolveToMethodType(MethodHandles.lookup(), d).erase();\n+    static MethodHandle opHandle(String opName, FunctionType ft) {\n+        MethodType mt = resolveToMethodType(MethodHandles.lookup(), ft).erase();\n@@ -611,0 +611,4 @@\n+    public static MethodType resolveToMethodType(MethodHandles.Lookup l, FunctionType ft) {\n+        return resolveToMethodType(l, MethodTypeDesc.ofFunctionType(ft));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.code.type.FunctionType;\n@@ -66,1 +67,1 @@\n-            final MethodTypeDesc funcDescriptor;\n+            final FunctionType funcType;\n@@ -68,1 +69,1 @@\n-            Builder(Body.Builder ancestorBody, String funcName, MethodTypeDesc funcDescriptor) {\n+            Builder(Body.Builder ancestorBody, String funcName, FunctionType funcType) {\n@@ -71,1 +72,1 @@\n-                this.funcDescriptor = funcDescriptor;\n+                this.funcType = funcType;\n@@ -75,1 +76,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, funcDescriptor);\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n@@ -152,2 +153,2 @@\n-        public MethodTypeDesc funcDescriptor() {\n-            return body.descriptor();\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n@@ -304,1 +305,1 @@\n-            Body.Builder bodyC = Body.Builder.of(null, MethodTypeDesc.VOID);\n+            Body.Builder bodyC = Body.Builder.of(null, FunctionType.VOID);\n@@ -447,1 +448,1 @@\n-            final MethodTypeDesc functionalDescriptor;\n+            final FunctionType funcType;\n@@ -450,1 +451,1 @@\n-            Builder(Body.Builder ancestorBody, MethodTypeDesc functionalDescriptor, TypeElement functionalInterface) {\n+            Builder(Body.Builder ancestorBody, FunctionType funcType, TypeElement functionalInterface) {\n@@ -452,1 +453,1 @@\n-                this.functionalDescriptor = functionalDescriptor;\n+                this.funcType = funcType;\n@@ -457,1 +458,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, functionalDescriptor);\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n@@ -501,2 +502,2 @@\n-        public MethodTypeDesc funcDescriptor() {\n-            return body.descriptor();\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n@@ -563,22 +564,0 @@\n-    \/**\n-     * A synthetic closure type, that is the operation result-type of a closure operation.\n-     *\/\n-    \/\/ @@@: Replace with use of FunctionType\n-    public interface Closure {\n-        \/\/ Type description must be the same in the java.base and jdk.compiler module\n-        JavaType CLOSURE_TYPE = new JavaTypeImpl(CoreOps_CLASS_NAME +\n-                \"$\" + Closure.class.getSimpleName());\n-\n-        static JavaType type(JavaType... types) {\n-            return JavaType.type(\n-                    CLOSURE_TYPE,\n-                    types);\n-        }\n-\n-        static JavaType type(List<JavaType> types) {\n-            return JavaType.type(\n-                    CLOSURE_TYPE,\n-                    types);\n-        }\n-    }\n-\n@@ -594,1 +573,1 @@\n-            final MethodTypeDesc functionalDescriptor;\n+            final FunctionType funcType;\n@@ -596,1 +575,1 @@\n-            Builder(Body.Builder ancestorBody, MethodTypeDesc functionalDescriptor) {\n+            Builder(Body.Builder ancestorBody, FunctionType funcType) {\n@@ -598,1 +577,1 @@\n-                this.functionalDescriptor = functionalDescriptor;\n+                this.funcType = funcType;\n@@ -602,1 +581,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, functionalDescriptor);\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n@@ -636,7 +615,0 @@\n-        static JavaType closureType(MethodTypeDesc functionalDescriptor) {\n-            List<JavaType> l = new ArrayList<>();\n-            l.add((JavaType) functionalDescriptor.returnType());\n-            l.addAll(functionalDescriptor.parameters().stream().map(t -> (JavaType) t).toList());\n-            return Closure.type(l);\n-        }\n-\n@@ -649,2 +621,2 @@\n-        public MethodTypeDesc funcDescriptor() {\n-            return body.descriptor();\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n@@ -703,1 +675,1 @@\n-            return closureType(body().descriptor());\n+            return body.bodyType();\n@@ -734,17 +706,0 @@\n-        static JavaType resultType(List<Value> args) {\n-            if (args.isEmpty()) {\n-                throw new IllegalArgumentException(\n-                        \"Operation must have one or more operands: \" + args.size());\n-            }\n-            JavaType t = (JavaType) args.get(0).type();\n-\n-            if (t.typeArguments().isEmpty()) {\n-                throw new IllegalArgumentException(\n-                        \"Operation result type must have one or more parameters: \" + t.typeArguments().size());\n-            }\n-            if (t.typeArguments().size() != args.size()) {\n-                throw new IllegalArgumentException();\n-            }\n-            return t.typeArguments().get(0);\n-        }\n-\n@@ -753,1 +708,2 @@\n-            return resultType(operands());\n+            FunctionType ft = (FunctionType) operands().getFirst().type();\n+            return ft.returnType();\n@@ -1356,1 +1312,1 @@\n-            return descriptor().returnType();\n+            return opType().returnType();\n@@ -2818,1 +2774,1 @@\n-     * @param funcDescriptor the function descriptor\n+     * @param funcType the function type\n@@ -2821,2 +2777,2 @@\n-    public static FuncOp.Builder func(String funcName, MethodTypeDesc funcDescriptor) {\n-        return new FuncOp.Builder(null, funcName, funcDescriptor);\n+    public static FuncOp.Builder func(String funcName, FunctionType funcType) {\n+        return new FuncOp.Builder(null, funcName, funcType);\n@@ -2874,1 +2830,1 @@\n-        return new FuncCallOp(func.funcName(), func.funcDescriptor().returnType(), args);\n+        return new FuncCallOp(func.funcName(), func.invokableType().returnType(), args);\n@@ -2903,1 +2859,1 @@\n-        Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.VOID);\n+        Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n@@ -2922,2 +2878,2 @@\n-     * @param functionalDescriptor the lambda operation's functional descriptor\n-     * @param functionalInterface the lambda operation's functional interface\n+     * @param funcType the lambda operation's function type\n+     * @param functionalInterface the lambda operation's functional interface type\n@@ -2927,2 +2883,2 @@\n-                                          MethodTypeDesc functionalDescriptor, TypeElement functionalInterface) {\n-        return new LambdaOp.Builder(ancestorBody, functionalDescriptor, functionalInterface);\n+                                          FunctionType funcType, TypeElement functionalInterface) {\n+        return new LambdaOp.Builder(ancestorBody, funcType, functionalInterface);\n@@ -2933,1 +2889,1 @@\n-     * @param functionalInterface the lambda operation's functional interface\n+     * @param functionalInterface the lambda operation's functional interface type\n@@ -2944,1 +2900,1 @@\n-     * @param functionalDescriptor the closure operation's functional descriptor\n+     * @param funcType the closure operation's function type\n@@ -2948,2 +2904,2 @@\n-                                            MethodTypeDesc functionalDescriptor) {\n-        return new ClosureOp.Builder(ancestorBody, functionalDescriptor);\n+                                            FunctionType funcType) {\n+        return new ClosureOp.Builder(ancestorBody, funcType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":37,"deletions":81,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n@@ -32,0 +31,1 @@\n+import java.lang.reflect.code.type.FunctionType;\n@@ -322,2 +322,2 @@\n-            if (!body.descriptor().returnType().equals(JavaType.VOID)) {\n-                throw new IllegalArgumentException(\"Body should return void: \" + body.descriptor());\n+            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n@@ -325,2 +325,2 @@\n-            if (!body.descriptor().parameters().isEmpty()) {\n-                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.descriptor());\n+            if (!body.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.bodyType());\n@@ -402,2 +402,2 @@\n-            if (!body.descriptor().returnType().equals(JavaType.VOID)) {\n-                throw new IllegalArgumentException(\"Body should return void: \" + body.descriptor());\n+            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n@@ -405,2 +405,2 @@\n-            if (!body.descriptor().parameters().isEmpty()) {\n-                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.descriptor());\n+            if (!body.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.bodyType());\n@@ -464,1 +464,1 @@\n-        static final MethodTypeDesc PREDICATE_TYPE = MethodTypeDesc.methodType(JavaType.BOOLEAN);\n+        static final FunctionType PREDICATE_TYPE = FunctionType.functionType(JavaType.BOOLEAN);\n@@ -466,1 +466,1 @@\n-        static final MethodTypeDesc ACTION_TYPE = MethodTypeDesc.VOID;\n+        static final FunctionType ACTION_TYPE = FunctionType.VOID;\n@@ -583,1 +583,1 @@\n-                        MethodTypeDesc.VOID);\n+                        FunctionType.VOID);\n@@ -600,2 +600,2 @@\n-                    if (!fromPred.descriptor().equals(MethodTypeDesc.methodType(JavaType.BOOLEAN))) {\n-                        throw new IllegalArgumentException(\"Illegal predicate body descriptor: \" + fromPred.descriptor());\n+                    if (!fromPred.bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+                        throw new IllegalArgumentException(\"Illegal predicate body descriptor: \" + fromPred.bodyType());\n@@ -604,2 +604,2 @@\n-                if (!action.descriptor().equals(MethodTypeDesc.VOID)) {\n-                    throw new IllegalArgumentException(\"Illegal action body descriptor: \" + action.descriptor());\n+                if (!action.bodyType().equals(FunctionType.VOID)) {\n+                    throw new IllegalArgumentException(\"Illegal action body descriptor: \" + action.bodyType());\n@@ -798,1 +798,1 @@\n-                        MethodTypeDesc.methodType(TupleType.tupleType(initTypes)));\n+                        FunctionType.functionType(TupleType.tupleType(initTypes)));\n@@ -820,1 +820,1 @@\n-                        MethodTypeDesc.methodType(JavaType.BOOLEAN, initTypes));\n+                        FunctionType.functionType(JavaType.BOOLEAN, initTypes));\n@@ -844,1 +844,1 @@\n-                        MethodTypeDesc.methodType(JavaType.VOID, initTypes));\n+                        FunctionType.functionType(JavaType.VOID, initTypes));\n@@ -871,1 +871,1 @@\n-                        MethodTypeDesc.methodType(JavaType.VOID, initTypes));\n+                        FunctionType.functionType(JavaType.VOID, initTypes));\n@@ -923,2 +923,2 @@\n-            if (!update.descriptor().returnType().equals(JavaType.VOID)) {\n-                throw new IllegalArgumentException(\"Update should return void: \" + update.descriptor());\n+            if (!update.bodyType().returnType().equals(JavaType.VOID)) {\n+                throw new IllegalArgumentException(\"Update should return void: \" + update.bodyType());\n@@ -928,2 +928,2 @@\n-            if (!body.descriptor().returnType().equals(JavaType.VOID)) {\n-                throw new IllegalArgumentException(\"Body should return void: \" + body.descriptor());\n+            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n@@ -1059,1 +1059,1 @@\n-                        MethodTypeDesc.methodType(iterableType));\n+                        FunctionType.functionType(iterableType));\n@@ -1084,1 +1084,1 @@\n-                        MethodTypeDesc.methodType(bodyElementType, elementType));\n+                        FunctionType.functionType(bodyElementType, elementType));\n@@ -1107,1 +1107,1 @@\n-                        MethodTypeDesc.methodType(JavaType.VOID, elementType));\n+                        FunctionType.functionType(JavaType.VOID, elementType));\n@@ -1149,2 +1149,2 @@\n-            if (expression.descriptor().returnType().equals(JavaType.VOID)) {\n-                throw new IllegalArgumentException(\"Expression should return non-void value: \" + expression.descriptor());\n+            if (expression.bodyType().returnType().equals(JavaType.VOID)) {\n+                throw new IllegalArgumentException(\"Expression should return non-void value: \" + expression.bodyType());\n@@ -1152,2 +1152,2 @@\n-            if (!expression.descriptor().parameters().isEmpty()) {\n-                throw new IllegalArgumentException(\"Expression should have zero parameters: \" + expression.descriptor());\n+            if (!expression.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Expression should have zero parameters: \" + expression.bodyType());\n@@ -1157,2 +1157,2 @@\n-            if (init.descriptor().returnType().equals(JavaType.VOID)) {\n-                throw new IllegalArgumentException(\"Initialization should return non-void value: \" + init.descriptor());\n+            if (init.bodyType().returnType().equals(JavaType.VOID)) {\n+                throw new IllegalArgumentException(\"Initialization should return non-void value: \" + init.bodyType());\n@@ -1160,2 +1160,2 @@\n-            if (init.descriptor().parameters().size() != 1) {\n-                throw new IllegalArgumentException(\"Initialization should have one parameter: \" + init.descriptor());\n+            if (init.bodyType().parameterTypes().size() != 1) {\n+                throw new IllegalArgumentException(\"Initialization should have one parameter: \" + init.bodyType());\n@@ -1165,2 +1165,2 @@\n-            if (!body.descriptor().returnType().equals(JavaType.VOID)) {\n-                throw new IllegalArgumentException(\"Body should return void: \" + body.descriptor());\n+            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n@@ -1168,2 +1168,2 @@\n-            if (body.descriptor().parameters().size() != 1) {\n-                throw new IllegalArgumentException(\"Body should have one parameter: \" + body.descriptor());\n+            if (body.bodyType().parameterTypes().size() != 1) {\n+                throw new IllegalArgumentException(\"Body should have one parameter: \" + body.bodyType());\n@@ -1198,1 +1198,1 @@\n-            boolean isArray = ((JavaType) expression.descriptor().returnType()).isArray();\n+            boolean isArray = ((JavaType) expression.bodyType().returnType()).isArray();\n@@ -1200,1 +1200,1 @@\n-            Block.Builder preHeader = b.block(expression.descriptor().returnType());\n+            Block.Builder preHeader = b.block(expression.bodyType().returnType());\n@@ -1313,1 +1313,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1330,1 +1330,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.VOID);\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n@@ -1363,1 +1363,1 @@\n-            if (!bodies.get(0).descriptor().equals(MethodTypeDesc.methodType(JavaType.BOOLEAN))) {\n+            if (!bodies.get(0).bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n@@ -1365,2 +1365,2 @@\n-                        \"Predicate body descriptor should be \" + MethodTypeDesc.methodType(JavaType.BOOLEAN) +\n-                                \" but is \" + bodies.get(0).descriptor());\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(JavaType.BOOLEAN) +\n+                                \" but is \" + bodies.get(0).bodyType());\n@@ -1368,1 +1368,1 @@\n-            if (!bodies.get(1).descriptor().equals(MethodTypeDesc.VOID)) {\n+            if (!bodies.get(1).bodyType().equals(FunctionType.VOID)) {\n@@ -1370,2 +1370,2 @@\n-                        \"Body descriptor should be \" + MethodTypeDesc.methodType(JavaType.VOID) +\n-                                \" but is \" + bodies.get(1).descriptor());\n+                        \"Body descriptor should be \" + FunctionType.functionType(JavaType.VOID) +\n+                                \" but is \" + bodies.get(1).bodyType());\n@@ -1460,1 +1460,1 @@\n-                Body.Builder predicate = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+                Body.Builder predicate = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1475,1 +1475,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.VOID);\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n@@ -1507,1 +1507,1 @@\n-            if (!bodies.get(0).descriptor().equals(MethodTypeDesc.VOID)) {\n+            if (!bodies.get(0).bodyType().equals(FunctionType.VOID)) {\n@@ -1509,2 +1509,2 @@\n-                        \"Body descriptor should be \" + MethodTypeDesc.methodType(JavaType.VOID) +\n-                                \" but is \" + bodies.get(1).descriptor());\n+                        \"Body descriptor should be \" + FunctionType.functionType(JavaType.VOID) +\n+                                \" but is \" + bodies.get(1).bodyType());\n@@ -1512,1 +1512,1 @@\n-            if (!bodies.get(1).descriptor().equals(MethodTypeDesc.methodType(JavaType.BOOLEAN))) {\n+            if (!bodies.get(1).bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n@@ -1514,2 +1514,2 @@\n-                        \"Predicate body descriptor should be \" + MethodTypeDesc.methodType(JavaType.BOOLEAN) +\n-                                \" but is \" + bodies.get(0).descriptor());\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(JavaType.BOOLEAN) +\n+                                \" but is \" + bodies.get(0).bodyType());\n@@ -1621,2 +1621,2 @@\n-                if (!b.descriptor().equals(MethodTypeDesc.methodType(JavaType.BOOLEAN))) {\n-                    throw new IllegalArgumentException(\"Body conditional body descriptor: \" + b.descriptor());\n+                if (!b.bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+                    throw new IllegalArgumentException(\"Body conditional body descriptor: \" + b.bodyType());\n@@ -1685,1 +1685,1 @@\n-                    pred = startBlock.block(fromPred.descriptor().parameters());\n+                    pred = startBlock.block(fromPred.bodyType().parameterTypes());\n@@ -1717,1 +1717,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1772,1 +1772,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1860,2 +1860,2 @@\n-            if (!cond.descriptor().equals(MethodTypeDesc.methodType(JavaType.BOOLEAN))) {\n-                throw new IllegalArgumentException(\"Illegal cond body descriptor: \" + cond.descriptor());\n+            if (!cond.bodyType().equals(FunctionType.functionType(JavaType.BOOLEAN))) {\n+                throw new IllegalArgumentException(\"Illegal cond body descriptor: \" + cond.bodyType());\n@@ -1933,1 +1933,1 @@\n-                        MethodTypeDesc.methodType(JavaType.VOID, resourceTypes));\n+                        FunctionType.functionType(JavaType.VOID, resourceTypes));\n@@ -1956,1 +1956,1 @@\n-                        MethodTypeDesc.methodType(JavaType.VOID, exceptionType));\n+                        FunctionType.functionType(JavaType.VOID, exceptionType));\n@@ -1964,1 +1964,1 @@\n-                Body.Builder _finally = Body.Builder.of(ancestorBody, MethodTypeDesc.VOID);\n+                Body.Builder _finally = Body.Builder.of(ancestorBody, FunctionType.VOID);\n@@ -1991,1 +1991,1 @@\n-            if (first.descriptor().returnType().equals(JavaType.VOID)) {\n+            if (first.bodyType().returnType().equals(JavaType.VOID)) {\n@@ -2000,1 +2000,1 @@\n-            if (last.descriptor().parameters().isEmpty()) {\n+            if (last.bodyType().parameterTypes().isEmpty()) {\n@@ -2042,2 +2042,2 @@\n-                if (resources.descriptor().returnType().equals(JavaType.VOID)) {\n-                    throw new IllegalArgumentException(\"Resources should not return void: \" + resources.descriptor());\n+                if (resources.bodyType().returnType().equals(JavaType.VOID)) {\n+                    throw new IllegalArgumentException(\"Resources should not return void: \" + resources.bodyType());\n@@ -2045,2 +2045,2 @@\n-                if (!resources.descriptor().parameters().isEmpty()) {\n-                    throw new IllegalArgumentException(\"Resources should have zero parameters: \" + resources.descriptor());\n+                if (!resources.bodyType().parameterTypes().isEmpty()) {\n+                    throw new IllegalArgumentException(\"Resources should have zero parameters: \" + resources.bodyType());\n@@ -2053,2 +2053,2 @@\n-            if (!body.descriptor().returnType().equals(JavaType.VOID)) {\n-                throw new IllegalArgumentException(\"Try should return void: \" + body.descriptor());\n+            if (!body.bodyType().returnType().equals(JavaType.VOID)) {\n+                throw new IllegalArgumentException(\"Try should return void: \" + body.bodyType());\n@@ -2059,2 +2059,2 @@\n-                if (!_catch.descriptor().returnType().equals(JavaType.VOID)) {\n-                    throw new IllegalArgumentException(\"Catch should return void: \" + _catch.descriptor());\n+                if (!_catch.bodyType().returnType().equals(JavaType.VOID)) {\n+                    throw new IllegalArgumentException(\"Catch should return void: \" + _catch.bodyType());\n@@ -2062,2 +2062,2 @@\n-                if (_catch.descriptor().parameters().size() != 1) {\n-                    throw new IllegalArgumentException(\"Catch should have zero parameters: \" + _catch.descriptor());\n+                if (_catch.bodyType().parameterTypes().size() != 1) {\n+                    throw new IllegalArgumentException(\"Catch should have zero parameters: \" + _catch.bodyType());\n@@ -2069,2 +2069,2 @@\n-                if (!finalizer.descriptor().returnType().equals(JavaType.VOID)) {\n-                    throw new IllegalArgumentException(\"Finally should return void: \" + finalizer.descriptor());\n+                if (!finalizer.bodyType().returnType().equals(JavaType.VOID)) {\n+                    throw new IllegalArgumentException(\"Finally should return void: \" + finalizer.bodyType());\n@@ -2072,2 +2072,2 @@\n-                if (!finalizer.descriptor().parameters().isEmpty()) {\n-                    throw new IllegalArgumentException(\"Finally should have zero parameters: \" + finalizer.descriptor());\n+                if (!finalizer.bodyType().parameterTypes().isEmpty()) {\n+                    throw new IllegalArgumentException(\"Finally should have zero parameters: \" + finalizer.bodyType());\n@@ -2214,1 +2214,1 @@\n-                Block.Parameter t = catcher.parameter(catcherBody.descriptor().parameters().get(0));\n+                Block.Parameter t = catcher.parameter(catcherBody.bodyType().parameterTypes().get(0));\n@@ -3059,1 +3059,1 @@\n-        Body.Builder _try = Body.Builder.of(ancestorBody, MethodTypeDesc.VOID);\n+        Body.Builder _try = Body.Builder.of(ancestorBody, FunctionType.VOID);\n@@ -3076,1 +3076,1 @@\n-                MethodTypeDesc.methodType(TupleType.tupleType(resourceTypes)));\n+                FunctionType.functionType(TupleType.tupleType(resourceTypes)));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":86,"deletions":86,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.type.FunctionType;\n@@ -264,1 +264,1 @@\n-                MethodTypeDesc.methodType(c.typeFactory.constructType(n.rtype)));\n+                FunctionType.functionType(c.typeFactory.constructType(n.rtype)));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/OpParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,0 +58,19 @@\n+                    case FunctionType.NAME -> {\n+                        if (tree.typeArguments().isEmpty()) {\n+                            throw new IllegalArgumentException();\n+                        }\n+\n+                        TypeElement rt = thisThenF.constructType(tree.typeArguments().getFirst());\n+                        if (rt == null) {\n+                            throw new IllegalArgumentException();\n+                        }\n+                        List<TypeElement> pts = new ArrayList<>(tree.typeArguments().size() - 1);\n+                        for (TypeDefinition child : tree.typeArguments().subList(1, tree.typeArguments().size())) {\n+                            TypeElement c = thisThenF.constructType(child);\n+                            if (c == null) {\n+                                throw new IllegalArgumentException();\n+                            }\n+                            pts.add(c);\n+                        }\n+                        yield FunctionType.functionType(rt, pts);\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -13,1 +13,8 @@\n-    static final String NAME = \"->\";\n+    \/\/ @@@ Change to \"->\" when the textual form supports it\n+    static final String NAME = \"func\";\n+\n+    \/**\n+     * The function type with no parameters, returning void.\n+     *\/\n+    \/\/ @@@ Uses JavaType\n+    public static final FunctionType VOID = functionType(JavaType.VOID);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/FunctionType.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-        write(body.descriptor().returnType().toString());\n+        write(body.bodyType().returnType().toString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-        cparen().type(body.descriptor().returnType().toString()).space().rarrow().space().obrace().nl();\n+        cparen().type(body.bodyType().returnType().toString()).space().rarrow().space().obrace().nl();\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/SRRenderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+import jdk.internal.java.lang.reflect.code.type.FunctionType;\n@@ -394,1 +395,1 @@\n-        BodyStack(BodyStack parent, JCTree tree, MethodTypeDesc bodyType) {\n+        BodyStack(BodyStack parent, JCTree tree, FunctionType bodyType) {\n@@ -467,1 +468,2 @@\n-            MethodTypeDesc mtDesc = MethodTypeDesc.methodType(typeToTypeElement(tree.sym.type.getReturnType()), parameters);\n+            FunctionType bodyType = FunctionType.functionType(\n+                    typeToTypeElement(tree.sym.type.getReturnType()), parameters);\n@@ -469,1 +471,1 @@\n-            this.stack = this.top = new BodyStack(null, tree.body, mtDesc);\n+            this.stack = this.top = new BodyStack(null, tree.body, bodyType);\n@@ -497,1 +499,1 @@\n-            MethodTypeDesc mtDesc = MethodTypeDesc.methodType(typeToTypeElement(mtype.restype),\n+            FunctionType mtDesc = FunctionType.functionType(typeToTypeElement(mtype.restype),\n@@ -505,1 +507,1 @@\n-        void pushBody(JCTree tree, MethodTypeDesc bodyType) {\n+        void pushBody(JCTree tree, FunctionType bodyType) {\n@@ -1099,1 +1101,1 @@\n-            pushBody(pattern, MethodTypeDesc.methodType(patternType));\n+            pushBody(pattern, FunctionType.functionType(patternType));\n@@ -1165,1 +1167,1 @@\n-            MethodTypeDesc patternDesc = MethodTypeDesc.methodType(JavaType.VOID, patternDescParams);\n+            FunctionType matchFuncType = FunctionType.functionType(JavaType.VOID, patternDescParams);\n@@ -1168,1 +1170,1 @@\n-            Body.Builder matchBody = Body.Builder.of(patternBody.ancestorBody(), patternDesc);\n+            Body.Builder matchBody = Body.Builder.of(patternBody.ancestorBody(), matchFuncType);\n@@ -1250,3 +1252,3 @@\n-            final MethodTypeDesc lambdaType = switch (kind) {\n-                case QUOTED_STRUCTURAL -> typeToMethodTypeDesc(tree.target);\n-                default -> typeToMethodTypeDesc(types.findDescriptorType(tree.target));\n+            final FunctionType lambdaType = switch (kind) {\n+                case QUOTED_STRUCTURAL -> typeToFunctionType(tree.target);\n+                default -> typeToFunctionType(types.findDescriptorType(tree.target));\n@@ -1259,1 +1261,1 @@\n-                pushBody(tree.body, MethodTypeDesc.VOID);\n+                pushBody(tree.body, FunctionType.VOID);\n@@ -1335,1 +1337,1 @@\n-                        MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+                        FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1345,1 +1347,1 @@\n-                pushBody(tree.thenpart, MethodTypeDesc.VOID);\n+                pushBody(tree.thenpart, FunctionType.VOID);\n@@ -1360,1 +1362,1 @@\n-                    pushBody(elsepart, MethodTypeDesc.VOID);\n+                    pushBody(elsepart, FunctionType.VOID);\n@@ -1384,1 +1386,1 @@\n-            MethodTypeDesc caseLabelType = MethodTypeDesc.methodType(JavaType.BOOLEAN, target.type());\n+            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n@@ -1386,1 +1388,1 @@\n-            MethodTypeDesc actionType = MethodTypeDesc.methodType(typeToTypeElement(switchType));\n+            FunctionType actionType = FunctionType.functionType(typeToTypeElement(switchType));\n@@ -1403,1 +1405,1 @@\n-                        pushBody(pcl.pat, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1409,1 +1411,1 @@\n-                        pushBody(c.guard, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1443,1 +1445,1 @@\n-                            pushBody(ccl, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1473,1 +1475,1 @@\n-                    pushBody(headCl, MethodTypeDesc.VOID);\n+                    pushBody(headCl, FunctionType.VOID);\n@@ -1547,1 +1549,1 @@\n-            pushBody(cond, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1557,1 +1559,1 @@\n-            pushBody(tree.body, MethodTypeDesc.VOID);\n+            pushBody(tree.body, FunctionType.VOID);\n@@ -1576,1 +1578,1 @@\n-            pushBody(tree.body, MethodTypeDesc.VOID);\n+            pushBody(tree.body, FunctionType.VOID);\n@@ -1585,1 +1587,1 @@\n-            pushBody(cond, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1601,1 +1603,1 @@\n-            pushBody(tree.expr, MethodTypeDesc.methodType(typeToTypeElement(tree.expr.type)));\n+            pushBody(tree.expr, FunctionType.functionType(typeToTypeElement(tree.expr.type)));\n@@ -1617,1 +1619,1 @@\n-            pushBody(var, MethodTypeDesc.methodType(varEType, eType));\n+            pushBody(var, FunctionType.functionType(varEType, eType));\n@@ -1625,1 +1627,1 @@\n-            pushBody(tree.body, MethodTypeDesc.methodType(JavaType.VOID, varEType));\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varEType));\n@@ -1679,1 +1681,1 @@\n-                pushBody(null, MethodTypeDesc.methodType(TupleType.tupleType(varTypes)));\n+                pushBody(null, FunctionType.functionType(TupleType.tupleType(varTypes)));\n@@ -1685,1 +1687,1 @@\n-                pushBody(null, MethodTypeDesc.methodType(varTypes.get(0)));\n+                pushBody(null, FunctionType.functionType(varTypes.get(0)));\n@@ -1690,1 +1692,1 @@\n-                pushBody(null, MethodTypeDesc.VOID);\n+                pushBody(null, FunctionType.VOID);\n@@ -1701,1 +1703,1 @@\n-            pushBody(tree.cond, MethodTypeDesc.methodType(JavaType.BOOLEAN, varTypes));\n+            pushBody(tree.cond, FunctionType.functionType(JavaType.BOOLEAN, varTypes));\n@@ -1718,1 +1720,1 @@\n-            pushBody(null, MethodTypeDesc.methodType(JavaType.VOID, varTypes));\n+            pushBody(null, FunctionType.functionType(JavaType.VOID, varTypes));\n@@ -1731,1 +1733,1 @@\n-            pushBody(tree.body, MethodTypeDesc.methodType(JavaType.VOID, varTypes));\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varTypes));\n@@ -1755,1 +1757,1 @@\n-                    MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+                    FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1770,1 +1772,1 @@\n-                    MethodTypeDesc.methodType(typeToTypeElement(condType)));\n+                    FunctionType.functionType(typeToTypeElement(condType)));\n@@ -1784,1 +1786,1 @@\n-                    MethodTypeDesc.methodType(typeToTypeElement(condType)));\n+                    FunctionType.functionType(typeToTypeElement(condType)));\n@@ -1820,1 +1822,1 @@\n-                pushBody(tree, MethodTypeDesc.VOID);\n+                pushBody(tree, FunctionType.VOID);\n@@ -1836,1 +1838,1 @@\n-            pushBody(tree, MethodTypeDesc.VOID);\n+            pushBody(tree, FunctionType.VOID);\n@@ -1870,1 +1872,1 @@\n-                pushBody(null, MethodTypeDesc.methodType(TupleType.tupleType(rTypes)));\n+                pushBody(null, FunctionType.functionType(TupleType.tupleType(rTypes)));\n@@ -1893,1 +1895,1 @@\n-            pushBody(tree.body, MethodTypeDesc.methodType(JavaType.VOID, rVarTypes));\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, rVarTypes));\n@@ -1912,1 +1914,1 @@\n-                pushBody(catcher.body, MethodTypeDesc.methodType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n+                pushBody(catcher.body, FunctionType.functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n@@ -1928,1 +1930,1 @@\n-                pushBody(tree.finalizer, MethodTypeDesc.VOID);\n+                pushBody(tree.finalizer, FunctionType.VOID);\n@@ -1994,1 +1996,1 @@\n-                pushBody(tree.lhs, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+                pushBody(tree.lhs, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -2004,1 +2006,1 @@\n-                pushBody(tree.rhs, MethodTypeDesc.methodType(JavaType.BOOLEAN));\n+                pushBody(tree.rhs, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -2206,2 +2208,2 @@\n-        MethodTypeDesc symbolToMethodTypeDesc(Symbol s) {\n-            return typeToMethodTypeDesc(s.type);\n+        FunctionType symbolToFunctionType(Symbol s) {\n+            return typeToFunctionType(s.type);\n@@ -2210,2 +2212,2 @@\n-        MethodTypeDesc typeToMethodTypeDesc(Type t) {\n-            return MethodTypeDesc.methodType(\n+        FunctionType typeToFunctionType(Type t) {\n+            return FunctionType.functionType(\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":51,"deletions":49,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.VOID;\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.FunctionType.VOID;\n@@ -54,1 +54,1 @@\n-        var body = Body.Builder.of(null, f.funcDescriptor());\n+        var body = Body.Builder.of(null, f.invokableType());\n@@ -69,1 +69,1 @@\n-        var body = Body.Builder.of(null, f.funcDescriptor());\n+        var body = Body.Builder.of(null, f.invokableType());\n@@ -86,1 +86,1 @@\n-        var body = Body.Builder.of(null, f.funcDescriptor());\n+        var body = Body.Builder.of(null, f.invokableType());\n@@ -98,1 +98,1 @@\n-        var body = Body.Builder.of(null, f.funcDescriptor());\n+        var body = Body.Builder.of(null, f.invokableType());\n@@ -110,1 +110,1 @@\n-        var body = Body.Builder.of(null, f.funcDescriptor());\n+        var body = Body.Builder.of(null, f.invokableType());\n@@ -127,1 +127,1 @@\n-        var body = Body.Builder.of(null, methodType(int.class, int.class, int.class));\n+        var body = Body.Builder.of(null, functionType(INT, INT, INT));\n@@ -157,1 +157,1 @@\n-        var body = Body.Builder.of(null, methodType(int.class, int.class, int.class));\n+        var body = Body.Builder.of(null, functionType(INT, INT, INT));\n@@ -180,1 +180,1 @@\n-        var abody = Body.Builder.of(null, methodType(int.class, int.class, int.class));\n+        var abody = Body.Builder.of(null, functionType(INT, INT, INT));\n@@ -185,1 +185,1 @@\n-        var bbody = Body.Builder.of(null, abody.descriptor());\n+        var bbody = Body.Builder.of(null, abody.bodyType());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n@@ -71,1 +71,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n@@ -78,1 +78,1 @@\n-                        return closure(qblock.parentBody(), methodType(int.class, int.class))\n+                        return closure(qblock.parentBody(), functionType(INT, INT))\n@@ -103,1 +103,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n@@ -110,1 +110,1 @@\n-                            methodType(int.class, int.class))\n+                                    functionType(INT, INT))\n@@ -138,1 +138,1 @@\n-        Assert.assertEquals(JavaType.type(Quoted.class, CoreOps.ClosureOp.class), fop.funcDescriptor().returnType());\n+        Assert.assertEquals(JavaType.type(Quoted.class, CoreOps.ClosureOp.class), fop.invokableType().returnType());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.type.FunctionType;\n@@ -54,1 +54,1 @@\n-        CoreOps.FuncOp f = func(\"f\", MethodTypeDesc.VOID).body(entry -> {\n+        CoreOps.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n@@ -81,1 +81,1 @@\n-        CoreOps.FuncOp f = func(\"f\", MethodTypeDesc.VOID).body(entry -> {\n+        CoreOps.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n@@ -117,1 +117,1 @@\n-        CoreOps.FuncOp f = func(\"f\", MethodTypeDesc.VOID).body(entry -> {\n+        CoreOps.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n@@ -160,1 +160,1 @@\n-        CoreOps.FuncOp f = func(\"f\", MethodTypeDesc.VOID).body(entry -> {\n+        CoreOps.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n@@ -201,1 +201,1 @@\n-        CoreOps.FuncOp f = func(\"f\", MethodTypeDesc.VOID).body(entry -> {\n+        CoreOps.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestDominate.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class))\n+        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class).toFunctionType())\n@@ -161,1 +161,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class))\n+        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class).toFunctionType())\n@@ -255,1 +255,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class))\n+        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class).toFunctionType())\n@@ -376,1 +376,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class))\n+        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class).toFunctionType())\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExceptionRegionOps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n@@ -53,1 +54,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n@@ -75,1 +76,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n@@ -119,1 +120,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n@@ -155,1 +156,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n@@ -187,1 +188,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n@@ -221,1 +222,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(void.class, int[].class))\n+        CoreOps.FuncOp f = func(\"f\", methodType(void.class, int[].class).toFunctionType())\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n@@ -73,1 +73,1 @@\n-        FuncOp f = func(\"f\", methodType(int.class, int.class))\n+        FuncOp f = func(\"f\", functionType(INT, INT))\n@@ -81,1 +81,1 @@\n-                                methodType(int.class, int.class), type(IntUnaryOperator.class))\n+                                functionType(INT, INT), type(IntUnaryOperator.class))\n@@ -110,1 +110,1 @@\n-        FuncOp f = func(\"f\", methodType(int.class, int.class))\n+        FuncOp f = func(\"f\", functionType(INT, INT))\n@@ -118,1 +118,1 @@\n-                            methodType(int.class, int.class), type(IntUnaryOperator.class))\n+                            functionType(INT, INT), type(IntUnaryOperator.class))\n@@ -156,1 +156,1 @@\n-        Assert.assertEquals(type(Quoted.class, LambdaOp.class), fop.funcDescriptor().returnType());\n+        Assert.assertEquals(type(Quoted.class, LambdaOp.class), fop.invokableType().returnType());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n@@ -71,1 +72,1 @@\n-            return insertQuery(c.funcDescriptor().returnType(), \"select\", c);\n+            return insertQuery(c.invokableType().returnType(), \"select\", c);\n@@ -117,1 +118,1 @@\n-                    methodType(qp.queryResultType(), currentQueryExpression.funcDescriptor().parameters()))\n+                    functionType(qp.queryResultType(), currentQueryExpression.invokableType().parameterTypes()))\n@@ -162,1 +163,1 @@\n-            var funDescriptor = methodType(provider().queryableType(), provider().queryableType());\n+            var funDescriptor = functionType(provider().queryableType(), provider().queryableType());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -8,1 +8,0 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n@@ -10,0 +9,1 @@\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n@@ -28,1 +28,1 @@\n-        FuncOp g = func(\"g\", methodType(DOUBLE, DOUBLE, DOUBLE))\n+        FuncOp g = func(\"g\", functionType(DOUBLE, DOUBLE, DOUBLE))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOpResultTypeNotCopiedBlindly.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n@@ -54,1 +55,1 @@\n-        return (Queryable<R>) insertQuery((JavaType) l.funcDescriptor().returnType(), \"select\", l);\n+        return (Queryable<R>) insertQuery((JavaType) l.invokableType().returnType(), \"select\", l);\n@@ -62,1 +63,1 @@\n-                methodType(queryableType, queryExpression.funcDescriptor().parameters()))\n+                functionType(queryableType, queryExpression.invokableType().parameterTypes()))\n@@ -93,1 +94,1 @@\n-                methodType(queryResultType, queryExpression.funcDescriptor().parameters()))\n+                functionType(queryResultType, queryExpression.invokableType().parameterTypes()))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n@@ -30,0 +29,1 @@\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n@@ -62,1 +62,1 @@\n-            var funDescriptor = methodType(queryableType, queryableType);\n+            var funDescriptor = functionType(queryableType, queryableType);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestQueryProvider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import static java.lang.reflect.code.op.CoreOps.invoke;\n@@ -47,1 +46,1 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n@@ -60,1 +59,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n@@ -68,1 +67,1 @@\n-                            methodType(int.class, int.class), type(IntUnaryOperator.class))\n+                            functionType(INT, INT), type(IntUnaryOperator.class))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestParse.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-            return func(\"fused.forEach\", MethodTypeDesc.methodType(JavaType.VOID, sourceType))\n+            return func(\"fused.forEach\", MethodTypeDesc.methodType(JavaType.VOID, sourceType).toFunctionType())\n@@ -213,2 +213,2 @@\n-            JavaType collectType = (JavaType) supplier.funcDescriptor().returnType();\n-            return func(\"fused.collect\", MethodTypeDesc.methodType(collectType, sourceType))\n+            JavaType collectType = (JavaType) supplier.invokableType().returnType();\n+            return func(\"fused.collect\", MethodTypeDesc.methodType(collectType, sourceType).toFunctionType())\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-            return func(\"fused.forEach\", MethodTypeDesc.methodType(JavaType.VOID, sourceType))\n+            return func(\"fused.forEach\", MethodTypeDesc.methodType(JavaType.VOID, sourceType).toFunctionType())\n@@ -238,2 +238,2 @@\n-            JavaType collectType = (JavaType) supplier.funcDescriptor().returnType();\n-            return func(\"fused.collect\", MethodTypeDesc.methodType(collectType, sourceType))\n+            JavaType collectType = (JavaType) supplier.invokableType().returnType();\n+            return func(\"fused.collect\", MethodTypeDesc.methodType(collectType, sourceType).toFunctionType())\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.VOID;\n@@ -35,0 +34,1 @@\n+import static java.lang.reflect.code.type.FunctionType.VOID;\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}