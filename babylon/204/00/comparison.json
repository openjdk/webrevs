{"files":[{"patch":"@@ -495,1 +495,1 @@\n-    %11 : float = invoke %10 @\"mandel.MandelCompute::scaleUp(float)float\";\n+    %11 : float = invoke %10 @\"mandel.Main::scaleUp(float)float\";\n@@ -525,1 +525,1 @@\n-    %11 : float = invoke %10 @\"mandel.MandelCompute::scaleUp(float)float\";\n+    %11 : float = invoke %10 @\"mandel.Main::scaleUp(float)float\";\n","filename":"hat\/docs\/hat-06-kernel-analysis.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import hat.buffer.S32Array;\n@@ -37,1 +36,1 @@\n-public class BlackScholes {\n+public class Main {\n@@ -117,1 +116,1 @@\n-                cc -> BlackScholes.blackScholes(cc, arr, S, X, T, r, v)  \/\/QuotableComputeContextConsumer\n+                cc -> Main.blackScholes(cc, arr, S, X, T, r, v)  \/\/QuotableComputeContextConsumer\n","filename":"hat\/examples\/blackscholes\/src\/main\/java\/blackscholes\/Main.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"hat\/examples\/blackscholes\/src\/main\/java\/blackscholes\/BlackScholes.java","status":"renamed"},{"patch":"@@ -31,1 +31,1 @@\n-    BoxImpl(int x1, int y1, int x2, int y2) {\n+    public BoxImpl(int x1, int y1, int x2, int y2) {\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/BoxImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    final int[] arrayOfData;\n+    public final int[] arrayOfData;\n@@ -95,1 +95,0 @@\n-            \/\/ there must be a better way!\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/ImageData.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-public class Heal {\n+public class Main {\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Heal.java","status":"renamed"},{"patch":"@@ -50,1 +50,1 @@\n-    final XYList xyList;\n+    public final XYList xyList;\n@@ -71,1 +71,1 @@\n-    int x1(){\n+    public int x1(){\n@@ -74,1 +74,1 @@\n-    int y1(){\n+    public int y1(){\n@@ -77,1 +77,1 @@\n-    int width(){\n+    public int width(){\n@@ -80,1 +80,1 @@\n-    int height(){\n+    public int height(){\n@@ -83,1 +83,1 @@\n-    int x2(){\n+    public int x2(){\n@@ -86,1 +86,1 @@\n-    int y2(){\n+    public int y2(){\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Path.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-class RGBListImpl implements RGBList {\n+public class RGBListImpl implements RGBList {\n@@ -55,1 +55,1 @@\n-    int length;\n+    public int length;\n@@ -136,1 +136,1 @@\n-    RGBListImpl(){\n+    public RGBListImpl(){\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/RGBListImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,70 +116,0 @@\n-    public static Point original(ImageData imageData, RGBList rgbList, Box searchBox, Box selectionBox, XYList selectionXYList) {\n-        float minSoFar = Float.MAX_VALUE;\n-        Point bestSoFar = new Point(0, 0);\n-        for (int y = searchBox.y1(); y < searchBox.y2(); y++) {\n-            for (int x = searchBox.x1(); x < searchBox.x2(); x++) {\n-                if (!isInSelection(selectionBox, x, y)) {\/\/ don't search inside the area we are healing\n-                    float sum = getSum(imageData, selectionBox, selectionXYList, rgbList, x, y);\n-                    if (sum < minSoFar) {\n-                        minSoFar = sum;\n-                        bestSoFar.setLocation(x - selectionBox.x1(), y - selectionBox.y1());\n-                    }\n-                }\n-            }\n-        }\n-        return bestSoFar;\n-    }\n-\n-\n-    public static Point sequential(ImageData imageData, RGBList rgbList, Box searchBox, Box selectionBox, XYList selectionXYList) {\n-        int searchBoxWidth = searchBox.x2() - searchBox.x1();\n-        int searchBoxHeight = searchBox.y2() - searchBox.y1();\n-        int range = searchBoxWidth * searchBoxHeight;\n-        float minSoFar = Float.MAX_VALUE;\n-        int bestId = range+1;\n-        for (int id = 0; id < range; id++) {\n-            int x = searchBox.x1() + id % searchBoxWidth;\n-            int y = searchBox.y1() + id \/ searchBoxWidth;\n-            if (!isInSelection(selectionBox, x, y)) {\/\/ don't search inside the area we are healing\n-                float sum = getSum(imageData, selectionBox, selectionXYList, rgbList, x, y);\n-                if (sum < minSoFar) {\n-                    minSoFar = sum;\n-                    bestId = id;\n-\n-                }\n-            }\n-        }\n-        int x = searchBox.x1() + (bestId % searchBoxWidth);\n-        int y = searchBox.y1() + (bestId \/ searchBoxWidth);\n-        return new Point(x - selectionBox.x1(), y - selectionBox.y1());\n-    }\n-\n-\n-    public static Point parallel(ImageData imageData, RGBList rgbList, Box searchBox, Box selectionBox, XYList selectionXYList) {\n-        int searchBoxWidth = searchBox.x2() - searchBox.x1();\n-        int searchBoxHeight = searchBox.y2() - searchBox.y1();\n-        int range = searchBoxWidth * searchBoxHeight;\n-        float[] sumArray = new float[range];\n-        IntStream.range(0, range).parallel().forEach(id -> {\n-            int x = searchBox.x1() + id % searchBoxWidth;\n-            int y = searchBox.y1() + id \/ searchBoxWidth;\n-            if (isInSelection(selectionBox, x, y)) {\/\/ don't search inside the area we are healing\n-                sumArray[id] = Float.MAX_VALUE;\n-            } else {\n-                sumArray[id] = getSum(imageData, selectionBox, selectionXYList, rgbList, x, y);\n-            }\n-        });\n-        float minSoFar = Float.MAX_VALUE;\n-        int id = sumArray.length + 1;\n-        for (int i = 0; i < sumArray.length; i++) {\n-            float value = sumArray[i];\n-            if (value < minSoFar) {\n-                id = i;\n-                minSoFar = value;\n-            }\n-        }\n-        int x = searchBox.x1() + (id % searchBoxWidth);\n-        int y = searchBox.y1() + (id \/ searchBoxWidth);\n-        return new Point(x - selectionBox.x1(), y - selectionBox.y1());\n-    }\n-\n@@ -233,2 +163,2 @@\n-                                  S32Array2D s32Array2D,  RGBList rgbList,\n-                                    Box searchBox, Box selectionBox, XYList selectionXYList, XY result){\n+             Point offset,\n+                                    S32Array2D s32Array2D,  RGBList rgbList, Box searchBox, Box selectionBox, XYList selectionXYList){\n@@ -239,1 +169,0 @@\n-\n@@ -241,1 +170,0 @@\n-\n@@ -244,1 +172,0 @@\n-\n@@ -248,2 +175,0 @@\n-\n-\n@@ -252,3 +177,1 @@\n-        result.x(x - selectionBox.x1());\n-        result.y(y - selectionBox.y1());\n-        \/\/return new Point(x - selectionBox.x1(), y - selectionBox.y1());\n+        offset.setLocation(x - selectionBox.x1(),y - selectionBox.y1());\n@@ -257,2 +180,2 @@\n-    public static Point getOffsetOfBestMatch(Accelerator accelerator,ImageData imageData, Path selectionPath) {\n-        Point offset = null;\n+    public static Point getOffsetOfBestMatch(Accelerator accelerator, ImageData imageData, Path selectionPath) {\n+        final Point offset  =new Point(0,0);\n@@ -281,1 +204,0 @@\n-            long searchStart = System.currentTimeMillis();\n@@ -283,18 +205,0 @@\n-            boolean useOriginal = true;\n-            boolean useSequential = true;\n-            \/\/ if (useOriginal) {\n-            long originalStart = System.currentTimeMillis();\n-            Box selectionBox = new BoxImpl(selectionPath.x1(), selectionPath.y1(), selectionPath.x2(), selectionPath.y2());\n-            XYList selectionXYList = selectionPath.xyList;\n-            offset = original(imageData, rgbList, searchBox, selectionBox, selectionXYList);\n-            System.out.println(\"original search \" + (System.currentTimeMillis() - originalStart) + \"ms\");\n-            \/\/  } else {\n-            \/\/   if (useSequential) {\n-            long sequentialStart = System.currentTimeMillis();\n-            offset = sequential(imageData, rgbList, searchBox, selectionBox, selectionXYList);\n-            System.out.println(\"sequential search \" + (System.currentTimeMillis() - sequentialStart) + \"ms\");\n-            \/\/    } else {\n-            long parallelStart = System.currentTimeMillis();\n-            offset = parallel(imageData, rgbList, searchBox, selectionBox, selectionXYList);\n-            System.out.println(\"parallel search \" + (System.currentTimeMillis() - parallelStart) + \"ms\");\n-            \/\/ }\n@@ -314,1 +218,1 @@\n-            XY result = XY.create(accelerator,0,0);\n+\n@@ -326,1 +230,2 @@\n-            accelerator.compute(cc->SearchCompute.bestCompute(cc,s32Array2D,mappedRGBList,mappedSearchBox,\n+            accelerator.compute(cc->SearchCompute.bestCompute(cc,offset,\n+                    s32Array2D,mappedRGBList,mappedSearchBox,\n@@ -328,2 +233,1 @@\n-                    mappedSelectionXYList,\n-                    result\n+                    mappedSelectionXYList\n@@ -331,6 +235,1 @@\n-\n-            System.out.println(\"offset \"+offset+ \" result\"+result.x()+\",\"+result.y());\n-            System.out.println(\"hat search \" + (System.currentTimeMillis() - hatStart) + \"ms\");\n-\n-\n-            System.out.println(\"total search \" + (System.currentTimeMillis() - searchStart) + \"ms\");\n+            System.out.println(\"total search \" + (System.currentTimeMillis() - hatStart) + \"ms\");\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/SearchCompute.java","additions":10,"deletions":111,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-package heal;\n+package heal.attic;\n@@ -52,1 +52,0 @@\n-import hat.buffer.S32Array;\n@@ -54,0 +53,7 @@\n+import heal.Box;\n+import heal.BoxImpl;\n+import heal.ImageData;\n+import heal.Path;\n+import heal.RGBList;\n+import heal.RGBListImpl;\n+import heal.XYList;\n@@ -77,1 +83,1 @@\n-public class SearchCompute {\n+public class SearchComputeSafe {\n@@ -133,1 +139,0 @@\n-\n@@ -326,1 +331,1 @@\n-            accelerator.compute(cc->SearchCompute.bestCompute(cc,s32Array2D,mappedRGBList,mappedSearchBox,\n+            accelerator.compute(cc-> SearchComputeSafe.bestCompute(cc,s32Array2D,mappedRGBList,mappedSearchBox,\n@@ -332,0 +337,1 @@\n+\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/attic\/SearchComputeSafe.java","additions":11,"deletions":5,"binary":false,"changes":16,"previous_filename":"hat\/examples\/heal\/src\/main\/java\/heal\/SearchCompute.java","status":"copied"},{"patch":"@@ -25,1 +25,1 @@\n-package heal;\n+package heal.attic;\n@@ -29,1 +29,0 @@\n-import hat.buffer.BufferAllocator;\n@@ -32,2 +31,0 @@\n-import java.lang.invoke.MethodHandles;\n-\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/attic\/XY.java","additions":1,"deletions":4,"binary":false,"changes":5,"previous_filename":"hat\/examples\/heal\/src\/main\/java\/heal\/XY.java","status":"renamed"},{"patch":"@@ -44,1 +44,1 @@\n-public class Life {\n+public class Main {\n@@ -153,1 +153,1 @@\n-                Life.class.getClassLoader().getResourceAsStream(\"orig.rle\")\n+                Main.class.getClassLoader().getResourceAsStream(\"orig.rle\")\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/examples\/life\/src\/main\/java\/life\/Life.java","status":"renamed"},{"patch":"@@ -166,1 +166,1 @@\n-    Viewer(String title, Life.Control control, Life.CellGrid cellGrid) {\n+    Viewer(String title, Main.Control control, Main.CellGrid cellGrid) {\n@@ -200,1 +200,1 @@\n-    public void update(Life.CellGrid cellGrid, int to) {\n+    public void update(Main.CellGrid cellGrid, int to) {\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Viewer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package mandel;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.S32Array;\n+import hat.buffer.S32Array2D;\n+\n+import java.awt.Color;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.runtime.CodeReflection;\n+\n+public class Main {\n+    @CodeReflection\n+    public static void mandel(KernelContext kc, S32Array2D s32Array2D, S32Array pallette, float offsetx, float offsety, float scale) {\n+        if (kc.x < kc.maxX) {\n+            float width = s32Array2D.width();\n+            float height = s32Array2D.height();\n+            float x = ((kc.x % s32Array2D.width()) * scale - (scale \/ 2f * width)) \/ width + offsetx;\n+            float y = ((kc.x \/ s32Array2D.width()) * scale - (scale \/ 2f * height)) \/ height + offsety;\n+            float zx = x;\n+            float zy = y;\n+            float new_zx;\n+            int colorIdx = 0;\n+            while ((colorIdx < pallette.length()) && (((zx * zx) + (zy * zy)) < 4f)) {\n+                new_zx = ((zx * zx) - (zy * zy)) + x;\n+                zy = (2f * zx * zy) + y;\n+                zx = new_zx;\n+                colorIdx++;\n+            }\n+            int color = colorIdx < pallette.length() ? pallette.array(colorIdx) : 0;\n+            s32Array2D.array(kc.x, color);\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    static public void compute(final ComputeContext computeContext, S32Array pallete, S32Array2D s32Array2D, float x, float y, float scale) {\n+\n+        computeContext.dispatchKernel(\n+                s32Array2D.width()*s32Array2D.height(), \/\/0..S32Array2D.size()\n+                kc -> Main.mandel(kc, s32Array2D, pallete, x, y, scale));\n+    }\n+\n+    public static void main(String[] args) {\n+        boolean headless = Boolean.getBoolean(\"headless\") ||( args.length>0 && args[0].equals(\"--headless\"));\n+\n+        final int width = 1024;\n+        final int height = 1024;\n+        final float defaultScale = 3f;\n+        final float originX = -1f;\n+        final float originY = 0;\n+        final int maxIterations = 64;\n+        final int zoomFrames = 200;\n+\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        S32Array2D s32Array2D = S32Array2D.create(accelerator, width, height);\n+\n+        int[] palletteArray = new int[maxIterations];\n+\n+        if (headless){\n+            for (int i = 1; i < maxIterations; i++) {\n+                palletteArray[i]=(i\/8+1);\/\/ 0-7?\n+            }\n+            palletteArray[0]=0;\n+        }else {\n+            for (int i = 0; i < maxIterations; i++) {\n+                final float h = i \/ (float) maxIterations;\n+                final float b = 1.0f - (h * h);\n+                palletteArray[i] = Color.HSBtoRGB(h, 1f, b);\n+            }\n+        }\n+        S32Array pallette = S32Array.createFrom(accelerator, palletteArray);\n+\n+        accelerator.compute(cc -> Main.compute(cc, pallette, s32Array2D, originX, originY, defaultScale));\n+\n+        if (headless){\n+            \/\/ Well take 1 in 4 samples (so 1024 -> 128 grid) of the pallette.\n+            int subsample = 16;\n+            char[] charPallette9 = new char []{' ', '.', ',',':', '-', '+','*', '#', '@', '%'};\n+            for (int y = 0; y<height\/subsample; y++) {\n+                for (int x = 0; x<width\/subsample; x++) {\n+                     int palletteValue = s32Array2D.get(x*subsample,y*subsample); \/\/ so 0->8\n+                     System.out.print(charPallette9[palletteValue]);\n+                }\n+                System.out.println();\n+            }\n+\n+        }else {\n+            Viewer viewer = new Viewer(\"mandel\", s32Array2D);\n+            viewer.imageViewer.syncWithRGB(s32Array2D);\n+\n+            while (viewer.imageViewer.getZoomPoint(defaultScale) instanceof Viewer.PointF32 zoomPoint) {\n+                float x = originX;\n+                float y = originY;\n+                float scale = defaultScale;\n+                final long startMillis = System.currentTimeMillis();\n+\n+                for (int sign : new int[]{-1, 1}) {\n+                    for (int i = 0; i < zoomFrames; i++) {\n+                        scale = scale + ((sign * defaultScale) \/ zoomFrames);\n+                        final float fscale = scale;\n+                        final float fx = x - sign * zoomPoint.x \/ zoomFrames;\n+                        final float fy = y - sign * zoomPoint.y \/ zoomFrames;\n+                        accelerator.compute(cc -> Main.compute(cc, pallette, s32Array2D, fx, fy, fscale));\n+                        viewer.imageViewer.syncWithRGB(s32Array2D);\n+                    }\n+                }\n+                System.out.println(\"FPS = \" + ((zoomFrames * 2 * 1000) \/ (System.currentTimeMillis() - startMillis)));\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/Main.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -1,139 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package mandel;\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.backend.Backend;\n-import hat.buffer.S32Array;\n-import hat.buffer.S32Array2D;\n-\n-import java.awt.Color;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.runtime.CodeReflection;\n-\n-public class MandelCompute {\n-    @CodeReflection\n-    public static void mandel(KernelContext kc, S32Array2D s32Array2D, S32Array pallette, float offsetx, float offsety, float scale) {\n-        if (kc.x < kc.maxX) {\n-            float width = s32Array2D.width();\n-            float height = s32Array2D.height();\n-            float x = ((kc.x % s32Array2D.width()) * scale - (scale \/ 2f * width)) \/ width + offsetx;\n-            float y = ((kc.x \/ s32Array2D.width()) * scale - (scale \/ 2f * height)) \/ height + offsety;\n-            float zx = x;\n-            float zy = y;\n-            float new_zx;\n-            int colorIdx = 0;\n-            while ((colorIdx < pallette.length()) && (((zx * zx) + (zy * zy)) < 4f)) {\n-                new_zx = ((zx * zx) - (zy * zy)) + x;\n-                zy = (2f * zx * zy) + y;\n-                zx = new_zx;\n-                colorIdx++;\n-            }\n-            int color = colorIdx < pallette.length() ? pallette.array(colorIdx) : 0;\n-            s32Array2D.array(kc.x, color);\n-        }\n-    }\n-\n-\n-    @CodeReflection\n-    static public void compute(final ComputeContext computeContext, S32Array pallete, S32Array2D s32Array2D, float x, float y, float scale) {\n-\n-        computeContext.dispatchKernel(\n-                s32Array2D.width()*s32Array2D.height(), \/\/0..S32Array2D.size()\n-                kc -> MandelCompute.mandel(kc, s32Array2D, pallete, x, y, scale));\n-    }\n-\n-    public static void main(String[] args) {\n-        boolean headless = Boolean.getBoolean(\"headless\") ||( args.length>0 && args[0].equals(\"--headless\"));\n-\n-        final int width = 1024;\n-        final int height = 1024;\n-        final float defaultScale = 3f;\n-        final float originX = -1f;\n-        final float originY = 0;\n-        final int maxIterations = 64;\n-        final int zoomFrames = 200;\n-\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-\n-        S32Array2D s32Array2D = S32Array2D.create(accelerator, width, height);\n-\n-        int[] palletteArray = new int[maxIterations];\n-\n-        if (headless){\n-            for (int i = 1; i < maxIterations; i++) {\n-                palletteArray[i]=(i\/8+1);\/\/ 0-7?\n-            }\n-            palletteArray[0]=0;\n-        }else {\n-            for (int i = 0; i < maxIterations; i++) {\n-                final float h = i \/ (float) maxIterations;\n-                final float b = 1.0f - (h * h);\n-                palletteArray[i] = Color.HSBtoRGB(h, 1f, b);\n-            }\n-        }\n-        S32Array pallette = S32Array.createFrom(accelerator, palletteArray);\n-\n-        accelerator.compute(cc -> MandelCompute.compute(cc, pallette, s32Array2D, originX, originY, defaultScale));\n-\n-        if (headless){\n-            \/\/ Well take 1 in 4 samples (so 1024 -> 128 grid) of the pallette.\n-            int subsample = 16;\n-            char[] charPallette9 = new char []{' ', '.', ',',':', '-', '+','*', '#', '@', '%'};\n-            for (int y = 0; y<height\/subsample; y++) {\n-                for (int x = 0; x<width\/subsample; x++) {\n-                     int palletteValue = s32Array2D.get(x*subsample,y*subsample); \/\/ so 0->8\n-                     System.out.print(charPallette9[palletteValue]);\n-                }\n-                System.out.println();\n-            }\n-\n-        }else {\n-            MandelViewer mandelViewer = new MandelViewer(\"mandel\", s32Array2D);\n-            mandelViewer.imageViewer.syncWithRGB(s32Array2D);\n-\n-            while (mandelViewer.imageViewer.getZoomPoint(defaultScale) instanceof MandelViewer.PointF32 zoomPoint) {\n-                float x = originX;\n-                float y = originY;\n-                float scale = defaultScale;\n-                final long startMillis = System.currentTimeMillis();\n-\n-                for (int sign : new int[]{-1, 1}) {\n-                    for (int i = 0; i < zoomFrames; i++) {\n-                        scale = scale + ((sign * defaultScale) \/ zoomFrames);\n-                        final float fscale = scale;\n-                        final float fx = x - sign * zoomPoint.x \/ zoomFrames;\n-                        final float fy = y - sign * zoomPoint.y \/ zoomFrames;\n-                        accelerator.compute(cc -> MandelCompute.compute(cc, pallette, s32Array2D, fx, fy, fscale));\n-                        mandelViewer.imageViewer.syncWithRGB(s32Array2D);\n-                    }\n-                }\n-                System.out.println(\"FPS = \" + ((zoomFrames * 2 * 1000) \/ (System.currentTimeMillis() - startMillis)));\n-            }\n-        }\n-    }\n-}\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/MandelCompute.java","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -46,1 +46,1 @@\n-public class MandelViewer extends JFrame {\n+public class Viewer extends JFrame {\n@@ -123,1 +123,1 @@\n-    public MandelViewer(String title, S32Array2D s32Array2D) {\n+    public Viewer(String title, S32Array2D s32Array2D) {\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/Viewer.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/MandelViewer.java","status":"renamed"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.backend.JavaMultiThreadedBackend;\n@@ -36,1 +35,1 @@\n-public class Squares {\n+public class Main {\n@@ -66,1 +65,1 @@\n-                cc -> Squares.square(cc, arr)  \/\/QuotableComputeContextConsumer\n+                cc -> Main.square(cc, arr)  \/\/QuotableComputeContextConsumer\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Main.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Squares.java","status":"renamed"},{"patch":"@@ -44,1 +44,1 @@\n-public class ViolaJonesCompute {\n+public class Main {\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCompute.java","status":"renamed"},{"patch":"@@ -29,3 +29,5 @@\n-   backend=$1\n-   example=$2\n-   example_class=$3\n+   echo $*\n+   headless=$1\n+   backend=$2\n+   example=$3\n+   shift 3\n@@ -47,2 +49,2 @@\n-            -Dheadless=true \\\n-            ${example}.${example_class}\n+            -Dheadless=${headless} \\\n+            ${example}.Main\n@@ -57,1 +59,16 @@\n-example $*\n+if [ $# -eq 0 ]; then \n+   echo 'usage:'\n+   echo '   bash hatrun.bash [headless] backend package args ...'\n+   echo '       headless : Optional passes -Dheadless=true to app'\n+   echo '       package  : the examples package (and dirname under hat\/examples)'\n+   echo '       backend  : opencl|cuda|spirv|ptx|mock'\n+   echo '       Class name is assumed to be package.Main '\n+else\n+   if [ $1 == headless ]; then \n+      echo headless!\n+      shift 1\n+      example true $*\n+   else\n+      example false $*\n+   fi\n+fi\n","filename":"hat\/hatrun.bash","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"}]}