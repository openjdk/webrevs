{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import optkl.InvokeOpHelper;\n@@ -38,0 +39,1 @@\n+import optkl.util.StreamMutable;\n@@ -42,1 +44,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -44,0 +45,1 @@\n+import static optkl.InvokeOpHelper.invokeOpHelper;\n@@ -45,1 +47,0 @@\n-import static optkl.OpTkl.lower;\n@@ -53,3 +54,3 @@\n-    public static ArrayList<AccessType> getAccessList(MethodHandles.Lookup l, CoreOp.FuncOp f) {\n-        CoreOp.FuncOp inlinedFunc = inlineLoop(l, f);\n-        buildAccessMap(l, inlinedFunc);\n+    public static ArrayList<AccessType> getAccessList(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        CoreOp.FuncOp inlinedFunc = inlineLoop(lookup, funcOp);\n+        buildAccessMap(lookup, inlinedFunc);\n@@ -60,1 +61,1 @@\n-            } else if (isAssignable(l, p.type(), MappableIface.class)) {\n+            } else if (isAssignable(lookup, p.type(), MappableIface.class)) {\n@@ -70,2 +71,1 @@\n-    public static CoreOp.FuncOp inlineLoop(MethodHandles.Lookup l, CoreOp.FuncOp f) {\n-\n+    public static CoreOp.FuncOp inlineLoop(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n@@ -73,2 +73,2 @@\n-        CoreOp.FuncOp ssaFunc =  SSA.transform(lower(here,f)) ;\/\/ OpTkl.SSATransformLower(here, f); \/\/ do we need this nesting?\n-        AtomicBoolean changed = new AtomicBoolean(true);\n+        CoreOp.FuncOp ssaFunc =  SSA.transform( funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER)) ;\n+        var changed  = StreamMutable.of(true);\n@@ -77,19 +77,18 @@\n-\n-            ssaFunc = OpTkl.transform(CallSite.of(BufferTagger.class, \"inlineLoop\"),ssaFunc,(bb, op) -> {\n-                if (op instanceof JavaOp.InvokeOp iop) {\n-                    MethodRef methodRef = iop.invokeDescriptor();\n-                    Method invokeOpCalledMethod;\n-                    try {\n-                        invokeOpCalledMethod = methodRef.resolveToMethod(l);\n-                    } catch (ReflectiveOperationException _) {\n-                        throw new IllegalStateException(\"Could not resolve invokeOp to method\");\n-                    }\n-                    if (invokeOpCalledMethod instanceof Method method) { \/\/ if method isn't a buffer access (is code reflected)\n-                        if (Op.ofMethod(method).isPresent()) {\n-                            CoreOp.FuncOp inline = Op.ofMethod(method).get(); \/\/ method to be inlined\n-                            CoreOp.FuncOp ssaInline =SSA.transform(lower(here,inline));\/\/OpTkl.SSATransformLower(here, inline);\n-                            Block.Builder exit = Inliner.inline(bb, ssaInline, bb.context().getValues(iop.operands()), (_, v) -> {\n-                                if (v != null) bb.context().mapValue(iop.result(), v);\n-                            });\n-                            if (!exit.parameters().isEmpty()) {\n-                                bb.context().mapValue(iop.result(), exit.parameters().getFirst());\n+            ssaFunc = OpTkl.transform(here, ssaFunc,(blockbuilder, op) -> {\n+                if (invokeOpHelper(lookup, op) instanceof InvokeOpHelper invokeOpHelper          \/\/ always but pattern friendly\n+                        && invokeOpHelper.resolvedMethodOrNull() instanceof Method method\n+                        && Op.ofMethod(method) instanceof Optional<CoreOp.FuncOp> optionalFuncOp \/\/ always but pattern friendly\n+                        && optionalFuncOp.isPresent()\n+                        && optionalFuncOp.get() instanceof CoreOp.FuncOp inline                  \/\/ always we just want var in scope\n+                ){\n+                    CoreOp.FuncOp ssaInline =SSA.transform(inline.transform(CodeTransformer.LOWERING_TRANSFORMER));\n+                    Block.Builder exit = Inliner.inline(\n+                            blockbuilder, ssaInline,\n+                            blockbuilder.context().getValues(invokeOpHelper.op().operands()), (_, _value) -> {\n+                                \/\/ intellij doesnt like value as var name so we use _value\n+                            if (_value == null) {\n+                               \/\/   What is special about TestArrayView.Compute.lifePerIdx? it reaches here\n+                                \/\/ I think its because it is void ? no return type.\n+                                    \/\/   throw new IllegalStateException(\"inliner returned  null processing \"+method);\n+                            }else{\n+                                blockbuilder.context().mapValue(invokeOpHelper.op().result(), _value);\n@@ -97,3 +96,3 @@\n-                            changed.set(true);\n-                            return exit.rebind(bb.context(), bb.transformer()); \/\/ return exit in same context as block\n-                        }\n+                    });\n+                    if (!exit.parameters().isEmpty()) {\n+                        blockbuilder.context().mapValue(invokeOpHelper.op().result(), exit.parameters().getFirst());\n@@ -101,0 +100,2 @@\n+                    changed.set(true);\n+                    return exit.rebind(blockbuilder.context(), blockbuilder.transformer());\n@@ -102,2 +103,2 @@\n-                bb.op(op);\n-                return bb;\n+                blockbuilder.op(op);\n+                return blockbuilder;\n@@ -110,1 +111,1 @@\n-    public static void buildAccessMap(MethodHandles.Lookup l, CoreOp.FuncOp f) {\n+    public static void buildAccessMap(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n@@ -112,3 +113,4 @@\n-        var here = CallSite.of(BufferTagger.class, \"buildAccessMap\");\n-        OpTkl.elements(here, f).filter(elem -> elem instanceof Block)\n-                .forEach(b -> blockParams.put((Block) b, ((Block) b).parameters()));\n+        funcOp.elements()\n+                .filter(elem -> elem instanceof Block)\n+                .map(elem->(Block)elem)\n+                .forEach(block -> blockParams.put(block, block.parameters()));\n@@ -116,1 +118,1 @@\n-        f.elements().forEach(op -> {\n+        funcOp.elements().forEach(op -> {\n@@ -118,3 +120,1 @@\n-                case CoreOp.BranchOp b -> {\n-                    mapBranch(l, b.branch());\n-                }\n+                case CoreOp.BranchOp b -> mapBranch(lookup, b.branch());\n@@ -122,2 +122,2 @@\n-                    mapBranch(l, cb.trueBranch()); \/\/ handle true branch\n-                    mapBranch(l, cb.falseBranch()); \/\/ handle false branch\n+                    mapBranch(lookup, cb.trueBranch()); \/\/ handle true branch\n+                    mapBranch(lookup, cb.falseBranch()); \/\/ handle false branch\n@@ -125,8 +125,6 @@\n-                case JavaOp.InvokeOp iop -> { \/\/ (almost) all the buffer accesses happen here\n-                    \/\/ actually now that we have arrayview we'll need to map the corresponding arrays too\n-                    if (isAssignable(l, iop.invokeDescriptor().refType(), MappableIface.class)) {\n-                        updateAccessType(getRootValue(iop), getAccessType(iop)); \/\/ update buffer access\n-                        if (isAssignable(l,  iop.invokeDescriptor().refType(), Buffer.class)\n-                                && iop.result() != null && !(iop.resultType() instanceof PrimitiveType)\n-                                && (isAssignable(l,  iop.resultType(), MappableIface.class)\n-                                    || iop.resultType() instanceof ArrayType)) {\n+                case JavaOp.InvokeOp invokeOp -> {\n+                    var ioh =  invokeOpHelper(lookup,invokeOp);\n+                    \/\/ we have to deal with  array views  too\n+                    if ( ioh.refIs(MappableIface.class)) {\n+                        updateAccessType(getRootValue(invokeOp), ioh.returnsVoid()? AccessType.WO : AccessType.RO); \/\/ update buffer access\n+                        if (ioh.refIs(Buffer.class) && (ioh.returns(MappableIface.class) || ioh.returnsArray())) {\n@@ -134,1 +132,1 @@\n-                            remappedVals.put(iop.result(), getRootValue(iop));\n+                            remappedVals.put(invokeOp.result(), getRootValue(invokeOp));\n@@ -139,1 +137,1 @@\n-                    if (isAssignable(l,  vop.resultType().valueType(), Buffer.class)) {\n+                    if (isAssignable(lookup,  vop.resultType().valueType(), Buffer.class)) {\n@@ -141,0 +139,2 @@\n+                    }else{\n+                        \/\/ or else maybe CoreOp.VarOp vop when ??? ->\n@@ -144,1 +144,1 @@\n-                    if (isAssignable(l,  flop.fieldDescriptor().refType(), KernelContext.class)) {\n+                    if (isAssignable(lookup,  flop.fieldDescriptor().refType(), KernelContext.class)) {\n@@ -146,0 +146,2 @@\n+                    }else{\n+                        \/\/ or else\n@@ -148,6 +150,2 @@\n-                case JavaOp.ArrayAccessOp.ArrayLoadOp alop -> {\n-                    updateAccessType(getRootValue(alop), AccessType.RO);\n-                }\n-                case JavaOp.ArrayAccessOp.ArrayStoreOp asop -> {\n-                    updateAccessType(getRootValue(asop), AccessType.WO);\n-                }\n+                case JavaOp.ArrayAccessOp.ArrayLoadOp alop -> updateAccessType(getRootValue(alop), AccessType.RO);\n+                case JavaOp.ArrayAccessOp.ArrayStoreOp asop -> updateAccessType(getRootValue(asop), AccessType.WO);\n@@ -160,2 +158,2 @@\n-    public static void mapBranch(MethodHandles.Lookup l, Block.Reference b) {\n-        List<Value> args = b.arguments();\n+    public static void mapBranch(MethodHandles.Lookup lookup, Block.Reference blockReference) {\n+        List<Value> args = blockReference.arguments();\n@@ -163,9 +161,8 @@\n-            Value key = blockParams.get(b.targetBlock()).get(i);\n-            Value val = args.get(i);\n-\n-            if (val instanceof Op.Result) {\n-                \/\/ either find root param or it doesnt exist (is a constant for example)\n-                if (isAssignable(l, val.type(), MappableIface.class)) {\n-                    val = getRootValue(((Op.Result) val).op());\n-                    if (val instanceof Block.Parameter) {\n-                        val = remappedVals.getOrDefault(val, val);\n+            Value key = blockParams.get(blockReference.targetBlock()).get(i);\n+            Value value = args.get(i);\n+            if (value instanceof Op.Result result) {\n+                \/\/ either find root param or it doesn't exist (is a constant for example)\n+                if (isAssignable(lookup, value.type(), MappableIface.class)) {\n+                    value = getRootValue(result.op());\n+                    if (value instanceof Block.Parameter) {\n+                        value = remappedVals.getOrDefault(value, value);\n@@ -173,0 +170,2 @@\n+                }else{\n+                    \/\/ or else\n@@ -174,0 +173,2 @@\n+            }else{\n+               \/\/ or else?\n@@ -175,1 +176,1 @@\n-            remappedVals.put(key, val);\n+            remappedVals.put(key, value);\n@@ -186,2 +187,3 @@\n-        while (op.operands().getFirst() instanceof Op.Result r) {\n-            op = r.op();\n+\n+        while (op.operands().getFirst() instanceof Op.Result result) { \/\/ Only first?\n+            op = result.op(); \/\/ we are changing our  par here I assume intended\n@@ -190,0 +192,2 @@\n+            }else{\n+                \/\/ or else\n@@ -195,5 +199,0 @@\n-    \/\/ retrieves accessType based on return value of InvokeOp\n-    public static AccessType getAccessType(JavaOp.InvokeOp iop) {\n-        return iop.invokeDescriptor().type().returnType().equals(JavaType.VOID) ? AccessType.WO : AccessType.RO;\n-    }\n-\n@@ -201,3 +200,3 @@\n-    public static void updateAccessType(Value val, AccessType curAccess) {\n-        Value remappedVal = remappedVals.getOrDefault(val, val);\n-        AccessType storedAccess = accessMap.get(remappedVal);\n+    public static void updateAccessType(Value value, AccessType currentAccess) {\n+        Value remappedValue = remappedVals.getOrDefault(value, value);\n+        AccessType storedAccess = accessMap.get(remappedValue);\n@@ -205,3 +204,5 @@\n-            accessMap.put(remappedVal, curAccess);\n-        } else if (curAccess != storedAccess && storedAccess != AccessType.RW) {\n-            accessMap.put(remappedVal, AccessType.RW);\n+            accessMap.put(remappedValue, currentAccess);\n+        } else if (currentAccess != storedAccess && storedAccess != AccessType.RW) {\n+            accessMap.put(remappedValue, AccessType.RW);\n+        } else {\n+            \/\/ or else\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":87,"deletions":86,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.ArrayType;\n@@ -32,1 +33,0 @@\n-import optkl.util.Regex;\n@@ -36,0 +36,1 @@\n+import java.lang.reflect.Method;\n@@ -60,0 +61,9 @@\n+    public Method resolvedMethodOrNull(){\n+        try {\n+            return op.invokeDescriptor().resolveToMethod(lookup) instanceof Method method ? method : null;\n+        }catch (ReflectiveOperationException rope){\n+            return null;\n+        }\n+    }\n+\n+\n@@ -63,0 +73,12 @@\n+\n+    public boolean refIs(Class<?> clazz) {\n+        return OpTkl.isAssignable(lookup, op.invokeDescriptor().refType(), clazz);\n+    }\n+\n+    public boolean returnsArray() {\n+        return op.resultType() instanceof ArrayType;\n+    }\n+\n+    public boolean returnsVoid() {\n+        return op.invokeDescriptor().type().returnType().equals(JavaType.VOID);\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/InvokeOpHelper.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"}]}