{"files":[{"patch":"@@ -62,0 +62,1 @@\n+import java.lang.invoke.StringConcatFactory;\n@@ -65,1 +66,0 @@\n-import java.lang.reflect.code.type.ClassType;\n@@ -84,0 +84,5 @@\n+    private static final DirectMethodHandleDesc DMHD_STRING_CONCAT = ofCallsiteBootstrap(\n+            StringConcatFactory.class.describeConstable().orElseThrow(),\n+            \"makeConcat\",\n+            CD_CallSite);\n+\n@@ -269,2 +274,11 @@\n-            var c = (Constable)constantOp.value();\n-            cob.loadConstant(c == null ? ConstantDescs.NULL : c.describeConstable().orElseThrow());\n+            cob.loadConstant(switch (constantOp.value()) {\n+                case null -> null;\n+                case Boolean b -> {\n+                    yield b ? 1 : 0;\n+                }\n+                case Byte b -> (int)b;\n+                case Character ch -> (int)ch;\n+                case Short s -> (int)s;\n+                case Constable c -> c.describeConstable().orElseThrow();\n+                default -> throw new IllegalArgumentException(\"Unexpected constant value: \" + constantOp.value());\n+            });\n@@ -858,0 +872,5 @@\n+                    case ConcatOp op -> {\n+                        processOperands(op);\n+                        cob.invokedynamic(DynamicCallSiteDesc.of(DMHD_STRING_CONCAT, MethodTypeDesc.of(CD_String, CD_String, CD_String)));\n+                        push(op.result());\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+import java.lang.constant.ConstantDesc;\n+import static java.lang.constant.ConstantDescs.CD_void;\n@@ -67,0 +69,2 @@\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n@@ -78,0 +82,5 @@\n+    private static final JavaType MHS_LOOKUP = JavaType.type(ConstantDescs.CD_MethodHandles_Lookup);\n+    private static final JavaType MH = JavaType.type(ConstantDescs.CD_MethodHandle);\n+    private static final JavaType MT = JavaType.type(ConstantDescs.CD_MethodType);\n+    private static final JavaType ARRAYLIST = JavaType.type(ArrayList.class.describeConstable().get());\n+    private static final FunctionType ARRAYLIST_INIT = FunctionType.functionType(ARRAYLIST);\n@@ -81,0 +90,12 @@\n+    private static final MethodRef LOOKUP = MethodRef.method(JavaType.type(ConstantDescs.CD_MethodHandles), \"lookup\", MHS_LOOKUP);\n+    private static final MethodRef ARRAYLIST_ADD = MethodRef.method(ARRAYLIST, \"add\", JavaType.BOOLEAN, JavaType.J_L_OBJECT);\n+    private static final MethodRef FIND_STATIC = MethodRef.method(MHS_LOOKUP, \"findStatic\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, MT);\n+    private static final MethodRef FIND_VIRTUAL = MethodRef.method(MHS_LOOKUP, \"findVirtual\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, MT);\n+    private static final MethodRef FIND_CONSTRUCTOR = MethodRef.method(MHS_LOOKUP, \"findConstructor\", MH, JavaType.J_L_CLASS, MT);\n+    private static final MethodRef FIND_GETTER = MethodRef.method(MHS_LOOKUP, \"findGetter\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, JavaType.J_L_CLASS);\n+    private static final MethodRef FIND_STATIC_GETTER = MethodRef.method(MHS_LOOKUP, \"findStaticGetter\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, JavaType.J_L_CLASS);\n+    private static final MethodRef FIND_SETTER = MethodRef.method(MHS_LOOKUP, \"findSetter\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, JavaType.J_L_CLASS);\n+    private static final MethodRef FIND_STATIC_SETTER = MethodRef.method(MHS_LOOKUP, \"findStaticSetter\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, JavaType.J_L_CLASS);\n+    private static final MethodRef METHOD_TYPE_0 = MethodRef.method(MT, \"methodType\", MT, JavaType.J_L_CLASS);\n+    private static final MethodRef METHOD_TYPE_1 = MethodRef.method(MT, \"methodType\", MT, JavaType.J_L_CLASS, JavaType.J_L_CLASS);\n+    private static final MethodRef METHOD_TYPE_L = MethodRef.method(MT, \"methodType\", MT, JavaType.J_L_CLASS, JavaType.J_U_LIST);\n@@ -89,0 +110,1 @@\n+    private final Map<Object, Op.Result> constantCache;\n@@ -91,17 +113,0 @@\n-    private static TypeElement toTypeElement(StackMapFrameInfo.VerificationTypeInfo vti) {\n-        return switch (vti) {\n-            case ITEM_INTEGER -> JavaType.INT;\n-            case ITEM_FLOAT -> JavaType.FLOAT;\n-            case ITEM_DOUBLE -> JavaType.DOUBLE;\n-            case ITEM_LONG -> JavaType.LONG;\n-            case ITEM_NULL -> JavaType.J_L_OBJECT;\n-            case StackMapFrameInfo.ObjectVerificationTypeInfo ovti ->\n-                    JavaType.type(ovti.classSymbol());\n-            case StackMapFrameInfo.UninitializedVerificationTypeInfo _ ->\n-                    JavaType.J_L_OBJECT;\n-            default ->\n-                throw new IllegalArgumentException(\"Unexpected VTI: \" + vti);\n-\n-        };\n-    }\n-\n@@ -119,1 +124,14 @@\n-                        smfi -> entryBlock.block(smfi.stack().stream().map(BytecodeLift::toTypeElement).toList())))).orElse(Map.of());\n+                        smfi -> entryBlock.block(smfi.stack().stream().map(vti -> (TypeElement)switch (vti) {\n+                            case ITEM_INTEGER -> JavaType.INT;\n+                            case ITEM_FLOAT -> JavaType.FLOAT;\n+                            case ITEM_DOUBLE -> JavaType.DOUBLE;\n+                            case ITEM_LONG -> JavaType.LONG;\n+                            case ITEM_NULL -> JavaType.J_L_OBJECT;\n+                            case ITEM_UNINITIALIZED_THIS -> JavaType.type(classModel.thisClass().asSymbol());\n+                            case StackMapFrameInfo.ObjectVerificationTypeInfo ovti ->\n+                                    JavaType.type(ovti.classSymbol());\n+                            case StackMapFrameInfo.UninitializedVerificationTypeInfo _ ->\n+                                    JavaType.J_L_OBJECT;\n+                            default ->\n+                                throw new IllegalArgumentException(\"Unexpected VTI: \" + vti);\n+                        }).toList())))).orElse(Map.of());\n@@ -129,0 +147,1 @@\n+        this.constantCache = new HashMap<>();\n@@ -150,8 +169,2 @@\n-        try {\n-            return SlotSSA.transform(lifted);\n-        } catch (Exception e) {\n-            System.out.println(\"lifted:\");\n-            lifted.writeTo(System.out);\n-            throw new IllegalStateException(\"SlotSSA transformation failed\");\n-        }\n-    }\n+        return SlotSSA.transform(lifted);\n+     }\n@@ -191,0 +204,1 @@\n+        constantCache.clear();\n@@ -200,0 +214,1 @@\n+        constantCache.clear();\n@@ -259,2 +274,2 @@\n-                        case IFNULL -> CoreOp.neq(operand, op(CoreOp.constant(JavaType.J_L_OBJECT, null)));\n-                        case IFNONNULL -> CoreOp.eq(operand, op(CoreOp.constant(JavaType.J_L_OBJECT, null)));\n+                        case IFNULL -> CoreOp.neq(operand, liftConstant(null));\n+                        case IFNONNULL -> CoreOp.eq(operand, liftConstant(null));\n@@ -304,1 +319,1 @@\n-                            op(CoreOp.constant(JavaType.INT, inst.constant()))))));\n+                            liftConstant(inst.constant())))));\n@@ -307,14 +322,1 @@\n-                    stack.push(op(switch (inst.constantValue()) {\n-                        case ClassDesc v -> CoreOp.constant(JavaType.J_L_CLASS, JavaType.type(v));\n-                        case Double v -> CoreOp.constant(JavaType.DOUBLE, v);\n-                        case Float v -> CoreOp.constant(JavaType.FLOAT, v);\n-                        case Integer v -> CoreOp.constant(JavaType.INT, v);\n-                        case Long v -> CoreOp.constant(JavaType.LONG, v);\n-                        case String v -> CoreOp.constant(JavaType.J_L_STRING, v);\n-                        case DynamicConstantDesc<?> v when v.bootstrapMethod().owner().equals(ConstantDescs.CD_ConstantBootstraps)\n-                                                     && v.bootstrapMethod().methodName().equals(\"nullConstant\")\n-                                -> CoreOp.constant(JavaType.J_L_OBJECT, null);\n-                        default ->\n-                            \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n-                            throw new IllegalArgumentException(\"Unsupported constant value: \" + inst.constantValue());\n-                    }));\n+                    stack.push(liftConstant(inst.constantValue()));\n@@ -388,1 +390,1 @@\n-                                stack.push(op(CoreOp.fieldStore(fd, stack.pop(), value)));\n+                                op(CoreOp.fieldStore(fd, stack.pop(), value));\n@@ -391,1 +393,1 @@\n-                                stack.push(op(CoreOp.fieldStore(fd, stack.pop())));\n+                                op(CoreOp.fieldStore(fd, stack.pop()));\n@@ -441,10 +443,8 @@\n-                case InvokeDynamicInstruction inst when inst.bootstrapMethod().kind() == DirectMethodHandleDesc.Kind.STATIC\n-                                                     && inst.bootstrapMethod().owner().equals(CD_LambdaMetafactory)\n-                                                     && inst.bootstrapArgs().get(0) instanceof MethodTypeDesc mtd\n-                                                     && inst.bootstrapArgs().get(1) instanceof DirectMethodHandleDesc dmhd -> {\n-                    LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n-                            FunctionType.functionType(JavaType.type(mtd.returnType()), mtd.parameterList().stream().map(JavaType::type).toList()),\n-                            JavaType.type(inst.typeSymbol().returnType()));\n-                    if (dmhd.owner().equals(classModel.thisClass().asSymbol())) {\n-                        \/\/ inline lambda impl method\n-                        MethodModel implMethod = classModel.methods().stream().filter(m -> m.methodName().equalsString(dmhd.methodName())).findFirst().orElseThrow();\n+                case InvokeDynamicInstruction inst when inst.bootstrapMethod().kind() == DirectMethodHandleDesc.Kind.STATIC -> {\n+                    if (inst.bootstrapMethod().owner().equals(CD_LambdaMetafactory)\n+                        && inst.bootstrapArgs().get(0) instanceof MethodTypeDesc mtd\n+                        && inst.bootstrapArgs().get(1) instanceof DirectMethodHandleDesc dmhd) {\n+\n+                        LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n+                                FunctionType.functionType(JavaType.type(mtd.returnType()), mtd.parameterList().stream().map(JavaType::type).toList()),\n+                                JavaType.type(inst.typeSymbol().returnType()));\n@@ -458,5 +458,24 @@\n-                        stack.push(op(lambda.body(\n-                                eb -> new BytecodeLift(eb,\n-                                                       classModel,\n-                                                       implMethod.code().orElseThrow(),\n-                                                       capturedValues).liftBody())));\n+                        if (dmhd.methodName().startsWith(\"lambda$\") && dmhd.owner().equals(classModel.thisClass().asSymbol())) {\n+                            \/\/ inline lambda impl method\n+                            MethodModel implMethod = classModel.methods().stream().filter(m -> m.methodName().equalsString(dmhd.methodName())).findFirst().orElseThrow();\n+                            stack.push(op(lambda.body(\n+                                    eb -> new BytecodeLift(eb,\n+                                                           classModel,\n+                                                           implMethod.code().orElseThrow(),\n+                                                           capturedValues).liftBody())));\n+                        } else {\n+                            \/\/ lambda call to a MH\n+                            stack.push(op(lambda.body(eb -> {\n+                                MethodTypeDesc mt = dmhd.invocationType();\n+                                if (capturedValues.length > 0) {\n+                                    mt = mt.dropParameterTypes(0, capturedValues.length);\n+                                }\n+                                eb.op(CoreOp._return(eb.op(CoreOp.invoke(\n+                                        MethodRef.method(\n+                                                JavaType.type(dmhd.owner()),\n+                                                dmhd.methodName(),\n+                                                JavaType.type(mt.returnType()),\n+                                                mt.parameterList().stream().map(JavaType::type).toList()),\n+                                        Stream.concat(Arrays.stream(capturedValues), eb.parameters().stream()).toArray(Value[]::new)))));\n+                            })));\n+                        }\n@@ -464,11 +483,32 @@\n-                        \/\/ lambda call to a MH\n-                        stack.push(op(lambda.body(eb -> {\n-                            MethodTypeDesc mt = dmhd.invocationType();\n-                            eb.op(CoreOp._return(eb.op(CoreOp.invoke(\n-                                    MethodRef.method(\n-                                            JavaType.type(dmhd.owner()),\n-                                            dmhd.methodName(),\n-                                            JavaType.type(mt.returnType()),\n-                                            mt.parameterList().stream().map(JavaType::type).toList()),\n-                                    eb.parameters().stream().toArray(Value[]::new)))));\n-                        })));\n+                        MethodTypeDesc mtd = inst.typeSymbol();\n+\n+                        \/\/bootstrap\n+                        List<Value> bootstrapArgs = new ArrayList<>();\n+                        bootstrapArgs.add(lookup());\n+                        bootstrapArgs.add(liftConstant(inst.name().toString()));\n+                        bootstrapArgs.add(liftConstant(mtd));\n+                        for (ConstantDesc barg : inst.bootstrapArgs()) {\n+                            bootstrapArgs.add(liftConstant(barg));\n+                        }\n+                        DirectMethodHandleDesc bsm = inst.bootstrapMethod();\n+                        MethodTypeDesc bsmDesc = bsm.invocationType();\n+                        MethodRef bsmRef = MethodRef.method(JavaType.type(bsm.owner()),\n+                                                            bsm.methodName(),\n+                                                            JavaType.type(bsmDesc.returnType()),\n+                                                            bsmDesc.parameterList().stream().map(JavaType::type).toArray(TypeElement[]::new));\n+                        Value methodHandle = op(CoreOp.invoke(MethodRef.method(CallSite.class, \"dynamicInvoker\", MethodHandle.class),\n+                                                    op(CoreOp.invoke(JavaType.type(ConstantDescs.CD_CallSite), bsmRef, bootstrapArgs))));\n+\n+                        \/\/invocation\n+                        List<Value> operands = new ArrayList<>();\n+                        for (int c = 0; c < mtd.parameterCount(); c++) {\n+                            operands.add(stack.pop());\n+                        }\n+                        operands.add(methodHandle);\n+                        MethodRef mDesc = MethodRef.method(JavaType.type(ConstantDescs.CD_MethodHandle),\n+                                                           \"invokeExact\",\n+                                                           MethodRef.ofNominalDescriptor(mtd));\n+                        Op.Result result = op(CoreOp.invoke(mDesc, operands.reversed()));\n+                        if (!result.type().equals(JavaType.VOID)) {\n+                            stack.push(result);\n+                        }\n@@ -615,0 +655,4 @@\n+                case MonitorInstruction _ -> {\n+                    stack.pop(); \/\/ @@@ lift monitorenter and monitorexit ?\n+                }\n+                case NopInstruction _ -> {}\n@@ -624,0 +668,78 @@\n+    private Op.Result lookup() {\n+        return constantCache.computeIfAbsent(LOOKUP, _ -> op(CoreOp.invoke(LOOKUP)));\n+    }\n+\n+    private Op.Result liftConstant(Object c) {\n+        Op.Result res = constantCache.get(c);\n+        if (res == null) {\n+            res = switch (c) {\n+                case null -> op(CoreOp.constant(JavaType.J_L_OBJECT, null));\n+                case ClassDesc cd -> op(CoreOp.constant(JavaType.J_L_CLASS, JavaType.type(cd)));\n+                case Double d -> op(CoreOp.constant(JavaType.DOUBLE, d));\n+                case Float f -> op(CoreOp.constant(JavaType.FLOAT, f));\n+                case Integer ii -> op(CoreOp.constant(JavaType.INT, ii));\n+                case Long l -> op(CoreOp.constant(JavaType.LONG, l));\n+                case String s -> op(CoreOp.constant(JavaType.J_L_STRING, s));\n+                case DirectMethodHandleDesc dmh -> {\n+                    Op.Result lookup = lookup();\n+                    Op.Result owner = liftConstant(dmh.owner());\n+                    Op.Result name = liftConstant(dmh.methodName());\n+                    MethodTypeDesc invDesc = dmh.invocationType();\n+                    yield op(switch (dmh.kind()) {\n+                        case STATIC, INTERFACE_STATIC  ->\n+                            CoreOp.invoke(FIND_STATIC, lookup, owner, name, liftConstant(invDesc));\n+                        case VIRTUAL, INTERFACE_VIRTUAL ->\n+                            CoreOp.invoke(FIND_VIRTUAL, lookup, owner, name, liftConstant(invDesc.dropParameterTypes(0, 1)));\n+                        case SPECIAL, INTERFACE_SPECIAL ->\n+                            \/\/CoreOp.invoke(MethodRef.method(e), \"findSpecial\", owner, name, liftConstant(invDesc.dropParameterTypes(0, 1)), lookup.lookupClass());\n+                            throw new UnsupportedOperationException(dmh.toString());\n+                        case CONSTRUCTOR       ->\n+                            CoreOp.invoke(FIND_CONSTRUCTOR, lookup, owner, liftConstant(invDesc.changeReturnType(CD_void)));\n+                        case GETTER            ->\n+                            CoreOp.invoke(FIND_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n+                        case STATIC_GETTER     ->\n+                            CoreOp.invoke(FIND_STATIC_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n+                        case SETTER            ->\n+                            CoreOp.invoke(FIND_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(1)));\n+                        case STATIC_SETTER     ->\n+                            CoreOp.invoke(FIND_STATIC_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(0)));\n+                    });\n+                }\n+                case MethodTypeDesc mt -> op(switch (mt.parameterCount()) {\n+                    case 0 -> CoreOp.invoke(METHOD_TYPE_0, liftConstant(mt.returnType()));\n+                    case 1 -> CoreOp.invoke(METHOD_TYPE_1, liftConstant(mt.returnType()), liftConstant(mt.parameterType(0)));\n+                    default -> {\n+                        Op.Result list = op(CoreOp._new(ARRAYLIST_INIT));\n+                        for (ClassDesc p : mt.parameterList()) {\n+                            op(CoreOp.invoke(ARRAYLIST_ADD, list, liftConstant(p)));\n+                        }\n+                        yield CoreOp.invoke(METHOD_TYPE_L, liftConstant(mt.returnType()), list);\n+                    }\n+                });\n+                case DynamicConstantDesc<?> v when v.bootstrapMethod().owner().equals(ConstantDescs.CD_ConstantBootstraps)\n+                                             && v.bootstrapMethod().methodName().equals(\"nullConstant\")\n+                        -> liftConstant(null);\n+                case DynamicConstantDesc<?> dcd -> {\n+                    List<Value> bootstrapArgs = new ArrayList<>();\n+                    bootstrapArgs.add(lookup());\n+                    bootstrapArgs.add(liftConstant(dcd.constantName()));\n+                    bootstrapArgs.add(liftConstant(dcd.constantType()));\n+                    for (ConstantDesc barg : dcd.bootstrapArgs()) {\n+                        bootstrapArgs.add(liftConstant(barg));\n+                    }\n+                    DirectMethodHandleDesc bsm = dcd.bootstrapMethod();\n+                    MethodTypeDesc bsmDesc = bsm.invocationType();\n+                    MethodRef bsmRef = MethodRef.method(JavaType.type(bsm.owner()),\n+                                                        bsm.methodName(),\n+                                                        JavaType.type(bsmDesc.returnType()),\n+                                                        bsmDesc.parameterList().stream().map(JavaType::type).toArray(TypeElement[]::new));\n+                    yield op(CoreOp.invoke(bsmRef, bootstrapArgs));\n+                }\n+                case Boolean b -> op(CoreOp.constant(JavaType.BOOLEAN, b));\n+                default -> throw new UnsupportedOperationException(c.getClass().toString());\n+            };\n+            constantCache.put(c, res);\n+        }\n+        return res;\n+    }\n+\n@@ -630,1 +752,1 @@\n-                    op(CoreOp.eq(v, op(CoreOp.constant(JavaType.INT, sc.caseValue())))),\n+                    op(CoreOp.eq(v, liftConstant(sc.caseValue()))),\n@@ -655,1 +777,1 @@\n-        return op(CoreOp.constant(vt, vt.equals(PrimitiveType.BOOLEAN) ? false : 0));\n+        return vt.equals(PrimitiveType.BOOLEAN) ? liftConstant(false) : liftConstant(0);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":195,"deletions":73,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -85,2 +85,2 @@\n-            if (opdef.operands().size() != 1) {\n-                throw new IllegalArgumentException(\"Operation must have one operand\");\n+            if (!opdef.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must not have any operands\");\n@@ -120,2 +120,2 @@\n-            if (opdef.operands().size() != 2) {\n-                throw new IllegalArgumentException(\"Operation must have two operands\");\n+            if (opdef.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.reflect.code.op.CoreOp;\n@@ -79,1 +80,6 @@\n-                    cc.mapValue(op.result(), v);\n+                    if (vl.resultType().equals(v.type())) {\n+                        cc.mapValue(op.result(), v);\n+                    } else {\n+                        \/\/ @@@ Explicit cast to return type, mainly due to cast of aconst_null (j.l.Object) to a target array type\n+                        cc.mapValue(op.result(), block.op(CoreOp.cast(vl.resultType(), v)));\n+                    }\n@@ -174,1 +180,3 @@\n-                    variableStack.get(slot).push(new SlotBlockArgument(n.b(), slot));\n+                    \/\/ Regular variable is always declared in a dominant block, so it can be asserted in the variable SSA trasform.\n+                    \/\/ However slot is never declared, so it cannot be asserted in the SlotSSA transform.\n+                    variableStack.computeIfAbsent(slot, _ -> new ArrayDeque<>()).push(new SlotBlockArgument(n.b(), slot));\n@@ -186,0 +194,1 @@\n+                    \/\/ The slot is always stored without any prior declaration\n@@ -295,6 +304,9 @@\n-        LinkedHashMap<Integer, SlotAccesses> slotMap = r.traverse(new LinkedHashMap<>(), CodeElement.opVisitor((slots, op) -> {\n-            if (op instanceof SlotOp.SlotStoreOp storeOp) {\n-                slots.computeIfAbsent(storeOp.slot(), _ -> new SlotAccesses()).stores.add(storeOp.parentBlock());\n-            } else if (op instanceof SlotOp.SlotLoadOp loadOp) {\n-                var sa = slots.computeIfAbsent(loadOp.slot(), _ -> new SlotAccesses());\n-                if (!sa.stores.contains(loadOp.parentBlock())) sa.loadsBeforeStores.add(loadOp.parentBlock());\n+        LinkedHashMap<Integer, SlotAccesses> slotMap = new LinkedHashMap<>();\n+        for (Block b : r.blocks()) {\n+            for (Op op : b.ops()) {\n+                if (op instanceof SlotOp.SlotStoreOp storeOp) {\n+                    slotMap.computeIfAbsent(storeOp.slot(), _ -> new SlotAccesses()).stores.add(storeOp.parentBlock());\n+                } else if (op instanceof SlotOp.SlotLoadOp loadOp) {\n+                    var sa = slotMap.computeIfAbsent(loadOp.slot(), _ -> new SlotAccesses());\n+                    if (!sa.stores.contains(loadOp.parentBlock())) sa.loadsBeforeStores.add(loadOp.parentBlock());\n+                }\n@@ -302,2 +314,1 @@\n-            return slots;\n-        }));\n+        }\n@@ -350,1 +361,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotSSA.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -466,0 +466,13 @@\n+    @CodeReflection\n+    static String stringConcat(String a, String b) {\n+        return a + b;\n+    }\n+\n+    @CodeReflection\n+    static int ifTrue(int i) {\n+        if (true) {\n+            return i;\n+        }\n+        return -i;\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.constant.DynamicConstantDesc;\n@@ -32,0 +33,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -68,0 +70,38 @@\n+    public record TestRecord(int i, String s) {\n+    }\n+\n+    @Test\n+    public void testObjectMethodsIndy() throws Throwable {\n+        byte[] testRecord = TestRecord.class.getResourceAsStream(\"TestLiftCustomBytecode$TestRecord.class\").readAllBytes();\n+        CoreOp.FuncOp toString = getFuncOp(testRecord, \"toString\");\n+        CoreOp.FuncOp hashCode = getFuncOp(testRecord, \"hashCode\");\n+        CoreOp.FuncOp equals = getFuncOp(testRecord, \"equals\");\n+\n+        TestRecord tr1 = new TestRecord(1, \"hi\"), tr2 = new TestRecord(2, \"bye\"), tr3 = new TestRecord(1, \"hi\");\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Assert.assertEquals((String)Interpreter.invoke(lookup, toString, tr1), tr1.toString());\n+        Assert.assertEquals((String)Interpreter.invoke(lookup, toString, tr2), tr2.toString());\n+        Assert.assertEquals((int)Interpreter.invoke(lookup, hashCode, tr1), tr1.hashCode());\n+        Assert.assertEquals((int)Interpreter.invoke(lookup, hashCode, tr2), tr2.hashCode());\n+        Assert.assertTrue((boolean)Interpreter.invoke(lookup, equals, tr1, tr1));\n+        Assert.assertFalse((boolean)Interpreter.invoke(lookup, equals, tr1, tr2));\n+        Assert.assertTrue((boolean)Interpreter.invoke(lookup, equals, tr1, tr3));\n+        Assert.assertFalse((boolean)Interpreter.invoke(lookup, equals, tr1, \"hello\"));\n+    }\n+\n+    @Test\n+    public void testConstantBootstrapsCondy() throws Throwable {\n+        byte[] testCondy = ClassFile.of().build(ClassDesc.of(\"TestCondy\"), clb ->\n+                clb.withMethodBody(\"condyMethod\", MethodTypeDesc.of(ConstantDescs.CD_Class), ClassFile.ACC_STATIC, cob ->\n+                        cob.ldc(DynamicConstantDesc.ofNamed(\n+                                ConstantDescs.ofConstantBootstrap(ConstantDescs.CD_ConstantBootstraps, \"primitiveClass\", ConstantDescs.CD_Class),\n+                                int.class.descriptorString(),\n+                                ConstantDescs.CD_Class))\n+                           .areturn()));\n+\n+        CoreOp.FuncOp primitiveInteger = getFuncOp(testCondy, \"condyMethod\");\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Assert.assertEquals((Class)Interpreter.invoke(lookup, primitiveInteger), int.class);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        Assert.assertTrue(passed > 24000, String.format(\"\"\"\n+        Assert.assertTrue(passed > 29000, String.format(\"\"\"\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}